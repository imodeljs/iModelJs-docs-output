(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("bentleyjs_core"));
	else if(typeof define === 'function' && define.amd)
		define("geometry_core", ["bentleyjs_core"], factory);
	else if(typeof exports === 'object')
		exports["geometry_core"] = factory(require("bentleyjs_core"));
	else
		root["geometry_core"] = factory(root["bentleyjs_core"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__) {
return (this["webpackJsonp"] = this["webpackJsonp"] || []).push([["geometry-core"],{

/***/ "./lib/Constant.js":
/*!*************************!*\
  !*** ./lib/Constant.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
/** Commonly used constant values.
 * @alpha
 */
class Constant {
}
exports.Constant = Constant;
/** symbolic name for 1 millimeter:  0.001 meter */
Constant.oneMillimeter = 0.001;
/** symbolic name for 1 centimeter:  0.01 meter */
Constant.oneCentimeter = 0.01;
/** symbolic name for 1 meter:  1.0 meter */
Constant.oneMeter = 1.0;
/** symbolic name for 1 kilometer: 1000 meter */
Constant.oneKilometer = 1000.0;
/** Diameter of the earth in kilometers. */
Constant.diameterOfEarth = 12742.0 * Constant.oneKilometer;
/** circumference of the earth in meters. */
Constant.circumferenceOfEarth = 40075.0 * Constant.oneKilometer;


/***/ }),

/***/ "./lib/Geometry.js":
/*!*************************!*\
  !*** ./lib/Geometry.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty*/
const Point2dVector2d_1 = __webpack_require__(/*! ./geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
/** Enumeration of the 6 possible orderings of XYZ axis order
 * @public
 */
var AxisOrder;
(function (AxisOrder) {
    /** Right handed system, X then Y then Z */
    AxisOrder[AxisOrder["XYZ"] = 0] = "XYZ";
    /** Right handed system, Y then Z then X */
    AxisOrder[AxisOrder["YZX"] = 1] = "YZX";
    /** Right handed system, Z then X then Y */
    AxisOrder[AxisOrder["ZXY"] = 2] = "ZXY";
    /** Left handed system, X then Z then Y */
    AxisOrder[AxisOrder["XZY"] = 4] = "XZY";
    /** Left handed system, Y then X then Z */
    AxisOrder[AxisOrder["YXZ"] = 5] = "YXZ";
    /** Left handed system, Z then Y then X */
    AxisOrder[AxisOrder["ZYX"] = 6] = "ZYX";
})(AxisOrder = exports.AxisOrder || (exports.AxisOrder = {}));
/** Enumeration of numeric indices of 3 axes AxisIndex.X, AxisIndex.Y, AxisIndex.Z
 * @public
 */
var AxisIndex;
(function (AxisIndex) {
    /** x axis is index 0 */
    AxisIndex[AxisIndex["X"] = 0] = "X";
    /** y axis is index 1 */
    AxisIndex[AxisIndex["Y"] = 1] = "Y";
    /** 2 axis is index 2 */
    AxisIndex[AxisIndex["Z"] = 2] = "Z";
})(AxisIndex = exports.AxisIndex || (exports.AxisIndex = {}));
/** Standard views.   Used in `Matrix3d.createStandardViewAxes (index: StandardViewIndex, worldToView :boolean)`
 * @public
 */
var StandardViewIndex;
(function (StandardViewIndex) {
    /** X to right, Y up */
    StandardViewIndex[StandardViewIndex["Top"] = 1] = "Top";
    /** X to right, negative Y up */
    StandardViewIndex[StandardViewIndex["Bottom"] = 2] = "Bottom";
    /** negative Y to right, Z up */
    StandardViewIndex[StandardViewIndex["Left"] = 3] = "Left";
    /**  Y to right, Z up */
    StandardViewIndex[StandardViewIndex["Right"] = 4] = "Right";
    /** X to right, Z up */
    StandardViewIndex[StandardViewIndex["Front"] = 5] = "Front";
    /** negative X to right, Z up */
    StandardViewIndex[StandardViewIndex["Back"] = 6] = "Back";
    /** View towards origin from (-1,-1,1) */
    StandardViewIndex[StandardViewIndex["Iso"] = 7] = "Iso";
    /** View towards origin from (1,-1,1) */
    StandardViewIndex[StandardViewIndex["RightIso"] = 8] = "RightIso";
})(StandardViewIndex = exports.StandardViewIndex || (exports.StandardViewIndex = {}));
/** Enumeration among choice for how a coordinate transformation should incorporate scaling.
 * @public
 */
var AxisScaleSelect;
(function (AxisScaleSelect) {
    /** All axes of unit length. */
    AxisScaleSelect[AxisScaleSelect["Unit"] = 0] = "Unit";
    /** On each axis, the vector length matches the longest side of the range of the data. */
    AxisScaleSelect[AxisScaleSelect["LongestRangeDirection"] = 1] = "LongestRangeDirection";
    /** On each axis, the vector length matches he length of the corresponding edge of the range. */
    AxisScaleSelect[AxisScaleSelect["NonUniformRangeContainment"] = 2] = "NonUniformRangeContainment";
})(AxisScaleSelect = exports.AxisScaleSelect || (exports.AxisScaleSelect = {}));
/**
 * Class containing static methods for typical numeric operations.
 * * Experimentally, methods like Geometry.hypotenuse are observed to be faster than the system intrinsics.
 * * This is probably due to
 *    * Fixed length arg lists
 *    * strongly typed parameters
 * @public
 */
class Geometry {
    /** Test if absolute value of x is huge.
     * * See `Geometry.hugeCoordinate`
     */
    static isHugeCoordinate(x) {
        return x > this.hugeCoordinate || x < -this.hugeCoordinate;
    }
    /** Test if a number is odd.
     */
    static isOdd(x) {
        return (x & (0x01)) === 1;
    }
    /** Correct `distance` to zero if smaller than metric tolerance.   Otherwise return it unchanged. */
    static correctSmallMetricDistance(distance, replacement = 0.0) {
        if (Math.abs(distance) < Geometry.smallMetricDistance) {
            return replacement;
        }
        return distance;
    }
    /**
   * If `a` is large enough for safe division, return `1/a`, using Geometry.smallMetricDistance as the tolerance for declaring it as divide by zero.  Otherwise return `undefined`.
   * @param a denominator of division
   */
    static inverseMetricDistance(a) { return (Math.abs(a) <= Geometry.smallMetricDistance) ? undefined : 1.0 / a; }
    /**
     * If `a` is large enough, return `1/a`, using the square of Geometry.smallMetricDistance as the tolerance for declaring it as divide by zero.  Otherwise return `undefined`.
     * @param a denominator of division
     */
    static inverseMetricDistanceSquared(a) {
        return (Math.abs(a) <= Geometry.smallMetricDistanceSquared) ? undefined : 1.0 / a;
    }
    /** Boolean test for metric coordinate near-equality */
    static isSameCoordinate(x, y, tol) {
        if (tol)
            return Math.abs(x - y) < Math.abs(tol);
        return Math.abs(x - y) < Geometry.smallMetricDistance;
    }
    /** Boolean test for metric coordinate near-equality, with toleranceFactor applied to the usual smallMetricDistance */
    static isSameCoordinateWithToleranceFactor(x, y, toleranceFactor) {
        return Geometry.isSameCoordinate(x, y, toleranceFactor * Geometry.smallMetricDistance);
    }
    /** Boolean test for metric coordinate near-equality of x, y pair */
    static isSameCoordinateXY(x0, y0, x1, y1, tol = Geometry.smallMetricDistance) {
        let d = x1 - x0;
        if (d < 0)
            d = -d;
        if (d > tol)
            return false;
        d = y1 - y0;
        if (d < 0)
            d = -d;
        return d < tol;
    }
    /** Boolean test for squared metric coordinate near-equality */
    static isSameCoordinateSquared(x, y) {
        return Math.abs(Math.sqrt(x) - Math.sqrt(y)) < Geometry.smallMetricDistance;
    }
    /** boolean test for small `dataA.distance (dataB)`  within `smallMetricDistance` */
    static isSamePoint3d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    /** boolean test for distance between `XYZ` objects within `smallMetricDistance`
     *  * Note that Point3d and Vector3d are both derived from XYZ, so this method tolerates mixed types.
     */
    static isSameXYZ(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */
    static isSamePoint3dXY(dataA, dataB) { return dataA.distanceXY(dataB) < Geometry.smallMetricDistance; }
    /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */
    static isSameVector3d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */
    static isSamePoint2d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */
    static isSameVector2d(dataA, dataB) { return dataA.distance(dataB) < Geometry.smallMetricDistance; }
    /**
     * Lexical comparison of (a.x,a.y) (b.x,b.y) with x as first test, y second.
     * * This is appropriate for a horizontal sweep in the plane.
     */
    static lexicalXYLessThan(a, b) {
        if (a.x < b.x)
            return -1;
        else if (a.x > b.x)
            return 1;
        if (a.y < b.y)
            return -1;
        else if (a.y > b.y)
            return 1;
        return 0;
    }
    /**
     * Lexical comparison of (a.x,a.y) (b.x,b.y) with y as first test, x second.
     * * This is appropriate for a vertical sweep in the plane.
     */
    static lexicalYXLessThan(a, b) {
        if (a.y < b.y)
            return -1;
        else if (a.y > b.y)
            return 1;
        if (a.x < b.x)
            return -1;
        else if (a.x > b.x)
            return 1;
        return 0;
    }
    /**
     * Lexical test, based on x first, y second, z third.
     */
    static lexicalXYZLessThan(a, b) {
        if (a.x < b.x)
            return -1;
        else if (a.x > b.x)
            return 1;
        if (a.y < b.y)
            return -1;
        else if (a.y > b.y)
            return 1;
        if (a.z < b.z)
            return -1;
        else if (a.z > b.z)
            return 1;
        return 0;
    }
    /** Test if `value` is small compared to `smallAngleRadians`.
     * * This is appropriate if `value` is know to be a typical 0..1 fraction.
     */
    static isSmallRelative(value) { return Math.abs(value) < Geometry.smallAngleRadians; }
    /** Test if `value` is small compared to `smallAngleRadians` */
    static isSmallAngleRadians(value) { return Math.abs(value) < Geometry.smallAngleRadians; }
    /** Toleranced equality test, using tolerance `smallAngleRadians * ( 1 + abs(a) + (abs(b)))`
     * * Effectively an absolute tolerance of `smallAngleRadians`, with tolerance increasing for larger values of a and b.
    */
    static isAlmostEqualNumber(a, b) {
        const sumAbs = 1.0 + Math.abs(a) + Math.abs(b);
        return Math.abs(a - b) <= Geometry.smallAngleRadians * sumAbs;
    }
    /** Toleranced equality test, using caller-supplied tolerance. */
    static isDistanceWithinTol(distance, tol) {
        return Math.abs(distance) <= Math.abs(tol);
    }
    /** Toleranced equality test, using `smallMetricDistance` tolerance. */
    static isSmallMetricDistance(distance) {
        return Math.abs(distance) <= Geometry.smallMetricDistance;
    }
    /** Toleranced equality, using `smallMetricDistanceSquared` tolerance. */
    static isSmallMetricDistanceSquared(distanceSquared) {
        return Math.abs(distanceSquared) <= Geometry.smallMetricDistanceSquared;
    }
    /** Return `axis modulo 3` with proper handling of negative indices (-1 is z), -2 is y, -3 is x etc) */
    static cyclic3dAxis(axis) {
        /* Direct test for the most common cases, avoid modulo */
        if (axis >= 0) {
            if (axis < 3)
                return axis;
            if (axis < 6)
                return axis - 3;
            return axis % 3;
        }
        const j = axis + 3;
        if (j >= 0)
            return j;
        return 2 - ((-axis - 1) % 3);
    }
    /** Return the AxisOrder for which axisIndex is the first named axis.
     * * `axisIndex===0`returns AxisOrder.XYZ
     * * `axisIndex===1`returns AxisOrder.YZX
     * * `axisIndex===2`returns AxisOrder.ZXY
     */
    static axisIndexToRightHandedAxisOrder(axisIndex) {
        if (axisIndex === 0)
            return AxisOrder.XYZ;
        if (axisIndex === 1)
            return AxisOrder.YZX;
        if (axisIndex === 2)
            return AxisOrder.ZXY;
        return Geometry.axisIndexToRightHandedAxisOrder(Geometry.cyclic3dAxis(axisIndex));
    }
    /** Return the largest absolute distance from a to either of b0 or b1 */
    static maxAbsDiff(a, b0, b1) { return Math.max(Math.abs(a - b0), Math.abs(a - b1)); }
    /** Return the largest absolute absolute value among x,y,z */
    static maxAbsXYZ(x, y, z) {
        return Geometry.maxXYZ(Math.abs(x), Math.abs(y), Math.abs(z));
    }
    /** Return the largest absolute absolute value among x,y */
    static maxAbsXY(x, y) {
        return Geometry.maxXY(Math.abs(x), Math.abs(y));
    }
    /** Return the largest signed value among a, b, c */
    static maxXYZ(a, b, c) {
        let q = a;
        if (b > q)
            q = b;
        if (c > q)
            q = c;
        return q;
    }
    /** Examine the value (particularly sign) of x.
     * * If x is negative, return outNegative.
     * * If x is true zero, return outZero
     * * If x is positive, return outPositive
     */
    static split3WaySign(x, outNegative, outZero, outPositive) {
        if (x < 0)
            return outNegative;
        if (x > 0.0)
            return outPositive;
        return outZero;
    }
    /** Return the largest signed value among a, b */
    static maxXY(a, b) {
        let q = a;
        if (b > q)
            q = b;
        return q;
    }
    /** Return the smallest signed value among a, b */
    static minXY(a, b) {
        let q = a;
        if (b < q)
            q = b;
        return q;
    }
    /** Return the hypotenuse `sqrt(x*x + y*y)`. This is much faster than `Math.hypot(x,y)`. */
    static hypotenuseXY(x, y) { return Math.sqrt(x * x + y * y); }
    /** Return the squared `hypotenuse (x*x + y*y)`. */
    static hypotenuseSquaredXY(x, y) { return x * x + y * y; }
    /** Return the square of x */
    static square(x) { return x * x; }
    /** Return the hypotenuse `sqrt(x*x + y*y + z*z)`. This is much faster than `Math.hypot(x,y,z)`. */
    static hypotenuseXYZ(x, y, z) { return Math.sqrt(x * x + y * y + z * z); }
    /** Return the squared hypotenuse `(x*x + y*y + z*z)`. This is much faster than `Math.hypot(x,y,z)`. */
    static hypotenuseSquaredXYZ(x, y, z) { return x * x + y * y + z * z; }
    /** Return the (full 4d) hypotenuse `sqrt(x*x + y*y + z*z + w*w)`. This is much faster than `Math.hypot(x,y,z,w)`. */
    static hypotenuseXYZW(x, y, z, w) { return Math.sqrt(x * x + y * y + z * z + w * w); }
    /** Return the squared hypotenuse `(x*x + y*y + z*z+w*w)`. This is much faster than `Math.hypot(x,y,z)`. */
    static hypotenuseSquaredXYZW(x, y, z, w) { return x * x + y * y + z * z + w * w; }
    /**
     * Return the distance between xy points given as numbers.
     * @param x0 x coordinate of point 0
     * @param y0 y coordinate of point 0
     * @param x1 x coordinate of point 1
     * @param y1 y coordinate of point 1
     */
    static distanceXYXY(x0, y0, x1, y1) {
        return Geometry.hypotenuseXY(x1 - x0, y1 - y0);
    }
    /**
     * Return the distance between xyz points given as numbers.
     * @param x0 x coordinate of point 0
     * @param y0 y coordinate of point 0
     * @param z0 z coordinate of point 0
     * @param x1 x coordinate of point 1
     * @param y1 y coordinate of point 1
     * @param z1 z coordinate of point 1
     */
    static distanceXYZXYZ(x0, y0, z0, x1, y1, z1) {
        return Geometry.hypotenuseXYZ(x1 - x0, y1 - y0, z1 - z0);
    }
    /** Returns Returns the triple product of 3 vectors provided as x,y,z number sequences.
     *
     * * The triple product is the determinant of the 3x3 matrix with the 9 numbers placed in either row or column order.
     * * The triple product is positive if the 3 vectors form a right handed coordinate system.
     * * The triple product is negative if the 3 vectors form a left handed coordinate system.
     * * Treating the 9 numbers as 3 vectors U, V, W, any of these formulas gives the same result:
     *
     * ** U dot (V cross W)
     * ** V dot (W cross U)
     * ** W dot (U cross V)
     * **  (-U dot (W cross V))  -- (note the negative -- reversing cross product order changes the sign)
     * ** (-V dot (U cross W)) -- (note the negative -- reversing cross product order changes the sign)
     * ** (-W dot (V cross U)) -- (note the negative -- reversing cross product order changes the sign)
     * * the triple product is 6 times the (signed) volume of the tetrahedron with the three vectors as edges from a common vertex.
     */
    static tripleProduct(ux, uy, uz, vx, vy, vz, wx, wy, wz) {
        return ux * (vy * wz - vz * wy)
            + uy * (vz * wx - vx * wz)
            + uz * (vx * wy - vy * wx);
    }
    /** Returns the determinant of the 4x4 matrix unrolled as the 16 parameters.
     */
    static determinant4x4(xx, xy, xz, xw, yx, yy, yz, yw, zx, zy, zz, zw, wx, wy, wz, ww) {
        return xx * this.tripleProduct(yy, yz, yw, zy, zz, zw, wy, wz, ww)
            - yx * this.tripleProduct(xy, xz, xw, zy, zz, zw, wy, wz, ww)
            + zx * this.tripleProduct(xy, xz, xw, yy, yz, yw, wy, wz, ww)
            - wx * this.tripleProduct(xy, xz, xw, yy, yz, yw, zy, zz, zw);
    }
    /**
   * Returns curvature magnitude from a first and second derivative vector.
   * @param ux  first derivative x component
   * @param uy first derivative y component
   * @param uz first derivative z component
   * @param vx second derivative x component
   * @param vy second derivative y component
   * @param vz second derivative z component
   */
    static curvatureMagnitude(ux, uy, uz, vx, vy, vz) {
        let q = uy * vz - uz * vy;
        let sum = q * q;
        q = uz * vx - ux * vz;
        sum += q * q;
        q = ux * vy - uy * vx;
        sum += q * q;
        const a = Math.sqrt(ux * ux + uy * uy + uz * uz);
        const b = Math.sqrt(sum);
        // (sum and a are both nonnegative)
        const aaa = a * a * a;
        // radius of curvature = aaa / b;
        // curvature = b/aaa
        const tol = Geometry.smallAngleRadians;
        if (aaa > tol * b)
            return b / aaa;
        return 0; // hm.. maybe should be infinite?
    }
    /** Returns the determinant of 3x3 matrix with x and y rows taken from 3 points, third row from corresponding numbers.
     *
     */
    static tripleProductXYW(columnA, weightA, columnB, weightB, columnC, weightC) {
        return Geometry.tripleProduct(columnA.x, columnB.x, columnC.x, columnA.y, columnB.y, columnC.y, weightA, weightB, weightC);
    }
    /** Returns the determinant of 3x3 matrix with x and y rows taken from 3 points, third row from corresponding numbers.
     *
     */
    static tripleProductPoint4dXYW(columnA, columnB, columnC) {
        return Geometry.tripleProduct(columnA.x, columnB.x, columnC.x, columnA.y, columnB.y, columnC.y, columnA.w, columnB.w, columnC.w);
    }
    /** 2D cross product of vectors layed out as scalars. */
    static crossProductXYXY(ux, uy, vx, vy) {
        return ux * vy - uy * vx;
    }
    /** 3D cross product of vectors layed out as scalars. */
    static crossProductXYZXYZ(ux, uy, uz, vx, vy, vz, result) {
        return Point3dVector3d_1.Vector3d.create(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx, result);
    }
    /** magnitude of 3D cross product of vectors, with the vectors presented as */
    static crossProductMagnitude(ux, uy, uz, vx, vy, vz) {
        return Geometry.hypotenuseXYZ(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx);
    }
    /** 3D dot product of vectors layed out as scalars. */
    static dotProductXYZXYZ(ux, uy, uz, vx, vy, vz) {
        return ux * vx + uy * vy + uz * vz;
    }
    /** 2D dot product of vectors layed out as scalars. */
    static dotProductXYXY(ux, uy, vx, vy) {
        return ux * vx + uy * vy;
    }
    /**
     * Clamp to (min(a,b), max(a,b))
     * @param x
     * @param a
     * @param b
     */
    static clampToStartEnd(x, a, b) {
        if (a > b)
            return Geometry.clampToStartEnd(x, b, a);
        if (x < a)
            return a;
        if (b < x)
            return b;
        return x;
    }
    /**
     * Clamp value to (min,max) with no test for order of (min,max)
     * @param value value to clamp
     * @param min smallest allowed output
     * @param max largest allowed result.
     */
    static clamp(value, min, max) { return Math.max(min, Math.min(max, value)); }
    /** If given a number, return it.   If given undefined, return `defaultValue`. */
    static resolveNumber(value, defaultValue = 0) {
        return value !== undefined ? value : defaultValue;
    }
    /** simple interpolation between values, but choosing (based on fraction) a or b as starting point for maximum accuracy. */
    static interpolate(a, f, b) {
        return f <= 0.5 ? a + f * (b - a) : b - (1.0 - f) * (b - a);
    }
    /** given an axisOrder (e.g. XYZ, YZX, ZXY, XZYLeftHanded etc) and an (integer) offset, resolve to an axis index. */
    static axisOrderToAxis(order, index) {
        const axis = order <= AxisOrder.ZXY ? order + index : (order - AxisOrder.XZY) - index;
        return Geometry.cyclic3dAxis(axis);
    }
    /** Return (a modulo period), e.g. for use as a cyclic index.  Both a and period may be negative. */
    static modulo(a, period) {
        if (period <= 0) {
            if (period === 0)
                return a;
            return -Geometry.modulo(-a, -period);
        }
        if (a >= 0) {
            if (a < period)
                return a;
            if (a < 2 * period)
                return a - period;
        }
        else {
            a += period; // hopefully move into primary period without division and floor
            if (a > 0)
                return a;
        }
        const m = Math.floor(a / period);
        return a - m * period;
    }
    /** return 0 if the value is undefined, 1 if defined. */
    static defined01(value) { return value === undefined ? 0 : 1; }
    /** normally, return numerator/denominator.
     * but if the ratio would exceed Geometry.largeFractionResult, return undefined.
     */
    static conditionalDivideFraction(numerator, denominator) {
        if (Math.abs(denominator) * Geometry.largeFractionResult > Math.abs(numerator))
            return numerator / denominator;
        return undefined;
    }
    /** normally, return numerator/denominator.
     * but if the ratio would exceed Geometry.largestResult, return undefined.
     */
    static conditionalDivideCoordinate(numerator, denominator, largestResult = Geometry.largeCoordinateResult) {
        if (Math.abs(denominator * largestResult) > Math.abs(numerator))
            return numerator / denominator;
        return undefined;
    }
    /** return the 0, 1, or 2 pairs of (c,s) values that solve
     * {constCoff + cosCoff * c + sinCoff * s = }
     * with the constraint {c*c+s*s = 1}
     */
    static solveTrigForm(constCoff, cosCoff, sinCoff) {
        {
            const delta2 = cosCoff * cosCoff + sinCoff * sinCoff;
            const constCoff2 = constCoff * constCoff;
            // let nSolution = 0;
            let result;
            if (delta2 > 0.0) {
                const lambda = -constCoff / delta2;
                const a2 = constCoff2 / delta2;
                const D2 = 1.0 - a2;
                if (D2 >= 0.0) {
                    const mu = Math.sqrt(D2 / delta2);
                    /* c0,s0 = closest approach of line to origin */
                    const c0 = lambda * cosCoff;
                    const s0 = lambda * sinCoff;
                    // nSolution = 2;
                    result = [Point2dVector2d_1.Vector2d.create(c0 - mu * sinCoff, s0 + mu * cosCoff), Point2dVector2d_1.Vector2d.create(c0 + mu * sinCoff, s0 - mu * cosCoff)];
                }
            }
            return result;
        }
    }
    /** normally,  return the number result of conditionalDivideFraction.
     * but if conditionalDivideFraction fails return specified default number.
     */
    static safeDivideFraction(numerator, denominator, defaultResult) {
        const a = Geometry.conditionalDivideFraction(numerator, denominator);
        if (a !== undefined)
            return a;
        return defaultResult;
    }
    /** For a line f(x) whose function values at x0 and x1 are f0 and f1, return the x value at which f(x)=fTarget;
     */
    static inverseInterpolate(x0, f0, x1, f1, targetF = 0, defaultResult) {
        const g = Geometry.conditionalDivideFraction(targetF - f0, f1 - f0);
        if (g)
            return Geometry.interpolate(x0, g, x1);
        return defaultResult;
    }
    /** For a line f(x) whose function values at x=0 and x=1 are f0 and f1, return the x value at which f(x)=fTarget;
     */
    static inverseInterpolate01(f0, f1, targetF = 0) {
        return Geometry.conditionalDivideFraction(targetF - f0, f1 - f0);
    }
    /** Return true if json is an array with at least minEntries, and all entries are numbers (including those beyond minEntries) */
    static isNumberArray(json, minEntries = 0) {
        if (Array.isArray(json) && json.length >= minEntries) {
            let entry;
            for (entry of json) {
                //        if (!(entry as number) && entry !== 0.0)
                if (!Number.isFinite(entry))
                    return false;
            }
            return true;
        }
        return false;
    }
    /** Return true if json is an array of at least numNumberArrays, with at least minEntries in each number array.
     */
    static isArrayOfNumberArray(json, numNumberArray, minEntries = 0) {
        if (Array.isArray(json) && json.length >= numNumberArray) {
            let entry;
            for (entry of json)
                if (!Geometry.isNumberArray(entry, minEntries))
                    return false;
            return true;
        }
        return false;
    }
    /** return the number of steps to take so that numSteps * stepSize >= total.
     * minCount is returned for both (a) setSize 0 or less and (b) stepSize > total.
     * A small tolerance is applied for almost
    */
    static stepCount(stepSize, total, minCount = 1, maxCount = 101) {
        if (stepSize <= 0)
            return minCount;
        if (stepSize >= total)
            return minCount;
        const stepCount = Math.floor((total + 0.999999 * stepSize) / stepSize);
        if (stepCount < minCount)
            return minCount;
        if (stepCount > maxCount)
            return maxCount;
        return stepCount;
    }
    /** Test if x is in simple 0..1 interval.  But optionally skip the test.  (this odd behavior is very convenient for code that sometimes does not do the filtering.)
     * @param x value to test.
     * @param apply01 if false, accept all x.
     */
    static isIn01(x, apply01 = true) { return apply01 ? x >= 0.0 && x <= 1.0 : true; }
    /** Test if x is in simple 0..1 interval.  But optionally skip the test.  (this odd behavior is very convenient for code that sometimes does not do the filtering.)
     * @param x value to test.
     * @param apply01 if false, accept all x.
     */
    static isIn01WithTolerance(x, tolerance) { return x + tolerance >= 0.0 && x - tolerance <= 1.0; }
    /**
     * restrict x so it is in the interval `[a,b]`, allowing a,b to be in either order.
     * @param x
     * @param a (usually the lower) interval limit
     * @param b (usually the upper) interval limit
     */
    static restrictToInterval(x, a, b) {
        if (a <= b) {
            if (x < a)
                return a;
            if (x > b)
                return b;
            return x;
        }
        // reversed interval ....
        if (x < b)
            return b;
        if (x > a)
            return a;
        return x;
    }
}
exports.Geometry = Geometry;
/** Tolerance for small distances in metric coordinates */
Geometry.smallMetricDistance = 1.0e-6;
/** Square of `smallMetricTolerance` */
Geometry.smallMetricDistanceSquared = 1.0e-12;
/** tolerance for small angle measured in radians. */
Geometry.smallAngleRadians = 1.0e-12;
/** square of `smallAngleRadians` */
Geometry.smallAngleRadiansSquared = 1.0e-24;
/** numeric value that may considered huge for numbers expected to be 0..1 fractions.
 * * But note that the "allowed" result value is vastly larger than 1.
 */
Geometry.largeFractionResult = 1.0e10;
/** numeric value that may considered huge for numbers expected to be coordinates.
 * * This allows larger results than `largeFractionResult`.
 */
Geometry.largeCoordinateResult = 1.0e13;
/** numeric value that may considered infinite for metric coordinates.
 * * This coordinate should be used only as a placeholder indicating "at infinity" -- computing actual points at this coordinate invites numerical problems.
 */
Geometry.hugeCoordinate = 1.0e12;
/** Radians value for full circle 2PI radians minus `smallAngleRadians` */
Geometry.fullCircleRadiansMinusSmallAngle = 2.0 * Math.PI - 1.0e-12; // smallAngleRadians less than 360degrees


/***/ }),

/***/ "./lib/bspline/BSpline1dNd.js":
/*!************************************!*\
  !*** ./lib/bspline/BSpline1dNd.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const KnotVector_1 = __webpack_require__(/*! ./KnotVector */ "./lib/bspline/KnotVector.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/** Bspline knots and poles for 1d-to-Nd.
 * * The "pole" (aka control point) of this class is a block of `poleLength` numbers.
 * * Derived classes (not this class) assign meaning such as x,y,z,w.
 * * for instance, an instance of this class with `poleLength===3` does not know if its poles are x,y,z or weighed 2D x,y,w
 * @public
 */
class BSpline1dNd {
    /**
     * initialize arrays for given spline dimensions.
     * @param numPoles number of poles
     * @param poleLength number of coordinates per pole (e.g.. 3 for 3D unweighted, 4 for 3d weighted, 2 for 2d unweighted, 3 for 2d weighted)
     * @param order number of poles in support for a section of the bspline
     * @param knots KnotVector.  This is captured, not cloned.
     */
    constructor(numPoles, poleLength, order, knots) {
        this.knots = knots;
        this.packedData = new Float64Array(numPoles * poleLength);
        this.poleLength = poleLength;
        this.basisBuffer = new Float64Array(order);
        this.poleBuffer = new Float64Array(poleLength);
        this.basisBuffer1 = new Float64Array(order);
        this.basisBuffer2 = new Float64Array(order);
        this.poleBuffer1 = new Float64Array(poleLength);
        this.poleBuffer2 = new Float64Array(poleLength);
    }
    /** (property accessor) Return the degree of the polynomials. */
    get degree() { return this.knots.degree; }
    /** (property accessor) Return the number of order (one more than degree) of the polynomials */
    get order() { return this.knots.degree + 1; }
    /** (property accessor) Return the number of bezier spans (including null spans at multiple knots)*/
    get numSpan() { return this.numPoles - this.knots.degree; }
    /** (property accessor)  Return the number of poles*/
    get numPoles() { return this.packedData.length / this.poleLength; }
    /** copy 3 values of pole `i` into a point.
     * * The calling clas sis responsible for knowing if this is an appropriate access to the blocked data.
     */
    getPoint3dPole(i, result) { return Point3dVector3d_1.Point3d.createFromPacked(this.packedData, i, result); }
    /**
     * create a 1Bspline1dNd`
     * @param numPoles number of poles
     * @param poleLength number of coordinates per pole (e.g.. 3 for 3D unweighted, 4 for 3d weighted, 2 for 2d unweighted, 3 for 2d weighted)
     * @param order number of poles in support for a section of the bspline
     * @param knots KnotVector.  This is captured, not cloned.
     */
    static create(numPoles, poleLength, order, knots) {
        return new BSpline1dNd(numPoles, poleLength, order, knots);
    }
    /** Map a span index and local fraction to knot value. */
    spanFractionToKnot(span, localFraction) {
        return this.knots.spanFractionToKnot(span, localFraction);
    }
    /** Evaluate the `order` basis functions (and optionally one or two derivatives) at a given fractional position within indexed span. */
    evaluateBasisFunctionsInSpan(spanIndex, spanFraction, f, df, ddf) {
        if (spanIndex < 0)
            spanIndex = 0;
        if (spanIndex >= this.numSpan)
            spanIndex = this.numSpan - 1;
        const knotIndex0 = spanIndex + this.degree - 1;
        const globalKnot = this.knots.baseKnotFractionToKnot(knotIndex0, spanFraction);
        return df ?
            this.knots.evaluateBasisFunctions1(knotIndex0, globalKnot, f, df, ddf) :
            this.knots.evaluateBasisFunctions(knotIndex0, globalKnot, f);
    }
    /**
     * * Evaluate the basis functions at spanIndex and fraction.
     *   * Evaluations are stored in the preallocated `this.basisBuffer`
     * * Immediately do the summations of the basis values times the respective control points
     *   * Summations are stored in the preallocated `this.poleBuffer`
     * */
    evaluateBuffersInSpan(spanIndex, spanFraction) {
        this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer);
        this.sumPoleBufferForSpan(spanIndex);
    }
    /**
     * * Evaluate the basis functions and one derivative at spanIndex and fraction.
     *   * Evaluations are stored in the preallocated `this.basisBuffer`
     * * Immediately do the summations of the basis values times the respective control points
     *   * Summations are stored in the preallocated `this.poleBuffer` and `this.poleBuffer`
     * */
    evaluateBuffersInSpan1(spanIndex, spanFraction) {
        this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer, this.basisBuffer1);
        this.sumPoleBufferForSpan(spanIndex);
        this.sumPoleBuffer1ForSpan(spanIndex);
    }
    /** sum poles at span `spanIndex` by the weights in the `poleBuffer` */
    sumPoleBufferForSpan(spanIndex) {
        this.poleBuffer.fill(0);
        let k = spanIndex * this.poleLength;
        for (const f of this.basisBuffer) {
            for (let j = 0; j < this.poleLength; j++) {
                this.poleBuffer[j] += f * this.packedData[k++];
            }
        }
    }
    /** sum poles at span `spanIndex` by the weights in the `poleBuffer1`, i.e. form first derivatives */
    sumPoleBuffer1ForSpan(spanIndex) {
        this.poleBuffer1.fill(0);
        let k = spanIndex * this.poleLength;
        for (const f of this.basisBuffer1) {
            for (let j = 0; j < this.poleLength; j++) {
                this.poleBuffer1[j] += f * this.packedData[k++];
            }
        }
    }
    /** sum poles at span `spanIndex` by the weights in the `poleBuffer2`, i.e. form second derivatives */
    sumPoleBuffer2ForSpan(spanIndex) {
        this.poleBuffer2.fill(0);
        let k = spanIndex * this.poleLength;
        for (const f of this.basisBuffer2) {
            for (let j = 0; j < this.poleLength; j++) {
                this.poleBuffer2[j] += f * this.packedData[k++];
            }
        }
    }
    /** Evaluate the function values and 1 or 2 derivatives into `this.poleBuffer`, `this.poleBuffer1` and `this.poleBuffer2` */
    evaluateBuffersAtKnot(u, numDerivative = 0) {
        const knotIndex0 = this.knots.knotToLeftKnotIndex(u);
        if (numDerivative < 1) {
            this.knots.evaluateBasisFunctions(knotIndex0, u, this.basisBuffer);
            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);
        }
        else if (numDerivative === 1) {
            this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1);
            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);
            this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);
        }
        else {
            this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1, this.basisBuffer2);
            this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);
            this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);
            this.sumPoleBuffer2ForSpan(knotIndex0 - this.degree + 1);
        }
    }
    /**
     * Reverse the (blocked) poles (in `this.packedData` in place.
     */
    reverseInPlace() {
        // reverse poles in blocks ...
        const b = this.poleLength;
        const data = this.packedData;
        for (let i0 = 0, j0 = b * (this.numPoles - 1); i0 < j0; i0 += b, j0 -= b) {
            let t = 0;
            for (let i = 0; i < b; i++) {
                t = data[i0 + i];
                data[i0 + i] = data[j0 + i];
                data[j0 + i] = t;
            }
        }
        this.knots.reflectKnots();
    }
    /**
     * Test if the leading and trailing polygon coordinates are replicated in the manner of a "closed" bspline polygon which has been expanded
     * to act as a normal bspline.
     * @returns true if `degree` leading and trailing polygon blocks match
     */
    testCloseablePolygon(mode) {
        if (mode === undefined)
            mode = this.knots.wrappable;
        const degree = this.degree;
        const blockSize = this.poleLength;
        const indexDelta = (this.numPoles - this.degree) * blockSize;
        const data = this.packedData;
        if (mode === KnotVector_1.BSplineWrapMode.OpenByAddingControlPoints) {
            // expect {degree} matched points.
            const numValuesToTest = degree * blockSize;
            for (let i0 = 0; i0 < numValuesToTest; i0++) {
                if (!Geometry_1.Geometry.isSameCoordinate(data[i0], data[i0 + indexDelta]))
                    return false;
            }
            return true;
        }
        if (mode === KnotVector_1.BSplineWrapMode.OpenByRemovingKnots) {
            // no pole conditions are applied.
            return true;
        }
        return false;
    }
}
exports.BSpline1dNd = BSpline1dNd;


/***/ }),

/***/ "./lib/bspline/BSplineCurve.js":
/*!*************************************!*\
  !*** ./lib/bspline/BSplineCurve.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const StrokeCountMap_1 = __webpack_require__(/*! ../curve/Query/StrokeCountMap */ "./lib/curve/Query/StrokeCountMap.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ../curve/CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const KnotVector_1 = __webpack_require__(/*! ./KnotVector */ "./lib/bspline/KnotVector.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const BezierCurve3dH_1 = __webpack_require__(/*! ./BezierCurve3dH */ "./lib/bspline/BezierCurve3dH.js");
const BezierCurve3d_1 = __webpack_require__(/*! ./BezierCurve3d */ "./lib/bspline/BezierCurve3d.js");
const BSpline1dNd_1 = __webpack_require__(/*! ./BSpline1dNd */ "./lib/bspline/BSpline1dNd.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const Bezier1dNd_1 = __webpack_require__(/*! ./Bezier1dNd */ "./lib/bspline/Bezier1dNd.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
/**
 * Base class for BSplineCurve3d and BSplineCurve3dH.
 * * A bspline curve consists of a set of knots and a set of poles.
 * * The bspline curve is a function of the independent "knot axis" variable
 * * The curve "follows" the poles loosely.
 * * The is a set of polynomial spans.
 * * The polynomial spans all have same `degree`.
 * * Within each span, the polynomial of that `degree` is controlled by `order = degree + 1` contiguous points called poles.
 * * The is a strict relationship between knot and poles counts:  `numPoles + order = numKnots + 2'
 * * The number of spans is `numSpan = numPoles - degree`
 * * For a given `spanIndex`:
 *   * The `order` poles begin at index `spanIndex`.
 *   * The `2*order` knots begin as span index
 *   * The knot interval for this span is from `knot[degree+span-1] to knot[degree+span]`
 * * The active part of the knot axis is `knot[degree-1] < knot < knot[degree-1 + numSpan]` i.e. `knot[degree-1] < knot < knot[numPoles]
 *
 * Nearly all bsplines are "clamped ".
 * * Clamping make the curve pass through its first and last poles, with tangents directed along the first and last edges of the control polygon.
 * * The knots for a clamped bspline have `degree` copies of the lowest knot value and `degree` copies of the highest knot value.
 * * For instance, the knot vector `[0,0,0,1,2,3,3,3]
 *   * can be evaluated from `0<=knot<=3`
 *   * has 3 spans: 0 to 1, 1 to 2, 2 to 3
 *   * has 6 poles
 *   * passes through its first and last poles.
 * * `create` methods may allow classic convention that has an extra knot at the beginning and end of the knot vector.
 *   * The extra knots (first and last) were never referenced by the bspline recurrence relations.
 *   * When the `create` methods recognize the classic setup (`numPoles + order = numKnots`), the extra knot is not saved with the BSplineCurve3dBase knots.
 *
 * * The weighted variant has the problem that CurvePrimitive 3d typing does not allow undefined result where Point4d has zero weight.
 * * The convention for these is to return 000 in such places.
 *
 * * Note the class relationships:
 *   * BSpline1dNd knows the bspline recurrence relations for control points (poles) with no physical meaning.
 *   * BsplineCurve3dBase owns a protected BSpline1dNd
 *   * BsplineCurve3dBase is derived from CurvePrimitive, which creates obligation to act as a 3D curve, such as
 *     * evaluate fraction to point and derivatives wrt fraction
 *     * compute intersection with plane
 *   * BSplineCurve3d and BSplineCurve3dH have variant logic driven by whether or not there are "weights" on the poles.
 *     * For `BSplineCurve3d`, the xyz value of pole calculations are "final" values for 3d evaluation
 *     * For `BSplineCurve3dH`, various `BSpline1dNd` results with xyzw have to be normalized back to xyz.
 *
 * * These classes do not support "periodic" variants.
 *   * Periodic curves need to have certain leading knots and poles replicated at the end
 * @public
 */
class BSplineCurve3dBase extends CurvePrimitive_1.CurvePrimitive {
    constructor(poleDimension, numPoles, order, knots) {
        super();
        /** String name for schema properties */
        this.curvePrimitiveType = "bsplineCurve";
        this._bcurve = BSpline1dNd_1.BSpline1dNd.create(numPoles, poleDimension, order, knots);
    }
    /** Return the degree (one less than the order) of the curve */
    get degree() { return this._bcurve.degree; }
    /** Return the order (one more than degree) of the curve */
    get order() { return this._bcurve.order; }
    /** Return the number of bezier spans in the curve.  Note that this number includes the number of null spans at repeated knows */
    get numSpan() { return this._bcurve.numSpan; }
    /** Return the number of poles */
    get numPoles() { return this._bcurve.numPoles; }
    /**
   * return a simple array form of the knots.  optionally replicate the first and last
   * in classic over-clamped manner
   */
    copyKnots(includeExtraEndKnot) { return this._bcurve.knots.copyKnots(includeExtraEndKnot); }
    /**
   * Set the flag indicating the bspline might be suitable for having wrapped "closed" interpretation.
   */
    setWrappable(value) {
        this._bcurve.knots.wrappable = value;
    }
    /** Evaluate the curve point at `fraction` */
    fractionToPoint(fraction, result) {
        return this.knotToPoint(this._bcurve.knots.fractionToKnot(fraction), result);
    }
    /** Construct a ray with
     * * origin at the fractional position along the arc
     * * direction is the first derivative, i.e. tangent along the curve
     */
    fractionToPointAndDerivative(fraction, result) {
        const knot = this._bcurve.knots.fractionToKnot(fraction);
        result = this.knotToPointAndDerivative(knot, result);
        result.direction.scaleInPlace(this._bcurve.knots.knotLength01);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the curve
     * * y axis is the second derivative
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const knot = this._bcurve.knots.fractionToKnot(fraction);
        result = this.knotToPointAnd2Derivatives(knot, result);
        const a = this._bcurve.knots.knotLength01;
        result.vectorU.scaleInPlace(a);
        result.vectorV.scaleInPlace(a * a);
        return result;
    }
    /**
     * Return the start point of the curve.
     */
    startPoint() { return this.evaluatePointInSpan(0, 0.0); }
    /**
     * Return the end point of the curve
     */
    endPoint() { return this.evaluatePointInSpan(this.numSpan - 1, 1.0); }
    /** Reverse the curve in place.
     * * Poles are reversed
     * * knot values are mirrored around the middle of the
     */
    reverseInPlace() { this._bcurve.reverseInPlace(); }
    /**
     * Return an array with this curve's bezier fragments.
     */
    collectBezierSpans(prefer3dH) {
        const result = [];
        const numSpans = this.numSpan;
        for (let i = 0; i < numSpans; i++) {
            if (this._bcurve.knots.isIndexOfRealSpan(i)) {
                const span = this.getSaturatedBezierSpan3dOr3dH(i, prefer3dH);
                if (span)
                    result.push(span);
            }
        }
        return result;
    }
    /** Given a pole index, return the starting index for the contiguous array. */
    poleIndexToDataIndex(poleIndex) {
        if (poleIndex >= 0 && poleIndex < this.numPoles)
            return poleIndex * this._bcurve.poleLength;
        return undefined;
    }
    /** Search for the curve point that is closest to the spacePoint.
     *
     * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.
     * * Since CurvePrimitive should always have start and end available as candidate points, this method should always succeed
     * @param spacePoint point in space
     * @param extend true to extend the curve (if possible)
     * @returns Returns a CurveLocationDetail structure that holds the details of the close point.
     */
    closestPoint(spacePoint, _extend) {
        const point = this.fractionToPoint(0);
        const result = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistance(this, 0.0, point, point.distance(spacePoint));
        this.fractionToPoint(1.0, point);
        result.updateIfCloserCurveFractionPointDistance(this, 1.0, point, spacePoint.distance(point));
        let span;
        const numSpans = this.numSpan;
        for (let i = 0; i < numSpans; i++) {
            if (this._bcurve.knots.isIndexOfRealSpan(i)) {
                span = this.getSaturatedBezierSpan3dOr3dH(i, true, span);
                if (span) {
                    if (span.updateClosestPointByTruePerpendicular(spacePoint, result)) {
                        // the detail records the span bezier -- promote it to the parent curve . ..
                        result.curve = this;
                        result.fraction = span.fractionToParentFraction(result.fraction);
                    }
                }
            }
        }
        return result;
    }
    /** Implement `CurvePrimitive.appendPlaneIntersections`
     * @param plane A plane (e.g. specific type Plane3dByOriginAndUnitNormal or Point4d)
     * @param result growing array of plane intersections
     * @return number of intersections appended to the array.
    */
    appendPlaneIntersectionPoints(plane, result) {
        const numPole = this.numPoles;
        const order = this.order;
        const allCoffs = new Float64Array(numPole);
        const numSpan = this.numSpan;
        const point4d = Point4d_1.Point4d.create();
        // compute all pole altitudes from the plane
        const minMax = Range_1.Range1d.createNull();
        // Put the altitudes of all the bspline poles in one array.
        for (let i = 0; i < numPole; i++) {
            allCoffs[i] = plane.weightedAltitude(this.getPolePoint4d(i, point4d));
            minMax.extendX(allCoffs[i]);
        }
        // A univariate bspline through the altitude poles gives altitude as function of the bspline knot.
        // The (bspline) altitude function for each span is `order` consecutive altitudes.
        // If those altitudes bracket zero, the span may potentially have a crossing.
        // When that occurs,
        let univariateBezier;
        let numFound = 0;
        let previousFraction = -1000.0;
        if (minMax.containsX(0.0)) {
            for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
                if (this._bcurve.knots.isIndexOfRealSpan(spanIndex)) { // ignore trivial knot intervals.
                    // outer range test ...
                    minMax.setNull();
                    minMax.extendArraySubset(allCoffs, spanIndex, order);
                    if (minMax.containsX(0.0)) {
                        // pack the bspline support into a univariate bezier ...
                        univariateBezier = BezierPolynomials_1.UnivariateBezier.createArraySubset(allCoffs, spanIndex, order, univariateBezier);
                        // saturate and solve the bezier
                        Bezier1dNd_1.Bezier1dNd.saturate1dInPlace(univariateBezier.coffs, this._bcurve.knots, spanIndex);
                        const roots = univariateBezier.roots(0.0, true);
                        if (roots) {
                            for (const spanFraction of roots) {
                                // promote each local bezier fraction to global fraction.
                                // save the curve evaluation at that fraction.
                                numFound++;
                                const fraction = this._bcurve.knots.spanFractionToFraction(spanIndex, spanFraction);
                                if (!Geometry_1.Geometry.isAlmostEqualNumber(fraction, previousFraction)) {
                                    const detail = CurveLocationDetail_1.CurveLocationDetail.createCurveEvaluatedFraction(this, fraction);
                                    detail.intervalRole = CurveLocationDetail_1.CurveIntervalRole.isolated;
                                    result.push(detail);
                                    previousFraction = fraction;
                                }
                            }
                        }
                    }
                }
            }
        }
        return numFound;
    }
}
exports.BSplineCurve3dBase = BSplineCurve3dBase;
/**
 * A BSplineCurve3d is a bspline curve whose poles are Point3d.
 * See BSplineCurve3dBase for description of knots, order, degree.
 * @public
 */
class BSplineCurve3d extends BSplineCurve3dBase {
    constructor(numPoles, order, knots) {
        super(3, numPoles, order, knots);
    }
    initializeWorkBezier() {
        if (this._workBezier === undefined)
            this._workBezier = BezierCurve3dH_1.BezierCurve3dH.createOrder(this.order);
        return this._workBezier;
    }
    /** test of `other` is an instance of BSplineCurve3d */
    isSameGeometryClass(other) { return other instanceof BSplineCurve3d; }
    /** Apply `transform` to the poles. */
    tryTransformInPlace(transform) { PointHelpers_1.Point3dArray.multiplyInPlace(transform, this._bcurve.packedData); return true; }
    /** Get a pole as simple Point3d. */
    getPolePoint3d(poleIndex, result) {
        const k = this.poleIndexToDataIndex(poleIndex);
        if (k !== undefined) {
            const data = this._bcurve.packedData;
            return Point3dVector3d_1.Point3d.create(data[k], data[k + 1], data[k + 2], result);
        }
        return undefined;
    }
    /** Get a pole as Point4d with weight 1 */
    getPolePoint4d(poleIndex, result) {
        const k = this.poleIndexToDataIndex(poleIndex);
        if (k !== undefined) {
            const data = this._bcurve.packedData;
            return Point4d_1.Point4d.create(data[k], data[k + 1], data[k + 2], 1.0, result);
        }
        return undefined;
    }
    /** Convert  `spanIndex` and `localFraction` to a knot. */
    spanFractionToKnot(span, localFraction) {
        return this._bcurve.spanFractionToKnot(span, localFraction);
    }
    /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */
    copyPoints() { return PointHelpers_1.Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData, 3); }
    /** Return a simple array of the control points coordinates */
    copyPointsFloat64Array() { return this._bcurve.packedData.slice(); }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(includeExtraEndKnot) { return this._bcurve.knots.copyKnots(includeExtraEndKnot); }
    /** Create a bspline with uniform knots. */
    static createUniformKnots(poles, order) {
        const numPoles = poles instanceof Float64Array ? poles.length / 3 : poles.length;
        if (order < 1 || numPoles < order)
            return undefined;
        const knots = KnotVector_1.KnotVector.createUniformClamped(numPoles, order - 1, 0.0, 1.0);
        const curve = new BSplineCurve3d(numPoles, order, knots);
        if (poles instanceof Float64Array) {
            for (let i = 0; i < 3 * numPoles; i++)
                curve._bcurve.packedData[i] = poles[i];
        }
        else if (poles instanceof GrowableXYZArray_1.GrowableXYZArray) {
            curve._bcurve.packedData = poles.float64Data().slice(0, 3 * numPoles);
        }
        else {
            let i = 0;
            for (const p of poles) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
            }
        }
        return curve;
    }
    /** Create a bspline with given knots.
     *
     * *  Two count conditions are recognized:
     *
     * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.
     *
     */
    static create(poleArray, knotArray, order) {
        let numPoles = poleArray.length;
        if (poleArray instanceof Float64Array) {
            numPoles /= 3; // blocked as xyz
        }
        const numKnots = knotArray.length;
        // shift knots-of-interest limits for overclamped case ...
        const skipFirstAndLast = (numPoles + order === numKnots);
        if (order < 1 || numPoles < order)
            return undefined;
        const knots = KnotVector_1.KnotVector.create(knotArray, order - 1, skipFirstAndLast);
        const curve = new BSplineCurve3d(numPoles, order, knots);
        if (poleArray instanceof Float64Array) {
            let i = 0;
            for (const coordinate of poleArray) {
                curve._bcurve.packedData[i++] = coordinate;
            }
        }
        else {
            let i = 0;
            for (const p of poleArray) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
            }
        }
        return curve;
    }
    /** Return a deep clone */
    clone() {
        const knotVector1 = this._bcurve.knots.clone();
        const curve1 = new BSplineCurve3d(this.numPoles, this.order, knotVector1);
        curve1._bcurve.packedData = this._bcurve.packedData.slice();
        return curve1;
    }
    /** Return a transformed deep clone. */
    cloneTransformed(transform) {
        const curve1 = this.clone();
        curve1.tryTransformInPlace(transform);
        return curve1;
    }
    /** Evaluate at a position given by fractional position within a span. */
    evaluatePointInSpan(spanIndex, spanFraction) {
        this._bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);
        return Point3dVector3d_1.Point3d.createFrom(this._bcurve.poleBuffer);
    }
    /** Evaluate point and derivative vector at a position given by fractional position within a span.
     * * The derivative is with respect to the span fraction (NOT scaled to either global fraction or knot)
     */
    evaluatePointAndDerivativeInSpan(spanIndex, spanFraction) {
        this._bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);
        return Ray3d_1.Ray3d.createCapture(Point3dVector3d_1.Point3d.createFrom(this._bcurve.poleBuffer), Point3dVector3d_1.Vector3d.createFrom(this._bcurve.poleBuffer1));
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPoint(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u);
        return Point3dVector3d_1.Point3d.createFrom(this._bcurve.poleBuffer, result);
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPointAndDerivative(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u, 1);
        if (!result)
            return Ray3d_1.Ray3d.createCapture(Point3dVector3d_1.Point3d.createFrom(this._bcurve.poleBuffer), Point3dVector3d_1.Vector3d.createFrom(this._bcurve.poleBuffer1));
        result.origin.setFrom(this._bcurve.poleBuffer);
        result.direction.setFrom(this._bcurve.poleBuffer1);
        return result;
    }
    /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */
    knotToPointAnd2Derivatives(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u, 2);
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(this._bcurve.poleBuffer[0], this._bcurve.poleBuffer[1], this._bcurve.poleBuffer[2], this._bcurve.poleBuffer1[0], this._bcurve.poleBuffer1[1], this._bcurve.poleBuffer1[2], this._bcurve.poleBuffer2[0], this._bcurve.poleBuffer2[1], this._bcurve.poleBuffer2[2], result);
    }
    /** Evaluate the curve point at a fractional of the entire knot range. */
    fractionToPoint(fraction, result) {
        return this.knotToPoint(this._bcurve.knots.fractionToKnot(fraction), result);
    }
    /** Evaluate the curve point at a fractional of the entire knot range. */
    fractionToPointAndDerivative(fraction, result) {
        const knot = this._bcurve.knots.fractionToKnot(fraction);
        result = this.knotToPointAndDerivative(knot, result);
        result.direction.scaleInPlace(this._bcurve.knots.knotLength01);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the arc
     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.
     * If the arc is circular, the second derivative is directly towards the center
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const knot = this._bcurve.knots.fractionToKnot(fraction);
        result = this.knotToPointAnd2Derivatives(knot, result);
        const a = this._bcurve.knots.knotLength01;
        result.vectorU.scaleInPlace(a);
        result.vectorV.scaleInPlace(a * a);
        return result;
    }
    /** test if almost the same curve as `other` */
    isAlmostEqual(other) {
        if (other instanceof BSplineCurve3d) {
            return this._bcurve.knots.isAlmostEqual(other._bcurve.knots)
                && PointHelpers_1.Point3dArray.isAlmostEqual(this._bcurve.packedData, other._bcurve.packedData);
        }
        return false;
    }
    /** test if this curve is entirely within plane. */
    isInPlane(plane) {
        return PointHelpers_1.Point3dArray.isCloseToPlane(this._bcurve.packedData, plane);
    }
    /** Return the control polygon length as approximation (always overestimate) of the curve length. */
    quickLength() { return PointHelpers_1.Point3dArray.sumEdgeLengths(this._bcurve.packedData); }
    /** Emit beziers or strokes (selected by the stroke options) to the handler. */
    emitStrokableParts(handler, options) {
        const needBeziers = handler.announceBezierCurve !== undefined;
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        let numStrokes;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dOr3dH(spanIndex, false, workBezier);
            if (bezier) {
                numStrokes = bezier.computeStrokeCountForOptions(options);
                if (needBeziers) {
                    handler.announceBezierCurve(bezier, numStrokes, this, spanIndex, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));
                }
                else {
                    handler.announceIntervalForUniformStepStrokes(this, numStrokes, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));
                }
            }
        }
    }
    /**
     * Assess length and turn to determine a stroke count.
     * @param options stroke options structure.
     */
    computeStrokeCountForOptions(options) {
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        let numStroke = 0;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);
            if (bezier)
                numStroke += bezier.computeStrokeCountForOptions(options);
        }
        return numStroke;
    }
    /**
     * Compute individual segment stroke counts.  Attach in a StrokeCountMap.
     * @param options StrokeOptions that determine count
     * @param parentStrokeMap evolving parent map.
     * @alpha
     */
    computeAndAttachRecursiveStrokeCounts(options, parentStrokeMap) {
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        const myData = StrokeCountMap_1.StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);
            if (bezier) {
                const segmentLength = workBezier.curveLength();
                const numStrokeOnSegment = workBezier.computeStrokeCountForOptions(options);
                myData.addToCountAndLength(numStrokeOnSegment, segmentLength);
            }
        }
        CurvePrimitive_1.CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);
    }
    /** Append strokes to a linestring. */
    emitStrokes(dest, options) {
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);
            if (bezier)
                bezier.emitStrokes(dest, options);
        }
    }
    /**
     * Test knots, control points, and wrappable flag to see if all agree for a possible wrapping.
     * @returns the manner of closing.   Se BSplineWrapMode for particulars of each mode.
     *
     */
    get isClosable() {
        const mode = this._bcurve.knots.wrappable;
        if (mode === KnotVector_1.BSplineWrapMode.None)
            return KnotVector_1.BSplineWrapMode.None;
        if (!this._bcurve.knots.testClosable(mode))
            return KnotVector_1.BSplineWrapMode.None;
        if (!this._bcurve.testCloseablePolygon(mode))
            return KnotVector_1.BSplineWrapMode.None;
        return mode;
    }
    /**
     * Return a BezierCurveBase for this curve.  The concrete return type may be BezierCurve3d or BezierCurve3dH according to this type.
     * @param spanIndex
     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.
     */
    getSaturatedBezierSpan3dOr3dH(spanIndex, prefer3dH, result) {
        if (prefer3dH)
            return this.getSaturatedBezierSpan3dH(spanIndex, result);
        return this.getSaturatedBezierSpan3d(spanIndex, result);
    }
    /**
     * Return a CurvePrimitive (which is a BezierCurve3d) for a specified span of this curve.
     * @param spanIndex
     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.
     */
    getSaturatedBezierSpan3d(spanIndex, result) {
        if (spanIndex < 0 || spanIndex >= this.numSpan)
            return undefined;
        const order = this.order;
        if (result === undefined || !(result instanceof BezierCurve3d_1.BezierCurve3d) || result.order !== order)
            result = BezierCurve3d_1.BezierCurve3d.createOrder(order);
        const bezier = result;
        bezier.loadSpanPoles(this._bcurve.packedData, spanIndex);
        if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))
            return result;
        return undefined;
    }
    /**
     * Return a CurvePrimitive (which is a BezierCurve3dH) for a specified span of this curve.
     * @param spanIndex
     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.
     */
    getSaturatedBezierSpan3dH(spanIndex, result) {
        if (spanIndex < 0 || spanIndex >= this.numSpan)
            return undefined;
        const order = this.order;
        if (result === undefined || !(result instanceof BezierCurve3dH_1.BezierCurve3dH) || result.order !== order)
            result = BezierCurve3dH_1.BezierCurve3dH.createOrder(order);
        const bezier = result;
        bezier.loadSpan3dPolesWithWeight(this._bcurve.packedData, spanIndex, 1.0);
        if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))
            return bezier;
        return undefined;
    }
    /**
     * Set the flag indicating the bspline might be suitable for having wrapped "closed" interpretation.
     */
    setWrappable(value) {
        this._bcurve.knots.wrappable = value;
    }
    /** Second step of double dispatch:  call `handler.handleBSplineCurve3d(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineCurve3d(this);
    }
    /**
     * Extend a range so in includes the range of this curve
     * * REMARK: this is based on the poles, not the exact curve.  This is generally larger than the true curve range.
     * @param rangeToExtend
     * @param transform transform to apply to points as they are entered into the range.
     */
    extendRange(rangeToExtend, transform) {
        const buffer = this._bcurve.packedData;
        const n = buffer.length - 2;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += 3)
                rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
        else {
            for (let i0 = 0; i0 < n; i0 += 3)
                rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
    }
}
exports.BSplineCurve3d = BSplineCurve3d;


/***/ }),

/***/ "./lib/bspline/BSplineCurve3dH.js":
/*!****************************************!*\
  !*** ./lib/bspline/BSplineCurve3dH.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const KnotVector_1 = __webpack_require__(/*! ./KnotVector */ "./lib/bspline/KnotVector.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const BezierCurve3dH_1 = __webpack_require__(/*! ./BezierCurve3dH */ "./lib/bspline/BezierCurve3dH.js");
const BSplineCurve_1 = __webpack_require__(/*! ./BSplineCurve */ "./lib/bspline/BSplineCurve.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const StrokeCountMap_1 = __webpack_require__(/*! ../curve/Query/StrokeCountMap */ "./lib/curve/Query/StrokeCountMap.js");
/**
 * Weighted (Homogeneous) BSplineCurve in 3d
 * @public
 */
class BSplineCurve3dH extends BSplineCurve_1.BSplineCurve3dBase {
    constructor(numPoles, order, knots) {
        super(4, numPoles, order, knots);
    }
    initializeWorkBezier() {
        if (this._workBezier === undefined)
            this._workBezier = BezierCurve3dH_1.BezierCurve3dH.createOrder(this.order);
        return this._workBezier;
    }
    /** Test if `other` is an instance of `BSplineCurve3dH` */
    isSameGeometryClass(other) { return other instanceof BSplineCurve3dH; }
    /** Apply `transform` to the curve */
    tryTransformInPlace(transform) { PointHelpers_1.Point4dArray.multiplyInPlace(transform, this._bcurve.packedData); return true; }
    /** Get a pole, normalized to Point3d. */
    getPolePoint3d(poleIndex, result) {
        const k = this.poleIndexToDataIndex(poleIndex);
        if (k !== undefined) {
            const data = this._bcurve.packedData;
            const divW = Geometry_1.Geometry.conditionalDivideFraction(1.0, data[k + 3]);
            if (divW !== undefined)
                return Point3dVector3d_1.Point3d.create(data[k] * divW, data[k + 1] * divW, data[k + 2] * divW, result);
        }
        return undefined;
    }
    /** Get a pole as Point4d */
    getPolePoint4d(poleIndex, result) {
        const k = this.poleIndexToDataIndex(poleIndex);
        if (k !== undefined) {
            const data = this._bcurve.packedData;
            return Point4d_1.Point4d.create(data[k], data[k + 1], data[k + 2], data[k + 3], result);
        }
        return undefined;
    }
    /** map a spanIndex and fraction to a knot value. */
    spanFractionToKnot(span, localFraction) {
        return this._bcurve.spanFractionToKnot(span, localFraction);
    }
    /** Return a simple array of arrays with the control points as `[[x,y,z,w],[x,y,z,w],..]` */
    copyPoints() { return PointHelpers_1.Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData, 4); }
    /** Return a simple array of the control points coordinates */
    copyPointsFloat64Array() { return this._bcurve.packedData.slice(); }
    /** Create a bspline with uniform knots.
     * * Control points may be supplied as:
     *   * array of Point4d, with weight already multiplied into the `[wx,wy,wz,w]`
     *   * array of Point3d, with implied weight 1.
     *   * Float64Array, blocked as xyzw, i.e. 4 doubles per control point.
     * @param controlPoints pole data in array form as noted above.
     * @param order  curve order (1 more than degree)
     */
    static createUniformKnots(controlPoints, order) {
        const numPoles = (controlPoints instanceof Float64Array) ? controlPoints.length / 4 : controlPoints.length;
        if (order < 1 || numPoles < order)
            return undefined;
        const knots = KnotVector_1.KnotVector.createUniformClamped(controlPoints.length, order - 1, 0.0, 1.0);
        const curve = new BSplineCurve3dH(numPoles, order, knots);
        let i = 0;
        if (controlPoints[0] instanceof Point3dVector3d_1.Point3d) {
            for (const p of controlPoints) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
                curve._bcurve.packedData[i++] = 1.0;
            }
        }
        else if (controlPoints[0] instanceof Point4d_1.Point4d) {
            for (const p of controlPoints) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
                curve._bcurve.packedData[i++] = p.w;
            }
        }
        else if (controlPoints instanceof Float64Array) {
            const qPoles = controlPoints;
            const numQ = qPoles.length;
            for (let k = 0; k < numQ; k++) {
                curve._bcurve.packedData[k] = qPoles[k];
            }
        }
        else {
            return undefined;
        }
        return curve;
    }
    /** Create a bspline with given knots.
     *
     * *  Two count conditions are recognized:
     *
     * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.
     *
     */
    static create(controlPoints, knotArray, order) {
        let numPoles = controlPoints.length;
        if (controlPoints instanceof Float64Array) {
            numPoles /= 4; // blocked as xyz
        }
        const numKnots = knotArray.length;
        // shift knots-of-interest limits for overclamped case ...
        const skipFirstAndLast = (numPoles + order === numKnots);
        if (order < 1 || numPoles < order)
            return undefined;
        const knots = KnotVector_1.KnotVector.create(knotArray, order - 1, skipFirstAndLast);
        const curve = new BSplineCurve3dH(numPoles, order, knots);
        if (controlPoints instanceof Float64Array) {
            let i = 0;
            for (const coordinate of controlPoints) {
                curve._bcurve.packedData[i++] = coordinate;
            }
        }
        else if (controlPoints[0] instanceof Point4d_1.Point4d) {
            let i = 0;
            for (const p of controlPoints) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
                curve._bcurve.packedData[i++] = p.w;
            }
        }
        else if (controlPoints[0] instanceof Point3dVector3d_1.Point3d) {
            let i = 0;
            for (const p of controlPoints) {
                curve._bcurve.packedData[i++] = p.x;
                curve._bcurve.packedData[i++] = p.y;
                curve._bcurve.packedData[i++] = p.z;
                curve._bcurve.packedData[i++] = 1.0;
            }
        }
        return curve;
    }
    /** Return a deep clone of this curve. */
    clone() {
        const knotVector1 = this._bcurve.knots.clone();
        const curve1 = new BSplineCurve3dH(this.numPoles, this.order, knotVector1);
        curve1._bcurve.packedData = this._bcurve.packedData.slice();
        return curve1;
    }
    /** Clone the curve and apply a transform to the clone. */
    cloneTransformed(transform) {
        const curve1 = this.clone();
        curve1.tryTransformInPlace(transform);
        return curve1;
    }
    /** Evaluate at a position given by fractional position within a span. */
    evaluatePointInSpan(spanIndex, spanFraction, result) {
        this._bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);
        const xyzw = this._bcurve.poleBuffer;
        return Point4d_1.Point4d.createRealPoint3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], result);
    }
    /** Evaluate at a position given by fractional position within a span. */
    evaluatePointAndDerivativeInSpan(spanIndex, spanFraction, result) {
        this._bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);
        const xyzw = this._bcurve.poleBuffer;
        const dXYZW = this._bcurve.poleBuffer1;
        return Point4d_1.Point4d.createRealDerivativeRay3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], dXYZW[0], dXYZW[1], dXYZW[2], dXYZW[3], result);
    }
    /** Evaluate at a position given by a knot value. */
    knotToPoint(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u);
        const xyzw = this._bcurve.poleBuffer;
        return Point4d_1.Point4d.createRealPoint3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], result);
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPointAndDerivative(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u, 1);
        const xyzw = this._bcurve.poleBuffer;
        const dXYZW = this._bcurve.poleBuffer1;
        return Point4d_1.Point4d.createRealDerivativeRay3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], dXYZW[0], dXYZW[1], dXYZW[2], dXYZW[3], result);
    }
    /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */
    knotToPointAnd2Derivatives(u, result) {
        this._bcurve.evaluateBuffersAtKnot(u, 2);
        const xyzw = this._bcurve.poleBuffer;
        const dXYZW = this._bcurve.poleBuffer1;
        const ddXYZW = this._bcurve.poleBuffer2;
        return Point4d_1.Point4d.createRealDerivativePlane3dByOriginAndVectorsDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], dXYZW[0], dXYZW[1], dXYZW[2], dXYZW[3], ddXYZW[0], ddXYZW[1], ddXYZW[2], ddXYZW[3], result);
    }
    /** test if the curve is almost equal to `other` */
    isAlmostEqual(other) {
        if (other instanceof BSplineCurve3dH) {
            return this._bcurve.knots.isAlmostEqual(other._bcurve.knots)
                && PointHelpers_1.Point4dArray.isAlmostEqual(this._bcurve.packedData, other._bcurve.packedData);
        }
        return false;
    }
    /** Test if the curve is entirely within a plane. */
    isInPlane(plane) {
        return PointHelpers_1.Point4dArray.isCloseToPlane(this._bcurve.packedData, plane);
    }
    /** Return the control polygon length as quick approximation to the curve length. */
    quickLength() { return PointHelpers_1.Point3dArray.sumEdgeLengths(this._bcurve.packedData); }
    /** call a handler with interval data for stroking. */
    emitStrokableParts(handler, options) {
        const needBeziers = handler.announceBezierCurve;
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        let numStrokes;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dOr3dH(spanIndex, false, workBezier);
            if (bezier) {
                numStrokes = bezier.computeStrokeCountForOptions(options);
                if (needBeziers) {
                    handler.announceBezierCurve(bezier, numStrokes, this, spanIndex, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));
                }
                else {
                    handler.announceIntervalForUniformStepStrokes(this, numStrokes, this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0), this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));
                }
            }
        }
    }
    /**  Append stroked approximation of this curve to the linestring. */
    emitStrokes(dest, options) {
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);
            if (bezier)
                bezier.emitStrokes(dest, options);
        }
    }
    /**
     * Assess length and turn to determine a stroke count.
     * @param options stroke options structure.
     */
    computeStrokeCountForOptions(options) {
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        let numStroke = 0;
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);
            if (bezier)
                numStroke += bezier.computeStrokeCountForOptions(options);
        }
        return numStroke;
    }
    /**
     * Compute individual segment stroke counts.  Attach in a StrokeCountMap.
     * @param options StrokeOptions that determine count
     * @param parentStrokeMap evolving parent map.
     */
    computeAndAttachRecursiveStrokeCounts(options, parentStrokeMap) {
        const workBezier = this.initializeWorkBezier();
        const numSpan = this.numSpan;
        const myData = StrokeCountMap_1.StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);
        for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {
            const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);
            if (bezier) {
                const segmentLength = workBezier.curveLength();
                const numStrokeOnSegment = workBezier.computeStrokeCountForOptions(options);
                myData.addToCountAndLength(numStrokeOnSegment, segmentLength);
            }
        }
        CurvePrimitive_1.CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);
    }
    /**
     * return true if the spline is (a) unclamped with (degree-1) matching knot intervals,
     * (b) (degree-1) wrapped points,
     * (c) marked wrappable from construction time.
     */
    get isClosable() {
        if (!this._bcurve.knots.wrappable)
            return false;
        const degree = this.degree;
        const leftKnotIndex = this._bcurve.knots.leftKnotIndex;
        const rightKnotIndex = this._bcurve.knots.rightKnotIndex;
        const period = this._bcurve.knots.rightKnot - this._bcurve.knots.leftKnot;
        const indexDelta = rightKnotIndex - leftKnotIndex;
        for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {
            const k1 = k0 + indexDelta;
            if (!Geometry_1.Geometry.isSameCoordinate(this._bcurve.knots.knots[k0] + period, this._bcurve.knots.knots[k1]))
                return false;
        }
        const poleIndexDelta = this.numPoles - this.degree;
        for (let p0 = 0; p0 < degree; p0++) {
            const p1 = p0 + poleIndexDelta;
            if (!Geometry_1.Geometry.isSamePoint3d(this.getPolePoint3d(p0), this.getPolePoint3d(p1)))
                return false;
        }
        return true;
    }
    /**
     * Return a CurvePrimitive (which is a BezierCurve3dH) for a specified span of this curve.
     * @param spanIndex
     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.
     */
    getSaturatedBezierSpan3dH(spanIndex, result) {
        if (spanIndex < 0 || spanIndex >= this.numSpan)
            return undefined;
        const order = this.order;
        if (result === undefined || !(result instanceof BezierCurve3dH_1.BezierCurve3dH) || result.order !== order)
            result = BezierCurve3dH_1.BezierCurve3dH.createOrder(order);
        const bezier = result;
        bezier.loadSpan4dPoles(this._bcurve.packedData, spanIndex);
        if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))
            return result;
        return undefined;
    }
    /**
     * Return a BezierCurveBase for this curve.  Because BSplineCurve3dH is homogeneous, the returned BezierCurveBase is always homogeneous.
     * @param spanIndex
     * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3dH with matching order.
     */
    getSaturatedBezierSpan3dOr3dH(spanIndex, _prefer3dH, result) {
        return this.getSaturatedBezierSpan3dH(spanIndex, result);
    }
    /** Second step of double dispatch:  call `handler.handleBSplineCurve3dH(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineCurve3dH(this);
    }
    /**
     * Extend a range so in includes the range of this curve
     * * REMARK: this is based on the poles, not the exact curve.  This is generally larger than the true curve range.
     * @param rangeToExtend
     * @param transform transform to apply to points as they are entered into the range.
     */
    extendRange(rangeToExtend, transform) {
        const buffer = this._bcurve.packedData;
        const n = buffer.length - 3;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += 4)
                rangeToExtend.extendTransformedXYZW(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2], buffer[i0 + 3]);
        }
        else {
            for (let i0 = 0; i0 < n; i0 += 4)
                rangeToExtend.extendXYZW(buffer[i0], buffer[i0 + 1], buffer[i0 + 2], buffer[i0 + 3]);
        }
    }
}
exports.BSplineCurve3dH = BSplineCurve3dH;


/***/ }),

/***/ "./lib/bspline/BSplineSurface.js":
/*!***************************************!*\
  !*** ./lib/bspline/BSplineSurface.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const KnotVector_1 = __webpack_require__(/*! ./KnotVector */ "./lib/bspline/KnotVector.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const GeometryQuery_1 = __webpack_require__(/*! ../curve/GeometryQuery */ "./lib/curve/GeometryQuery.js");
/**
 * UVSelect is an integer indicating uDirection (0) or vDirection (1) in a bspline surface parameterization.
 * @public
 */
var UVSelect;
(function (UVSelect) {
    /** index of u direction */
    UVSelect[UVSelect["uDirection"] = 0] = "uDirection";
    /** index of v direction */
    UVSelect[UVSelect["VDirection"] = 1] = "VDirection";
})(UVSelect = exports.UVSelect || (exports.UVSelect = {}));
/**
 * Enumeration of how weights are carried
 * * UnWeighted (0) -- there are no weights
 * * WeightsAlreadyAppliedToCoordinates (1) -- for real point (x,y,z) the homogeneous point has weight applied throughout as (wx,wy,wz,w)
 * * WeightsSeparateFromCoordinates (2) -- for real point (x,y,z) the homogeneous point is (x,y,z,w)
 *   * Note that "internal" computations never use WeightsSeparateFromCoordinates.
 *   * WeightsSeparateFromCoordinates is only useful as input or output state in serializers.
 * @public
 */
var WeightStyle;
(function (WeightStyle) {
    /** There are no weights. */
    WeightStyle[WeightStyle["UnWeighted"] = 0] = "UnWeighted";
    /**
     * * Data is weighted
     * * point with normalized coordinate `[x,y,z]` and weight `w` has weights already multiplied in as `[x*w,y*w,z*w,w]`
     * */
    WeightStyle[WeightStyle["WeightsAlreadyAppliedToCoordinates"] = 1] = "WeightsAlreadyAppliedToCoordinates";
    /**
     * * Data is weighted
     * * point with normalized coordinate `[x,y,z]` and weight `w` has is `[x,y,z,w]`
     * */
    WeightStyle[WeightStyle["WeightsSeparateFromCoordinates"] = 2] = "WeightsSeparateFromCoordinates";
})(WeightStyle = exports.WeightStyle || (exports.WeightStyle = {}));
/** Bspline knots and poles for 2d-to-Nd.
 * * This abstract class in not independently instantiable -- GeometryQuery methods must be implemented by derived classes.
 * @public
 */
class BSpline2dNd extends GeometryQuery_1.GeometryQuery {
    /**
     * initialize arrays for given spline dimensions.
     */
    constructor(numPolesU, numPolesV, poleLength, knotsU, knotsV) {
        super();
        /** String name for schema properties */
        this.geometryCategory = "bsurf";
        const orderU = knotsU.degree + 1;
        const orderV = knotsV.degree + 1;
        this.knots = [knotsU, knotsV];
        this.coffs = new Float64Array(numPolesU * numPolesV * poleLength);
        this.poleDimension = poleLength;
        this._basisBufferUV = [new Float64Array(orderU), new Float64Array(orderV)];
        this._basisBuffer1UV = [new Float64Array(orderU), new Float64Array(orderV)];
        this._numPoles = [numPolesU, numPolesV];
        this._poleBuffer = new Float64Array(poleLength);
        this._poleBuffer1UV = [new Float64Array(poleLength), new Float64Array(poleLength)];
    }
    /** Return the degree (one less than order) for the `select` direction (0 or 1) */
    degreeUV(select) { return this.knots[select].degree; }
    /** Return the order (one more than degree) for the `select` direction (0 or 1) */
    orderUV(select) { return this.knots[select].degree + 1; }
    /** Return the number of spans (INCLUDING NULL SPANS) for the `select` direction (0 or 1) */
    numSpanUV(select) { return this._numPoles[select] - this.knots[select].degree; }
    /** Return the total number of poles (product of x and y pole counts) */
    numPolesTotal() { return this.coffs.length / this.poleDimension; }
    /** Return the number of poles for the `select` direction (0 or 1) */
    numPolesUV(select) { return this._numPoles[select]; }
    /** Return the step between adjacent poles for the `select` direction (0 or 1) */
    poleStepUV(select) { return select === 0 ? 1 : this._numPoles[0]; }
    /** Confirm that order and pole counts agree for both u and v directions */
    static validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numUV) {
        if (orderU < 2 || numPolesU < orderU)
            return false;
        if (orderV < 2 || numPolesV < orderV)
            return false;
        if (numPolesU * numPolesV !== numUV)
            return false;
        return true;
    }
    /** Get the Point3d by row and column.
     * * (IMPORTANT) This assumes this is an xyz surface.  Data will be incorrect if this is an xyzw surface.
     */
    getPoint3dPole(i, j, result) {
        return Point3dVector3d_1.Point3d.createFromPacked(this.coffs, i + j * this._numPoles[0], result);
    }
    /** Get the Point3d by row and column, projecting the weight away to get to xyz
     * * (IMPORTANT) This assumes this is an xyzw surface.  Data will be incorrect if this is an xyz surface.
     */
    getPoint3dPoleXYZW(i, j, result) {
        return Point3dVector3d_1.Point3d.createFromPackedXYZW(this.coffs, i + j * this._numPoles[0], result);
    }
    /**
     * Return 0 for 0 input, 1 for any nonzero input.
     * @param value numeric value to convert to strict 0 or 1.
     */
    numberToUVSelect(value) { return value === 0 ? 0 : 1; }
    /** extend a range, treating each block as simple XYZ */
    extendRangeXYZ(rangeToExtend, transform) {
        const buffer = this.coffs;
        const pd = this.poleDimension;
        const n = buffer.length + 1 - pd;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += pd)
                rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
        else {
            for (let i0 = 0; i0 < n; i0 += pd)
                rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);
        }
    }
    /** extend a range, treating each block as homogeneous xyzw, with weight at offset 3 */
    extendRangeXYZH(rangeToExtend, transform) {
        const buffer = this.coffs;
        const pd = this.poleDimension;
        const n = buffer.length + 1 - pd;
        let w = 0;
        let divW = 0;
        if (transform) {
            for (let i0 = 0; i0 < n; i0 += pd) {
                w = buffer[i0 + 3];
                if (w !== 0.0) {
                    divW = 1.0 / w;
                    rangeToExtend.extendTransformedXYZ(transform, buffer[i0] * divW, buffer[i0 + 1] * divW, buffer[i0 + 2] * divW);
                }
            }
        }
        else {
            for (let i0 = 0; i0 < n; i0 += pd) {
                w = buffer[i0 + 3];
                if (w !== 0.0) {
                    divW = 1.0 / w;
                    rangeToExtend.extendXYZ(buffer[i0] * divW, buffer[i0 + 1] * divW, buffer[i0 + 2] * divW);
                }
            }
        }
    }
    /**
     * evaluate the surface at u and v fractions. Return a (squared, right handed) coordinate frame at that point on the surface.
     * @param fractionU u parameter
     * @param fractionV v parameter
     * @param result undefined if surface derivatives are parallel (or either alone is zero)
     */
    fractionToRigidFrame(fractionU, fractionV, result) {
        const skewVectors = this.fractionToPointAndDerivatives(fractionU, fractionV);
        if (!skewVectors)
            return undefined;
        const axes = Matrix3d_1.Matrix3d.createColumnsInAxisOrder(Geometry_1.AxisOrder.XYZ, skewVectors.vectorU, skewVectors.vectorV, undefined);
        const axes1 = Matrix3d_1.Matrix3d.createRigidFromMatrix3d(axes, Geometry_1.AxisOrder.XYZ, axes);
        if (axes1)
            result = Transform_1.Transform.createOriginAndMatrix(skewVectors.origin, axes1, result);
        return result;
    }
    /**
     * Map a position, specified as (uv direction, bezier span, fraction within the bezier), to an overall knot value.
     * @param select selector indicating U or V direction.
     * @param span index of bezier span
     * @param localFraction fractional coordinate within the bezier span
     */
    spanFractionToKnot(select, span, localFraction) {
        return this.knots[select].spanFractionToKnot(span, localFraction);
    }
    /** Evaluate basis functions given
     * * choice of u or v
     * * span index
     * * local fraction within the span.
     */
    spanFractionsToBasisFunctions(select, spanIndex, spanFraction, f, df) {
        spanIndex = Geometry_1.Geometry.clampToStartEnd(spanIndex, 0, this.numSpanUV(select));
        const knotIndex0 = spanIndex + this.degreeUV(select) - 1;
        const globalKnot = this.knots[select].baseKnotFractionToKnot(knotIndex0, spanFraction);
        return df ?
            this.knots[select].evaluateBasisFunctions1(knotIndex0, globalKnot, f, df) :
            this.knots[select].evaluateBasisFunctions(knotIndex0, globalKnot, f);
    }
    /** sum poles by the weights in the basisBuffer, using poles for given span */
    sumPoleBufferForSpan(spanIndexU, spanIndexV) {
        const poleBuffer = this._poleBuffer;
        const coffs = this.coffs;
        poleBuffer.fill(0);
        const m = this.poleDimension;
        const stepV = this.poleDimension * this._numPoles[0];
        let kU = m * spanIndexU + spanIndexV * stepV;
        let g = 0;
        for (const fV of this._basisBufferUV[1]) {
            let k = kU;
            for (const fU of this._basisBufferUV[0]) {
                g = fU * fV;
                for (let j = 0; j < m; j++) {
                    poleBuffer[j] += g * coffs[k++];
                }
            }
            kU += stepV;
        }
    }
    /** sum derivatives by the weights in the basisBuffer, using poles for given span */
    sumpoleBufferDerivativesForSpan(spanIndexU, spanIndexV) {
        const poleBuffer1U = this._poleBuffer1UV[0];
        const poleBuffer1V = this._poleBuffer1UV[1];
        poleBuffer1U.fill(0);
        poleBuffer1V.fill(0);
        const m = this.poleDimension;
        const stepV = this.poleDimension * this._numPoles[0];
        let kU = m * spanIndexU + spanIndexV * stepV;
        // U partial derivatives ...
        let g = 0;
        for (const fV of this._basisBufferUV[1]) {
            let k = kU;
            for (const fU of this._basisBuffer1UV[0]) {
                g = fU * fV;
                for (let j = 0; j < m; j++) {
                    poleBuffer1U[j] += g * this.coffs[k++];
                }
            }
            kU += stepV;
        }
        // V partial derivatives ...
        kU = m * spanIndexU + spanIndexV * stepV;
        for (const fV of this._basisBuffer1UV[1]) {
            let k = kU;
            for (const fU of this._basisBufferUV[0]) {
                g = fU * fV;
                for (let j = 0; j < m; j++) {
                    poleBuffer1V[j] += g * this.coffs[k++];
                }
            }
            kU += stepV;
        }
    }
    /**
     * Evaluate the _basisBuffer, _poleBuffer and (optionally) _basisBuffer1 and _poleBuffer1 arrays at given knot.
     *
     * @param u u knot value
     * @param v v not value
     * @param numDerivative number of derivatives needed
     */
    evaluateBuffersAtKnot(u, v, numDerivative = 0) {
        const knotIndex0U = this.knots[0].knotToLeftKnotIndex(u);
        const knotIndex0V = this.knots[1].knotToLeftKnotIndex(v);
        const poleIndex0U = knotIndex0U - this.degreeUV(0) + 1;
        const poleIndex0V = knotIndex0V - this.degreeUV(1) + 1;
        if (numDerivative < 1) {
            this.knots[0].evaluateBasisFunctions(knotIndex0U, u, this._basisBufferUV[0]);
            this.knots[1].evaluateBasisFunctions(knotIndex0V, v, this._basisBufferUV[1]);
            this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);
        }
        else {
            this.knots[0].evaluateBasisFunctions1(knotIndex0U, u, this._basisBufferUV[0], this._basisBuffer1UV[0]);
            this.knots[1].evaluateBasisFunctions1(knotIndex0V, v, this._basisBufferUV[1], this._basisBuffer1UV[1]);
            this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);
            this.sumpoleBufferDerivativesForSpan(poleIndex0U, poleIndex0V);
        }
    }
    // Swap numSwap entries in coffs, starting at i0 and i1 (absolute indices -- not blocks)
    swapBlocks(i0, i1, numSwap) {
        let a;
        for (let i = 0; i < numSwap; i++) {
            a = this.coffs[i0 + i];
            this.coffs[i0 + i] = this.coffs[i1 + i];
            this.coffs[i1 + i] = a;
        }
    }
    /**
     * Reverse the parameter direction for either u or v.
     * @param select direction to reverse -- 0 for u, 1 for v.
     */
    reverseInPlace(select) {
        const m = this.poleDimension;
        const numU = this.numPolesUV(0);
        const numV = this.numPolesUV(1);
        if (select === 0) {
            // reverse within rows.
            for (let j = 0; j < numV; j++) {
                const rowStart = j * numU * m;
                for (let i0 = 0, i1 = numU - 1; i0 < i1; i0++, i1--) {
                    this.swapBlocks(rowStart + i0 * m, rowStart + i1 * m, m);
                }
            }
        }
        else {
            // swap full rows ..
            const numPerRow = m * numU;
            for (let i0 = 0, i1 = (numV - 1) * numPerRow; i0 < i1; i0 += numPerRow, i1 -= numPerRow) {
                this.swapBlocks(i0, i1, numPerRow);
            }
        }
        this.knots[select].reflectKnots();
    }
    /**
     * Set the flag indicating the bspline might be suitable for having wrapped "closed" interpretation.
     */
    setWrappable(select, value) {
        this.knots[select].wrappable = value;
    }
    /**
     * Test if `degree` leading and trailing (one of U or V) blocks match, as if the data is an unwrapped closed spline in the selected direction.
     * @param select select U or V direction
     * @returns true if coordinates matched.
     */
    isClosable(select) {
        if (this.knots[select].wrappable === KnotVector_1.BSplineWrapMode.None)
            return false;
        if (!this.knots[select].testClosable())
            return false;
        const numU = this.numPolesUV(0);
        const numV = this.numPolesUV(1);
        const blockSize = this.poleDimension;
        const rowToRowStep = numU * blockSize;
        const degreeU = this.degreeUV(0);
        const degreeV = this.degreeUV(1);
        const data = this.coffs;
        if (select === 0) {
            const numTest = blockSize * degreeU; // degreeU contiguous poles.
            for (let row = 0; row < numV; row++) {
                const i0 = row * rowToRowStep;
                const i1 = i0 + rowToRowStep - numTest;
                for (let i = 0; i < numTest; i++) {
                    if (!Geometry_1.Geometry.isSameCoordinate(data[i0 + i], data[i1 + i]))
                        return false;
                }
            }
        }
        else {
            // Test the entire multi-row contiguous block in one loop . ..
            const numTest = degreeV * rowToRowStep;
            const i1 = blockSize * numU * numV - numTest;
            for (let i = 0; i < numTest; i++) {
                if (!Geometry_1.Geometry.isSameCoordinate(data[i], data[i1 + i]))
                    return false;
            }
        }
        return true;
    }
}
exports.BSpline2dNd = BSpline2dNd;
/**  BSplineSurface3d is a parametric surface in xyz space.
 * * This (BSplineSurface3d) is an unweighted surface.   Use the separate class BSplineSurface3dH for a weighted surface.
 *
 * The various static "create" methods have subtle differences in how grid sizes are conveyed:
 * | Method | control point array | counts |
 * | create | flat array of [x,y,z] | arguments numPolesU, numPolesV |
 * | createGrid | array of array of [x,y,z ] | There are no `numPolesU` or `numPolesV` args. The counts are conveyed by the deep arrays |
 * @public
 */
class BSplineSurface3d extends BSpline2dNd {
    /** Test if `other` is an instance of `BSplineSurface3d */
    isSameGeometryClass(other) { return other instanceof BSplineSurface3d; }
    /** Apply the transform to the poles */
    tryTransformInPlace(transform) { PointHelpers_1.Point3dArray.multiplyInPlace(transform, this.coffs); return true; }
    /** Return a pole by u and v indices */
    getPole(i, j, result) {
        return this.getPoint3dPole(i, j, result);
    }
    constructor(numPolesU, numPolesV, knotsU, knotsV) {
        super(numPolesU, numPolesV, 3, knotsU, knotsV);
    }
    /**
     * Return control points json arrays.
     * * if `flatArray===true`, each point appears as an array [x,y,z] in row-major order of a containing array.
     * * if `flatArray===false` each row of points is an an array of [x,y,z] in an array.  Each of these row arrays is in the result array.
     */
    getPointArray(flatArray = true) {
        if (flatArray)
            return PointHelpers_1.Point3dArray.unpackNumbersToNestedArrays(this.coffs, 3);
        return PointHelpers_1.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0));
    }
    /**
     * Return control points json arrays.
     * * Each row of points is an an array.
     * * Within the array for each row, each point is an array [x,y,z]
     */
    getPointGridJSON() {
        const result = {
            points: PointHelpers_1.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0)),
            weighStyle: WeightStyle.UnWeighted,
            numCartesianDimensions: 3,
        };
        return result;
    }
    /** Return a simple array of the control points coordinates */
    copyPointsFloat64Array() { return this.coffs.slice(); }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(select, includeExtraEndKnot) { return this.knots[select].copyKnots(includeExtraEndKnot); }
    /** Create a bspline surface.
     * * This `create` variant takes control points in a "flattened" array, with
     *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in
     *  a row-by-row grid structure
     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omitted (undefined).
     * *  When knots are given, two knot count conditions are recognized:
     * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have
     *      the classic unused first and last knot.
     * @param controlPointArray Array of points, ordered along the U direction.
     * @param numPoleU number of poles in each row in the U direction.
     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayU knots for the V direction.  See note above about knot counts.
     * @param numPoleV number of poles in each row in the U direction.
     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayV knots for the V direction.  See note above about knot counts.
     */
    static create(controlPointArray, numPolesU, orderU, knotArrayU, numPolesV, orderV, knotArrayV) {
        let numPoles = controlPointArray.length;
        if (controlPointArray instanceof Float64Array)
            numPoles /= 3;
        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))
            return undefined;
        // shift knots-of-interest limits for overclampled case ...
        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;
        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        const knotsU = knotArrayU ?
            KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const knotsV = knotArrayV ?
            KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);
        const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV);
        if (controlPointArray instanceof Float64Array) {
            let i = 0;
            for (const coordinate of controlPointArray) {
                surface.coffs[i++] = coordinate;
            }
        }
        else {
            let i = 0;
            for (const p of controlPointArray) {
                surface.coffs[i++] = p.x;
                surface.coffs[i++] = p.y;
                surface.coffs[i++] = p.z;
            }
        }
        return surface;
    }
    /** Create a bspline surface.
     * * This `create` variant takes control points in a "grid" array, with the points from
     * each grid row `[rowIndex]` being an independent array `points[rowIndex][indexAlongRow][x,y,z]`
     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omited (undefined).
     * *  When knots are given, two knot count conditions are recognized:
     * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have
     *      the classic unused first and last knot.
     * @param controlPointArray Array of points, ordered along the U direction.
     * @param numPoleU number of poles in each row in the U direction.
     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayU knots for the V direction.  See note above about knot counts.
     * @param numPoleV number of poles in each row in the U direction.
     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayV knots for the V direction.  See note above about knot counts.
     */
    static createGrid(points, orderU, knotArrayU, orderV, knotArrayV) {
        const numPolesV = points.length;
        const numPolesU = points[0].length;
        const numPoles = numPolesU * numPolesV;
        // shift knots-of-interest limits for overclamped case ...
        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;
        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))
            return undefined;
        const knotsU = knotArrayU ?
            KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const knotsV = knotArrayV ?
            KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV);
        let i = 0;
        for (const row of points) {
            for (const xyz of row) {
                surface.coffs[i++] = xyz[0];
                surface.coffs[i++] = xyz[1];
                surface.coffs[i++] = xyz[2];
            }
        }
        return surface;
    }
    /**
     * Return a complete copy of the bspline surface.
     */
    clone() {
        const knotVector1U = this.knots[0].clone();
        const knotVector1V = this.knots[1].clone();
        const surface1 = new BSplineSurface3d(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V);
        surface1.coffs = this.coffs.slice();
        return surface1;
    }
    /**
     * Return a complete copy of the bspline surface, with a transform applied to the control points.
     * @param transform transform to apply to the control points
     */
    cloneTransformed(transform) {
        const surface1 = this.clone();
        surface1.tryTransformInPlace(transform);
        return surface1;
    }
    /** Evaluate at a position given by u and v coordinates in knot space.
     * @param u u value, in knot range.
     * @param v v value in knot range.
   * @returns Return the xyz coordinates on the surface.
     */
    knotToPoint(u, v) {
        this.evaluateBuffersAtKnot(u, v);
        return Point3dVector3d_1.Point3d.createFrom(this._poleBuffer);
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPointAndDerivatives(u, v, result) {
        this.evaluateBuffersAtKnot(u, v, 1);
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectorsArrays(this._poleBuffer, this._poleBuffer1UV[0], this._poleBuffer1UV[1], result);
    }
    /** Evaluate at a position given by fractional coordinate in each direction.
       * @param fractionU u coordinate, as a fraction of the knot range.
       * @param fractionV v coordinate, as a fraction of the knot range.
     * @returns Return the xyz coordinates on the surface.
     */
    fractionToPoint(fractionU, fractionV) {
        return this.knotToPoint(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));
    }
    /**
     * evaluate the surface at u and v fractions.
     * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.
     * @param fractionU u coordinate, as a fraction of the knot range.
     * @param fractionV v coordinate, as a fraction of the knot range.
     * @param result optional pre-allocated object for return values.
     * @returns Returns point and derivative directions.
     */
    fractionToPointAndDerivatives(fractionU, fractionV, result) {
        const knotU = this.knots[0].fractionToKnot(fractionU);
        const knotV = this.knots[1].fractionToKnot(fractionV);
        return this.knotToPointAndDerivatives(knotU, knotV, result);
    }
    /** test for identical counts and near-equal coordinates */
    isAlmostEqual(other) {
        if (other instanceof BSplineSurface3d) {
            return this.knots[0].isAlmostEqual(other.knots[0])
                && this.knots[1].isAlmostEqual(other.knots[1])
                && PointHelpers_1.Point3dArray.isAlmostEqual(this.coffs, other.coffs);
        }
        return false;
    }
    /** Test if all poles are in a plane */
    isInPlane(plane) {
        return PointHelpers_1.Point3dArray.isCloseToPlane(this.coffs, plane);
    }
    /** Second step of double dispatch:  call `handler.handleBSplineSurface3d(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineSurface3d(this);
    }
    /** Extend the range to include all poles
     * * This is not a tight range.
     */
    extendRange(rangeToExtend, transform) {
        this.extendRangeXYZ(rangeToExtend, transform);
    }
}
exports.BSplineSurface3d = BSplineSurface3d;
/**  BsplinceCurve in xyzw homogeneous space
 * @public
 */
class BSplineSurface3dH extends BSpline2dNd {
    /** Test if `other` is an instance of `BSplineSurface3dH */
    isSameGeometryClass(other) { return other instanceof BSplineSurface3dH; }
    /** Apply the transform to the poles */
    tryTransformInPlace(transform) {
        PointHelpers_1.Point4dArray.multiplyInPlace(transform, this.coffs);
        return true;
    }
    /** Return a pole by u and v indices */
    getPole(i, j, result) {
        return this.getPoint3dPoleXYZW(i, j, result);
    }
    constructor(numPolesU, numPolesV, knotsU, knotsV) {
        super(numPolesU, numPolesV, 4, knotsU, knotsV);
    }
    /** Return a simple array of the control points. */
    copyPoints4d() { return PointHelpers_1.Point4dArray.unpackToPoint4dArray(this.coffs); }
    /** Return a simple array of the control points. */
    copyPointsAndWeights(points, weights, formatter = Point3dVector3d_1.Point3d.create) {
        PointHelpers_1.Point4dArray.unpackFloat64ArrayToPointsAndWeights(this.coffs, points, weights, formatter);
    }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(select, includeExtraEndKnot) { return this.knots[select].copyKnots(includeExtraEndKnot); }
    /** Create a weighted bspline surface, with control points and weights each organized as flattened array of points continuing from one U row to the next.
     * * This `create` variant takes control points in a "flattened" array, with
     *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in
     *  a deeper grid array structure.
     * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omitted (undefined).
     * *  When knots are given, two knot count conditions are recognized:
     * * * If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * * * If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have
     *      the classic unused first and last knot.
     * @param controlPointArray Array of points, ordered along the U direction.
     * @param weightArray array of weights, ordered along the U direction.
     * @param numPoleU number of poles in each row in the U direction.
     * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayU optional knots for the V direction.  See note above about knot counts.
     * @param numPoleV number of poles in each row in the U direction.
     * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  "cubic" polynomial is order 4.)
     * @param KnotArrayV optional knots for the V direction.  See note above about knot counts.
     */
    static create(controlPointArray, weightArray, numPolesU, orderU, knotArrayU, numPolesV, orderV, knotArrayV) {
        const numPoles = controlPointArray.length;
        if (numPolesU * numPolesV !== numPoles)
            return undefined;
        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))
            return undefined;
        const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;
        const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        const knotsU = knotArrayU ?
            KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);
        const knotsV = knotArrayV ?
            KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :
            KnotVector_1.KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);
        const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV);
        PointHelpers_1.Point4dArray.packPointsAndWeightsToFloat64Array(controlPointArray, weightArray, surface.coffs);
        return surface;
    }
    /** Create a bspline with given knots.
     *
     *   Two count conditions are recognized in each direction:
     *
     * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the
     *      extraneous knots of classic clamping.
     * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.
     *
     */
    static createGrid(xyzwGrid, weightStyle, orderU, knotArrayU, orderV, knotArrayV) {
        const numPolesV = xyzwGrid.length;
        const numPolesU = xyzwGrid[0].length;
        const numPoles = numPolesU * numPolesV;
        if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))
            return undefined;
        // const numPoles = numPolesU * numPolesV;
        // shift knots-of-interest limits for overclamped case ...
        const numKnotsU = knotArrayU.length;
        const numKnotsV = knotArrayV.length;
        const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);
        const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);
        const knotsU = KnotVector_1.KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU);
        const knotsV = KnotVector_1.KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV);
        const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV);
        if (weightStyle === WeightStyle.WeightsSeparateFromCoordinates) {
            let i = 0;
            for (const row of xyzwGrid) {
                for (const point of row) {
                    const w = point[3];
                    surface.coffs[i++] = point[0] * w;
                    surface.coffs[i++] = point[1] * w;
                    surface.coffs[i++] = point[2] * w;
                    surface.coffs[i++] = point[3];
                }
            }
        }
        else {
            // implicit WeightStyle.WeightsAlreadyAppliedToCoordinates
            let i = 0;
            for (const row of xyzwGrid) {
                for (const point of row) {
                    surface.coffs[i++] = point[0];
                    surface.coffs[i++] = point[1];
                    surface.coffs[i++] = point[2];
                    surface.coffs[i++] = point[3];
                }
            }
        }
        return surface;
    }
    /** Return a deep clone */
    clone() {
        const knotVector1U = this.knots[0].clone();
        const knotVector1V = this.knots[1].clone();
        const surface1 = new BSplineSurface3dH(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V);
        surface1.coffs = this.coffs.slice();
        return surface1;
    }
    /** Return a transformed clone */
    cloneTransformed(transform) {
        const surface1 = this.clone();
        surface1.tryTransformInPlace(transform);
        return surface1;
    }
    /**
      * Return control points json arrays.
      * * Each row of points is an an array.
      * * Within the array for each row, each point is an array [wx,wy,wz,w].
      */
    getPointGridJSON() {
        const result = {
            points: PointHelpers_1.Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 4, this.numPolesUV(0)),
            numCartesianDimensions: 3,
            weightStyle: WeightStyle.WeightsAlreadyAppliedToCoordinates,
        };
        return result;
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPoint4d(u, v) {
        this.evaluateBuffersAtKnot(u, v);
        return Point4d_1.Point4d.createFromPackedXYZW(this._poleBuffer, 0);
    }
    /** Evaluate at a position given by a knot value.  */
    knotToPointAndDerivatives(u, v, result) {
        this.evaluateBuffersAtKnot(u, v, 1);
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectorsWeightedArrays(this._poleBuffer, this._poleBuffer1UV[0], this._poleBuffer1UV[1], result);
    }
    /** Evaluate the Point4d (leaving weights in the point) at given fractional coordinates. */
    fractionToPoint4d(fractionU, fractionV) {
        return this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));
    }
    /**
     * * evaluate the surface and return the cartesian (weight = 1) point.
     * * if the surface XYZW point has weight0, returns point3d at 000.
     * @param fractionU u direction fraction
     * @param fractionV v direction fraction
     * @param result optional result
     */
    fractionToPoint(fractionU, fractionV, result) {
        const point4d = this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));
        return point4d.realPointDefault000(result);
    }
    /**
   * * evaluate the surface and return the cartesian (weight = 1) point.
   * * if the surface XYZW point has weight0, returns point3d at 000.
   * @param knotU u direction knot
   * @param knotV v direction knot
   * @param result optional result
   */
    knotToPoint(knotU, knotV, result) {
        const point4d = this.knotToPoint4d(knotU, knotV);
        return point4d.realPointDefault000(result);
    }
    /**
     * evaluate the surface at u and v fractions.
     * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.
     * @param fractionU u coordinate, as a fraction of the knot range.
     * @param fractionV v coordinate, as a fraction of the knot range.
     * @param result optional pre-allocated object for return values.
     * @returns Returns point and derivative directions.
     */
    fractionToPointAndDerivatives(fractionU, fractionV, result) {
        const knotU = this.knots[0].fractionToKnot(fractionU);
        const knotV = this.knots[1].fractionToKnot(fractionV);
        return this.knotToPointAndDerivatives(knotU, knotV, result);
    }
    /** test for identical counts and near-equal coordinates */
    isAlmostEqual(other) {
        if (other instanceof BSplineSurface3dH) {
            return this.knots[0].isAlmostEqual(other.knots[0])
                && this.knots[1].isAlmostEqual(other.knots[1])
                && PointHelpers_1.Point4dArray.isAlmostEqual(this.coffs, other.coffs);
        }
        return false;
    }
    /** Test if all poles are in a plane */
    isInPlane(plane) {
        return PointHelpers_1.Point4dArray.isCloseToPlane(this.coffs, plane);
    }
    /** Second step of double dispatch:  call `handler.handleBSplineSurface3dH(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleBSplineSurface3dH(this);
    }
    /**
     * extend a range to include the (optionally transformed) points of this surface
     * @param rangeToExtend range that is updated to include this surface range
     * @param transform transform to apply to the surface points
     */
    extendRange(rangeToExtend, transform) {
        this.extendRangeXYZH(rangeToExtend, transform);
    }
}
exports.BSplineSurface3dH = BSplineSurface3dH;


/***/ }),

/***/ "./lib/bspline/Bezier1dNd.js":
/*!***********************************!*\
  !*** ./lib/bspline/Bezier1dNd.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
/** @module Bspline */
/**
 * Shared implementation details for derived bezier curve classes
 * * BezierCurve3d implements with blockSize 3.
 * * BezierCurve3dH implements with blockSize 4.
 * @public
 */
class Bezier1dNd {
    // constructor CAPTURES the control points array.
    constructor(blockSize, polygon) {
        this._blockSize = blockSize;
        this._order = Math.floor(polygon.length / blockSize); // This should be an integer!!!
        this._packedData = polygon;
        this._basis = new BezierPolynomials_1.UnivariateBezier(this._order);
    }
    /** return a clone of the data array */
    clonePolygon(result) {
        const n = this._packedData.length;
        if (!result || result.length !== n)
            return this._packedData.slice();
        /** move data into the supplied result */
        for (let i = 0; i < n; i++)
            result[i] = this._packedData[i];
        return result;
    }
    /** Return the bezier order */
    get order() { return this._order; }
    /** return the packed data array.  This is a REFERENCE to the array. */
    get packedData() { return this._packedData; }
    /** Create a Bezier1dNd, using the structure of `data[0]` to determine the bezier order. */
    static create(data) {
        if (data.length < 1)
            return undefined;
        if (data[0] instanceof Point3dVector3d_1.Point3d) {
            const polygon = new Float64Array(data.length * 3);
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = p.z;
            }
            return new Bezier1dNd(3, polygon);
        }
        else if (data[0] instanceof Point4d_1.Point4d) {
            const polygon = new Float64Array(data.length * 4);
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = p.z;
                polygon[i++] = p.w;
            }
            return new Bezier1dNd(4, polygon);
        }
        else if (data[0] instanceof Point2dVector2d_1.Point2d) {
            const polygon = new Float64Array(data.length * 2);
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
            }
            return new Bezier1dNd(2, polygon);
        }
        return undefined;
    }
    /** Return the curve value at bezier fraction `s`
     * @return buffer of length `blockSize`.
     */
    evaluate(s, buffer) {
        return this._basis.sumBasisFunctions(s, this._packedData, this._blockSize, buffer);
    }
    /** Return the curve derivative value at bezier fraction `s`
     * @return buffer of length `blockSize`.
     */
    evaluateDerivative(s, buffer) {
        return this._basis.sumBasisFunctionDerivatives(s, this._packedData, this._blockSize, buffer);
    }
    /** get a single point of the polygon as a simple array.  */
    getPolygonPoint(i, buffer) {
        if (!buffer)
            buffer = new Float64Array(this._blockSize);
        if (i >= 0 && i < this._order) {
            const k0 = this._blockSize * i;
            for (let k = 0; k < this._blockSize; k++)
                buffer[k] = this._packedData[k0 + k];
            return buffer;
        }
        return undefined;
    }
    /** set a single point of the polygon as a simple array.  */
    setPolygonPoint(i, buffer) {
        if (i >= 0 && i < this._order) {
            const k0 = this._blockSize * i;
            for (let k = 0; k < this._blockSize; k++)
                this._packedData[k0 + k] = buffer[k];
        }
    }
    /** Load order * dimension doubles from data[dimension * spanIndex] as poles
     * @param data packed source array.  block size in `data` assumed to match dimension for this.
     * @param spanIndex block index in data.
     */
    loadSpanPoles(data, spanIndex) {
        let k = spanIndex * this._blockSize;
        for (let i = 0; i < this._packedData.length; i++)
            this._packedData[i] = data[k++];
    }
    /** Load order * (dataDimension + 1)  doubles from data[dataDimension * spanIndex] as poles with weight inserted
     * @param data packed array of data.
     * @param dataDimension dimension of data. Must have `dataDimension+1=this.order`
     * @param spanIndex index of first data block to access.
     * @param weight weight to append to each block
     */
    loadSpanPolesWithWeight(data, dataDimension, spanIndex, weight) {
        let destIndex = 0;
        const order = this._order;
        let dataIndex = spanIndex * dataDimension;
        for (let i = 0; i < order; i++) {
            for (let j = 0; j < dataDimension; j++)
                this._packedData[destIndex++] = data[dataIndex++];
            this._packedData[destIndex++] = weight;
        }
    }
    /**  return a json array of arrays with each control point as a lower level array of numbers */
    unpackToJsonArrays() {
        return PointHelpers_1.Point3dArray.unpackNumbersToNestedArrays(this._packedData, this._blockSize);
    }
    /** equality test with usual metric tolerances */
    isAlmostEqual(other) {
        if (other instanceof Bezier1dNd) {
            if (this._blockSize !== other._blockSize)
                return false;
            if (this._order !== other._order)
                return false;
            if (this._packedData.length !== other._packedData.length)
                return false;
            for (let i = 0; i < this._packedData.length; i++) {
                if (!Geometry_1.Geometry.isSameCoordinate(this._packedData[i], other._packedData[i]))
                    return false;
            }
            return true;
        }
        return false;
    }
    /** block-by-block reversal */
    reverseInPlace() {
        const m = this._blockSize;
        const n = this._order;
        let i, j;
        let a;
        for (i = 0, j = (n - 1) * m; i < j; i += m, j -= m) {
            for (let k = 0; k < m; k++) {
                a = this._packedData[i + k];
                this._packedData[i + k] = this._packedData[j + k];
                this._packedData[j + k] = a;
            }
        }
    }
    //
    /**
     * interpolate at `fraction` between poleA and poleB.
     * * Data is left "in place" in poleIndexA
     * @param poleIndexA first pole index
     * @param fraction fractional position
     * @param poleIndexB second pole index
     */
    interpolatePoleInPlace(poleIndexA, fraction, poleIndexB) {
        let i0 = poleIndexA * this._blockSize;
        let i1 = poleIndexB * this._blockSize;
        const data = this._packedData;
        for (let i = 0; i < this._blockSize; i++, i0++, i1++) {
            data[i0] += fraction * (data[i1] - data[i0]);
        }
    }
    /**
     * Compute new control points to "clamp" bspline unsaturated support to saturated form.
     * * At input time, the control points are associated with the input knots (unsaturated)
     * * At output, they control points are modified by repeated knot insertion to be fully clamped.
     * @param knots knot values for the current (unsaturated) pole set
     * @param spanIndex index of span whose (unsaturated) poles are in the bezier.
     * @param optional function for `setInterval (knotA, knotB)` call to announce knot limits.
     */
    saturateInPlace(knots, spanIndex) {
        const degree = knots.degree;
        const kA = spanIndex + degree - 1; // left knot index of the active span
        const kB = kA + 1;
        if (spanIndex < 0 || spanIndex >= knots.numSpans)
            return false;
        const knotArray = knots.knots;
        const knotA = knotArray[kA];
        const knotB = knotArray[kB];
        this.setInterval(knotA, knotB);
        if (knotB <= knotA + Bezier1dNd._knotTolerance)
            return false;
        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {
            //  left numInsert poles are pulled forward
            let k0 = kA - numInsert;
            if (knotArray[k0] < knotA) {
                let k1 = kB;
                for (let i = 0; i < numInsert; i++, k0++, k1++) {
                    const knot0 = knotArray[k0];
                    const knot1 = knotArray[k1];
                    const fraction = (knotA - knot0) / (knot1 - knot0);
                    this.interpolatePoleInPlace(i, fraction, i + 1);
                }
            }
        }
        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {
            let k2 = kB + numInsert;
            if (knotArray[k2] > knotB) {
                for (let i = 0; i < numInsert; i++, k2--) {
                    const knot2 = knotArray[k2]; // right side of moving window
                    // left side of window ia always the (previously saturated) knotA
                    const fraction = (knotB - knot2) / (knotA - knot2);
                    this.interpolatePoleInPlace(degree - i, fraction, degree - i - 1);
                }
            }
        }
        return true;
    }
    /**
     * Saturate a univariate bspline coefficient array in place
     * * On input, the array is the coefficients one span of a bspline, packed in an array of `(knots.order)` values.
     * * These are modified in place, and on return are a bezier for the same knot interval.
     * @param coffs input as bspline coefficients, returned as bezier coefficients
     * @param knots knot vector
     * @param spanIndex index of span whose (unsaturated) poles are in the coefficients.
     * @param optional function for `setInterval (knotA, knotB)` call to announce knot limits.
     */
    static saturate1dInPlace(coffs, knots, spanIndex) {
        const degree = knots.degree;
        const kA = spanIndex + degree - 1; // left knot index of the active span
        const kB = kA + 1;
        if (spanIndex < 0 || spanIndex >= knots.numSpans)
            return false;
        const knotArray = knots.knots;
        const knotA = knotArray[kA];
        const knotB = knotArray[kB];
        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {
            //  left numInsert poles are pulled forward
            let k0 = kA - numInsert;
            if (knotArray[k0] < knotA) {
                let k1 = kB;
                for (let i = 0; i < numInsert; i++, k0++, k1++) {
                    const knot0 = knotArray[k0];
                    const knot1 = knotArray[k1];
                    const fraction = (knotA - knot0) / (knot1 - knot0);
                    coffs[i] = coffs[i] + fraction * (coffs[i + 1] - coffs[i]);
                }
            }
        }
        for (let numInsert = degree - 1; numInsert > 0; numInsert--) {
            let k2 = kB + numInsert;
            let k;
            if (knotArray[k2] > knotB) {
                for (let i = 0; i < numInsert; i++, k2--) {
                    const knot2 = knotArray[k2]; // right side of moving window
                    // left side of window ia always the (previously saturated) knotA
                    const fraction = (knotB - knot2) / (knotA - knot2);
                    k = degree - i;
                    coffs[k] += fraction * (coffs[k - 1] - coffs[k]);
                }
            }
        }
        return true;
    }
    /**
     * Apply deCasteljou interpolations to isolate a smaller bezier polygon, representing interval 0..fraction of the original
     * @param fraction "end" fraction for split.
     * @returns false if fraction is 0 -- no changes applied.
     */
    subdivideInPlaceKeepLeft(fraction) {
        if (Geometry_1.Geometry.isAlmostEqualNumber(fraction, 1.0))
            return true;
        if (Geometry_1.Geometry.isAlmostEqualNumber(fraction, 0.0))
            return false;
        const g = 1.0 - fraction; // interpolations will pull towards right indices
        const order = this.order;
        for (let level = 1; level < order; level++) {
            for (let i1 = order - 1; i1 >= level; i1--) {
                this.interpolatePoleInPlace(i1, g, i1 - 1); // leave updates to right
            }
        }
        return true;
    }
    /**
     * Apply deCasteljou interpolations to isolate a smaller bezier polygon, representing interval 0..fraction of the original
     * @param fraction "end" fraction for split.
     * @returns false if fraction is 0 -- no changes applied.
     */
    subdivideInPlaceKeepRight(fraction) {
        if (Geometry_1.Geometry.isAlmostEqualNumber(fraction, 0.0))
            return true;
        if (Geometry_1.Geometry.isAlmostEqualNumber(fraction, 1.0))
            return false;
        const order = this.order;
        for (let level = 1; level < order; level++) {
            for (let i0 = 0; i0 + level < order; i0++)
                this.interpolatePoleInPlace(i0, fraction, i0 + 1); // leave updates to left.
        }
        return true;
    }
    /**
     * Saturate a univariate bspline coefficient array in place
     * @param fraction0 fraction for first split.   This is the start of the output polygon
     * @param fraction1 fraction for first split.   This is the start of the output polygon
     * @return false if fractions are (almost) identical.
     */
    subdivideToIntervalInPlace(fraction0, fraction1) {
        if (Geometry_1.Geometry.isAlmostEqualNumber(fraction0, fraction1))
            return false;
        if (fraction1 < fraction0) {
            this.subdivideToIntervalInPlace(fraction0, fraction1);
            this.reverseInPlace();
            return true;
        }
        this.subdivideInPlaceKeepLeft(fraction1);
        this.subdivideInPlaceKeepRight(fraction0 / fraction1);
        return true;
    }
    /** create or update the mapping to parent curve. */
    setInterval(a, b) {
        this.interval = Segment1d_1.Segment1d.create(a, b, this.interval);
    }
    /** map a fraction to the parent space. */
    fractionToParentFraction(fraction) { return this.interval ? this.interval.fractionToPoint(fraction) : fraction; }
}
exports.Bezier1dNd = Bezier1dNd;
Bezier1dNd._knotTolerance = 1.0e-8;


/***/ }),

/***/ "./lib/bspline/BezierCurve3d.js":
/*!**************************************!*\
  !*** ./lib/bspline/BezierCurve3d.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const BezierCurveBase_1 = __webpack_require__(/*! ./BezierCurveBase */ "./lib/bspline/BezierCurveBase.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
/** @module Bspline */
// ================================================================================================================
// ================================================================================================================
// ================================================================================================================
// ================================================================================================================
/** 3d Bezier curve class.
 * * Use BezierCurve3dH if the curve has weights.
 * * The control points (xyz) are managed as the _packedData buffer in the _polygon member of BezierCurveBase.
 * @public
 */
class BezierCurve3d extends BezierCurveBase_1.BezierCurveBase {
    /**
     * Capture a polygon as the data for a new `BezierCurve3d`
     * @param polygon complete packed data and order.
     */
    constructor(polygon) {
        super(3, polygon);
        this._workRay0 = Ray3d_1.Ray3d.createXAxis();
        this._workRay1 = Ray3d_1.Ray3d.createXAxis();
    }
    /** test if `other` is also a BezierCurve3d. */
    isSameGeometryClass(other) { return other instanceof BezierCurve3d; }
    /** apply the transform to the control points. */
    tryTransformInPlace(transform) {
        const data = this._workData0;
        for (let i = 0; i < this._polygon.order; i++) {
            this._polygon.getPolygonPoint(i, data);
            transform.multiplyXYZToFloat64Array(data[0], data[1], data[2], data);
            this._polygon.setPolygonPoint(i, data);
        }
        return true;
    }
    /** Return a specific pole as a full `[x,y,z] Point3d` */
    getPolePoint3d(i, result) {
        const data = this._polygon.getPolygonPoint(i, this._workData0);
        if (data)
            return Point3dVector3d_1.Point3d.create(data[0], data[1], data[2], result);
        return undefined;
    }
    /** Return a specific pole as a full `[w*x,w*y,w*z, w] Point4d` */
    getPolePoint4d(i, result) {
        const data = this._polygon.getPolygonPoint(i, this._workData0);
        if (data)
            return Point4d_1.Point4d.create(data[0], data[1], data[2], 1.0, result);
        return undefined;
    }
    /** Return poles as a linestring */
    copyPointsAsLineString() {
        const result = LineString3d_1.LineString3d.create();
        for (let i = 0; i < this._polygon.order; i++)
            result.addPoint(this.getPolePoint3d(i));
        return result;
    }
    /** Create a curve with given points.
     * * If input is `Point2d[]`, the points are promoted with `z=0` and `w=1`
     * * If input is `Point3d[]`, the points are promoted with w=1`
     *
     */
    static create(data) {
        if (data.length < 1)
            return undefined;
        const polygon = new Float64Array(data.length * 3);
        if (data[0] instanceof Point3dVector3d_1.Point3d) {
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = p.z;
            }
            return new BezierCurve3d(polygon);
        }
        else if (data[0] instanceof Point2dVector2d_1.Point2d) {
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = 0.0;
            }
            return new BezierCurve3d(polygon);
        }
        return undefined;
    }
    /** create a bezier curve of specified order, filled with zeros */
    static createOrder(order) {
        const polygonArray = new Float64Array(order * 3); // This is initialized to zeros!!
        return new BezierCurve3d(polygonArray);
    }
    /** Load order * 3 doubles from data[3 * spanIndex] as poles */
    loadSpanPoles(data, spanIndex) {
        this._polygon.loadSpanPoles(data, spanIndex);
    }
    /** Clone as a bezier 3d. */
    clone() {
        return new BezierCurve3d(this._polygon.clonePolygon());
    }
    /** Clone the interval from f0 to f1. */
    clonePartialCurve(f0, f1) {
        const partialCurve = new BezierCurve3d(this._polygon.clonePolygon());
        partialCurve._polygon.subdivideToIntervalInPlace(f0, f1);
        return partialCurve;
    }
    /**
     * Return a curve after transform.
     */
    cloneTransformed(transform) {
        const curve1 = this.clone();
        curve1.tryTransformInPlace(transform);
        return curve1;
    }
    /** Return a (de-weighted) point on the curve. If de-weight fails, returns 000 */
    fractionToPoint(fraction, result) {
        this._polygon.evaluate(fraction, this._workData0);
        return Point3dVector3d_1.Point3d.create(this._workData0[0], this._workData0[1], this._workData0[2], result);
    }
    /** Return the cartesian point and derivative vector. */
    fractionToPointAndDerivative(fraction, result) {
        this._polygon.evaluate(fraction, this._workData0);
        this._polygon.evaluateDerivative(fraction, this._workData1);
        return Ray3d_1.Ray3d.createXYZUVW(this._workData0[0], this._workData0[1], this._workData0[2], this._workData1[0], this._workData1[1], this._workData1[2], result);
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the arc
     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.
     * If the arc is circular, the second derivative is directly towards the center
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const epsilon = 1.0e-8;
        const a = 1.0 / (2.0 * epsilon);
        if (!result)
            result = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
        const ray = this.fractionToPointAndDerivative(fraction, this._workRay0);
        result.origin.setFrom(ray.origin);
        result.vectorU.setFrom(ray.direction);
        const ray0 = this.fractionToPointAndDerivative(fraction - epsilon, this._workRay0);
        const ray1 = this.fractionToPointAndDerivative(fraction + epsilon, this._workRay1);
        Point3dVector3d_1.Vector3d.createAdd2Scaled(ray0.direction, -a, ray1.direction, a, result.vectorV);
        return result;
    }
    /** Near-equality test on poles. */
    isAlmostEqual(other) {
        if (other instanceof BezierCurve3d) {
            return this._polygon.isAlmostEqual(other._polygon);
        }
        return false;
    }
    /** Second step of double dispatch:  call `handler.handleBezierCurve3d(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleBezierCurve3d(this);
    }
    /** Extend `rangeToExtend`, using candidate extrema at
     * * both end points
     * * any internal extrema in x,y,z
     */
    extendRange(rangeToExtend, transform) {
        const order = this.order;
        if (!transform) {
            this.allocateAndZeroBezierWorkData(order - 1, 0, 0);
            const bezier = this._workBezier;
            this.getPolePoint3d(0, this._workPoint0);
            rangeToExtend.extend(this._workPoint0);
            this.getPolePoint3d(order - 1, this._workPoint0);
            rangeToExtend.extend(this._workPoint0);
            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {
                BezierPolynomials_1.BezierPolynomialAlgebra.componentDifference(bezier.coffs, this._polygon.packedData, 3, order, axisIndex);
                const roots = bezier.roots(0.0, true);
                if (roots) {
                    for (const r of roots) {
                        this.fractionToPoint(r, this._workPoint0);
                        rangeToExtend.extend(this._workPoint0);
                    }
                }
            }
        }
        else {
            this.allocateAndZeroBezierWorkData(order - 1, order, 0);
            const bezier = this._workBezier;
            const componentCoffs = this._workCoffsA; // to hold transformed copy of x,y,z in turn.
            this.getPolePoint3d(0, this._workPoint0);
            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
            this.getPolePoint3d(order - 1, this._workPoint0);
            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
            const data = this._polygon.packedData;
            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {
                // apply one row of the transform to get the transformed coff by itself
                for (let i = 0, k = 0; i < order; i++, k += 3)
                    componentCoffs[i] = transform.multiplyComponentXYZ(axisIndex, data[k], data[k + 1], data[k + 2]);
                BezierPolynomials_1.BezierPolynomialAlgebra.univariateDifference(componentCoffs, bezier.coffs);
                const roots = bezier.roots(0.0, true);
                if (roots && roots.length > 0) {
                    for (const r of roots) {
                        this.fractionToPoint(r, this._workPoint0);
                        rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
                    }
                }
            }
        }
    }
}
exports.BezierCurve3d = BezierCurve3d;


/***/ }),

/***/ "./lib/bspline/BezierCurve3dH.js":
/*!***************************************!*\
  !*** ./lib/bspline/BezierCurve3dH.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const BezierCurveBase_1 = __webpack_require__(/*! ./BezierCurveBase */ "./lib/bspline/BezierCurveBase.js");
/** @module Bspline */
/** 3d curve with homogeneous weights.
 * * A control point with weight w and cartesian (projected) coordinates x,y,z has the weight multiplied into the coordinates,
 *    hence the control point as stored is (xw, yw, zw, w).
 * @public
 */
class BezierCurve3dH extends BezierCurveBase_1.BezierCurveBase {
    /**
     * Capture a polygon as the data for a new `BezierCurve3dH`
     * @param polygon complete packed data and order.
     */
    constructor(polygon) {
        super(4, polygon);
        this._workRay0 = Ray3d_1.Ray3d.createXAxis();
        this._workRay1 = Ray3d_1.Ray3d.createXAxis();
    }
    /** test if `other` is also a BezierCurve3dH. */
    isSameGeometryClass(other) { return other instanceof BezierCurve3dH; }
    /**
     * Apply (multiply by) an affine transform
     * @param transform
     */
    tryTransformInPlace(transform) {
        const data = this._workData0;
        for (let i = 0; i < this._polygon.order; i++) {
            this._polygon.getPolygonPoint(i, data);
            transform.multiplyXYZWToFloat64Array(data[0], data[1], data[2], data[3], data);
            this._polygon.setPolygonPoint(i, data);
        }
        return true;
    }
    /**
     * Apply (multiply by) a perspective transform
     * @param matrix
     */
    tryMultiplyMatrix4dInPlace(matrix) {
        matrix.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData);
    }
    /** Return a specific pole as a full `[x,y,z,x] Point4d` */
    getPolePoint4d(i, result) {
        const data = this._polygon.getPolygonPoint(i, this._workData0);
        if (data)
            return Point4d_1.Point4d.create(data[0], data[1], data[2], data[3], result);
        return undefined;
    }
    /** Return a specific pole normalized to weight 1
     */
    getPolePoint3d(i, result) {
        const data = this._polygon.getPolygonPoint(i, this._workData0);
        if (data)
            return Point3dVector3d_1.Point3d.createFromPackedXYZW(data, 0, result);
        return undefined;
    }
    /**
     * Returns true if all weights are within tolerance of 1.0
     */
    isUnitWeight(tolerance) {
        if (tolerance === undefined)
            tolerance = Geometry_1.Geometry.smallAngleRadians;
        const aLow = 1.0 - tolerance;
        const aHigh = 1.0 + tolerance;
        const data = this._polygon.packedData;
        const n = data.length;
        let a;
        for (let i = 3; i < n; i += 4) {
            a = data[i];
            if (a < aLow || a > aHigh)
                return false;
        }
        return true;
    }
    /** Create a curve with given points.
     * * If input is `Point2d[]`, the points are promoted with `z=0` and `w=1`
     * * If input is `Point3d[]`, the points are promoted with w=1`
     *
     */
    static create(data) {
        if (data.length < 1)
            return undefined;
        const polygon = new Float64Array(data.length * 4);
        if (data[0] instanceof Point3dVector3d_1.Point3d) {
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = p.z;
                polygon[i++] = 1.0;
            }
            return new BezierCurve3dH(polygon);
        }
        else if (data[0] instanceof Point4d_1.Point4d) {
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = p.z;
                polygon[i++] = p.w;
            }
            return new BezierCurve3dH(polygon);
        }
        else if (data[0] instanceof Point2dVector2d_1.Point2d) {
            let i = 0;
            for (const p of data) {
                polygon[i++] = p.x;
                polygon[i++] = p.y;
                polygon[i++] = 0.0;
                polygon[i++] = 1.0;
            }
            return new BezierCurve3dH(polygon);
        }
        return undefined;
    }
    /** create a bezier curve of specified order, filled with zeros */
    static createOrder(order) {
        const polygonArray = new Float64Array(order * 4); // and we trust that this is all zeros !!!
        return new BezierCurve3dH(polygonArray);
    }
    /** Load order * 4 doubles from data[3 * spanIndex] as poles (with added weight) */
    loadSpan3dPolesWithWeight(data, spanIndex, weight) {
        this._polygon.loadSpanPolesWithWeight(data, 3, spanIndex, weight);
    }
    /** Load order * 4 doubles from data[3 * spanIndex] as poles (with added weight) */
    loadSpan4dPoles(data, spanIndex) {
        this._polygon.loadSpanPoles(data, spanIndex);
    }
    /** Clone the entire curve. */
    clone() {
        return new BezierCurve3dH(this._polygon.clonePolygon());
    }
    /**
     * Return a curve after transform.
     */
    cloneTransformed(transform) {
        const curve1 = this.clone();
        curve1.tryTransformInPlace(transform);
        return curve1;
    }
    /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */
    fractionToPoint(fraction, result) {
        this._polygon.evaluate(fraction, this._workData0);
        result = Point3dVector3d_1.Point3d.createFromPackedXYZW(this._workData0, 0, result);
        return result ? result : Point3dVector3d_1.Point3d.createZero();
    }
    /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */
    fractionToPoint4d(fraction, result) {
        this._polygon.evaluate(fraction, this._workData0);
        return Point4d_1.Point4d.createFromPackedXYZW(this._workData0, 0, result);
    }
    /** Return the cartesian point and derivative vector. */
    fractionToPointAndDerivative(fraction, result) {
        this._polygon.evaluate(fraction, this._workData0);
        this._polygon.evaluateDerivative(fraction, this._workData1);
        result = Ray3d_1.Ray3d.createWeightedDerivative(this._workData0, this._workData1, result);
        if (result)
            return result;
        // Bad. Very Bad.  Return origin and x axis.   Should be undefined, but usual cartesian types do not allow that
        return Ray3d_1.Ray3d.createXAxis();
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the arc
     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.
     * If the arc is circular, the second derivative is directly towards the center
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const epsilon = 1.0e-8;
        const a = 1.0 / (2.0 * epsilon);
        if (!result)
            result = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
        const ray = this.fractionToPointAndDerivative(fraction, this._workRay0);
        result.origin.setFrom(ray.origin);
        result.vectorU.setFrom(ray.direction);
        const ray0 = this.fractionToPointAndDerivative(fraction - epsilon, this._workRay0);
        const ray1 = this.fractionToPointAndDerivative(fraction + epsilon, this._workRay1);
        Point3dVector3d_1.Vector3d.createAdd2Scaled(ray0.direction, -a, ray1.direction, a, result.vectorV);
        return result;
    }
    /** test for nearly equal control points */
    isAlmostEqual(other) {
        if (other instanceof BezierCurve3dH) {
            return this._polygon.isAlmostEqual(other._polygon);
        }
        return false;
    }
    /** Second step of double dispatch:  call `handler.handleBezierCurve3dH(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleBezierCurve3dH(this);
    }
    /**
     * Form dot products of each pole with given coefficients. Return as entries in products array.
     * @param products array of (scalar) dot products
     * @param ax x coefficient
     * @param ay y coefficient
     * @param az z coefficient
     * @param aw w coefficient
     */
    poleProductsXYZW(products, ax, ay, az, aw) {
        const n = this.numPoles;
        const data = this._polygon.packedData;
        for (let i = 0, k = 0; i < n; i++, k += 4)
            products[i] = ax * data[k] + ay * data[k + 1] + az * data[k + 2] + aw * data[k + 3];
    }
    /** Find the closest point within the bezier span, using true perpendicular test (but no endpoint test)
     * * If closer than previously recorded, update the CurveLocationDetail
     * * This assumes this bezier is saturated.
     * @param spacePoint point being projected
     * @param detail pre-allocated detail to record (evolving) closest point.
     * @returns true if an updated occurred, false if either (a) no perpendicular projections or (b) perpendiculars were not closer.
     */
    updateClosestPointByTruePerpendicular(spacePoint, detail) {
        let numUpdates = 0;
        let roots;
        if (this.isUnitWeight()) {
            // unweighted !!!
            const productOrder = 2 * this.order - 2;
            this.allocateAndZeroBezierWorkData(productOrder, 0, 0);
            const bezier = this._workBezier;
            // closestPoint condition is:
            //   (spacePoint - curvePoint) DOT curveTangent = 0;
            // Each product (x,y,z) of the DOT is the product of two bezier polynomials
            BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 0, -spacePoint.x, 0);
            BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 1, -spacePoint.y, 1);
            BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 2, -spacePoint.z, 2);
            roots = bezier.roots(0.0, true);
        }
        else {
            // This bezier has weights.
            // The pure cartesian closest point condition is
            //   (spacePoint - X/w) DOT (X' w - w' X)/ w^2 = 0
            // ignoring denominator and using bezier coefficient differences for the derivative, making the numerator 0 is
            //   (w * spacePoint - X) DOT ( DELTA X * w - DELTA w * X) = 0
            const orderA = this.order;
            const orderB = 2 * this.order - 2; // products of component and component difference.
            const productOrder = orderA + orderB - 1;
            this.allocateAndZeroBezierWorkData(productOrder, orderA, orderB);
            const bezier = this._workBezier;
            const workA = this._workCoffsA;
            const workB = this._workCoffsB;
            const packedData = this._polygon.packedData;
            for (let i = 0; i < 3; i++) {
                // x representing loop pass:   (w * spacePoint.x - curve.x(s), 1.0) * (curveDelta.x(s) * curve.w(s) - curve.x(s) * curveDelta.w(s))
                // (and p.w is always 1)
                BezierPolynomials_1.BezierPolynomialAlgebra.scaledComponentSum(workA, packedData, 4, orderA, 3, spacePoint.at(i), // w * spacePoint.x
                i, -1.0); // curve.x(s) * 1.0
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(workB, packedData, 4, orderA, 1.0, 3, 1.0, i);
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(workB, packedData, 4, orderA, -1.0, i, 1.0, 3);
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateProduct(bezier.coffs, workA, workB);
            }
            roots = bezier.roots(0.0, true);
        }
        if (roots) {
            for (const fraction of roots) {
                const xyz = this.fractionToPoint(fraction);
                const a = xyz.distance(spacePoint);
                numUpdates += detail.updateIfCloserCurveFractionPointDistance(this, fraction, xyz, a) ? 1 : 0;
            }
        }
        return numUpdates > 0;
    }
    /** Extend `rangeToExtend`, using candidate extrema at
     * * both end points
     * * any internal extrema in x,y,z
     */
    extendRange(rangeToExtend, transform) {
        const order = this.order;
        if (!transform) {
            this.allocateAndZeroBezierWorkData(order * 2 - 2, 0, 0);
            const bezier = this._workBezier;
            const data = this._polygon.packedData;
            this.getPolePoint3d(0, this._workPoint0);
            rangeToExtend.extend(this._workPoint0);
            this.getPolePoint3d(order - 1, this._workPoint0);
            rangeToExtend.extend(this._workPoint0);
            // Example:
            // For x component ...
            //     coefficients of (weighted x) are at axisIndex=0
            //     deweighted polynomial is (x(s)/w(s))
            //    its derivative (to be zeroed) is
            //              (x'(s)*w(s) -x(s) * w'(s)) / w^2(s)
            // The coefficients of the derivatives are (degree times) differences of successive coffs.
            // Make the numerator zero to get extrema
            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {
                bezier.zero();
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, data, 4, order, 1.0, axisIndex, 0.0, 3);
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, data, 4, order, -1.0, 3, 0.0, axisIndex);
                const roots = bezier.roots(0.0, true);
                if (roots) {
                    for (const r of roots) {
                        this.fractionToPoint(r, this._workPoint0);
                        rangeToExtend.extend(this._workPoint0);
                    }
                }
            }
        }
        else {
            this.allocateAndZeroBezierWorkData(order * 2 - 2, order, order);
            const componentCoffs = this._workCoffsA; // to hold transformed copy of x,y,z in turn.
            const weightCoffs = this._workCoffsB; // to hold weights
            const bezier = this._workBezier;
            this.getPolePoint3d(0, this._workPoint0);
            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
            this.getPolePoint3d(order - 1, this._workPoint0);
            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
            const data = this._polygon.packedData; // Example:
            // For x component ...
            //     coefficients of (weighted x) are at axisIndex=0
            //     deweighted polynomial is (x(s)/w(s))
            //    its derivative (to be zeroed) is
            //              (x'(s)*w(s) -x(s) * w'(s)) / w^2(s)
            // The coefficients of the derivatives are (degree times) differences of successive coffs.
            // Make the numerator zero to get extrema
            // apply one row of the transform to get the transformed coff by itself
            let weight;
            for (let axisIndex = 0; axisIndex < 3; axisIndex++) {
                bezier.zero();
                for (let i = 0, k = 0; i < order; i++, k += 4) {
                    weight = data[k + 3];
                    componentCoffs[i] = transform.multiplyComponentXYZW(axisIndex, data[k], data[k + 1], data[k + 2], weight);
                    weightCoffs[i] = weight;
                }
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateProductWithDifferences(bezier.coffs, componentCoffs, weightCoffs, 1.0);
                BezierPolynomials_1.BezierPolynomialAlgebra.accumulateProductWithDifferences(bezier.coffs, weightCoffs, componentCoffs, -1.0);
                const roots = bezier.roots(0.0, true);
                if (roots && roots.length > 0) {
                    for (const r of roots) {
                        this.fractionToPoint(r, this._workPoint0);
                        rangeToExtend.extendTransformedPoint(transform, this._workPoint0);
                    }
                }
            }
        }
    }
}
exports.BezierCurve3dH = BezierCurve3dH;


/***/ }),

/***/ "./lib/bspline/BezierCurveBase.js":
/*!****************************************!*\
  !*** ./lib/bspline/BezierCurveBase.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const StrokeOptions_1 = __webpack_require__(/*! ../curve/StrokeOptions */ "./lib/curve/StrokeOptions.js");
const Bezier1dNd_1 = __webpack_require__(/*! ./Bezier1dNd */ "./lib/bspline/Bezier1dNd.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
/**
 * Base class for CurvePrimitive (necessarily 3D) with _polygon.
 * * This has a Bezier1dNd polygon as a member, and implements dimension-independent methods
 * * This exists to support
 *    * BezierCurve3d -- 3 coordinates x,y,z per block in the Bezier1dNd poles
 *    * BezierCurve3dH -- 4 coordinates x,y,z,w per block in the Bezier1dNd poles
 * * The implementations of "pure 3d" queries is based on calling `getPolePoint3d`.
 * * This has the subtle failure difference that `getPolePoint3d` call with a valid index on on a 3d curve always succeeds, but on 3dH curve fails when weight is zero.
 * @public
 */
class BezierCurveBase extends CurvePrimitive_1.CurvePrimitive {
    constructor(blockSize, data) {
        super();
        /** String name for schema properties */
        this.curvePrimitiveType = "bezierCurve";
        this._polygon = new Bezier1dNd_1.Bezier1dNd(blockSize, data);
        this._workPoint0 = Point3dVector3d_1.Point3d.create();
        this._workPoint1 = Point3dVector3d_1.Point3d.create();
        this._workData0 = new Float64Array(blockSize);
        this._workData1 = new Float64Array(blockSize);
    }
    /** reverse the poles in place */
    reverseInPlace() { this._polygon.reverseInPlace(); }
    /** saturate the pole in place, using knot intervals from `spanIndex` of the `knotVector` */
    saturateInPlace(knotVector, spanIndex) {
        const boolStat = this._polygon.saturateInPlace(knotVector, spanIndex);
        if (boolStat) {
            this.setInterval(knotVector.spanFractionToFraction(spanIndex, 0.0), knotVector.spanFractionToFraction(spanIndex, 1.0));
        }
        return boolStat;
    }
    /** (property accessor) Return the polynomial degree (one less than order) */
    get degree() {
        return this._polygon.order - 1;
    }
    /** (property accessor) Return the polynomial order */
    get order() { return this._polygon.order; }
    /** (property accessor) Return the number of poles (aka control points) */
    get numPoles() { return this._polygon.order; }
    /** Set mapping to parent curve (e.g. if this bezier is a span extracted from a bspline, this is the knot interval of the span) */
    setInterval(a, b) { this._polygon.setInterval(a, b); }
    /** map `fraction` from this Bezier curves inherent 0..1 range to the (a,b) range of parent
     * * ( The parent range should have been previously defined with `setInterval`)
     */
    fractionToParentFraction(fraction) { return this._polygon.fractionToParentFraction(fraction); }
    /** append stroke points to a linestring, based on `strokeCount` and `fractionToPoint` from derived class*/
    emitStrokes(dest, options) {
        const numPerSpan = this.computeStrokeCountForOptions(options);
        const fractionStep = 1.0 / numPerSpan;
        for (let i = 0; i <= numPerSpan; i++) {
            const fraction = i * fractionStep;
            this.fractionToPoint(fraction, this._workPoint0);
            dest.appendStrokePoint(this._workPoint0);
        }
    }
    /** announce intervals with stroke counts */
    emitStrokableParts(handler, _options) {
        const numPerSpan = this.computeStrokeCountForOptions(_options);
        handler.announceIntervalForUniformStepStrokes(this, numPerSpan, 0.0, 1.0);
    }
    /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */
    copyPolesAsJsonArray() { return this._polygon.unpackToJsonArrays(); }
    /** return true if all poles are on a plane. */
    isInPlane(plane) {
        let point = this._workPoint0;
        for (let i = 0;; i++) {
            point = this.getPolePoint3d(i, point);
            if (!point)
                return true;
            if (!plane.isPointInPlane(point))
                break; // which gets to return false, which is otherwise unreachable . . .
        }
        return false;
    }
    /** Return the length of the control polygon. */
    polygonLength() {
        if (!this.getPolePoint3d(0, this._workPoint0))
            return 0.0;
        let i = 0;
        let sum = 0.0;
        while (this.getPolePoint3d(++i, this._workPoint1)) {
            sum += this._workPoint0.distance(this._workPoint1);
            this._workPoint0.setFrom(this._workPoint1);
        }
        return sum;
    }
    /** Return the start point.  (first control point) */
    startPoint() {
        const result = this.getPolePoint3d(0); // ASSUME non-trivial pole set -- if null comes back, it bubbles out
        return result;
    }
    /** Return the end point.  (last control point) */
    endPoint() {
        const result = this.getPolePoint3d(this.order - 1); // ASSUME non-trivial pole set
        return result;
    }
    /** Return the control polygon length as a quick length estimate. */
    quickLength() { return this.polygonLength(); }
    /**
     * set up the _workBezier members with specific order.
     * * Try to reuse existing members if their sizes match.
     * * Ignore members corresponding to args that are 0 or negative.
     * @param primaryBezierOrder order of expected bezier
     * @param orderA length of _workCoffsA (simple array)
     * @param orderB length of _workCoffsB (simple array)
     */
    allocateAndZeroBezierWorkData(primaryBezierOrder, orderA, orderB) {
        if (primaryBezierOrder > 0) {
            if (this._workBezier !== undefined && this._workBezier.order === primaryBezierOrder) {
                this._workBezier.zero();
            }
            else
                this._workBezier = new BezierPolynomials_1.UnivariateBezier(primaryBezierOrder);
        }
        if (orderA > 0) {
            if (this._workCoffsA !== undefined && this._workCoffsA.length === orderA)
                this._workCoffsA.fill(0);
            else
                this._workCoffsA = new Float64Array(orderA);
        }
        if (orderB > 0) {
            if (this._workCoffsB !== undefined && this._workCoffsB.length === orderB)
                this._workCoffsB.fill(0);
            else
                this._workCoffsB = new Float64Array(orderB);
        }
    }
    /**
     * Assess length and turn to determine a stroke count.
     * * this method is used by both BSplineCurve3d and BSplineCurve3dH.
     * * points are accessed via getPolePoint3d.
     *   * Hence a zero-weight pole will be a problem
     * @param options stroke options structure.
     */
    computeStrokeCountForOptions(options) {
        this.getPolePoint3d(0, this._workPoint0);
        this.getPolePoint3d(1, this._workPoint1);
        let numStrokes = 1;
        if (this._workPoint0 && this._workPoint1) {
            let dx0 = this._workPoint1.x - this._workPoint0.x;
            let dy0 = this._workPoint1.y - this._workPoint0.y;
            let dz0 = this._workPoint1.z - this._workPoint0.z;
            let dx1, dy1, dz1; // first differences of leading edge
            let sumRadians = 0.0;
            let thisLength = Geometry_1.Geometry.hypotenuseXYZ(dx0, dy0, dz0);
            this._workPoint1.setFromPoint3d(this._workPoint0);
            let sumLength = thisLength;
            let maxLength = thisLength;
            let maxRadians = 0.0;
            let thisRadians;
            for (let i = 2; this.getPolePoint3d(i, this._workPoint1); i++) {
                dx1 = this._workPoint1.x - this._workPoint0.x;
                dy1 = this._workPoint1.y - this._workPoint0.y;
                dz1 = this._workPoint1.z - this._workPoint0.z;
                thisRadians = Angle_1.Angle.radiansBetweenVectorsXYZ(dx0, dy0, dz0, dx1, dy1, dz1);
                sumRadians += thisRadians;
                maxRadians = Geometry_1.Geometry.maxAbsXY(thisRadians, maxRadians);
                thisLength = Geometry_1.Geometry.hypotenuseXYZ(dx1, dy1, dz1);
                sumLength += thisLength;
                maxLength = Geometry_1.Geometry.maxXY(maxLength, thisLength);
                dx0 = dx1;
                dy0 = dy1;
                dz0 = dz1;
                this._workPoint0.setFrom(this._workPoint1);
            }
            const length1 = maxLength * this.degree; // This may be larger than sumLength
            const length2 = Math.sqrt(length1 * sumLength); // This is in between
            let radians1 = maxRadians * (this.degree - 1); // As if worst case keeps happening.
            if (this.degree < 3)
                radians1 *= 3; // so quadratics aren't under-stroked
            const radians2 = Math.sqrt(radians1 * sumRadians);
            numStrokes = StrokeOptions_1.StrokeOptions.applyAngleTol(options, StrokeOptions_1.StrokeOptions.applyMaxEdgeLength(options, this.degree, length2), radians2, 0.1);
            if (options) {
                numStrokes = options.applyChordTolToLengthAndRadians(numStrokes, sumLength, radians1);
            }
        }
        return numStrokes;
    }
}
exports.BezierCurveBase = BezierCurveBase;


/***/ }),

/***/ "./lib/bspline/KnotVector.js":
/*!***********************************!*\
  !*** ./lib/bspline/KnotVector.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Bspline */
// import { Point2d } from "../Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
/**
 * Enumeration of the possible ways of converting a "periodic" knot vector to an open knot vector.
 * None (0) ==> no wrap possible
 * OpenByAddintControlPoints (1)  ==> wrapped by adding poles
 * OpenByRemovingKnots (2)  ==> wrapped by deleting extreme knots.
 * @public
 */
var BSplineWrapMode;
(function (BSplineWrapMode) {
    /** No conversion to periodic */
    BSplineWrapMode[BSplineWrapMode["None"] = 0] = "None";
    /** Convert to periodic by removing control points.  This is typical for closed bcurve constructed by control points with maximum continuity.
     * * Knots stay the same in open and periodic form.
     * * Periodic form omits {degree} control points.
     */
    BSplineWrapMode[BSplineWrapMode["OpenByAddingControlPoints"] = 1] = "OpenByAddingControlPoints";
    /** Convert to periodic by adding special knots.  This is typical of closed bcurve constructed as exact circular or elliptic arc
     * * 2 knots on each end are omitted in open form
     * * poles stay the same.
     */
    BSplineWrapMode[BSplineWrapMode["OpenByRemovingKnots"] = 2] = "OpenByRemovingKnots";
})(BSplineWrapMode = exports.BSplineWrapMode || (exports.BSplineWrapMode = {}));
/**
 * Array of non-decreasing numbers acting as a knot array for bsplines.
 *
 * * Essential identity: numKnots = numPoles + order = numPoles + degree - 1
 * * Various bspline libraries have confusion over how many "end knots" are needed. "Many" libraries (including MicroStation)
 *     incorrectly demand "order" knots at each end for clamping.   But only "order - 1" are really needed.
 * * This class uses the "order-1" convention.
 * * This class provides queries to convert among spanIndex and knotIndex
 * * A span is a single interval of the knots.
 * * The left knot of span {k} is knot {k+degree-1}
 * * This class provides queries to convert among spanFraction, fraction of knot range, and knot
 * * core computations (evaluateBasisFunctions) have leftKnotIndex and global knot value as inputs.  Caller's need to
 * know their primary values (global knot, spanFraction).
 * @public
 */
class KnotVector {
    /**
     *
     * * If knots is a number array or Float64Array, the those values become the local knot array.
     * * If knots is a simple number, the local knot array is allocated to that size but left as zeros.
     * @param knots
     * @param degree
     */
    constructor(knots, degree) {
        this.degree = degree;
        // default values to satisfy compiler -- real values hapn setupFixedValues or final else defers to user
        this._knot0 = 0.0;
        this._knot1 = 1.0;
        // satisfy the initialize checker ..
        if (Array.isArray(knots)) { // remark:  This ctor is private.  The callers (as of April 2019) do not use this path.
            this.knots = new Float64Array(knots.length);
            this.setKnots(knots);
            this.setupFixedValues();
        }
        else if (knots instanceof Float64Array) {
            this.knots = knots.slice();
            this.setupFixedValues();
        }
        else { // caller is responsible for filling array separately ...
            this.knots = new Float64Array(knots);
        }
    }
    /** Return the leftmost knot value (of the active interval, ignoring unclamped leading knots)*/
    get leftKnot() { return this._knot0; }
    /** Return the rightmost knot value (of the active interval, ignoring unclamped leading knots)*/
    get rightKnot() { return this._knot1; }
    /** Return the index of the leftmost knot of the active interval */
    get leftKnotIndex() { return this.degree - 1; }
    /** Return the index of the rightmost knot of the active interval */
    get rightKnotIndex() { return this.knots.length - this.degree; }
    /**
     * Return true if the bspline was created by adding poles in to "closed" structure
     */
    get wrappable() { return this._wrapMode === undefined ? BSplineWrapMode.None : this._wrapMode; }
    /** Set the wrappable flag.  This is used by serialize/deserialize to mark knotVector's that were converted from periodic style. */
    set wrappable(value) { this._wrapMode = value; }
    /** Return the number of bezier spans.  Not that this includes zero-length spans if there are repeated knots. */
    get numSpans() { return this.rightKnotIndex - this.leftKnotIndex; }
    /** copy degree and knots to a new KnotVector. */
    clone() { return new KnotVector(this.knots, this.degree); }
    setupFixedValues() {
        // These should be read-only . ..
        this._knot0 = this.knots[this.degree - 1];
        this._knot1 = this.knots[this.knots.length - this.degree];
    }
    /** Return the total knot distance from beginning to end. */
    get knotLength01() { return this._knot1 - this._knot0; }
    /**
     * Returns true if all numeric values have wraparound conditions for "closed" knotVector with specified wrap mode
     * @param mode optional test mode.  If undefined, use the this.wrappable.
     */
    testClosable(mode) {
        if (mode === undefined)
            mode = this.wrappable;
        const leftKnotIndex = this.leftKnotIndex;
        const rightKnotIndex = this.rightKnotIndex;
        const period = this.rightKnot - this.leftKnot;
        const degree = this.degree;
        const indexDelta = rightKnotIndex - leftKnotIndex;
        // maximum continuity mode .  . .
        if (mode === BSplineWrapMode.OpenByAddingControlPoints) {
            for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {
                const k1 = k0 + indexDelta;
                if (!Geometry_1.Geometry.isSameCoordinate(this.knots[k0] + period, this.knots[k1]))
                    return false;
            }
            return true;
        }
        // arc mode ...
        if (mode === BSplineWrapMode.OpenByRemovingKnots) {
            // we expect {degree} replicated knots at each end . . .
            const numRepeated = degree - 1;
            const leftKnot = this.knots[leftKnotIndex];
            const rightKnot = this.knots[rightKnotIndex];
            for (let i = 0; i < numRepeated; i++) {
                if (!Geometry_1.Geometry.isSameCoordinate(leftKnot, this.knots[leftKnotIndex - i - 1]))
                    return false;
                if (!Geometry_1.Geometry.isSameCoordinate(rightKnot, this.knots[rightKnotIndex + i + 1]))
                    return false;
            }
            return true;
        }
        return false;
    }
    /** Test matching degree and knot values */
    isAlmostEqual(other) {
        if (this.degree !== other.degree)
            return false;
        return PointHelpers_1.NumberArray.isAlmostEqual(this.knots, other.knots, KnotVector.knotTolerance);
    }
    /** install knot values from an array, optionally ignoring first and last.
     */
    setKnots(knots, skipFirstAndLast) {
        const numAllocate = skipFirstAndLast ? knots.length - 2 : knots.length;
        if (numAllocate !== this.knots.length)
            this.knots = new Float64Array(numAllocate);
        if (skipFirstAndLast) {
            for (let i = 1; i + 1 < knots.length; i++)
                this.knots[i - 1] = knots[i];
        }
        else {
            for (let i = 0; i < knots.length; i++)
                this.knots[i] = knots[i];
        }
        this.setupFixedValues();
    }
    /**
     * Create knot vector with {degree-1} replicated knots at start and end, and uniform knots between.
     * @param numPoles Number of poles
     * @param degree degree of polynomial
     * @param a0 left knot value for active interval
     * @param a1 right knot value for active interval
     */
    static createUniformClamped(numPoles, degree, a0, a1) {
        const knots = new KnotVector(numPoles + degree - 1, degree);
        let k = 0;
        for (let m = 0; m < degree; m++)
            knots.knots[k++] = a0;
        const du = 1.0 / (numPoles - degree);
        for (let i = 1; i + degree < numPoles; i++)
            knots.knots[k++] = a0 + i * du * (a1 - a0);
        for (let m = 0; m < degree; m++)
            knots.knots[k++] = a1;
        knots.setupFixedValues();
        return knots;
    }
    /**
     * Create knot vector with {degree-1} replicated knots at start and end, and uniform knots between.
     * @param  numInterval number of intervals in knot space.  (NOT POLE COUNT)
     * @param degree degree of polynomial
     * @param a0 left knot value for active interval
     * @param a1 right knot value for active interval
     */
    static createUniformWrapped(numInterval, degree, a0, a1) {
        const knots = new KnotVector(numInterval + 2 * degree - 1, degree);
        const du = 1.0 / numInterval;
        for (let i = 1 - degree, k = 0; i < numInterval + degree; i++, k++) {
            knots.knots[k] = Geometry_1.Geometry.interpolate(a0, i * du, a1);
        }
        knots.setupFixedValues();
        return knots;
    }
    /**
     * Create knot vector with given knot values and degree.
     * @param knotArray knot values
     * @param degree degree of polynomial
     * @param skipFirstAndLast true to skip class overclamped end knots.
     */
    static create(knotArray, degree, skipFirstAndLast) {
        const numAllocate = skipFirstAndLast ? knotArray.length - 2 : knotArray.length;
        const knots = new KnotVector(numAllocate, degree);
        knots.setKnots(knotArray, skipFirstAndLast);
        return knots;
    }
    /**
     * Return the average of degree consecutive knots beginning at spanIndex.
     */
    grevilleKnot(spanIndex) {
        if (spanIndex < 0)
            return this.leftKnot;
        if (spanIndex > this.rightKnotIndex)
            return this.rightKnot;
        let sum = 0.0;
        for (let i = spanIndex; i < spanIndex + this.degree; i++)
            sum += this.knots[i];
        return sum / this.degree;
    }
    /** Return an array sized for a set of the basis function values. */
    createBasisArray() { return new Float64Array(this.degree + 1); }
    /** Convert localFraction within the interval following an indexed knot to a knot value. */
    baseKnotFractionToKnot(knotIndex0, localFraction) {
        const knot0 = this.knots[knotIndex0];
        return knot0 + localFraction * (this.knots[knotIndex0 + 1] - knot0);
    }
    /** Convert localFraction within an indexed bezier span to a knot value. */
    spanFractionToKnot(spanIndex, localFraction) {
        const k = this.spanIndexToLeftKnotIndex(spanIndex);
        return this.knots[k] + localFraction * (this.knots[k + 1] - this.knots[k]);
    }
    /** Convert localFraction within an indexed bezier span to fraction of active knot range. */
    spanFractionToFraction(spanIndex, localFraction) {
        const knot = this.spanFractionToKnot(spanIndex, localFraction);
        return (knot - this.leftKnot) / (this.rightKnot - this.leftKnot);
    }
    /** Return fraction of active knot range to knot value. */
    fractionToKnot(fraction) {
        return Geometry_1.Geometry.interpolate(this.knots[this.degree - 1], fraction, this.knots[this.knots.length - this.degree]);
    }
    /**
     * Evaluate basis functions f[] at knot value u.
     *
     * @param u knot value for evaluation
     * @param f array of basis values.  ASSUMED PROPER LENGTH
     */
    evaluateBasisFunctions(knotIndex0, u, f) {
        f[0] = 1.0;
        if (this.degree < 1)
            return;
        // direct compute for linear part ...
        const u0 = this.knots[knotIndex0];
        const u1 = this.knots[knotIndex0 + 1];
        f[1] = (u - u0) / (u1 - u0);
        f[0] = 1.0 - f[1];
        if (this.degree < 2)
            return;
        for (let depth = 1; depth < this.degree; depth++) {
            let kLeft = knotIndex0 - depth;
            let kRight = kLeft + depth + 1;
            let gCarry = 0.0;
            for (let step = 0; step <= depth; step++) {
                const tLeft = this.knots[kLeft++];
                const tRight = this.knots[kRight++];
                const fraction = (u - tLeft) / (tRight - tLeft);
                const g1 = f[step] * fraction;
                const g0 = f[step] * (1.0 - fraction);
                f[step] = gCarry + g0;
                gCarry = g1;
            }
            f[depth + 1] = gCarry;
        }
    }
    /**
     * Evaluate basis fucntions f[] at knot value u.
     *
     * @param u knot value for evaluation
     * @param f array of basis values.  ASSUMED PROPER LENGTH
     */
    evaluateBasisFunctions1(knotIndex0, u, f, df, ddf) {
        f[0] = 1.0;
        df[0] = 0.0;
        if (this.degree < 1)
            return;
        // direct compute for linear part ...
        const u0 = this.knots[knotIndex0];
        const u1 = this.knots[knotIndex0 + 1];
        // ah = 1/(u1-u0)      is the derivative of fraction0
        // (-ah) is the derivative of fraction1.
        let ah = 1.0 / (u1 - u0);
        f[1] = (u - u0) * ah;
        f[0] = 1.0 - f[1];
        df[0] = -ah;
        df[1] = ah;
        if (ddf) { // first derivative started constant, second derivative started zero.
            ddf[0] = 0.0;
            ddf[1] = 0.0;
        }
        if (this.degree < 2)
            return;
        for (let depth = 1; depth < this.degree; depth++) {
            let kLeft = knotIndex0 - depth;
            let kRight = kLeft + depth + 1;
            let gCarry = 0.0;
            let dgCarry = 0.0;
            let ddgCarry = 0.0;
            // f, df, ddf, are each row vectors with product of `step` linear terms.
            // f is multiplied on the right by matrix V.  Each row has 2 nonzero entries (which sum to 1)  (0,0,1-fraction, fraction,0,0,0)
            //    Each row of the derivative dV is two entries (0,0, -1/h, 1/h,0,0,0)
            // Hence fnew = f * V
            //      dfnew = df * V + f * dV
            //      ddfnew = ddf * V + df*dV + df * dV + f * ddV
            // but ddV is zero so
            //      ddfnew = ddf * V + 2 * df * dV
            for (let step = 0; step <= depth; step++) {
                const tLeft = this.knots[kLeft++];
                const tRight = this.knots[kRight++];
                ah = 1.0 / (tRight - tLeft);
                const fraction = (u - tLeft) * ah;
                const fraction1 = 1.0 - fraction;
                const g1 = f[step] * fraction;
                const g0 = f[step] * fraction1;
                const dg1 = df[step] * fraction + f[step] * ah;
                const dg0 = df[step] * fraction1 - f[step] * ah;
                const dfSave = 2.0 * df[step] * ah;
                f[step] = gCarry + g0;
                df[step] = dgCarry + dg0;
                gCarry = g1;
                dgCarry = dg1;
                if (ddf) { // do the backward reference to df before rewriting df !!!
                    const ddg1 = ddf[step] * fraction + dfSave;
                    const ddg0 = ddf[step] * fraction1 - dfSave;
                    ddf[step] = ddgCarry + ddg0;
                    ddgCarry = ddg1;
                }
            }
            f[depth + 1] = gCarry;
            df[depth + 1] = dgCarry;
            if (ddf)
                ddf[depth + 1] = ddgCarry;
        }
    }
    /** Return the (highest) index of the knot less than or equal to u */
    knotToLeftKnotIndex(u) {
        // Anything to left is in the first span . .
        const firstLeftKnot = this.degree - 1;
        if (u < this.knots[firstLeftKnot + 1])
            return firstLeftKnot;
        // Anything to right is in the last span ...
        const lastLeftKnot = this.knots.length - this.degree - 1;
        if (u >= this.knots.length - this.degree)
            return this.knots[lastLeftKnot];
        // ugh ... linear search ...
        for (let i = firstLeftKnot + 1; i < lastLeftKnot; i++)
            if (u < this.knots[i + 1])
                return i; // testing against right side skips over multiple knot cases???
        return lastLeftKnot;
    }
    /**
     * Given a span index, return the index of the knot at its left.
     * @param spanIndex index of span
     */
    spanIndexToLeftKnotIndex(spanIndex) {
        const d = this.degree;
        if (spanIndex <= 0.0)
            return d - 1;
        return Math.min(spanIndex + d - 1, this.knots.length - d);
    }
    /** Return the knot interval length of indexed bezier span. */
    spanIndexToSpanLength(spanIndex) {
        const k = this.spanIndexToLeftKnotIndex(spanIndex);
        return this.knots[k + 1] - this.knots[k];
    }
    /**
     * Given a span index, test if it is within range and has nonzero length.
     * * note that a false return does not imply there are no more spans.  This may be a double knot (zero length span) followed by more real spans
     * @param spanIndex index of span to test.
     */
    isIndexOfRealSpan(spanIndex) {
        if (spanIndex >= 0 && spanIndex < this.knots.length - this.degree)
            return !Geometry_1.Geometry.isSmallMetricDistance(this.spanIndexToSpanLength(spanIndex));
        return false;
    }
    /** Reflect all knots so `leftKnot` and `rightKnot` are maintained but interval lengths reverse. */
    reflectKnots() {
        const a = this.leftKnot;
        const b = this.rightKnot;
        const numKnots = this.knots.length;
        for (let i = 0; i < numKnots; i++)
            this.knots[i] = a + (b - this.knots[i]);
        this.knots.reverse();
    }
    /**
     * return a simple array form of the knots.  optionally replicate the first and last
     * in classic over-clamped manner
     */
    copyKnots(includeExtraEndKnot) {
        const wrap = this.wrappable === BSplineWrapMode.OpenByAddingControlPoints && this.testClosable();
        const leftIndex = this.leftKnotIndex;
        const rightIndex = this.rightKnotIndex;
        const a0 = this.leftKnot;
        const a1 = this.rightKnot;
        const delta = a1 - a0;
        const degree = this.degree;
        const values = [];
        if (includeExtraEndKnot) {
            if (wrap) {
                values.push(this.knots[rightIndex - degree] - delta);
            }
            else {
                values.push(this.knots[0]);
            }
        }
        for (const u of this.knots)
            values.push(u);
        if (includeExtraEndKnot) {
            if (wrap) {
                values.push(this.knots[leftIndex + degree] + delta);
            }
            else
                values.push(values[values.length - 1]);
        }
        return values;
    }
}
exports.KnotVector = KnotVector;
/** tolerance for considering two knots to be the same. */
KnotVector.knotTolerance = 1.0e-9;


/***/ }),

/***/ "./lib/bspline/SurfaceLocationDetail.js":
/*!**********************************************!*\
  !*** ./lib/bspline/SurfaceLocationDetail.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
/**
 * CurveLocationDetail carries point and paramter data about a point evaluated on a curve.
 * * These are returned by a variety of queries.
 * * Particular contents can vary among the queries.
 * @public
 */
class UVSurfaceLocationDetail {
    /** Construct with empty data. */
    constructor(surface, uv, point) {
        this.surface = surface;
        this.point = point ? point : Point3dVector3d_1.Point3d.createZero();
        this.uv = uv ? uv : Point2dVector2d_1.Point2d.createZero();
        this.a = 0.0;
    }
    /**
     * Create a new detail structure.
     * @param surface
     * @param uv coordinates to copy (not capture) into the `detail.uv`
     * @param point coordinates to copy (not capture) into the `detail.point`
     */
    static createSurfaceUVPoint(surface, uv, point) {
        const detail = new UVSurfaceLocationDetail(surface);
        if (uv)
            detail.uv.setFrom(uv);
        detail.point.setFromPoint3d(point);
        return detail;
    }
}
exports.UVSurfaceLocationDetail = UVSurfaceLocationDetail;
/**
 * Carrier for both curve and surface data, e.g. from intersection calculations.
 * @public
 */
class CurveAndSurfaceLocationDetail {
    /** CAPTURE both details . . */
    constructor(curveDetail, surfaceDetail) {
        this.curveDetail = curveDetail;
        this.surfaceDetail = surfaceDetail;
    }
}
exports.CurveAndSurfaceLocationDetail = CurveAndSurfaceLocationDetail;


/***/ }),

/***/ "./lib/clipping/ClipPlane.js":
/*!***********************************!*\
  !*** ./lib/clipping/ClipPlane.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Plane3dByOriginAndUnitNormal_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndUnitNormal */ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const ClipUtils_1 = __webpack_require__(/*! ./ClipUtils */ "./lib/clipping/ClipUtils.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const PolygonOps_1 = __webpack_require__(/*! ../geometry3d/PolygonOps */ "./lib/geometry3d/PolygonOps.js");
/** A ClipPlane is a single plane represented as
 * * An inward unit normal (u,v,w)
 * * A signedDistance
 *
 * Hence
 * * The halfspace function evaluation for "point" [x,y,z,] is: ([x,y,z] DOT (u,v,w)l - signedDistance)
 * * POSITIVE values of the halfspace function are "inside"
 * * ZERO value of the halfspace function is "on"
 * * NEGATIVE value of the halfspace function is "outside"
 * * A representative point on the plane is (signedDistance*u, signedDistance * v, signedDistance *w)
 * * Given a point and inward normal, the signedDistance is (point DOT normal)
 * @public
 */
class ClipPlane {
    constructor(normal, distance, invisible, interior) {
        this._invisible = invisible;
        this._interior = interior;
        this._inwardNormal = normal;
        this._distanceFromOrigin = distance;
    }
    safeSetXYZDistance(nx, ny, nz, d) {
        this._inwardNormal.set(nx, ny, nz);
        this._distanceFromOrigin = d;
    }
    /**
     * Return true if all members are almostEqual to corresponding members of other.
     * @param other clip plane to compare
     */
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSameCoordinate(this._distanceFromOrigin, other._distanceFromOrigin)
            && this._inwardNormal.isAlmostEqual(other._inwardNormal)
            && this._interior === other._interior
            && this._invisible === other._invisible;
    }
    /** return a cloned plane */
    clone() {
        const result = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);
        return result;
    }
    /** return Return a cloned plane with coordinate data negated. */
    cloneNegated() {
        const plane = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);
        plane.negateInPlace();
        return plane;
    }
    /** Create a ClipPlane from Plane3dByOriginAndUnitNormal. */
    static createPlane(plane, invisible = false, interior = false, result) {
        const distance = plane.getNormalRef().dotProduct(plane.getOriginRef());
        if (result) {
            result._invisible = invisible;
            result._interior = interior;
            result._inwardNormal = plane.getNormalRef().clone();
            result._distanceFromOrigin = distance;
            return result;
        }
        return new ClipPlane(plane.getNormalRef().clone(), distance, invisible, interior);
    }
    /**
     * * Create a ClipPlane with direct normal and signedDistance.
     * * The vector is normalized for storage.
     */
    static createNormalAndDistance(normal, distance, invisible = false, interior = false, result) {
        const normalized = normal.normalize();
        if (normalized) {
            if (result) {
                result._invisible = invisible;
                result._interior = interior;
                result._inwardNormal = normalized;
                result._distanceFromOrigin = distance;
            }
            return new ClipPlane(normalized, distance, invisible, interior);
        }
        return undefined;
    }
    /** Create a ClipPlane
     * * "normal" is the inward normal of the plane. (It is internally normalized)
     * * "point" is any point of the plane.
     * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as a vector from the origin.)
     */
    static createNormalAndPoint(normal, point, invisible = false, interior = false, result) {
        const normalized = normal.normalize();
        if (normalized) {
            const distance = normalized.dotProduct(point);
            if (result) {
                result._invisible = invisible;
                result._interior = interior;
                result._inwardNormal = normalized;
                result._distanceFromOrigin = distance;
            }
            return new ClipPlane(normalized, distance, invisible, interior);
        }
        return undefined;
    }
    /** Create a ClipPlane
     * * "normal" (normalX, normalY, nz) is the inward normal of the plane.
     * * The given (normalX,normalY,normalZ)
     * * "point" is any point of the plane.
     * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as a vector from the origin.)
     */
    static createNormalAndPointXYZXYZ(normalX, normalY, normalZ, originX, originY, originZ, invisible = false, interior = false, result) {
        const q = Geometry_1.Geometry.hypotenuseXYZ(normalX, normalY, normalZ);
        const r = Geometry_1.Geometry.conditionalDivideFraction(1, q);
        if (r !== undefined) {
            if (result) {
                result._inwardNormal.set(normalX * r, normalY * r, normalZ * r);
                result._distanceFromOrigin = result._inwardNormal.dotProductXYZ(originX, originY, originZ);
                result._invisible = invisible;
                result._interior = interior;
                return result;
            }
            const normal = Point3dVector3d_1.Vector3d.create(normalX * r, normalY * r, normalZ * r);
            return new ClipPlane(normal, normal.dotProductXYZ(originX, originY, originZ), invisible, interior);
        }
        return undefined;
    }
    /**
     * return a json object of the form
     * `{"normal":[u,v,w],"dist":signedDistanceValue,"interior":true,"invisible":true}`
     */
    toJSON() {
        const val = {};
        val.normal = this.inwardNormalRef.toJSON();
        val.dist = this.distance;
        if (this.interior)
            val.interior = true;
        if (this.invisible)
            val.invisible = true;
        return val;
    }
    /** parse json object to ClipPlane instance */
    static fromJSON(json, result) {
        if (json && json.normal && Number.isFinite(json.dist)) {
            return ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.fromJSON(json.normal), json.dist, !!json.invisible, !!json.interior);
        }
        return ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.unitZ(), 0, false, false, result);
    }
    /** Set both the invisible and interior flags. */
    setFlags(invisible, interior) {
        this._invisible = invisible;
        this._interior = interior;
    }
    /**
     * Return the stored distanceFromOrigin property.
     */
    get distance() { return this._distanceFromOrigin; }
    /**
     * Return the stored inward normal property.
     */
    get inwardNormalRef() { return this._inwardNormal; }
    /**
     * Return the "interior" property bit
     */
    get interior() { return this._interior; }
    /**
     * Return the "invisible" property bit.
     */
    get invisible() { return this._invisible; }
    /**
     * Create a plane defined by two points, an up vector, and a tilt angle relative to the up vector.
     * @param point0 start point of the edge
     * @param point1 end point of the edge
     * @param upVector vector perpendicular to the plane
     * @param tiltAngle angle to tilt the plane around the edge in the direction of the up vector.
     * @param result optional preallocated plane
     */
    static createEdgeAndUpVector(point0, point1, upVector, tiltAngle, result) {
        const edgeVector = Point3dVector3d_1.Vector3d.createFrom(point1.minus(point0));
        let normal = (upVector.crossProduct(edgeVector)).normalize();
        if (normal) {
            if (!tiltAngle.isAlmostZero) {
                const tiltNormal = Point3dVector3d_1.Vector3d.createRotateVectorAroundVector(normal, edgeVector, tiltAngle);
                if (tiltNormal) {
                    normal = tiltNormal.clone();
                }
            }
            normal.negate(normal);
            return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);
        }
        return undefined;
    }
    /**
     * Create a plane perpendicular to the edge between the xy parts of point0 and point1
     */
    static createEdgeXY(point0, point1, result) {
        const normal = Point3dVector3d_1.Vector3d.create(point0.y - point1.y, point1.x - point0.x);
        if (normal.normalizeInPlace())
            return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);
        return undefined;
    }
    /**
     * Return the Plane3d form of the plane.
     * * The plane origin is the point `distance * inwardNormal`
     * * The plane normal is the inward normal of the ClipPlane.
     */
    getPlane3d() {
        const d = this._distanceFromOrigin;
        // Normal should be normalized, will not return undefined
        return Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.create(Point3dVector3d_1.Point3d.create(this._inwardNormal.x * d, this._inwardNormal.y * d, this._inwardNormal.z * d), this._inwardNormal);
    }
    /**
     * Return the Point4d d form of the plane.
     * * The homogeneous xyz are the inward normal xyz.
     * * The homogeneous weight is the negated ClipPlane distance.
     */
    getPlane4d() {
        return Point4d_1.Point4d.create(this._inwardNormal.x, this._inwardNormal.y, this._inwardNormal.z, -this._distanceFromOrigin);
    }
    /**
     * Set the plane from DPoint4d style plane.
     * * The saved plane has its direction normalized.
     * * This preserves the plane itself as a zero set but make plane evaluations act as true distances (even if the plane coefficients are scaled otherwise)
     * @param plane
     */
    setPlane4d(plane) {
        const a = Math.sqrt(plane.x * plane.x + plane.y * plane.y + plane.z * plane.z);
        const r = a === 0.0 ? 1.0 : 1.0 / a;
        this._inwardNormal.x = r * plane.x;
        this._inwardNormal.y = r * plane.y;
        this._inwardNormal.z = r * plane.z;
        this._distanceFromOrigin = -r * plane.w;
    }
    /**
     * Evaluate the distance from the plane to a point in space, i.e. (dot product with inward normal) minus distance
     * @param point space point to test
     * @deprecated Instead of `clipPlane.evaluatePoint(spacePoint)` use `clipPlane.altitude(spacePoint)` (for compatibility with interface `PlaneAltitudeEvaluator`)
     */
    evaluatePoint(point) {
        return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z - this._distanceFromOrigin;
    }
    /**
     * Evaluate the altitude in weighted space, i.e. (dot product with inward normal) minus distance, with point.w scale applied to distance)
     * @param point space point to test
     */
    weightedAltitude(point) {
        return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z - point.w * this._distanceFromOrigin;
    }
    /**
     * Evaluate the distance from the plane to a point in space, i.e. (dot product with inward normal) minus distance
     * @param point space point to test
     */
    altitude(point) {
        return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z - this._distanceFromOrigin;
    }
    /**
     * Evaluate the distance from the plane to a point in space with point given as x,y,z, i.e. (dot product with inward normal) minus distance
     * @param point space point to test
     */
    altitudeXYZ(x, y, z) {
        return x * this._inwardNormal.x + y * this._inwardNormal.y + z * this._inwardNormal.z - this._distanceFromOrigin;
    }
    /** Return the dot product of the plane normal with the vector (NOT using the plane's distanceFromOrigin).
     * @deprecated Instead of `clipPlane.dotProduct (vector)` use `clipPlane.velocity(vector)` for compatibility with interface `PlaneAltitudeEvaluator`
     */
    dotProductVector(vector) {
        return vector.x * this._inwardNormal.x + vector.y * this._inwardNormal.y + vector.z * this._inwardNormal.z;
    }
    /** Return the dot product of the plane normal with the vector (NOT using the plane's distanceFromOrigin).
     */
    velocity(vector) {
        return vector.x * this._inwardNormal.x + vector.y * this._inwardNormal.y + vector.z * this._inwardNormal.z;
    }
    /** Return the dot product of the plane normal with the x,yz, vector components (NOT using the plane's distanceFromOrigin).
     */
    velocityXYZ(x, y, z) {
        return x * this._inwardNormal.x + y * this._inwardNormal.y + z * this._inwardNormal.z;
    }
    /** Return the dot product of the plane normal with the point (treating the point xyz as a vector, and NOT using the plane's distanceFromOrigin).
     */
    dotProductPlaneNormalPoint(point) {
        return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z;
    }
    /**
     * Return true if spacePoint is inside or on the plane, with tolerance applied to "on".
     * @param spacePoint point to test.
     * @param tolerance tolerance for considering "near plane" to be "on plane"
     */
    isPointOnOrInside(spacePoint, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        let value = this.altitude(spacePoint);
        if (tolerance) {
            value += tolerance;
        }
        return value >= 0.0;
    }
    /**
     * Return true if spacePoint is strictly inside the halfspace, with tolerance applied to "on".
     * @param spacePoint point to test.
     * @param tolerance tolerance for considering "near plane" to be "on plane"
     */
    isPointInside(point, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        let value = this.altitude(point);
        if (tolerance) {
            value -= tolerance;
        }
        return value > 0.0;
    }
    /**
     * Return true if spacePoint is strictly on the plane, within tolerance
     * @param spacePoint point to test.
     * @param tolerance tolerance for considering "near plane" to be "on plane"
     */
    isPointOn(point, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        return Math.abs(this.altitude(point)) <= tolerance;
    }
    /**
     * Compute intersections of an (UNBOUNDED) arc with the plane.  Append them (as radians) to a growing array.
     * @param arc arc to test.  The angle limits of the arc are NOT considered.
     * @param intersectionRadians array to receive results
     */
    appendIntersectionRadians(arc, intersectionRadians) {
        const arcVectors = arc.toVectors();
        const alpha = this.altitude(arc.center);
        const beta = this.velocity(arcVectors.vector0);
        const gamma = this.velocity(arcVectors.vector90);
        Polynomials_1.AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, undefined, undefined, intersectionRadians);
    }
    /** Announce fractional intervals of arc clip.
     * * Each call to `announce(fraction0, fraction1, arc)` announces one interval that is inside the clip plane.
     */
    announceClippedArcIntervals(arc, announce) {
        const breaks = ClipPlane._clipArcFractionArray;
        breaks.clear();
        this.appendIntersectionRadians(arc, breaks);
        arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);
        return ClipUtils_1.ClipUtilities.selectIntervals01(arc, breaks, this, announce);
    }
    /**
     * * Compute intersection of (unbounded) segment with the plane.
     * * If the ends are on the same side of the plane, return undefined.
     * * If the intersection is an endpoint or interior to the segment return the fraction.
     * * If both ends are on, return undefined.
     */
    getBoundedSegmentSimpleIntersection(pointA, pointB) {
        const h0 = this.altitude(pointA);
        const h1 = this.altitude(pointB);
        if (h0 * h1 > 0.0)
            return undefined;
        if (h0 === 0.0 && h1 === 0.0) {
            return undefined;
        }
        return -h0 / (h1 - h0);
    }
    /** Apply transform to the origin.  Apply inverse transpose of the matrix part to th normal vector. */
    transformInPlace(transform) {
        const plane = this.getPlane3d();
        const matrix = transform.matrix;
        const newPoint = transform.multiplyPoint3d(plane.getOriginRef());
        // Normal transforms as the inverse transpose of the matrix part
        // BTW: If the matrix is orthogonal, this is a long way to multiply by the matrix part (mumble grumble)
        const newNormal = matrix.multiplyInverseTranspose(plane.getNormalRef());
        if (!newNormal)
            return false;
        plane.set(newPoint, newNormal);
        const normalized = (plane.getNormalRef()).normalize();
        if (!normalized)
            return false;
        this._inwardNormal = normalized;
        this._distanceFromOrigin = this._inwardNormal.dotProduct(plane.getOriginRef());
        return true;
    }
    /** Set the invisible flag.   Interpretation of this is up to the use code algorithms. */
    setInvisible(invisible) {
        this._invisible = invisible;
    }
    /**  reverse the sign of all coefficients, so outside and inside reverse */
    negateInPlace() {
        this._inwardNormal = this._inwardNormal.negate();
        this._distanceFromOrigin = -this._distanceFromOrigin;
    }
    /**
     * Move the plane INWARD by given distance
     * @param offset distance of shift inwards
     */
    offsetDistance(offset) {
        this._distanceFromOrigin += offset;
    }
    /**
     * Clip a polygon, returning the clip result in the same object.
     * @param xyz input/output polygon
     * @param work scratch object
     * @param tolerance tolerance for on-plane decision.
     * @deprecated Instead of `clipPlane.convexPolygonClipInPlace (xyz, work, tolerance)` use `PolygonOps.clipConvexPoint3dPolygonInPlace (clipPlane, xyz, work, tolerance)`
     */
    convexPolygonClipInPlace(xyz, work, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        return PolygonOps_1.Point3dArrayPolygonOps.convexPolygonClipInPlace(this, xyz, work, tolerance);
    }
    /**
     * Clip a polygon to the inside or outside of the plane.
     * * Results with 2 or fewer points are ignored.
     * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.
     * @param xyz input points.
     * @param work work buffer
     * @param tolerance tolerance for "on plane" decision.
     */
    clipConvexPolygonInPlace(xyz, work, inside = true, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        return PolygonOps_1.IndexedXYZCollectionPolygonOps.clipConvexPolygonInPlace(this, xyz, work, inside, tolerance);
    }
    /**
     * Split a (convex) polygon into 2 parts.
     * @param xyz original polygon
     * @param xyzIn array to receive inside part
     * @param xyzOut array to receive outside part
     * @param altitudeRange min and max altitudes encountered.
     * @deprecated instead of `plane.convexPolygonSplitInsideOutside (xyz, xyzIn, xyzOut, altitudeRange)` use `PolygonOops.splitConvexPolygonInsideOutsidePlane(this, xyz, xyzIn, xyzOut, altitudeRange)`
     */
    convexPolygonSplitInsideOutside(xyz, xyzIn, xyzOut, altitudeRange) {
        PolygonOps_1.Point3dArrayPolygonOps.convexPolygonSplitInsideOutsidePlane(this, xyz, xyzIn, xyzOut, altitudeRange);
    }
    /**
     * Split a (convex) polygon into 2 parts.
     * @param xyz original polygon
     * @param xyzIn array to receive inside part
     * @param xyzOut array to receive outside part
     * @param altitudeRange min and max altitudes encountered.
     * @deprecated instead of `plane.convexPolygonSplitInsideOutsideGrowableArrays (xyz, xyzIn, xyzOut, altitudeRange)` use `PolygonOops.splitConvexPoint3dArrayolygonInsideOutsidePlane(this, xyz, xyzIn, xyzOut, altitudeRange)`
     */
    convexPolygonSplitInsideOutsideGrowableArrays(xyz, xyzIn, xyzOut, altitudeRange) {
        PolygonOps_1.IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(this, xyz, xyzIn, xyzOut, altitudeRange);
    }
    /**
     * Multiply the ClipPlane's DPoint4d by matrix.
     * @param matrix matrix to apply.
     * @param invert if true, use in verse of the matrix.
     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)
     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA
     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.
     * * Both params default to true to get the full effect of transforming space.
     * @param matrix matrix to apply
     * @return false if unable to invert
     */
    multiplyPlaneByMatrix4d(matrix, invert = true, transpose = true) {
        const plane = this.getPlane4d();
        if (invert) {
            const inverse = matrix.createInverse();
            if (inverse)
                return this.multiplyPlaneByMatrix4d(inverse, false, transpose);
            return false;
        }
        if (transpose)
            matrix.multiplyTransposePoint4d(plane, plane);
        else
            matrix.multiplyPoint4d(plane, plane);
        this.setPlane4d(plane);
        return true;
    }
    /** Return an array containing
     * * All points that are exactly on the plane.
     * * Crossing points between adjacent points that are (strictly) on opposite sides.
     * @deprecated ClipPlane method `clipPlane.polygonCrossings(polygonPoints, crossings)` is deprecated.  Use Point3dArrayPolygonOps.polygonPlaneCrossings (clipPlane, polygonPoints, crossings)`
     */
    polygonCrossings(xyz, crossings) {
        return PolygonOps_1.Point3dArrayPolygonOps.polygonPlaneCrossings(this, xyz, crossings);
    }
    /** announce the interval (if any) where a line is within the clip plane half space. */
    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {
        if (f1 < f0)
            return false;
        const h0 = -this.altitude(pointA);
        const h1 = -this.altitude(pointB);
        const delta = h1 - h0;
        const f = Geometry_1.Geometry.conditionalDivideFraction(-h0, delta);
        if (f === undefined) { // The segment is parallel to the plane.
            if (h0 <= 0.0) {
                if (announce)
                    announce(f0, f1);
                return true;
            }
            return false;
        }
        if (delta > 0) { // segment aims OUT
            if (f < f1)
                f1 = f;
        }
        else {
            // segment aims IN
            if (f > f0)
                f0 = f;
        }
        if (f1 < f0)
            return false;
        if (announce)
            announce(f0, f1);
        return true;
    }
    /**
     * Return a coordinate frame with
     * * origin at closest point to global origin
     * * z axis points in
     * x and y are "in plane"
     */
    getFrame() {
        const d = this._distanceFromOrigin;
        const origin = Point3dVector3d_1.Point3d.create(this._inwardNormal.x * d, this._inwardNormal.y * d, this._inwardNormal.z * d);
        const matrix = Matrix3d_1.Matrix3d.createRigidHeadsUp(this._inwardNormal, Geometry_1.AxisOrder.ZXY);
        return Transform_1.Transform.createOriginAndMatrix(origin, matrix);
    }
    /**
     * Return the intersection of the plane with a range cube.
     * @param range
     * @param xyzOut intersection polygon.  This is convex.
     */
    intersectRange(range, addClosurePoint = false) {
        if (range.isNull)
            return undefined;
        const corners = range.corners();
        const frameOnPlane = this.getFrame();
        frameOnPlane.multiplyInversePoint3dArrayInPlace(corners);
        const localRange = Range_1.Range3d.createArray(corners);
        if (localRange.low.z * localRange.high.z > 0.0)
            return undefined;
        // oversized polygon on local z= 0
        const xyzOut = new GrowableXYZArray_1.GrowableXYZArray();
        xyzOut.pushXYZ(localRange.low.x, localRange.low.y, 0);
        xyzOut.pushXYZ(localRange.high.x, localRange.low.y, 0);
        xyzOut.pushXYZ(localRange.high.x, localRange.high.y, 0);
        xyzOut.pushXYZ(localRange.low.x, localRange.high.y, 0);
        xyzOut.multiplyTransformInPlace(frameOnPlane);
        ClipPlane.intersectRangeConvexPolygonInPlace(range, xyzOut);
        if (xyzOut.length === 0)
            return undefined;
        if (addClosurePoint)
            xyzOut.pushWrap(1);
        return xyzOut;
    }
    /**
     * Return the intersection of the plane with a range cube.
     * @param range
     * @param xyzOut intersection polygon.  This is convex.
     */
    static intersectRangeConvexPolygonInPlace(range, xyz) {
        if (range.isNull)
            return undefined;
        const work = new GrowableXYZArray_1.GrowableXYZArray();
        // clip the polygon to each plane of the cubic ...
        const clipper = ClipPlane.createNormalAndPointXYZXYZ(-1, 0, 0, range.high.x, range.high.y, range.high.z);
        clipper.clipConvexPolygonInPlace(xyz, work);
        if (xyz.length === 0)
            return undefined;
        clipper.safeSetXYZDistance(0, -1, 0, -range.high.y);
        clipper.clipConvexPolygonInPlace(xyz, work);
        if (xyz.length === 0)
            return undefined;
        clipper.safeSetXYZDistance(0, 0, -1, -range.high.z);
        clipper.clipConvexPolygonInPlace(xyz, work);
        if (xyz.length === 0)
            return undefined;
        clipper.safeSetXYZDistance(1, 0, 0, range.low.x);
        clipper.clipConvexPolygonInPlace(xyz, work);
        if (xyz.length === 0)
            return undefined;
        clipper.safeSetXYZDistance(0, 1, 0, range.low.y);
        clipper.clipConvexPolygonInPlace(xyz, work);
        if (xyz.length === 0)
            return undefined;
        clipper.safeSetXYZDistance(0, 0, 1, range.low.z);
        clipper.clipConvexPolygonInPlace(xyz, work);
        if (xyz.length === 0)
            return undefined;
        return xyz;
    }
}
exports.ClipPlane = ClipPlane;
ClipPlane._clipArcFractionArray = new GrowableFloat64Array_1.GrowableFloat64Array();


/***/ }),

/***/ "./lib/clipping/ClipPrimitive.js":
/*!***************************************!*\
  !*** ./lib/clipping/ClipPrimitive.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const ClipPlane_1 = __webpack_require__(/*! ./ClipPlane */ "./lib/clipping/ClipPlane.js");
const ConvexClipPlaneSet_1 = __webpack_require__(/*! ./ConvexClipPlaneSet */ "./lib/clipping/ConvexClipPlaneSet.js");
const ClipUtils_1 = __webpack_require__(/*! ./ClipUtils */ "./lib/clipping/ClipUtils.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const PolygonOps_1 = __webpack_require__(/*! ../geometry3d/PolygonOps */ "./lib/geometry3d/PolygonOps.js");
const UnionOfConvexClipPlaneSets_1 = __webpack_require__(/*! ./UnionOfConvexClipPlaneSets */ "./lib/clipping/UnionOfConvexClipPlaneSets.js");
const Triangulation_1 = __webpack_require__(/*! ../topology/Triangulation */ "./lib/topology/Triangulation.js");
const Graph_1 = __webpack_require__(/*! ../topology/Graph */ "./lib/topology/Graph.js");
/**
 * Bit mask type for referencing subsets of 6 planes of range box.
 * @public
 */
var ClipMaskXYZRangePlanes;
(function (ClipMaskXYZRangePlanes) {
    /** no planes */
    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes["None"] = 0] = "None";
    /** low x plane */
    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes["XLow"] = 1] = "XLow";
    /** high x plane */
    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes["XHigh"] = 2] = "XHigh";
    /** low y plane */
    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes["YLow"] = 4] = "YLow";
    /** high y plane */
    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes["YHigh"] = 8] = "YHigh";
    /** low z plane */
    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes["ZLow"] = 16] = "ZLow";
    /** high z plane */
    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes["ZHigh"] = 32] = "ZHigh";
    /** all x and y planes, neither z plane */
    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes["XAndY"] = 15] = "XAndY";
    /** all 6 planes */
    ClipMaskXYZRangePlanes[ClipMaskXYZRangePlanes["All"] = 63] = "All";
})(ClipMaskXYZRangePlanes = exports.ClipMaskXYZRangePlanes || (exports.ClipMaskXYZRangePlanes = {}));
/**
 * * ClipPrimitive is a base class for clipping implementations that use
 *   * A ClipPlaneSet designated "clipPlanes"
 *   * an "invisible" flag
 * * When constructed directly, objects of type ClipPrimitive (directly, not through a derived class) will have just planes
 * * Derived classes (e.g. ClipShape) carry additional data of a swept shape.
 * * ClipPrimitive can be constructed with no planes.
 *     * Derived class is responsible for filling the plane sets.
 *     * At discretion of derived classes, plane construction can be done at construction time or "on demand when" queries call `ensurePlaneSets ()`
 * * ClipPrimitive can be constructed with planes (and no derived class).
 * @public
 */
class ClipPrimitive {
    constructor(planeSet, isInvisible = false) {
        this._clipPlanes = planeSet;
        this._invisible = isInvisible;
    }
    /** Get a reference to the `UnionOfConvexClipPlaneSets`.
     *  * It triggers construction of the sets by `this.ensurePlaneSets()`.
     *  * Derived class typically caches the set on the first such call.
     */
    fetchClipPlanesRef() { this.ensurePlaneSets(); return this._clipPlanes; }
    /** Ask if this primitive is a hole. */
    get invisible() { return this._invisible; }
    /**
     * Create a ClipPrimitive, capturing the supplied plane set as the clip planes.
     * @param planes clipper
     * @param isInvisible true to invert sense of the test
     */
    static createCapture(planes, isInvisible = false) {
        let planeData;
        if (planes instanceof UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets)
            planeData = planes;
        if (planes instanceof ConvexClipPlaneSet_1.ConvexClipPlaneSet)
            planeData = UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets.createConvexSets([planes]);
        return new ClipPrimitive(planeData, isInvisible);
    }
    /** Emit json form of the clip planes */
    toJSON() {
        const data = {};
        if (this._clipPlanes)
            data.clips = this._clipPlanes.toJSON();
        if (this._invisible)
            data.invisible = true;
        return { planes: data };
    }
    /**
     * Returns true if the planes are present.
     * * This can be false (for instance) if a ClipShape is holding a polygon but has not yet been asked to construct the planes.
     */
    arePlanesDefined() {
        return this._clipPlanes !== undefined;
    }
    /** Return a deep clone  */
    clone() {
        const newPlanes = this._clipPlanes ? this._clipPlanes.clone() : undefined;
        const result = new ClipPrimitive(newPlanes, this._invisible);
        return result;
    }
    /**
     * * trigger (if needed)  computation of plane sets (if applicable) in the derived class.
     * * Base class is no op.
     * * In derived class, on first call create planes sets from defining data (e.g. swept shape).
     * * In derived class, if planes are present leave them alone.
     */
    ensurePlaneSets() { }
    /** Return true if the point lies inside/on this polygon (or not inside/on if this polygon is a mask). Otherwise, return false.
     * * Note that a derived class may choose to (a) implement its own test using its defining data, or (b) accept this implementation using planes that it inserted in the base class.
     */
    pointInside(point, onTolerance = Geometry_1.Geometry.smallMetricDistanceSquared) {
        this.ensurePlaneSets();
        let inside = true;
        if (this._clipPlanes)
            inside = this._clipPlanes.isPointOnOrInside(point, onTolerance);
        if (this._invisible)
            inside = !inside;
        return inside;
    }
    /**
     * Multiply all ClipPlanes DPoint4d by matrix.
     * @param matrix matrix to apply.
     * @param invert if true, use in verse of the matrix.
     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)
     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA
     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.
     * * Both params default to true to get the full effect of transforming space.
     * @param matrix matrix to apply
     */
    multiplyPlanesByMatrix4d(matrix, invert = true, transpose = true) {
        if (invert) { // form inverse once here, reuse for all planes
            const inverse = matrix.createInverse();
            if (!inverse)
                return false;
            return this.multiplyPlanesByMatrix4d(inverse, false, transpose);
        }
        if (this._clipPlanes)
            this._clipPlanes.multiplyPlanesByMatrix4d(matrix);
        return true;
    }
    /** Apply a transform to the clipper (e.g. transform all planes) */
    transformInPlace(transform) {
        if (this._clipPlanes)
            this._clipPlanes.transformInPlace(transform);
        return true;
    }
    /** Sets both the clip plane set and the mask set visibility */
    setInvisible(invisible) {
        this._invisible = invisible;
    }
    /**
     * Return true if any plane of the primary clipPlanes has (a) non-zero z component in its normal vector and (b) finite distance from origin.
     */
    containsZClip() {
        if (this.fetchClipPlanesRef() !== undefined)
            for (const convexSet of this._clipPlanes.convexSets)
                for (const plane of convexSet.planes)
                    if (Math.abs(plane.inwardNormalRef.z) > 1.0e-6 && Math.abs(plane.distance) !== Number.MAX_VALUE)
                        return true;
        return false;
    }
    /**
     * Quick test of whether the given points fall completely inside or outside.
     * @param points points to test
     * @param ignoreInvisibleSetting if true, do the test with the clip planes and return that, ignoring the invisible setting.
     */
    classifyPointContainment(points, ignoreInvisibleSetting) {
        this.ensurePlaneSets();
        const planes = this._clipPlanes;
        let inside = ClipUtils_1.ClipPlaneContainment.StronglyInside;
        if (planes)
            inside = planes.classifyPointContainment(points, false);
        if (this._invisible && !ignoreInvisibleSetting)
            switch (inside) {
                case ClipUtils_1.ClipPlaneContainment.StronglyInside:
                    return ClipUtils_1.ClipPlaneContainment.StronglyOutside;
                case ClipUtils_1.ClipPlaneContainment.StronglyOutside:
                    return ClipUtils_1.ClipPlaneContainment.StronglyInside;
                case ClipUtils_1.ClipPlaneContainment.Ambiguous:
                    return ClipUtils_1.ClipPlaneContainment.Ambiguous;
            }
        return inside;
    }
    /** Promote json object form to class instance
     * * First try to convert to a ClipShape
     * * then try as a standalone instance of the base class ClipPrimitive.
     */
    static fromJSON(json) {
        // try known derived classes first . . .
        const shape = ClipShape.fromClipShapeJSON(json);
        if (shape)
            return shape;
        const prim = ClipPrimitive.fromJSONClipPrimitive(json);
        if (prim)
            return prim;
        return undefined;
    }
    /** Specific converter producing the base class ClipPrimitive. */
    static fromJSONClipPrimitive(json) {
        if (json && json.planes) {
            const planes = json.planes;
            const clipPlanes = planes.hasOwnProperty("clips") ? UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets.fromJSON(planes.clips) : undefined;
            const invisible = planes.hasOwnProperty("invisible") ? planes.invisible : false;
            return new ClipPrimitive(clipPlanes, invisible);
        }
        return undefined;
    }
}
exports.ClipPrimitive = ClipPrimitive;
/** Internal helper class holding XYZ components that serves as a representation of polygon edges defined by clip planes */
class PolyEdge {
    constructor(origin, next, normal, z) {
        this.origin = Point3dVector3d_1.Point3d.create(origin.x, origin.y, z);
        this.next = Point3dVector3d_1.Point3d.create(next.x, next.y, z);
        this.normal = normal;
    }
}
/**
 * A clipping volume defined by a shape (an array of 3d points using only x and y dimensions).
 * May be given either a ClipPlaneSet to store directly, or an array of polygon points as well as other parameters
 * for parsing clipplanes from the shape later.
 * @public
 */
class ClipShape extends ClipPrimitive {
    constructor(polygon = [], zLow, zHigh, transform, isMask = false, invisible = false) {
        super(undefined, invisible); // ClipPlaneSets will be set up later after storing points
        this._isMask = false;
        this._polygon = polygon;
        this.initSecondaryProps(isMask, zLow, zHigh, transform);
    }
    /** Returns true if this ClipShape is marked as invisible. */
    get invisible() { return this._invisible; }
    /** Return this transformFromClip, which may be undefined. */
    get transformFromClip() { return this._transformFromClip; }
    /** Return this transformToClip, which may be undefined. */
    get transformToClip() { return this._transformToClip; }
    /** Returns true if this ClipShape's transforms are currently set. */
    get transformValid() { return this.transformFromClip !== undefined; }
    /** Returns true if this ClipShape's lower z boundary is set. */
    get zLowValid() { return this._zLow !== undefined; }
    /** Returns true if this ClipShape's upper z boundary is set. */
    get zHighValid() { return this._zHigh !== undefined; }
    /** Return true if this ClipShape has a local to world transform */
    get transformIsValid() { return this._transformFromClip !== undefined; }
    /** Return this zLow, which may be undefined. */
    get zLow() { return this._zLow; }
    /** Return this zHigh, which may be undefined. */
    get zHigh() { return this._zHigh; }
    /** Returns a reference to this ClipShape's polygon array. */
    get polygon() { return this._polygon; }
    /** Returns true if this ClipShape is a masking set. */
    get isMask() { return this._isMask; }
    /** Sets the polygon points array of this ClipShape to the array given (by reference). */
    setPolygon(polygon) {
        // Add closure point
        if (!polygon[0].isAlmostEqual(polygon[polygon.length - 1]))
            polygon.push(polygon[0].clone());
        this._polygon = polygon;
    }
    /**
     * * If the ClipShape's associated `UnionOfConvexClipPlaneSets` is defined, do nothing.
     * * If the ClipShape's associated `UnionOfConvexClipPlaneSets` is undefined, generate it from the `ClipShape` and transform.
     */
    ensurePlaneSets() {
        if (this._clipPlanes !== undefined)
            return;
        this._clipPlanes = UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets.createEmpty();
        this.parseClipPlanes(this._clipPlanes);
        if (this._transformFromClip)
            this._clipPlanes.transformInPlace(this._transformFromClip);
    }
    /**
     * Initialize the members of the ClipShape class that may at times be undefined.
     * zLow and zHigh default to Number.MAX_VALUE, and the transform defaults to an identity transform
     */
    initSecondaryProps(isMask, zLow, zHigh, transform) {
        this._isMask = isMask;
        this._zLow = zLow;
        this._zHigh = zHigh;
        if (transform !== undefined) {
            this._transformFromClip = transform;
            this._transformToClip = transform.inverse(); // could be undefined
        }
        else {
            this._transformFromClip = Transform_1.Transform.createIdentity();
            this._transformToClip = Transform_1.Transform.createIdentity();
        }
    }
    /** emit json object form */
    toJSON() {
        const val = {};
        val.shape = {};
        val.shape.points = [];
        for (const pt of this._polygon)
            val.shape.points.push(pt.toJSON());
        if (this.invisible)
            val.shape.invisible = true;
        if (this._transformFromClip && !this._transformFromClip.isIdentity)
            val.shape.trans = this._transformFromClip.toJSON();
        if (this.isMask)
            val.shape.mask = true;
        if (typeof (this.zLow) !== "undefined" && this.zLow !== -Number.MAX_VALUE)
            val.shape.zlow = this.zLow;
        if (typeof (this.zHigh) !== "undefined" && this.zHigh !== Number.MAX_VALUE)
            val.shape.zhigh = this.zHigh;
        return val;
    }
    /** parse `json` to a clip shape. */
    static fromClipShapeJSON(json, result) {
        if (!json.shape)
            return undefined;
        const points = [];
        if (json.shape.points)
            for (const pt of json.shape.points)
                points.push(Point3dVector3d_1.Point3d.fromJSON(pt));
        let trans;
        if (json.shape.trans)
            trans = Transform_1.Transform.fromJSON(json.shape.trans);
        let zLow;
        if (undefined !== json.shape.zlow)
            zLow = json.shape.zlow;
        let zHigh;
        if (undefined !== json.shape.zhigh)
            zHigh = json.shape.zhigh;
        let isMask = false;
        if (json.shape.mask)
            isMask = json.shape.mask;
        let invisible = false;
        if (json.shape.invisible)
            invisible = true;
        return ClipShape.createShape(points, zLow, zHigh, trans, isMask, invisible, result);
    }
    /** Returns a new ClipShape that is a deep copy of the ClipShape given */
    static createFrom(other, result) {
        const retVal = ClipShape.createEmpty(false, false, undefined, result);
        retVal._invisible = other._invisible;
        for (const point of other._polygon) {
            retVal._polygon.push(point.clone());
        }
        retVal._isMask = other._isMask;
        retVal._zLow = other._zLow;
        retVal._zHigh = other._zHigh;
        retVal._transformToClip = other._transformToClip ? other._transformToClip.clone() : undefined;
        retVal._transformFromClip = other._transformFromClip ? other._transformFromClip.clone() : undefined;
        return retVal;
    }
    /** Create a new ClipShape from an array of points that make up a 2d shape (stores a deep copy of these points). */
    static createShape(polygon = [], zLow, zHigh, transform, isMask = false, invisible = false, result) {
        if (polygon.length < 3)
            return undefined;
        const pPoints = polygon.slice(0);
        // Add closure point
        if (!pPoints[0].isExactEqual(pPoints[pPoints.length - 1]))
            pPoints.push(pPoints[0]);
        if (result) {
            result._clipPlanes = undefined; // Start as undefined
            result._invisible = invisible;
            result._polygon = pPoints;
            result.initSecondaryProps(isMask, zLow, zHigh, transform);
            return result;
        }
        else {
            return new ClipShape(pPoints, zLow, zHigh, transform, isMask, invisible);
        }
    }
    /**
     * Create a ClipShape that exists as a 3 dimensional box of the range given. Optionally choose to
     * also store this shape's zLow and zHigh members from the range through the use of a RangePlaneBitMask.
     */
    static createBlock(extremities, clipMask, isMask = false, invisible = false, transform, result) {
        const low = extremities.low;
        const high = extremities.high;
        const blockPoints = [];
        for (let i = 0; i < 5; i++)
            blockPoints.push(Point3dVector3d_1.Point3d.create());
        blockPoints[0].x = blockPoints[3].x = blockPoints[4].x = low.x;
        blockPoints[1].x = blockPoints[2].x = high.x;
        blockPoints[0].y = blockPoints[1].y = blockPoints[4].y = low.y;
        blockPoints[2].y = blockPoints[3].y = high.y;
        return ClipShape.createShape(blockPoints, (ClipMaskXYZRangePlanes.None !== (clipMask & ClipMaskXYZRangePlanes.ZLow)) ? low.z : undefined, ClipMaskXYZRangePlanes.None !== (clipMask & ClipMaskXYZRangePlanes.ZHigh) ? high.z : undefined, transform, isMask, invisible, result);
    }
    /** Creates a new ClipShape with undefined members and a polygon points array of zero length. */
    static createEmpty(isMask = false, invisible = false, transform, result) {
        if (result) {
            result._clipPlanes = undefined;
            result._invisible = invisible;
            result._polygon.length = 0;
            result.initSecondaryProps(isMask, undefined, undefined, transform);
            return result;
        }
        return new ClipShape([], undefined, undefined, transform, isMask, invisible);
    }
    /** Checks to ensure that the member polygon has an area, and that the polygon is closed. */
    get isValidPolygon() {
        if (this._polygon.length < 3)
            return false;
        if (!this._polygon[0].isExactEqual(this._polygon[this._polygon.length - 1]))
            return false;
        return true;
    }
    /** Returns a deep copy of this instance of ClipShape, storing in an optional result */
    clone(result) {
        return ClipShape.createFrom(this, result);
    }
    /** Given the current polygon data, parses clip planes that together form an object, storing the result in the set given, either clipplanes or maskplanes. */
    parseClipPlanes(set) {
        const points = this._polygon;
        if (points.length === 3 && !this._isMask && points[0].isExactEqual(points[points.length - 1])) {
            this.parseLinearPlanes(set, this._polygon[0], this._polygon[1]);
            return true;
        }
        const direction = PolygonOps_1.PolygonOps.testXYPolygonTurningDirections(points);
        if (0 !== direction) {
            this.parseConvexPolygonPlanes(set, this._polygon, direction);
            return true;
        }
        else {
            this.parseConcavePolygonPlanes(set, this._polygon);
            return false;
        }
    }
    /** Given a start and end point, populate the given UnionOfConvexClipPlaneSets with ConvexClipPlaneSets defining the bounded region of linear planes. Returns true if successful. */
    parseLinearPlanes(set, start, end, cameraFocalLength) {
        // Handles the degenerate case of 2 distinct points (used by select by line).
        const normal = start.vectorTo(end);
        if (normal.magnitude() === 0.0)
            return false;
        normal.normalize(normal);
        const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
        if (cameraFocalLength === undefined) {
            const perpendicular = Point2dVector2d_1.Vector2d.create(-normal.y, normal.x);
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(normal.x, normal.y), Point3dVector3d_1.Point3d.createFrom(start), this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(-normal.x, -normal.y), Point3dVector3d_1.Point3d.createFrom(end), this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(perpendicular.x, perpendicular.y), Point3dVector3d_1.Point3d.createFrom(start), this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(-perpendicular.x, -perpendicular.y), Point3dVector3d_1.Point3d.createFrom(start), this._invisible));
        }
        else {
            const start3d = Point3dVector3d_1.Point3d.create(start.x, start.y, -cameraFocalLength);
            const end3d = Point3dVector3d_1.Point3d.create(end.x, end.y, -cameraFocalLength);
            const vecEnd3d = Point3dVector3d_1.Vector3d.createFrom(end3d);
            const perpendicular = vecEnd3d.crossProduct(Point3dVector3d_1.Vector3d.createFrom(start3d)).normalize();
            let endNormal = Point3dVector3d_1.Vector3d.createFrom(start3d).crossProduct(perpendicular).normalize();
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(perpendicular, 0.0, this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(endNormal, 0.0, this._invisible));
            perpendicular.negate();
            endNormal = vecEnd3d.crossProduct(perpendicular).normalize();
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(perpendicular, 0.0, this._invisible));
            convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(endNormal, 0.0, this._invisible));
        }
        convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);
        set.addConvexSet(convexSet);
        return true;
    }
    /** Given a convex polygon defined as an array of points, populate the given UnionOfConvexClipPlaneSets with ConvexClipPlaneSets defining the bounded region. Returns true if successful. */
    parseConvexPolygonPlanes(set, polygon, direction, cameraFocalLength) {
        const samePointTolerance = 1.0e-8; // This could possibly be replaced with more widely used constants
        const edges = [];
        const reverse = (direction < 0) !== this._isMask;
        for (let i = 0; i < polygon.length - 1; i++) {
            const z = (cameraFocalLength === undefined) ? 0.0 : -cameraFocalLength;
            const dir = Point2dVector2d_1.Vector2d.createFrom((polygon[i + 1].minus(polygon[i])));
            const magnitude = dir.magnitude();
            dir.normalize(dir);
            if (magnitude > samePointTolerance) {
                const normal = Point2dVector2d_1.Vector2d.create(reverse ? dir.y : -dir.y, reverse ? -dir.x : dir.x);
                edges.push(new PolyEdge(polygon[i], polygon[i + 1], normal, z));
            }
        }
        if (edges.length < 3) {
            return false;
        }
        if (this._isMask) {
            const last = edges.length - 1;
            for (let i = 0; i <= last; i++) {
                const edge = edges[i];
                const prevEdge = edges[i ? (i - 1) : last];
                const nextEdge = edges[(i === last) ? 0 : (i + 1)];
                const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
                const prevNormal = edge.normal.minus(prevEdge.normal);
                const nextNormal = edge.normal.minus(nextEdge.normal);
                prevNormal.normalize(prevNormal);
                nextNormal.normalize(nextNormal);
                // Create three-sided fans from each edge.   Note we could define the correct region
                // with only two planes for edge, but cannot then designate the "interior" status of the edges accurately.
                convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(prevNormal.x, prevNormal.y), edge.origin, this._invisible, true));
                convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(edge.normal.x, edge.normal.y), edge.origin, this._invisible, false));
                convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(nextNormal.x, nextNormal.y), nextEdge.origin, this._invisible, true));
                convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);
                set.addConvexSet(convexSet);
            }
            set.addOutsideZClipSets(this._invisible, this._zLow, this._zHigh);
        }
        else {
            const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
            if (cameraFocalLength === undefined) {
                for (const edge of edges)
                    convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndPoint(Point3dVector3d_1.Vector3d.create(edge.normal.x, edge.normal.y), edge.origin));
            }
            else {
                if (reverse)
                    for (const edge of edges)
                        convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.createFrom(edge.origin).crossProduct(Point3dVector3d_1.Vector3d.createFrom(edge.next)).normalize(), 0.0));
                else
                    for (const edge of edges)
                        convexSet.planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.createFrom(edge.next).crossProduct(Point3dVector3d_1.Vector3d.createFrom(edge.origin)).normalize(), 0.0));
            }
            convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);
            set.addConvexSet(convexSet);
        }
        return true;
    }
    /** Given a concave polygon defined as an array of points, populate the given UnionOfConvexClipPlaneSets with multiple ConvexClipPlaneSets defining the bounded region. Returns true if successful. */
    parseConcavePolygonPlanes(set, polygon, cameraFocalLength) {
        const triangulatedPolygon = Triangulation_1.Triangulator.createTriangulatedGraphFromSingleLoop(polygon);
        Triangulation_1.Triangulator.flipTriangles(triangulatedPolygon);
        triangulatedPolygon.announceFaceLoops((_graph, edge) => {
            if (!edge.isMaskSet(Graph_1.HalfEdgeMask.EXTERIOR)) {
                const convexFacetPoints = edge.collectAroundFace((node) => {
                    if (!node.isMaskSet(Graph_1.HalfEdgeMask.EXTERIOR))
                        return Point3dVector3d_1.Point3d.create(node.x, node.y, 0);
                });
                // parseConvexPolygonPlanes expects a closed loop (pushing the reference doesn't matter)
                convexFacetPoints.push(convexFacetPoints[0]);
                const direction = PolygonOps_1.PolygonOps.testXYPolygonTurningDirections(convexFacetPoints); // ###TODO: Can we expect a direction coming out of graph facet?
                this.parseConvexPolygonPlanes(set, convexFacetPoints, direction, cameraFocalLength);
            }
            return true;
        });
        return true;
    }
    /**
     * Multiply all ClipPlanes DPoint4d by matrix.
     * @param matrix matrix to apply.
     * @param invert if true, use in verse of the matrix.
     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)
     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA
     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.
     * * Both params default to true to get the full effect of transforming space.
     * @param matrix matrix to apply
     */
    multiplyPlanesByMatrix4d(matrix, invert = true, transpose = true) {
        this.ensurePlaneSets();
        return super.multiplyPlanesByMatrix4d(matrix, invert, transpose);
    }
    /** Apply `transform` to the local to world (`transformFromClip`) transform.
     * * The world to local transform (`transformToClip` is recomputed from the (changed) `transformToClip`
     * * the transform is passed to the base class to be applied to clip plane form of the clipper.
     */
    transformInPlace(transform) {
        if (transform.isIdentity)
            return true;
        super.transformInPlace(transform);
        if (this._transformFromClip)
            transform.multiplyTransformTransform(this._transformFromClip, this._transformFromClip);
        else
            this._transformFromClip = transform.clone();
        this._transformToClip = this._transformFromClip.inverse(); // could be undefined
        return true;
    }
    /** Return true if
     * * at least one point is defined
     * * The local to world transform (transformFromClip) either
     *   * is undefined
     *   * has no xy parts in its column Z (local frame Z is parallel to global Z)
     */
    get isXYPolygon() {
        if (this._polygon.length === 0) // Note: This is a lenient check, as points array could also contain less than 3 points (not a polygon)
            return false;
        if (this._transformFromClip === undefined)
            return true;
        const zVector = this._transformFromClip.matrix.columnZ();
        return zVector.magnitudeXY() < 1.0e-8;
    }
    /** Transform the input point using this instance's transformToClip member */
    performTransformToClip(point) {
        if (this._transformToClip !== undefined)
            this._transformToClip.multiplyPoint3d(point);
    }
    /** Transform the input point using this instance's transformFromClip member */
    performTransformFromClip(point) {
        if (this._transformFromClip !== undefined)
            this._transformFromClip.multiplyPoint3d(point);
    }
}
exports.ClipShape = ClipShape;


/***/ }),

/***/ "./lib/clipping/ClipUtils.js":
/*!***********************************!*\
  !*** ./lib/clipping/ClipUtils.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const UnionOfConvexClipPlaneSets_1 = __webpack_require__(/*! ./UnionOfConvexClipPlaneSets */ "./lib/clipping/UnionOfConvexClipPlaneSets.js");
const ClipPrimitive_1 = __webpack_require__(/*! ./ClipPrimitive */ "./lib/clipping/ClipPrimitive.js");
const ConvexClipPlaneSet_1 = __webpack_require__(/*! ./ConvexClipPlaneSet */ "./lib/clipping/ConvexClipPlaneSet.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const ClipVector_1 = __webpack_require__(/*! ./ClipVector */ "./lib/clipping/ClipVector.js");
/** @module CartesianGeometry */
/** Enumerated type for describing where geometry lies with respect to clipping planes.
 * @public
 */
var ClipPlaneContainment;
(function (ClipPlaneContainment) {
    /** All points inside */
    ClipPlaneContainment[ClipPlaneContainment["StronglyInside"] = 1] = "StronglyInside";
    /** Inside/outside state unknown. */
    ClipPlaneContainment[ClipPlaneContainment["Ambiguous"] = 2] = "Ambiguous";
    /** All points outside */
    ClipPlaneContainment[ClipPlaneContainment["StronglyOutside"] = 3] = "StronglyOutside";
})(ClipPlaneContainment = exports.ClipPlaneContainment || (exports.ClipPlaneContainment = {}));
/** Enumerated type for describing what must yet be done to clip a piece of geometry.
 * @public
 */
var ClipStatus;
(function (ClipStatus) {
    /** some geometry may cross the clip boundaries */
    ClipStatus[ClipStatus["ClipRequired"] = 0] = "ClipRequired";
    /** geometry is clearly outside */
    ClipStatus[ClipStatus["TrivialReject"] = 1] = "TrivialReject";
    /** geometry is clearly inside */
    ClipStatus[ClipStatus["TrivialAccept"] = 2] = "TrivialAccept";
})(ClipStatus = exports.ClipStatus || (exports.ClipStatus = {}));
/** Static class whose various methods are functions for clipping geometry
 * @public
 */
class ClipUtilities {
    /**
     * * Augment the unsortedFractionsArray with 0 and 1
     * * sort
     * * test the midpoint of each interval with `clipper.isPointOnOrInside`
     * * pass accepted intervals to `announce(f0,f1,curve)`
     */
    static selectIntervals01(curve, unsortedFractions, clipper, announce) {
        unsortedFractions.push(0);
        unsortedFractions.push(1);
        unsortedFractions.sort();
        let f0 = unsortedFractions.atUncheckedIndex(0);
        let f1;
        let fMid;
        const testPoint = ClipUtilities._selectIntervals01TestPoint;
        const n = unsortedFractions.length;
        for (let i = 1; i < n; i++, f0 = f1) {
            f1 = unsortedFractions.atUncheckedIndex(i);
            fMid = 0.5 * (f0 + f1);
            if (f1 > f0 && (fMid >= 0.0 && fMid <= 1.0)) {
                curve.fractionToPoint(fMid, testPoint);
                if (clipper.isPointOnOrInside(testPoint)) {
                    if (announce)
                        announce(f0, f1, curve);
                    else
                        return true;
                }
            }
        }
        return false;
    }
    /**
     * Announce triples of (low, high, cp) for each entry in intervals
     * @param intervals source array
     * @param cp CurvePrimitive for announcement
     * @param announce function to receive data
     */
    static announceNNC(intervals, cp, announce) {
        if (announce) {
            for (const ab of intervals) {
                announce(ab.low, ab.high, cp);
            }
        }
        return intervals.length > 0;
    }
    /** Find portions of the curve that are within the clipper.
     * Collect them into an array of curve primitives.
     */
    static collectClippedCurves(curve, clipper) {
        const result = [];
        curve.announceClipIntervals(clipper, (fraction0, fraction1, curveA) => {
            if (fraction1 !== fraction0) {
                const partialCurve = curveA.clonePartialCurve(fraction0, fraction1);
                if (partialCurve)
                    result.push(partialCurve);
            }
        });
        return result;
    }
    /**
     * Clip a polygon down to regions defined by each shape of a ClipShape.
     * @return An multidimensional array of points, where each array is the boundary of part of the remaining polygon.
     */
    static clipPolygonToClipShape(polygon, clipShape) {
        const outputA = this.clipPolygonToClipShapeReturnGrowableXYZArrays(polygon, clipShape);
        const output = [];
        for (const g of outputA)
            output.push(g.getPoint3dArray());
        return output;
    }
    /**
     * Clip a polygon down to regions defined by each shape of a ClipShape.
     * @return An multidimensional array of points, where each array is the boundary of part of the remaining polygon.
     */
    static clipPolygonToClipShapeReturnGrowableXYZArrays(polygon, clipShape) {
        const output = [];
        const clipper = clipShape.fetchClipPlanesRef();
        // NEEDS WORK -- what if it is a mask !!!!
        if (clipper) {
            clipper.polygonClip(polygon, output);
        }
        return output;
    }
    /** Given an array of points, test for trivial containment conditions.
     * * ClipStatus.TrivialAccept if all points are in any one of the convexSet's.
     * * ClipStatus.ClipRequired if (in any single convexSet) there were points on both sides of any single plane.
     * * ClipStatus.TrivialReject if neither of those occurred.
     */
    static pointSetSingleClipStatus(points, planeSet, tolerance) {
        if (planeSet.convexSets.length === 0)
            return ClipStatus.TrivialAccept;
        for (const convexSet of planeSet.convexSets) {
            let allOutsideSinglePlane = false, anyOutside = false;
            for (const plane of convexSet.planes) {
                let numInside = 0, numOutside = 0;
                const planeDistance = plane.distance - tolerance;
                const currPt = Point3dVector3d_1.Point3d.create();
                const currVec = Point3dVector3d_1.Vector3d.create();
                for (let i = 0; i < points.length; i++) {
                    points.getPoint3dAtUncheckedPointIndex(i, currPt);
                    currVec.setFrom(currPt);
                    currVec.dotProduct(plane.inwardNormalRef) > planeDistance ? numInside++ : numOutside++;
                }
                anyOutside = (numOutside !== 0) ? true : anyOutside;
                if (numInside === 0) {
                    allOutsideSinglePlane = true;
                    break;
                }
            }
            if (!anyOutside) // totally inside this set - no clip required
                return ClipStatus.TrivialAccept;
            if (!allOutsideSinglePlane)
                return ClipStatus.ClipRequired;
        }
        return ClipStatus.TrivialReject;
    }
    /**
     * Emit point loops for intersection of a convex set with a range.
     * * return zero length array for (a) null range or (b) no intersections
     * @param range range to intersect
     * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.
     * @param includeRangeFaces if false, do not compute facets originating as range faces
     * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.
     */
    static announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet, range, loopFunction, includeConvexSetFaces = true, includeRangeFaces = true, ignoreInvisiblePlanes = false) {
        const work = new GrowableXYZArray_1.GrowableXYZArray();
        if (includeConvexSetFaces) {
            // Clip convexSet planes to the range and to the rest of the convexSet . .
            for (const plane of convexSet.planes) {
                if (ignoreInvisiblePlanes && plane.invisible)
                    continue;
                const pointsClippedToRange = plane.intersectRange(range, true);
                const finalPoints = new GrowableXYZArray_1.GrowableXYZArray();
                if (pointsClippedToRange) {
                    convexSet.polygonClip(pointsClippedToRange, finalPoints, work, plane);
                    if (finalPoints.length > 0)
                        loopFunction(finalPoints);
                }
            }
        }
        if (includeRangeFaces) {
            // clip range faces to the convex set . . .
            const corners = range.corners();
            for (let i = 0; i < 6; i++) {
                const indices = Range_1.Range3d.faceCornerIndices(i);
                const finalPoints = new GrowableXYZArray_1.GrowableXYZArray();
                const lineString = LineString3d_1.LineString3d.createIndexedPoints(corners, indices);
                convexSet.polygonClip(lineString.packedPoints, finalPoints, work);
                if (finalPoints.length > 0)
                    loopFunction(finalPoints);
            }
        }
    }
    /**
     * Return a (possibly empty) array of geometry (Loops !!) which are facets of the intersection of the convex set intersecting a range.
     * * return zero length array for (a) null range or (b) no intersections
     * @param range range to intersect
     * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.
     * @param includeRangeFaces if false, do not compute facets originating as range faces
     * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.
     */
    static loopsOfConvexClipPlaneIntersectionWithRange(convexSet, range, includeConvexSetFaces = true, includeRangeFaces = true, ignoreInvisiblePlanes = false) {
        const result = [];
        this.announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet, range, (points) => {
            if (points.length > 0)
                result.push(Loop_1.Loop.createPolygon(points));
        }, includeConvexSetFaces, includeRangeFaces, ignoreInvisiblePlanes);
        return result;
    }
    /**
     * Return the (possibly null) range of the intersection of the convex set with a range.
     * * The convex set is permitted to be unbounded (e.g. a single plane).  The range parameter provides bounds.
     * @param convexSet convex set for intersection.
     * @param range range to intersect
     */
    static rangeOfConvexClipPlaneSetIntersectionWithRange(convexSet, range) {
        const result = Range_1.Range3d.createNull();
        this.announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet, range, (points) => {
            if (points.length > 0)
                result.extendArray(points);
        }, true, true, false);
        return result;
    }
    /**
     * Return the range of various types of clippers
     * * `ConvexClipPlaneSet` -- dispatch to `rangeOfConvexClipPlaneSetIntersectionWithRange`
     * * `UnionOfConvexClipPlaneSet` -- union of ranges of member `ConvexClipPlaneSet`
     * * `ClipPrimitive` -- access its `UnionOfConvexClipPlaneSet`.
     * * `ClipVector` -- intersection of the ranges of its `ClipPrimitive`.
     * * `undefined` -- entire input range.
     * * If `observeInvisibleFlag` is false, the "invisible" properties are ignored, and this effectively returns the range of the edge work of the members
     * * If `observeInvisibleFlag` is false, the "invisible" properties are observed, and "invisible" parts do not restrict the range.
     * @param clipper
     * @param range non-null range.
     * @param observeInvisibleFlag indicates how "invisible" bit is applied for ClipPrimitive.
     */
    static rangeOfClipperIntersectionWithRange(clipper, range, observeInvisibleFlag = true) {
        if (clipper === undefined)
            return range.clone();
        if (clipper instanceof ConvexClipPlaneSet_1.ConvexClipPlaneSet)
            return this.rangeOfConvexClipPlaneSetIntersectionWithRange(clipper, range);
        if (clipper instanceof UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets) {
            const rangeUnion = Range_1.Range3d.createNull();
            for (const c of clipper.convexSets) {
                const rangeC = this.rangeOfConvexClipPlaneSetIntersectionWithRange(c, range);
                rangeUnion.extendRange(rangeC);
            }
            return rangeUnion;
        }
        if (clipper instanceof ClipPrimitive_1.ClipPrimitive) {
            if (observeInvisibleFlag && clipper.invisible)
                return range.clone();
            return this.rangeOfClipperIntersectionWithRange(clipper.fetchClipPlanesRef(), range);
        }
        if (clipper instanceof ClipVector_1.ClipVector) {
            const rangeIntersection = range.clone();
            for (const c of clipper.clips) {
                if (observeInvisibleFlag && c.invisible) {
                    // trivial range tests do not expose the effects.   Assume the hole allows everything.
                }
                else {
                    const rangeC = this.rangeOfClipperIntersectionWithRange(c, range, observeInvisibleFlag);
                    rangeIntersection.intersect(rangeC, rangeIntersection);
                }
            }
            return rangeIntersection;
        }
        return range.clone();
    }
    /**
     * Test if various types of clippers have any intersection with a range.
     * * This follows the same logic as `rangeOfClipperIntersectionWithRange` but attempts to exit at earliest point of confirmed intersection
     * * `ConvexClipPlaneSet` -- dispatch to `doesConvexClipPlaneSetIntersectRange`
     * * `UnionOfConvexClipPlaneSet` -- union of ranges of member `ConvexClipPlaneSet`
     * * `ClipPrimitive` -- access its `UnionOfConvexClipPlaneSet`.
     * * `ClipVector` -- intersection of the ranges of its `ClipPrimitive`.
     * * `undefined` -- entire input range.
     * * If `observeInvisibleFlag` is false, the "invisible" properties are ignored, and holes do not affect the result.
     * * If `observeInvisibleFlag` is true, the "invisible" properties are observed, and may affect the result.
     * @param clipper
     * @param range non-null range.
     * @param observeInvisibleFlag indicates how "invisible" bit is applied for ClipPrimitive.
     */
    static doesClipperIntersectRange(clipper, range, observeInvisibleFlag = true) {
        if (clipper === undefined)
            return true;
        if (clipper instanceof ConvexClipPlaneSet_1.ConvexClipPlaneSet)
            return this.doesConvexClipPlaneSetIntersectRange(clipper, range);
        if (clipper instanceof UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets) {
            for (const c of clipper.convexSets) {
                if (this.doesConvexClipPlaneSetIntersectRange(c, range))
                    return true;
            }
            return false;
        }
        if (clipper instanceof ClipPrimitive_1.ClipPrimitive) {
            if (observeInvisibleFlag && clipper.invisible) // um is there an easy way to detect range-completely-inside?
                return true;
            return this.doesClipperIntersectRange(clipper.fetchClipPlanesRef(), range);
        }
        if (clipper instanceof ClipVector_1.ClipVector) {
            const rangeIntersection = range.clone();
            for (const c of clipper.clips) {
                if (observeInvisibleFlag && c.invisible) {
                    // trivial range tests do not expose the effects.   Assume the hole allows everything.
                }
                else {
                    const rangeC = this.rangeOfClipperIntersectionWithRange(c, range, observeInvisibleFlag);
                    rangeIntersection.intersect(rangeC, rangeIntersection);
                }
            }
            return !rangeIntersection.isNull;
        }
        /** If the case statement above is complete for the variant inputs, this is unreachable .. */
        return false;
    }
    /**
     * Emit point loops for intersection of a convex set with a range.
     * * return zero length array for (a) null range or (b) no intersections
     * @param range range to intersect
     * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.
     * @param includeRangeFaces if false, do not compute facets originating as range faces
     * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.
     */
    static doesConvexClipPlaneSetIntersectRange(convexSet, range, includeConvexSetFaces = true, includeRangeFaces = true, ignoreInvisiblePlanes = false) {
        const work = new GrowableXYZArray_1.GrowableXYZArray();
        if (includeConvexSetFaces) {
            // Clip convexSet planes to the range and to the rest of the convexSet . .
            for (const plane of convexSet.planes) {
                if (ignoreInvisiblePlanes && plane.invisible)
                    continue;
                const pointsClippedToRange = plane.intersectRange(range, true);
                if (pointsClippedToRange) {
                    const finalPoints = new GrowableXYZArray_1.GrowableXYZArray();
                    convexSet.polygonClip(pointsClippedToRange, finalPoints, work, plane);
                    if (finalPoints.length > 0)
                        return true;
                }
            }
        }
        if (includeRangeFaces) {
            // clip range faces to the convex set . . .
            const corners = range.corners();
            for (let i = 0; i < 6; i++) {
                const indices = Range_1.Range3d.faceCornerIndices(i);
                const finalPoints = new GrowableXYZArray_1.GrowableXYZArray();
                const lineString = LineString3d_1.LineString3d.createIndexedPoints(corners, indices);
                convexSet.polygonClip(lineString.packedPoints, finalPoints, work);
                if (finalPoints.length > 0)
                    return true;
            }
        }
        return false;
    }
}
exports.ClipUtilities = ClipUtilities;
ClipUtilities._selectIntervals01TestPoint = Point3dVector3d_1.Point3d.create();


/***/ }),

/***/ "./lib/clipping/ClipVector.js":
/*!************************************!*\
  !*** ./lib/clipping/ClipVector.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const ClipPrimitive_1 = __webpack_require__(/*! ./ClipPrimitive */ "./lib/clipping/ClipPrimitive.js");
const ClipUtils_1 = __webpack_require__(/*! ./ClipUtils */ "./lib/clipping/ClipUtils.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const LineSegment3d_1 = __webpack_require__(/*! ../curve/LineSegment3d */ "./lib/curve/LineSegment3d.js");
/** Class holding an array structure of shapes defined by `ClipPrimitive`
 * * The `ClipVector` defines an intersection of the member `ClipPrimitive` regions.
 * * In the most common usage, one of the `ClipPrimitive` will be an outer region, and all others are holes with marker flag indicating that they outside of each hole is live.
 * @public
 */
class ClipVector {
    constructor(clips) {
        /** range acting as first filter.
         * * This is understood as overall range limit, not as precise planes.
         * * applying any rotation to the whole ClipVector generally expands this range, rather than exactly transforming its planes.
         */
        this.boundingRange = Range_1.Range3d.createNull();
        this._clips = clips ? clips : [];
    }
    /** Returns a reference to the array of ClipShapes. */
    get clips() { return this._clips; }
    /** Returns true if this ClipVector contains a ClipPrimitive. */
    get isValid() { return this._clips.length > 0; }
    /** Create a ClipVector with an empty set of ClipShapes. */
    static createEmpty(result) {
        if (result) {
            result._clips.length = 0;
            return result;
        }
        return new ClipVector();
    }
    /** Create a ClipVector from an array of ClipPrimitives (or derived classes) (capture the pointers) */
    static createCapture(clips, result) {
        if (result) {
            result._clips = clips;
            return result;
        }
        return new ClipVector(clips);
    }
    /** Create a ClipVector from (clones of) an array of ClipPrimitives */
    static create(clips, result) {
        const clipClones = [];
        for (const clip of clips)
            clipClones.push(clip.clone());
        return ClipVector.createCapture(clipClones, result);
    }
    /** Create a deep copy of another ClipVector */
    clone(result) {
        const retVal = result ? result : new ClipVector();
        retVal._clips.length = 0;
        for (const clip of this._clips) {
            retVal._clips.push(clip.clone());
        }
        retVal.boundingRange.setFrom(this.boundingRange);
        return retVal;
    }
    /** Parse this ClipVector into a JSON object. */
    toJSON() {
        if (!this.isValid)
            return [];
        const val = [];
        for (const clipShape of this.clips)
            val.push(clipShape.toJSON());
        return val;
    }
    /** Parse a JSON object into a new ClipVector. */
    static fromJSON(json, result) {
        result = result ? result : new ClipVector();
        result.clear();
        try {
            for (const clip of json) {
                const clipPrim = ClipPrimitive_1.ClipPrimitive.fromJSON(clip);
                if (clipPrim)
                    result._clips.push(clipPrim);
            }
        }
        catch (e) {
            result.clear();
        }
        return result;
    }
    /** Empties out the array of ClipShapes. */
    clear() {
        this._clips.length = 0;
    }
    /** Append a deep copy of the given ClipPrimitive to this ClipVector. */
    appendClone(clip) {
        this._clips.push(clip.clone());
    }
    /** Append a reference of the given ClipPrimitive to this ClipVector. */
    appendReference(clip) {
        this._clips.push(clip);
    }
    /** Create and append a new ClipPrimitive to the array given a shape as an array of points. Returns true if successful. */
    appendShape(shape, zLow, zHigh, transform, isMask = false, invisible = false) {
        const clip = ClipPrimitive_1.ClipShape.createShape(shape, zLow, zHigh, transform, isMask, invisible);
        if (!clip)
            return false;
        this._clips.push(clip);
        return true;
    }
    /** Returns true if the given point lies inside all of this ClipVector's ClipShapes (by rule of intersection). */
    pointInside(point, onTolerance = Geometry_1.Geometry.smallMetricDistanceSquared) {
        if (!this.boundingRange.isNull && !this.boundingRange.containsPoint(point))
            return false;
        for (const clip of this._clips) {
            if (!clip.pointInside(point, onTolerance))
                return false;
        }
        return true;
    }
    /** Transforms this ClipVector to a new coordinate-system.
     * Note that if the transform has rotate and scale the boundingRange member expands.
     * Returns true if successful.
     */
    transformInPlace(transform) {
        for (const clip of this._clips)
            if (clip.transformInPlace(transform) === false)
                return false;
        if (!this.boundingRange.isNull)
            transform.multiplyRange(this.boundingRange, this.boundingRange);
        return true;
    }
    /**
     * A simple way of packaging this ClipVector's ClipShape points into a multidimensional array, while also
     * taking into account each ClipPrimitive's individual transforms.
     *
     * ClipPrimitives OTHER THAN ClipShape are ignored.
     *
     * Information out:
     *  - All of the loop points are stored in the multidimensional Point3d array given (will return unchanged upon failure)
     *  - If given a transform, will be set from the transformFromClip of the first ClipPrimitive
     *  - The ClipMask of the final ClipPrimitive is stored in the returned array at index 0
     *  - The last valid zLow found is stored in the returned array at index 1
     *  - The last valid zHigh found is stored in the returned array at index 2
     */
    extractBoundaryLoops(loopPoints, transform) {
        let clipM = ClipPrimitive_1.ClipMaskXYZRangePlanes.None;
        let zBack = -Number.MAX_VALUE;
        let zFront = Number.MAX_VALUE;
        const retVal = [];
        let nLoops = 0;
        if (this._clips.length === 0)
            return retVal;
        let firstClipShape;
        const deltaTrans = Transform_1.Transform.createIdentity();
        for (const clip of this._clips) {
            if (clip instanceof ClipPrimitive_1.ClipShape) {
                if (firstClipShape !== undefined && clip !== firstClipShape) { // Is not the first iteration
                    let fwdTrans = Transform_1.Transform.createIdentity();
                    let invTrans = Transform_1.Transform.createIdentity();
                    if (firstClipShape.transformValid && clip.transformValid) {
                        fwdTrans = clip.transformFromClip.clone();
                        invTrans = firstClipShape.transformToClip.clone();
                    }
                    deltaTrans.setFrom(invTrans.multiplyTransformTransform(fwdTrans));
                }
                if (!firstClipShape)
                    firstClipShape = clip;
                loopPoints[nLoops] = [];
                if (clip.polygon !== undefined) {
                    clipM = ClipPrimitive_1.ClipMaskXYZRangePlanes.XAndY;
                    if (clip.zHighValid) {
                        clipM = clipM | ClipPrimitive_1.ClipMaskXYZRangePlanes.ZHigh;
                        zFront = clip.zHigh;
                    }
                    if (clip.zLowValid) {
                        clipM = clipM | ClipPrimitive_1.ClipMaskXYZRangePlanes.ZLow;
                        zBack = clip.zLow;
                    }
                    for (const point of clip.polygon)
                        loopPoints[nLoops].push(point.clone());
                    deltaTrans.multiplyPoint3dArray(loopPoints[nLoops], loopPoints[nLoops]);
                    nLoops++;
                }
            }
        }
        retVal.push(clipM);
        retVal.push(zBack);
        retVal.push(zFront);
        if (transform && firstClipShape)
            transform.setFrom(firstClipShape.transformFromClip);
        return retVal;
    }
    /** Sets this ClipVector and all of its members to the visibility specified. */
    setInvisible(invisible) {
        for (const clip of this._clips)
            clip.setInvisible(invisible);
    }
    /** For every clip, parse the member point array into the member clip plane object (only for clipPlanes member, not the mask) */
    parseClipPlanes() {
        for (const clip of this._clips)
            clip.fetchClipPlanesRef();
    }
    /**
     * Multiply all ClipPlanes DPoint4d by matrix.
     * @param matrix matrix to apply.
     * @param invert if true, use in verse of the matrix.
     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)
     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA
     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.
     * * Both params default to true to get the full effect of transforming space.
     * @param matrix matrix to apply
     * @returns false if matrix inversion fails.
     */
    multiplyPlanesByMatrix4d(matrix, invert = true, transpose = true) {
        if (invert) { // form inverse once here, reuse for all planes
            const inverse = matrix.createInverse();
            if (!inverse)
                return false;
            return this.multiplyPlanesByMatrix4d(inverse, false, transpose);
        }
        // no inverse necessary -- lower level cannot fail.
        for (const clip of this._clips)
            clip.multiplyPlanesByMatrix4d(matrix, false, transpose);
        return true;
    }
    /**
     * Determines whether the given points fall inside or outside this set of ClipShapes. If any set is defined by masking planes,
     * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the _clipplanes member.
     */
    classifyPointContainment(points, ignoreMasks = false) {
        let currentContainment = ClipUtils_1.ClipPlaneContainment.Ambiguous;
        for (const primitive of this._clips) {
            const thisContainment = primitive.classifyPointContainment(points, ignoreMasks);
            if (ClipUtils_1.ClipPlaneContainment.Ambiguous === thisContainment)
                return ClipUtils_1.ClipPlaneContainment.Ambiguous;
            if (ClipUtils_1.ClipPlaneContainment.Ambiguous === currentContainment)
                currentContainment = thisContainment;
            else if (currentContainment !== thisContainment)
                return ClipUtils_1.ClipPlaneContainment.Ambiguous;
        }
        return currentContainment;
    }
    /**
     * Determines whether a 3D range lies inside or outside this set of ClipShapes. If any set is defined by masking planes,
     * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the _clipplanes member.
     */
    classifyRangeContainment(range, ignoreMasks) {
        const corners = range.corners();
        return this.classifyPointContainment(corners, ignoreMasks);
    }
    /**
     * For an array of points (making up a LineString), tests whether the segment between each point lies inside the ClipVector.
     * If true, returns true immediately.
     */
    isAnyLineStringPointInside(points) {
        for (const clip of this._clips) {
            const clipPlaneSet = clip.fetchClipPlanesRef();
            if (clipPlaneSet !== undefined) {
                for (let i = 0; i + 1 < points.length; i++) {
                    const segment = LineSegment3d_1.LineSegment3d.create(points[i], points[i + 1]);
                    if (clipPlaneSet.isAnyPointInOrOnFromSegment(segment))
                        return true;
                }
            }
        }
        return false;
    }
    /** Note: Line segments are used to represent 1 dimensional intervals here, rather than segments. */
    sumSizes(intervals, begin, end) {
        let s = 0.0;
        for (let i = begin; i < end; i++)
            s += (intervals[i].x1 - intervals[i].x0);
        return s;
    }
    /**
     * For an array of points that make up a LineString, develops a line segment between each point pair,
     * and returns true if all segments lie inside this ClipVector.
     */
    isLineStringCompletelyContained(points) {
        const clipIntervals = [];
        for (let i = 0; i + 1 < points.length; i++) {
            const segment = LineSegment3d_1.LineSegment3d.create(points[i], points[i + 1]);
            let fractionSum = 0.0;
            let index0 = 0;
            for (const clip of this._clips) {
                const clipPlaneSet = clip.fetchClipPlanesRef();
                if (clipPlaneSet !== undefined) {
                    clipPlaneSet.appendIntervalsFromSegment(segment, clipIntervals);
                    const index1 = clipIntervals.length;
                    fractionSum += this.sumSizes(clipIntervals, index0, index1);
                    index0 = index1;
                    // ASSUME primitives are non-overlapping...
                    if (fractionSum >= ClipVector._TARGET_FRACTION_SUM)
                        break;
                }
            }
            if (fractionSum < ClipVector._TARGET_FRACTION_SUM)
                return false;
        }
        return true;
    }
}
exports.ClipVector = ClipVector;
ClipVector._TARGET_FRACTION_SUM = 0.99999999;


/***/ }),

/***/ "./lib/clipping/ConvexClipPlaneSet.js":
/*!********************************************!*\
  !*** ./lib/clipping/ConvexClipPlaneSet.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const PolygonOps_1 = __webpack_require__(/*! ../geometry3d/PolygonOps */ "./lib/geometry3d/PolygonOps.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const ClipPlane_1 = __webpack_require__(/*! ./ClipPlane */ "./lib/clipping/ClipPlane.js");
const ClipUtils_1 = __webpack_require__(/*! ./ClipUtils */ "./lib/clipping/ClipUtils.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
/**
 * A ConvexClipPlaneSet is a collection of ClipPlanes, often used for bounding regions of space.
 * @public
 */
class ConvexClipPlaneSet {
    // private _parity: number;   <--- Not yet used
    // public get parity() { return this._parity; }
    // public set parity(value: number) { this._parity = value; }
    constructor(planes) {
        // this._parity = 1;
        this._planes = planes ? planes : [];
    }
    /** Return an array containing all the planes of the convex set.
     * * Note that this has no leading keyword identifying it as a ConvexClipPlaneSet.
     */
    toJSON() {
        const val = [];
        for (const plane of this._planes) {
            val.push(plane.toJSON());
        }
        return val;
    }
    /** Extract clip planes from a json array `[  clipPlane, clipPlane ]`.
     * * Non-clipPlane members are ignored.
     */
    static fromJSON(json, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        if (!Array.isArray(json))
            return result;
        for (const thisJson of json) {
            const plane = ClipPlane_1.ClipPlane.fromJSON(thisJson);
            if (plane)
                result._planes.push(plane);
        }
        return result;
    }
    /**
     * Return true if all members are almostEqual to corresponding members of other.  This includes identical order in array.
     * @param other clip plane to compare
     */
    isAlmostEqual(other) {
        if (this._planes.length !== other._planes.length)
            return false;
        for (let i = 0; i < this._planes.length; i++)
            if (!this._planes[i].isAlmostEqual(other._planes[i]))
                return false;
        return true;
    }
    /** create from an array of planes.
     * * Each plane reference in the `planes` array is taken into the result.
     * * The input array itself is NOT taken into the result.
     */
    static createPlanes(planes, result) {
        result = result ? result : new ConvexClipPlaneSet();
        for (const plane of planes)
            result._planes.push(plane);
        return result;
    }
    /**
     * Create new convex set using selected planes of a Range3d.
     * @param range range with coordinates
     * @param lowX true to clip at the low x plane
     * @param highX true to clip at the high x plane
     * @param lowY true to clip at the low y plane
     * @param highY true to clip at the high z plane
     * @param lowZ true to clip at the low z plane
     * @param highZ true to clip at the high z plane
     */
    static createRange3dPlanes(range, lowX = true, highX = true, lowY = true, highY = true, lowZ = true, highZ = true) {
        const result = ConvexClipPlaneSet.createEmpty();
        if (lowX)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(1, 0, 0, range.low.x, 0, 0));
        if (highX)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(-1, 0, 0, range.high.x, 0, 0));
        if (lowY)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(0, 1, 0, 0, range.low.y, 0));
        if (highY)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(0, -1, 0, 0, range.high.y, 0));
        if (lowZ)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(0, 0, 1, 0, 0, range.low.z));
        if (highZ)
            result.planes.push(ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(0, 0, -1, 0, 0, range.high.z));
        return result;
    }
    /** create an empty `ConvexClipPlaneSet` */
    static createEmpty(result) {
        if (result) {
            result._planes.length = 0;
            return result;
        }
        return new ConvexClipPlaneSet();
    }
    /** negate all planes of the set. */
    negateAllPlanes() {
        for (const plane of this._planes)
            plane.negateInPlace();
    }
    /** Create a convex clip plane set that clips to `x0 <= x <= x1` and `y0 <= y <= y1`.
     * * Note that there is no test for the usual ordering `x0 <= x1` or `y0 <= y1`.
     *    * if the usual ordering is violated, the convex set is an empty set.
     */
    static createXYBox(x0, y0, x1, y1, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        const clip0 = ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(-1, 0, 0), -x1, false, true);
        const clip1 = ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(1, 0, 0), x0, false, true);
        const clip2 = ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(0, -1, 0), -y1, false, true);
        const clip3 = ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(0, 1, 0), y0, false, true);
        if (clip0 && clip1 && clip2 && clip3) {
            result._planes.push(clip0, clip1, clip2, clip3);
        }
        return result;
    }
    /** Create a convex set containing a half space for each edge between points of a polyline.
     * * Caller is responsible for assuring the polyline is convex.
     * @param points array of points.  Only xy parts are considered.
     * @param interior array whose boolean value is used as both the `interior` and `invisible` bits of the plane for the succeeding segment.
     * @param leftIsInside if true, the interior is "to the left" of the segments.  If false, interior is "to the right"
     */
    static createXYPolyLine(points, interior, leftIsInside, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        for (let i0 = 0; (i0 + 1) < points.length; i0++) {
            const edgeVector = Point3dVector3d_1.Vector3d.createStartEnd(points[i0], points[i0 + 1]);
            const perp = edgeVector.unitPerpendicularXY();
            perp.z = 0.0;
            if (!leftIsInside)
                perp.negate();
            const perpNormalized = perp.normalize();
            if (perpNormalized) {
                const clip = ClipPlane_1.ClipPlane.createNormalAndPoint(perp, points[i0], interior[i0], interior[i0]);
                if (clip) {
                    result._planes.push(clip);
                }
            }
        }
        return result;
    }
    /**
     * Create a convexClipPlaneSet with planes whose "inside" normal is to the left of each segment.
     * @param points array of points.
     */
    static createXYPolyLineInsideLeft(points, result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        for (let i0 = 0; (i0 + 1) < points.length; i0++) {
            const edgeVector = Point3dVector3d_1.Vector3d.createStartEnd(points[i0], points[i0 + 1]);
            const perp = edgeVector.unitPerpendicularXY();
            perp.z = 0.0;
            const perpNormalized = perp.normalize();
            if (perpNormalized) {
                const clip = ClipPlane_1.ClipPlane.createNormalAndPoint(perp, points[i0], false, false);
                if (clip) {
                    result._planes.push(clip);
                }
            }
        }
        return result;
    }
    /**
     * (re)set a plane and ConvexClipPlaneSet for a convex array, such as a convex facet used for xy clip.
     * * The planeOfPolygon is (re)initialized with the normal from 3 points, but not otherwise referenced.
     * * The ConvexClipPlaneSet is filled with outward normals of the facet edges as viewed to xy plane.
     * @param points
     * @param result
     */
    static setPlaneAndXYLoopCCW(points, planeOfPolygon, frustum) {
        let i0 = points.length - 1;
        const n = points.length;
        let x0 = points.getXAtUncheckedPointIndex(i0);
        let y0 = points.getYAtUncheckedPointIndex(i0);
        let x1, y1, nx, ny;
        frustum._planes.length = 0;
        const z0 = points.getZAtUncheckedPointIndex(i0); // z for planes can stay fixed
        const planeNormal = points.crossProductIndexIndexIndex(0, 2, 1);
        ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(planeNormal.x, planeNormal.y, planeNormal.z, x0, y0, z0, false, false, planeOfPolygon);
        if (planeNormal.normalizeInPlace()) {
            for (let i1 = 0; i1 < n; i0 = i1, i1++, x0 = x1, y0 = y1) {
                x1 = points.getXAtUncheckedPointIndex(i1);
                y1 = points.getYAtUncheckedPointIndex(i1);
                nx = -(y1 - y0);
                ny = x1 - x0;
                const clipper = ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(nx, ny, 0, x1, y1, z0);
                if (clipper)
                    frustum._planes.push(clipper);
            }
        }
    }
    /** Deep clone of all planes. */
    clone(result) {
        result = result ? result : new ConvexClipPlaneSet();
        result._planes.length = 0;
        for (const plane of this._planes)
            result._planes.push(plane.clone());
        return result;
    }
    /** Return the (reference to the) array of `ClipPlane` */
    get planes() {
        return this._planes;
    }
    /** Test if there is any intersection with a ray defined by origin and direction.
     * * Optionally record the range (null or otherwise) in caller-allocated result.
     * * If the ray is unbounded inside the clip, result can contain positive or negative "Geometry.hugeCoordinate" values
     * * If no result is provide, there are no object allocations.
     * @param result optional Range1d to receive parameters along the ray.
     */
    hasIntersectionWithRay(ray, result) {
        // form low and high values in locals that do not require allocation.
        // transfer to caller-supplied result at end
        let t0 = -Geometry_1.Geometry.hugeCoordinate;
        let t1 = Geometry_1.Geometry.hugeCoordinate;
        if (result)
            result.setNull();
        for (const plane of this._planes) {
            const vD = plane.velocity(ray.direction);
            const vN = plane.altitude(ray.origin);
            if (vD === 0.0) {
                // Ray is parallel... No need to continue testing if outside halfspace.
                if (vN < 0.0)
                    return false; // and result is a null range.
            }
            else {
                const rayFraction = -vN / vD;
                if (vD < 0.0) {
                    if (rayFraction < t1)
                        t1 = rayFraction;
                }
                else {
                    if (rayFraction > t0)
                        t0 = rayFraction;
                }
            }
        }
        if (t1 < t0)
            return false; // and result is a null range.
        if (result) {
            result.extendX(t0);
            result.extendX(t1);
        }
        return true;
    }
    /**
     * Multiply all the ClipPlanes DPoint4d by matrix.
     * @param matrix matrix to apply.
     * @param invert if true, use in verse of the matrix.
     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)
     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA
     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.
     * * Both params default to true to get the full effect of transforming space.
     * @param matrix matrix to apply
     */
    multiplyPlanesByMatrix4d(matrix, invert = true, transpose = true) {
        if (invert) { // form inverse once here, reuse for all planes
            const inverse = matrix.createInverse();
            if (!inverse)
                return false;
            return this.multiplyPlanesByMatrix4d(inverse, false, transpose);
        }
        for (const plane of this._planes) {
            plane.multiplyPlaneByMatrix4d(matrix, false, transpose);
        }
        return true;
    }
    /** Return true if `point` satisfies `point.isPointInside` for all planes */
    isPointInside(point) {
        for (const plane of this._planes) {
            if (!plane.isPointInside(point)) // Defaults to strict inside check. Other clipping classes may use "on or inside" check for the "on" case
                return false;
        }
        return true;
    }
    /** Return true if `point` satisfies `point.isPointOnOrInside` for all planes */
    isPointOnOrInside(point, tolerance) {
        const interiorTolerance = Math.abs(tolerance); // Interior tolerance should always be positive. (TFS# 246598).
        for (const plane of this._planes) {
            if (!plane.isPointOnOrInside(point, (plane.interior ? interiorTolerance : tolerance)))
                return false;
        }
        return true;
    }
    /**
     * Test if a sphere is completely inside the convex set.
     * @param centerPoint center of sphere
     * @param radius radius of sphere.
     */
    isSphereInside(centerPoint, radius) {
        const r1 = Math.abs(radius) + Geometry_1.Geometry.smallMetricDistance;
        for (const plane of this._planes) {
            if (!plane.isPointOnOrInside(centerPoint, r1)) {
                return false;
            }
        }
        return true;
    }
    /** Find the parts of the line segment  (if any) that is within the convex clip volume.
     * * The input fractional interval from fraction0 to fraction1 (increasing!!) is the active part to consider.
     * * To clip to the usual bounded line segment, starts with fractions (0,1).
     * If the clip volume is unbounded, the line interval may also be unbounded.
     * * An unbounded line portion will have fraction coordinates positive or negative Number.MAX_VALUE.
     * @param fraction0 fraction that is the initial lower fraction of the active interval. (e.g. 0.0 for bounded segment)
     * @param fraction1 fraction that is the initial upper fraction of the active interval.  (e.g. 1.0 for bounded segment)
     * @param pointA segment start (fraction 0)
     * @param pointB segment end (fraction 1)
     * @param announce function to be called to announce a fraction interval that is within the convex clip volume.
     * @returns true if a segment was announced, false if entirely outside.
     */
    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {
        let fraction;
        if (f1 < f0)
            return false;
        for (const plane of this._planes) {
            const hA = -plane.altitude(pointA);
            const hB = -plane.altitude(pointB);
            fraction = Geometry_1.Geometry.safeDivideFraction(-hA, (hB - hA), 0.0);
            if (fraction === undefined) {
                // LIne parallel to the plane.  If positive, it is all OUT
                if (hA > 0.0)
                    return false;
            }
            else if (hB > hA) { // STRICTLY moving outward
                if (fraction < f0)
                    return false;
                if (fraction < f1)
                    f1 = fraction;
            }
            else if (hA > hB) { // STRICTLY moving inward
                if (fraction > f1)
                    return false;
                if (fraction > f0)
                    f0 = fraction;
            }
            else {
                // Strictly equal evaluations
                if (hA > 0.0)
                    return false;
            }
        }
        if (f1 >= f0) {
            if (announce)
                announce(f0, f1);
            return true;
        }
        return false;
    }
    /** Find fractional parts of the arc that are within this ClipPlaneSet, and announce each as
     * * `announce(fraction, fraction, curve)`
     */
    announceClippedArcIntervals(arc, announce) {
        const breaks = ConvexClipPlaneSet._clipArcFractionArray;
        breaks.clear();
        for (const clipPlane of this.planes) {
            clipPlane.appendIntersectionRadians(arc, breaks);
        }
        arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);
        return ClipUtils_1.ClipUtilities.selectIntervals01(arc, breaks, this, announce);
    }
    /** Find the parts of the (unbounded) line segment  (if any) that is within the convex clip volume.
     * @param pointA segment start (fraction 0)
     * @param pointB segment end (fraction 1)
     * @param announce function to be called to announce a fraction interval that is within the convex clip volume.
     * @returns true if a segment was announced, false if entirely outside.
     */
    clipUnboundedSegment(pointA, pointB, announce) {
        return this.announceClippedSegmentIntervals(-Number.MAX_VALUE, Number.MAX_VALUE, pointA, pointB, announce);
    }
    /** transform each plane in place. */
    transformInPlace(transform) {
        for (const plane of this._planes) {
            plane.transformInPlace(transform);
        }
    }
    /**
     * Clip a polygon to the inside of the convex set.
     * * Results with 2 or fewer points are ignored.
     * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.
     * @param xyz input points.
     * @param work work buffer
     * @param tolerance tolerance for "on plane" decision.
     */
    clipConvexPolygonInPlace(xyz, work, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        for (const plane of this._planes) {
            plane.clipConvexPolygonInPlace(xyz, work, true, tolerance);
            if (xyz.length < 3)
                return;
        }
    }
    /** Returns 1, 2, or 3 based on whether point array is strongly inside, ambiguous, or strongly outside respectively.
     * * This has a peculiar expected use case as a very fast pre-filter for more precise clipping.
     * * The expected point set is for a polygon.
     * * Hence any clipping will eventually have to consider the lines between the points.
     * * This method looks for the special case of a single clip plane that has all the points outside.
     * * In this case the whole polygon must be outside.
     * * Note that this does not detect a polygon that is outside but "crosses a corner" -- it is mixed with respect to
     *     multiple planes.
     */
    classifyPointContainment(points, onIsOutside) {
        let allInside = true;
        const onTolerance = onIsOutside ? 1.0e-8 : -1.0e-8;
        const interiorTolerance = 1.0e-8; // Interior tolerance should always be positive
        for (const plane of this._planes) {
            let nOutside = 0;
            for (const point of points) {
                if (plane.altitude(point) < (plane.interior ? interiorTolerance : onTolerance)) {
                    nOutside++;
                    allInside = false;
                }
            }
            if (nOutside === points.length)
                return ClipUtils_1.ClipPlaneContainment.StronglyOutside;
        }
        return allInside ? ClipUtils_1.ClipPlaneContainment.StronglyInside : ClipUtils_1.ClipPlaneContainment.Ambiguous;
    }
    /**
     * * Create a convex clip set for a polygon swept with possible tilt angle.
     * * planes are constructed by ClipPlane.createEdgeAndUpVector, using successive points from the array.
     * * If the first and last points match, the polygon area is checked.  If the area is negative, points are used in reverse order.
     * * If first and last points do not match, points are used in order given
     * @param points polygon points. (Closure point optional)
     * @param upVector primary sweep direction, as applied by ClipPlane.createEdgeAndUpVector
     * @param tiltAngle angle to tilt sweep planes away from the sweep direction.
     */
    static createSweptPolyline(points, upVector, tiltAngle) {
        const result = ConvexClipPlaneSet.createEmpty();
        let reverse = false;
        if (points.length > 3 && points[0].isAlmostEqual(points[points.length - 1])) {
            const polygonNormal = PolygonOps_1.PolygonOps.areaNormal(points);
            const normalDot = polygonNormal.dotProduct(upVector);
            if (normalDot > 0.0)
                reverse = true;
        }
        for (let i = 0; (i + 1) < points.length; i++) {
            if (reverse) {
                const toAdd = ClipPlane_1.ClipPlane.createEdgeAndUpVector(points[i + 1], points[i], upVector, tiltAngle);
                if (toAdd) { // clipPlane creation could result in undefined
                    result.addPlaneToConvexSet(toAdd);
                }
                else {
                    return undefined;
                }
            }
            else {
                const toAdd = ClipPlane_1.ClipPlane.createEdgeAndUpVector(points[i], points[i + 1], upVector, tiltAngle);
                if (toAdd) { // clipPlane creation could result in undefined
                    result.addPlaneToConvexSet(toAdd);
                }
                else {
                    return undefined;
                }
            }
        }
        return result;
    }
    /**
     * Add a plane to the convex set.
     * @param plane plane to add
     */
    addPlaneToConvexSet(plane) {
        if (plane)
            this._planes.push(plane);
    }
    /**
     * test many points.  Distribute them to arrays depending on in/out result.
     * @param points points to test
     * @param inOrOn points that are in or on the set
     * @param out points that are out.
     */
    clipPointsOnOrInside(points, inOrOn, out) {
        inOrOn.length = 0;
        out.length = 0;
        for (const xyz of points) {
            if (this.isPointOnOrInside(xyz, 0.0)) {
                inOrOn.push(xyz);
            }
            else {
                out.push(xyz);
            }
        }
    }
    /**
     * Clip a polygon to the planes of the clip plane set.
     * * For a convex input polygon, the output is another convex polygon.
     * * For a non-convex input, the output may have double-back edges along plane intersections.  This is still a valid clip in a parity sense.
     * * The containingPlane parameter allows callers within ConvexClipPlane set to bypass planes known to contain the polygon
     * @param input input polygon, usually convex.
     * @param output output polygon
     * @param work work array.
     * @param containingPlane if this plane is found in the convex set, it is NOT applied.
     */
    polygonClip(input, output, work, planeToSkip) {
        if (input instanceof GrowableXYZArray_1.GrowableXYZArray)
            input.clone(output);
        else
            GrowableXYZArray_1.GrowableXYZArray.create(input, output);
        for (const plane of this._planes) {
            if (planeToSkip === plane)
                continue;
            if (output.length === 0)
                break;
            plane.clipConvexPolygonInPlace(output, work);
        }
    }
    /**
     * * Define new planes in this ConvexClipPlaneSet so it clips to the inside of a polygon.
     * * always create planes for the swept edges of the polygon
     * * optionally (with nonzero sideSelect) create a cap plane using the polygon normal.
     * @param points Points of a bounding polygon
     * @param sweepDirection direction to sweep.
     * @param sideSelect 0 to have no cap polygon, 1 if the sweep vector side is in, -1 if sweep vector side is out.
     */
    reloadSweptPolygon(points, sweepDirection, sideSelect) {
        this._planes.length = 0;
        const n = points.length;
        if (n <= 2)
            return 0;
        const planeNormal = PolygonOps_1.PolygonOps.areaNormal(points);
        const isCCW = sweepDirection.dotProduct(planeNormal) > 0.0;
        const delta = isCCW ? 1 : n - 1;
        for (let i = 0; i < n; i++) {
            const i1 = (i + delta) % n;
            const xyz0 = points[i];
            const xyz1 = points[i1];
            if (xyz0.isAlmostEqual(xyz1))
                continue;
            const edgeVector = Point3dVector3d_1.Vector3d.createStartEnd(xyz0, xyz1);
            const inwardNormal = Point3dVector3d_1.Vector3d.createCrossProduct(sweepDirection.x, sweepDirection.y, sweepDirection.z, edgeVector.x, edgeVector.y, edgeVector.z);
            const inwardNormalNormalized = inwardNormal.normalize();
            let distance;
            if (inwardNormalNormalized) { // Should never fail... simply a check due to the format of the normalize function return
                distance = inwardNormalNormalized.dotProduct(xyz0);
                const clipToAdd = ClipPlane_1.ClipPlane.createNormalAndDistance(inwardNormalNormalized, distance, false, false);
                if (clipToAdd) {
                    this._planes.push(clipToAdd);
                } // clipPlane creation could result in undefined
            }
        }
        if (sideSelect !== 0.0) {
            let planeNormalNormalized = planeNormal.normalize();
            if (planeNormalNormalized) { // Again.. should never fail
                const a = sweepDirection.dotProduct(planeNormalNormalized) * sideSelect;
                if (a < 0.0)
                    planeNormalNormalized = planeNormalNormalized.negate();
                const xyz0 = points[0];
                const distance = planeNormalNormalized.dotProduct(xyz0);
                const clipToAdd = ClipPlane_1.ClipPlane.createNormalAndDistance(planeNormalNormalized, distance, false, false);
                if (clipToAdd) {
                    this._planes.push(clipToAdd);
                } // clipPlane creation could result in undefined
            }
        }
        return isCCW ? 1 : -1;
    }
    /**
     * Compute intersections among all combinations of 3 planes in the convex set.
     * * optionally throw out points that are not in the set.
     * * optionally push the points in the caller-supplied point array.
     * * optionally extend a caller supplied range.
     * * In the common case where the convex set is (a) a slab or (b) a view frustum, there will be 8 points and the range is the range of the convex set.
     * * If the convex set is unbounded, the range only contains the range of the accepted (corner) points, and the range is not a representative of the "range of all points in the set" .
     * @param transform (optional) transform to apply to the points.
     * @param points (optional) array to which computed points are to be added.
     * @param range (optional) range to be extended by the computed points
     * @param transform (optional) transform to apply to the accepted points.
     * @param testContainment if true, test each point to see if it is within the convex set.  (Send false if confident that the convex set is rectilinear set such as a slab.  Send true if chiseled corners are possible)
     * @returns number of points.
     */
    computePlanePlanePlaneIntersections(points, rangeToExtend, transform, testContainment = true) {
        const normalRows = Matrix3d_1.Matrix3d.createIdentity();
        const allPlanes = this._planes;
        const n = allPlanes.length;
        let numPoints = 0; // explicitly count points -- can't wait to end for points.length because it may be an optional output.
        for (let i = 0; i < n; i++) {
            for (let j = i + 1; j < n; j++)
                for (let k = j + 1; k < n; k++) {
                    Matrix3d_1.Matrix3d.createRowValues(allPlanes[i].inwardNormalRef.x, allPlanes[i].inwardNormalRef.y, allPlanes[i].inwardNormalRef.z, allPlanes[j].inwardNormalRef.x, allPlanes[j].inwardNormalRef.y, allPlanes[j].inwardNormalRef.z, allPlanes[k].inwardNormalRef.x, allPlanes[k].inwardNormalRef.y, allPlanes[k].inwardNormalRef.z, normalRows);
                    if (normalRows.computeCachedInverse(false)) {
                        const xyz = normalRows.multiplyInverseXYZAsPoint3d(allPlanes[i].distance, allPlanes[j].distance, allPlanes[k].distance);
                        if (!testContainment || this.isPointOnOrInside(xyz, Geometry_1.Geometry.smallMetricDistance)) {
                            numPoints++;
                            if (transform)
                                transform.multiplyPoint3d(xyz, xyz);
                            if (points)
                                points.push(xyz);
                            if (rangeToExtend)
                                rangeToExtend.extendPoint(xyz);
                        }
                    }
                }
        }
        return numPoints;
    }
    /**
     * Set the `invisible` property on each plane of the convex set.
     * @param invisible value to store
     */
    setInvisible(invisible) {
        for (const plane of this._planes) {
            plane.setInvisible(invisible);
        }
    }
    /**
     * Add planes for z-direction clip between low and high z levels.
     * @param invisible value to apply to the `invisible` bit for the new planes
     * @param zLow low z value.  The plane clips out points with z below this.
     * @param zHigh high z value.  The plane clips out points with z above this.
     */
    addZClipPlanes(invisible, zLow, zHigh) {
        if (zLow !== undefined)
            this._planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(0, 0, 1), zLow, invisible));
        if (zHigh !== undefined)
            this._planes.push(ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(0, 0, -1), -zHigh, invisible));
    }
}
exports.ConvexClipPlaneSet = ConvexClipPlaneSet;
/** Value acting as "at infinity" for coordinates along a ray. */
ConvexClipPlaneSet.hugeVal = 1e37;
ConvexClipPlaneSet._clipArcFractionArray = new GrowableFloat64Array_1.GrowableFloat64Array();


/***/ }),

/***/ "./lib/clipping/UnionOfConvexClipPlaneSets.js":
/*!****************************************************!*\
  !*** ./lib/clipping/UnionOfConvexClipPlaneSets.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module CartesianGeometry */
Object.defineProperty(exports, "__esModule", { value: true });
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const ClipUtils_1 = __webpack_require__(/*! ./ClipUtils */ "./lib/clipping/ClipUtils.js");
const ConvexClipPlaneSet_1 = __webpack_require__(/*! ./ConvexClipPlaneSet */ "./lib/clipping/ConvexClipPlaneSet.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
/**
 * A collection of ConvexClipPlaneSets.
 * * A point is "in" the clip plane set if it is "in" one or more of  the ConvexClipPlaneSet
 * * Hence the boolean logic is that the ClipPlaneSet is a UNION of its constituents.
 * @public
 */
class UnionOfConvexClipPlaneSets {
    constructor() {
        this._convexSets = [];
    }
    /** (property accessor)  Return the (reference to the) array of `ConvexClipPlaneSet` */
    get convexSets() { return this._convexSets; }
    /** Return an array with the `toJSON` form of each  `ConvexClipPlaneSet` */
    toJSON() {
        const val = [];
        for (const convex of this._convexSets) {
            val.push(convex.toJSON());
        }
        return val;
    }
    /** Convert json `UnionOfConvexClipPlaneSets`, using `setFromJSON`. */
    static fromJSON(json, result) {
        result = result ? result : new UnionOfConvexClipPlaneSets();
        result._convexSets.length = 0;
        if (!Array.isArray(json))
            return result;
        for (const thisJson of json) {
            result._convexSets.push(ConvexClipPlaneSet_1.ConvexClipPlaneSet.fromJSON(thisJson));
        }
        return result;
    }
    /** Create a `UnionOfConvexClipPlaneSets` with no members. */
    static createEmpty(result) {
        if (result) {
            result._convexSets.length = 0;
            return result;
        }
        return new UnionOfConvexClipPlaneSets();
    }
    /**
     * Return true if all member convex sets are almostEqual to corresponding members of other.  This includes identical order in array.
     * @param other clip plane to compare
     */
    isAlmostEqual(other) {
        if (this._convexSets.length !== other._convexSets.length)
            return false;
        for (let i = 0; i < this._convexSets.length; i++)
            if (!this._convexSets[i].isAlmostEqual(other._convexSets[i]))
                return false;
        return true;
    }
    /** Create a `UnionOfConvexClipPlaneSets` with given `ConvexClipPlaneSet` members */
    static createConvexSets(convexSets, result) {
        result = result ? result : new UnionOfConvexClipPlaneSets();
        for (const set of convexSets)
            result._convexSets.push(set);
        return result;
    }
    /** return a deep copy. */
    clone(result) {
        result = result ? result : new UnionOfConvexClipPlaneSets();
        result._convexSets.length = 0;
        for (const convexSet of this._convexSets)
            result._convexSets.push(convexSet.clone());
        return result;
    }
    /** Append `toAdd` to the array of `ConvexClipPlaneSet` */
    addConvexSet(toAdd) {
        this._convexSets.push(toAdd);
    }
    /** Test if there is any intersection with a ray defined by origin and direction.
     * * Optionally record the range (null or otherwise) in caller-allocated result.
     * * If the ray is unbounded inside the clip, result can contain positive or negative "Geometry.hugeCoordinate" values
     * * If no result is provide, there are no object allocations.
     * @param maximalRange optional Range1d to receive parameters along the ray.
     */
    hasIntersectionWithRay(ray, maximalRange) {
        if (maximalRange === undefined) {
            // if complete result is not requested, return after any hit.
            for (const planeSet of this._convexSets) {
                if (planeSet.hasIntersectionWithRay(ray))
                    return true;
            }
            return false;
        }
        maximalRange.setNull();
        const rangeA = Range_1.Range1d.createNull();
        for (const planeSet of this._convexSets) {
            if (planeSet.hasIntersectionWithRay(ray, rangeA))
                maximalRange.extendRange(rangeA);
        }
        return !maximalRange.isNull;
    }
    /** Return true if true is returned for any contained convex set returns true for `convexSet.isPointInside (point, tolerance)`  */
    isPointInside(point) {
        for (const convexSet of this._convexSets) {
            if (convexSet.isPointInside(point)) {
                return true;
            }
        }
        return false;
    }
    /** Return true if true is returned for any contained convex set returns true for `convexSet.isPointOnOrInside (point, tolerance)`  */
    isPointOnOrInside(point, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        for (const convexSet of this._convexSets) {
            if (convexSet.isPointOnOrInside(point, tolerance))
                return true;
        }
        return false;
    }
    /** Return true if true is returned for any contained convex set returns true for `convexSet.isSphereOnOrInside (point, tolerance)`  */
    isSphereInside(point, radius) {
        for (const convexSet of this._convexSets) {
            if (convexSet.isSphereInside(point, radius))
                return true;
        }
        return false;
    }
    /** test if any part of a line segment is within the volume */
    isAnyPointInOrOnFromSegment(segment) {
        for (const convexSet of this._convexSets) {
            if (convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref))
                return true;
        }
        return false;
    }
    // Intervals must be Segment1d array, as there may be multiple intervals along segment that pass through set regions,
    // and so splitting the intervals into segments aids in better organization
    /** Returns the fractions of the segment that pass through the set region, as 1 dimensional pieces */
    appendIntervalsFromSegment(segment, intervals) {
        for (const convexSet of this._convexSets) {
            convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref, (fraction0, fraction1) => intervals.push(Segment1d_1.Segment1d.create(fraction0, fraction1)));
        }
    }
    /** apply `transform` to all the ConvexClipPlaneSet's */
    transformInPlace(transform) {
        for (const convexSet of this._convexSets) {
            convexSet.transformInPlace(transform);
        }
    }
    /** Returns 1, 2, or 3 based on whether point is strongly inside, ambiguous, or strongly outside respectively */
    classifyPointContainment(points, onIsOutside) {
        for (const convexSet of this._convexSets) {
            const thisStatus = convexSet.classifyPointContainment(points, onIsOutside);
            if (thisStatus !== ClipUtils_1.ClipPlaneContainment.StronglyOutside)
                return thisStatus;
        }
        return ClipUtils_1.ClipPlaneContainment.StronglyOutside;
    }
    /** Clip a polygon using this ClipPlaneSet, returning new polygon boundaries. Note that each polygon may lie next to the previous, or be disconnected. */
    polygonClip(input, output) {
        output.length = 0;
        if (Array.isArray(input))
            input = GrowableXYZArray_1.GrowableXYZArray.create(input);
        const work = new GrowableXYZArray_1.GrowableXYZArray();
        for (const convexSet of this._convexSets) {
            const convexSetOutput = new GrowableXYZArray_1.GrowableXYZArray();
            convexSet.polygonClip(input, convexSetOutput, work);
            if (convexSetOutput.length !== 0)
                output.push(convexSetOutput);
        }
    }
    /**
     * * announce clipSegment() for each convexSet in this ClipPlaneSet.
     * * all clipPlaneSets are inspected
     * * announced intervals are for each individual clipPlaneSet -- adjacent intervals are not consolidated.
     * @param f0 active interval start.
     * @param f1 active interval end
     * @param pointA line segment start
     * @param pointB line segment end
     * @param announce function to announce interval.
     * @returns Return true if any announcements are made.
     */
    announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce) {
        let numAnnounce = 0;
        for (const convexSet of this._convexSets) {
            if (convexSet.announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce))
                numAnnounce++;
        }
        return numAnnounce > 0;
    }
    /** Find parts of an arc that are inside any member clipper.
     * Announce each with `announce(startFraction, endFraction, this)`
     */
    announceClippedArcIntervals(arc, announce) {
        const breaks = UnionOfConvexClipPlaneSets._clipArcFractionArray;
        breaks.clear();
        for (const convexSet of this._convexSets) {
            for (const clipPlane of convexSet.planes) {
                clipPlane.appendIntersectionRadians(arc, breaks);
            }
        }
        arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);
        return ClipUtils_1.ClipUtilities.selectIntervals01(arc, breaks, this, announce);
    }
    /**
     * Collect the output from computePlanePlanePlaneIntersections in all the contained convex sets.
     *
     * @param transform (optional) transform to apply to the points.
     * @param points (optional) array to which computed points are to be added.
     * @param range (optional) range to be extended by the computed points
     * @param transform (optional) transform to apply to the accepted points.
     * @param testContainment if true, test each point to see if it is within the convex set.  (Send false if confident that the convex set is rectilinear set such as a slab.  Send true if chiseled corners are possible)
     * @returns number of points.
     */
    computePlanePlanePlaneIntersectionsInAllConvexSets(points, rangeToExtend, transform, testContainment = true) {
        let n = 0;
        for (const convexSet of this._convexSets) {
            n += convexSet.computePlanePlanePlaneIntersections(points, rangeToExtend, transform, testContainment);
        }
        return n;
    }
    /**
     * Multiply all ClipPlanes DPoint4d by matrix.
     * @param matrix matrix to apply.
     * @param invert if true, use in verse of the matrix.
     * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)
     * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA
     * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.
     * * Both params default to true to get the full effect of transforming space.
     * @param matrix matrix to apply
     */
    multiplyPlanesByMatrix4d(matrix, invert = true, transpose = true) {
        if (invert) { // form inverse once here, reuse for all planes
            const inverse = matrix.createInverse();
            if (!inverse)
                return false;
            return this.multiplyPlanesByMatrix4d(inverse, false, transpose);
        }
        // (no inversion -- no failures possible)
        for (const convexSet of this._convexSets) {
            convexSet.multiplyPlanesByMatrix4d(matrix, false, transpose);
        }
        return true;
    }
    /** Recursively call `setInvisible` on all member convex sets. */
    setInvisible(invisible) {
        for (const convexSet of this._convexSets) {
            convexSet.setInvisible(invisible);
        }
    }
    /** add convex sets that accept points below `zLow` and above `zHigh` */
    addOutsideZClipSets(invisible, zLow, zHigh) {
        if (zLow) {
            const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
            convexSet.addZClipPlanes(invisible, zLow);
            this._convexSets.push(convexSet);
        }
        if (zHigh) {
            const convexSet = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
            convexSet.addZClipPlanes(invisible, undefined, zHigh);
            this._convexSets.push(convexSet);
        }
    }
}
exports.UnionOfConvexClipPlaneSets = UnionOfConvexClipPlaneSets;
UnionOfConvexClipPlaneSets._clipArcFractionArray = new GrowableFloat64Array_1.GrowableFloat64Array();


/***/ }),

/***/ "./lib/curve/Arc3d.js":
/*!****************************!*\
  !*** ./lib/curve/Arc3d.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const CurveExtendMode_1 = __webpack_require__(/*! ./CurveExtendMode */ "./lib/curve/CurveExtendMode.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const StrokeOptions_1 = __webpack_require__(/*! ./StrokeOptions */ "./lib/curve/StrokeOptions.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
/**
 * Circular or elliptic arc.
 *
 * * The angle to point equation is:
 *
 * **  `X = center + cos(theta) * vector0 + sin(theta) * vector90`
 * * When the two vectors are perpendicular and have equal length, it is a true circle.
 * * Non-perpendicular vectors are always elliptic.
 * *  vectors of unequal length are always elliptic.
 * * To create an ellipse in the common "major and minor axis" form of an ellipse:
 * ** vector0 is the vector from the center to the major axis extreme.
 * ** vector90 is the vector from the center to the minor axis extreme.
 * ** note the constructing the vectors to the extreme points makes them perpendicular.
 * *  The method toScaledMatrix3d () can be called to convert the unrestricted vector0,vector90 to perpendicular form.
 * * The unrestricted form is much easier to work with for common calculations -- stroking, projection to 2d, intersection with plane.
 * @public
 */
class Arc3d extends CurvePrimitive_1.CurvePrimitive {
    // constructor copies the pointers !!!
    constructor(center, matrix, sweep) {
        super();
        /** String name for schema properties */
        this.curvePrimitiveType = "arc";
        this._center = center;
        this._matrix = matrix;
        this._sweep = sweep;
    }
    /**
     * Test if this and other are both instances of Arc3d.
     */
    isSameGeometryClass(other) { return other instanceof Arc3d; }
    /**
     * read property for (clone of) center
     */
    get center() { return this._center.clone(); }
    /**
     * read property for (clone of) vector0
     */
    get vector0() { return this._matrix.columnX(); }
    /**
     * read property for (clone of) vector90
     */
    get vector90() { return this._matrix.columnY(); }
    /**
     * read property for (clone of) plane normal, with arbitrary length.
     */
    get perpendicularVector() { return this._matrix.columnZ(); }
    /**
     * read property for (clone of!) matrix of vector0, vector90, unit normal
     */
    get matrix() { return this._matrix.clone(); }
    /**
     * read property for (reference to !!) matrix of vector0, vector90, unit normal
     */
    get matrixRef() { return this._matrix; }
    /** property getter for the angle sweep */
    get sweep() { return this._sweep; }
    /** property setter for angle sweep */
    set sweep(value) { this._sweep.setFrom(value); }
    /**
     * An Arc3d extends along its complete elliptic arc
     */
    get isExtensibleFractionSpace() { return true; }
    /**
     *  Return a clone of the arc, with transform applied
     * @param transform
     */
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    /**
     * Redefine the arc with (captured references to) given data.
     * @param center arc center
     * @param matrix matrix with columns vector0, vector 90, and their unit cross product
     * @param sweep angle sweep
     */
    setRefs(center, matrix, sweep) {
        this._center = center;
        this._matrix = matrix;
        this._sweep = sweep;
    }
    /**
     * Redefine the arc with (clones of) given data.
     * @param center arc center
     * @param matrix matrix with columns vector0, vector 90, and their unit cross product
     * @param sweep angle sweep
     */
    set(center, matrix, sweep) {
        this.setRefs(center.clone(), matrix.clone(), sweep ? sweep.clone() : AngleSweep_1.AngleSweep.create360());
    }
    /**
     * Copy center, matrix, and sweep from other Arc3d.
     */
    setFrom(other) {
        this._center.setFrom(other._center);
        this._matrix.setFrom(other._matrix);
        this._sweep.setFrom(other._sweep);
    }
    /** Return a clone of this arc. */
    clone() {
        return new Arc3d(this._center.clone(), this._matrix.clone(), this._sweep.clone());
    }
    /**
     * Create an arc, capturing references to center, matrix and sweep.
     * @param center center point
     * @param matrix matrix with columns vector0, vector90, and unit cross product
     * @param sweep sweep limits
     * @param result optional preallocated result.
     */
    static createRefs(center, matrix, sweep, result) {
        if (result) {
            result.setRefs(center, matrix, sweep);
            return result;
        }
        return new Arc3d(center, matrix, sweep);
    }
    /**
     * Create an arc from center, x column to be scaled, and y column to be scaled.
     * @param center center of ellipse
     * @param matrix matrix whose x and y columns are unit vectors to be scaled by radius0 and radius90
     * @param radius0 radius in x direction.
     * @param radius90 radius in y direction.
     * @param sweep sweep limits
     * @param result optional preallocated result.
     */
    static createScaledXYColumns(center, matrix, radius0, radius90, sweep, result) {
        const vector0 = matrix.columnX();
        const vector90 = matrix.columnY();
        return Arc3d.create(center, vector0.scale(radius0, vector0), vector90.scale(radius90, vector90), sweep, result);
    }
    /**
     * Create a (full circular) arc from center, normal and radius
     * @param center center of ellipse
     * @param normal normal vector
     * @param radius radius in x direction.
     * @param result optional preallocated result.
     */
    static createCenterNormalRadius(center, normal, radius, result) {
        const frame = Matrix3d_1.Matrix3d.createRigidHeadsUp(normal, Geometry_1.AxisOrder.ZYX);
        return Arc3d.createScaledXYColumns(center, frame, radius, radius, undefined, result);
    }
    /**
     * Creat an arc by center with vectors to points at 0 and 90 degrees in parameter space.
     * @param center arc center
     * @param vector0 vector to 0 degrees (commonly major axis)
     * @param vector90 vector to 90 degree point (commonly minor axis)
     * @param sweep sweep limits
     * @param result optional preallocated result
     */
    static create(center, vector0, vector90, sweep, result) {
        const normal = vector0.unitCrossProductWithDefault(vector90, 0, 0, 0); // normal will be 000 for degenerate case ! !!
        const matrix = Matrix3d_1.Matrix3d.createColumns(vector0, vector90, normal);
        return Arc3d.createRefs(center.clone(), matrix, sweep ? sweep.clone() : AngleSweep_1.AngleSweep.create360(), result);
    }
    /** Return a clone of this arc, projected to given z value.
     * * If `z` is omitted, the clone is at the z of the center.
     * * Note that projection to fixed z can change circle into ellipse (and (rarely) ellipse to circle)
     */
    cloneAtZ(z) {
        if (z === undefined)
            z = this._center.z;
        return Arc3d.createXYZXYZXYZ(this._center.x, this._center.y, this._center.z, this._matrix.coffs[0], this._matrix.coffs[3], z, this._matrix.coffs[1], this._matrix.coffs[4], z, this._sweep);
    }
    /**
     * Create an arc by center (cx,cy,xz) with vectors (ux,uy,uz) and (vx,vy,vz) to points at 0 and 90 degrees in parameter space.
     * @param result optional preallocated result
     */
    static createXYZXYZXYZ(cx, cy, cz, ux, uy, uz, vx, vy, vz, sweep, result) {
        return Arc3d.create(Point3dVector3d_1.Point3d.create(cx, cy, cz), Point3dVector3d_1.Vector3d.create(ux, uy, uz), Point3dVector3d_1.Vector3d.create(vx, vy, vz), sweep, result);
    }
    /**
     * Return a quick estimate of the eccentricity of the ellipse.
     * * The estimator is the cross magnitude of the product of vectors U and V, divided by square of the larger magnitude
     * * for typical Arc3d with perpendicular UV, this is exactly the small axis divided by large.
     * * note that the eccentricity is AT MOST ONE.
     */
    quickEccentricity() {
        const magX = this._matrix.columnXMagnitude();
        const magY = this._matrix.columnYMagnitude();
        const jacobian = this._matrix.columnXYCrossProductMagnitude();
        const largeAxis = Geometry_1.Geometry.maxXY(magX, magY);
        return jacobian / (largeAxis * largeAxis);
    }
    /** Create a circular arc defined by start point, any intermediate point, and end point.
     * If the points are colinear, assemble them into a linestring.
     */
    static createCircularStartMiddleEnd(pointA, pointB, pointC, result) {
        const vectorAB = Point3dVector3d_1.Vector3d.createStartEnd(pointA, pointB);
        const vectorAC = Point3dVector3d_1.Vector3d.createStartEnd(pointA, pointC);
        const ab = vectorAB.magnitude();
        const bc = vectorAC.magnitude();
        const normal = vectorAB.sizedCrossProduct(vectorAC, Math.sqrt(ab * bc));
        if (normal) {
            const vectorToCenter = Polynomials_1.SmallSystem.linearSystem3d(normal.x, normal.y, normal.z, vectorAB.x, vectorAB.y, vectorAB.z, vectorAC.x, vectorAC.y, vectorAC.z, 0, // vectorToCenter DOT normal = 0
            0.5 * ab * ab, // vectorToCenter DOT vectorBA = 0.5 * vectorBA DOT vectorBA  (Rayleigh quotient)
            0.5 * bc * bc); // vectorToCenter DOT vectorBC = 0.5 * vectorBC DOT vectorBC  (Rayleigh quotient)
            if (vectorToCenter) {
                const center = Point3dVector3d_1.Point3d.create(pointA.x, pointA.y, pointA.z).plus(vectorToCenter);
                const vectorX = Point3dVector3d_1.Vector3d.createStartEnd(center, pointA);
                const vectorY = Point3dVector3d_1.Vector3d.createRotateVectorAroundVector(vectorX, normal, Angle_1.Angle.createDegrees(90));
                if (vectorY) {
                    const vectorCenterToC = Point3dVector3d_1.Vector3d.createStartEnd(center, pointC);
                    const sweepAngle = vectorX.signedAngleTo(vectorCenterToC, normal);
                    if (sweepAngle.radians < 0.0)
                        sweepAngle.addMultipleOf2PiInPlace(1.0);
                    return Arc3d.create(center, vectorX, vectorY, AngleSweep_1.AngleSweep.createStartEndRadians(0.0, sweepAngle.radians), result);
                }
            }
        }
        return LineString3d_1.LineString3d.create(pointA, pointB, pointC);
    }
    /** The arc has simple proportional arc length if and only if it is a circular arc. */
    getFractionToDistanceScale() {
        const radius = this.circularRadius();
        if (radius !== undefined)
            return Math.abs(radius * this._sweep.sweepRadians);
        return undefined;
    }
    /**
     * Convert a fractional position to xyz coordinates
     * @param fraction fractional position on arc
     * @param result optional preallocated result
     */
    fractionToPoint(fraction, result) {
        const radians = this._sweep.fractionToRadians(fraction);
        return this._matrix.originPlusMatrixTimesXY(this._center, Math.cos(radians), Math.sin(radians), result);
    }
    /**
     * Convert fractional arc and radial positions to xyz coordinates
     * @param fraction fractional position on arc
     * @param result optional preallocated result
     */
    fractionAndRadialFractionToPoint(arcFraction, radialFraction, result) {
        const radians = this._sweep.fractionToRadians(arcFraction);
        return this._matrix.originPlusMatrixTimesXY(this._center, radialFraction * Math.cos(radians), radialFraction * Math.sin(radians), result);
    }
    /**
     * Convert a fractional position to xyz coordinates and derivative with respect to fraction.
     * @param fraction fractional position on arc
     * @param result optional preallocated result
     */
    fractionToPointAndDerivative(fraction, result) {
        result = this.radiansToPointAndDerivative(this._sweep.fractionToRadians(fraction), result);
        result.direction.scaleInPlace(this._sweep.sweepRadians);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the arc
     * * x axis is the first derivative, i.e. tangent along the arc
     * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.
     * If the arc is circular, the second derivative is directly towards the center
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const radians = this._sweep.fractionToRadians(fraction);
        if (!result)
            result = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);
        const a = this._sweep.sweepRadians;
        this._matrix.multiplyXY(-a * s, a * c, result.vectorU);
        const aa = a * a;
        this._matrix.multiplyXY(-aa * c, -aa * s, result.vectorV);
        return result;
    }
    /**
     * Evaluate the point and derivative with respect to the angle (in radians)
     * @param radians angular position
     * @param result optional preallocated ray.
     */
    radiansToPointAndDerivative(radians, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);
        this._matrix.multiplyXY(-s, c, result.direction);
        return result;
    }
    /**
     * Return a parametric plane with
     * * origin at arc center
     * * vectorU from center to arc at angle (in radians)
     * * vectorV from center to arc at 90 degrees past the angle.
     * @param radians angular position
     * @param result optional preallocated plane
     */
    radiansToRotatedBasis(radians, result) {
        result = result ? result : Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        result.origin.setFromPoint3d(this.center);
        this._matrix.multiplyXY(c, s, result.vectorU);
        this._matrix.multiplyXY(-s, c, result.vectorV);
        return result;
    }
    /**
     * Evaluate the point and derivative with respect to the angle (in radians)
     * @param theta angular position
     * @param result optional preallocated ray.
     */
    angleToPointAndDerivative(theta, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        const c = theta.cos();
        const s = theta.sin();
        this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);
        this._matrix.multiplyXY(-s, c, result.direction);
        return result;
    }
    /**
     * Return the start point tof the arc.
     * @param result optional preallocated result
     */
    startPoint(result) { return this.fractionToPoint(0.0, result); }
    /**
     * Return the end point tof the arc.
     * @param result optional preallocated result
     */
    endPoint(result) { return this.fractionToPoint(1.0, result); }
    /** * If this is a circular arc, return the simple length derived from radius and sweep.
     * * Otherwise (i.e. if this elliptical) fall through to CurvePrimitive base implementation which
     *     Uses quadrature.
     */
    curveLength() {
        return this.curveLengthBetweenFractions(0, 1);
    }
    /** * If this is a circular arc, return the simple length derived from radius and sweep.
     * * Otherwise (i.e. if this elliptical) fall through CurvePrimitive integrator.
     */
    curveLengthBetweenFractions(fraction0, fraction1) {
        const simpleLength = this.getFractionToDistanceScale();
        if (simpleLength !== undefined)
            return simpleLength * Math.abs(fraction1 - fraction0);
        // fall through for true ellipse . .. stroke and accumulate quadrature with typical count .  ..
        let f0 = fraction0;
        let f1 = fraction1;
        if (fraction0 > fraction1) {
            f0 = fraction1;
            f1 = fraction0;
        }
        const sweepDegrees = (f1 - f0) * this._sweep.sweepDegrees;
        let eccentricity = this.quickEccentricity();
        if (eccentricity < 0.00001)
            eccentricity = 0.00001;
        let numInterval = Math.ceil(sweepDegrees / (eccentricity * Arc3d.quadratureIntervalAngleDegrees));
        if (numInterval > 400)
            numInterval = 400;
        if (numInterval < 1)
            numInterval = 1;
        return super.curveLengthWithFixedIntervalCountQuadrature(f0, f1, numInterval, Arc3d.quadratureGuassCount);
    }
    /**
     * Return an approximate (but easy to compute) arc length.
     * The estimate is:
     * * Form 8 chords on full circle, proportionally fewer for partials.  (But 2 extras if less than half circle.)
     * * sum the chord lengths
     * * For a circle, we know this crude approximation has to be increased by a factor (theta/(2 sin (theta/2)))
     * * Apply that factor.
     * * Experiments confirm that this is within 3 percent for a variety of eccentricities and arc sweeps.
     */
    quickLength() {
        const totalSweep = Math.abs(this._sweep.sweepRadians);
        let numInterval = Math.ceil(4 * totalSweep / Math.PI);
        if (numInterval < 1)
            numInterval = 1;
        if (numInterval < 4)
            numInterval += 3;
        else if (numInterval < 6)
            numInterval += 2; // force extras for short arcs
        const pointA = Arc3d._workPointA;
        const pointB = Arc3d._workPointB;
        let chordSum = 0.0;
        this.fractionToPoint(0.0, pointA);
        for (let i = 1; i <= numInterval; i++) {
            this.fractionToPoint(i / numInterval, pointB);
            chordSum += pointA.distance(pointB);
            pointA.setFromPoint3d(pointB);
        }
        // The chord sum is always shorter.
        // if it is a true circular arc, the ratio of correct over sum is easy ...
        const dTheta = totalSweep / numInterval;
        const factor = dTheta / (2.0 * Math.sin(0.5 * dTheta));
        return chordSum * factor;
    }
    /**
     * * See extended comments on `CurvePrimitive.moveSignedDistanceFromFraction`
     * * A zero length line generates `CurveSearchStatus.error`
     * * Nonzero length line generates `CurveSearchStatus.success` or `CurveSearchStatus.stoppedAtBoundary`
     */
    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {
        if (!this.isCircular) // suppress extension !!!
            return super.moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result);
        const totalLength = this.curveLength();
        const signedFractionMove = Geometry_1.Geometry.conditionalDivideFraction(signedDistance, totalLength);
        if (signedFractionMove === undefined) {
            return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, startFraction, this.fractionToPoint(startFraction), 0.0, CurveLocationDetail_1.CurveSearchStatus.error);
        }
        return CurveLocationDetail_1.CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, startFraction + signedFractionMove, signedDistance, result);
    }
    /**
     * Return all angles (in radians) where the ellipse tangent is perpendicular to the vector to a spacePoint.
     * @param spacePoint point of origin of vectors to the ellipse
     * @param _extend (NOT SUPPORTED -- ALWAYS ACTS AS "true")
     * @param _endpoints if true, force the end radians into the result.
     */
    allPerpendicularAngles(spacePoint, _extend = true, _endpoints = false) {
        const radians = [];
        const vectorQ = spacePoint.vectorTo(this.center);
        const uu = this._matrix.columnXMagnitudeSquared();
        const uv = this._matrix.columnXDotColumnY();
        const vv = this._matrix.columnYMagnitudeSquared();
        Polynomials_1.TrigPolynomial.solveUnitCircleImplicitQuadricIntersection(uv, vv - uu, -uv, this._matrix.dotColumnY(vectorQ), -this._matrix.dotColumnX(vectorQ), 0.0, radians);
        if (_endpoints) {
            radians.push(this.sweep.startRadians);
            radians.push(this.sweep.endRadians);
        }
        return radians;
    }
    /**
     * Return details of the closest point on the arc, optionally extending to full ellipse.
     * @param spacePoint search for point closest to this point.
     * @param extend if true, consider projections to the complete ellipse.   If false, consider only endpoints and projections within the arc sweep.
     * @param result optional preallocated result.
     */
    closestPoint(spacePoint, extend, result) {
        result = CurveLocationDetail_1.CurveLocationDetail.create(this, result);
        const allRadians = this.allPerpendicularAngles(spacePoint, true, true);
        if (!extend && !this._sweep.isFullCircle) {
            allRadians.push(this._sweep.startRadians);
            allRadians.push(this._sweep.endRadians);
        }
        // hm... logically there must at least two angles there ...  but if it happens return the start point ...
        const workRay = Ray3d_1.Ray3d.createZero();
        if (allRadians.length === 0) {
            result.setFR(0.0, this.radiansToPointAndDerivative(this._sweep.startRadians, workRay));
            result.a = spacePoint.distance(result.point);
        }
        else {
            let dMin = Number.MAX_VALUE;
            let d = 0;
            for (const radians of allRadians) {
                const fraction = CurveExtendMode_1.CurveExtendOptions.resolveRadiansToSweepFraction(extend, radians, this.sweep);
                if (fraction !== undefined) {
                    this.fractionToPointAndDerivative(fraction, workRay);
                    d = spacePoint.distance(workRay.origin);
                    if (d < dMin) {
                        dMin = d;
                        result.setFR(fraction, workRay);
                        result.a = d;
                    }
                }
            }
        }
        return result;
    }
    /** Reverse the sweep  of the arc. */
    reverseInPlace() { this._sweep.reverseInPlace(); }
    /** apply a transform to the arc basis vectors.
     * * nonuniform (i.e. skewing) transforms are allowed.
     * * The transformed vector0 and vector90 are NOT squared up as major minor axes.  (This is a good feature!!)
     */
    tryTransformInPlace(transform) {
        this._center = transform.multiplyPoint3d(this._center, this._center);
        this._matrix = transform.matrix.multiplyMatrixMatrix(this._matrix, this._matrix);
        // force re-normalization of columnZ.
        this.setVector0Vector90(this._matrix.columnX(), this._matrix.columnY());
        return true;
    }
    /**
     * Return true if the ellipse center and basis vectors are in the plane
     * @param plane
     */
    isInPlane(plane) {
        const normal = plane.getNormalRef();
        // The ellipse vectors are full-length  -- true distance comparisons say things.
        return Geometry_1.Geometry.isSmallMetricDistance(plane.altitude(this._center))
            && Geometry_1.Geometry.isSmallMetricDistance(this._matrix.dotColumnX(normal))
            && Geometry_1.Geometry.isSmallMetricDistance(this._matrix.dotColumnY(normal));
    }
    /**
     * Return true if the vector0 and vector90 are of equal length and perpendicular.
     */
    get isCircular() {
        const axx = this._matrix.columnXMagnitudeSquared();
        const ayy = this._matrix.columnYMagnitudeSquared();
        const axy = this._matrix.columnXDotColumnY();
        return Angle_1.Angle.isPerpendicularDotSet(axx, ayy, axy) && Geometry_1.Geometry.isSameCoordinateSquared(axx, ayy);
    }
    /** If the arc is circular, return its radius.  Otherwise return undefined */
    circularRadius() {
        return this.isCircular ? this._matrix.columnXMagnitude() : undefined;
    }
    /** Return the larger of the two defining vectors. */
    maxVectorLength() { return Math.max(this._matrix.columnXMagnitude(), this._matrix.columnYMagnitude()); }
    /**
     * compute intersections with a plane.
     * @param plane plane to intersect
     * @param result array of locations on the curve.
     */
    appendPlaneIntersectionPoints(plane, result) {
        const constCoff = plane.altitude(this._center);
        const coffs = this._matrix.coffs;
        const cosCoff = plane.velocityXYZ(coffs[0], coffs[3], coffs[6]);
        const sinCoff = plane.velocityXYZ(coffs[1], coffs[4], coffs[7]);
        const trigPoints = Geometry_1.Geometry.solveTrigForm(constCoff, cosCoff, sinCoff);
        let numIntersection = 0;
        if (trigPoints !== undefined) {
            numIntersection = trigPoints.length;
            let xy;
            for (xy of trigPoints) {
                const radians = Math.atan2(xy.y, xy.x);
                const fraction = this._sweep.radiansToPositivePeriodicFraction(radians);
                const detail = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction));
                detail.intervalRole = CurveLocationDetail_1.CurveIntervalRole.isolated;
                if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._sweep.startRadians))
                    detail.intervalRole = CurveLocationDetail_1.CurveIntervalRole.isolatedAtVertex;
                else if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._sweep.startRadians))
                    detail.intervalRole = CurveLocationDetail_1.CurveIntervalRole.isolatedAtVertex;
                result.push(detail);
            }
        }
        return numIntersection;
    }
    /**
     * Extend a range to include the range of the arc.
     * @param range range being extended.
     * @param transform optional transform to apply to the arc.
     */
    extendRange(range, transform) {
        const df = 1.0 / 32;
        // KLUDGE --- evaluate lots of points ...
        let point = Point3dVector3d_1.Point3d.create();
        for (let fraction = 0; fraction <= 1.001; fraction += df) {
            point = this.fractionToPoint(fraction, point);
            if (transform)
                range.extendTransformedPoint(transform, point);
            else
                range.extendPoint(point);
        }
    }
    /**
     * Create a new arc which is a unit circle centered at the origin.
     */
    static createUnitCircle() {
        return Arc3d.createRefs(Point3dVector3d_1.Point3d.create(0, 0, 0), Matrix3d_1.Matrix3d.createIdentity(), AngleSweep_1.AngleSweep.create360());
    }
    /**
     * Create a new arc which is parallel to the xy plane, with given center and radius and optional angle sweep.
     * @param center center of arc
     * @param radius radius of arc
     * @param sweep sweep limits.  defaults to full circle.
     */
    static createXY(center, radius, sweep = AngleSweep_1.AngleSweep.create360()) {
        return new Arc3d(center.clone(), Matrix3d_1.Matrix3d.createScale(radius, radius, 1.0), sweep);
    }
    /**
     * Create a new arc which is parallel to the xy plane, with given center and x,y radii, and optional angle sweep
     * @param center center of ellipse
     * @param radiusA x axis radius
     * @param radiusB y axis radius
     * @param sweep angle sweep
     */
    static createXYEllipse(center, radiusA, radiusB, sweep = AngleSweep_1.AngleSweep.create360()) {
        return new Arc3d(center.clone(), Matrix3d_1.Matrix3d.createScale(radiusA, radiusB, 1.0), sweep);
    }
    /**
     * Replace the arc's 0 and 90 degree vectors.
     * @param vector0 vector from center to ellipse point at 0 degrees in parameter space
     * @param vector90 vector from center to ellipse point at 90 degrees in parameter space
     */
    setVector0Vector90(vector0, vector90) {
        this._matrix.setColumns(vector0, vector90, vector0.unitCrossProductWithDefault(vector90, 0, 0, 0));
    }
    /** Return the arc definition with rigid matrix form with axis radii.
     */
    toScaledMatrix3d() {
        const angleData = Angle_1.Angle.dotProductsToHalfAngleTrigValues(this._matrix.columnXMagnitudeSquared(), this._matrix.columnYMagnitudeSquared(), this._matrix.columnXDotColumnY(), true);
        const vector0A = this._matrix.multiplyXY(angleData.c, angleData.s);
        const vector90A = this._matrix.multiplyXY(-angleData.s, angleData.c);
        const axes = Matrix3d_1.Matrix3d.createRigidFromColumns(vector0A, vector90A, Geometry_1.AxisOrder.XYZ);
        return {
            axes: (axes ? axes : Matrix3d_1.Matrix3d.createIdentity()),
            center: this._center,
            r0: vector0A.magnitude(),
            r90: vector90A.magnitude(),
            sweep: this.sweep.cloneMinusRadians(angleData.radians),
        };
    }
    /** Return the arc definition with center, two vectors, and angle sweep;
     */
    toVectors() {
        return {
            center: this.center,
            vector0: this._matrix.columnX(),
            vector90: this._matrix.columnY(),
            sweep: this.sweep,
        };
    }
    /** Return the arc definition with center, two vectors, and angle sweep, optionally transformed.
     */
    toTransformedVectors(transform) {
        return transform ? {
            center: transform.multiplyPoint3d(this._center),
            vector0: transform.multiplyVector(this._matrix.columnX()),
            vector90: transform.multiplyVector(this._matrix.columnY()),
            sweep: this.sweep,
        }
            : {
                center: this._center.clone(),
                vector0: this._matrix.columnX(),
                vector90: this._matrix.columnY(),
                sweep: this.sweep,
            };
    }
    /** Return the arc definition with center, two vectors, and angle sweep, transformed to 4d points.
     */
    toTransformedPoint4d(matrix) {
        return {
            center: matrix.multiplyPoint3d(this._center, 1.0),
            vector0: matrix.multiplyPoint3d(this._matrix.columnX(), 0.0),
            vector90: matrix.multiplyPoint3d(this._matrix.columnY(), 0.0),
            sweep: this.sweep,
        };
    }
    /**
     * Set this arc from a json object with these values:
     * * center center point
     * * vector0 vector from center to 0 degree point in parameter space (commonly but not always the major axis vector)
     * * vector90 vector from center to 90 degree point in parameter space (commonly but not always the minor axis vector)
     * @param json
     */
    setFromJSON(json) {
        if (json && json.center && json.vector0 && json.vector90 && json.sweep) {
            this._center.setFromJSON(json.center);
            const vector0 = Point3dVector3d_1.Vector3d.create();
            const vector90 = Point3dVector3d_1.Vector3d.create();
            vector0.setFromJSON(json.vector0);
            vector90.setFromJSON(json.vector90);
            this.setVector0Vector90(vector0, vector90);
            this._sweep.setFromJSON(json.sweep);
        }
        else {
            this._center.set(0, 0, 0);
            this._matrix.setFrom(Matrix3d_1.Matrix3d.identity);
            this._sweep.setStartEndRadians();
        }
    }
    /**
     * Convert to a JSON object.
     * @return {*} [center:  [], vector0:[], vector90:[], sweep []}
     */
    toJSON() {
        return {
            center: this._center.toJSON(),
            sweep: this._sweep.toJSON(),
            vector0: this._matrix.columnX().toJSON(),
            vector90: this._matrix.columnY().toJSON(),
        };
    }
    /**
     * Test if this arc is almost equal to another GeometryQuery object
     */
    isAlmostEqual(otherGeometry) {
        if (otherGeometry instanceof Arc3d) {
            const other = otherGeometry;
            return this._center.isAlmostEqual(other._center)
                && this._matrix.isAlmostEqual(other._matrix)
                && this._sweep.isAlmostEqualAllowPeriodShift(other._sweep);
        }
        return false;
    }
    /** Emit strokes to caller-supplied linestring */
    emitStrokes(dest, options) {
        const numStrokes = this.computeStrokeCountForOptions(options);
        dest.appendFractionalStrokePoints(this, numStrokes, 0.0, 1.0, true);
    }
    /** Emit strokes to caller-supplied handler */
    emitStrokableParts(handler, options) {
        const numStrokes = this.computeStrokeCountForOptions(options);
        handler.startCurvePrimitive(this);
        handler.announceIntervalForUniformStepStrokes(this, numStrokes, 0.0, 1.0);
        handler.endCurvePrimitive(this);
    }
    /**
     * return the stroke count required for given options.
     * @param options StrokeOptions that determine count
     */
    computeStrokeCountForOptions(options) {
        let numStroke = 1;
        if (options) {
            const rMax = this.maxVectorLength();
            numStroke = options.applyTolerancesToArc(rMax, this._sweep.sweepRadians);
        }
        else {
            numStroke = StrokeOptions_1.StrokeOptions.applyAngleTol(undefined, 1, this._sweep.sweepRadians);
        }
        return numStroke;
    }
    /** Second step of double dispatch:  call `handler.handleArc3d(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleArc3d(this);
    }
    /** Return (if possible) an arc which is a portion of this curve.
     * @param fractionA [in] start fraction
     * @param fractionB [in] end fraction
     */
    clonePartialCurve(fractionA, fractionB) {
        if (fractionB < fractionA) {
            const arcA = this.clonePartialCurve(fractionB, fractionA);
            if (arcA)
                arcA.reverseInPlace();
            return arcA;
        }
        const arcB = this.clone();
        arcB.sweep.setStartEndRadians(this.sweep.fractionToRadians(fractionA), this.sweep.fractionToRadians(fractionB));
        return arcB;
    }
    /** Return an arc whose basis vectors are rotated by given angle within the current basis space.
     * * the result arc will have its zero-degree point (new `vector0`) at the current `vector0 * cos(theta) + vector90 * sin(theta)`
     * * the result sweep is adjusted so all fractional coordinates (e.g. start and end) evaluate to the same xyz.
     *   * Specifically, theta is subtracted from the original start and end angles.
     * @param theta the angle (in the input arc space) which is to become the 0-degree point in the new arc.
     */
    cloneInRotatedBasis(theta) {
        const c = theta.cos();
        const s = theta.sin();
        const vector0 = this._matrix.multiplyXY(c, s);
        const vector90 = this.matrix.multiplyXY(-s, c);
        const newSweep = AngleSweep_1.AngleSweep.createStartEndRadians(this._sweep.startRadians - theta.radians, this._sweep.endRadians - theta.radians);
        const arcB = Arc3d.create(this._center.clone(), vector0, vector90, newSweep);
        return arcB;
    }
    /**
     * Find intervals of this CurvePrimitive that are interior to a clipper
     * @param clipper clip structure (e.g.clip planes)
     * @param announce(optional) function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     * @returns true if any "in" segments are announced.
     */
    announceClipIntervals(clipper, announce) {
        return clipper.announceClippedArcIntervals(this, announce);
    }
    /** Compute the center and vectors of another arc as local coordinates within this arc's frame. */
    otherArcAsLocalVectors(other) {
        const otherOrigin = this._matrix.multiplyInverseXYZAsPoint3d(other.center.x - this.center.x, other.center.y - this.center.y, other.center.z - this.center.z);
        const otherVector0 = this._matrix.multiplyInverse(other.vector0);
        const otherVector90 = this._matrix.multiplyInverse(other.vector90);
        if (otherOrigin && otherVector0 && otherVector90) {
            return { center: otherOrigin, vector0: otherVector0, vector90: otherVector90, sweep: this.sweep.clone() };
        }
        return undefined;
    }
    /**
     * Determine an arc "at a point of inflection" of a point sequence.
     * * Return the arc along with the fractional positions of the tangency points.
     * * In the returned object:
     *   * `arc` is the (bounded) arc
     *   * `fraction10` is the tangency point's position as an interpolating fraction of the line segment from `point1` (backwards) to `point0`
     *   * `fraction12` is the tangency point's position as an interpolating fraction of the line segment from `point1` (forward) to `point2`
     *   * `point1` is the `point1` input.
     * * If unable to construct the arc:
     *   * `point` is the `point` input.
     *   * both fractions are zero
     *   * `arc` is undefined.
     * @param point0 first point of path. (the point before the point of inflection)
     * @param point1 second point of path (the point of inflection)
     * @param point2 third point of path (the point after the point of inflection)
     * @param radius arc radius
     *
     */
    static createFilletArc(point0, point1, point2, radius) {
        const vector10 = Point3dVector3d_1.Vector3d.createStartEnd(point1, point0);
        const vector12 = Point3dVector3d_1.Vector3d.createStartEnd(point1, point2);
        const d10 = vector10.magnitude();
        const d12 = vector12.magnitude();
        if (vector10.normalizeInPlace() && vector12.normalizeInPlace()) {
            const bisector = vector10.plus(vector12);
            if (bisector.normalizeInPlace()) {
                // const theta = vector12.angleTo(bisector);
                // vector10, vector12, and bisector are UNIT vectors
                // bisector splits the angle between vector10 and vector12
                const perpendicular = vector12.minus(vector10);
                const perpendicularMagnitude = perpendicular.magnitude(); // == 2 * sin(theta)
                const sinTheta = 0.5 * perpendicularMagnitude;
                if (!Geometry_1.Geometry.isSmallAngleRadians(sinTheta)) { // (for small theta, sinTheta is almost equal to theta)
                    const cosTheta = Math.sqrt(1 - sinTheta * sinTheta);
                    const tanTheta = sinTheta / cosTheta;
                    const alphaRadians = Math.acos(sinTheta);
                    const distanceToCenter = radius / sinTheta;
                    const distanceToTangency = radius / tanTheta;
                    const f10 = distanceToTangency / d10;
                    const f12 = distanceToTangency / d12;
                    const center = point1.plusScaled(bisector, distanceToCenter);
                    bisector.scaleInPlace(-radius);
                    perpendicular.scaleInPlace(radius / perpendicularMagnitude);
                    const arc02 = Arc3d.create(center, bisector, perpendicular, AngleSweep_1.AngleSweep.createStartEndRadians(-alphaRadians, alphaRadians));
                    return { arc: arc02, fraction10: f10, fraction12: f12, point: point1.clone() };
                }
            }
        }
        return { fraction10: 0.0, fraction12: 0.0, point: point1.clone() };
    }
}
exports.Arc3d = Arc3d;
Arc3d._workPointA = Point3dVector3d_1.Point3d.create();
Arc3d._workPointB = Point3dVector3d_1.Point3d.create();
// !! misspelled Gauss in the published static !!!   Declare it ok.
// cspell::word Guass
/** Gauss point quadrature count for evaluating curve length.   (The number of intervals is adjusted to the arc sweep) */
Arc3d.quadratureGuassCount = 5;
/** In quadrature for arc length, use this interval (divided by quickEccentricity) */
Arc3d.quadratureIntervalAngleDegrees = 10.0;


/***/ }),

/***/ "./lib/curve/ChainCollectorContext.js":
/*!********************************************!*\
  !*** ./lib/curve/ChainCollectorContext.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./lib/curve/Path.js");
/**
 * Manage a growing array of arrays of curve primitives that are to be joined "head to tail" in paths.
 * * The caller makes a sequence of calls to announce individual primitives.
 * * Ordering so "head to tail" is obvious is the caller's responsibility.
 * * This class manages the tedium of distinguishing isolated primitives, paths, and multiple paths.
 * * Construction logic makes each chain internally continuous, i.e. suitable for being a Path.
 * * Chaining only occurs between primitives that are consecutive in the announcement stream.
 * * Usage pattern is
 *   * initialization: `context = new ChainCollectorContext (makeClones: boolean)`
 *   * many times: `   context.announceCurvePrimitive (primitive)`
 *   * end:        ` result = context.grabResults ()`
 * @internal
 */
class ChainCollectorContext {
    /** Initialize with an empty array of chains.
     * @param makeClones if true, all CurvePrimitives sent to `announceCurvePrimitive` is immediately cloned.  If false, the reference to the original curve is maintained.
     */
    constructor(makeClones) {
        this._chains = [];
        this._makeClones = makeClones;
    }
    /**
     * Push a new chain with an optional first primitive.
     */
    pushNewChain(primitive) {
        const chain = [];
        if (primitive)
            chain.push(primitive);
        this._chains.push(chain);
    }
    findOrCreateTailChain() {
        if (this._chains.length === 0)
            this.pushNewChain();
        return this._chains[this._chains.length - 1];
    }
    /** Announce a curve primitive
     * * If possible, append it to the current chain.
     * * Otherwise start a new chain.
     */
    announceCurvePrimitive(candidate) {
        if (candidate) {
            if (this._makeClones) {
                const candidate1 = candidate.clone();
                if (!candidate1 || !(candidate1 instanceof CurvePrimitive_1.CurvePrimitive))
                    return;
                this.transferMarkup(candidate, candidate1);
                candidate = candidate1;
            }
            const activeChain = this.findOrCreateTailChain();
            if (activeChain.length === 0 || !ChainCollectorContext.needBreakBetweenPrimitives(activeChain[activeChain.length - 1], candidate))
                activeChain.push(candidate);
            else
                this.pushNewChain(candidate);
        }
    }
    /** Transfer markup (e.g. isCutAtStart, isCutAtEnd) from source to destination */
    transferMarkup(source, dest) {
        if (source && dest) {
            dest.startCut = source.startCut;
            dest.endCut = source.endCut;
        }
    }
    /** turn an array of curve primitives into the simplest possible strongly typed curve structure.
     * * The input array is assumed to be connected appropriately to act as the curves of a Path.
     * * When a path is created the curves array is CAPTURED.
     */
    promoteArrayToCurves(curves) {
        if (curves.length === 0)
            return undefined;
        if (curves.length === 1)
            return curves[0];
        return Path_1.Path.createArray(curves);
    }
    /** Return the collected results, structured as the simplest possible type. */
    grabResult() {
        const chains = this._chains;
        if (chains.length === 0)
            return undefined;
        if (chains.length === 1)
            return this.promoteArrayToCurves(chains[0]);
        const bag = CurveCollection_1.BagOfCurves.create();
        for (const chain of chains) {
            const q = this.promoteArrayToCurves(chain);
            bag.tryAddChild(q);
        }
        return bag;
    }
    /** test if there is a break between primitiveA and primitiveB, due to any condition such as
     * * primitiveA.isCutAtEnd
     * * primitiveB.isCutAtStart
     * * physical gap between primitives.
     */
    static needBreakBetweenPrimitives(primitiveA, primitiveB, isXYOnly = false) {
        if (primitiveA === undefined)
            return true;
        if (primitiveB === undefined)
            return true;
        if (primitiveA.endCut !== undefined)
            return true;
        if (primitiveB.startCut !== undefined)
            return true;
        ChainCollectorContext._workPointA = primitiveA.endPoint(ChainCollectorContext._workPointA);
        ChainCollectorContext._workPointB = primitiveA.startPoint(ChainCollectorContext._workPointB);
        return isXYOnly
            ? ChainCollectorContext._workPointA.isAlmostEqualXY(ChainCollectorContext._workPointB)
            : ChainCollectorContext._workPointA.isAlmostEqual(ChainCollectorContext._workPointB);
    }
}
exports.ChainCollectorContext = ChainCollectorContext;


/***/ }),

/***/ "./lib/curve/ConstructCurveBetweenCurves.js":
/*!**************************************************!*\
  !*** ./lib/curve/ConstructCurveBetweenCurves.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const GeometryHandler_1 = __webpack_require__(/*! ../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
const Arc3d_1 = __webpack_require__(/*! ./Arc3d */ "./lib/curve/Arc3d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * Context for constructing a curve that is interpolated between two other curves.
 * * The only callable method is the static `InterpolateBetween`.
 * * Other methods are called only by `dispatchToGeometryHandler`
 * @public
 */
class ConstructCurveBetweenCurves extends GeometryHandler_1.NullGeometryHandler {
    constructor(_geometry0, _fraction, _geometry1) {
        super();
        // this.geometry0 = _geometry0;   <-- Never used
        this._geometry1 = _geometry1;
        this._fraction = _fraction;
    }
    /**
     * * To be directly called only by double dispatcher
     * * Assumes this.geometry1 was set by calling context.
     * * Construct the interpolated curve between this.geometry1 and the supplied segment0.
     */
    handleLineSegment3d(segment0) {
        if (this._geometry1 instanceof LineSegment3d_1.LineSegment3d) {
            const segment1 = this._geometry1;
            return LineSegment3d_1.LineSegment3d.create(segment0.startPoint().interpolate(this._fraction, segment1.startPoint()), segment0.endPoint().interpolate(this._fraction, segment1.endPoint()));
        }
        return undefined;
    }
    /**
     * * To be directly called only by double dispatcher
     * * Assumes this.geometry1 was set by calling context.
     * * Construct the interpolated curve between this.geometry1 and the supplied ls0.
     */
    handleLineString3d(ls0) {
        if (this._geometry1 instanceof LineString3d_1.LineString3d) {
            const ls1 = this._geometry1;
            if (ls0.numPoints() === ls1.numPoints()) {
                const numPoints = ls0.numPoints();
                const ls = LineString3d_1.LineString3d.create();
                const workPoint = Point3dVector3d_1.Point3d.create();
                const workPoint0 = Point3dVector3d_1.Point3d.create();
                const workPoint1 = Point3dVector3d_1.Point3d.create();
                let workVector0;
                let workVector1;
                const fraction = this._fraction;
                for (let i = 0; i < numPoints; i++) {
                    ls0.pointAt(i, workPoint0);
                    ls1.pointAt(i, workPoint1);
                    workPoint0.interpolate(fraction, workPoint1, workPoint);
                    ls.addPoint(workPoint);
                }
                if (ls0.fractions && ls1.fractions) {
                    for (let i = 0; i < numPoints; i++) {
                        ls.addFraction(Geometry_1.Geometry.interpolate(ls0.fractions.atUncheckedIndex(i), fraction, ls1.fractions.atUncheckedIndex(i)));
                    }
                }
                if (ls0.strokeData && ls1.strokeData) {
                    // Policy: simple clone of stroke count map from ls0.
                    // The curveLength will not match.
                    // But we expect to be called at a time compatible count and a0,a1 are the important thing.
                    ls.strokeData = ls0.strokeData.clone();
                }
                if (ls0.packedDerivatives && ls1.packedDerivatives) {
                    if (!workVector0)
                        workVector0 = Point3dVector3d_1.Vector3d.create();
                    if (!workVector1)
                        workVector1 = Point3dVector3d_1.Vector3d.create();
                    for (let i = 0; i < numPoints; i++) {
                        ls0.packedDerivatives.getVector3dAtCheckedVectorIndex(i, workVector0);
                        ls1.packedDerivatives.getVector3dAtCheckedVectorIndex(i, workVector1);
                        ls.addDerivative(workVector0.interpolate(fraction, workVector1));
                    }
                }
                return ls;
            }
        }
        return undefined;
    }
    /**
     * * To be directly called only by double dispatcher
     * * Assumes this.geometry1 was set by calling context.
     * * Construct the interpolated curve between this.geometry1 and the supplied arc0.
     */
    handleArc3d(arc0) {
        if (this._geometry1 instanceof Arc3d_1.Arc3d) {
            const arc1 = this._geometry1;
            return Arc3d_1.Arc3d.create(arc0.center.interpolate(this._fraction, arc1.center), arc0.vector0.interpolate(this._fraction, arc1.vector0), arc0.vector90.interpolate(this._fraction, arc1.vector90), arc0.sweep.interpolate(this._fraction, arc1.sweep));
        }
        return undefined;
    }
    /**
     * Construct a geometry item which is fractionally interpolated between two others.
     * * The construction is only supported between certain types:
     * * * LineSegment3d+LineSegment3d -- endpoints are interpolated
     * * * LineString3d+LineString3d with matching counts.  Each point is interpolated.
     * * * Arc3d+Arc3d -- center, vector0, vector90, and limit angles of the sweep are interpolated.
     * @param geometry0 geometry "at fraction 0"
     * @param fraction  fractional position
     * @param geometry1 geometry "at fraction 1"
     */
    static interpolateBetween(geometry0, fraction, geometry1) {
        const handler = new ConstructCurveBetweenCurves(geometry0, fraction, geometry1);
        return geometry0.dispatchToGeometryHandler(handler);
    }
}
exports.ConstructCurveBetweenCurves = ConstructCurveBetweenCurves;


/***/ }),

/***/ "./lib/curve/CoordinateXYZ.js":
/*!************************************!*\
  !*** ./lib/curve/CoordinateXYZ.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const GeometryQuery_1 = __webpack_require__(/*! ./GeometryQuery */ "./lib/curve/GeometryQuery.js");
/** A Coordinate is a Point3d with supporting methods from the GeometryQuery abstraction.
 * @public
 */
class CoordinateXYZ extends GeometryQuery_1.GeometryQuery {
    /**
     * @param xyz point to be CAPTURED.
     */
    constructor(xyz) {
        super();
        /** String name for interface properties */
        this.geometryCategory = "point";
        this._xyz = xyz;
    }
    /** Return a (REFERENCE TO) the coordinate data. */
    get point() { return this._xyz; }
    /** Create a new CoordinateXYZ containing a CLONE of point */
    static create(point) {
        return new CoordinateXYZ(point.clone());
    }
    /** Create a new CoordinateXYZ */
    static createXYZ(x = 0, y = 0, z = 0) {
        return new CoordinateXYZ(Point3dVector3d_1.Point3d.create(x, y, z));
    }
    /** return the range of the point */
    range() { return Range_1.Range3d.create(this._xyz); }
    /** extend `rangeToExtend` to include this point (optionally transformed) */
    extendRange(rangeToExtend, transform) {
        if (transform)
            rangeToExtend.extendTransformedXYZ(transform, this._xyz.x, this._xyz.y, this._xyz.z);
        else
            rangeToExtend.extend(this._xyz);
    }
    /** Apply transform to the Coordinate's point. */
    tryTransformInPlace(transform) {
        transform.multiplyPoint3d(this._xyz, this._xyz);
        return true;
    }
    /** return a transformed clone.
     */
    cloneTransformed(transform) {
        const result = new CoordinateXYZ(this._xyz.clone());
        result.tryTransformInPlace(transform);
        return result;
    }
    /** return a clone */
    clone() {
        return new CoordinateXYZ(this._xyz.clone());
    }
    /** return GeometryQuery children for recursive queries.
     *
     * * leaf classes do not need to implement.
     */
    /** test if (other instanceof Coordinate).  */
    isSameGeometryClass(other) {
        return other instanceof CoordinateXYZ;
    }
    /** test for exact structure and nearly identical geometry.
     *
     * *  Leaf classes must implement !!!
     * *  base class implementation recurses through children.
     * *  base implementation is complete for classes with children and no properties.
     * *  classes with both children and properties must implement for properties, call super for children.
     */
    isAlmostEqual(other) {
        return (other instanceof CoordinateXYZ) && this._xyz.isAlmostEqual(other._xyz);
    }
    /** Second step of double dispatch:  call `handler.handleCoordinateXYZ(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleCoordinateXYZ(this);
    }
}
exports.CoordinateXYZ = CoordinateXYZ;


/***/ }),

/***/ "./lib/curve/CurveChainWithDistanceIndex.js":
/*!**************************************************!*\
  !*** ./lib/curve/CurveChainWithDistanceIndex.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const StrokeCountMap_1 = __webpack_require__(/*! ../curve/Query/StrokeCountMap */ "./lib/curve/Query/StrokeCountMap.js");
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const CurveExtendMode_1 = __webpack_require__(/*! ./CurveExtendMode */ "./lib/curve/CurveExtendMode.js");
/**
 * * Annotation of an interval of a curve.
 * * The interval is marked with two pairs of numbers:
 * * * fraction0, fraction1 = fraction parameters along the child curve
 * * * distance0,distance1 = distances within containing CurveChainWithDistanceIndex
 * @public
 */
class PathFragment {
    /** Create a fragment with complete fraction, distance and child data. */
    constructor(childFraction0, childFraction1, distance0, distance1, childCurve) {
        this.childFraction0 = childFraction0;
        this.childFraction1 = childFraction1;
        this.chainDistance0 = distance0;
        this.chainDistance1 = distance1;
        this.childCurve = childCurve;
    }
    /**
     * Return true if the distance is within the distance limits of this fragment.
     * @param distance
     */
    containsChainDistance(distance) {
        return distance >= this.chainDistance0 && distance <= this.chainDistance1;
    }
    /**
     * Return true if this fragment addresses `curve` and brackets `fraction`
     * @param distance
     */
    containsChildCurveAndChildFraction(curve, fraction) {
        return this.childCurve === curve && fraction >= this.childFraction0 && fraction <= this.childFraction1;
    }
    /** Convert distance to local fraction, and apply that to interpolate between the stored curve fractions.
     * Note that proportional calculation does NOT account for nonuniform parameterization in the child curve.
     */
    chainDistanceToInterpolatedChildFraction(distance) {
        return Geometry_1.Geometry.inverseInterpolate(this.childFraction0, this.chainDistance0, this.childFraction1, this.chainDistance1, distance, this.childFraction0); // the interval "must" have nonzero length, division should be safe . ..
    }
    /** Convert chainDistance to true chidFraction, using detailed moveSignedDistanceFromFraction
     */
    chainDistanceToAccurateChildFraction(chainDistance) {
        // The fragments are really expected to do good mappings in their distance range ...
        const childDetail = this.childCurve.moveSignedDistanceFromFraction(this.childFraction0, chainDistance - this.chainDistance0, false);
        return childDetail.fraction;
    }
    /** Return the scale factor to map childCurve fraction derivatives to chain fraction derivatives
     * @param globalDistance total length of the global curve.
     */
    fractionScaleFactor(globalDistance) {
        return globalDistance * (this.childFraction1 - this.childFraction0) / (this.chainDistance1 - this.chainDistance0);
    }
    /** Reverse the fraction and distance data.
     * * each child fraction `f` is replaced by `1-f`
     * * each `chainDistance` is replaced by `totalDistance-chainDistance`
     */
    reverseFractionsAndDistances(totalDistance) {
        const f0 = this.childFraction0;
        const f1 = this.childFraction1;
        const d0 = this.chainDistance0;
        const d1 = this.chainDistance1;
        this.childFraction0 = 1.0 - f1;
        this.childFraction1 = 1.0 - f0;
        this.chainDistance0 = totalDistance - d1;
        this.chainDistance1 = totalDistance - d0;
    }
    /**
     * convert a fractional position on the childCurve to distance in the chain space.
     * * Return value is SIGNED -- will be negative when fraction < this.childFraction0.
     * @param fraction fraction along the curve within this fragment
     */
    childFractionTChainDistance(fraction) {
        let d = this.childCurve.curveLengthBetweenFractions(this.childFraction0, fraction);
        if (fraction < this.childFraction0)
            d = -d;
        return this.chainDistance0 + d;
    }
}
exports.PathFragment = PathFragment;
/** Non-instantiable class to build a distance index for a path. */
class DistanceIndexConstructionContext {
    constructor() {
        this._accumulatedDistance = 0;
        this._fragments = [];
    }
    // ignore curve announcements -- they are repeated in stroke announcements
    startParentCurvePrimitive(_cp) { }
    startCurvePrimitive(_cp) { }
    endParentCurvePrimitive(_cp) { }
    endCurvePrimitive(_cp) { }
    // um .. we need to see curves? how to reject?
    announcePointTangent(_xyz, _fraction, _tangent) { }
    /** Announce numPoints interpolated between point0 and point1, with associated fractions */
    announceSegmentInterval(cp, point0, point1, numStrokes, fraction0, fraction1) {
        let d0 = this._accumulatedDistance;
        if (numStrokes <= 1) {
            this._accumulatedDistance += point0.distance(point1);
            this._fragments.push(new PathFragment(fraction0, fraction1, d0, this._accumulatedDistance, cp));
        }
        else {
            let f1;
            for (let i = 1, f0 = 0.0; i <= numStrokes; i++, f0 = f1) {
                f1 = Geometry_1.Geometry.interpolate(fraction0, i / numStrokes, fraction1);
                d0 = this._accumulatedDistance;
                this._accumulatedDistance += (Math.abs(f1 - f0) * point0.distance(point1));
                this._fragments.push(new PathFragment(f0, f1, d0, this._accumulatedDistance, cp));
            }
        }
    }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        let f1, d, d0;
        for (let i = 1, f0 = fraction0; i <= numStrokes; i++, f0 = f1) {
            f1 = Geometry_1.Geometry.interpolate(fraction0, i / numStrokes, fraction1);
            d = cp.curveLengthBetweenFractions(f0, f1);
            d0 = this._accumulatedDistance;
            this._accumulatedDistance += d;
            this._fragments.push(new PathFragment(f0, f1, d0, this._accumulatedDistance, cp));
        }
    }
    static createPathFragmentIndex(path, options) {
        const handler = new DistanceIndexConstructionContext();
        for (const curve of path.children) {
            curve.emitStrokableParts(handler, options);
        }
        const fragments = handler._fragments;
        return fragments;
    }
}
/**
 * `CurveChainWithDistanceIndex` is a CurvePrimitive whose fractional parameterization is proportional to true
 * distance along a CurveChain.
 * * The curve chain can be any type derived from CurveChain.
 * * * i.e. either a `Path` or a `Loop`
 * @public
 */
class CurveChainWithDistanceIndex extends CurvePrimitive_1.CurvePrimitive {
    // final assembly of CurveChainWithDistanceIndex -- caller must create valid fragment index.
    constructor(path, fragments) {
        super();
        /** String name for schema properties */
        this.curvePrimitiveType = "curveChainWithDistanceIndex";
        this._path = path;
        this._fragments = fragments;
        this._totalLength = fragments[fragments.length - 1].chainDistance1;
    }
    /** Test if other is a `CurveChainWithDistanceIndex` */
    isSameGeometryClass(other) { return other instanceof CurveChainWithDistanceIndex; }
    /**
     * Create a clone, transformed and with its own distance index.
     * @param transform transform to apply in the clone.
     */
    cloneTransformed(transform) {
        const c = this._path.clone();
        if (c !== undefined && c instanceof CurveCollection_1.CurveChain && c.tryTransformInPlace(transform))
            return CurveChainWithDistanceIndex.createCapture(c);
        return undefined;
    }
    /** Reference to the contained path.
     * * Do not modify the path.  The distance index will be wrong.
     */
    get path() { return this._path; }
    /** Return a deep clone */
    clone() {
        const c = this._path.clone();
        if (c !== undefined && c instanceof CurveCollection_1.CurveChain)
            return CurveChainWithDistanceIndex.createCapture(c);
        return undefined;
    }
    /** Ask if the curve is within tolerance of a plane.
     * @returns Returns true if the curve is completely within tolerance of the plane.
     */
    isInPlane(plane) {
        for (const c of this._path.children) {
            if (!c.isInPlane(plane))
                return false;
        }
        return true;
    }
    /** return the start point of the primitive.  The default implementation returns fractionToPoint (0.0) */
    startPoint(result) {
        const c = this._path.cyclicCurvePrimitive(0);
        if (c)
            return c.startPoint(result);
        return Point3dVector3d_1.Point3d.createZero(result);
    }
    /** Return the end point of the primitive. The default implementation returns fractionToPoint(1.0) */
    endPoint(result) {
        const c = this._path.cyclicCurvePrimitive(-1);
        if (c)
            return c.endPoint(result);
        return Point3dVector3d_1.Point3d.createZero(result);
    }
    /** Add strokes to caller-supplied linestring */
    emitStrokes(dest, options) {
        for (const c of this._path.children) {
            c.emitStrokes(dest, options);
        }
    }
    /** Ask the curve to announce points and simple subcurve fragments for stroking.
     * See IStrokeHandler for description of the sequence of the method calls.
     */
    emitStrokableParts(dest, options) {
        for (const c of this._path.children) {
            c.emitStrokableParts(dest, options);
        }
    }
    /**
     * return the stroke count required for given options.
     * @param options StrokeOptions that determine count
     */
    computeStrokeCountForOptions(options) {
        let numStroke = 0;
        for (const c of this._path.children) {
            numStroke += c.computeStrokeCountForOptions(options);
        }
        return numStroke;
    }
    /**
     * construct StrokeCountMap for each child, accumulating data to stroke count map for this primitive.
     * @param options StrokeOptions that determine count
     * @param parentStrokeMap evolving parent map.
     */
    computeAndAttachRecursiveStrokeCounts(options, parentStrokeMap) {
        const myMap = StrokeCountMap_1.StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap);
        for (const c of this._path.children) {
            c.computeAndAttachRecursiveStrokeCounts(options, myMap);
        }
        CurvePrimitive_1.CurvePrimitive.installStrokeCountMap(this, myMap, parentStrokeMap);
    }
    /** Second step of double dispatch:  call `this._path.dispatchToGeometryHandler (handler)`
     * * Note that this exposes the children individually to the handler.
     */
    dispatchToGeometryHandler(handler) {
        return this._path.dispatchToGeometryHandler(handler);
    }
    /** Extend (increase) `rangeToExtend` as needed to include these curves (optionally transformed)
     */
    extendRange(rangeToExtend, transform) {
        this._path.extendRange(rangeToExtend, transform);
    }
    /**
     *
     * * Curve length is always positive.
     * @returns Returns a (high accuracy) length of the curve between fractional positions
     * @returns Returns the length of the curve.
     */
    curveLengthBetweenFractions(fraction0, fraction1) {
        return Math.abs(fraction1 - fraction0) * this._totalLength;
    }
    /**
     * Capture (not clone) a path into a new `CurveChainWithDistanceIndex`
     * @param primitives primitive array to be CAPTURED (not cloned)
     */
    static createCapture(path, options) {
        if (path.children.length === 0)
            return undefined;
        const fragments = DistanceIndexConstructionContext.createPathFragmentIndex(path, options);
        const result = new CurveChainWithDistanceIndex(path, fragments);
        return result;
    }
    /**
     * Resolve a fraction of the CurveChain to a PathFragment
     * @param distance
     * @param allowExtrapolation
     */
    chainDistanceToFragment(distance, allowExtrapolation = false) {
        const numFragments = this._fragments.length;
        const fragments = this._fragments;
        if (numFragments > 0) {
            if (distance < 0.0)
                return allowExtrapolation ? fragments[0] : undefined;
            if (distance >= this._totalLength)
                return allowExtrapolation ? fragments[numFragments - 1] : undefined;
            // humbug, linear search
            for (const fragment of fragments) {
                if (fragment.containsChainDistance(distance))
                    return fragment;
            }
        }
        return undefined;
    }
    /**
     * Convert distance along the chain to fraction along the chain.
     * @param distance distance along the chain
     */
    chainDistanceToChainFraction(distance) { return distance / this._totalLength; }
    /**
     * Resolve a fraction within a specific curve to a fragment.
     * @param curve
     * @param fraction
     */
    curveAndChildFractionToFragment(curve, fraction) {
        const numFragments = this._fragments.length;
        const fragments = this._fragments;
        if (numFragments > 0) {
            // humbug, linear search
            for (const fragment of fragments) {
                if (fragment.containsChildCurveAndChildFraction(curve, fraction))
                    return fragment;
            }
            if (fraction <= 0)
                return fragments[0];
            if (fraction > 1.0)
                return fragments[numFragments - 1];
        }
        return undefined;
    }
    /**
     * Returns the total length of curves.
     */
    curveLength() {
        return this._totalLength;
    }
    /**
     * Returns the total length of the path.
     * * This is exact (and simple property lookup) because the true lengths were summed at construction time.
     */
    quickLength() {
        return this._totalLength;
    }
    /**
     * Return the point (x,y,z) on the curve at fractional position along the chain.
     * @param fraction fractional position along the geometry.
     * @returns Returns a point on the curve.
     */
    fractionToPoint(fraction, result) {
        const chainDistance = fraction * this._totalLength;
        let fragment = this.chainDistanceToFragment(chainDistance, true);
        if (fragment) {
            const childFraction = fragment.chainDistanceToAccurateChildFraction(chainDistance);
            return fragment.childCurve.fractionToPoint(childFraction, result);
        }
        fragment = this.chainDistanceToFragment(chainDistance, true);
        return this._fragments[0].childCurve.fractionToPoint(0.0, result);
    }
    /** Return the point (x,y,z) and derivative on the curve at fractional position.
     *
     * * Note that this derivative is "derivative of xyz with respect to fraction."
     * * this derivative shows the speed of the "fractional point" moving along the curve.
     * * this is not generally a unit vector.  use fractionToPointAndUnitTangent for a unit vector.
     * @param fraction fractional position along the geometry.
     * @returns Returns a ray whose origin is the curve point and direction is the derivative with respect to the fraction.
     */
    fractionToPointAndDerivative(fraction, result) {
        const distanceAlongPath = fraction * this._totalLength;
        const fragment = this.chainDistanceToFragment(distanceAlongPath, true);
        const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath);
        result = fragment.childCurve.fractionToPointAndDerivative(curveFraction, result);
        const a = this._totalLength / result.direction.magnitude();
        result.direction.scaleInPlace(a);
        return result;
    }
    /**
     * Returns a ray whose origin is the curve point and direction is the unit tangent.
     * @param fraction fractional position on the curve
     * @param result optional receiver for the result.
     * Returns a ray whose origin is the curve point and direction is the unit tangent.
     */
    fractionToPointAndUnitTangent(fraction, result) {
        const distanceAlongPath = fraction * this._totalLength;
        const fragment = this.chainDistanceToFragment(distanceAlongPath, true);
        const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath);
        result = fragment.childCurve.fractionToPointAndDerivative(curveFraction, result);
        result.direction.normalizeInPlace();
        return result;
    }
    /** Return a plane with
     *
     * * origin at fractional position along the curve
     * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.
     * * vectorV is the second derivative, i.e.derivative of vectorU.
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        const totalLength = this._totalLength;
        const distanceAlongPath = fraction * totalLength;
        const fragment = this.chainDistanceToFragment(distanceAlongPath, true);
        const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath);
        result = fragment.childCurve.fractionToPointAnd2Derivatives(curveFraction, result);
        if (!result)
            return undefined;
        const dotUU = result.vectorU.magnitudeSquared();
        const magU = Math.sqrt(dotUU);
        const dotUV = result.vectorU.dotProduct(result.vectorV);
        const duds = 1.0 / magU;
        const a = duds * duds;
        Point3dVector3d_1.Vector3d.createAdd2Scaled(result.vectorV, a, result.vectorU, -a * dotUV / dotUU, result.vectorV); // IN PLACE update to vectorV.
        result.vectorU.scale(duds);
        // scale for 0..1 parameterization ....
        result.vectorU.scaleInPlace(totalLength);
        result.vectorV.scaleInPlace(totalLength * totalLength);
        return result;
    }
    /** Attempt to transform in place.
     * * Warning: If any child fails, this object becomes invalid.  But that should never happen.
     */
    tryTransformInPlace(transform) {
        let numFail = 0;
        for (const c of this._path.children) {
            if (!c.tryTransformInPlace(transform))
                numFail++;
        }
        return numFail === 0;
    }
    /** Reverse the curve's data so that its fractional stroking moves in the opposite direction. */
    reverseInPlace() {
        this._path.reverseChildrenInPlace();
        const totalLength = this._totalLength;
        for (const fragment of this._fragments)
            fragment.reverseFractionsAndDistances(totalLength);
        for (let i = 0, j = this._fragments.length - 1; i < j; i++, j--) {
            const fragment = this._fragments[i];
            this._fragments[i] = this._fragments[j];
            this._fragments[j] = fragment;
        }
    }
    /**
     * Test for equality conditions:
     * * Mismatched totalLength is a quick exit condition
     * * If totalLength matches, recurse to the path for matching primitives.
     * @param other
     */
    isAlmostEqual(other) {
        if (other instanceof CurveChainWithDistanceIndex) {
            return Geometry_1.Geometry.isSameCoordinate(this._totalLength, other._totalLength)
                && this._path.isAlmostEqual(other._path);
        }
        return false;
    }
    /** Implement moveSignedDistanceFromFraction.
     * * See `CurvePrimitive` for parameter details.
     * * The returned location directly identifies fractional position along the CurveChainWithDistanceIndex, and has pointer to an additional detail for the child curve.
     */
    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {
        const distanceA = startFraction * this._totalLength;
        const distanceB = distanceA + signedDistance;
        const fragmentB = this.chainDistanceToFragment(distanceB, true);
        const childDetail = fragmentB.childCurve.moveSignedDistanceFromFraction(fragmentB.childFraction0, distanceB - fragmentB.chainDistance0, allowExtension, result);
        const endFraction = startFraction + (signedDistance / this._totalLength);
        const chainDetail = CurveLocationDetail_1.CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, endFraction, signedDistance, result);
        chainDetail.childDetail = childDetail;
        return chainDetail;
    }
    /** Search for the curve point that is closest to the spacePoint.
     * * The CurveChainWithDistanceIndex invokes the base class CurvePrimitive method, which
     *     (via a handler) determines a CurveLocation detail among the children.
     * * The returned detail directly identifies fractional position along the CurveChainWithDistanceIndex, and has pointer to an additional detail for the child curve.
     * @param spacePoint point in space
     * @param extend true to extend the curve (NOT USED)
     * @returns Returns a CurveLocationDetail structure that holds the details of the close point.
     */
    closestPoint(spacePoint, extend) {
        // umm... to "extend", would require selective extension of first, last
        let childDetail;
        let aMin = Number.MAX_VALUE;
        const numChildren = this.path.children.length;
        if (numChildren === 1) {
            childDetail = this.path.children[0].closestPoint(spacePoint, extend);
        }
        else {
            const extend0 = [CurveExtendMode_1.CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extend, 0), CurveExtendMode_1.CurveExtendMode.None];
            const extend1 = [CurveExtendMode_1.CurveExtendMode.None, CurveExtendMode_1.CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extend, 1)];
            for (let childIndex = 0; childIndex < numChildren; childIndex++) {
                const child = this.path.children[childIndex];
                const detailA = child.closestPoint(spacePoint, childIndex === 0 ? extend0 : childIndex + 1 === numChildren ? extend1 : false);
                if (detailA && detailA.a < aMin) {
                    aMin = detailA.a;
                    childDetail = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(detailA.curve, detailA.fraction, detailA.point, childDetail);
                    childDetail.a = detailA.a;
                }
            }
        }
        if (!childDetail)
            return undefined;
        const fragment = this.curveAndChildFractionToFragment(childDetail.curve, childDetail.fraction);
        if (fragment) {
            const chainDistance = fragment.childFractionTChainDistance(childDetail.fraction);
            const chainFraction = this.chainDistanceToChainFraction(chainDistance);
            const chainDetail = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(this, chainFraction, childDetail.point);
            chainDetail.childDetail = childDetail;
            return chainDetail;
        }
        return undefined;
    }
}
exports.CurveChainWithDistanceIndex = CurveChainWithDistanceIndex;


/***/ }),

/***/ "./lib/curve/CurveCollection.js":
/*!**************************************!*\
  !*** ./lib/curve/CurveCollection.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const GeometryQuery_1 = __webpack_require__(/*! ./GeometryQuery */ "./lib/curve/GeometryQuery.js");
const CurveProcessor_1 = __webpack_require__(/*! ./CurveProcessor */ "./lib/curve/CurveProcessor.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
// import { SumLengthsContext, GapSearchContext, CountLinearPartsSearchContext, CloneCurvesContext, TransformInPlaceContext } from "./CurveSearches";
/** Algorithmic class: Accumulate maximum gap between adjacent primitives of CurveChain.
 */
class GapSearchContext extends CurveProcessor_1.RecursiveCurveProcessorWithStack {
    constructor() { super(); this.maxGap = 0.0; }
    static maxGap(target) {
        const context = new GapSearchContext();
        target.announceToCurveProcessor(context);
        return context.maxGap;
    }
    announceCurvePrimitive(curve, _indexInParent) {
        if (this._stack.length > 0) {
            const parent = this._stack[this._stack.length - 1];
            if (parent instanceof CurveChain) {
                const chain = parent;
                const nextCurve = chain.cyclicCurvePrimitive(_indexInParent + 1);
                if (curve !== undefined && nextCurve !== undefined) {
                    this.maxGap = Math.max(this.maxGap, curve.endPoint().distance(nextCurve.startPoint()));
                }
            }
        }
    }
}
/** Algorithmic class: Count LineSegment3d and LineString3d primitives.
 */
class CountLinearPartsSearchContext extends CurveProcessor_1.RecursiveCurveProcessorWithStack {
    constructor() {
        super();
        this.numLineSegment = 0;
        this.numLineString = 0;
        this.numOther = 0;
    }
    static hasNonLinearPrimitives(target) {
        const context = new CountLinearPartsSearchContext();
        target.announceToCurveProcessor(context);
        return context.numOther > 0;
    }
    announceCurvePrimitive(curve, _indexInParent) {
        if (curve instanceof LineSegment3d_1.LineSegment3d)
            this.numLineSegment++;
        else if (curve instanceof LineString3d_1.LineString3d)
            this.numLineString++;
        else
            this.numOther++;
    }
}
/** Algorithmic class: Transform curves in place.
 */
class TransformInPlaceContext extends CurveProcessor_1.RecursiveCurveProcessor {
    constructor(transform) { super(); this.numFail = 0; this.numOK = 0; this.transform = transform; }
    static tryTransformInPlace(target, transform) {
        const context = new TransformInPlaceContext(transform);
        target.announceToCurveProcessor(context);
        return context.numFail === 0;
    }
    announceCurvePrimitive(curvePrimitive, _indexInParent) {
        if (!curvePrimitive.tryTransformInPlace(this.transform))
            this.numFail++;
        else
            this.numOK++;
    }
}
/** Algorithmic class: Sum lengths of curves */
class SumLengthsContext extends CurveProcessor_1.RecursiveCurveProcessor {
    constructor() { super(); this._sum = 0.0; }
    static sumLengths(target) {
        const context = new SumLengthsContext();
        target.announceToCurveProcessor(context);
        return context._sum;
    }
    announceCurvePrimitive(curvePrimitive, _indexInParent) {
        this._sum += curvePrimitive.curveLength();
    }
}
/**
 * Algorithmic class for cloning curve collections.
 * * recurse through collection nodes, building image nodes as needed and inserting clones of children.
 * * for individual primitive, invoke doClone (protected) for direct clone; insert into parent
 */
class CloneCurvesContext extends CurveProcessor_1.RecursiveCurveProcessorWithStack {
    constructor(transform) {
        super();
        this._transform = transform;
        this._result = undefined;
    }
    static clone(target, transform) {
        const context = new CloneCurvesContext(transform);
        target.announceToCurveProcessor(context);
        return context._result;
    }
    enter(c) {
        if (c instanceof CurveCollection)
            super.enter(c.cloneEmptyPeer());
    }
    leave() {
        const result = super.leave();
        if (result) {
            if (this._stack.length === 0) // this should only happen once !!!
                this._result = result;
            else // push this result to top of stack.
                this._stack[this._stack.length - 1].tryAddChild(result);
        }
        return result;
    }
    // specialized clone methods override this (and allow announceCurvePrimitive to insert to parent)
    doClone(primitive) {
        if (this._transform)
            return primitive.cloneTransformed(this._transform);
        return primitive.clone();
    }
    announceCurvePrimitive(primitive, _indexInParent) {
        const c = this.doClone(primitive);
        if (c !== undefined && this._stack.length > 0) {
            const parent = this._stack[this._stack.length - 1];
            if (parent instanceof CurveChain || parent instanceof BagOfCurves)
                if (Array.isArray(c)) {
                    for (const c1 of c) {
                        parent.tryAddChild(c1);
                    }
                }
                else {
                    parent.tryAddChild(c);
                }
        }
    }
}
/**
 * Algorithmic class for cloning with linestrings expanded to line segments
 */
class CloneWithExpandedLineStrings extends CloneCurvesContext {
    constructor() {
        // we have no transform ....
        super(undefined);
    }
    // We know we have no transform !!!
    doClone(primitive) {
        if (primitive instanceof LineString3d_1.LineString3d && primitive.numPoints() > 1) {
            const packedPoints = primitive.packedPoints;
            const n = packedPoints.length;
            const segments = [];
            for (let i = 0; i + 1 < n; i++) {
                segments.push(LineSegment3d_1.LineSegment3d.createCapture(packedPoints.getPoint3dAtUncheckedPointIndex(i), packedPoints.getPoint3dAtUncheckedPointIndex(i + 1)));
            }
            return segments;
        }
        return primitive.clone();
    }
    static clone(target) {
        const context = new CloneWithExpandedLineStrings();
        target.announceToCurveProcessor(context);
        return context._result;
    }
}
/**
 * * A `CurveCollection` is an abstract (non-instantiable) class for various sets of curves with particular structures:
 *   * `CurveChain` is a (non-instantiable) intermediate class for a sequence of `CurvePrimitive ` joining head-to-tail.  The two instantiable forms of `CurveChain` are
 *     * `Path` - A chain not required to close, and not enclosing a planar area
 *     * `Loop` - A chain required to close from last to first so that a planar area is enclosed.
 *   * `ParityRegion` -- a collection of coplanar `Loop`s, with "in/out" classification by parity rules
 *   * `UnionRegion` -- a collection of coplanar `Loop`s, with "in/out" classification by union rules
 *   * `BagOfCurves` -- a collection of `AnyCurve` with no implied structure.
 * @public
 */
class CurveCollection extends GeometryQuery_1.GeometryQuery {
    constructor() {
        super(...arguments);
        /** String name for schema properties */
        this.geometryCategory = "curveCollection";
        /* tslint:disable:variable-name no-empty*/
        /**  Flag for inner loop status. Only used by `Loop`. */
        this.isInner = false;
    }
    /** Return the sum of the lengths of all contained curves. */
    sumLengths() { return SumLengthsContext.sumLengths(this); }
    /** return the max gap between adjacent primitives in Path and Loop collections.
     *
     * * In a Path, gaps are computed between consecutive primitives.
     * * In a Loop, gaps are computed between consecutive primitives and between last and first.
     * * gaps are NOT computed between consecutive CurvePrimitives in "unstructured" collections.  The type is "unstructured" so gaps should not be semantically meaningful.
     */
    maxGap() { return GapSearchContext.maxGap(this); }
    /** return true if the curve collection has any primitives other than LineSegment3d and LineString3d  */
    checkForNonLinearPrimitives() { return CountLinearPartsSearchContext.hasNonLinearPrimitives(this); }
    /** Apply transform recursively to children */
    tryTransformInPlace(transform) { return TransformInPlaceContext.tryTransformInPlace(this, transform); }
    /** Return a deep copy. */
    clone() {
        return CloneCurvesContext.clone(this);
    }
    /** Create a deep copy of transformed curves. */
    cloneTransformed(transform) {
        return CloneCurvesContext.clone(this, transform);
    }
    /** Create a deep copy with all linestrings expanded to multiple LineSegment3d. */
    cloneWithExpandedLineStrings() {
        return CloneWithExpandedLineStrings.clone(this);
    }
    /** Recurse through children to collect CurvePrimitive's in flat array. */
    collectCurvePrimitivesGo(results) {
        if (this.children) {
            for (const child of this.children) {
                if (child instanceof CurvePrimitive_1.CurvePrimitive)
                    results.push(child);
                else if (child instanceof CurveCollection)
                    child.collectCurvePrimitivesGo(results);
            }
        }
    }
    /**
     * Return an array containing only the curve primitives.
     * * These are leaf nodes
     * * If there is a CurveChainWithDistanceIndex, that primitive stands as a leaf. (NOT its constituent curves)
     */
    collectCurvePrimitives() {
        const results = [];
        this.collectCurvePrimitivesGo(results);
        return results;
    }
    /** Return true for planar region types:
     * * `Loop`
     * * `ParityRegion`
     * * `UnionRegion`
     */
    get isAnyRegionType() {
        return this.dgnBoundaryType() === 2 || this.dgnBoundaryType() === 5 || this.dgnBoundaryType() === 4;
    }
    /** Return true for a `Path`, i.e. a chain of curves joined head-to-tail
     */
    get isOpenPath() {
        return this.dgnBoundaryType() === 1;
    }
    /** Return true for a single-loop planar region type, i.e. `Loop`.
     * * This is _not- a test for physical closure of a `Path`
     */
    get isClosedPath() {
        return this.dgnBoundaryType() === 2;
    }
    /** Extend (increase) `rangeToExtend` as needed to include these curves (optionally transformed) */
    extendRange(rangeToExtend, transform) {
        const children = this.children;
        if (children) {
            for (const c of children) {
                c.extendRange(rangeToExtend, transform);
            }
        }
    }
    /**
     * * Find any curve primitive in the source.
     * * Evaluate it at a fraction (which by default is an interior fraction)
     * @param source containing `CurvePrimitive` or `CurveCollection`
     * @param fraction fraction to use in `curve.fractionToPoint(fraction)`
     */
    static createCurveLocationDetailOnAnyCurvePrimitive(source, fraction = 0.5) {
        if (!source)
            return undefined;
        if (source instanceof CurvePrimitive_1.CurvePrimitive) {
            return CurveLocationDetail_1.CurveLocationDetail.createCurveEvaluatedFraction(source, fraction);
        }
        else if (source instanceof CurveCollection && source.children !== undefined)
            for (const child of source.children) {
                const detail = this.createCurveLocationDetailOnAnyCurvePrimitive(child, fraction);
                if (detail)
                    return detail;
            }
        return undefined;
    }
}
exports.CurveCollection = CurveCollection;
/** Shared base class for use by both open and closed paths.
 * * A `CurveChain` contains only curvePrimitives.  No other paths, loops, or regions allowed.
 * * A single entry in the chain can in fact contain multiple curve primitives if the entry itself is (for instance) `CurveChainWithDistanceIndex`
 *   which presents itself (through method interface) as a CurvePrimitive with well defined mappings from fraction to xyz, but in fact does all the
 *    calculations over multiple primitives.
 * * The specific derived classes are `Path` and `Loop`
 * * `CurveChain` is an intermediate class.   It is not instantiable on its own.
 * @public
 */
class CurveChain extends CurveCollection {
    constructor() { super(); this._curves = []; }
    /** Return the array of `CurvePrimitive` */
    get children() {
        if (this._curves === undefined)
            this._curves = [];
        return this._curves;
    }
    /**
     * Return curve primitive by index, interpreted cyclically for both Loop and Path
     * @param index index to array
     */
    /**
     * Return the `[index]` curve primitive, using `modulo` to map`index` to the cyclic indexing.
     * * In particular, `-1` is the final curve.
     * @param index cyclic index
     */
    cyclicCurvePrimitive(index) {
        const n = this.children.length;
        if (n === 0)
            return undefined;
        const index2 = Geometry_1.Geometry.modulo(index, n);
        return this.children[index2];
    }
    /** Stroke the chain into a simple xyz array.
     * @param options tolerance parameters controlling the stroking.
     */
    getPackedStrokes(options) {
        const tree = this.cloneStroked(options);
        if (tree instanceof CurveChain) {
            const children = tree.children;
            if (children.length === 1) {
                const ls = children[0];
                if (ls instanceof LineString3d_1.LineString3d)
                    return ls.packedPoints;
            }
        }
        return undefined;
    }
    /** Return a structural clone, with CurvePrimitive objects stroked. */
    cloneStroked(options) {
        const strokes = LineString3d_1.LineString3d.create();
        for (const curve of this.children)
            curve.emitStrokes(strokes, options);
        return strokes;
    }
    /** add a child curve.
     * * Returns false if the given child is not a CurvePrimitive.
     */
    tryAddChild(child) {
        if (child && child instanceof CurvePrimitive_1.CurvePrimitive) {
            this._curves.push(child);
            return true;
        }
        return false;
    }
    /** Return a child by index */
    getChild(i) {
        if (i < this._curves.length)
            return this._curves[i];
        return undefined;
    }
    /** invoke `curve.extendRange(range, transform)` for each child  */
    extendRange(range, transform) {
        for (const curve of this._curves)
            curve.extendRange(range, transform);
    }
    /**
     * Reverse each child curve (in place)
     * Reverse the order of the children in the CurveChain array.
     */
    reverseChildrenInPlace() {
        for (const curve of this._curves)
            curve.reverseInPlace();
        this._curves.reverse();
    }
}
exports.CurveChain = CurveChain;
/**
 * * A `BagOfCurves` object is a collection of `AnyCurve` objects.
 * * A `BagOfCurves` has no implied properties such as being planar.
 * @public
 */
class BagOfCurves extends CurveCollection {
    /** Construct an empty `BagOfCurves` */
    constructor() {
        super();
        /** String name for schema properties */
        this.curveCollectionType = "bagOfCurves";
        this._children = [];
    }
    /** test if `other` is an instance of `BagOfCurves` */
    isSameGeometryClass(other) { return other instanceof BagOfCurves; }
    /** Return the (reference to) array of children */
    get children() { return this._children; }
    /** create with given curves. */
    static create(...data) {
        const result = new BagOfCurves();
        for (const child of data) {
            result.tryAddChild(child);
        }
        return result;
    }
    /** Return the boundary type (0) of a corresponding  MicroStation CurveVector */
    dgnBoundaryType() { return 0; }
    /** invoke `processor.announceBagOfCurves(this, indexInParent);` */
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceBagOfCurves(this, indexInParent);
    }
    /** Clone all children in stroked form. */
    cloneStroked(options) {
        const clone = new BagOfCurves();
        let child;
        for (child of this.children) {
            if (child instanceof CurvePrimitive_1.CurvePrimitive) {
                const ls = LineString3d_1.LineString3d.create();
                child.emitStrokes(ls, options);
                if (ls)
                    clone.children.push(ls);
            }
            else if (child instanceof CurveCollection) {
                const childStrokes = child.cloneStroked(options);
                if (childStrokes)
                    clone.children.push(childStrokes);
            }
        }
        return clone;
    }
    /** Return an empty `BagOfCurves` */
    cloneEmptyPeer() { return new BagOfCurves(); }
    /** Add a child  */
    tryAddChild(child) {
        if (child)
            this._children.push(child);
        return true;
    }
    /** Get a child by index */
    getChild(i) {
        if (i < this._children.length)
            return this._children[i];
        return undefined;
    }
    /** Second step of double dispatch:  call `handler.handleBagOfCurves(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleBagOfCurves(this);
    }
}
exports.BagOfCurves = BagOfCurves;
/**
 * * Options to control method `RegionOps.consolidateAdjacentPrimitives`
 * @public
 */
class ConsolidateAdjacentCurvePrimitivesOptions {
    constructor() {
        /** True to consolidated linear geometry   (e.g. separate LineSegment3d and LineString3d) into LineString3d */
        this.consolidateLinearGeometry = true;
        /** True to consolidate contiguous arcs */
        this.consolidateCompatibleArcs = true;
        /** Tolerance for collapsing identical points */
        this.duplicatePointTolerance = Geometry_1.Geometry.smallMetricDistance;
        /** Tolerance for removing interior colinear points. */
        this.colinearPointTolerance = Geometry_1.Geometry.smallMetricDistance;
    }
}
exports.ConsolidateAdjacentCurvePrimitivesOptions = ConsolidateAdjacentCurvePrimitivesOptions;


/***/ }),

/***/ "./lib/curve/CurveCurve.js":
/*!*********************************!*\
  !*** ./lib/curve/CurveCurve.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurveCurveIntersectXY_1 = __webpack_require__(/*! ./CurveCurveIntersectXY */ "./lib/curve/CurveCurveIntersectXY.js");
const CurveCurveIntersectXYZ_1 = __webpack_require__(/*! ./CurveCurveIntersectXYZ */ "./lib/curve/CurveCurveIntersectXYZ.js");
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
/** @module Curve */
/**
 * `CurveCurve` has static method for various computations that work on a pair of curves or curve collections.
 * @public
 */
class CurveCurve {
    /**
     * Return xy intersections of 2 curves.
     * @param geometryA second geometry
     * @param extendA true to allow geometryA to extend
     * @param geometryB second geometry
     * @param extendB true to allow geometryB to extend
     * @deprecated Use CurveCurve.intersectionXYPairs (..) to get results in preferred directly paired form.
     */
    static intersectionXY(geometryA, extendA, geometryB, extendB) {
        const handler = new CurveCurveIntersectXY_1.CurveCurveIntersectXY(undefined, geometryA, extendA, geometryB, extendB);
        geometryA.dispatchToGeometryHandler(handler);
        return handler.grabResults();
    }
    /**
     * Return xy intersections of 2 curves.
     * @param geometryA second geometry
     * @param extendA true to allow geometryA to extend
     * @param geometryB second geometry
     * @param extendB true to allow geometryB to extend
     */
    static intersectionXYPairs(geometryA, extendA, geometryB, extendB) {
        const handler = new CurveCurveIntersectXY_1.CurveCurveIntersectXY(undefined, geometryA, extendA, geometryB, extendB);
        if (geometryB instanceof CurvePrimitive_1.CurvePrimitive) {
            geometryA.dispatchToGeometryHandler(handler);
        }
        else if (geometryB instanceof CurveCollection_1.CurveCollection) {
            const allCurves = geometryB.collectCurvePrimitives();
            for (const child of allCurves) {
                handler.resetGeometry(geometryA, false, child, false);
                geometryA.dispatchToGeometryHandler(handler);
            }
        }
        return handler.grabPairedResults();
    }
    /**
     * Return xy intersections of 2 projected curves
     * @param geometryA second geometry
     * @param extendA true to allow geometryA to extend
     * @param geometryB second geometry
     * @param extendB true to allow geometryB to extend
     */
    static intersectionProjectedXY(worldToLocal, geometryA, extendA, geometryB, extendB) {
        const handler = new CurveCurveIntersectXY_1.CurveCurveIntersectXY(worldToLocal, geometryA, extendA, geometryB, extendB);
        geometryA.dispatchToGeometryHandler(handler);
        return handler.grabResults();
    }
    /**
     * Return full 3d xyz intersections of 2 curves.
     *  * Implemented for combinations of LineSegment3d, LineString3d, Arc3d.
     *  * Not Implemented for bspline and bezier curves.
     * @beta
     * @param geometryA second geometry
     * @param extendA true to allow geometryA to extend
     * @param geometryB second geometry
     * @param extendB true to allow geometryB to extend
     */
    static intersectionXYZ(geometryA, extendA, geometryB, extendB) {
        const handler = new CurveCurveIntersectXYZ_1.CurveCurveIntersectXYZ(geometryA, extendA, geometryB, extendB);
        geometryA.dispatchToGeometryHandler(handler);
        return handler.grabResults();
    }
}
exports.CurveCurve = CurveCurve;


/***/ }),

/***/ "./lib/curve/CurveCurveIntersectXY.js":
/*!********************************************!*\
  !*** ./lib/curve/CurveCurveIntersectXY.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const GeometryHandler_1 = __webpack_require__(/*! ../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
// import { Arc3d } from "./Arc3d";
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
// import { LineString3d } from "./LineString3d";
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Arc3d_1 = __webpack_require__(/*! ./Arc3d */ "./lib/curve/Arc3d.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const BSplineCurve_1 = __webpack_require__(/*! ../bspline/BSplineCurve */ "./lib/bspline/BSplineCurve.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const Newton_1 = __webpack_require__(/*! ../numerics/Newton */ "./lib/numerics/Newton.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
// cspell:word XYRR
/**
 * * Private class for refining bezier-bezier intersections.
 * * The inputs are assumed pre-transformed so that the target condition is to match x and y coordinates.
 * @public
 */
class BezierBezierIntersectionXYRRToRRD extends Newton_1.NewtonEvaluatorRRtoRRD {
    constructor(curveA, curveB) {
        super();
        this._curveA = curveA;
        this._curveB = curveB;
        this._rayA = Ray3d_1.Ray3d.createZero();
        this._rayB = Ray3d_1.Ray3d.createZero();
    }
    evaluate(fractionA, fractionB) {
        this._curveA.fractionToPointAndDerivative(fractionA, this._rayA);
        this._curveB.fractionToPointAndDerivative(fractionB, this._rayB);
        this.currentF.setOriginAndVectorsXYZ(this._rayB.origin.x - this._rayA.origin.x, this._rayB.origin.y - this._rayA.origin.y, 0.0, -this._rayA.direction.x, -this._rayA.direction.y, 0.0, this._rayB.direction.x, this._rayB.direction.y, 0.0);
        return true;
    }
}
/**
 * Data bundle for a pair of arrays of CurveLocationDetail structures such as produced by CurveCurve,IntersectXY and
 * CurveCurve.ClosestApproach
 * @public
 */
class CurveLocationDetailArrayPair {
    constructor() {
        this.dataA = [];
        this.dataB = [];
    }
}
exports.CurveLocationDetailArrayPair = CurveLocationDetailArrayPair;
/**
 * * Instances are initialized and called from CurveCurve.
 * * Constructor is told two geometry items A and B
 *   * geometryB is saved for later reference
 *   * type-specific handler methods will "see" geometry A repeatedly.
 *   * Hence geometryA is NOT saved by the constructor.
 * @internal
 */
class CurveCurveIntersectXY extends GeometryHandler_1.NullGeometryHandler {
    /**
     * @param worldToLocal optional transform (possibly perspective) to project to xy plane for intersection.
     * @param _geometryA first curve for intersection.  This is NOT saved.
     * @param extendA flag to enable using extension of geometryA.
     * @param geometryB second curve for intersection.  Saved for reference by specific handler methods.
     * @param extendB flag for extension of geometryB.
     */
    constructor(worldToLocal, _geometryA, extendA, geometryB, extendB) {
        super();
        // this.geometryA = _geometryA;
        this._extendA = extendA;
        this._geometryB = geometryB;
        this._extendB = extendB;
        this._worldToLocalPerspective = undefined;
        this._worldToLocalAffine = undefined;
        if (worldToLocal !== undefined && !worldToLocal.isIdentity()) {
            this._worldToLocalAffine = worldToLocal.asTransform;
            if (!this._worldToLocalAffine)
                this._worldToLocalPerspective = worldToLocal.clone();
        }
        this.reinitialize();
    }
    reinitialize() {
        this._results = [];
    }
    /** Reset the geometry flags, leaving all other parts unchanged (and preserving accumulated intersections) */
    resetGeometry(_geometryA, extendA, geometryB, extendB) {
        this._extendA = extendA;
        this._geometryB = geometryB;
        this._extendB = extendB;
    }
    /**
     * * Return the results structure for the intersection calculation, structured as two separate arrays of CurveLocationDetail.
     * @deprecated use `CurveCurveIntersectXY.grabPairedResults` instead of `CurveCurveIntersectXY.grabResults`
     * @param reinitialize if true, a new results structure is created for use by later calls.
     *
     */
    grabResults(reinitialize = false) {
        const resultPairs = this._results;
        if (reinitialize)
            this.reinitialize();
        const oldResult = new CurveLocationDetailArrayPair();
        for (const pair of resultPairs) {
            oldResult.dataA.push(pair.detailA);
            oldResult.dataB.push(pair.detailB);
        }
        return oldResult;
    }
    acceptFraction(extend0, fraction, extend1) {
        if (!extend0 && fraction < 0.0)
            return false;
        if (!extend1 && fraction > 1.0)
            return false;
        return true;
    }
    /**
     * * Return the results structure for the intersection calculation, structured as an array of CurveLocationDetailPair
     * @param reinitialize if true, a new results structure is created for use by later calls.
     *
     */
    grabPairedResults(reinitialize = false) {
        const result = this._results;
        if (reinitialize)
            this.reinitialize();
        return result;
    }
    /** compute intersection of two line segments.
     * filter by extension rules.
     * record with fraction mapping.
     */
    recordPointWithLocalFractions(localFractionA, cpA, fractionA0, fractionA1, localFractionB, // Computed intersection fraction
    cpB, fractionB0, fractionB1, reversed) {
        const globalFractionA = Geometry_1.Geometry.interpolate(fractionA0, localFractionA, fractionA1);
        const globalFractionB = Geometry_1.Geometry.interpolate(fractionB0, localFractionB, fractionB1);
        // ignore duplicate of most recent point .  ..
        const numPrevious = this._results.length;
        if (numPrevious > 0) {
            const topFractionA = this._results[numPrevious - 1].detailA.fraction;
            const topFractionB = this._results[numPrevious - 1].detailB.fraction;
            if (reversed) {
                if (Geometry_1.Geometry.isAlmostEqualNumber(topFractionA, globalFractionB) && Geometry_1.Geometry.isAlmostEqualNumber(topFractionB, globalFractionA))
                    return;
            }
            else {
                if (Geometry_1.Geometry.isAlmostEqualNumber(topFractionA, globalFractionA) && Geometry_1.Geometry.isAlmostEqualNumber(topFractionB, globalFractionB))
                    return;
            }
        }
        const detailA = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(cpA, globalFractionA, cpA.fractionToPoint(globalFractionA));
        detailA.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.isolated);
        const detailB = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(cpB, globalFractionB, cpB.fractionToPoint(globalFractionB));
        detailB.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.isolated);
        if (reversed) {
            this._results.push(new CurveLocationDetail_1.CurveLocationDetailPair(detailB, detailA));
        }
        else {
            this._results.push(new CurveLocationDetail_1.CurveLocationDetailPair(detailA, detailB));
        }
    }
    /** compute intersection of two line segments.
     * filter by extension rules.
     * record with fraction mapping.
     */
    computeSegmentSegment3D(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {
        const uv = CurveCurveIntersectXY._workVector2dA;
        if (Polynomials_1.SmallSystem.lineSegment3dXYTransverseIntersectionUnbounded(pointA0, pointA1, pointB0, pointB1, uv)
            && this.acceptFraction(extendA0, uv.x, extendA1)
            && this.acceptFraction(extendB0, uv.y, extendB1)) {
            this.recordPointWithLocalFractions(uv.x, cpA, fractionA0, fractionA1, uv.y, cpB, fractionB0, fractionB1, reversed);
        }
    }
    // intersection of PROJECTED homogeneous segments ...  assumes caller knows the _worldToLocal is present
    computeSegmentSegment3DH(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {
        const hA0 = CurveCurveIntersectXY._workPointA0H;
        const hA1 = CurveCurveIntersectXY._workPointA1H;
        const hB0 = CurveCurveIntersectXY._workPointB0H;
        const hB1 = CurveCurveIntersectXY._workPointB1H;
        this._worldToLocalPerspective.multiplyPoint3d(pointA0, 1, hA0);
        this._worldToLocalPerspective.multiplyPoint3d(pointA1, 1, hA1);
        this._worldToLocalPerspective.multiplyPoint3d(pointB0, 1, hB0);
        this._worldToLocalPerspective.multiplyPoint3d(pointB1, 1, hB1);
        const fractionAB = Polynomials_1.SmallSystem.lineSegment3dHXYTransverseIntersectionUnbounded(hA0, hA1, hB0, hB1);
        if (fractionAB !== undefined) {
            const fractionA = fractionAB.x;
            const fractionB = fractionAB.y;
            if (this.acceptFraction(extendA0, fractionA, extendA1) && this.acceptFraction(extendB0, fractionB, extendB1)) {
                // final fraction acceptance uses original world points, with perspective-aware fractions
                this.recordPointWithLocalFractions(fractionA, cpA, fractionA0, fractionA1, fractionB, cpB, fractionB0, fractionB1, reversed);
            }
        }
    }
    // Caller accesses data from a line segment and passes to here.
    // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.  The fraction and extend parameters
    // allow all combinations to be passed in)
    // This method applies transform.
    dispatchSegmentSegment(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {
        if (this._worldToLocalAffine) {
            // non-perspective projection
            CurveCurveIntersectXY.setTransformedWorkPoints(this._worldToLocalAffine, pointA0, pointA1, pointB0, pointB1);
            this.computeSegmentSegment3D(cpA, extendA0, CurveCurveIntersectXY._workPointA0, fractionA0, CurveCurveIntersectXY._workPointA1, fractionA1, extendA1, cpB, extendB0, CurveCurveIntersectXY._workPointB0, fractionB0, CurveCurveIntersectXY._workPointB1, fractionB1, extendB1, reversed);
        }
        else if (this._worldToLocalPerspective) {
            this.computeSegmentSegment3DH(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed);
        }
        else {
            this.computeSegmentSegment3D(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed);
        }
    }
    // Caller accesses data from a linestring or segment and passes it here.
    // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.  The fraction and extend parameters
    // allow all combinations to be passed in)
    dispatchSegmentArc(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, arc, extendB0, extendB1, reversed) {
        // Arc: X = C + cU + sV
        // Line:  contains points A0,A1
        // Arc point colinear with line if det (A0, A1, X) = 0
        // with homogeneous xyw points and vectors.
        // With equational X:   det (A0, A1, C) + c det (A0, A1,U) + s det (A0, A1, V) = 0.
        // solve for theta.
        // evaluate points.
        // project back to line.
        if (this._worldToLocalPerspective) {
            const data = arc.toTransformedPoint4d(this._worldToLocalPerspective);
            const pointA0H = this._worldToLocalPerspective.multiplyPoint3d(pointA0, 1);
            const pointA1H = this._worldToLocalPerspective.multiplyPoint3d(pointA1, 1);
            const alpha = Geometry_1.Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.center);
            const beta = Geometry_1.Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.vector0);
            const gamma = Geometry_1.Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.vector90);
            const cosines = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const sines = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const radians = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const numRoots = Polynomials_1.AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosines, sines, radians);
            for (let i = 0; i < numRoots; i++) {
                const arcPoint = data.center.plus2Scaled(data.vector0, cosines.atUncheckedIndex(i), data.vector90, sines.atUncheckedIndex(i));
                const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.atUncheckedIndex(i));
                const lineFraction = Polynomials_1.SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, arcPoint);
                if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB0, arcFraction, extendB1)) {
                    this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, arcFraction, arc, 0, 1, reversed);
                }
            }
        }
        else {
            const data = arc.toTransformedVectors(this._worldToLocalAffine);
            let pointA0Local = pointA0;
            let pointA1Local = pointA1;
            if (this._worldToLocalAffine) {
                pointA0Local = this._worldToLocalAffine.multiplyPoint3d(pointA0);
                pointA1Local = this._worldToLocalAffine.multiplyPoint3d(pointA1);
            }
            const alpha = Geometry_1.Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.center, 1);
            const beta = Geometry_1.Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector0, 0);
            const gamma = Geometry_1.Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector90, 0);
            const cosines = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const sines = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const radians = new GrowableFloat64Array_1.GrowableFloat64Array(2);
            const numRoots = Polynomials_1.AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosines, sines, radians);
            for (let i = 0; i < numRoots; i++) {
                const arcPoint = data.center.plus2Scaled(data.vector0, cosines.atUncheckedIndex(i), data.vector90, sines.atUncheckedIndex(i));
                const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.atUncheckedIndex(i));
                const lineFraction = Polynomials_1.SmallSystem.lineSegment3dXYClosestPointUnbounded(pointA0Local, pointA1Local, arcPoint);
                if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB0, arcFraction, extendB1)) {
                    this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, arcFraction, arc, 0, 1, reversed);
                }
            }
        }
    }
    // Caller accesses data from two arcs.
    // each matrix has [U V C] in (x,y,w) form from projection.
    // invert the projection matrix matrixA.
    // apply the inverse to matrixB. Then arc b is an ellipse in the circular space of A
    dispatchArcArcThisOrder(cpA, matrixA, // homogeneous xyw projection !!!
    extendA, cpB, matrixB, // homogeneous xyw projection !!!
    extendB, reversed) {
        const inverseA = matrixA.inverse();
        if (inverseA) {
            const localB = inverseA.multiplyMatrixMatrix(matrixB);
            const ellipseRadians = [];
            const circleRadians = [];
            Polynomials_1.TrigPolynomial.solveUnitCircleHomogeneousEllipseIntersection(localB.coffs[2], localB.coffs[5], localB.coffs[8], // center xyw
            localB.coffs[0], localB.coffs[3], localB.coffs[6], // center xyw
            localB.coffs[1], localB.coffs[4], localB.coffs[7], // center xyw
            ellipseRadians, circleRadians);
            for (let i = 0; i < ellipseRadians.length; i++) {
                const fractionA = cpA.sweep.radiansToSignedPeriodicFraction(circleRadians[i]);
                const fractionB = cpB.sweep.radiansToSignedPeriodicFraction(ellipseRadians[i]);
                // hm .. do we really need to check the fractions?  We know they are internal to the beziers
                if (this.acceptFraction(extendA, fractionA, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {
                    this.recordPointWithLocalFractions(fractionA, cpA, 0, 1, fractionB, cpB, 0, 1, reversed);
                }
            }
        }
    }
    // Caller accesses data from two arcs.
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchArcArc(cpA, extendA, cpB, extendB, reversed) {
        // Arc: X = C + cU + sV
        // Line:  contains points A0,A1
        // Arc point colinear with line if det (A0, A1, X) = 0
        // with homogeneous xyw points and vectors.
        // With equational X:   det (A0, A1, C) + c det (A0, A1,U) + s det (A0, A1, V) = 0.
        // solve for theta.
        // evaluate points.
        // project back to line.
        let matrixA;
        let matrixB;
        if (this._worldToLocalPerspective) {
            const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);
            const dataB = cpB.toTransformedPoint4d(this._worldToLocalPerspective);
            matrixA = Matrix3d_1.Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);
            matrixB = Matrix3d_1.Matrix3d.createColumnsXYW(dataB.vector0, dataB.vector0.w, dataB.vector90, dataA.vector90.w, dataB.center, dataB.center.w);
        }
        else {
            const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);
            const dataB = cpB.toTransformedVectors(this._worldToLocalAffine);
            matrixA = Matrix3d_1.Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);
            matrixB = Matrix3d_1.Matrix3d.createColumnsXYW(dataB.vector0, 0, dataB.vector90, 0, dataB.center, 1);
        }
        const conditionA = matrixA.conditionNumber();
        const conditionB = matrixB.conditionNumber();
        if (conditionA > conditionB)
            this.dispatchArcArcThisOrder(cpA, matrixA, extendA, cpB, matrixB, extendB, reversed);
        else
            this.dispatchArcArcThisOrder(cpB, matrixB, extendB, cpA, matrixA, extendA, !reversed);
    }
    // Caller accesses data from two arcs.
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchArcBsplineCurve3d(cpA, extendA, cpB, extendB, reversed) {
        // Arc: X = C + cU + sV
        // implicitize the arc as viewed.  This "3d" matrix is homogeneous "XYW" not "xyz"
        let matrixA;
        if (this._worldToLocalPerspective) {
            const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);
            matrixA = Matrix3d_1.Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);
        }
        else {
            const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);
            matrixA = Matrix3d_1.Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);
        }
        // The worldToLocal has moved the arc vectors into screen space.
        // matrixA captures the xyw parts (ignoring z)
        // for any point in world space,
        // THIS CODE ONLY WORKS FOR
        const matrixAInverse = matrixA.inverse();
        if (matrixAInverse) {
            const orderF = cpB.order; // order of the beziers for simple coordinates
            const orderG = 2 * orderF - 1; // order of the (single) bezier for squared coordinates.
            const coffF = new Float64Array(orderF);
            const univariateBezierG = new BezierPolynomials_1.UnivariateBezier(orderG);
            const axx = matrixAInverse.at(0, 0);
            const axy = matrixAInverse.at(0, 1);
            const axz = 0.0;
            const axw = matrixAInverse.at(0, 2);
            const ayx = matrixAInverse.at(1, 0);
            const ayy = matrixAInverse.at(1, 1);
            const ayz = 0.0;
            const ayw = matrixAInverse.at(1, 2);
            const awx = matrixAInverse.at(2, 0);
            const awy = matrixAInverse.at(2, 1);
            const awz = 0.0;
            const aww = matrixAInverse.at(2, 2);
            if (matrixAInverse) {
                let bezier;
                for (let spanIndex = 0;; spanIndex++) {
                    bezier = cpB.getSaturatedBezierSpan3dH(spanIndex, bezier);
                    if (!bezier)
                        break;
                    if (this._worldToLocalPerspective)
                        bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);
                    else if (this._worldToLocalAffine)
                        bezier.tryTransformInPlace(this._worldToLocalAffine);
                    univariateBezierG.zero();
                    bezier.poleProductsXYZW(coffF, axx, axy, axz, axw);
                    univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);
                    bezier.poleProductsXYZW(coffF, ayx, ayy, ayz, ayw);
                    univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);
                    bezier.poleProductsXYZW(coffF, awx, awy, awz, aww);
                    univariateBezierG.addSquaredSquaredBezier(coffF, -1.0);
                    const roots = univariateBezierG.roots(0.0, true);
                    if (roots) {
                        for (const root of roots) {
                            const fractionB = bezier.fractionToParentFraction(root);
                            // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space
                            const bcurvePoint4d = bezier.fractionToPoint4d(root);
                            const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);
                            const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);
                            const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));
                            if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {
                                this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1, fractionB, cpB, 0, 1, reversed);
                            }
                        }
                    }
                }
            }
        }
    }
    /** apply the transformation to bezier curves. optionally construct ranges.
     *
     */
    transformBeziers(beziers) {
        if (this._worldToLocalAffine) {
            for (const bezier of beziers)
                bezier.tryTransformInPlace(this._worldToLocalAffine);
        }
        else if (this._worldToLocalPerspective) {
            for (const bezier of beziers)
                bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);
        }
    }
    getRanges(beziers) {
        const ranges = [];
        ranges.length = 0;
        for (const b of beziers) {
            ranges.push(b.range());
        }
        return ranges;
    }
    dispatchBezierBezierStrokeFirst(bezierA, bcurveA, strokeCountA, bezierB, bcurveB, _strokeCountB, univariateBezierB, // caller-allocated for univariate coefficients.
    reversed) {
        if (!this._xyzwA0)
            this._xyzwA0 = Point4d_1.Point4d.create();
        if (!this._xyzwA1)
            this._xyzwA1 = Point4d_1.Point4d.create();
        if (!this._xyzwPlane)
            this._xyzwPlane = Point4d_1.Point4d.create();
        if (!this._xyzwB)
            this._xyzwB = Point4d_1.Point4d.create();
        /*
    
                  const roots = univariateBezierG.roots(0.0, true);
                  if (roots) {
                    for (const root of roots) {
                      const fractionB = bezier.fractionToParentFraction(root);
                      // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space
                      const bcurvePoint4d = bezier.fractionToPoint4d(root);
                      const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);
                      const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);
                      const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));
                      if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {
                        this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,
                          fractionB, cpB, 0, 1, reversed);
                      }
                    }
        */
        bezierA.fractionToPoint4d(0.0, this._xyzwA0);
        let f0 = 0.0;
        let f1 = 1.0;
        const intervalTolerance = 1.0e-5;
        const df = 1.0 / strokeCountA;
        for (let i = 1; i <= strokeCountA; i++, f0 = f1, this._xyzwA0.setFrom(this._xyzwA1)) {
            f1 = i * df;
            bezierA.fractionToPoint4d(f1, this._xyzwA1);
            Point4d_1.Point4d.createPlanePointPointZ(this._xyzwA0, this._xyzwA1, this._xyzwPlane);
            bezierB.poleProductsXYZW(univariateBezierB.coffs, this._xyzwPlane.x, this._xyzwPlane.y, this._xyzwPlane.z, this._xyzwPlane.w);
            let errors = 0;
            const roots = univariateBezierB.roots(0.0, true);
            if (roots)
                for (const r of roots) {
                    let bezierBFraction = r;
                    bezierB.fractionToPoint4d(bezierBFraction, this._xyzwB);
                    const segmentAFraction = Polynomials_1.SmallSystem.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0, this._xyzwA1, this._xyzwB);
                    if (segmentAFraction && Geometry_1.Geometry.isIn01WithTolerance(segmentAFraction, intervalTolerance)) {
                        let bezierAFraction = Geometry_1.Geometry.interpolate(f0, segmentAFraction, f1);
                        const xyMatchingFunction = new BezierBezierIntersectionXYRRToRRD(bezierA, bezierB);
                        const newtonSearcher = new Newton_1.Newton2dUnboundedWithDerivative(xyMatchingFunction);
                        newtonSearcher.setUV(bezierAFraction, bezierBFraction);
                        if (newtonSearcher.runIterations()) {
                            bezierAFraction = newtonSearcher.getU();
                            bezierBFraction = newtonSearcher.getV();
                        }
                        // We have a near intersection at fractions on the two beziers !!!
                        // Iterate on the curves for a true intersection ....
                        // NEEDS WORK -- just accept . . .
                        const bcurveAFraction = bezierA.fractionToParentFraction(bezierAFraction);
                        const bcurveBFraction = bezierB.fractionToParentFraction(bezierBFraction);
                        const xyzA0 = bezierA.fractionToPoint(bezierAFraction);
                        const xyzA1 = bcurveA.fractionToPoint(bcurveAFraction);
                        const xyzB0 = bezierB.fractionToPoint(bezierBFraction);
                        const xyzB1 = bcurveB.fractionToPoint(bcurveBFraction);
                        if (!xyzA0.isAlmostEqualXY(xyzA1))
                            errors++;
                        if (!xyzB0.isAlmostEqualXY(xyzB1))
                            errors++;
                        if (errors > 0 && !xyzA0.isAlmostEqual(xyzB0))
                            errors++;
                        if (errors > 0 && !xyzA1.isAlmostEqual(xyzB1))
                            errors++;
                        if (this.acceptFraction(false, bcurveAFraction, false) && this.acceptFraction(false, bcurveBFraction, false)) {
                            this.recordPointWithLocalFractions(bcurveAFraction, bcurveA, 0, 1, bcurveBFraction, bcurveB, 0, 1, reversed);
                        }
                    }
                }
        }
    }
    // Caller accesses data from two arcs.
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchBSplineCurve3dBSplineCurve3d(bcurveA, bcurveB, _reversed) {
        const bezierSpanA = bcurveA.collectBezierSpans(true);
        const bezierSpanB = bcurveB.collectBezierSpans(true);
        const numA = bezierSpanA.length;
        const numB = bezierSpanB.length;
        this.transformBeziers(bezierSpanA);
        this.transformBeziers(bezierSpanB);
        const rangeA = this.getRanges(bezierSpanA);
        const rangeB = this.getRanges(bezierSpanB);
        const orderA = bcurveA.order;
        const orderB = bcurveB.order;
        const univariateCoffsA = new BezierPolynomials_1.UnivariateBezier(orderA);
        const univariateCoffsB = new BezierPolynomials_1.UnivariateBezier(orderB);
        for (let a = 0; a < numA; a++) {
            for (let b = 0; b < numB; b++) {
                if (rangeA[a].intersectsRangeXY(rangeB[b])) {
                    const strokeCountA = bezierSpanA[a].computeStrokeCountForOptions();
                    const strokeCountB = bezierSpanB[b].computeStrokeCountForOptions();
                    if (strokeCountA < strokeCountB)
                        this.dispatchBezierBezierStrokeFirst(bezierSpanA[a], bcurveA, strokeCountA, bezierSpanB[b], bcurveB, strokeCountB, univariateCoffsB, !_reversed);
                    else
                        this.dispatchBezierBezierStrokeFirst(bezierSpanB[b], bcurveB, strokeCountB, bezierSpanA[a], bcurveA, strokeCountA, univariateCoffsA, _reversed);
                }
            }
        }
    }
    /**
     * Apply the projection transform (if any) to (xyz, w)
     * @param xyz xyz parts of input point.
     * @param w   weight to use for homogeneous effects
     */
    projectPoint(xyz, w = 1.0) {
        if (this._worldToLocalPerspective)
            return this._worldToLocalPerspective.multiplyPoint3d(xyz, w);
        if (this._worldToLocalAffine)
            return this._worldToLocalAffine.multiplyXYZW(xyz.x, xyz.y, xyz.z, w);
        return Point4d_1.Point4d.createFromPointAndWeight(xyz, w);
    }
    mapNPCPlaneToWorld(npcPlane, worldPlane) {
        // for NPC pointY, Y^ * H = 0 is "on" plane H.  (Hat is transpose)
        // NPC Y is A*X for our transform A and worldPointX.
        // hence (A X)^ * H = 0
        // hence X^ * A^ * H = 0
        // hence K = A^ * H
        if (this._worldToLocalAffine) {
            this._worldToLocalAffine.multiplyTransposeXYZW(npcPlane.x, npcPlane.y, npcPlane.z, npcPlane.w, worldPlane);
        }
        else if (this._worldToLocalPerspective) {
            this._worldToLocalPerspective.multiplyTransposePoint4d(npcPlane, worldPlane);
        }
        else {
            npcPlane.clone(worldPlane);
        }
    }
    // Caller accesses data from segment and bsplineCurve
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchSegmentBsplineCurve(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, bcurve, extendB, reversed) {
        const pointA0H = this.projectPoint(pointA0);
        const pointA1H = this.projectPoint(pointA1);
        const planeCoffs = Point4d_1.Point4d.createPlanePointPointZ(pointA0H, pointA1H);
        this.mapNPCPlaneToWorld(planeCoffs, planeCoffs);
        // NOW .. we have a plane in world space.  Intersect it with the bspline:
        const intersections = [];
        bcurve.appendPlaneIntersectionPoints(planeCoffs, intersections);
        // intersections has WORLD points with bspline fractions.   (The bspline fractions are all good 0..1 fractions within the spline.)
        // accept those that are within the segment range.
        for (const detail of intersections) {
            const fractionB = detail.fraction;
            const curvePoint = detail.point;
            const curvePointH = this.projectPoint(curvePoint);
            const lineFraction = Polynomials_1.SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, curvePointH);
            if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB, fractionB, extendB)) {
                this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, fractionB, bcurve, 0, 1, reversed);
            }
        }
    }
    /** low level dispatch of linestring with (beziers of) a bspline curve */
    dispatchLineStringBSplineCurve(lsA, extendA, curveB, extendB, reversed) {
        const numA = lsA.numPoints();
        if (numA > 1) {
            const dfA = 1.0 / (numA - 1);
            let fA0;
            let fA1;
            fA0 = 0.0;
            const pointA0 = CurveCurveIntersectXY._workPointA0;
            const pointA1 = CurveCurveIntersectXY._workPointA1;
            lsA.pointAt(0, pointA0);
            for (let iA = 1; iA < numA; iA++, pointA0.setFrom(pointA1), fA0 = fA1) {
                lsA.pointAt(iA, pointA1);
                fA1 = iA * dfA;
                this.dispatchSegmentBsplineCurve(lsA, iA === 1 && extendA, pointA0, fA0, pointA1, fA1, (iA + 1) === numA && extendA, curveB, extendB, reversed);
            }
        }
        return undefined;
    }
    /** Detail computation for segment intersecting linestring. */
    computeSegmentLineString(lsA, extendA, lsB, extendB, reversed) {
        const pointA0 = lsA.point0Ref;
        const pointA1 = lsA.point1Ref;
        const pointB0 = CurveCurveIntersectXY._workPointBB0;
        const pointB1 = CurveCurveIntersectXY._workPointBB1;
        const numB = lsB.numPoints();
        if (numB > 1) {
            const dfB = 1.0 / (numB - 1);
            let fB0;
            let fB1;
            fB0 = 0.0;
            lsB.pointAt(0, pointB0);
            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                lsB.pointAt(ib, pointB1);
                fB1 = ib * dfB;
                this.dispatchSegmentSegment(lsA, extendA, pointA0, 0.0, pointA1, 1.0, extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, reversed);
            }
        }
        return undefined;
    }
    /** Detail computation for arcA intersecting lsB. */
    computeArcLineString(arcA, extendA, lsB, extendB, reversed) {
        const pointB0 = CurveCurveIntersectXY._workPointBB0;
        const pointB1 = CurveCurveIntersectXY._workPointBB1;
        const numB = lsB.numPoints();
        if (numB > 1) {
            const dfB = 1.0 / (numB - 1);
            let fB0;
            let fB1;
            fB0 = 0.0;
            lsB.pointAt(0, pointB0);
            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                lsB.pointAt(ib, pointB1);
                fB1 = ib * dfB;
                this.dispatchSegmentArc(lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, arcA, extendA, extendA, !reversed);
            }
        }
        return undefined;
    }
    static setTransformedWorkPoints(transform, pointA0, pointA1, pointB0, pointB1) {
        transform.multiplyPoint3d(pointA0, this._workPointA0);
        transform.multiplyPoint3d(pointA1, this._workPointA1);
        transform.multiplyPoint3d(pointB0, this._workPointB0);
        transform.multiplyPoint3d(pointB1, this._workPointB1);
    }
    /** double dispatch handler for strongly typed segment.. */
    handleLineSegment3d(segmentA) {
        if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            const segmentB = this._geometryB;
            this.dispatchSegmentSegment(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, segmentB, this._extendB, segmentB.point0Ref, 0.0, segmentB.point1Ref, 1.0, this._extendB, false);
        }
        else if (this._geometryB instanceof LineString3d_1.LineString3d) {
            this.computeSegmentLineString(segmentA, this._extendA, this._geometryB, this._extendB, false);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.dispatchSegmentArc(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, this._geometryB, this._extendB, this._extendB, false);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3d) {
            this.dispatchSegmentBsplineCurve(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, this._geometryB, this._extendB, false);
        }
    }
    /** double dispatch handler for strongly typed linestring.. */
    handleLineString3d(lsA) {
        if (this._geometryB instanceof LineString3d_1.LineString3d) {
            const lsB = this._geometryB;
            const pointA0 = CurveCurveIntersectXY._workPointAA0;
            const pointA1 = CurveCurveIntersectXY._workPointAA1;
            const pointB0 = CurveCurveIntersectXY._workPointBB0;
            const pointB1 = CurveCurveIntersectXY._workPointBB1;
            const numA = lsA.numPoints();
            const numB = lsB.numPoints();
            if (numA > 1 && numB > 1) {
                lsA.pointAt(0, pointA0);
                const dfA = 1.0 / (numA - 1);
                const dfB = 1.0 / (numB - 1);
                let fA0 = 0.0;
                let fB0;
                let fA1;
                let fB1;
                const extendA = this._extendA;
                const extendB = this._extendB;
                lsA.pointAt(0, pointA0);
                for (let ia = 1; ia < numA; ia++, pointA0.setFrom(pointA1), fA0 = fA1) {
                    fA1 = ia * dfA;
                    fB0 = 0.0;
                    lsA.pointAt(ia, pointA1);
                    lsB.pointAt(0, pointB0);
                    for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                        lsB.pointAt(ib, pointB1);
                        fB1 = ib * dfB;
                        this.dispatchSegmentSegment(lsA, ia === 1 && extendA, pointA0, fA0, pointA1, fA1, (ia + 1) === numA && extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, false);
                    }
                }
            }
        }
        else if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            this.computeSegmentLineString(this._geometryB, this._extendB, lsA, this._extendA, true);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.computeArcLineString(this._geometryB, this._extendB, lsA, this._extendA, true);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3d) {
            this.dispatchLineStringBSplineCurve(lsA, this._extendA, this._geometryB, this._extendB, false);
        }
        return undefined;
    }
    /** double dispatch handler for strongly typed arc .. */
    handleArc3d(arc0) {
        if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            this.dispatchSegmentArc(this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB, arc0, this._extendA, this._extendA, true);
        }
        else if (this._geometryB instanceof LineString3d_1.LineString3d) {
            this.computeArcLineString(arc0, this._extendA, this._geometryB, this._extendB, false);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.dispatchArcArc(arc0, this._extendA, this._geometryB, this._extendB, false);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3d) {
            this.dispatchArcBsplineCurve3d(arc0, this._extendA, this._geometryB, this._extendB, false);
        }
        return undefined;
    }
    /** double dispatch handler for strongly typed bspline curve .. */
    handleBSplineCurve3d(curve) {
        if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            this.dispatchSegmentBsplineCurve(this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB, curve, this._extendA, true);
        }
        else if (this._geometryB instanceof LineString3d_1.LineString3d) {
            this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3dBase) {
            this.dispatchBSplineCurve3dBSplineCurve3d(curve, this._geometryB, false);
        }
        return undefined;
    }
    /** double dispatch handler for strongly typed homogeneous bspline curve .. */
    handleBSplineCurve3dH(_curve) {
        /* NEEDS WORK -- make "dispatch" methods tolerant of both 3d and 3dH ..."easy" if both present BezierCurve3dH span loaders
        if (this._geometryB instanceof LineSegment3d) {
          this.dispatchSegmentBsplineCurve(
            this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,
            curve, this._extendA, true);
        } else if (this._geometryB instanceof LineString3d) {
          this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);
        } else if (this._geometryB instanceof Arc3d) {
          this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);
        }
        */
        return undefined;
    }
}
exports.CurveCurveIntersectXY = CurveCurveIntersectXY;
CurveCurveIntersectXY._workVector2dA = Point2dVector2d_1.Vector2d.create();
CurveCurveIntersectXY._workPointA0H = Point4d_1.Point4d.create();
CurveCurveIntersectXY._workPointA1H = Point4d_1.Point4d.create();
CurveCurveIntersectXY._workPointB0H = Point4d_1.Point4d.create();
CurveCurveIntersectXY._workPointB1H = Point4d_1.Point4d.create();
CurveCurveIntersectXY._workPointAA0 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointAA1 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointBB0 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointBB1 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointA0 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointA1 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointB0 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXY._workPointB1 = Point3dVector3d_1.Point3d.create();


/***/ }),

/***/ "./lib/curve/CurveCurveIntersectXYZ.js":
/*!*********************************************!*\
  !*** ./lib/curve/CurveCurveIntersectXYZ.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const GeometryHandler_1 = __webpack_require__(/*! ../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
// import { Arc3d } from "./Arc3d";
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
// import { XYAndZ } from "../geometry3d/XYZProps";
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
// import { LineString3d } from "./LineString3d";
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
// import { Point4d } from "../geometry4d/Point4d";
// import { Transform } from "../geometry3d/Transform";
// import { Matrix3d } from "../geometry3d/Matrix3d";
const Arc3d_1 = __webpack_require__(/*! ./Arc3d */ "./lib/curve/Arc3d.js");
const BSplineCurve_1 = __webpack_require__(/*! ../bspline/BSplineCurve */ "./lib/bspline/BSplineCurve.js");
// import { Range3d } from "../geometry3d/Range";
const CurveCurveIntersectXY_1 = __webpack_require__(/*! ./CurveCurveIntersectXY */ "./lib/curve/CurveCurveIntersectXY.js");
const Plane3dByOriginAndUnitNormal_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndUnitNormal */ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js");
// cspell:word XYRR
/**
 * * Handler class for XYZ intersections.
 * * Instances are initialized and called from CurveCurve.
 * * Constructor is told two geometry items A and B
 *   * geometryB is saved for later reference
 *   * type-specific handler methods will "see" geometry A repeatedly.
 *   * Hence geometryA is NOT saved by the constructor.
 * @internal
 */
class CurveCurveIntersectXYZ extends GeometryHandler_1.NullGeometryHandler {
    /**
     *
     * @param _geometryA first curve for intersection.  This is NOT saved.
     * @param extendA flag to enable using extension of geometryA.
     * @param geometryB second curve for intersection.  Saved for reference by specific handler methods.
     * @param extendB flag for extension of geometryB.
     */
    constructor(_geometryA, extendA, geometryB, extendB) {
        super();
        // this.geometryA = _geometryA;
        this._extendA = extendA;
        this._geometryB = geometryB;
        this._extendB = extendB;
        this.reinitialize();
    }
    reinitialize() {
        this._results = new CurveCurveIntersectXY_1.CurveLocationDetailArrayPair();
    }
    /**
     * * Return the results structure for the intersection calculation.
     * @param reinitialize if true, a new results structure is created for use by later calls.
     *
     */
    grabResults(reinitialize = false) {
        const result = this._results;
        if (reinitialize)
            this.reinitialize();
        return result;
    }
    acceptFraction(extend0, fraction, extend1) {
        if (!extend0 && fraction < 0.0)
            return false;
        if (!extend1 && fraction > 1.0)
            return false;
        return true;
    }
    /** compute intersection of two line segments.
     * filter by extension rules.
     * reject if evaluated points do not match coordinates (e.g. close approach point)
     * record with fraction mapping.
     */
    recordPointWithLocalFractions(localFractionA, cpA, fractionA0, fractionA1, localFractionB, // Computed intersection fraction
    cpB, fractionB0, fractionB1, reversed) {
        const globalFractionA = Geometry_1.Geometry.interpolate(fractionA0, localFractionA, fractionA1);
        const globalFractionB = Geometry_1.Geometry.interpolate(fractionB0, localFractionB, fractionB1);
        // ignore duplicate of most recent point .  ..
        const numPrevious = this._results.dataA.length;
        if (numPrevious > 0) {
            const topFractionA = this._results.dataA[numPrevious - 1].fraction;
            const topFractionB = this._results.dataB[numPrevious - 1].fraction;
            if (reversed) {
                if (Geometry_1.Geometry.isAlmostEqualNumber(topFractionA, globalFractionB) && Geometry_1.Geometry.isAlmostEqualNumber(topFractionB, globalFractionA))
                    return;
            }
            else {
                if (Geometry_1.Geometry.isAlmostEqualNumber(topFractionA, globalFractionA) && Geometry_1.Geometry.isAlmostEqualNumber(topFractionB, globalFractionB))
                    return;
            }
        }
        const pointA = cpA.fractionToPoint(globalFractionA);
        const pointB = cpB.fractionToPoint(globalFractionB);
        if (!pointA.isAlmostEqualMetric(pointB))
            return;
        const detailA = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(cpA, globalFractionA, pointA);
        detailA.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.isolated);
        const detailB = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(cpB, globalFractionB, pointB);
        detailB.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.isolated);
        if (reversed) {
            this._results.dataA.push(detailB);
            this._results.dataB.push(detailA);
        }
        else {
            this._results.dataA.push(detailA);
            this._results.dataB.push(detailB);
        }
    }
    /** compute intersection of two line segments.
     * filter by extension rules.
     * record with fraction mapping.
     */
    computeSegmentSegment3D(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {
        const uv = CurveCurveIntersectXYZ._workVector2dA;
        if (Polynomials_1.SmallSystem.lineSegment3dClosestApproachUnbounded(pointA0, pointA1, pointB0, pointB1, uv)
            && this.acceptFraction(extendA0, uv.x, extendA1)
            && this.acceptFraction(extendB0, uv.y, extendB1)) {
            this.recordPointWithLocalFractions(uv.x, cpA, fractionA0, fractionA1, uv.y, cpB, fractionB0, fractionB1, reversed);
        }
    }
    // Caller accesses data from a line segment and passes to here.
    // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.  The fraction and extend parameters
    // allow all combinations to be passed in)
    // This method applies transform.
    dispatchSegmentSegment(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed) {
        this.computeSegmentSegment3D(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1, reversed);
    }
    /**
     * Create a plane whose normal is a "better" cross product as a choice of `vectorA cross vectorB` or `vectorA cross vectorC`
     * * The heuristic for "better" is:
     *   * first choice is cross product with `vectorB`.  Use it if the cosine of the angel from vectorA to vectorB is less than cosineValue.
     *   * otherwise use vectorC
     * @param origin plane origin
     * @param vectorA vector which must be in the plane.
     * @param cosineValue typically cosine of something near 90 degrees.
     * @param vectorB first candidate for additional in-plane vector
     * @param vectorC second candidate for additional in-plane vector
     */
    createPlaneWithPreferredPerpendicular(origin, vectorA, cosineValue, vectorB, vectorC) {
        const dotAA = vectorA.magnitudeSquared();
        const dotBB = vectorB.magnitudeSquared();
        const dotAB = Math.abs(vectorA.dotProduct(vectorB));
        const cross = vectorA.unitCrossProduct(dotAB < cosineValue * dotAA * dotBB ? vectorB : vectorC);
        if (cross)
            return Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.create(origin, cross);
        return undefined;
    }
    // Caller accesses data from a linestring or segment and passes it here.
    // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.  The fraction and extend parameters
    // allow all combinations to be passed in)
    dispatchSegmentArc(cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1, arc, extendB0, extendB1, reversed) {
        const lineVector = Point3dVector3d_1.Vector3d.createStartEnd(pointA0, pointA1);
        const plane = this.createPlaneWithPreferredPerpendicular(pointA0, lineVector, 0.9, arc.perpendicularVector, arc.vector0);
        if (plane !== undefined) {
            const candidates = [];
            arc.appendPlaneIntersectionPoints(plane, candidates);
            let lineFraction;
            let linePoint;
            for (const c of candidates) {
                if (this.acceptFraction(extendB0, c.fraction, extendB1)) {
                    lineFraction = Polynomials_1.SmallSystem.lineSegment3dXYClosestPointUnbounded(pointA0, pointA1, c.point);
                    if (lineFraction !== undefined) {
                        linePoint = pointA0.interpolate(lineFraction, pointA1, linePoint);
                        if (linePoint.isAlmostEqualMetric(c.point)
                            && this.acceptFraction(extendA0, lineFraction, extendA1)) {
                            this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1, c.fraction, arc, 0, 1, reversed);
                        }
                    }
                }
            }
        }
    }
    // Caller promises arcs are coplanar.
    // Passes "other" as {center, vector0, vector90} in local xy space of cpA
    // Solves the arc-arc equations for that local ellipse with unit circle.
    // Solution fractions map directly to original arcs.
    dispatchArcArcInPlane(cpA, extendA, cpB, extendB, reversed) {
        const otherVectors = cpA.otherArcAsLocalVectors(cpB);
        if (otherVectors !== undefined) {
            const ellipseRadians = [];
            const circleRadians = [];
            Polynomials_1.TrigPolynomial.solveUnitCircleHomogeneousEllipseIntersection(otherVectors.center.x, otherVectors.center.y, 1.0, otherVectors.vector0.x, otherVectors.vector0.y, 0.0, otherVectors.vector90.x, otherVectors.vector90.y, 0.0, ellipseRadians, circleRadians);
            for (let i = 0; i < ellipseRadians.length; i++) {
                const fractionA = cpA.sweep.radiansToSignedPeriodicFraction(circleRadians[i]);
                const fractionB = cpA.sweep.radiansToSignedPeriodicFraction(ellipseRadians[i]);
                // hm .. do we really need to check the fractions?  We know they are internal to the beziers
                if (this.acceptFraction(extendA, fractionA, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {
                    this.recordPointWithLocalFractions(fractionA, cpA, 0, 1, fractionB, cpB, 0, 1, reversed);
                }
            }
        }
    }
    // Caller accesses data from two arcs.
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchArcArc(cpA, extendA, cpB, extendB, reversed) {
        // If arcs are in different planes:
        // 1) Intersect each plane with the other arc (quadratic)
        // 2) accept points that appear in both intersection sets.
        // If arcs are in parallel planes -- no intersections
        // If arcs are in the same plane -- xy intersection in that plane.
        const planeA = Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.create(cpA.center, cpA.perpendicularVector);
        const planeB = Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.create(cpB.center, cpB.perpendicularVector);
        if (planeA === undefined || planeB === undefined)
            return;
        if (planeA.getNormalRef().isParallelTo(planeB.getNormalRef())) {
            if (planeA.isPointInPlane(planeB.getOriginRef()) && planeB.isPointInPlane(planeA.getOriginRef())) {
                // coplanar !!!
                this.dispatchArcArcInPlane(cpA, extendA, cpB, extendB, reversed);
            }
        }
        else {
            const arcBPoints = [];
            cpB.appendPlaneIntersectionPoints(planeA, arcBPoints);
            const arcAPoints = [];
            cpA.appendPlaneIntersectionPoints(planeB, arcAPoints);
            for (const detailB of arcBPoints) {
                for (const detailA of arcAPoints) {
                    if (detailA.point.isAlmostEqual(detailB.point)) {
                        if (this.acceptFraction(extendA, detailA.fraction, extendA)
                            && this.acceptFraction(extendB, detailB.fraction, extendB)) {
                            this.recordPointWithLocalFractions(detailA.fraction, cpA, 0, 1, detailB.fraction, cpB, 0, 1, reversed);
                        }
                    }
                }
            }
        }
    }
    // Caller accesses data from two arcs.
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchArcBsplineCurve3d(_, _extendA, _cpB, _extendB, _reversed) {
        /*
        // Arc: X = C + cU + sV
        // implicitize the arc as viewed.  This "3d" matrix is homogeneous "XYW" not "xyz"
        let matrixA: Matrix3d;
        if (this._worldToLocalPerspective) {
          const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);
          matrixA = Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);
        } else {
          const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);
          matrixA = Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);
        }
        // The worldToLocal has moved the arc vectors into screen space.
        // matrixA captures the xyw parts (ignoring z)
        // for any point in world space,
        // THIS CODE ONLY WORKS FOR
        const matrixAInverse = matrixA.inverse();
        if (matrixAInverse) {
          const orderF = cpB.order; // order of the beziers for simple coordinates
          const orderG = 2 * orderF - 1;  // order of the (single) bezier for squared coordinates.
          const coffF = new Float64Array(orderF);
          const univariateBezierG = new UnivariateBezier(orderG);
          const axx = matrixAInverse.at(0, 0); const axy = matrixAInverse.at(0, 1); const axz = 0.0; const axw = matrixAInverse.at(0, 2);
          const ayx = matrixAInverse.at(1, 0); const ayy = matrixAInverse.at(1, 1); const ayz = 0.0; const ayw = matrixAInverse.at(1, 2);
          const awx = matrixAInverse.at(2, 0); const awy = matrixAInverse.at(2, 1); const awz = 0.0; const aww = matrixAInverse.at(2, 2);
    
          if (matrixAInverse) {
            let bezier: BezierCurve3dH | undefined;
            for (let spanIndex = 0; ; spanIndex++) {
              bezier = cpB.getSaturatedBezierSpan3dH(spanIndex, bezier);
              if (!bezier) break;
              if (this._worldToLocalPerspective)
                bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);
              else if (this._worldToLocalAffine)
                bezier.tryTransformInPlace(this._worldToLocalAffine);
              univariateBezierG.zero();
              bezier.poleProductsXYZW(coffF, axx, axy, axz, axw);
              univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);
              bezier.poleProductsXYZW(coffF, ayx, ayy, ayz, ayw);
              univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);
              bezier.poleProductsXYZW(coffF, awx, awy, awz, aww);
              univariateBezierG.addSquaredSquaredBezier(coffF, -1.0);
              const roots = univariateBezierG.roots(0.0, true);
              if (roots) {
                for (const root of roots) {
                  const fractionB = bezier.fractionToParentFraction(root);
                  // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space
                  const bcurvePoint4d = bezier.fractionToPoint4d(root);
                  const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);
                  const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);
                  const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));
                  if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {
                    this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,
                      fractionB, cpB, 0, 1, reversed);
                  }
                }
              }
            }
          }
        }
        */
    }
    /*
    // apply the transformation to bezier curves. optionally construct ranges.
    private transformBeziers(beziers: BezierCurve3dH[]) {
      if (this._worldToLocalAffine) {
        for (const bezier of beziers) bezier.tryTransformInPlace(this._worldToLocalAffine);
      } else if (this._worldToLocalPerspective) {
        for (const bezier of beziers) bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);
      }
    }
    */
    /*
    private getRanges(beziers: BezierCurveBase[]): Range3d[] {
      const ranges: Range3d[] = [];
      ranges.length = 0;
      for (const b of beziers) {
        ranges.push(b.range());
      }
      return ranges;
    }
    private _xyzwA0?: Point4d;
    private _xyzwA1?: Point4d;
    private _xyzwPlane?: Point4d;
    private _xyzwB?: Point4d;
  
    private dispatchBezierBezierStrokeFirst(
      bezierA: BezierCurve3dH,
      bcurveA: BSplineCurve3dBase,
      strokeCountA: number,
      bezierB: BezierCurve3dH,
      bcurveB: BSplineCurve3dBase,
      _strokeCountB: number,
      univariateBezierB: UnivariateBezier,  // caller-allocated for univariate coefficients.
      reversed: boolean) {
      if (!this._xyzwA0) this._xyzwA0 = Point4d.create();
      if (!this._xyzwA1) this._xyzwA1 = Point4d.create();
      if (!this._xyzwPlane) this._xyzwPlane = Point4d.create();
      if (!this._xyzwB) this._xyzwB = Point4d.create();
      /-*
  
                const roots = univariateBezierG.roots(0.0, true);
                if (roots) {
                  for (const root of roots) {
                    const fractionB = bezier.fractionToParentFraction(root);
                    // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space
                    const bcurvePoint4d = bezier.fractionToPoint4d(root);
                    const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);
                    const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);
                    const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));
                    if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {
                      this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,
                        fractionB, cpB, 0, 1, reversed);
                    }
                  }
      *-/
      bezierA.fractionToPoint4d(0.0, this._xyzwA0);
      let f0 = 0.0;
      let f1 = 1.0;
      const intervalTolerance = 1.0e-5;
      const df = 1.0 / strokeCountA;
      for (let i = 1; i <= strokeCountA; i++ , f0 = f1, this._xyzwA0.setFrom(this._xyzwA1)) {
        f1 = i * df;
        bezierA.fractionToPoint4d(f1, this._xyzwA1);
        Point4d.createPlanePointPointZ(this._xyzwA0, this._xyzwA1, this._xyzwPlane);
        bezierB.poleProductsXYZW(univariateBezierB.coffs, this._xyzwPlane.x, this._xyzwPlane.y, this._xyzwPlane.z, this._xyzwPlane.w);
        let errors = 0;
        const roots = univariateBezierB.roots(0.0, true);
        if (roots)
          for (const r of roots) {
            const bezierBFraction = r;
            bezierB.fractionToPoint4d(bezierBFraction, this._xyzwB);
            const segmentAFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0, this._xyzwA1, this._xyzwB);
            if (segmentAFraction && Geometry.isIn01WithTolerance(segmentAFraction, intervalTolerance)) {
              const bezierAFraction = Geometry.interpolate(f0, segmentAFraction, f1);
              /*- TODO implement newton search
              const xyMatchingFunction = new BezierBezierIntersectionXYRRToRRD(bezierA, bezierB);
              const newtonSearcher = new Newton2dUnboundedWithDerivative(xyMatchingFunction);
              newtonSearcher.setUV(bezierAFraction, bezierBFraction);
              if (newtonSearcher.runIterations()) {
                bezierAFraction = newtonSearcher.getU();
                bezierBFraction = newtonSearcher.getV();
              }
              *-/
              // We have a near intersection at fractions on the two beziers !!!
              // Iterate on the curves for a true intersection ....
              // NEEDS WORK -- just accept . . .
              const bcurveAFraction = bezierA.fractionToParentFraction(bezierAFraction);
              const bcurveBFraction = bezierB.fractionToParentFraction(bezierBFraction);
              const xyzA0 = bezierA.fractionToPoint(bezierAFraction);
              const xyzA1 = bcurveA.fractionToPoint(bcurveAFraction);
              const xyzB0 = bezierB.fractionToPoint(bezierBFraction);
              const xyzB1 = bcurveB.fractionToPoint(bcurveBFraction);
              if (!xyzA0.isAlmostEqualXY(xyzA1))
                errors++;
              if (!xyzB0.isAlmostEqualXY(xyzB1))
                errors++;
              if (errors > 0 && !xyzA0.isAlmostEqual(xyzB0))
                errors++;
              if (errors > 0 && !xyzA1.isAlmostEqual(xyzB1))
                errors++;
              if (this.acceptFraction(false, bcurveAFraction, false) && this.acceptFraction(false, bcurveBFraction, false)) {
                this.recordPointWithLocalFractions(bcurveAFraction, bcurveA, 0, 1,
                  bcurveBFraction, bcurveB, 0, 1, reversed);
              }
            }
          }
      }
    }
    */
    // Caller accesses data from two arcs.
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchBSplineCurve3dBSplineCurve3d(_bcurveA, _bcurveB, _reversed) {
        /*
      const bezierSpanA = bcurveA.collectBezierSpans(true) as BezierCurve3dH[];
      const bezierSpanB = bcurveB.collectBezierSpans(true) as BezierCurve3dH[];
      const numA = bezierSpanA.length;
      const numB = bezierSpanB.length;
      this.transformBeziers(bezierSpanA);
      this.transformBeziers(bezierSpanB);
      const rangeA = this.getRanges(bezierSpanA);
      const rangeB = this.getRanges(bezierSpanB);
      const orderA = bcurveA.order;
      const orderB = bcurveB.order;
      const univariateCoffsA = new UnivariateBezier(orderA);
      const univariateCoffsB = new UnivariateBezier(orderB);
      for (let a = 0; a < numA; a++) {
        for (let b = 0; b < numB; b++) {
          if (rangeA[a].intersectsRangeXY(rangeB[b])) {
            const strokeCountA = bezierSpanA[a].computeStrokeCountForOptions();
            const strokeCountB = bezierSpanB[b].computeStrokeCountForOptions();
            if (strokeCountA < strokeCountB)
              this.dispatchBezierBezierStrokeFirst(bezierSpanA[a], bcurveA, strokeCountA, bezierSpanB[b], bcurveB, strokeCountB, univariateCoffsB, !_reversed);
            else
              this.dispatchBezierBezierStrokeFirst(bezierSpanB[b], bcurveB, strokeCountB, bezierSpanA[a], bcurveA, strokeCountA, univariateCoffsA, _reversed);
          }
        }
      }
      */
    }
    /**
     * Apply the projection transform (if any) to (xyz, w)
     * @param xyz xyz parts of input point.
     * @param w   weight to use for homogeneous effects
     */
    /*
    private projectPoint(xyz: XYAndZ, w: number = 1.0): Point4d {
      if (this._worldToLocalPerspective)
        return this._worldToLocalPerspective.multiplyPoint3d(xyz, w);
      if (this._worldToLocalAffine)
        return this._worldToLocalAffine.multiplyXYZW(xyz.x, xyz.y, xyz.z, w);
      return Point4d.createFromPointAndWeight(xyz, w);
    }
    private mapNPCPlaneToWorld(npcPlane: Point4d, worldPlane: Point4d) {
      // for NPC pointY, Y^ * H = 0 is "on" plane H.  (Hat is transpose)
      // NPC Y is A*X for our transform A and worldPointX.
      // hence (A X)^ * H = 0
      // hence X^ * A^ * H = 0
      // hence K = A^ * H
      if (this._worldToLocalAffine) {
        this._worldToLocalAffine.multiplyTransposeXYZW(npcPlane.x, npcPlane.y, npcPlane.z, npcPlane.w, worldPlane);
      } else if (this._worldToLocalPerspective) {
        this._worldToLocalPerspective.multiplyTransposePoint4d(npcPlane, worldPlane);
      } else {
        npcPlane.clone(worldPlane);
      }
    }
    */
    // Caller accesses data from segment and bsplineCurve
    // Selects the best conditioned arc (in xy parts) as "circle after inversion"
    // Solves the arc-arc equations
    dispatchSegmentBsplineCurve(_cpA, _extendA0, _pointA0, _fractionA0, _pointA1, _fractionA1, _extendA1, _bcurve, _extendB, _reversed) {
        /*
        const pointA0H = this.projectPoint(pointA0);
        const pointA1H = this.projectPoint(pointA1);
        const planeCoffs = Point4d.createPlanePointPointZ(pointA0H, pointA1H);
        this.mapNPCPlaneToWorld(planeCoffs, planeCoffs);
        // NOW .. we have a plane in world space.  Intersect it with the bspline:
        const intersections: CurveLocationDetail[] = [];
        bcurve.appendPlaneIntersectionPoints(planeCoffs, intersections);
        // intersections has WORLD points with bspline fractions.   (The bspline fractions are all good 0..1 fractions within the spline.)
        // accept those that are within the segment range.
        for (const detail of intersections) {
          const fractionB = detail.fraction;
          const curvePoint = detail.point;
          const curvePointH = this.projectPoint(curvePoint);
          const lineFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, curvePointH);
          if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB, fractionB, extendB)) {
            this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1,
              fractionB, bcurve, 0, 1, reversed);
          }
        }
        */
    }
    /** low lever bspline curve -- STUB  .. */
    dispatchLineStringBSplineCurve(_lsA, _extendA, _curveB, _extendB, _reversed) {
        /*
        const numA = lsA.numPoints();
        if (numA > 1) {
          const dfA = 1.0 / (numA - 1);
          let fA0;
          let fA1;
          fA0 = 0.0;
          const pointA0 = CurveCurveIntersectXYZ._workPointA0;
          const pointA1 = CurveCurveIntersectXYZ._workPointA1;
          lsA.pointAt(0, pointA0);
          for (let iA = 1; iA < numA; iA++ , pointA0.setFrom(pointA1), fA0 = fA1) {
            lsA.pointAt(iA, pointA1);
            fA1 = iA * dfA;
            this.dispatchSegmentBsplineCurve(
              lsA, iA === 1 && extendA, pointA0, fA0, pointA1, fA1, (iA + 1) === numA && extendA,
              curveB, extendB, reversed);
          }
        }
        return undefined;
        */
    }
    /** low lever segment intersect linestring .. */
    computeSegmentLineString(lsA, extendA, lsB, extendB, reversed) {
        const pointA0 = lsA.point0Ref;
        const pointA1 = lsA.point1Ref;
        const pointB0 = CurveCurveIntersectXYZ._workPointBB0;
        const pointB1 = CurveCurveIntersectXYZ._workPointBB1;
        const numB = lsB.numPoints();
        if (numB > 1) {
            const dfB = 1.0 / (numB - 1);
            let fB0;
            let fB1;
            fB0 = 0.0;
            lsB.pointAt(0, pointB0);
            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                lsB.pointAt(ib, pointB1);
                fB1 = ib * dfB;
                this.dispatchSegmentSegment(lsA, extendA, pointA0, 0.0, pointA1, 1.0, extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, reversed);
            }
        }
        return undefined;
    }
    /** low lever arc intersect linestring .. */
    computeArcLineString(arcA, extendA, lsB, extendB, reversed) {
        const pointB0 = CurveCurveIntersectXYZ._workPointBB0;
        const pointB1 = CurveCurveIntersectXYZ._workPointBB1;
        const numB = lsB.numPoints();
        if (numB > 1) {
            const dfB = 1.0 / (numB - 1);
            let fB0;
            let fB1;
            fB0 = 0.0;
            lsB.pointAt(0, pointB0);
            for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                lsB.pointAt(ib, pointB1);
                fB1 = ib * dfB;
                this.dispatchSegmentArc(lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, arcA, extendA, extendA, !reversed);
            }
        }
        return undefined;
    }
    /** double dispatch handler for strongly typed segment.. */
    handleLineSegment3d(segmentA) {
        if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            const segmentB = this._geometryB;
            this.dispatchSegmentSegment(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, segmentB, this._extendB, segmentB.point0Ref, 0.0, segmentB.point1Ref, 1.0, this._extendB, false);
        }
        else if (this._geometryB instanceof LineString3d_1.LineString3d) {
            this.computeSegmentLineString(segmentA, this._extendA, this._geometryB, this._extendB, false);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.dispatchSegmentArc(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, this._geometryB, this._extendB, this._extendB, false);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3d) {
            this.dispatchSegmentBsplineCurve(segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA, this._geometryB, this._extendB, false);
        }
    }
    /** double dispatch handler for strongly typed linestring .. */
    handleLineString3d(lsA) {
        if (this._geometryB instanceof LineString3d_1.LineString3d) {
            const lsB = this._geometryB;
            const pointA0 = CurveCurveIntersectXYZ._workPointAA0;
            const pointA1 = CurveCurveIntersectXYZ._workPointAA1;
            const pointB0 = CurveCurveIntersectXYZ._workPointBB0;
            const pointB1 = CurveCurveIntersectXYZ._workPointBB1;
            const numA = lsA.numPoints();
            const numB = lsB.numPoints();
            if (numA > 1 && numB > 1) {
                lsA.pointAt(0, pointA0);
                const dfA = 1.0 / (numA - 1);
                const dfB = 1.0 / (numB - 1);
                let fA0 = 0.0;
                let fB0;
                let fA1;
                let fB1;
                const extendA = this._extendA;
                const extendB = this._extendB;
                lsA.pointAt(0, pointA0);
                for (let ia = 1; ia < numA; ia++, pointA0.setFrom(pointA1), fA0 = fA1) {
                    fA1 = ia * dfA;
                    fB0 = 0.0;
                    lsA.pointAt(ia, pointA1);
                    lsB.pointAt(0, pointB0);
                    for (let ib = 1; ib < numB; ib++, pointB0.setFrom(pointB1), fB0 = fB1) {
                        lsB.pointAt(ib, pointB1);
                        fB1 = ib * dfB;
                        this.dispatchSegmentSegment(lsA, ia === 1 && extendA, pointA0, fA0, pointA1, fA1, (ia + 1) === numA && extendA, lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB, false);
                    }
                }
            }
        }
        else if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            this.computeSegmentLineString(this._geometryB, this._extendB, lsA, this._extendA, true);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.computeArcLineString(this._geometryB, this._extendB, lsA, this._extendA, true);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3d) {
            this.dispatchLineStringBSplineCurve(lsA, this._extendA, this._geometryB, this._extendB, false);
        }
        return undefined;
    }
    /** double dispatch handler for strongly typed arc .. */
    handleArc3d(arc0) {
        if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            this.dispatchSegmentArc(this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB, arc0, this._extendA, this._extendA, true);
        }
        else if (this._geometryB instanceof LineString3d_1.LineString3d) {
            this.computeArcLineString(arc0, this._extendA, this._geometryB, this._extendB, false);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.dispatchArcArc(arc0, this._extendA, this._geometryB, this._extendB, false);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3d) {
            this.dispatchArcBsplineCurve3d(arc0, this._extendA, this._geometryB, this._extendB, false);
        }
        return undefined;
    }
    /** double dispatch handler for strongly typed bspline curve.. */
    handleBSplineCurve3d(curve) {
        if (this._geometryB instanceof LineSegment3d_1.LineSegment3d) {
            this.dispatchSegmentBsplineCurve(this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB, curve, this._extendA, true);
        }
        else if (this._geometryB instanceof LineString3d_1.LineString3d) {
            this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);
        }
        else if (this._geometryB instanceof Arc3d_1.Arc3d) {
            this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);
        }
        else if (this._geometryB instanceof BSplineCurve_1.BSplineCurve3dBase) {
            this.dispatchBSplineCurve3dBSplineCurve3d(curve, this._geometryB, false);
        }
        return undefined;
    }
    /** double dispatch handler for strongly typed homogeneous bspline curve. */
    handleBSplineCurve3dH(_curve) {
        /* NEEDS WORK -- make "dispatch" methods tolerant of both 3d and 3dH ..."easy" if both present BezierCurve3dH span loaders
        if (this._geometryB instanceof LineSegment3d) {
          this.dispatchSegmentBsplineCurve(
            this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,
            curve, this._extendA, true);
        } else if (this._geometryB instanceof LineString3d) {
          this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);
        } else if (this._geometryB instanceof Arc3d) {
          this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);
        }
        */
        return undefined;
    }
}
exports.CurveCurveIntersectXYZ = CurveCurveIntersectXYZ;
CurveCurveIntersectXYZ._workVector2dA = Point2dVector2d_1.Vector2d.create();
CurveCurveIntersectXYZ._workPointAA0 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXYZ._workPointAA1 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXYZ._workPointBB0 = Point3dVector3d_1.Point3d.create();
CurveCurveIntersectXYZ._workPointBB1 = Point3dVector3d_1.Point3d.create();


/***/ }),

/***/ "./lib/curve/CurveExtendMode.js":
/*!**************************************!*\
  !*** ./lib/curve/CurveExtendMode.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/** module Curve */
/** enumeration of condition for extending a curve beyond start or end point.
 * * Not all CurvePrimitives support these modes.
 * @public
 */
var CurveExtendMode;
(function (CurveExtendMode) {
    /** No extension allowed. */
    CurveExtendMode[CurveExtendMode["None"] = 0] = "None";
    /** Extend along continuation of the end tangent */
    CurveExtendMode[CurveExtendMode["OnTangent"] = 1] = "OnTangent";
    /** Extend along continuation of the curve. */
    CurveExtendMode[CurveExtendMode["OnCurve"] = 2] = "OnCurve";
})(CurveExtendMode = exports.CurveExtendMode || (exports.CurveExtendMode = {}));
/** Logic for deciding how a curve may be extended for closest point or intersection searches.
 * @public
 */
class CurveExtendOptions {
    /** Given an ExtendParameter, isolate the particular CurveExtendOptions in effect at an end.
     * * Return undefined if `param === false`
     * * return the (strongly typed) pointer to the param if it is a single CurveExtendOptions.
     * * Return dereferenced array entry 0 or 1 if the param is an array of CurveExtendOptions.
     */
    static resolveVariantCurveExtendParameterToCurveExtendMode(param, endIndex) {
        if (param === false)
            return CurveExtendMode.None;
        if (param === true)
            return CurveExtendMode.OnCurve;
        if (Array.isArray(param))
            return param[endIndex];
        return param;
    }
    /**
     *
     * * if fraction is between 0 and 1 return it unchanged.
     * * if fraction is less than 0 use the variant param to choose the fraction or 0
     * * if fraction is greater than 1 use the variant param to choose the fraction or 1
     *
     */
    static correctFraction(extendParam, fraction) {
        if (fraction < 0) {
            const mode = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 0);
            if (mode === CurveExtendMode.None)
                fraction = 0.0;
        }
        else if (fraction > 1.0) {
            const mode = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 1);
            if (mode === CurveExtendMode.None)
                fraction = 1.0;
        }
        return fraction;
    }
    /**
     * Adjust a radians value to an angle sweep, allowing the extendParam to affect choice among periodic fractions.
     * * if radians is within the sweep, convert it to a fraction of the sweep.
     * * if radians is outside, use the extendParam to choose among:
     *    * fraction below 0
     *    * fraction above 1
     */
    static resolveRadiansToSweepFraction(extendParam, radians, sweep) {
        let fraction = sweep.radiansToSignedPeriodicFraction(radians);
        if (!sweep.isRadiansInSweep(radians)) {
            const fractionPeriod = sweep.fractionPeriod();
            const mode0 = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 0);
            const mode1 = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 1);
            if (mode0 !== CurveExtendMode.None) {
                if (mode1 !== CurveExtendMode.None) {
                    // both extensions possible ... let the sweep resolve to the "closer" end
                    fraction = sweep.radiansToSignedPeriodicFraction(radians);
                }
                else {
                    // only extend to negative .....
                    if (fraction > 1.0)
                        fraction -= fractionPeriod;
                }
            }
            else if (mode1 !== CurveExtendMode.None) {
                if (fraction < 0.0)
                    fraction += fractionPeriod;
            }
            else { // both clamped !!!!
                fraction = Geometry_1.Geometry.clamp(fraction, 0, 1);
            }
        }
        return fraction;
    }
}
exports.CurveExtendOptions = CurveExtendOptions;


/***/ }),

/***/ "./lib/curve/CurveFactory.js":
/*!***********************************!*\
  !*** ./lib/curve/CurveFactory.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Arc3d_1 = __webpack_require__(/*! ./Arc3d */ "./lib/curve/Arc3d.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
const Point3dArrayCarrier_1 = __webpack_require__(/*! ../geometry3d/Point3dArrayCarrier */ "./lib/geometry3d/Point3dArrayCarrier.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./lib/curve/Path.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * The `CurveFactory` class contains methods for specialized curve constructions.
 * @public
 */
class CurveFactory {
    /** (cautiously) construct and save a line segment between fractional positions. */
    static addPartialSegment(path, allowBackup, pointA, pointB, fraction0, fraction1) {
        if (allowBackup || (fraction1 > fraction0)) {
            if (pointA !== undefined && pointB !== undefined && !Geometry_1.Geometry.isAlmostEqualNumber(fraction0, fraction1))
                path.tryAddChild(LineSegment3d_1.LineSegment3d.create(pointA.interpolate(fraction0, pointB), pointA.interpolate(fraction1, pointB)));
        }
    }
    /**
     * Construct a sequence of alternating lines and arcs with the arcs creating tangent transition between consecutive edges.
     * @param points point source
     * @param radius fillet radius
     * @param allowBackupAlongEdge true to allow edges to be created going "backwards" along edges if needed to create the blend.
     */
    static createFilletsInLineString(points, radius, allowBackupAlongEdge = true) {
        if (Array.isArray(points))
            return this.createFilletsInLineString(new Point3dArrayCarrier_1.Point3dArrayCarrier(points), radius, allowBackupAlongEdge);
        if (points instanceof LineString3d_1.LineString3d)
            return this.createFilletsInLineString(points.packedPoints, radius, allowBackupAlongEdge);
        const n = points.length;
        if (n <= 1)
            return undefined;
        const pointA = points.getPoint3dAtCheckedPointIndex(0);
        const pointB = points.getPoint3dAtCheckedPointIndex(1);
        // remark: n=2 and n=3 cases should fall out from loop logic
        const blendArray = [];
        // build one-sided blends at each end . .
        blendArray.push({ fraction10: 0.0, fraction12: 0.0, point: pointA.clone() });
        for (let i = 1; i + 1 < n; i++) {
            const pointC = points.getPoint3dAtCheckedPointIndex(i + 1);
            blendArray.push(Arc3d_1.Arc3d.createFilletArc(pointA, pointB, pointC, radius));
            pointA.setFromPoint3d(pointB);
            pointB.setFromPoint3d(pointC);
        }
        blendArray.push({ fraction10: 0.0, fraction12: 0.0, point: pointB.clone() });
        if (!allowBackupAlongEdge) {
            // suppress arcs that have overlap with both neighbors or flood either neighbor ..
            for (let i = 1; i + 1 < n; i++) {
                const b = blendArray[i];
                if (b.fraction10 > 1.0
                    || b.fraction12 > 1.0
                    || 1.0 - b.fraction10 < blendArray[i - 1].fraction12
                    || b.fraction12 > 1.0 - blendArray[i + 1].fraction10) {
                    b.fraction10 = 0.0;
                    b.fraction12 = 0.0;
                    blendArray[i].arc = undefined;
                }
            }
            // on edge with conflict, suppress the arc with larger fraction
            for (let i = 1; i < n; i++) {
                const b0 = blendArray[i - 1];
                const b1 = blendArray[i];
                if (b0.fraction12 > 1 - b1.fraction10) {
                    const b = b0.fraction12 > b1.fraction12 ? b1 : b0;
                    b.fraction10 = 0.0;
                    b.fraction12 = 0.0;
                    blendArray[i].arc = undefined;
                }
            }
        }
        const path = Path_1.Path.create();
        this.addPartialSegment(path, allowBackupAlongEdge, blendArray[0].point, blendArray[1].point, blendArray[0].fraction12, 1.0 - blendArray[1].fraction10);
        // add each path and successor edge ...
        for (let i = 1; i + 1 < points.length; i++) {
            const b0 = blendArray[i];
            const b1 = blendArray[i + 1];
            path.tryAddChild(b0.arc);
            this.addPartialSegment(path, allowBackupAlongEdge, b0.point, b1.point, b0.fraction12, 1.0 - b1.fraction10);
        }
        return path;
    }
    /**
     * If `arcB` is a continuation of `arcA`, extend `arcA` (in place) to include the range of `arcB`
     * * This only succeeds if the two arcs are part of identical complete arcs and end of `arcA` matches the beginning of `arcB`.
     * * "Reversed"
     * @param arcA
     * @param arcB
     */
    static appendToArcInPlace(arcA, arcB, allowReverse = false) {
        if (arcA.center.isAlmostEqual(arcB.center)) {
            const sweepSign = Geometry_1.Geometry.split3WaySign(arcA.sweep.sweepRadians * arcB.sweep.sweepRadians, -1, 0, 1);
            // evaluate derivatives wrt radians (not fraction!), but adjust direction for sweep signs
            const endA = arcA.angleToPointAndDerivative(arcA.sweep.fractionToAngle(1.0));
            if (arcA.sweep.sweepRadians < 0)
                endA.direction.scaleInPlace(-1.0);
            const startB = arcB.angleToPointAndDerivative(arcB.sweep.fractionToAngle(0.0));
            if (arcB.sweep.sweepRadians < 0)
                startB.direction.scaleInPlace(-1.0);
            if (endA.isAlmostEqual(startB)) {
                arcA.sweep.setStartEndRadians(arcA.sweep.startRadians, arcA.sweep.startRadians + arcA.sweep.sweepRadians + sweepSign * arcB.sweep.sweepRadians);
                return true;
            }
            // Also ok if negated tangent . ..
            if (allowReverse) {
                startB.direction.scaleInPlace(-1.0);
                if (endA.isAlmostEqual(startB)) {
                    arcA.sweep.setStartEndRadians(arcA.sweep.startRadians, arcA.sweep.startRadians + arcA.sweep.sweepRadians - sweepSign * arcB.sweep.sweepRadians);
                    return true;
                }
            }
        }
        return false;
    }
}
exports.CurveFactory = CurveFactory;


/***/ }),

/***/ "./lib/curve/CurveLocationDetail.js":
/*!******************************************!*\
  !*** ./lib/curve/CurveLocationDetail.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * An enumeration of special conditions being described by a CurveLocationDetail.
 * @public
 */
var CurveIntervalRole;
(function (CurveIntervalRole) {
    /** This point is an isolated point NOT at a primary vertex. */
    CurveIntervalRole[CurveIntervalRole["isolated"] = 0] = "isolated";
    /**  This point is an isolated vertex hit */
    CurveIntervalRole[CurveIntervalRole["isolatedAtVertex"] = 1] = "isolatedAtVertex";
    /** This is the beginning of an interval */
    CurveIntervalRole[CurveIntervalRole["intervalStart"] = 10] = "intervalStart";
    /** This is an interior point of an interval. */
    CurveIntervalRole[CurveIntervalRole["intervalInterior"] = 11] = "intervalInterior";
    /** This is the end of an interval */
    CurveIntervalRole[CurveIntervalRole["intervalEnd"] = 12] = "intervalEnd";
})(CurveIntervalRole = exports.CurveIntervalRole || (exports.CurveIntervalRole = {}));
/**
 * Return code for CurvePrimitive method `moveSignedDistanceFromFraction`
 * @public
 */
var CurveSearchStatus;
(function (CurveSearchStatus) {
    /** unimplemented or zero length curve  */
    CurveSearchStatus[CurveSearchStatus["error"] = 0] = "error";
    /** complete success of search */
    CurveSearchStatus[CurveSearchStatus["success"] = 1] = "success";
    /** search ended prematurely (e.g. at incomplete distance moved) at start or end of curve */
    CurveSearchStatus[CurveSearchStatus["stoppedAtBoundary"] = 2] = "stoppedAtBoundary";
})(CurveSearchStatus = exports.CurveSearchStatus || (exports.CurveSearchStatus = {}));
/**
 * use to update a vector in case where source and prior result are both possibly undefined.
 * * Any undefined source returns undefined.
 * * For defined source, reuse optional result if available.
 * @param source optional source
 * @param result optional result
 */
function optionalVectorUpdate(source, result) {
    if (source) {
        return source.clone(result);
    }
    return undefined;
}
/**
 * CurveLocationDetail carries point and paramter data about a point evaluated on a curve.
 * * These are returned by a variety of queries.
 * * Particular contents can vary among the queries.
 * @public
 */
class CurveLocationDetail {
    constructor() {
        this.pointQ = Point3dVector3d_1.Point3d.createZero();
        this.fraction = 0;
        this.point = Point3dVector3d_1.Point3d.createZero();
        this.a = 0.0;
    }
    /** Set the (optional) intervalRole field */
    setIntervalRole(value) {
        this.intervalRole = value;
    }
    /** test if this is an isolated point. This is true if intervalRole is any of (undefined, isolated, isolatedAtVertex) */
    get isIsolated() {
        return this.intervalRole === undefined
            || this.intervalRole === CurveIntervalRole.isolated
            || this.intervalRole === CurveIntervalRole.isolatedAtVertex;
    }
    /** Return a complete copy, WITH CAVEATS . . .
     * * curve member is copied as a reference.
     * * point and vector members are cloned.
     */
    clone(result) {
        if (result === this)
            return result;
        result = result ? result : new CurveLocationDetail();
        result.curve = this.curve;
        result.fraction = this.fraction;
        result.point.setFromPoint3d(this.point);
        result.vectorInCurveLocationDetail = optionalVectorUpdate(this.vectorInCurveLocationDetail, result.vectorInCurveLocationDetail);
        result.a = this.a;
        result.curveSearchStatus = this.curveSearchStatus;
        return result;
    }
    /**
     * Updated in this instance.
     * * Note that if caller omits `vector` and `a`, those fields are updated to the call-list defaults (NOT left as-is)
     * * point and vector updates are by data copy (not capture of pointers)
     * @param fraction (required) fraction to install
     * @param point  (required) point to install
     * @param vector (optional) vector to install.
     * @param a (optional) numeric value to install.
     */
    setFP(fraction, point, vector, a = 0.0) {
        this.fraction = fraction;
        this.point.setFrom(point);
        this.vectorInCurveLocationDetail = optionalVectorUpdate(vector, this.vectorInCurveLocationDetail);
        this.a = a;
    }
    /**
     * Updated in this instance.
     * * Note that if caller omits a`, that field is updated to the call-list default (NOT left as-is)
     * * point and vector updates are by data copy (not capture of the ray members)
     * @param fraction (required) fraction to install
     * @param ray  (required) point and vector to install
     * @param a (optional) numeric value to install.
     */
    setFR(fraction, ray, a = 0) {
        return this.setFP(fraction, ray.origin, ray.direction, a);
    }
    /** Set the CurvePrimitive pointer, leaving all other properties untouched.
     */
    setCurve(curve) { this.curve = curve; }
    /** record the distance from the CurveLocationDetail's point to the parameter point. */
    setDistanceTo(point) {
        this.a = this.point.distance(point);
    }
    /** create with a CurvePrimitive pointer but no coordinate data.
     */
    static create(curve, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        return result;
    }
    /** create with CurvePrimitive pointer, fraction, and point coordinates.
     */
    static createCurveFractionPoint(curve, fraction, point, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = fraction;
        result.point.setFromPoint3d(point);
        result.vectorInCurveLocationDetail = undefined;
        result.a = 0.0;
        result.curveSearchStatus = undefined;
        return result;
    }
    /**
     * Create a new detail with only ray, fraction, and point.
     */
    static createRayFractionPoint(ray, fraction, point, result) {
        result = result ? result : new CurveLocationDetail();
        result.fraction = fraction;
        result.ray = ray;
        result.point.setFromPoint3d(point);
        return result;
    }
    /** create with CurvePrimitive pointer, fraction, and point coordinates
     */
    static createCurveFractionPointDistanceCurveSearchStatus(curve, fraction, point, distance, status, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = fraction;
        result.point.setFromPoint3d(point);
        result.vectorInCurveLocationDetail = undefined;
        result.a = distance;
        result.curveSearchStatus = status;
        return result;
    }
    /** create with curveSearchStatus affected by allowExtension.
     * *
     */
    static createConditionalMoveSignedDistance(allowExtension, curve, startFraction, endFraction, requestedSignedDistance, result) {
        let a = requestedSignedDistance;
        let status = CurveSearchStatus.success;
        if (!allowExtension && !Geometry_1.Geometry.isIn01(endFraction)) {
            // cap the movement at the endpoint
            if (endFraction < 0.0) {
                a = -curve.curveLengthBetweenFractions(startFraction, 0.0);
                endFraction = 0.0;
                status = CurveSearchStatus.stoppedAtBoundary;
            }
            else if (endFraction > 1.0) {
                endFraction = 1.0;
                a = curve.curveLengthBetweenFractions(startFraction, 1.0);
                status = CurveSearchStatus.stoppedAtBoundary;
            }
        }
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = endFraction;
        result.point = curve.fractionToPoint(endFraction, result.point);
        result.vectorInCurveLocationDetail = undefined;
        result.a = a;
        result.curveSearchStatus = status;
        return result;
    }
    /** create with CurvePrimitive pointer, fraction, and point coordinates.
     */
    static createCurveEvaluatedFraction(curve, fraction, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = fraction;
        result.point = curve.fractionToPoint(fraction);
        result.vectorInCurveLocationDetail = undefined;
        result.curveSearchStatus = undefined;
        result.a = 0.0;
        return result;
    }
    /** create with CurvePrimitive pointer, fraction, and point coordinates.
     */
    static createCurveFractionPointDistance(curve, fraction, point, a, result) {
        result = result ? result : new CurveLocationDetail();
        result.curve = curve;
        result.fraction = fraction;
        result.point.setFromPoint3d(point);
        result.vectorInCurveLocationDetail = undefined;
        result.a = a;
        result.curveSearchStatus = undefined;
        return result;
    }
    /** update or create if closer than current contents.
     * @param curve candidate curve
     * @param fraction candidate fraction
     * @param point candidate point
     * @param a candidate distance
     * @returns true if the given distance is smaller (and hence this detail was updated.)
     */
    updateIfCloserCurveFractionPointDistance(curve, fraction, point, a) {
        if (this.a < a)
            return false;
        CurveLocationDetail.createCurveFractionPointDistance(curve, fraction, point, a, this);
        return true;
    }
}
exports.CurveLocationDetail = CurveLocationDetail;
/** Enumeration of configurations for intersections and min/max distance-between-curve
 * @public
 */
var CurveCurveApproachType;
(function (CurveCurveApproachType) {
    /** Intersection at a single point */
    CurveCurveApproachType[CurveCurveApproachType["Intersection"] = 0] = "Intersection";
    /** Distinct points on the two curves, with each curve's tangent perpendicular to the chord between the points */
    CurveCurveApproachType[CurveCurveApproachType["PerpendicularChord"] = 1] = "PerpendicularChord";
    /** Completely coincident geometry */
    CurveCurveApproachType[CurveCurveApproachType["CoincidentGeometry"] = 2] = "CoincidentGeometry";
    /** Completely parallel geometry. */
    CurveCurveApproachType[CurveCurveApproachType["ParallelGeometry"] = 3] = "ParallelGeometry";
})(CurveCurveApproachType = exports.CurveCurveApproachType || (exports.CurveCurveApproachType = {}));
/** A pair of CurveLocationDetail.
 * @public
 */
class CurveLocationDetailPair {
    constructor(detailA, detailB) {
        this.detailA = detailA ? detailA : new CurveLocationDetail();
        this.detailB = detailB ? detailB : new CurveLocationDetail();
    }
    /** Create a curve detail pair using references to two CurveLocationDetails */
    static createCapture(detailA, detailB, result) {
        result = result ? result : new CurveLocationDetailPair();
        result.detailA = detailA;
        result.detailB = detailB;
        return result;
    }
    /** Make a deep copy of this CurveLocationDetailPair */
    clone(result) {
        result = result ? result : new CurveLocationDetailPair();
        result.detailA = this.detailA.clone();
        result.detailB = this.detailB.clone();
        result.approachType = this.approachType;
        return result;
    }
}
exports.CurveLocationDetailPair = CurveLocationDetailPair;


/***/ }),

/***/ "./lib/curve/CurvePrimitive.js":
/*!*************************************!*\
  !*** ./lib/curve/CurvePrimitive.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Newton_1 = __webpack_require__(/*! ../numerics/Newton */ "./lib/numerics/Newton.js");
const Quadrature_1 = __webpack_require__(/*! ../numerics/Quadrature */ "./lib/numerics/Quadrature.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const GeometryQuery_1 = __webpack_require__(/*! ./GeometryQuery */ "./lib/curve/GeometryQuery.js");
const StrokeCountMap_1 = __webpack_require__(/*! ../curve/Query/StrokeCountMap */ "./lib/curve/Query/StrokeCountMap.js");
const CurveExtendMode_1 = __webpack_require__(/*! ./CurveExtendMode */ "./lib/curve/CurveExtendMode.js");
/**
 * A curve primitive is bounded
 * A curve primitive maps fractions in 0..1 to points in space.
 * As the fraction proceeds from 0 towards 1, the point moves "forward" along the curve.
 * True distance along the curve is not always strictly proportional to fraction.
 * * LineSegment3d always has proportional fraction and distance
 * * an Arc3d which is true circular has proportional fraction and distance
 * *  A LineString3d is not proportional (except for special case of all segments of equal length)
 * * A Spiral3d is proportional
 * * A BsplineCurve3d is only proportional for special cases.
 *
 * For fractions outside 0..1, the curve primitive class may either (a) return the near endpoint or (b) evaluate an extended curve.
 * @public
 */
class CurvePrimitive extends GeometryQuery_1.GeometryQuery {
    constructor() {
        super();
        /** String name for schema properties */
        this.geometryCategory = "curvePrimitive";
    }
    /**
     * Returns a ray whose origin is the curve point and direction is the unit tangent.
     * @param fraction fractional position on the curve
     * @param result optional preallocated ray.
     */
    fractionToPointAndUnitTangent(fraction, result) {
        const ray = this.fractionToPointAndDerivative(fraction, result);
        ray.trySetDirectionMagnitudeInPlace(1.0);
        return ray;
    }
    /** Construct a frenet frame:
     * * origin at the point on the curve
     * * x axis is unit vector along the curve (tangent)
     * * y axis is perpendicular and in the plane of the osculating circle.
     * * z axis perpendicular to those.
     */
    fractionToFrenetFrame(fraction, result) {
        const plane = this.fractionToPointAnd2Derivatives(fraction);
        if (!plane)
            return undefined;
        let axes = Matrix3d_1.Matrix3d.createRigidFromColumns(plane.vectorU, plane.vectorV, Geometry_1.AxisOrder.XYZ);
        if (axes)
            return Transform_1.Transform.createRefs(plane.origin, axes, result);
        // 2nd derivative not distinct -- do arbitrary headsUP ...
        const perpVector = Matrix3d_1.Matrix3d.createPerpendicularVectorFavorXYPlane(plane.vectorU, plane.vectorV);
        axes = Matrix3d_1.Matrix3d.createRigidFromColumns(plane.vectorU, perpVector, Geometry_1.AxisOrder.XYZ);
        if (axes)
            return Transform_1.Transform.createRefs(plane.origin, axes, result);
        return undefined;
    }
    /**
     * Construct a point extrapolated along tangent at fraction.
     * @param fraction fractional position on the primitive
     * @param distance (signed) distance to move on the tangent.
     */
    fractionAndDistanceToPointOnTangent(fraction, distance) {
        const ray = this.fractionToPointAndUnitTangent(fraction);
        return ray.fractionToPoint(distance);
    }
    /**
     * return the length of the curve.
     * * Curve length is always positive.
     */
    curveLength() {
        const context = new CurveLengthContext();
        this.emitStrokableParts(context);
        return context.getSum();
    }
    /**
     * Returns a (high accuracy) length of the curve between fractional positions
     * * Curve length is always positive.
     * * Default implementation applies a generic gaussian integration.
     * * Most curve classes (certainly LineSegment, LineString, Arc) are expected to provide efficient implementations.
     */
    curveLengthBetweenFractions(fraction0, fraction1) {
        if (fraction0 === fraction1)
            return 0.0;
        const scale = this.getFractionToDistanceScale();
        if (scale !== undefined) {
            // We are in luck! simple proportions determine it all  !!!
            // (for example, a LineSegment3d or a circular arc)
            const totalLength = this.curveLength();
            return Math.abs((fraction1 - fraction0) * totalLength);
        }
        const context = new CurveLengthContext(fraction0, fraction1);
        this.emitStrokableParts(context);
        return Math.abs(context.getSum());
    }
    /**
     *
     * * Run an integration (with a default gaussian quadrature) with a fixed fractional step
     * * This is typically called by specific curve type implementations of curveLengthBetweenFractions.
     *   * For example, in Arc3d implementation of curveLengthBetweenFractions:
     *     * If the Arc3d is true circular, it the arc is true circular, use the direct `arcLength = radius * sweepRadians`
     *     * If the Arc3d is not true circular, call this method with an interval count appropriate to eccentricity and sweepRadians.
     * @returns Returns an integral estimated by numerical quadrature between the fractional positions.
     * @param fraction0 start fraction for integration
     * @param fraction1 end fraction for integration
     * @param numInterval number of quadrature intervals
     */
    curveLengthWithFixedIntervalCountQuadrature(fraction0, fraction1, numInterval, numGauss = 5) {
        if (fraction0 > fraction1) {
            const fSave = fraction0;
            fraction0 = fraction1;
            fraction1 = fSave;
        }
        const context = new CurveLengthContext(fraction0, fraction1, numGauss);
        context.announceIntervalForUniformStepStrokes(this, numInterval, fraction0, fraction1);
        return Math.abs(context.getSum());
    }
    /**
     *
     * * (Attempt to) find a position on the curve at a signed distance from start fraction.
     * * Return the position as a CurveLocationDetail.
     * * In the `CurveLocationDetail`, record:
     *   * `fractional` position
     *   * `fraction` = coordinates of the point
     *   * `search
     *   * `a` = (signed!) distance moved.   If `allowExtension` is false and the move reached the start or end of the curve, this distance is smaller than the requested signedDistance.
     *   * `curveSearchStatus` indicates one of:
     *     * `error` (unusual) computation failed not supported for this curve.
     *     * `success` full movement completed
     *     * `stoppedAtBoundary` partial movement completed. This can be due to either
     *        * `allowExtension` parameter sent as `false`
     *        * the curve type (e.g. bspline) does not support extended range.
     * * if `allowExtension` is true, movement may still end at the startPoint or end point for curves that do not support extended geometry (specifically bsplines)
     * * if the curve returns a value (i.e. not `undefined`) for `curve.getFractionToDistanceScale()`, the base class carries out the computation
     *    and returns a final location.
     *   * LineSegment3d relies on this.
     * * If the curve does not implement the computation or the curve has zero length, the returned `CurveLocationDetail` has
     *    * `fraction` = the value of `startFraction`
     *    * `point` = result of `curve.fractionToPoint(startFraction)`
     *    * `a` = 0
     *    * `curveStartState` = `CurveSearchStatus.error`
     * @param startFraction fractional position where the move starts
     * @param signedDistance distance to move.   Negative distance is backwards in the fraction space
     * @param allowExtension if true, all the move to go beyond the startPoint or endpoint of the curve.  If false, do not allow movement beyond the startPoint or endpoint
     * @param result optional result.
     * @returns A CurveLocationDetail annotated as above.  Note that if the curve does not support the calculation, there is still a result which contains the point at the input startFraction, with failure indicated in the `curveStartState` member
     */
    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {
        const scale = this.getFractionToDistanceScale();
        if (scale !== undefined) {
            // We are in luck! simple proportions determine it all  !!!
            // (for example, a LineSegment3d or a circular arc)
            const totalLength = this.curveLength();
            const signedFractionMove = Geometry_1.Geometry.conditionalDivideFraction(signedDistance, totalLength);
            if (signedFractionMove === undefined) {
                return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, startFraction, this.fractionToPoint(startFraction), 0.0, CurveLocationDetail_1.CurveSearchStatus.error);
            }
            return CurveLocationDetail_1.CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, startFraction + signedFractionMove, signedDistance, result);
        }
        return this.moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result);
    }
    /**
     * Generic algorithm to search for point at signed distance from a fractional startPoint.
     * * This will work for well for smooth curves.
     * * Curves with tangent or other low-order-derivative discontinuities may need to implement specialized algorithms.
     * * We need to find an endFraction which is the end-of-interval (usually upper) limit of integration of the tangent magnitude from startFraction to endFraction
     * * That integral is a function of endFraction.
     * * The derivative of that integral with respect to end fraction is the tangent magnitude at end fraction.
     * * Use that function and (easily evaluated!) derivative for a Newton iteration
     * * TO ALL WHO HAVE FUZZY MEMORIES OF CALCULUS CLASS: "The derivative of the integral wrt upper limit is the value of the integrand there" is the
     *       fundamental theorem of integral calculus !!! The fundamental theorem is not just an abstraction !!! It is being used
     *       here in its barest possible form !!!
     * * See https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus
     * @param startFraction
     * @param signedDistance
     * @param _allowExtension
     * @param result
     */
    moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result) {
        const limitFraction = signedDistance > 0.0 ? 1.0 : 0.0;
        const absDistance = Math.abs(signedDistance);
        const directionFactor = signedDistance < 0.0 ? -1.0 : 1.0;
        const availableLength = this.curveLengthBetweenFractions(startFraction, limitFraction); // that is always positive
        if (availableLength < absDistance && !allowExtension)
            return CurveLocationDetail_1.CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, limitFraction, signedDistance, result);
        const fractionStep = absDistance / availableLength;
        let fractionB = Geometry_1.Geometry.interpolate(startFraction, fractionStep, limitFraction);
        let fractionA = startFraction;
        let distanceA = 0.0;
        const tol = 1.0e-12 * availableLength;
        let numConverged = 0;
        const tangent = Ray3d_1.Ray3d.createXAxis();
        // on each loop entry:
        // fractionA is the most recent endOfInterval.  (It may have been reached by a mixture of forward and backward step.)
        // distanceA is the distance to (the point at) fractionA
        // fractionB is the next end fraction
        for (let iterations = 0; iterations < 10; iterations++) {
            const distanceAB = this.curveLengthBetweenFractions(fractionA, fractionB);
            const directionAB = fractionB > fractionA ? directionFactor : -directionFactor;
            const distance0B = distanceA + directionAB * distanceAB;
            const distanceError = absDistance - distance0B;
            if (Math.abs(distanceError) < tol) {
                numConverged++;
                if (numConverged > 1)
                    break;
            }
            else {
                numConverged = 0;
            }
            this.fractionToPointAndDerivative(fractionB, tangent);
            const tangentMagnitude = tangent.direction.magnitude();
            fractionA = fractionB;
            fractionB = fractionA + directionFactor * distanceError / tangentMagnitude;
            if (fractionA === fractionB) { // YES -- that is an exact equality test.   When it happens, there's no need for confirming with another iteration.
                numConverged = 100;
                break;
            }
            distanceA = distance0B;
        }
        if (numConverged > 1)
            return CurveLocationDetail_1.CurveLocationDetail.createConditionalMoveSignedDistance(false, this, startFraction, fractionB, signedDistance, result);
        result = CurveLocationDetail_1.CurveLocationDetail.createCurveEvaluatedFraction(this, startFraction, result);
        result.a = 0.0;
        result.curveSearchStatus = CurveLocationDetail_1.CurveSearchStatus.error;
        return result;
    }
    /**
     * * Returns true if the curve's fraction queries extend beyond 0..1.
     * * Base class default implementation returns false.
     * * These class (and perhaps others in the future) will return true:
     *   * LineSegment3d
     *   * LineString3d
     *   * Arc3d
     */
    get isExtensibleFractionSpace() { return false; }
    /** Search for the curve point that is closest to the spacePoint.
     *
     * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.
     * * Since CurvePrimitive should always have start and end available as candidate points, this method should always succeed
     * @param spacePoint point in space
     * @param extend true to extend the curve (if possible), false for no extend, single CurveExtendOptions (for both directions), or array of distinct CurveExtendOptions for start and end.
     * @returns Returns a CurveLocationDetail structure that holds the details of the close point.
     */
    closestPoint(spacePoint, extend) {
        const strokeHandler = new ClosestPointStrokeHandler(spacePoint, extend);
        this.emitStrokableParts(strokeHandler);
        return strokeHandler.claimResult();
    }
    /**
     * Find intervals of this curvePrimitive that are interior to a clipper
     * @param clipper clip structure (e.g. clip planes)
     * @param announce (optional) function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     * @returns true if any "in" segments are announced.
     */
    announceClipIntervals(_clipper, _announce) {
        // DEFAULT IMPLEMENTATION -- no interior parts
        return false;
    }
    /** Return (if possible) a curve primitive which is a portion of this curve.
     * @param _fractionA [in] start fraction
     * @param _fractionB [in] end fraction
     */
    clonePartialCurve(_fractionA, _fractionB) {
        return undefined;
    }
    /**
     * * If the curve primitive has distance-along-curve strictly proportional to curve fraction, return true
     * * If distance-along-the-curve is not proportional, return undefined.
     * * When defined, the scale factor is always the length of the curve.
     * * This scale factor is typically available for these curve types:
     * * * All `LineSegment3d`
     * * * Arc3d which is a true circular arc (axes perpendicular and of equal length).
     * * * CurveChainWithDistanceIndex
     * * This scale factor is undefined for these curve types:
     * * * Arc3d which is a true ellipse, i.e. unequal lengths of defining vectors or non-perpendicular defining vectors.
     * * * bspline and bezier curves
     * @returns scale factor or undefined
     */
    getFractionToDistanceScale() { return undefined; }
    /**
     * Compute intersections with a plane.
     * * The intersections are appended to the result array.
     * * The base class implementation emits strokes to an AppendPlaneIntersectionStrokeHandler object, which uses a Newton iteration to get
     *     high-accuracy intersection points within strokes.
     * * Derived classes should override this default implementation if there are easy analytic solutions.
     * * Derived classes are free to implement extended intersections (e.g. arc!!!)
     * @param plane The plane to be intersected.
     * @param result Array to receive intersections
     * @returns Return the number of CurveLocationDetail's added to the result array.
     */
    appendPlaneIntersectionPoints(plane, result) {
        const strokeHandler = new AppendPlaneIntersectionStrokeHandler(plane, result);
        const n0 = result.length;
        this.emitStrokableParts(strokeHandler);
        return result.length - n0;
    }
    /**
     * Examine contents of an array of CurveLocationDetail.
     * Filter the intersections according to the parameters.
     * @param allowExtend if false, remove points on the extension.
     * @param applySnappedCoordinates if true, change the stored fractions and coordinates to exact end values.  Otherwise
     *     use the exact values only for purpose of updating the curveIntervalRole.
     * @param startEndFractionTolerance if nonzero, adjust fraction to 0 or 1 with this tolerance.
     * @param startEndXYZTolerance if nonzero, adjust to endpoint with this tolerance.
     * @internal
     */
    static snapAndRestrictDetails(details, allowExtend = true, applySnappedCoordinates = false, startEndFractionTolerance = Geometry_1.Geometry.smallAngleRadians, startEndXYZTolerance = Geometry_1.Geometry.smallMetricDistance) {
        const n0 = details.length;
        let acceptIndex = 0;
        const point0 = Point3dVector3d_1.Point3d.create();
        const point1 = Point3dVector3d_1.Point3d.create();
        let snappedCoordinates;
        for (let candidateIndex = 0; candidateIndex < n0; candidateIndex++) {
            snappedCoordinates = undefined;
            const detail = details[candidateIndex];
            let fraction = detail.fraction;
            let accept = allowExtend || Geometry_1.Geometry.isIn01(fraction);
            if (detail.curve) {
                detail.curve.startPoint(point0);
                detail.curve.endPoint(point1);
            }
            if (startEndFractionTolerance > 0) {
                if (Math.abs(fraction) < startEndFractionTolerance) {
                    fraction = 0.0;
                    accept = true;
                    detail.intervalRole = CurveLocationDetail_1.CurveIntervalRole.isolatedAtVertex;
                    snappedCoordinates = point0;
                }
                if (Math.abs(fraction - 1.0) < startEndFractionTolerance) {
                    fraction = 1.0;
                    accept = true;
                    detail.intervalRole = CurveLocationDetail_1.CurveIntervalRole.isolatedAtVertex;
                    snappedCoordinates = point1;
                    if (detail.curve)
                        snappedCoordinates = detail.curve.startPoint(point1);
                }
            }
            if (startEndXYZTolerance > 0 && detail.curve !== undefined) {
                // REMARK: always test both endpoints.   If there is a cyclic fraction space, an intersection marked as "after" the end might have wrapped all the way to the beginning.
                if (detail.point.distance(point0) <= startEndXYZTolerance) {
                    fraction = 0.0;
                    detail.intervalRole = CurveLocationDetail_1.CurveIntervalRole.isolatedAtVertex;
                    snappedCoordinates = point0;
                }
                else if (detail.point.distance(point1) <= startEndXYZTolerance) {
                    fraction = 1.0;
                    detail.intervalRole = CurveLocationDetail_1.CurveIntervalRole.isolatedAtVertex;
                    snappedCoordinates = point1;
                }
            }
            if (accept) {
                if (applySnappedCoordinates) {
                    detail.fraction = fraction;
                    if (snappedCoordinates !== undefined)
                        detail.point.setFrom(snappedCoordinates);
                }
                if (acceptIndex < candidateIndex)
                    details[acceptIndex] = detail;
                acceptIndex++;
            }
        }
        if (acceptIndex < n0)
            details.length = acceptIndex;
    }
    /** return the startPoint of the primitive.  The default implementation returns fractionToPoint (0.0) */
    startPoint(result) { return this.fractionToPoint(0.0, result); }
    /** return the end point of the primitive. The default implementation returns fractionToPoint(1.0) */
    endPoint(result) { return this.fractionToPoint(1.0, result); }
    /**
     * attach StrokeCountMap structure to this primitive (and recursively to any children)
     * * Base class implementation (here) gets the simple count from computeStrokeCountForOptions and attaches it.
     * * LineString3d, arc3d, BezierCurve3d, BezierCurve3dH accept that default.
     * * Subdivided primitives (linestring, bspline curve) implement themselves and attach a StrokeCountMap containing the
     *       total count, and also containing an array of StrokeCountMap per component.
     * * For CurvePrimitiveWithDistanceIndex, the top level gets (only) a total count, and each child gets
     *       its own StrokeCountMap with appropriate structure.
     * @param options StrokeOptions that determine count
     * @param parentStrokeMap optional map from parent.  Its count, curveLength, and a1 values are increased with count and distance from this primitive.
     * @return sum of `a0+this.curveLength()`, for use as `a0` of successor in chain.
     */
    computeAndAttachRecursiveStrokeCounts(options, parentMap) {
        const n = this.computeStrokeCountForOptions(options);
        const a = this.curveLength();
        CurvePrimitive.installStrokeCountMap(this, StrokeCountMap_1.StrokeCountMap.createWithCurvePrimitive(this, n, a, 0, a), parentMap);
    }
    /**
     * * evaluate strokes at fractions indicated in a StrokeCountMap.
     *   * Base class implementation (here) gets the simple count from computeStrokeCountForOptions and strokes at uniform fractions.
     *   * LineString3d, arc3d, BezierCurve3d, BezierCurve3dH accept that default.
     *   * Subdivided primitives (linestring, bspline curve) implement themselves and evaluate within components.
     *   * CurvePrimitiveWithDistanceIndex recurses to its children.
     * * if packedFraction and packedDerivative arrays are present in the LineString3d, fill them.
     * @param map = stroke count data.
     * @param linestring = receiver linestring.
     * @return number of strokes added.  0 if any errors matching the map to the curve primitive.
     */
    addMappedStrokesToLineString3D(map, linestring) {
        const numPoint0 = linestring.numPoints();
        if (map.primitive && map.primitive === this && map.numStroke > 0) {
            for (let i = 0; i <= map.numStroke; i++) {
                const fraction = i / map.numStroke;
                linestring.appendFractionToPoint(this, fraction);
            }
        }
        return linestring.numPoints() - numPoint0;
    }
    /**
     * final install step to save curveMap in curve.  If parentMap is given, update its length, count, and a1 fields
     * @param curve curve to receive the annotation
     * @param map
     * @param parentMap
     */
    static installStrokeCountMap(curve, curveMap, parentMap) {
        if (parentMap)
            parentMap.addToCountAndLength(curveMap.numStroke, curveMap.curveLength);
        curve.strokeData = curveMap;
    }
}
exports.CurvePrimitive = CurvePrimitive;
/** Intermediate class for managing the parentCurve announcements from an IStrokeHandler */
class NewtonRotRStrokeHandler extends Newton_1.NewtonEvaluatorRtoR {
    constructor() {
        super();
        this._parentCurvePrimitive = undefined;
    }
    /** retain the parentCurvePrimitive.
     * * Calling this method tells the handler that the parent curve is to be used for detail searches.
     * * Example: Transition spiral search is based on linestring first, then the exact spiral.
     * * Example: CurveChainWithDistanceIndex does NOT do this announcement -- the constituents act independently.
     */
    startParentCurvePrimitive(curve) { this._parentCurvePrimitive = curve; }
    /** Forget the parentCurvePrimitive */
    endParentCurvePrimitive(_curve) { this._parentCurvePrimitive = undefined; }
}
class AppendPlaneIntersectionStrokeHandler extends NewtonRotRStrokeHandler {
    constructor(plane, intersections) {
        super();
        this._fractionA = 0;
        this._functionA = 0;
        // private derivativeA: number;   <---- Not currently used
        this._functionB = 0;
        this._fractionB = 0;
        this._derivativeB = 0;
        this._numThisCurve = 0;
        this._plane = plane;
        this._intersections = intersections;
        this.startCurvePrimitive(undefined);
        this._ray = Ray3d_1.Ray3d.createZero();
        this._newtonSolver = new Newton_1.Newton1dUnboundedApproximateDerivative(this);
    }
    // Return the first defined curve among: this.parentCurvePrimitive, this.curve;
    effectiveCurve() {
        if (this._parentCurvePrimitive)
            return this._parentCurvePrimitive;
        return this._curve;
    }
    get getDerivativeB() { return this._derivativeB; } // <--- DerivativeB is not currently used anywhere. Provided getter to suppress tslint error
    startCurvePrimitive(curve) {
        this._curve = curve;
        this._fractionA = 0.0;
        this._numThisCurve = 0;
        this._functionA = 0.0;
        // this.derivativeA = 0.0;
    }
    endCurvePrimitive() { }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        this.startCurvePrimitive(cp);
        if (numStrokes < 1)
            numStrokes = 1;
        const df = 1.0 / numStrokes;
        for (let i = 0; i <= numStrokes; i++) {
            const fraction = Geometry_1.Geometry.interpolate(fraction0, i * df, fraction1);
            cp.fractionToPointAndDerivative(fraction, this._ray);
            this.announcePointTangent(this._ray.origin, fraction, this._ray.direction);
        }
    }
    announceSegmentInterval(_cp, point0, point1, _numStrokes, fraction0, fraction1) {
        const h0 = this._plane.altitude(point0);
        const h1 = this._plane.altitude(point1);
        if (h0 * h1 > 0.0)
            return;
        const fraction01 = BezierPolynomials_1.Order2Bezier.solveCoffs(h0, h1);
        // let numIntersection = 0;
        if (fraction01 !== undefined) {
            // numIntersection++;
            const fraction = Geometry_1.Geometry.interpolate(fraction0, fraction01, fraction1);
            this._newtonSolver.setX(fraction);
            if (this._newtonSolver.runIterations()) {
                this.announceSolutionFraction(this._newtonSolver.getX());
            }
            // this.intersections.push(CurveLocationDetail.createCurveFractionPoint(cp, fraction, cp.fractionToPoint(fraction)));
        }
    }
    announceSolutionFraction(fraction) {
        const curve = this.effectiveCurve();
        if (curve) {
            this._ray = curve.fractionToPointAndDerivative(fraction, this._ray);
            this._intersections.push(CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(curve, fraction, this._ray.origin));
        }
    }
    evaluate(fraction) {
        const curve = this.effectiveCurve();
        if (!curve)
            return false;
        this.currentF = this._plane.altitude(curve.fractionToPoint(fraction));
        return true;
    }
    /**
     * * ASSUME both the "A" and "B"  evaluations (fraction, function, and derivative) are known.
     * * If function value changed sign between, interpolate an approximate root and improve it with
     *     the newton solver.
     */
    searchInterval() {
        if (this._functionA * this._functionB > 0)
            return;
        if (this._functionA === 0)
            this.announceSolutionFraction(this._fractionA);
        if (this._functionB === 0)
            this.announceSolutionFraction(this._fractionB);
        if (this._functionA * this._functionB < 0) {
            const fraction = Geometry_1.Geometry.inverseInterpolate(this._fractionA, this._functionA, this._fractionB, this._functionB);
            if (fraction) {
                this._newtonSolver.setX(fraction);
                if (this._newtonSolver.runIterations())
                    this.announceSolutionFraction(this._newtonSolver.getX());
            }
        }
    }
    /** Evaluate and save _functionB, _derivativeB, and _fractionB. */
    evaluateB(xyz, fraction, tangent) {
        this._functionB = this._plane.altitude(xyz);
        this._derivativeB = this._plane.velocity(tangent);
        this._fractionB = fraction;
    }
    /**
     * Announce point and tangent for evaluations.
     * * The function evaluation is saved as the "B" function point.
     * * The function point count is incremented
     * * If function point count is greater than 1, the current interval is searched.
     * * The just-evaluated point ("B") is saved as the "old" ("A") evaluation point.
     * @param xyz
     * @param fraction
     * @param tangent
     */
    announcePointTangent(xyz, fraction, tangent) {
        this.evaluateB(xyz, fraction, tangent);
        if (this._numThisCurve++ > 0)
            this.searchInterval();
        this._functionA = this._functionB;
        this._fractionA = this._fractionB;
        this._fractionA = this._fractionB;
    }
}
class CurveLengthContext {
    constructor(fraction0 = 0.0, fraction1 = 1.0, numGaussPoints = 5) {
        this.startCurvePrimitive(undefined);
        this._summedLength = 0.0;
        this._ray = Ray3d_1.Ray3d.createZero();
        if (fraction0 < fraction1) {
            this._fraction0 = fraction0;
            this._fraction1 = fraction1;
        }
        else {
            this._fraction0 = fraction1;
            this._fraction1 = fraction0;
        }
        this._gaussMapper = new Quadrature_1.GaussMapper(numGaussPoints);
    }
    tangentMagnitude(fraction) {
        this._ray = this._curve.fractionToPointAndDerivative(fraction, this._ray);
        return this._ray.direction.magnitude();
    }
    getSum() { return this._summedLength; }
    startCurvePrimitive(curve) {
        this._curve = curve;
    }
    startParentCurvePrimitive(_curve) { }
    endParentCurvePrimitive(_curve) { }
    endCurvePrimitive() { }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        if (fraction0 < this._fraction0)
            fraction0 = this._fraction0;
        if (fraction1 > this._fraction1)
            fraction1 = this._fraction1;
        if (fraction1 > fraction0) {
            this.startCurvePrimitive(cp);
            if (numStrokes < 1)
                numStrokes = 1;
            const df = 1.0 / numStrokes;
            for (let i = 1; i <= numStrokes; i++) {
                const fractionA = Geometry_1.Geometry.interpolate(fraction0, (i - 1) * df, fraction1);
                const fractionB = i === numStrokes ? fraction1 : Geometry_1.Geometry.interpolate(fraction0, (i) * df, fraction1);
                const numGauss = this._gaussMapper.mapXAndW(fractionA, fractionB);
                for (let k = 0; k < numGauss; k++) {
                    this._summedLength += this._gaussMapper.gaussW[k] * this.tangentMagnitude(this._gaussMapper.gaussX[k]);
                }
            }
        }
    }
    announceSegmentInterval(_cp, point0, point1, _numStrokes, fraction0, fraction1) {
        const segmentLength = point0.distance(point1);
        if (this._fraction0 <= fraction0 && fraction1 <= this._fraction1)
            this._summedLength += segmentLength;
        else {
            let g0 = fraction0;
            let g1 = fraction1;
            if (g0 < this._fraction0)
                g0 = this._fraction0;
            if (g1 > this._fraction1)
                g1 = this._fraction1;
            if (g1 > g0) {
                this._summedLength += segmentLength * (g1 - g0) / (fraction1 - fraction0);
            }
        }
    }
    announcePointTangent(_xyz, _fraction, _tangent) {
        // uh oh -- need to retain point for next interval
    }
}
// context for searching for closest point .. .
class ClosestPointStrokeHandler extends NewtonRotRStrokeHandler {
    constructor(spacePoint, extend) {
        super();
        this._fractionA = 0;
        this._functionA = 0;
        this._functionB = 0;
        this._fractionB = 0;
        this._numThisCurve = 0;
        this._spacePoint = spacePoint;
        this._workPoint = Point3dVector3d_1.Point3d.create();
        this._workRay = Ray3d_1.Ray3d.createZero();
        this._closestPoint = undefined;
        this._extend = extend;
        this.startCurvePrimitive(undefined);
        this._newtonSolver = new Newton_1.Newton1dUnboundedApproximateDerivative(this);
    }
    claimResult() {
        if (this._closestPoint) {
            this._newtonSolver.setX(this._closestPoint.fraction);
            this._curve = this._closestPoint.curve;
            if (this._newtonSolver.runIterations()) {
                let fraction = this._newtonSolver.getX();
                fraction = CurveExtendMode_1.CurveExtendOptions.correctFraction(this._extend, fraction);
                this.announceSolutionFraction(fraction);
            }
        }
        return this._closestPoint;
    }
    startCurvePrimitive(curve) {
        this._curve = curve;
        this._fractionA = 0.0;
        this._numThisCurve = 0;
        this._functionA = 0.0;
    }
    endCurvePrimitive() { }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        this.startCurvePrimitive(cp);
        if (numStrokes < 1)
            numStrokes = 1;
        const df = 1.0 / numStrokes;
        for (let i = 0; i <= numStrokes; i++) {
            const fraction = Geometry_1.Geometry.interpolate(fraction0, i * df, fraction1);
            cp.fractionToPointAndDerivative(fraction, this._workRay);
            this.announceRay(fraction, this._workRay);
        }
    }
    announceCandidate(cp, fraction, point) {
        const distance = this._spacePoint.distance(point);
        if (this._closestPoint && distance > this._closestPoint.a)
            return;
        this._closestPoint = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(cp, fraction, point, this._closestPoint);
        this._closestPoint.a = distance;
        if (this._parentCurvePrimitive !== undefined)
            this._closestPoint.curve = this._parentCurvePrimitive;
    }
    announceSegmentInterval(cp, point0, point1, _numStrokes, fraction0, fraction1) {
        let localFraction = this._spacePoint.fractionOfProjectionToLine(point0, point1, 0.0);
        // only consider extending the segment if the immediate caller says we are at endpoints ...
        if (!this._extend)
            localFraction = Geometry_1.Geometry.clampToStartEnd(localFraction, 0.0, 1.0);
        else {
            if (fraction0 !== 0.0)
                localFraction = Math.max(localFraction, 0.0);
            if (fraction1 !== 1.0)
                localFraction = Math.min(localFraction, 1.0);
        }
        this._workPoint = point0.interpolate(localFraction, point1);
        const globalFraction = Geometry_1.Geometry.interpolate(fraction0, localFraction, fraction1);
        this.announceCandidate(cp, globalFraction, this._workPoint);
    }
    searchInterval() {
        if (this._functionA * this._functionB > 0)
            return;
        if (this._functionA === 0)
            this.announceSolutionFraction(this._fractionA);
        if (this._functionB === 0)
            this.announceSolutionFraction(this._fractionB);
        if (this._functionA * this._functionB < 0) {
            const fraction = Geometry_1.Geometry.inverseInterpolate(this._fractionA, this._functionA, this._fractionB, this._functionB);
            if (fraction) {
                this._newtonSolver.setX(fraction);
                if (this._newtonSolver.runIterations())
                    this.announceSolutionFraction(this._newtonSolver.getX());
            }
        }
    }
    evaluateB(fractionB, dataB) {
        this._functionB = dataB.dotProductToPoint(this._spacePoint);
        this._fractionB = fractionB;
    }
    announceSolutionFraction(fraction) {
        if (this._curve)
            this.announceCandidate(this._curve, fraction, this._curve.fractionToPoint(fraction));
    }
    evaluate(fraction) {
        let curve = this._curve;
        if (this._parentCurvePrimitive)
            curve = this._parentCurvePrimitive;
        if (curve) {
            this._workRay = curve.fractionToPointAndDerivative(fraction, this._workRay);
            this.currentF = this._workRay.dotProductToPoint(this._spacePoint);
            return true;
        }
        return false;
    }
    announceRay(fraction, data) {
        this.evaluateB(fraction, data);
        if (this._numThisCurve++ > 0)
            this.searchInterval();
        this._functionA = this._functionB;
        this._fractionA = this._fractionB;
        this._fractionA = this._fractionB;
    }
    announcePointTangent(point, fraction, tangent) {
        this._workRay.set(point, tangent);
        this.announceRay(fraction, this._workRay);
    }
}


/***/ }),

/***/ "./lib/curve/CurveProcessor.js":
/*!*************************************!*\
  !*** ./lib/curve/CurveProcessor.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
/* tslint:disable:variable-name no-empty*/
/** base class for detailed traversal of curve artifacts.
 * * This recurses to children in the quickest way (no records of path)
 * * Use the RecursiveCurveProcessorWithStack to record the path along the visit.
 * @public
 */
class RecursiveCurveProcessor {
    constructor() {
    }
    /** process error content */
    announceUnexpected(_data, _indexInParent) { }
    /** process a leaf primitive. */
    announceCurvePrimitive(_data, _indexInParent = -1) { }
    /** announce a path (recurse to children) */
    announcePath(data, _indexInParent = -1) {
        let i = 0;
        for (const curve of data.children)
            this.announceCurvePrimitive(curve, i++);
    }
    /** announce a loop (recurse to children) */
    announceLoop(data, _indexInParent = -1) {
        let i = 0;
        for (const curve of data.children)
            this.announceCurvePrimitive(curve, i++);
    }
    /** announce beginning or end of loops in a parity region */
    announceParityRegion(data, _indexInParent = -1) {
        let i = 0;
        for (const loop of data.children)
            this.announceLoop(loop, i++);
    }
    /** announce beginning or end of a parity region */
    announceUnionRegion(data, _indexInParent = -1) {
        let i = 0;
        for (const child of data.children) {
            child.announceToCurveProcessor(this, i++);
        }
    }
    /** announce a bag of curves.
     * * The default implementation visits each child and calls the appropriate dispatch to
     * * `this.announceCurvePrimitive(child)`
     * * `child.announceToCurveProcessor(this)`
     */
    announceBagOfCurves(data, _indexInParent = -1) {
        for (const child of data.children) {
            if (child instanceof CurvePrimitive_1.CurvePrimitive)
                this.announceCurvePrimitive(child);
            else
                child.announceToCurveProcessor(this);
        }
    }
}
exports.RecursiveCurveProcessor = RecursiveCurveProcessor;
/** base class for detailed traversal of curve artifacts
 * * During recursion,  maintains a stack that shows complete path to each artifact.
 * * Use the QuickRecursiveCurveProcessor to visit without recording the path.
 * @public
 */
class RecursiveCurveProcessorWithStack extends RecursiveCurveProcessor {
    constructor() {
        super();
        this._stack = [];
    }
    /** Push `data` onto the stack so its status is available during processing of children.
     * * Called when `data` is coming into scope.
     */
    enter(data) { this._stack.push(data); }
    /** Pop the stack
     * * called when the top of the stack goes out of scope
     */
    leave() { return this._stack.pop(); }
    /** process error content */
    announceUnexpected(_data, _indexInParent) { }
    /** process a leaf primitive. */
    announceCurvePrimitive(_data, _indexInParent = -1) { }
    /** announce a path (recurse to children) */
    announcePath(data, indexInParent = -1) {
        this.enter(data);
        super.announcePath(data, indexInParent);
        this.leave();
    }
    /** announce a loop (recurse to children) */
    announceLoop(data, indexInParent = -1) {
        this.enter(data);
        super.announceLoop(data, indexInParent);
        this.leave();
    }
    /** announce beginning or end of loops in a parity region */
    announceParityRegion(data, _indexInParent = -1) {
        this.enter(data);
        let i = 0;
        for (const loop of data.children)
            this.announceLoop(loop, i++);
        this.leave();
    }
    /** announce beginning or end of a parity region */
    announceUnionRegion(data, indexInParent = -1) {
        this.enter(data);
        super.announceUnionRegion(data, indexInParent);
        this.leave();
    }
    /**
     * Announce members of an unstructured collection.
     * * push the collection reference on the stack
     * * announce children
     * * pop the stack
     * @param data the collection
     * @param _indexInParent index where the collection appears in its parent.
     */
    announceBagOfCurves(data, _indexInParent = -1) {
        this.enter(data);
        let i = 0;
        for (const child of data.children) {
            if (child instanceof CurvePrimitive_1.CurvePrimitive)
                this.announceCurvePrimitive(child, i++);
            else
                child.announceToCurveProcessor(this);
        }
        this.leave();
    }
}
exports.RecursiveCurveProcessorWithStack = RecursiveCurveProcessorWithStack;


/***/ }),

/***/ "./lib/curve/CurveWireMomentsXYZ.js":
/*!******************************************!*\
  !*** ./lib/curve/CurveWireMomentsXYZ.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
// import { Geometry, Angle, AngleSweep } from "../Geometry";
const MomentData_1 = __webpack_require__(/*! ../geometry4d/MomentData */ "./lib/geometry4d/MomentData.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
const Quadrature_1 = __webpack_require__(/*! ../numerics/Quadrature */ "./lib/numerics/Quadrature.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * Class to visit curve primitives and accumulate wire moment integrations.
 * @internal
 */
class CurveWireMomentsXYZ {
    constructor(numGaussPoints = 5) {
        this._activeMomentData = MomentData_1.MomentData.create();
        this._activeMomentData.needOrigin = true;
        this._gaussMapper = new Quadrature_1.GaussMapper(numGaussPoints);
    }
    get momentData() { return this._activeMomentData; }
    startParentCurvePrimitive(_cp) { }
    startCurvePrimitive(_cp) { }
    endCurvePrimitive(_cp) { }
    endParentCurvePrimitive(_cp) { }
    announceIntervalForUniformStepStrokes(cp, numStrokes, fraction0, fraction1) {
        this.startCurvePrimitive(cp);
        if (numStrokes < 1)
            numStrokes = 1;
        const df = 1.0 / numStrokes;
        let scaleFactor, fraction;
        for (let i = 1; i <= numStrokes; i++) {
            const fractionA = Geometry_1.Geometry.interpolate(fraction0, (i - 1) * df, fraction1);
            const fractionB = i === numStrokes ? fraction1 : Geometry_1.Geometry.interpolate(fraction0, (i) * df, fraction1);
            const numGauss = this._gaussMapper.mapXAndW(fractionA, fractionB);
            for (let k = 0; k < numGauss; k++) {
                fraction = this._gaussMapper.gaussX[k];
                const ray = cp.fractionToPointAndDerivative(fraction);
                scaleFactor = this._gaussMapper.gaussW[k] * ray.direction.magnitude();
                this._activeMomentData.accumulateScaledOuterProduct(ray.origin, scaleFactor);
            }
        }
    }
    announceSegmentInterval(_cp, point0, point1, _numStrokes, _fraction0, _fraction1) {
        this._activeMomentData.accumulateLineMomentsXYZ(point0, point1);
    }
    announcePointTangent(_xyz, _fraction, _tangent) {
        // umm ... this should not happen.  We need to know intervals. The other functions should have prevented this.
    }
    /** Recurse to leaf-level primitives */
    visitLeaves(root) {
        if (root instanceof CurvePrimitive_1.CurvePrimitive)
            root.emitStrokableParts(this);
        else if (root instanceof CurveCollection_1.CurveCollection) {
            if (root.children !== undefined)
                for (const child of root.children) {
                    this.visitLeaves(child);
                }
        }
    }
}
exports.CurveWireMomentsXYZ = CurveWireMomentsXYZ;


/***/ }),

/***/ "./lib/curve/GeometryQuery.js":
/*!************************************!*\
  !*** ./lib/curve/GeometryQuery.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
/** Queries to be supported by Curve, Surface, and Solid objects */
/**
 * * `GeometryQuery` is an abstract base class with (abstract) methods for querying curve, solid primitive, mesh, and bspline surfaces
 * @public
 */
class GeometryQuery {
    /** return the range of the entire (tree) GeometryQuery */
    range(transform, result) {
        if (result)
            result.setNull();
        const range = result ? result : Range_1.Range3d.createNull();
        this.extendRange(range, transform);
        return range;
    }
    /** try to move the geometry by dx,dy,dz */
    tryTranslateInPlace(dx, dy = 0.0, dz = 0.0) {
        return this.tryTransformInPlace(Transform_1.Transform.createTranslationXYZ(dx, dy, dz));
    }
    /** return GeometryQuery children for recursive queries.
     *
     * * leaf classes do not need to implement.
     */
    get children() { return undefined; }
    /** test for exact structure and nearly identical geometry.
     *
     * *  Leaf classes must implement !!!
     * *  base class implementation recurses through children.
     * *  base implementation is complete for classes with children and no properties.
     * *  classes with both children and properties must implement for properties, call super for children.
     */
    isAlmostEqual(other) {
        if (this.isSameGeometryClass(other)) {
            const childrenA = this.children;
            const childrenB = other.children;
            if (childrenA && childrenB) {
                if (childrenA.length !== childrenB.length)
                    return false;
                for (let i = 0; i < childrenA.length; i++) {
                    if (!childrenA[i].isAlmostEqual(childrenB[i]))
                        return false;
                }
                return true;
            }
            else if (childrenA || childrenB) { // CurveCollections start with empty arrays for children.  So these null pointer cases are never reached.
                return false; // plainly different .
            }
            else {
                // both children null. call it equal?   This class should probably have implemented.
                return true;
            }
        }
        return false;
    }
}
exports.GeometryQuery = GeometryQuery;


/***/ }),

/***/ "./lib/curve/LineSegment3d.js":
/*!************************************!*\
  !*** ./lib/curve/LineSegment3d.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const BezierPolynomials_1 = __webpack_require__(/*! ../numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const CurveExtendMode_1 = __webpack_require__(/*! ./CurveExtendMode */ "./lib/curve/CurveExtendMode.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
/* tslint:disable:variable-name no-empty*/
/**
 * A LineSegment3d is:
 *
 * * A 3d line segment represented by its start and end coordinates
 *   * startPoint
 *   * endPoint
 * * The segment is parameterized with fraction 0 at the start and fraction 1 at the end, i.e. either of these equivalent forms to map fraction `f` to a point `X(f)`
 *   *  `X(f) = startPoint + f * (endPoint - startPoint)`
 *   * `X(f) = (1-f)*startPoint  + f * endPoint`
 * @public
 */
class LineSegment3d extends CurvePrimitive_1.CurvePrimitive {
    /**
     * CAPTURE point references as a `LineSegment3d`
     * @param point0
     * @param point1
     */
    constructor(point0, point1) {
        super();
        /** String name for schema properties */
        this.curvePrimitiveType = "lineSegment";
        this._point0 = point0;
        this._point1 = point1;
    }
    /** test if `other` is of class `LineSegment3d` */
    isSameGeometryClass(other) { return other instanceof LineSegment3d; }
    /** Return REFERENCE to the start point of this segment.
     * * (This is distinct from the `CurvePrimitive` abstract method `endPoint()` which creates a returned point
     */
    get point0Ref() { return this._point0; }
    /** Return REFERENCE to the end point of this segment.
     * * (This is distinct from the `CurvePrimitive` abstract method `endPoint()` which creates a returned point
     */
    get point1Ref() { return this._point1; }
    /**
     * A LineSegment3d extends along its infinite line.
     */
    get isExtensibleFractionSpace() { return true; }
    /** Set the start and endpoints by capturing input references. */
    setRefs(point0, point1) { this._point0 = point0; this._point1 = point1; }
    /** Set the start and endpoints by cloning the input parameters. */
    set(point0, point1) { this._point0 = point0.clone(); this._point1 = point1.clone(); }
    /** copy (clone) data from other */
    setFrom(other) { this._point0.setFrom(other._point0); this._point1.setFrom(other._point1); }
    /** Return a (clone of) the start point. (This is NOT a reference to the stored start point) */
    startPoint(result) {
        if (result) {
            result.setFrom(this._point0);
            return result;
        }
        return this._point0.clone();
    }
    /** Return a (clone of) the end point. (This is NOT a reference to the stored end point) */
    endPoint(result) {
        if (result) {
            result.setFrom(this._point1);
            return result;
        }
        return this._point1.clone();
    }
    /** Return the point and derivative vector at fractional position along the line segment. */
    fractionToPointAndDerivative(fraction, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        result.direction.setStartEnd(this._point0, this._point1);
        this._point0.interpolate(fraction, this._point1, result.origin);
        return result;
    }
    /** Construct a plane with
     * * origin at the fractional position along the line segment
     * * x axis is the first derivative, i.e. along the line segment
     * * y axis is the second derivative, i.e. 000
     */
    fractionToPointAnd2Derivatives(fraction, result) {
        result = result ? result : Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
        result.vectorU.setStartEnd(this._point0, this._point1);
        result.vectorV.set(0, 0, 0);
        this._point0.interpolate(fraction, this._point1, result.origin);
        return result;
    }
    /** Clone the LineSegment3d */
    clone() { return LineSegment3d.create(this._point0, this._point1); }
    /** Clone and apply transform to the clone. */
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    /** Create with start and end points.  The point contents are cloned into the LineSegment3d. */
    static create(point0, point1, result) {
        if (result) {
            result.set(point0, point1); // and this will clone them !!
            return result;
        }
        return new LineSegment3d(point0.clone(), point1.clone());
    }
    /** Create with start and end points.  The point contents are CAPTURED into the result */
    static createCapture(point0, point1) {
        return new LineSegment3d(point0, point1);
    }
    /** create a LineSegment3d from xy coordinates of start and end, with common z.
     * @param x0 start point x coordinate.
     * @param y0 start point y coordinate.
     * @param x1 end point x coordinate.
     * @param y1 end point y coordinate.
     * @param z z coordinate to use for both points.
     * @param result optional existing LineSegment to be reinitialized.
     */
    static createXYXY(x0, y0, x1, y1, z = 0, result) {
        if (result) {
            result._point0.set(x0, y0, z);
            result._point1.set(x1, y1, z);
            return result;
        }
        return new LineSegment3d(Point3dVector3d_1.Point3d.create(x0, y0, z), Point3dVector3d_1.Point3d.create(x1, y1, z));
    }
    /** create a LineSegment3d from xy coordinates of start and end, with common z.
     * @param x0 start point x coordinate.
     * @param y0 start point y coordinate.
     * @param x1 end point x coordinate.
     * @param y1 end point y coordinate.
     * @param z z coordinate to use for both points.
     * @param result optional existing LineSegment to be reinitialized.
     */
    static createXYZXYZ(x0, y0, z0, x1, y1, z1, result) {
        if (result) {
            result._point0.set(x0, y0, z0);
            result._point1.set(x1, y1, z1);
            return result;
        }
        return new LineSegment3d(Point3dVector3d_1.Point3d.create(x0, y0, z0), Point3dVector3d_1.Point3d.create(x1, y1, z1));
    }
    /** Return the point at fractional position along the line segment. */
    fractionToPoint(fraction, result) { return this._point0.interpolate(fraction, this._point1, result); }
    /** Return the length of the segment. */
    curveLength() { return this._point0.distance(this._point1); }
    /** Return the length of the partial segment between fractions. */
    curveLengthBetweenFractions(fraction0, fraction1) {
        return Math.abs(fraction1 - fraction0) * this._point0.distance(this._point1);
    }
    /** Return the length of the segment. */
    quickLength() { return this.curveLength(); }
    /**
     * Returns a curve location detail with both xyz and fractional coordinates of the closest point.
     * @param spacePoint point in space
     * @param extend if false, only return points within the bounded line segment. If true, allow the point to be on the unbounded line that contains the bounded segment.
     */
    closestPoint(spacePoint, extend, result) {
        let fraction = spacePoint.fractionOfProjectionToLine(this._point0, this._point1, 0.0);
        fraction = CurveExtendMode_1.CurveExtendOptions.correctFraction(extend, fraction);
        result = CurveLocationDetail_1.CurveLocationDetail.create(this, result);
        // remark: This can be done by result.setFP (fraction, thePoint, undefined, a)
        //   but that creates a temporary point.
        result.fraction = fraction;
        this._point0.interpolate(fraction, this._point1, result.point);
        result.vectorInCurveLocationDetail = undefined;
        result.a = result.point.distance(spacePoint);
        return result;
    }
    /** swap the endpoint references. */
    reverseInPlace() {
        const a = this._point0;
        this._point0 = this._point1;
        this._point1 = a;
    }
    /** Transform the two endpoints of this LinSegment. */
    tryTransformInPlace(transform) {
        this._point0 = transform.multiplyPoint3d(this._point0, this._point0);
        this._point1 = transform.multiplyPoint3d(this._point1, this._point1);
        return true;
    }
    /** Test if both endpoints are in a plane (within tolerance) */
    isInPlane(plane) {
        return Geometry_1.Geometry.isSmallMetricDistance(plane.altitude(this._point0))
            && Geometry_1.Geometry.isSmallMetricDistance(plane.altitude(this._point1));
    }
    /** Compute points of simple (transverse) with a plane.
     * * Use isInPlane to test if the line segment is completely in the plane.
     */
    appendPlaneIntersectionPoints(plane, result) {
        const h0 = plane.altitude(this._point0);
        const h1 = plane.altitude(this._point1);
        const fraction = BezierPolynomials_1.Order2Bezier.solveCoffs(h0, h1);
        let numIntersection = 0;
        if (fraction !== undefined) {
            numIntersection++;
            const detail = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction));
            detail.intervalRole = CurveLocationDetail_1.CurveIntervalRole.isolated;
            result.push(detail);
        }
        return numIntersection;
    }
    /**
     * Extend a range to include the (optionally transformed) line segment
     * @param range range to extend
     * @param transform optional transform to apply to the end points
     */
    extendRange(range, transform) {
        if (transform) {
            range.extendTransformedPoint(transform, this._point0);
            range.extendTransformedPoint(transform, this._point1);
        }
        else {
            range.extendPoint(this._point0);
            range.extendPoint(this._point1);
        }
    }
    /**
     * Construct a line from either of these json forms:
     *
     * * object with named start and end:
     * `{startPoint: pointValue, endPoint: pointValue}`
     * * array of two point values:
     * `[pointValue, pointValue]`
     * The point values are any values accepted by the Point3d method setFromJSON.
     * @param json data to parse.
     */
    setFromJSON(json) {
        if (!json) {
            this._point0.set(0, 0, 0);
            this._point1.set(1, 0, 0);
            return;
        }
        else if (json.startPoint && json.endPoint) { // {startPoint:json point, endPoint:json point}
            this._point0.setFromJSON(json.startPoint);
            this._point1.setFromJSON(json.endPoint);
        }
        else if (Array.isArray(json)
            && json.length > 1) { // [json point, json point]
            this._point0.setFromJSON(json[0]);
            this._point1.setFromJSON(json[1]);
        }
    }
    /** A simple line segment's fraction and distance are proportional. */
    getFractionToDistanceScale() { return this.curveLength(); }
    /**
     * Place the lineSegment3d start and points in a json object
     * @return {*} [[x,y,z],[x,y,z]]
     */
    toJSON() { return [this._point0.toJSON(), this._point1.toJSON()]; }
    /** Create a new `LineSegment3d` with coordinates from json object.   See `setFromJSON` for object layout description. */
    static fromJSON(json) {
        const result = new LineSegment3d(Point3dVector3d_1.Point3d.createZero(), Point3dVector3d_1.Point3d.create());
        result.setFromJSON(json);
        return result;
    }
    /** Near equality test with `other`. */
    isAlmostEqual(other) {
        if (other instanceof LineSegment3d) {
            const ls = other;
            return this._point0.isAlmostEqual(ls._point0) && this._point1.isAlmostEqual(ls._point1);
        }
        return false;
    }
    /** Emit strokes to caller-supplied linestring */
    emitStrokes(dest, options) {
        const numStroke = this.computeStrokeCountForOptions(options);
        dest.appendFractionalStrokePoints(this, numStroke, 0.0, 1.0);
    }
    /** Emit strokes to caller-supplied handler */
    emitStrokableParts(handler, options) {
        handler.startCurvePrimitive(this);
        const numStroke = this.computeStrokeCountForOptions(options);
        handler.announceSegmentInterval(this, this._point0, this._point1, numStroke, 0.0, 1.0);
        handler.endCurvePrimitive(this);
    }
    /**
     * return the stroke count required for given options.
     * @param options StrokeOptions that determine count
     */
    computeStrokeCountForOptions(options) {
        let numStroke = 1;
        if (options) {
            if (options.maxEdgeLength)
                numStroke = options.applyMaxEdgeLength(numStroke, this.curveLength());
            numStroke = options.applyMinStrokesPerPrimitive(numStroke);
        }
        return numStroke;
    }
    /** Second step of double dispatch:  call `handler.handleLineSegment3d(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleLineSegment3d(this);
    }
    /**
     * Find intervals of this curve primitive that are interior to a clipper
     * @param clipper clip structure (e.g. clip planes)
     * @param announce function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     */
    announceClipIntervals(clipper, announce) {
        return clipper.announceClippedSegmentIntervals(0.0, 1.0, this._point0, this._point1, announce ? (fraction0, fraction1) => announce(fraction0, fraction1, this) : undefined);
    }
    /** Return (if possible) a curve primitive which is a portion of this curve.
     * @param fractionA [in] start fraction
     * @param fractionB [in] end fraction
     */
    clonePartialCurve(fractionA, fractionB) {
        return LineString3d_1.LineString3d.create(this.fractionToPoint(fractionA), this.fractionToPoint(fractionB));
    }
}
exports.LineSegment3d = LineSegment3d;


/***/ }),

/***/ "./lib/curve/LineString3d.js":
/*!***********************************!*\
  !*** ./lib/curve/LineString3d.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const GrowableXYArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYArray */ "./lib/geometry3d/GrowableXYArray.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const StrokeCountMap_1 = __webpack_require__(/*! ./Query/StrokeCountMap */ "./lib/curve/Query/StrokeCountMap.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
const PointStreaming_1 = __webpack_require__(/*! ../geometry3d/PointStreaming */ "./lib/geometry3d/PointStreaming.js");
/* tslint:disable:variable-name no-empty*/
/* Starting with baseIndex and moving index by stepDirection:
If the vector from baseIndex to baseIndex +1 crossed with vectorA can be normalized, accumulate it (scaled) to normal.
Return when successful.
(Do nothing if everything is parallel through limits of the array)
*/
function accumulateGoodUnitPerpendicular(points, vectorA, baseIndex, stepDirection, weight, normal, workVector) {
    const n = points.length;
    if (stepDirection > 0) {
        for (let i = baseIndex; i + 1 < n; i++) {
            points.vectorIndexIndex(i, i + 1, workVector);
            vectorA.crossProduct(workVector, workVector);
            if (workVector.normalizeInPlace()) {
                normal.addScaledInPlace(workVector, weight);
                return true;
            }
        }
    }
    else {
        if (baseIndex + 1 >= n)
            baseIndex = n - 2;
        for (let i = baseIndex; i >= 0; i--) {
            points.vectorIndexIndex(i, i + 1, workVector);
            workVector.crossProduct(vectorA, workVector);
            if (workVector.normalizeInPlace()) {
                normal.addScaledInPlace(workVector, weight);
                return true;
            }
        }
    }
    return false;
}
/**
 * * A LineString3d (sometimes called a PolyLine) is a sequence of xyz coordinates that are to be joined by line segments.
 * * The point coordinates are stored in a GrowableXYZArray, not as full point objects
 * * The parameterization of "fraction along" is
 *    * In a linestring with `N` segments (i.e. `N+1` points), each segment (regardless of physical length) occupies the same fraction (1/N) of the 0-to-1 fraction space.
 *    * Within segment `i`, the fraction interval `i/N` to `(i+1)/N` is mapped proportionally to the segment
 *    * Note that this `fraction` is therefore NOT fraction of true distance along.
 *       * Use `moveSignedDistanceFromFraction` to do true-length evaluations.
 * @public
 */
class LineString3d extends CurvePrimitive_1.CurvePrimitive {
    constructor(points) {
        super();
        /** String name for schema properties */
        this.curvePrimitiveType = "lineString";
        if (points)
            this._points = points;
        else
            this._points = new GrowableXYZArray_1.GrowableXYZArray();
    }
    /** test if `other` is an instance of `LineString3d` */
    isSameGeometryClass(other) { return other instanceof LineString3d; }
    /**
     * A LineString3d extends along its first and final segments.
     */
    get isExtensibleFractionSpace() { return true; }
    /** return the points array (cloned). */
    get points() { return this._points.getPoint3dArray(); }
    /** Return (reference to) point data in packed GrowableXYZArray. */
    get packedPoints() { return this._points; }
    /** Return array of fraction parameters.
     * * These Are only present during certain constructions such as faceting.
     * * When present, these fractions are fractions of some other curve being stroked, and are NOT related to the linestring fraction parameters.
     */
    get fractions() { return this._fractions; }
    /** Return the (optional) array of derivatives. These Are only present during certain constructions such as faceting. */
    get packedDerivatives() { return this._derivatives; }
    /** Return the (optional) array of uv params. These Are only present during certain constructions such as faceting. */
    get packedUVParams() { return this._uvParams; }
    /** Return the (optional) array of surface normals. These Are only present during certain constructions such as faceting. */
    get packedSurfaceNormals() { return this._surfaceNormals; }
    /** Return the (optional) array of normal indices. These Are only present during certain constructions such as faceting. */
    get normalIndices() { return this._normalIndices; }
    /** Return the (optional) array of param indices. These Are only present during certain constructions such as faceting. */
    get paramIndices() { return this._uvIndices; }
    /** Return the (optional) array of point indices. These Are only present during certain constructions such as faceting. */
    get pointIndices() { return this._pointIndices; }
    /** Clone this linestring and apply the transform to the clone points. */
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    /** Create a linestring, using flex length arg list and any typical combination of points such as
     * Point3d, Point2d, `[1,2,3]', array of any of those, or GrowableXYZArray
     */
    static create(...points) {
        const result = new LineString3d();
        result.addPoints(points);
        return result;
    }
    /** Create a linestring, capturing the given GrowableXYZArray as the points.
     * Point3d, Point2d, `[1,2,3]', array of any of those, or GrowableXYZArray
     */
    static createCapture(points) {
        return new LineString3d(points);
    }
    /** Create a linestring from `XAndY` points, with a specified z applied to all. */
    static createXY(points, z, enforceClosure = false) {
        const result = new LineString3d();
        const xyz = result._points;
        for (const xy of points) {
            xyz.pushXYZ(xy.x, xy.y, z);
        }
        if (enforceClosure && points.length > 1) {
            const distance = xyz.distanceIndexIndex(0, xyz.length - 1);
            if (distance !== undefined && distance !== 0.0) {
                if (Geometry_1.Geometry.isSameCoordinate(0, distance)) {
                    xyz.pop(); // nonzero but small distance -- to be replaced by point 0 exactly.
                    const xyzA = xyz.front();
                    xyz.push(xyzA);
                }
            }
        }
        return result;
    }
    /** Add points to the linestring.
     * Valid inputs are:
     * * a Point2d
     * * a point3d
     * * An array of 2 doubles
     * * An array of 3 doubles
     * * A GrowableXYZArray
     * * An array of any of the above
     */
    addPoints(...points) {
        this._points.pushFrom(points);
    }
    /** Add points accessed by index in a GrowableXYZArray, with a specified index step. */
    addSteppedPoints(source, pointIndex0, step, numAdd) {
        this._points.addSteppedPoints(source, pointIndex0, step, numAdd);
    }
    /**
     * Add a point to the linestring.
     * @param point
     */
    addPoint(point) {
        this._points.push(point);
    }
    /**
     * Add a point to the linestring.
     * @param point
     */
    addPointXYZ(x, y, z = 0) {
        this._points.pushXYZ(x, y, z);
    }
    /**
     * Append a fraction to the fractions array.
     * @param fraction
     */
    addFraction(fraction) {
        if (!this._fractions)
            this._fractions = new GrowableFloat64Array_1.GrowableFloat64Array();
        this._fractions.push(fraction);
    }
    /** Ensure that the fraction array exists with no fractions but at least the capacity of the point array. */
    ensureEmptyFractions() {
        const n = this.numPoints();
        if (!this._fractions) {
            this._fractions = new GrowableFloat64Array_1.GrowableFloat64Array(n);
            return this._fractions;
        }
        this._fractions.clear();
        this._fractions.ensureCapacity(n);
        return this._fractions;
    }
    /** Ensure that the parameter array exists with no points but at least the capacity of the point array. */
    ensureEmptyUVParams() {
        const n = this.numPoints();
        if (!this._uvParams) {
            this._uvParams = new GrowableXYArray_1.GrowableXYArray(n);
            return this._uvParams;
        }
        this._uvParams.clear();
        this._uvParams.ensureCapacity(n);
        return this._uvParams;
    }
    /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */
    ensureEmptySurfaceNormals() {
        const n = this.numPoints();
        if (!this._surfaceNormals) {
            this._surfaceNormals = new GrowableXYZArray_1.GrowableXYZArray(n);
            return this._surfaceNormals;
        }
        this._surfaceNormals.clear();
        this._surfaceNormals.ensureCapacity(n);
        return this._surfaceNormals;
    }
    /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */
    ensureEmptyDerivatives() {
        const n = this.numPoints();
        if (!this._derivatives) {
            this._derivatives = new GrowableXYZArray_1.GrowableXYZArray(n);
            return this._derivatives;
        }
        this._derivatives.clear();
        this._derivatives.ensureCapacity(n);
        return this._derivatives;
    }
    /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */
    ensureEmptyNormalIndices() {
        const n = this.numPoints();
        if (!this._normalIndices) {
            this._normalIndices = new GrowableFloat64Array_1.GrowableFloat64Array(n);
            return this._normalIndices;
        }
        this._normalIndices.clear();
        this._normalIndices.ensureCapacity(n);
        return this._normalIndices;
    }
    /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */
    ensureEmptyUVIndices() {
        const n = this.numPoints();
        if (!this._uvIndices) {
            this._uvIndices = new GrowableFloat64Array_1.GrowableFloat64Array(n);
            return this._uvIndices;
        }
        this._uvIndices.clear();
        this._uvIndices.ensureCapacity(n);
        return this._uvIndices;
    }
    /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */
    ensureEmptyPointIndices() {
        const n = this.numPoints();
        if (!this._pointIndices) {
            this._pointIndices = new GrowableFloat64Array_1.GrowableFloat64Array(n);
            return this._pointIndices;
        }
        this._pointIndices.clear();
        this._pointIndices.ensureCapacity(n);
        return this._pointIndices;
    }
    /**
     * Append a uv coordinate to the uvParams array
     * @param uv
     */
    addUVParam(uvParam) {
        if (!this._uvParams)
            this._uvParams = new GrowableXYArray_1.GrowableXYArray();
        this._uvParams.pushXY(uvParam.x, uvParam.y);
    }
    /**
     * Append a uv coordinate to the uvParams array
     * @param uv
     */
    addUVParamAsUV(u, v) {
        if (!this._uvParams)
            this._uvParams = new GrowableXYArray_1.GrowableXYArray();
        this._uvParams.pushXY(u, v);
    }
    /**
     * Append a derivative to the derivative array
     * @param vector
     */
    addDerivative(vector) {
        if (!this._derivatives)
            this._derivatives = new GrowableXYZArray_1.GrowableXYZArray();
        this._derivatives.push(vector);
    }
    /**
     * Append a surface normal to the surface normal array.
     * @param vector
     */
    addSurfaceNormal(vector) {
        if (!this._surfaceNormals)
            this._surfaceNormals = new GrowableXYZArray_1.GrowableXYZArray();
        this._surfaceNormals.push(vector);
    }
    /**
     * If the linestring is not already closed, add a closure point.
     */
    addClosurePoint() {
        const distance = this._points.distanceIndexIndex(0, this._points.length - 1);
        if (distance !== undefined && !Geometry_1.Geometry.isSameCoordinate(distance, 0))
            this._points.pushWrap(1);
    }
    /** Eliminate (but do not return!!) the final point of the linestring */
    popPoint() {
        this._points.pop();
    }
    /** Compute `uvParams` array as (xy parts of) a linear transform of the xyz coordinates */
    computeUVFromXYZTransform(transform) {
        this._uvParams = GrowableXYArray_1.GrowableXYArray.createFromGrowableXYZArray(this._points, transform);
    }
    /** Create the linestring for a rectangle parallel to the xy plane.
     * * The z coordinate from `point0` is used for all points.
     * * `ax` and `ay` are signed.
     * * The point sequence is:
     *    * Start at `point0`
     *    * move by (signed !) `ax` in the x direction.
     *    * move by (signed !) `ay` in the y direction.
     *    * move by (signed !) negative `ax` in the x direction.
     *    * move by (signed !) negative `ay` in the y direction.
     *    * (this returns to `point0`)
     */
    static createRectangleXY(point0, ax, ay, closed = true) {
        const ls = LineString3d.create();
        const x0 = point0.x;
        const x1 = point0.x + ax;
        const y0 = point0.y;
        const y1 = point0.y + ay;
        const z = point0.z;
        ls.addPointXYZ(x0, y0, z);
        ls.addPointXYZ(x1, y0, z);
        ls.addPointXYZ(x1, y1, z);
        ls.addPointXYZ(x0, y1, z);
        if (closed)
            ls.addClosurePoint();
        return ls;
    }
    /**
     * Create a regular polygon centered
     * @param center center of the polygon.
     * @param edgeCount number of edges.
     * @param radius distance to vertex or edge (see `radiusToVertices`)
     * @param radiusToVertices true if polygon is inscribed in circle (radius measured to vertices); false if polygon is outside circle (radius to edges)
     */
    static createRegularPolygonXY(center, edgeCount, radius, radiusToVertices = true) {
        if (edgeCount < 3)
            edgeCount = 3;
        const ls = LineString3d.create();
        const i0 = radiusToVertices ? 0 : -1; // offset to make first vector (radius,0,0)
        const radiansStep = Math.PI / edgeCount;
        let c;
        let s;
        let radians;
        if (!radiusToVertices)
            radius = radius / Math.cos(radiansStep);
        for (let i = 0; i < edgeCount; i++) {
            radians = (i0 + 2 * i) * radiansStep;
            c = Angle_1.Angle.cleanupTrigValue(Math.cos(radians));
            s = Angle_1.Angle.cleanupTrigValue(Math.sin(radians));
            ls.addPointXYZ(center.x + radius * c, center.y + radius * s, center.z);
        }
        ls.addClosurePoint();
        return ls;
    }
    /**
     * Copy coordinate data from another linestring.
     *  * The copied content is:
     *    * points
     *    * derivatives (if present)
     *    * fractions (if present)
     *    * surfaceNormals (if present)
     *    * uvParams (if present)
     * @param other
     */
    setFrom(other) {
        // ugly -- "clone" methods are inconsistent about 'reuse' and 'result' parameter . . .
        this._points = other._points.clone(this._points);
        if (other._derivatives)
            this._derivatives = other._derivatives.clone(this._derivatives);
        else
            this._derivatives = undefined;
        if (other._fractions)
            this._fractions = other._fractions.clone(false);
        else
            this._fractions = undefined;
        if (other._surfaceNormals)
            this._surfaceNormals = other._surfaceNormals.clone(this._surfaceNormals);
        else
            this._surfaceNormals = undefined;
        if (other._uvParams)
            this._uvParams = other._uvParams.clone();
        else
            this._uvParams = undefined;
    }
    /** Create a linestring from an array of points. */
    static createPoints(points) {
        const ls = new LineString3d();
        let point;
        for (point of points)
            ls._points.push(point);
        return ls;
    }
    /** Create a linestring, taking points at specified indices from an array of points. */
    static createIndexedPoints(points, index, addClosure = false) {
        const ls = new LineString3d();
        for (const i of index)
            ls._points.push(points[i]); // no clone needed -- we know this reformats to packed array.
        if (addClosure && index.length > 1)
            ls._points.push(points[index[0]]);
        return ls;
    }
    /** Create a LineString3d from xyz coordinates packed in a Float64Array */
    static createFloat64Array(xyzData) {
        const ls = new LineString3d();
        for (let i = 0; i + 3 <= xyzData.length; i += 3)
            ls._points.push(Point3dVector3d_1.Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));
        return ls;
    }
    /** Return a clone of this linestring. */
    clone() {
        const retVal = new LineString3d();
        retVal.setFrom(this);
        return retVal;
    }
    /** Set point coordinates from a json array, e.g. `[[1,2,3],[4,5,6] . . .]`
     * * The `json` parameter must be an array.
     * * Each member `i` of the array is converted to a point with `Point3d.fromJSON(json[i]`)
     */
    setFromJSON(json) {
        this._points.clear();
        if (Array.isArray(json)) {
            let xyz;
            for (xyz of json)
                this._points.push(Point3dVector3d_1.Point3d.fromJSON(xyz));
        }
    }
    /**
     * Convert an LineString3d to a JSON object.
     * * The returned object is an array of arrays of x,y,z coordinates, `[[x,y,z],...[x,y,z]]`
     */
    toJSON() {
        const value = [];
        let i = 0;
        while (this._points.isIndexValid(i)) {
            value.push(this._points.getPoint3dAtUncheckedPointIndex(i).toJSON());
            i++;
        }
        return value;
    }
    /** construct a new linestring.
     * * See `LineString3d.setFromJSON ()` for remarks on `json` structure.
     */
    static fromJSON(json) {
        const ls = new LineString3d();
        ls.setFromJSON(json);
        return ls;
    }
    /**
     * Evaluate a point a fractional position along this linestring.
     * * See `LineString3d` class comments for description of how fraction relates to the linestring points.
     * @param fraction fractional position
     * @param result optional result
     */
    fractionToPoint(fraction, result) {
        const n = this._points.length;
        if (n === 0)
            return Point3dVector3d_1.Point3d.createZero();
        if (n === 1)
            return Point3dVector3d_1.Point3d.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0), result);
        const df = 1.0 / (n - 1);
        if (fraction <= df)
            return this._points.interpolate(0, fraction / df, 1, result);
        if (fraction + df >= 1.0)
            return this._points.interpolate(n - 1, (1.0 - fraction) / df, n - 2, result);
        const index0 = Math.floor(fraction / df);
        return this._points.interpolate(index0, (fraction - index0 * df) / df, index0 + 1, result);
    }
    /**
     * Evaluate a point a fractional position and derivative with respect to fraction along this linestring.
     * * See `LineString3d` class comments for description of how fraction relates to the linestring points.
     * @param fraction fractional position
     * @param result optional result
     */
    fractionToPointAndDerivative(fraction, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        const n = this._points.length;
        if (n <= 1) {
            result.direction.setZero();
            if (n === 1)
                result.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0));
            else
                result.origin.setZero();
            return result;
        }
        const numSegment = n - 1;
        const df = 1.0 / numSegment;
        if (fraction <= df) {
            result = result ? result : Ray3d_1.Ray3d.createZero();
            this._points.interpolate(0, fraction / df, 1, result.origin);
            this._points.vectorIndexIndex(0, 1, result.direction);
            result.direction.scaleInPlace(1.0 / df);
            return result;
        }
        if (fraction + df >= 1.0) {
            result = result ? result : Ray3d_1.Ray3d.createZero();
            this._points.interpolate(n - 2, 1.0 - (1.0 - fraction) / df, n - 1, result.origin);
            this._points.vectorIndexIndex(n - 2, n - 1, result.direction);
            result.direction.scaleInPlace(1.0 / df);
            return result;
        }
        /* true interior point */
        result = result ? result : Ray3d_1.Ray3d.createZero();
        const index0 = Math.floor(fraction / df);
        const localFraction = (fraction - index0 * df) / df;
        this._points.interpolate(index0, localFraction, index0 + 1, result.origin);
        this._points.vectorIndexIndex(index0, index0 + 1, result.direction);
        result.direction.scaleInPlace(1.0 / df);
        return result;
    }
    /** Return point and derivative at fraction, with 000 second derivative. */
    fractionToPointAnd2Derivatives(fraction, result) {
        const ray = this.fractionToPointAndDerivative(fraction);
        result = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createCapture(ray.origin, ray.direction, Point3dVector3d_1.Vector3d.createZero(), result);
        return result;
    }
    /**
     * Convert a segment index and local fraction to a global fraction.
     * @param index index of segment being evaluated
     * @param localFraction local fraction within that segment
     */
    segmentIndexAndLocalFractionToGlobalFraction(index, localFraction) {
        const numSegment = this._points.length - 1;
        if (numSegment < 1)
            return 0.0;
        return (index + localFraction) / numSegment;
    }
    /** Return a frenet frame, using nearby points to estimate a plane. */
    fractionToFrenetFrame(fraction, result) {
        const n = this._points.length;
        if (n <= 1) {
            if (n === 1)
                return Transform_1.Transform.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0), result);
            return Transform_1.Transform.createIdentity(result);
        }
        if (n === 2)
            return Transform_1.Transform.createRefs(this._points.interpolate(0, fraction, 1), Matrix3d_1.Matrix3d.createRigidHeadsUp(this._points.vectorIndexIndex(0, 1), Geometry_1.AxisOrder.XYZ));
        /** 3 or more points. */
        const numSegment = n - 1;
        const df = 1.0 / numSegment;
        let baseIndex = 0;
        let localFraction = 0;
        if (fraction <= df) {
            localFraction = fraction / df;
            baseIndex = 0;
        }
        else if (fraction + df >= 1.0) {
            baseIndex = n - 2;
            localFraction = 1.0 - (1.0 - fraction) / df;
        }
        else {
            baseIndex = Math.floor(fraction / df);
            localFraction = fraction * numSegment - baseIndex;
        }
        const origin = this._points.interpolate(baseIndex, localFraction, baseIndex + 1);
        const vectorA = this._points.vectorIndexIndex(baseIndex, baseIndex + 1);
        // tricky stuff to handle colinear points.   But if vectorA is zero it is still a mess . ..
        const normal = Point3dVector3d_1.Vector3d.create();
        const workVector = Point3dVector3d_1.Vector3d.create();
        if (baseIndex === 0) { // only look forward
            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, 1.0, normal, workVector);
        }
        else if (baseIndex + 2 >= n) { // only look back
            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, 1.0, normal, workVector);
        }
        else {
            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, (1.0 - localFraction), normal, workVector);
            accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, (localFraction), normal, workVector);
        }
        const matrix = Matrix3d_1.Matrix3d.createRigidFromColumns(normal, vectorA, Geometry_1.AxisOrder.ZXY);
        if (matrix)
            return Transform_1.Transform.createOriginAndMatrix(origin, matrix, result);
        return Transform_1.Transform.createTranslation(origin, result);
    }
    /** evaluate the start point of the linestring. */
    startPoint() {
        if (this._points.length === 0)
            return Point3dVector3d_1.Point3d.createZero();
        return this._points.getPoint3dAtUncheckedPointIndex(0);
    }
    /** If i is a valid index, return that point. */
    pointAt(i, result) {
        if (this._points.isIndexValid(i))
            return this._points.getPoint3dAtUncheckedPointIndex(i, result);
        return undefined;
    }
    /** If i and j are both valid indices, return the vector from point i to point j
     */
    vectorBetween(i, j, result) {
        return this._points.vectorIndexIndex(i, j, result);
    }
    /** If i is a valid index, return that stored derivative vector. */
    derivativeAt(i, result) {
        if (this._derivatives && this._derivatives.isIndexValid(i))
            return this._derivatives.getVector3dAtCheckedVectorIndex(i, result);
        return undefined;
    }
    /** If i is a valid index, return that stored surfaceNormal vector. */
    surfaceNormalAt(i, result) {
        if (this._surfaceNormals && this._surfaceNormals.isIndexValid(i))
            return this._surfaceNormals.getVector3dAtCheckedVectorIndex(i, result);
        return undefined;
    }
    /** Return the number of points in this linestring. */
    numPoints() { return this._points.length; }
    /** evaluate the end point of the linestring. */
    endPoint() {
        if (this._points.length === 0)
            return Point3dVector3d_1.Point3d.createZero();
        return this._points.getPoint3dAtUncheckedPointIndex(this._points.length - 1);
    }
    /** Reverse the points within the linestring. */
    reverseInPlace() {
        if (this._points.length >= 2) {
            let i0 = 0;
            let i1 = this._points.length - 1;
            let a = this._points.getPoint3dAtUncheckedPointIndex(0);
            while (i0 < i1) {
                a = this._points.getPoint3dAtUncheckedPointIndex(i0);
                this._points.setAtCheckedPointIndex(i0, this._points.getPoint3dAtUncheckedPointIndex(i1));
                this._points.setAtCheckedPointIndex(i1, a);
                i0++;
                i1--;
            }
        }
    }
    /** Apply `transform` to each point of this linestring. */
    tryTransformInPlace(transform) {
        this._points.multiplyTransformInPlace(transform);
        if (this._derivatives)
            this._derivatives.multiplyMatrix3dInPlace(transform.matrix);
        if (this._surfaceNormals)
            this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(transform.matrix);
        return true;
    }
    /** Sum the lengths of segments within the linestring */
    curveLength() { return this._points.sumLengths(); }
    /** Sum the lengths of segments between fractional positions on a linestring. */
    curveLengthBetweenFractions(fraction0, fraction1) {
        const numSegments = this._points.length - 1;
        if (fraction1 === fraction0 || numSegments < 1)
            return 0.0;
        if (fraction1 < fraction0)
            return this.curveLengthBetweenFractions(fraction1, fraction0);
        const scaledFraction0 = fraction0 * numSegments;
        const scaledFraction1 = fraction1 * numSegments;
        const index0 = Math.max(1, Math.ceil(scaledFraction0));
        const index1 = Math.min(Math.floor(scaledFraction1), numSegments - 1);
        const localFraction0 = index0 - scaledFraction0;
        const localFraction1 = scaledFraction1 - index1;
        if (index0 > index1) {
            // the interval is entirely within a single segment
            return Math.abs(scaledFraction1 - scaledFraction0) * this._points.distanceIndexIndex(index0 - 1, index0);
        }
        else {
            // there is leading partial interval, 0 or more complete segments, and a trailing partial interval.
            // (either or both partial may be zero length)
            let sum = localFraction0 * this._points.distanceIndexIndex(index0 - 1, index0)
                + localFraction1 * (this._points.distanceIndexIndex(index1, index1 + 1));
            for (let i = index0; i < index1; i++)
                sum += this._points.distanceIndexIndex(i, i + 1);
            return sum;
        }
    }
    /**
     * * Implementation of `CurvePrimitive.moveSignedDistanceFromFraction`.  (see comments there!)
     * * Find the segment that contains the start fraction
     * * Move point-by-point from that position to the start or end (respectively for negative or positive signedDistance)
     * * Optionally extrapolate
     * @param startFraction
     * @param signedDistance
     * @param allowExtension
     * @param result
     */
    moveSignedDistanceFromFraction(startFraction, signedDistance, allowExtension, result) {
        const numSegments = this._points.length - 1;
        const scaledFraction = startFraction * numSegments;
        let leftPointIndex = Geometry_1.Geometry.restrictToInterval(Math.floor(scaledFraction), 0, numSegments - 1); // lower point index on active segment.
        const localFraction = scaledFraction - leftPointIndex;
        const point0 = this._points.interpolate(leftPointIndex, localFraction, leftPointIndex + 1, LineString3d._workPointA);
        const point1 = LineString3d._workPointB;
        const context = new MoveByDistanceContext(point0, startFraction, signedDistance);
        if (signedDistance > 0.0) {
            for (; leftPointIndex <= numSegments;) {
                leftPointIndex++;
                this._points.getPoint3dAtCheckedPointIndex(leftPointIndex, point1);
                if (context.announcePoint(point1, leftPointIndex / numSegments))
                    return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, signedDistance, CurveLocationDetail_1.CurveSearchStatus.success, result);
            }
            // fall through for extrapolation from final segment
            if (allowExtension)
                context.announceExtrapolation(this._points, numSegments - 1, numSegments, (numSegments - 1) / numSegments, 1.0);
            return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, signedDistance, context.distanceStatus(), result);
        }
        else { // (moving backwards)
            if (localFraction <= 0.0)
                leftPointIndex--;
            for (; leftPointIndex >= 0; leftPointIndex--) {
                this._points.getPoint3dAtCheckedPointIndex(leftPointIndex, point1);
                if (context.announcePoint(point1, leftPointIndex / numSegments))
                    return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, signedDistance, CurveLocationDetail_1.CurveSearchStatus.success, result);
            }
            // fall through for backward extrapolation from initial segment
            if (allowExtension)
                context.announceExtrapolation(this._points, 1, 0, 1.0 / numSegments, 0.0);
            return CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0, -context.distance0, context.distanceStatus(), result);
        }
    }
    /** sum lengths of segments in the linestring.  (This is a true length.) */
    quickLength() { return this.curveLength(); }
    /**
     * compute and normalize cross product among 3 points on the linestring.
     * * "any" 3 points are acceptable -- no test for positive overall sense.
     * * This is appropriate for polygon known to be convex.
     * * use points spread at index step n/3, hopefully avoiding colinear points.
     * * If that fails, try points 012
     * @param result computed normal.
     */
    quickUnitNormal(result) {
        let step = Math.floor(this._points.length / 3);
        if (step < 1)
            step = 1;
        result = this._points.crossProductIndexIndexIndex(0, step, step + step);
        if (result && result.normalizeInPlace())
            return result;
        return undefined;
    }
    /** Find the point on the linestring (including its segment interiors) that is closest to spacePoint. */
    closestPoint(spacePoint, extend, result) {
        result = CurveLocationDetail_1.CurveLocationDetail.create(this, result);
        const numPoints = this._points.length;
        if (numPoints > 0) {
            const lastIndex = numPoints - 1;
            result.setFP(1.0, this._points.getPoint3dAtUncheckedPointIndex(lastIndex), undefined);
            result.setDistanceTo(spacePoint);
            if (numPoints > 1) {
                let segmentFraction = 0;
                let d = 0;
                const df = 1.0 / lastIndex;
                for (let i = 1; i < numPoints; i++) {
                    segmentFraction = spacePoint.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i));
                    if (segmentFraction < 0) {
                        if (!extend || i > 1)
                            segmentFraction = 0.0;
                    }
                    else if (segmentFraction > 1.0) {
                        if (!extend || i < lastIndex)
                            segmentFraction = 1.0;
                    }
                    this._points.getPoint3dAtUncheckedPointIndex(i - 1).interpolate(segmentFraction, this._points.getPoint3dAtUncheckedPointIndex(i), result.pointQ);
                    d = result.pointQ.distance(spacePoint);
                    if (d < result.a) {
                        result.setFP((i - 1 + segmentFraction) * df, result.pointQ, undefined, d);
                    }
                }
            }
        }
        return result;
    }
    /** Test if all points of the linestring are in a plane. */
    isInPlane(plane) {
        return this._points.isCloseToPlane(plane, Geometry_1.Geometry.smallMetricDistance);
    }
    /** push a hit, fixing up the prior entry if needed.
     * return the incremented counter.
     */
    static pushVertexHit(result, counter, cp, fraction, point) {
        const detail = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(cp, fraction, point);
        result.push(detail);
        if (counter === 0) {
            detail.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.isolatedAtVertex);
        }
        else if (counter === 1) { // last entry must be isolatedAtVertex !!!
            result[result.length - 2].setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.intervalStart);
            detail.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.intervalEnd);
        }
        else {
            result[result.length - 2].setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.intervalInterior);
            detail.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.intervalEnd);
        }
    }
    /** find intersections with a plane.
     *  Intersections within segments are recorded as CurveIntervalRole.isolated
     *   Intersections at isolated "on" vertex are recoded as CurveIntervalRole.isolatedAtVertex.
     */
    appendPlaneIntersectionPoints(plane, result) {
        if (this._points.length < 1)
            return 0;
        const initialLength = result.length;
        const n = this._points.length;
        const divisor = n === 1 ? 1.0 : n - 1;
        const pointA = LineString3d._workPointA;
        const pointB = LineString3d._workPointB;
        const pointC = LineString3d._workPointC;
        this._points.getPoint3dAtUncheckedPointIndex(0, pointA);
        let hB = 0;
        let numConsecutiveZero = 0;
        let hA = 0;
        let segmentFraction = 0;
        for (let i = 0; i < this._points.length; i++, pointA.setFrom(pointB), hA = hB) {
            this._points.getPoint3dAtUncheckedPointIndex(i, pointB);
            hB = Geometry_1.Geometry.correctSmallMetricDistance(plane.altitude(pointB));
            if (hB === 0.0)
                LineString3d.pushVertexHit(result, numConsecutiveZero++, this, i / divisor, pointB);
            else {
                if (hA * hB < 0.0) { // at point0, hA=0 will keep us out of here . ..
                    segmentFraction = hA / (hA - hB); // this division is safe because the signs are different.
                    pointA.interpolate(segmentFraction, pointB, pointC);
                    const detail = CurveLocationDetail_1.CurveLocationDetail.createCurveFractionPoint(this, (i - 1 + segmentFraction) / divisor, pointC);
                    detail.setIntervalRole(CurveLocationDetail_1.CurveIntervalRole.isolated);
                    result.push(detail);
                    numConsecutiveZero = 0;
                }
            }
        }
        return result.length - initialLength;
    }
    /** Extend `rangeToExtend` to include all points of this linestring. */
    extendRange(rangeToExtend, transform) { this._points.extendRange(rangeToExtend, transform); }
    /** Test if each point of this linestring isAlmostEqual with corresponding point in `other`. */
    isAlmostEqual(other) {
        if (!(other instanceof LineString3d))
            return false;
        if (!GrowableXYZArray_1.GrowableXYZArray.isAlmostEqual(this._points, other._points))
            return false;
        return true;
    }
    /** Append (clone of) one point.
     * * BUT ... skip if duplicates the tail of prior points.
     * * if fraction is given, "duplicate" considers both point and fraction.
     */
    appendStrokePoint(point, fraction) {
        const n = this._points.length;
        let add = true;
        const addFraction = fraction !== undefined && this._fractions !== undefined;
        if (n > 0) {
            if (addFraction && Geometry_1.Geometry.isSameCoordinate(fraction, this._fractions.back()))
                add = false;
            if (point.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(n - 1)))
                add = false;
        }
        if (add) {
            this._points.push(point);
            if (addFraction)
                this.addFraction(fraction);
        }
    }
    /** Append a suitable evaluation of a curve ..
     * * always append the curve point
     * * if fraction array is present, append the fraction
     * * if derivative array is present, append the derivative
     * BUT ... skip if duplicates the tail of prior points.
     */
    appendFractionToPoint(curve, fraction) {
        if (this._derivatives) {
            const ray = curve.fractionToPointAndDerivative(fraction, LineString3d._workRay);
            if (this._fractions)
                this._fractions.push(fraction);
            this._points.push(ray.origin);
            if (this._derivatives)
                this._derivatives.push(ray.direction);
        }
        else {
            const point = curve.fractionToPoint(fraction, LineString3d._workPointA);
            if (this._fractions)
                this._fractions.push(fraction);
            this._points.push(point);
        }
    }
    /**
     * clear all array data:
     * * points
     * * optional fractions.
     * * optional derivatives.
     */
    clear() {
        this._points.clear();
        if (this._fractions)
            this._fractions.clear();
        if (this._derivatives)
            this._derivatives.clear();
    }
    /**
     * * options.needParams triggers creation of fraction array and uvParams array.
     * * options.needNormals triggers creation of derivatives array
     * @param capacity if positive, initial capacity of arrays
     * @param options  optional, to indicate if fraction and derivative arrays are required.
     */
    static createForStrokes(capacity = 0, options) {
        const ls = LineString3d.create();
        if (capacity > 0)
            ls._points.ensureCapacity(capacity);
        if (options) {
            if (options.needParams) {
                ls._fractions = new GrowableFloat64Array_1.GrowableFloat64Array(capacity);
                ls._uvParams = new GrowableXYArray_1.GrowableXYArray(capacity);
            }
            if (options.needNormals) {
                ls._derivatives = new GrowableXYZArray_1.GrowableXYZArray(capacity);
                ls._surfaceNormals = new GrowableXYZArray_1.GrowableXYZArray(capacity);
            }
        }
        return ls;
    }
    /** Evaluate a curve at uniform fractions.  Append the evaluations to this linestring.
     * @param curve primitive to evaluate.
     * @param numStrokes number of strokes (edges).
     * @param fraction0 starting fraction coordinate
     * @param fraction1 end fraction coordinate
     * @param include01 if false, points at fraction0 and fraction1 are omitted.
     */
    appendFractionalStrokePoints(curve, numStrokes, fraction0 = 0, fraction1 = 1, include01 = true) {
        let i0 = 1;
        let i1 = numStrokes - 1;
        if (include01) {
            i0 = 0;
            i1 = numStrokes;
        }
        if (numStrokes >= 1) {
            const df = (fraction1 - fraction0) / numStrokes;
            for (let i = i0; i <= i1; i++)
                this.appendFractionToPoint(curve, fraction0 + i * df);
        }
    }
    /** Append points constructed as interpolation between two points.
     * @param numStrokes number of strokes.
     * @param point0 first point
     * @param point1 last point
     * @param include01 if false, OMIT both start and end points (i.e. only compute and add true interior points)
     */
    appendInterpolatedStrokePoints(numStrokes, point0, point1, include01) {
        if (include01)
            this.appendStrokePoint(point0, 0.0);
        if (numStrokes > 1) {
            const df = 1.0 / numStrokes;
            for (let i = 1; i < numStrokes; i++) {
                const f = i * df;
                this.appendStrokePoint(point0.interpolate(f, point1), f);
            }
        }
        if (include01)
            this.appendStrokePoint(point1, 1.0);
    }
    /** Emit strokes to caller-supplied linestring */
    emitStrokes(dest, options) {
        const n = this._points.length;
        const pointA = LineString3d._workPointA;
        const pointB = LineString3d._workPointB;
        if (n > 0) {
            // This is a linestring.
            // There is no need for chordTol and angleTol within a segment.
            // Do NOT apply min strokes per primitive.
            if (options && options.hasMaxEdgeLength) {
                dest.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));
                for (let i = 1; i < n; i++) {
                    this._points.getPoint3dAtUncheckedPointIndex(i - 1, pointA);
                    this._points.getPoint3dAtUncheckedPointIndex(i, pointB);
                    const numStroke = options.applyMaxEdgeLength(1, pointA.distance(pointB));
                    if (numStroke > 1)
                        dest.appendInterpolatedStrokePoints(numStroke, pointA, pointB, false);
                    dest.appendStrokePoint(pointB);
                }
            }
            else {
                for (let i = 0; i < n; i++) {
                    dest.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(i));
                }
            }
        }
    }
    /** Emit strokable parts of the curve to a caller-supplied handler.
     * If the stroke options does not have a maxEdgeLength, one stroke is emitted for each segment of the linestring.
     * If the stroke options has a maxEdgeLength, smaller segments are emitted as needed.
     */
    emitStrokableParts(handler, options) {
        const n = this._points.length;
        handler.startCurvePrimitive(this);
        if (n > 1) {
            const df = 1.0 / (n - 1);
            // This is a linestring.
            // There is no need for chordTol and angleTol within a segment.
            // Do NOT apply min strokes per primitive.
            if (options && options.hasMaxEdgeLength) {
                for (let i = 1; i < n; i++) {
                    const numStroke = options.applyMaxEdgeLength(1, this._points.getPoint3dAtUncheckedPointIndex(i - 1).distance(this._points.getPoint3dAtUncheckedPointIndex(i)));
                    handler.announceSegmentInterval(this, this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i), numStroke, (i - 1) * df, i * df);
                }
            }
            else {
                for (let i = 1; i < n; i++) {
                    handler.announceSegmentInterval(this, this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i), 1, (i - 1) * df, i * df);
                }
            }
        }
        handler.endCurvePrimitive(this);
    }
    /**
     * return the stroke count required for given options.
     * @param options StrokeOptions that determine count
     */
    computeStrokeCountForOptions(options) {
        const numPoints = this._points.length;
        let numStroke = numPoints - 1;
        if (options && options.hasMaxEdgeLength) {
            numStroke = 0;
            for (let i = 1; i < numPoints; i++) {
                numStroke += options.applyMaxEdgeLength(1, this._points.distanceIndexIndex(i - 1, i));
            }
        }
        return numStroke;
    }
    /**
     * Compute individual segment stroke counts.  Attach in a StrokeCountMap.
     * @param options StrokeOptions that determine count
     * @param parentStrokeMap evolving parent map.
     */
    computeAndAttachRecursiveStrokeCounts(options, parentStrokeMap) {
        const numPoints = this._points.length;
        const applyOptions = options !== undefined && options.hasMaxEdgeLength;
        const myData = StrokeCountMap_1.StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);
        for (let i = 1; i < numPoints; i++) {
            const segmentLength = this._points.distanceIndexIndex(i - 1, i);
            const numStrokeOnSegment = applyOptions ? options.applyMaxEdgeLength(1, segmentLength) : 1;
            myData.addToCountAndLength(numStrokeOnSegment, segmentLength);
        }
        CurvePrimitive_1.CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);
    }
    /** Second step of double dispatch:  call `handler.handleLineString3d(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleLineString3d(this);
    }
    // HARD TO TEST -- tests that get to announceClipInterval for arc, bspline do NOT get here with
    // linestring because the controller has special case loops through segments?
    /**
     * Find intervals of this CurvePrimitive that are interior to a clipper
     * @param clipper clip structure (e.g. clip planes)
     * @param announce (optional) function to be called announcing fractional intervals"  ` announce(fraction0, fraction1, curvePrimitive)`
     * @returns true if any "in" segments are announced.
     */
    announceClipIntervals(clipper, announce) {
        const n = this._points.length;
        if (n < 2)
            return false;
        let globalFractionA = 0.0;
        let globalFractionB = 1.0;
        const capture = (localFraction0, localFraction1) => {
            if (announce)
                announce(Geometry_1.Geometry.interpolate(globalFractionA, localFraction0, globalFractionB), Geometry_1.Geometry.interpolate(globalFractionA, localFraction1, globalFractionB), this);
        };
        const pointA = LineString3d._workPointA;
        const pointB = LineString3d._workPointB;
        this._points.getPoint3dAtUncheckedPointIndex(0, pointA);
        let status = false;
        for (let i = 1; i < n; i++, pointA.setFrom(pointB), globalFractionA = globalFractionB) {
            this._points.getPoint3dAtUncheckedPointIndex(i, pointB);
            globalFractionB = i / (n - 1);
            if (clipper.announceClippedSegmentIntervals(0.0, 1.0, pointA, pointB, capture))
                status = true;
        }
        return status;
    }
    addResolvedPoint(index, fraction, dest) {
        const n = this._points.length;
        if (n === 0)
            return;
        if (n === 1) {
            this._points.getPoint3dAtUncheckedPointIndex(0, LineString3d._indexPoint);
            dest.push(LineString3d._indexPoint);
            return;
        }
        if (index < 0)
            index = 0;
        if (index >= n) {
            index = n - 1;
            fraction += 1;
        }
        this._points.interpolate(index, fraction, index + 1, LineString3d._indexPoint);
        dest.push(LineString3d._indexPoint);
    }
    /** Return (if possible) a LineString which is a portion of this curve.
     * * This implementation does NOT extrapolate the linestring -- fractions are capped at 0 and 1.
     * @param fractionA [in] start fraction
     * @param fractionB [in] end fraction
     */
    clonePartialCurve(fractionA, fractionB) {
        if (fractionB < fractionA) {
            const linestringA = this.clonePartialCurve(fractionB, fractionA);
            if (linestringA)
                linestringA.reverseInPlace();
            return linestringA;
        }
        const n = this._points.length;
        const numEdge = n - 1;
        if (n < 2 || fractionA >= 1.0 || fractionB <= 0.0)
            return undefined;
        if (fractionA < 0)
            fractionA = 0;
        if (fractionB > 1)
            fractionB = 1;
        const gA = fractionA * numEdge;
        const gB = fractionB * numEdge;
        const indexA = Math.floor(gA);
        const indexB = Math.floor(gB);
        const localFractionA = gA - indexA;
        const localFractionB = gB - indexB;
        const result = LineString3d.create();
        this.addResolvedPoint(indexA, localFractionA, result._points);
        for (let index = indexA + 1; index <= indexB; index++) {
            this._points.getPoint3dAtUncheckedPointIndex(index, LineString3d._workPointA);
            result._points.push(LineString3d._workPointA);
        }
        if (!Geometry_1.Geometry.isSmallRelative(localFractionB)) {
            this.addResolvedPoint(indexB, localFractionB, result._points);
        }
        return result;
    }
    /** Return (if possible) a specific segment of the linestring */
    getIndexedSegment(index) {
        if (index >= 0 && index + 1 < this._points.length)
            return LineSegment3d_1.LineSegment3d.create(this._points.getPoint3dAtCheckedPointIndex(index), this._points.getPoint3dAtCheckedPointIndex(index + 1));
        return undefined;
    }
    /**
     * Returns true if first and last points are within metric tolerance.
     */
    get isPhysicallyClosed() {
        return this._points.length > 0 && Geometry_1.Geometry.isSmallMetricDistance(this._points.distanceIndexIndex(0, this._points.length - 1));
    }
    /**
     * evaluate strokes at fractions indicated in a StrokeCountMap.
     * * The map must have an array of component counts corresponding to the segment of this linestring.
     * * "fractions" in the output are mapped within a0,a1 of the map.componentData
     * @param map = stroke count data.
     * @param destLinestring = receiver linestring.
     * @return number of strokes added.  0 if `map.componentData` does not match the linestring
     */
    addMappedStrokesToLineString3D(map, destLinestring) {
        const numPoint0 = destLinestring.numPoints();
        const needFractions = destLinestring._fractions !== undefined;
        const needDerivatives = destLinestring._derivatives !== undefined;
        const points = this._points;
        const pointA = LineString3d._workPointA;
        const pointB = LineString3d._workPointB;
        const pointC = LineString3d._workPointC;
        const numParentPoint = points.length;
        if (map.primitive && map.primitive === this && map.componentData && map.componentData.length + 1 === numParentPoint) {
            points.getPoint3dAtUncheckedPointIndex(0, pointA);
            for (let k = 0; k + 1 < numParentPoint; k++, pointA.setFromPoint3d(pointB)) {
                points.getPoint3dAtUncheckedPointIndex(k + 1, pointB);
                const segmentMap = map.componentData[k];
                const m = segmentMap.numStroke;
                const vectorAB = pointA.vectorTo(pointB);
                vectorAB.scale(m);
                for (let i = 0; i <= m; i++) {
                    const fraction = i / m;
                    const outputFraction = segmentMap.fractionToA(fraction);
                    destLinestring.addPoint(pointA.interpolate(fraction, pointB, pointC));
                    if (needFractions)
                        destLinestring._fractions.push((outputFraction));
                    if (needDerivatives)
                        destLinestring._derivatives.push(vectorAB);
                }
            }
        }
        return destLinestring.numPoints() - numPoint0;
    }
    /** convert variant point data to a single level array of linestrings.
     * * The result is always an array of LineString3d.
     *   * Single linestring is NOT bubbled out as a special case.
     *   * data with no point is an empty array.
     *   * "deep" data is flattened to a single array of linestrings, losing structure.
     */
    static createArrayOfLineString3dFromVariantData(data) {
        const collector = new PointStreaming_1.PointStreamGrowableXYZArrayCollector();
        PointStreaming_1.VariantPointDataStream.streamXYZ(data, collector);
        const growableArrays = collector.claimArrayOfGrowableXYZArray();
        const result = [];
        if (growableArrays !== undefined) {
            for (const points of growableArrays)
                result.push(LineString3d.createCapture(points));
        }
        return result;
    }
    /**
     * This method name is deprecated. Use `LineString3d.createArrayOfLineString3dFromVariantData`
     * @deprecated use LineString3d.createArrayOfLineString3dFromVariantData
     */
    static createArrayOfLineString3d(data) {
        return this.createArrayOfLineString3dFromVariantData(data);
    }
}
exports.LineString3d = LineString3d;
LineString3d._workPointA = Point3dVector3d_1.Point3d.create();
LineString3d._workPointB = Point3dVector3d_1.Point3d.create();
LineString3d._workPointC = Point3dVector3d_1.Point3d.create();
LineString3d._workRay = Ray3d_1.Ray3d.createXAxis();
LineString3d._indexPoint = Point3dVector3d_1.Point3d.create(); // private point for indexAndFractionToPoint.
/** An AnnotatedLineString3d is a linestring with additional surface-related data attached to each point
 * * This is useful in facet construction.
 * @internal
 */
class AnnotatedLineString3d {
}
exports.AnnotatedLineString3d = AnnotatedLineString3d;
/**
 * context to be called to incrementally accumulate distance along line segments.
 */
class MoveByDistanceContext {
    /** CAPTURE point0, fraction0, targetDistance */
    constructor(point0, fraction0, targetDistance) {
        this.point0 = point0;
        this.distance0 = 0.0;
        this.targetDistance = Math.abs(targetDistance);
        this.fraction0 = fraction0;
    }
    // Return CurveSearchStatus indicating whether the accumulated distance has reached the target.
    distanceStatus() {
        return Geometry_1.Geometry.isSameCoordinate(this.distance0, this.targetDistance) ?
            CurveLocationDetail_1.CurveSearchStatus.success : CurveLocationDetail_1.CurveSearchStatus.stoppedAtBoundary;
    }
    /**
     * Announce next point on the polyline.
     * * if the additional segment does NOT reach the target:
     *   * accumulate the segment length
     *   * update point0 and fraction0
     *   * return false
     *  * if the additional segment DOES reach the target:
     *    * update point0 and fraction0 to the (possibly interpolated) final point and fraction
     *    * return true
     * @param point1 new point
     * @param fraction1 fraction at point1
     * @return true if targetDistance reached.
     */
    announcePoint(point1, fraction1) {
        const a = this.point0.distance(point1);
        const distance1 = this.distance0 + a;
        if (distance1 < this.targetDistance && !Geometry_1.Geometry.isSameCoordinate(distance1, this.targetDistance)) {
            this.point0.setFromPoint3d(point1);
            this.distance0 = distance1;
            this.fraction0 = fraction1;
            return false;
        }
        const b = this.targetDistance - this.distance0;
        const intervalFraction = Geometry_1.Geometry.safeDivideFraction(b, a, 0.0);
        this.point0.interpolate(intervalFraction, point1, this.point0);
        this.fraction0 = Geometry_1.Geometry.interpolate(this.fraction0, intervalFraction, fraction1);
        this.distance0 = this.targetDistance;
        return true;
    }
    /**
     * Update point0, fraction0, and distance0 based on extrapolation of a segment between indices of a point array.
     * @returns true if extrapolation succeeded.  (False if indexed points are coincident)
     * @param points
     * @param index0
     * @param index1
     * @param fraction0
     * @param fraction1
     * @param result
     * @param CurveLocationDetail
     */
    announceExtrapolation(points, index0, index1, fraction0, fraction1) {
        const residual = this.targetDistance - this.distance0;
        const d01 = points.distanceIndexIndex(index0, index1);
        if (!d01)
            return false;
        const extensionFraction = Geometry_1.Geometry.conditionalDivideFraction(residual, d01);
        if (extensionFraction === undefined)
            return false;
        // (Remark: indices are swapped and extensionFraction negated to prevent incidental precision
        // loss with the alternative call with (index0, 1 + extensionFraction, index1);
        points.interpolate(index1, -extensionFraction, index0, this.point0);
        this.distance0 = this.targetDistance;
        this.fraction0 = Geometry_1.Geometry.interpolate(fraction1, -extensionFraction, fraction0);
        return true;
    }
}


/***/ }),

/***/ "./lib/curve/Loop.js":
/*!***************************!*\
  !*** ./lib/curve/Loop.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
/**
 * A `Loop` is a curve chain that is the boundary of a closed (planar) loop.
 * @public
 */
class Loop extends CurveCollection_1.CurveChain {
    /** Test if `other` is an instance of `Loop` */
    constructor() {
        super();
        /** String name for schema properties */
        this.curveCollectionType = "loop";
        /** tag value that can be set to true for user code to mark inner and outer loops. */
        this.isInner = false;
    }
    /** test if `other` is a `Loop` */
    isSameGeometryClass(other) { return other instanceof Loop; }
    /**
     * Create a loop from variable length list of CurvePrimitives
     * @param curves array of individual curve primitives
     */
    static create(...curves) {
        const result = new Loop();
        for (const curve of curves) {
            result.children.push(curve);
        }
        return result;
    }
    /**
     * Create a loop from an array of curve primitives
     * @param curves array of individual curve primitives
     */
    static createArray(curves) {
        const result = new Loop();
        for (const curve of curves) {
            result.children.push(curve);
        }
        return result;
    }
    /** Create a loop from an array of points */
    static createPolygon(points) {
        const linestring = LineString3d_1.LineString3d.create(points);
        linestring.addClosurePoint();
        return Loop.create(linestring);
    }
    /** Create a loop with the stroked form of this loop. */
    cloneStroked(options) {
        const strokes = LineString3d_1.LineString3d.create();
        for (const curve of this.children)
            curve.emitStrokes(strokes, options);
        return Loop.create(strokes);
    }
    /** Return the boundary type (2) of a corresponding  MicroStation CurveVector */
    dgnBoundaryType() { return 2; } // (2) all "Loop" become "outer"
    /** invoke `processor.announceLoop(this, indexInParent)` */
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceLoop(this, indexInParent);
    }
    /** Create a new `Loop` with no children */
    cloneEmptyPeer() { return new Loop(); }
    /** Second step of double dispatch:  call `handler.handleLoop(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleLoop(this);
    }
}
exports.Loop = Loop;


/***/ }),

/***/ "./lib/curve/ParityRegion.js":
/*!***********************************!*\
  !*** ./lib/curve/ParityRegion.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
const Loop_1 = __webpack_require__(/*! ./Loop */ "./lib/curve/Loop.js");
/**
 * * A `ParityRegion` is a collection of `Loop` objects.
 * * The loops collectively define a planar region.
 * * A point is "in" the composite region if it is "in" an odd number of the loops.
 * @public
 */
class ParityRegion extends CurveCollection_1.CurveCollection {
    /** Construct parity region with empty loop array */
    constructor() {
        super();
        /** String name for schema properties */
        this.curveCollectionType = "parityRegion";
        this._children = [];
    }
    /** Test if `other` is an instance of `ParityRegion` */
    isSameGeometryClass(other) { return other instanceof ParityRegion; }
    /** Return the array of loops in this parity region. */
    get children() { return this._children; }
    /**
     * Add loops (recursively) to this region's children
     */
    addLoops(data) {
        if (data === undefined) {
        }
        else if (data instanceof Loop_1.Loop)
            this.children.push(data);
        else if (Array.isArray(data)) {
            for (const child of data) {
                if (child instanceof Loop_1.Loop)
                    this.children.push(child);
                else if (Array.isArray(child))
                    this.addLoops(child);
            }
        }
    }
    /** Return a single loop or parity region with given loops.
     * * The returned structure CAPTURES the loops.
     * * The loops are NOT reorganized by hole analysis.
     */
    static createLoops(data) {
        if (data instanceof Loop_1.Loop)
            return data;
        const result = new ParityRegion();
        result.addLoops(data);
        return result;
    }
    /** Create a parity region with given loops */
    static create(...data) {
        const result = new ParityRegion();
        for (const child of data) {
            result.children.push(child);
        }
        return result;
    }
    /** Return the boundary type (4) of a corresponding  MicroStation CurveVector */
    dgnBoundaryType() { return 4; }
    /** invoke `processor.announceParityRegion(this, indexInParent)` */
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceParityRegion(this, indexInParent);
    }
    /** Return a deep copy. */
    clone() {
        const clone = new ParityRegion();
        let child;
        for (child of this.children) {
            const childClone = child.clone();
            if (childClone instanceof Loop_1.Loop)
                clone.children.push(childClone);
        }
        return clone;
    }
    /** Stroke these curves into a new ParityRegion. */
    cloneStroked(options) {
        const clone = new ParityRegion();
        let child;
        for (child of this.children) {
            const childStrokes = child.cloneStroked(options);
            if (childStrokes)
                clone.children.push(childStrokes);
        }
        return clone;
    }
    /** Create a new empty parity region. */
    cloneEmptyPeer() { return new ParityRegion(); }
    /** Add `child` to this parity region.
     * * any child type other than `Loop` is ignored.
     */
    tryAddChild(child) {
        if (child && child instanceof Loop_1.Loop) {
            this._children.push(child);
            return true;
        }
        return false;
    }
    /** Get child `i` by index. */
    getChild(i) {
        if (i < this._children.length)
            return this._children[i];
        return undefined;
    }
    /** Second step of double dispatch:  call `handler.handleRegion(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleParityRegion(this);
    }
}
exports.ParityRegion = ParityRegion;


/***/ }),

/***/ "./lib/curve/Path.js":
/*!***************************!*\
  !*** ./lib/curve/Path.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
/**
 * * A `Path` object is a collection of curves that join head-to-tail to form a path.
 * * A `Path` object does not bound a planar region.  Use `Loop` to indicate region bounding.
 * @public
 */
class Path extends CurveCollection_1.CurveChain {
    /** Construct an empty path. */
    constructor() {
        super();
        /** String name for schema properties */
        this.curveCollectionType = "path";
    }
    /** Test if `other` is an instance of `Path` */
    isSameGeometryClass(other) { return other instanceof Path; }
    /** invoke `processor.announcePath(this, indexInParent)` */
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announcePath(this, indexInParent);
    }
    /**
     * Create a path from a variable length list of curve primitives
     * * CurvePrimitive params are captured !!!
     * @param curves variable length list of individual curve primitives or point arrays.
     */
    static create(...curves) {
        const result = new Path();
        for (const curve of curves) {
            if (curve instanceof CurvePrimitive_1.CurvePrimitive)
                result.children.push(curve);
            else if (Array.isArray(curve) && curve.length > 0 && curve[0] instanceof Point3dVector3d_1.Point3d) {
                result.children.push(LineString3d_1.LineString3d.create(curve));
            }
        }
        return result;
    }
    /**
     * Create a path from a an array of curve primitives
     * @param curves array of individual curve primitives
     */
    static createArray(curves) {
        const result = new Path();
        for (const curve of curves) {
            result.children.push(curve);
        }
        return result;
    }
    /** Return a deep copy, with leaf-level curve primitives stroked. */
    cloneStroked(options) {
        const strokes = LineString3d_1.LineString3d.create();
        for (const curve of this.children)
            curve.emitStrokes(strokes, options);
        return Path.create(strokes);
    }
    /** Return the boundary type (1) of a corresponding  MicroStation CurveVector */
    dgnBoundaryType() { return 1; }
    /** Clone as a new `Path` with no primitives */
    cloneEmptyPeer() { return new Path(); }
    /** Second step of double dispatch:  call `handler.handlePath(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handlePath(this);
    }
}
exports.Path = Path;


/***/ }),

/***/ "./lib/curve/PointString3d.js":
/*!************************************!*\
  !*** ./lib/curve/PointString3d.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const GeometryQuery_1 = __webpack_require__(/*! ./GeometryQuery */ "./lib/curve/GeometryQuery.js");
/* tslint:disable:variable-name no-empty*/
/**
 * A PointString3d is an array of points.
 * * PointString3D is first class (persistible, displayable) geometry derived from the GeometryQuery base class.
 * * The various points in the PointString3d are NOT connected by line segments for display or other calculations.
 * @public
 */
class PointString3d extends GeometryQuery_1.GeometryQuery {
    constructor() {
        super();
        /** String name for schema properties */
        this.geometryCategory = "pointCollection";
        this._points = [];
    }
    /** Test if `other` is a PointString3d */
    isSameGeometryClass(other) { return other instanceof PointString3d; }
    /** return a clone of the points array. */
    get points() { return this._points; }
    /** Clone and apply a transform. */
    cloneTransformed(transform) {
        const c = this.clone();
        c.tryTransformInPlace(transform);
        return c;
    }
    static flattenArray(arr) {
        return arr.reduce((flat, toFlatten) => {
            return flat.concat(Array.isArray(toFlatten) ? PointString3d.flattenArray(toFlatten) : toFlatten);
        }, []);
    }
    /** Create a PointString3d from points. */
    static create(...points) {
        const result = new PointString3d();
        result.addPoints(points);
        return result;
    }
    /** Add multiple points to the PointString3d */
    addPoints(...points) {
        const toAdd = PointString3d.flattenArray(points);
        for (const p of toAdd) {
            if (p instanceof Point3dVector3d_1.Point3d)
                this._points.push(p);
        }
    }
    /** Add a single point to the PointString3d */
    addPoint(point) {
        this._points.push(point);
    }
    /** Remove the last point added to the PointString3d */
    popPoint() {
        this._points.pop();
    }
    /** Replace this PointString3d's point array by a clone of the array in `other` */
    setFrom(other) {
        this._points = PointHelpers_1.Point3dArray.clonePoint3dArray(other._points);
    }
    /** Create from an array of Point3d */
    static createPoints(points) {
        const ps = new PointString3d();
        ps._points = PointHelpers_1.Point3dArray.clonePoint3dArray(points);
        return ps;
    }
    /** Create a PointString3d from xyz coordinates packed in a Float64Array */
    static createFloat64Array(xyzData) {
        const ps = new PointString3d();
        for (let i = 0; i + 3 <= xyzData.length; i += 3)
            ps._points.push(Point3dVector3d_1.Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));
        return ps;
    }
    /** Return a deep clone. */
    clone() {
        const retVal = new PointString3d();
        retVal.setFrom(this);
        return retVal;
    }
    /** Replace this instance's points by those from a json array, e.g. `[[1,2,3], [4,2,2]]` */
    setFromJSON(json) {
        this._points.length = 0;
        if (Array.isArray(json)) {
            let xyz;
            for (xyz of json)
                this._points.push(Point3dVector3d_1.Point3d.fromJSON(xyz));
        }
    }
    /**
     * Convert an PointString3d to a JSON object.
     * @return {*} [[x,y,z],...[x,y,z]]
     */
    toJSON() {
        const value = [];
        for (const p of this._points)
            value.push(p.toJSON());
        return value;
    }
    /** Create a PointString3d from a json array, e.g. `[[1,2,3], [4,2,2]]` */
    static fromJSON(json) {
        const ps = new PointString3d();
        ps.setFromJSON(json);
        return ps;
    }
    /** Access a single point by index. */
    pointAt(i, result) {
        if (i >= 0 && i < this._points.length) {
            if (result) {
                result.setFrom(this._points[i]);
                return result;
            }
            return this._points[i].clone();
        }
        return undefined;
    }
    /** Return the number of points. */
    numPoints() { return this._points.length; }
    /** Reverse the point order */
    reverseInPlace() {
        if (this._points.length >= 2) {
            let i0 = 0;
            let i1 = this._points.length - 1;
            while (i0 < i1) {
                const a = this._points[i0];
                this._points[i1] = this._points[i0];
                this._points[i0] = a;
                i0++;
                i1--;
            }
        }
    }
    /** Return the number of points. */
    tryTransformInPlace(transform) {
        transform.multiplyPoint3dArrayInPlace(this._points);
        return true;
    }
    /** Return the index and coordinates of the closest point to spacepoint. */
    closestPoint(spacePoint) {
        const result = { index: -1, xyz: Point3dVector3d_1.Point3d.create() };
        const index = PointHelpers_1.Point3dArray.closestPointIndex(this._points, spacePoint);
        if (index >= 0) {
            result.index = index;
            result.xyz.setFrom(this._points[index]);
        }
        return result;
    }
    /** Return true if all points are in the given plane. */
    isInPlane(plane) {
        return PointHelpers_1.Point3dArray.isCloseToPlane(this._points, plane, Geometry_1.Geometry.smallMetricDistance);
    }
    /** Extend a range to include the points in this PointString3d. */
    extendRange(rangeToExtend, transform) {
        rangeToExtend.extendArray(this._points, transform);
    }
    /** Return true if corresponding points are almost equal. */
    isAlmostEqual(other) {
        if (!(other instanceof PointString3d))
            return false;
        return PointHelpers_1.Point3dArray.isAlmostEqual(this._points, other._points);
    }
    /** Reduce to empty set of points. */
    clear() { this._points.length = 0; }
    /** Second step of double dispatch:  call `handler.handlePointString(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handlePointString3d(this);
    }
}
exports.PointString3d = PointString3d;


/***/ }),

/***/ "./lib/curve/PolygonOffsetContext.js":
/*!*******************************************!*\
  !*** ./lib/curve/PolygonOffsetContext.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable: no-console */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const LineSegment3d_1 = __webpack_require__(/*! ./LineSegment3d */ "./lib/curve/LineSegment3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ./CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./lib/curve/Path.js");
const Loop_1 = __webpack_require__(/*! ./Loop */ "./lib/curve/Loop.js");
const Arc3d_1 = __webpack_require__(/*! ./Arc3d */ "./lib/curve/Arc3d.js");
const CurveCurve_1 = __webpack_require__(/*! ./CurveCurve */ "./lib/curve/CurveCurve.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const RegionOps_1 = __webpack_require__(/*! ./RegionOps */ "./lib/curve/RegionOps.js");
/**
 * Classification of contortions at a joint.
 * @internal
 */
var JointMode;
(function (JointMode) {
    JointMode[JointMode["Unknown"] = 0] = "Unknown";
    JointMode[JointMode["Cap"] = 1] = "Cap";
    JointMode[JointMode["Extend"] = 2] = "Extend";
    JointMode[JointMode["Trim"] = -1] = "Trim";
    JointMode[JointMode["JustGeometry"] = 3] = "JustGeometry";
    JointMode[JointMode["Gap"] = 4] = "Gap";
})(JointMode || (JointMode = {}));
/**
 * * control parameters for joint construction.
 * * Decision order is:
 *   * if turn angle is greater than minArcDegrees, make an arc.
 *   * if turn angle is less than or equal maxChamferTurnDegrees, extend curves along tangent to single intersection point.
 *   * if turn angle is greater than maxChamferTurnDegrees,  construct multiple lines that are tangent to the turn circle "from the outside",
 *           with each equal turn less than maxChamferTurnDegrees.
 *   * otherwise make single edge.
 * @public
 */
class JointOptions {
    /** Construct JointOptions.
     * * leftOffsetDistance is required
     * * minArcDegrees and maxChamferDegrees are optional.
     */
    constructor(leftOffsetDistance, minArcDegrees = 180, maxChamferDegrees = 90) {
        /** smallest arc to construct.
         * * If this control angle is large, arcs are never created.
         */
        this.minArcDegrees = 180.0;
        this.maxChamferTurnDegrees = 90;
        this.leftOffsetDistance = 0;
        this.leftOffsetDistance = leftOffsetDistance;
        this.minArcDegrees = minArcDegrees;
        this.maxChamferTurnDegrees = maxChamferDegrees;
    }
    /**
     * Parse a number of JointOptions up to JointOptions:
     * * If leftOffsetDistanceOptions is a number, create a JointOptions with default arc and chamfer values.
     * * If leftOffsetDistanceOrOptions is a JointOptions, return it unchanged.
     * @param leftOffsetDistanceOrOptions
     */
    static create(leftOffsetDistanceOrOptions) {
        if (leftOffsetDistanceOrOptions instanceof JointOptions)
            return leftOffsetDistanceOrOptions;
        // if (Number.isFinite(leftOffsetDistanceOrOptions))
        return new JointOptions(leftOffsetDistanceOrOptions);
    }
    /** return true if the options indicate this amount of turn should be handled with an arc. */
    needArc(theta) {
        return Math.abs(theta.degrees) >= this.minArcDegrees;
    }
    /** Test if turn by theta should be output as single point. */
    numChamferPoints(theta) {
        const degrees = Math.abs(theta.degrees);
        const stepDegrees = Geometry_1.Geometry.clamp(this.maxChamferTurnDegrees, 10, 120);
        if (degrees <= stepDegrees)
            return 1;
        return Math.ceil(degrees / stepDegrees);
    }
}
exports.JointOptions = JointOptions;
/**
 * Description of geometry around a joint.
 * @internal
 */
class Joint {
    // capture references to all data . . .
    constructor(curve0, curve1, swingPoint) {
        this.curve0 = curve0;
        this.curve1 = curve1;
        this.swingPoint = swingPoint;
        this.flexure = JointMode.Unknown;
    }
    /** try to construct an arc transition from ray0 to ray1 with given center. */
    static constructArc(ray0, center, ray1) {
        if (center !== undefined && Geometry_1.Geometry.isSameCoordinate(ray0.origin.distance(center), ray1.origin.distance(center))) {
            const angle = ray0.direction.angleToXY(ray1.direction);
            const vector0 = Point3dVector3d_1.Vector3d.createStartEnd(center, ray0.origin);
            const vector90 = vector0.rotate90CCWXY();
            return Arc3d_1.Arc3d.create(center, vector0, vector90, AngleSweep_1.AngleSweep.createStartEndRadians(0.0, angle.radians));
        }
        return undefined;
    }
    /** Extract a json object of {curve0:data, fraction0:data, curve1:data, fraction1:data} */
    shallowExtract() {
        return { curve0: this.curve0, curve1: this.curve1, fraction0: this.fraction0, fraction1: this.fraction1 };
    }
    /** Establish the nextJoint and previousJoint links from joint0 to joint1. */
    static link(joint0, joint1) {
        joint0.nextJoint = joint1;
        if (joint1)
            joint1.previousJoint = joint0;
        if (joint0.curve1 && joint1 && !joint1.curve0)
            joint1.curve0 = joint0.curve1;
        else if (!joint0.curve1 && joint1 && joint1.curve0)
            joint0.curve1 = joint1.curve0;
    }
    /**
     * * If nextJoint and nextJoint.fraction0 are defined, return them.
     * * Otherwise return defaultValue
     */
    nextJointFraction0(defaultValue) {
        if (this.nextJoint && this.nextJoint.fraction0 !== undefined)
            return this.nextJoint.fraction0;
        return defaultValue;
    }
    static addStrokes(destination, curve) {
        if (curve) {
            curve.emitStrokes(destination);
        }
    }
    static addPoint(destination, point) {
        if (destination.packedPoints.length > 0) {
            const pointA = destination.endPoint();
            if (!pointA.isAlmostEqual(point))
                destination.packedPoints.push(point);
        }
    }
    static collectStrokesFromChain(start, destination, maxTest = 100) {
        let numOut = -2 * maxTest; // allow extra things to happen
        Joint.visitJointsOnChain(start, (joint) => {
            this.addStrokes(destination, joint.jointCurve);
            if (joint.curve1 && joint.fraction1 !== undefined) {
                const fA = joint.fraction1;
                const fB = joint.nextJointFraction0(1.0);
                let curve1;
                if (fA === 0.0 && fB === 1.0)
                    curve1 = joint.curve1.clone();
                else if (fA < fB)
                    curve1 = joint.curve1.clonePartialCurve(fA, fB);
                if (curve1) {
                    if (!joint.jointCurve) {
                        this.addPoint(destination, curve1.startPoint());
                    }
                }
                this.addStrokes(destination, curve1);
            }
            return numOut++ < maxTest;
        }, maxTest);
    }
    static collectPrimitive(destination, primitive) {
        if (primitive)
            destination.push(primitive);
    }
    static collectCurvesFromChain(start, destination, maxTest = 100) {
        let numOut = -2 * maxTest; // allow extra things to happen
        Joint.visitJointsOnChain(start, (joint) => {
            this.collectPrimitive(destination, joint.jointCurve);
            if (joint.curve1 && joint.fraction1 !== undefined) {
                const fA = joint.fraction1;
                const fB = joint.nextJointFraction0(1.0);
                let curve1;
                if (fA === 0.0 && fB === 1.0)
                    curve1 = joint.curve1.clone();
                else if (fA < fB)
                    curve1 = joint.curve1.clonePartialCurve(fA, fB);
                this.collectPrimitive(destination, curve1);
            }
            return numOut++ < maxTest;
        }, maxTest);
    }
    /** Execute `joint.annotateJointMode()` at all joints on the chain. */
    static annotateChain(start, options, maxTest = 100) {
        Joint.visitJointsOnChain(start, (joint) => { joint.annotateJointMode(options); return true; }, maxTest);
    }
    /**
     * Visit joints on a chain.
     * * terminate on `false` return from `callback`
     * @param start first (and, for cyclic chain, final) Joint
     * @param callback function to call with each Joint as a single parameter.
     */
    static visitJointsOnChain(start, callback, maxTest = 100) {
        let joint = start;
        if (joint) {
            let numTest = 0;
            while (joint !== undefined) {
                if (numTest++ >= maxTest + 5)
                    return true;
                if (!callback(joint))
                    return false;
                joint = joint.nextJoint;
                if (joint === start)
                    break;
            }
        }
        return true;
    }
    annotateExtension(options) {
        if (this.curve0 && this.curve1) {
            const ray0 = this.curve0.fractionToPointAndDerivative(1.0); // And we know that is full length ray !
            const ray1 = this.curve1.fractionToPointAndDerivative(0.0); // ditto
            const intersection = Ray3d_1.Ray3d.closestApproachRay3dRay3d(ray0, ray1);
            if (intersection.approachType === CurveLocationDetail_1.CurveCurveApproachType.Intersection) {
                this.fraction0 = 1.0;
                this.fraction1 = 0.0;
                if (intersection.detailA.fraction >= 0.0 && intersection.detailB.fraction <= 0.0) {
                    this.flexure = JointMode.Extend;
                    const theta = ray0.getDirectionRef().angleToXY(ray1.getDirectionRef());
                    if (options.needArc(theta)) {
                        const arc = Joint.constructArc(ray0, this.curve0.baseCurveEnd, ray1);
                        if (arc) {
                            this.fraction0 = 1.0;
                            this.fraction1 = 0.0;
                            this.jointCurve = arc;
                            return;
                        }
                    }
                    const numChamferPoints = options.numChamferPoints(theta);
                    if (numChamferPoints <= 1) {
                        this.jointCurve = LineString3d_1.LineString3d.create(ray0.origin, intersection.detailA.point, ray1.origin);
                        return;
                    }
                    if (numChamferPoints > 1) {
                        // A nontrivial linestring ...
                        const radians0 = theta.radians;
                        const numHalfStep = 2.0 * numChamferPoints;
                        const halfStepRadians = radians0 / numHalfStep;
                        const arc = Joint.constructArc(ray0, this.curve0.baseCurveEnd, ray1);
                        if (arc !== undefined) {
                            const radialFraction = 1 / Math.cos(halfStepRadians);
                            const jointCurve = LineString3d_1.LineString3d.create();
                            this.jointCurve = jointCurve;
                            jointCurve.addPoint(ray0.origin); // possibly extend segment or line string
                            for (let i = 0; i < numChamferPoints; i++) {
                                const arcFraction = (1 + 2 * i) / numHalfStep;
                                jointCurve.addPoint(arc.fractionAndRadialFractionToPoint(arcFraction, radialFraction));
                            }
                            jointCurve.addPoint(ray1.origin); // possibly extend segment or line string.
                            return;
                        }
                    }
                }
            }
            // desperation appears ...
            this.flexure = JointMode.Gap;
            this.jointCurve = LineSegment3d_1.LineSegment3d.create(this.curve0.fractionToPoint(1.0), this.curve1.fractionToPoint(0.0));
            this.fraction0 = 1.0;
            this.fraction1 = 0.0;
        }
    }
    // Select the index at which summed fraction difference is smallest.
    selectIntersectionIndexByFraction(fractionA, fractionB, intersections) {
        let index = -1;
        let aMin = Number.MAX_VALUE;
        for (let i = 0; i < intersections.dataA.length; i++) {
            const a = Math.abs(intersections.dataA[i].fraction - fractionA) + Math.abs(intersections.dataB[i].fraction - fractionB);
            if (a < aMin) {
                aMin = a;
                index = i;
            }
        }
        return index;
    }
    /**
     * Examine the adjacent geometry
     * * set JointMode:  one of Cap Extend, or Trim
     * * set fraction0 and fraction1 of intersection of curve0 and curve1
     * * this REFERENCES curve0, curve1, fraction0, fraction1
     * * this does not reference nextJoint and previousJoint
     */
    annotateJointMode(options) {
        if (this.curve0 && !this.curve1) {
            this.flexure = JointMode.Cap;
            this.fraction0 = 1.0;
        }
        else if (this.curve1 && !this.curve0) {
            this.flexure = JointMode.Cap;
            this.fraction1 = 0.0;
        }
        else if (this.curve0 && this.curve1) {
            const ray0 = this.curve0.fractionToPointAndDerivative(0.0); // And we know that is full length ray !
            const ray1 = this.curve1.fractionToPointAndDerivative(0.0); // ditto
            if (this.curve0 instanceof LineSegment3d_1.LineSegment3d && this.curve1 instanceof LineSegment3d_1.LineSegment3d) {
                // check for direct intersection -- occurs on offset of colinear base segments.
                if (this.curve0.endPoint().isAlmostEqual(this.curve1.startPoint())) {
                    this.fraction0 = 1.0;
                    this.fraction1 = 0.0;
                    this.flexure = JointMode.Trim;
                }
                else {
                    const intersection = Ray3d_1.Ray3d.closestApproachRay3dRay3d(ray0, ray1);
                    if (intersection.approachType === CurveLocationDetail_1.CurveCurveApproachType.Intersection) {
                        this.fraction0 = intersection.detailA.fraction;
                        this.fraction1 = intersection.detailB.fraction;
                        if (this.fraction0 >= 1.0 && this.fraction1 <= 0.0) {
                            this.annotateExtension(options);
                        }
                        else if (this.fraction0 < 1.0 && this.fraction1 > 0.0) {
                            this.flexure = JointMode.Trim;
                        }
                        else if (this.fraction0 > 1.0 && this.fraction1 > 1.0) {
                            this.flexure = JointMode.Gap;
                            this.jointCurve = LineSegment3d_1.LineSegment3d.create(this.curve0.fractionToPoint(1.0), this.curve1.fractionToPoint(0.0));
                            this.fraction0 = 1.0;
                            this.fraction1 = 0.0;
                        }
                    }
                }
            }
            else {
                // generic pair of curves ...
                const intersections = CurveCurve_1.CurveCurve.intersectionXY(this.curve0, false, this.curve1, false);
                const intersectionIndex = this.selectIntersectionIndexByFraction(1.0, 0.0, intersections);
                if (intersectionIndex >= 0) {
                    this.flexure = JointMode.Trim;
                    this.fraction0 = intersections.dataA[intersectionIndex].fraction;
                    this.fraction1 = intersections.dataB[intersectionIndex].fraction;
                }
                else {
                    this.annotateExtension(options);
                }
            }
        }
    }
    /**
     * * Examine the primitive trim fractions between each pair of joints.
     * * If trim fractions indicate the primitive must disappear, replace the joint pair by a new joint pointing at surrounding primitives
     * @param start
     */
    static removeDegeneratePrimitives(start, options, maxTest) {
        /*
        if (Checker.noisy.PolygonOffset)
          console.log("\nENTER removeDegenerates");
        */
        let jointA = start;
        let numRemoved = 0;
        const maxRemove = 1;
        let numTest = 0;
        if (jointA) {
            while (jointA !== undefined && numTest++ < maxTest) {
                const jointB = jointA.nextJoint;
                if (jointA
                    && jointB
                    && jointA.previousJoint
                    && jointB.nextJoint
                    && jointA.fraction1 !== undefined
                    && jointB.fraction0 !== undefined) {
                    const f0 = jointA.fraction1;
                    const f1 = jointB.fraction0;
                    const g0 = jointB.fraction1;
                    const g1 = jointB.nextJoint.fraction0;
                    // f0 and f1 are fractions on the single primitive between these joints.
                    /*
                      if (Checker.noisy.PolygonOffset) {
                        console.log("joint candidate");
                        console.log(prettyPrint(jointA.shallowExtract()));
                        console.log(prettyPrint(jointB.shallowExtract()));
                        console.log("FRACTIONS ", { fA1: f0, fB0: f1 });
                      }
                    */
                    const eliminateF = f0 >= f1 || f0 > 1.0;
                    const eliminateG = (g0 !== undefined && g0 > 1.0)
                        || (g0 !== undefined && g1 !== undefined && g0 >= g1);
                    if (eliminateF && eliminateG) {
                        const jointC = jointB.nextJoint;
                        const newJoint = new Joint(jointA.curve0, jointC.curve1, undefined);
                        Joint.link(jointA.previousJoint, newJoint);
                        Joint.link(newJoint, jointC.nextJoint);
                        newJoint.annotateJointMode(options);
                        newJoint.previousJoint.annotateJointMode(options);
                        if (newJoint.nextJoint)
                            newJoint.nextJoint.annotateJointMode(options);
                        /*
                        if (Checker.noisy.PolygonOffset) {
                          console.log(" NEW DOUBLE CUT");
                          console.log(prettyPrint(newJoint.shallowExtract()));
                        }
                        */
                    }
                    else if (eliminateF) {
                        const newJoint = new Joint(jointA.curve0, jointB.curve1, undefined);
                        Joint.link(jointA.previousJoint, newJoint);
                        Joint.link(newJoint, jointB.nextJoint);
                        newJoint.annotateJointMode(options);
                        newJoint.previousJoint.annotateJointMode(options);
                        newJoint.nextJoint.annotateJointMode(options);
                        /*
                        if (Checker.noisy.PolygonOffset) {
                          console.log(" NEW JOINT");
                          console.log(prettyPrint(newJoint.shallowExtract()));
                        }
                      */
                        numRemoved++;
                        if (jointA === start)
                            start = newJoint;
                        jointA = newJoint;
                        if (numRemoved >= maxRemove) {
                            /*
                            if (Checker.noisy.PolygonOffset)
                              console.log(" EXIT removeDegenerates at maxRemove\n");
                            */
                            return { newStart: start, numJointRemoved: numRemoved };
                        }
                    }
                }
                jointA = jointA.nextJoint;
                if (jointA === start)
                    break;
            }
        }
        return { newStart: start, numJointRemoved: numRemoved };
    }
}
/**
 * Context for building a wire offset.
 * @internal
 */
class PolygonWireOffsetContext {
    /** construct a context. */
    constructor() {
    }
    // Construct a single offset from base points
    static createOffsetSegment(basePointA, basePointB, distance) {
        Point3dVector3d_1.Vector3d.createStartEnd(basePointA, basePointB, this._unitAlong);
        if (this._unitAlong.normalizeInPlace()) {
            this._unitAlong.rotate90CCWXY(this._unitPerp);
            const segment = LineSegment3d_1.LineSegment3d.create(basePointA.plusScaled(this._unitPerp, distance, this._offsetA), basePointB.plusScaled(this._unitPerp, distance, this._offsetB));
            CurveChainWireOffsetContext.applyBasePoints(segment, basePointA.clone(), basePointB.clone());
            return segment;
        }
        return undefined;
    }
    /**
     * Construct curves that are offset from a polygon.
     * * The construction will remove "some" local effects of features smaller than the offset distance, but will not detect self intersection with far-away edges.
     * @param points
     * @param wrap
     * @param offsetDistance
     */
    constructPolygonWireXYOffset(points, wrap, leftOffsetDistanceOrOptions) {
        const options = JointOptions.create(leftOffsetDistanceOrOptions);
        const numPoints = points.length;
        let fragment0 = PolygonWireOffsetContext.createOffsetSegment(points[0], points[1], options.leftOffsetDistance);
        let joint0 = new Joint(undefined, fragment0, points[0]);
        let newJoint;
        let previousJoint = joint0;
        for (let i = 1; i + 1 < numPoints; i++) {
            const fragment1 = PolygonWireOffsetContext.createOffsetSegment(points[i], points[i + 1], options.leftOffsetDistance);
            newJoint = new Joint(fragment0, fragment1, points[i]);
            Joint.link(previousJoint, newJoint);
            previousJoint = newJoint;
            fragment0 = fragment1;
        }
        if (wrap)
            Joint.link(previousJoint, joint0);
        else {
            newJoint = new Joint(fragment0, undefined, points[numPoints - 1]);
            Joint.link(previousJoint, newJoint);
        }
        Joint.annotateChain(joint0, options, numPoints);
        for (let pass = 0; pass++ < 5;) {
            const state = Joint.removeDegeneratePrimitives(joint0, options, numPoints);
            joint0 = state.newStart;
            if (state.numJointRemoved === 0)
                break;
            /*
            if (Checker.noisy.PolygonOffset) {
              console.log("  POST REMOVE DEGENERATES  " + state.numJointRemoved);
              Joint.visitJointsOnChain(joint0, (joint: Joint) => { console.log(prettyPrint(joint.shallowExtract())); return true; });
            }
            */
        }
        // Joint.collectPrimitivesFromChain(joint0, result, numPoints);
        const chain = LineString3d_1.LineString3d.create();
        Joint.collectStrokesFromChain(joint0, chain, numPoints);
        const n = chain.packedPoints.length;
        if (n > 1) {
            if (chain.packedPoints.front().isAlmostEqual(chain.packedPoints.back()))
                return Loop_1.Loop.create(chain);
            else
                return Path_1.Path.create(chain);
        }
        return undefined;
    }
}
exports.PolygonWireOffsetContext = PolygonWireOffsetContext;
PolygonWireOffsetContext._unitAlong = Point3dVector3d_1.Vector3d.create();
PolygonWireOffsetContext._unitPerp = Point3dVector3d_1.Vector3d.create();
PolygonWireOffsetContext._offsetA = Point3dVector3d_1.Point3d.create();
PolygonWireOffsetContext._offsetB = Point3dVector3d_1.Point3d.create();
/**
 * Context for building a wire offset from a Path or Loop of CurvePrimitives
 * @internal
 */
class CurveChainWireOffsetContext {
    /** construct a context. */
    constructor() {
    }
    // Construct a single offset from base points
    static createOffsetSegment(basePointA, basePointB, distanceLeft) {
        Point3dVector3d_1.Vector3d.createStartEnd(basePointA, basePointB, this._unitAlong);
        if (this._unitAlong.normalizeInPlace()) {
            this._unitAlong.rotate90CCWXY(this._unitPerp);
            return LineSegment3d_1.LineSegment3d.create(basePointA.plusScaled(this._unitPerp, distanceLeft, this._offsetA), basePointB.plusScaled(this._unitPerp, distanceLeft, this._offsetB));
        }
        return undefined;
    }
    /**
     * Annotate a CurvePrimitive with properties `baseCurveStart` and `baseCurveEnd`.
     * * return cp
     * @param cp primitive to annotate
     * @param startPoint optional start point
     * @param endPoint optional end point
     */
    static applyBasePoints(cp, startPoint, endPoint) {
        if (cp !== undefined) {
            if (startPoint !== undefined)
                cp.baseCurveStart = startPoint;
            if (endPoint !== undefined)
                cp.baseCurveEnd = endPoint;
        }
        return cp;
    }
    /**
     * Create the offset of a single primitive.
     * * each primitive may be labeled (as an `any` object) with start or end point of base curve:
     *   * `(primitive as any).baseCurveStart: Point3d`
     *   * `(primitive as any).baseCurveEnd: Point3d`
     * @param g primitive to offset
     * @param distanceLeft
     */
    static createSingleOffsetPrimitiveXY(g, distanceLeft) {
        const point0 = g.fractionToPoint(0.0);
        const point1 = g.fractionToPoint(1.0);
        if (g instanceof LineSegment3d_1.LineSegment3d) {
            return this.applyBasePoints(this.createOffsetSegment(point0, point1, distanceLeft), point0, point1);
        }
        else if (g instanceof Arc3d_1.Arc3d) {
            const g1 = g.cloneAtZ();
            if (g1.isCircular) {
                const sign = g1.sweep.sweepRadians * g1.matrix.coffs[8] >= 0.0 ? 1.0 : -1.0;
                const r = g1.matrix.columnXMagnitude();
                const r1 = r - sign * distanceLeft;
                if (r1 >= 0) {
                    const factor = r1 / r;
                    const matrix = g1.matrix;
                    matrix.scaleColumnsInPlace(factor, factor, 1.0);
                    return this.applyBasePoints(Arc3d_1.Arc3d.createRefs(g1.center.clone(), matrix, g1.sweep.clone()), g.startPoint(), g.endPoint());
                }
            }
        }
        else if (g instanceof LineString3d_1.LineString3d) {
            const n = g.numPoints();
            if (n > 1) {
                const offsets = [];
                const pointA = Point3dVector3d_1.Point3d.create();
                const pointB = Point3dVector3d_1.Point3d.create();
                g.packedPoints.getPoint3dAtUncheckedPointIndex(0, pointA);
                for (let i = 1; i < n; i++) {
                    g.packedPoints.getPoint3dAtUncheckedPointIndex(i, pointB);
                    const g1 = this.applyBasePoints(this.createOffsetSegment(pointA, pointB, distanceLeft), pointA.clone(), pointB.clone());
                    if (g1 !== undefined)
                        offsets.push(g1);
                    pointA.setFromPoint3d(pointB);
                }
                return offsets;
            }
        }
        return undefined;
    }
    /**
     * Construct curves that are offset from a Path or Loop
     * * The construction will remove "some" local effects of features smaller than the offset distance, but will not detect self intersection among widely separated edges.
     * * Offset distance is defined as positive to the left.
     * * If offsetDistanceOrOptions is given as a number, default options are applied.
     * * When the offset needs to do an "outside" turn, the first applicable construction is applied:
     *   * If the turn is larger than `options.minArcDegrees`, a circular arc is constructed.
     *   * if the turn is larger than `options.maxChamferDegrees`, the turn is constructed as a sequence of straight lines that are
     *      * outside the arc
     *      * have uniform turn angle less than `options.maxChamferDegrees`
     *      * each line segment (except first and last) touches the arc at its midpoint.
     *   * Otherwise the prior and successor curves are extended to simple intersection.
     * @param curves input curves
     * @param offsetDistanceOrOptions offset controls.
     */
    static constructCurveXYOffset(curves, options) {
        const wrap = curves instanceof Loop_1.Loop;
        if (options === undefined)
            return undefined;
        const simpleOffsets = [];
        // setup pass: get simple offsets of each primitive
        for (const c of curves.children) {
            const c1 = CurveChainWireOffsetContext.createSingleOffsetPrimitiveXY(c, options.leftOffsetDistance);
            if (c1 === undefined)
                return undefined;
            if (c1 instanceof CurvePrimitive_1.CurvePrimitive)
                simpleOffsets.push(c1);
            else if (Array.isArray(c1)) {
                for (const c2 of c1) {
                    if (c2 instanceof CurvePrimitive_1.CurvePrimitive)
                        simpleOffsets.push(c2);
                }
            }
        }
        let fragment0 = simpleOffsets[0];
        const joint0 = new Joint(undefined, fragment0, fragment0.fractionToPoint(0.0));
        let newJoint;
        let previousJoint = joint0;
        for (let i = 1; i < simpleOffsets.length; i++) {
            const fragment1 = simpleOffsets[i];
            newJoint = new Joint(fragment0, fragment1, fragment1.fractionToPoint(0.0));
            Joint.link(previousJoint, newJoint);
            previousJoint = newJoint;
            fragment0 = fragment1;
        }
        if (curves instanceof Loop_1.Loop)
            Joint.link(previousJoint, joint0);
        const numOffset = simpleOffsets.length;
        Joint.annotateChain(joint0, options, numOffset);
        const outputCurves = [];
        Joint.collectCurvesFromChain(joint0, outputCurves, numOffset);
        return RegionOps_1.RegionOps.createLoopPathOrBagOfCurves(outputCurves, wrap);
    }
}
exports.CurveChainWireOffsetContext = CurveChainWireOffsetContext;
CurveChainWireOffsetContext._unitAlong = Point3dVector3d_1.Vector3d.create();
CurveChainWireOffsetContext._unitPerp = Point3dVector3d_1.Vector3d.create();
CurveChainWireOffsetContext._offsetA = Point3dVector3d_1.Point3d.create();
CurveChainWireOffsetContext._offsetB = Point3dVector3d_1.Point3d.create();


/***/ }),

/***/ "./lib/curve/Query/ConsolidateAdjacentPrimitivesContext.js":
/*!*****************************************************************!*\
  !*** ./lib/curve/Query/ConsolidateAdjacentPrimitivesContext.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const CurveCollection_1 = __webpack_require__(/*! ../CurveCollection */ "./lib/curve/CurveCollection.js");
const GeometryHandler_1 = __webpack_require__(/*! ../../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const LineSegment3d_1 = __webpack_require__(/*! ../LineSegment3d */ "./lib/curve/LineSegment3d.js");
const LineString3d_1 = __webpack_require__(/*! ../LineString3d */ "./lib/curve/LineString3d.js");
const PolylineOps_1 = __webpack_require__(/*! ../../geometry3d/PolylineOps */ "./lib/geometry3d/PolylineOps.js");
const Arc3d_1 = __webpack_require__(/*! ../Arc3d */ "./lib/curve/Arc3d.js");
const CurveFactory_1 = __webpack_require__(/*! ../CurveFactory */ "./lib/curve/CurveFactory.js");
/** @module Curve */
/**
 * * Implementation class for ConsolidateAdjacentCurvePrimitives.
 *
 * @internal
 */
class ConsolidateAdjacentCurvePrimitivesContext extends GeometryHandler_1.NullGeometryHandler {
    constructor(options) {
        super();
        this._options = options ? options : new CurveCollection_1.ConsolidateAdjacentCurvePrimitivesOptions();
    }
    /** look for adjacent compatible primitives in a path or loop. */
    handleCurveChain(g) {
        const children = g.children;
        const numOriginal = children.length;
        const points = [];
        let numAccept = 0;
        // i0 <=i < i1 is a range of child indices.
        // numAccept is the number of children accepted (contiguously at front of children)
        for (let i0 = 0; i0 < numOriginal;) {
            const basePrimitive = g.children[i0];
            if (this._options.consolidateLinearGeometry && (basePrimitive instanceof LineSegment3d_1.LineSegment3d || basePrimitive instanceof LineString3d_1.LineString3d)) {
                points.length = 0;
                let i1 = i0;
                // on exit, i1 is beyond the block of linear primitives  . ..
                for (; i1 < g.children.length; i1++) {
                    const nextPrimitive = g.children[i1];
                    if (nextPrimitive instanceof LineSegment3d_1.LineSegment3d) {
                        points.push(nextPrimitive.startPoint());
                        points.push(nextPrimitive.endPoint());
                    }
                    else if (nextPrimitive instanceof LineString3d_1.LineString3d) {
                        const source = nextPrimitive.packedPoints;
                        for (let k = 0; k < source.length; k++) {
                            points.push(source.getPoint3dAtUncheckedPointIndex(k));
                        }
                    }
                    else {
                        break;
                    }
                }
                if (points.length > 1) {
                    const compressedPointsA = PolylineOps_1.PolylineOps.compressShortEdges(points, this._options.colinearPointTolerance);
                    const compressedPointsB = PolylineOps_1.PolylineOps.compressByPerpendicularDistance(compressedPointsA, this._options.colinearPointTolerance);
                    if (compressedPointsB.length < 2) {
                        // Collapsed to a point?  Make a single point linestring
                        g.children[numAccept++] = LineString3d_1.LineString3d.create(compressedPointsB[0]);
                    }
                    else if (compressedPointsB.length === 2) {
                        g.children[numAccept++] = LineSegment3d_1.LineSegment3d.create(compressedPointsB[0], compressedPointsB[1]);
                    }
                    else {
                        g.children[numAccept++] = LineString3d_1.LineString3d.createPoints(compressedPointsB);
                    }
                }
                else {
                    g.children[numAccept++] = basePrimitive;
                }
                i0 = i1;
            }
            else if (this._options.consolidateCompatibleArcs && basePrimitive instanceof Arc3d_1.Arc3d) {
                // subsume subsequent arcs into basePrimitive.
                // always accept base primitive.
                for (; ++i0 < g.children.length;) {
                    const nextPrimitive = g.children[i0];
                    if (!(nextPrimitive instanceof Arc3d_1.Arc3d))
                        break;
                    if (!CurveFactory_1.CurveFactory.appendToArcInPlace(basePrimitive, nextPrimitive))
                        break;
                }
                // i0 has already advanced
                g.children[numAccept++] = basePrimitive; // which has been extended 0 or more times.
            }
            else {
                g.children[numAccept++] = basePrimitive;
                i0++;
            }
        }
        g.children.length = numAccept;
    }
    handlePath(g) { return this.handleCurveChain(g); }
    handleLoop(g) { return this.handleCurveChain(g); }
}
exports.ConsolidateAdjacentCurvePrimitivesContext = ConsolidateAdjacentCurvePrimitivesContext;


/***/ }),

/***/ "./lib/curve/Query/CurveSplitContext.js":
/*!**********************************************!*\
  !*** ./lib/curve/Query/CurveSplitContext.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurvePrimitive_1 = __webpack_require__(/*! ../CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const Geometry_1 = __webpack_require__(/*! ../../Geometry */ "./lib/Geometry.js");
const CurveCollection_1 = __webpack_require__(/*! ../CurveCollection */ "./lib/curve/CurveCollection.js");
const CurveCurve_1 = __webpack_require__(/*! ../CurveCurve */ "./lib/curve/CurveCurve.js");
const Path_1 = __webpack_require__(/*! ../Path */ "./lib/curve/Path.js");
/**
 * Data about a curve cut.
 */
class CutFractionDescriptor {
    constructor(fraction, otherCurveDetail) {
        this.fraction = fraction;
        this.otherCurveDetail = otherCurveDetail;
    }
    /** Transfer data from other to this.
     * * Optionally look at both to set `otherCurveDetail`
     *   * `other.otherCurveDetail` wins over `this.otherCurveDetail`
     */
    setFrom(other, combineCutFlag) {
        if (combineCutFlag && this.isSameFraction(other))
            this.otherCurveDetail = other.otherCurveDetail ? other.otherCurveDetail : this.otherCurveDetail;
        this.fraction = other.fraction;
    }
    /** Test if a the fractions are almost equal. */
    isSameFraction(other) {
        return Geometry_1.Geometry.isSmallAngleRadians(this.fraction - other.fraction);
    }
    /** set from direct data */
    set(fraction, otherCurveDetail) {
        this.fraction = fraction;
        this.otherCurveDetail = otherCurveDetail;
    }
}
/**
 * Context for splitting curves.
 * @internal
 */
class CurveSplitContext {
    // return true if data has one or more non-endpoint intersections.
    static hasInteriorDetailAIntersections(data, fractionTolerance = Geometry_1.Geometry.smallAngleRadians) {
        if (data.length === 0)
            return false;
        for (const pair of data) {
            if (pair.detailA.fraction > fractionTolerance || pair.detailA.fraction < 1 - fractionTolerance)
                return true;
        }
        return false;
    }
    collectFragmentAndAdvanceCut(curveToCut, cutA, cutB, dest) {
        if (!cutA.isSameFraction(cutB)) {
            const fragment = curveToCut.clonePartialCurve(cutA.fraction, cutB.fraction);
            if (fragment !== undefined) {
                fragment.startCut = cutA.otherCurveDetail;
                fragment.endCut = cutB.otherCurveDetail;
                dest.push(fragment);
            }
        }
        cutA.setFrom(cutB, true);
    }
    /** Collect fragments from an intersections array, with the array detailA entries all referencing to curveToCut.
     * * The `intersections` array is sorted on its detailA field.
     */
    collectSinglePrimitiveFragments(curveToCut, intersections, fragments) {
        if (intersections === undefined || !CurveSplitContext.hasInteriorDetailAIntersections(intersections)) {
            const fragment = curveToCut.clone();
            if (fragment)
                fragments.push(fragment);
            return;
        }
        intersections.sort((pairA, pairB) => (pairA.detailA.fraction - pairB.detailA.fraction));
        const cutA = new CutFractionDescriptor(0.0, undefined);
        const cutB = new CutFractionDescriptor(1.0, undefined); // but those values are immediately reset before use.
        for (const pair of intersections) {
            cutB.set(pair.detailA.fraction, pair.detailB);
            this.collectFragmentAndAdvanceCut(curveToCut, cutA, cutB, fragments);
        }
        cutB.set(1.0, undefined);
        this.collectFragmentAndAdvanceCut(curveToCut, cutA, cutB, fragments);
    }
    static cloneCurvesWithXYSplitFlags(curvesToCut, cutterCurves) {
        const context = new CurveSplitContext();
        if (curvesToCut instanceof CurvePrimitive_1.CurvePrimitive) {
            const result = [];
            const intersections = CurveCurve_1.CurveCurve.intersectionXYPairs(curvesToCut, false, cutterCurves, false);
            context.collectSinglePrimitiveFragments(curvesToCut, intersections, result);
            if (result.length === 1)
                return result[0];
            return Path_1.Path.createArray(result);
        }
        else if (curvesToCut instanceof CurveCollection_1.CurveChain) {
            const result = [];
            for (const primitive of curvesToCut.children) {
                const intersections = CurveCurve_1.CurveCurve.intersectionXYPairs(primitive, false, cutterCurves, false);
                context.collectSinglePrimitiveFragments(primitive, intersections, result);
            }
            return Path_1.Path.createArray(result);
        }
        return undefined;
    }
}
exports.CurveSplitContext = CurveSplitContext;


/***/ }),

/***/ "./lib/curve/Query/CylindricalRange.js":
/*!*********************************************!*\
  !*** ./lib/curve/Query/CylindricalRange.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const GeometryHandler_1 = __webpack_require__(/*! ../../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const LineString3d_1 = __webpack_require__(/*! ../LineString3d */ "./lib/curve/LineString3d.js");
const StrokeOptions_1 = __webpack_require__(/*! ../StrokeOptions */ "./lib/curve/StrokeOptions.js");
/**
 * Context for computing geometry range around an axis.
 * * The publicly called method is `computeZRRange (ray, geometry)
 */
class CylindricalRangeQuery extends GeometryHandler_1.RecurseToCurvesGeometryHandler {
    /** capture ray and initialize evolving ranges. */
    constructor(ray) {
        super();
        this._localPoint = Point3dVector3d_1.Point3d.create();
        this._worldPoint = Point3dVector3d_1.Point3d.create();
        this._perpVector = Point3dVector3d_1.Vector3d.createZero();
        this._maxDistance = 0.0;
        this._localToWorld = ray.toRigidZFrame();
    }
    announcePoint(xyz) {
        this._localToWorld.multiplyInversePoint3d(xyz, this._localPoint);
        const distance = this._localPoint.magnitudeXY();
        if (distance >= this._maxDistance) {
            this._maxDistance = distance;
            this._perpVector.setFromPoint3d(this._localPoint);
            this._perpVector.z = 0.0;
            this._localToWorld.matrix.multiplyXY(this._localPoint.x, this._localPoint.y, this._perpVector);
        }
    }
    handleLineSegment3d(segment0) {
        this.announcePoint(segment0.startPoint(this._worldPoint));
        this.announcePoint(segment0.endPoint(this._worldPoint));
    }
    handleLineString3d(ls0) {
        for (let i = 0; i < ls0.numPoints(); i++) {
            ls0.pointAt(i, this._worldPoint);
            this.announcePoint(this._worldPoint);
        }
    }
    handleArc3d(arc0) {
        // humbug .. just stroke it ..
        // exact solution is:
        //   project the arc to the z=0 plane of the local system.
        //   find max distance to origin.
        const numStroke = StrokeOptions_1.StrokeOptions.applyAngleTol(undefined, 3, arc0.sweep.sweepRadians, 0.1);
        const df = 1.0 / numStroke;
        for (let i = 0; i <= numStroke; i++) {
            arc0.fractionToPoint(i * df, this._worldPoint);
            this.announcePoint(this._worldPoint);
        }
        return undefined;
    }
    /**
     * Compute the largest vector perpendicular to a ray and ending on the geometry.
     * @param geometry0 geometry to search
     * @returns vector from ray to geometry.
     */
    static computeMaxVectorFromRay(ray, geometry) {
        const accumulator = new CylindricalRangeQuery(ray);
        geometry.dispatchToGeometryHandler(accumulator);
        return accumulator._perpVector.clone();
    }
    /**
     * Recurse through geometry.children to find linestrings.
     * In each linestring, compute the surface normal annotation from
     *  * the curve tangent stored in the linestring
     *  * the axis of rotation
     *  * a default V vector to be used when the linestring point is close to the axis.
     * @param geometry
     * @param axis
     * @param defaultVectorV
     */
    static buildRotationalNormalsInLineStrings(geometry, axis, defaultVectorFromAxis) {
        if (geometry instanceof LineString3d_1.LineString3d) {
            const points = geometry.packedPoints;
            const derivatives = geometry.packedDerivatives;
            const normals = geometry.ensureEmptySurfaceNormals();
            if (derivatives && normals) {
                const vectorU = Point3dVector3d_1.Vector3d.create();
                const vectorV = Point3dVector3d_1.Vector3d.create(); // v direction (forwward along sweep) for surface of rotation.
                const xyz = Point3dVector3d_1.Point3d.create();
                const n = points.length;
                for (let i = 0; i < n; i++) {
                    points.getPoint3dAtUncheckedPointIndex(i, xyz);
                    axis.perpendicularPartOfVectorToTarget(xyz, vectorU);
                    if (vectorU.isAlmostZero)
                        axis.direction.crossProduct(defaultVectorFromAxis, vectorV);
                    else
                        axis.direction.crossProduct(vectorU, vectorV);
                    geometry.packedDerivatives.getVector3dAtCheckedVectorIndex(i, vectorU); // reuse vector U as curve derivative
                    vectorU.crossProduct(vectorV, vectorV); // reuse vector V as normal!
                    vectorV.normalizeInPlace();
                    normals.push(vectorV);
                }
            }
        }
        else if (geometry.children) {
            const children = geometry.children;
            for (const child of children) {
                this.buildRotationalNormalsInLineStrings(child, axis, defaultVectorFromAxis);
            }
        }
    }
}
exports.CylindricalRangeQuery = CylindricalRangeQuery;


/***/ }),

/***/ "./lib/curve/Query/InOutTests.js":
/*!***************************************!*\
  !*** ./lib/curve/Query/InOutTests.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Loop_1 = __webpack_require__(/*! ../Loop */ "./lib/curve/Loop.js");
const Plane3dByOriginAndUnitNormal_1 = __webpack_require__(/*! ../../geometry3d/Plane3dByOriginAndUnitNormal */ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js");
const Angle_1 = __webpack_require__(/*! ../../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ../CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const ParityRegion_1 = __webpack_require__(/*! ../ParityRegion */ "./lib/curve/ParityRegion.js");
const Geometry_1 = __webpack_require__(/*! ../../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const UnionRegion_1 = __webpack_require__(/*! ../UnionRegion */ "./lib/curve/UnionRegion.js");
/**
 * Context for testing containment in Loop, ParityRegion and UnionRegion.
 * @internal
 */
class PointInOnOutContext {
    /**
     * In-out test for a single loop.
     * * Test by finding intersections with an xy line (xyz plane) in "some" direction.
     * * Test logic gets complicated if the plane has a vertex hit.
     * * If that happens, don't try to figure out the cases.   Just move on to another plane.
     * * Any "on" point triggers immediate 0 return.
     *   * (Hence if there are overlapping lines their self-canceling effect might be wrong.)
     * @param loop
     * @param x tested x coordinate
     * @param y tested y coordinate
     */
    static testPointInOnOutLoopXY(loop, x, y) {
        let plane;
        const xy = Point3dVector3d_1.Point3d.create(x, y);
        for (let radians = 0.0; Math.abs(radians) < 6.0; radians = -1.2313 * (radians + 0.3212897)) {
            plane = Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.createXYAngle(x, y, Angle_1.Angle.createRadians(radians));
            const normal = plane.getNormalRef();
            const intersections = [];
            for (const cp of loop.children) {
                if (cp instanceof CurvePrimitive_1.CurvePrimitive)
                    cp.appendPlaneIntersectionPoints(plane, intersections);
            }
            CurvePrimitive_1.CurvePrimitive.snapAndRestrictDetails(intersections, false, true);
            let numLeft = 0;
            let numRight = 0;
            let numTricky = 0;
            let wx, wy;
            // Count simple crossings to left and right.
            // Also count tricky crossings (vertex hits, onEdge)
            // If there are any tricky ones, go around with a different plane.
            // A intently devious tester could make every plane hit tricky things.
            for (const intersection of intersections) {
                if (intersection.intervalRole !== CurveLocationDetail_1.CurveIntervalRole.isolated
                    && intersection.intervalRole !== undefined) {
                    numTricky++;
                }
                wx = intersection.point.x - x;
                wy = intersection.point.y - y;
                if (Geometry_1.Geometry.isSameCoordinateXY(wx, wy, 0, 0))
                    return 0;
                const cross = Geometry_1.Geometry.crossProductXYXY(normal.x, normal.y, wx, wy);
                if (xy.isAlmostEqualXY(intersection.point))
                    return 0;
                if (cross < 0.0)
                    numLeft++;
                else if (cross > 0.0)
                    numRight++;
            }
            if (numTricky !== 0) // try another angle !!
                continue;
            const leftParity = numLeft & (0x01);
            const rightParity = numRight & (0x01);
            if (leftParity === rightParity)
                return leftParity === 1 ? 1 : -1;
        }
        return -1;
    }
    /**
     * strongly-typed parity region handling: XOR of all loops. (But any ON is returned as edge hit.)
     * @param parent
     * @param x
     * @param y
     */
    static testPointInOnOutParityRegionXY(parent, x, y) {
        let result = -1;
        for (const loop of parent.children) {
            if (loop instanceof Loop_1.Loop) {
                const q = this.testPointInOnOutLoopXY(loop, x, y);
                if (q === 0)
                    return 0;
                if (q > 0)
                    result = -result;
            }
        }
        return result;
    }
    static testPointInOnOutUnionRegionXY(parent, x, y) {
        for (const loop of parent.children) {
            const classify = this.testPointInOnOutRegionXY(loop, x, y);
            if (classify >= 0)
                return classify;
        }
        return -1;
    }
    static testPointInOnOutRegionXY(parent, x, y) {
        if (parent instanceof Loop_1.Loop)
            return this.testPointInOnOutLoopXY(parent, x, y);
        else if (parent instanceof ParityRegion_1.ParityRegion)
            return this.testPointInOnOutParityRegionXY(parent, x, y);
        else if (parent instanceof UnionRegion_1.UnionRegion)
            return this.testPointInOnOutUnionRegionXY(parent, x, y);
        return -1;
    }
}
exports.PointInOnOutContext = PointInOnOutContext;


/***/ }),

/***/ "./lib/curve/Query/StrokeCountChain.js":
/*!*********************************************!*\
  !*** ./lib/curve/Query/StrokeCountChain.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const StrokeCountMap_1 = __webpack_require__(/*! ./StrokeCountMap */ "./lib/curve/Query/StrokeCountMap.js");
const CurveCollection_1 = __webpack_require__(/*! ../CurveCollection */ "./lib/curve/CurveCollection.js");
const ParityRegion_1 = __webpack_require__(/*! ../ParityRegion */ "./lib/curve/ParityRegion.js");
const LineString3d_1 = __webpack_require__(/*! ../LineString3d */ "./lib/curve/LineString3d.js");
const Loop_1 = __webpack_require__(/*! ../Loop */ "./lib/curve/Loop.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../../Geometry */ "./lib/Geometry.js");
// cspell:word remapa
/**
 * abstract methods for callbacks during sweeps of collections of StrokeCount Structures.
 * * A set of StrokeCountMaps are to be visited multiple times.
 * * The logic that controls the sweep is as below.
 * * The callback object controls the number of sweeps and can adapt its action to the respective sweeps.
 * * Note that a "false" from cb.startPass() terminates passes for this chainIndex and primitiveIndex, but all others exit the whole sequence.
 * * This logic occurs 2 or three levels deep
 *   * outer level is "chains".   Simple swept path or loops have only one outer; parity regions have one outer per loop of the parity region
 *   * second level is primitive within chain.
 *     * If the primitives in a set are "single component", second level is lowest.
 *        * startSweep() and endSweep() calls are two parameters, with undefined componentIndex
 *     * If the primitives in a set are multi-component, there is a third level looping through corresponding components.
 * `
 *    if (!cb.startSweeps (chainIndex, primitiveIndex, componentIndex))
 *      return false;
 *    for (let pass = 0;cb.startPass (pass); pass++){
 *      for (each map in working set)
 *            if (!cb.visit (pass, map)) return false;
 *       if (!cb.endPass ()) return false;
 *        }
 *      }
 * if (!cb.endSweeps (chainIndex, primitiveIndex, componentIndex)) return false;
 * return true;
 * `
 * @internal
 */
class StrokeCountMapMultipassVisitor {
    /**
     * called to announce the beginning of one or more sweeps through related StrokeCountMap's
     * @param chainIndex index of loop or path within the various contours.
     * @param primitiveIndex index of primitive within the loop or path.
     * @param componentIndex optional component index.
     * @returns the number of sweeps to perform.
     */
    startSweeps(_chainIndex, _primitiveIndex, _componentIndex) { return true; }
    /**
     * announce the end of handling for particular chainIndex and primitiveIndex;
     * @return true to continue outer loops.
     */
    endSweeps(_chainIndex, _primitiveIndex, _componentIndex) { return true; }
}
exports.StrokeCountMapMultipassVisitor = StrokeCountMapMultipassVisitor;
/**
 * * pass 1: determine max numStroke
 * * pass 2: impose max numStroke
 * @internal
 */
class StrokeCountMapVisitorApplyMaxCount extends StrokeCountMapMultipassVisitor {
    constructor() {
        super();
        this.myMap = StrokeCountMap_1.StrokeCountMap.createWithComponentIndex();
    }
    /** set up for a pass through corresponding maps. */
    startPass(pass) {
        if (pass === 0) {
            this.myMap.numStroke = 0;
            return true;
        }
        else if (pass === 1) {
            // nothing to change == numStroke will be applied to each primitive.
            return true;
        }
        // all other pass numbers are rejected ...
        return false;
    }
    /** visit one of the set of corresponding maps. */
    visit(pass, map) {
        if (pass === 0) {
            if (map.numStroke > this.myMap.numStroke)
                this.myMap.numStroke = map.numStroke;
            return true;
        }
        else if (pass === 1) {
            // apply the max from prior pass
            map.numStroke = this.myMap.numStroke;
            return true;
        }
        // no other pass values should happen -- canceled by startPass.
        return false;
    }
    endPass(_pass) { return true; }
}
exports.StrokeCountMapVisitorApplyMaxCount = StrokeCountMapVisitorApplyMaxCount;
/**
 * * pass 1: determine max curveLength among maps presented.
 * * pass 2: set the a0 and a1 values to 0 and that max distance
 * @internal
 */
class StrokeCountMapVisitorApplyMaxCurveLength extends StrokeCountMapMultipassVisitor {
    constructor() {
        super();
        this.maxCurveLength = 0.0;
    }
    /** set up for a pass through corresponding maps. */
    startPass(pass) {
        if (pass === 0) {
            this.maxCurveLength = 0;
            return true;
        }
        else if (pass === 1) {
            // nothing to change == numStroke will be applied to each primitive.
            return true;
        }
        // all other pass numbers are rejected ...
        return false;
    }
    /** visit one of the set of corresponding maps. */
    visit(pass, map) {
        if (pass === 0) {
            this.maxCurveLength = Geometry_1.Geometry.maxXY(map.curveLength, this.maxCurveLength);
            return true;
        }
        else if (pass === 1) {
            // apply the max from prior pass
            map.a0 = 0.0;
            map.a1 = this.maxCurveLength;
            return true;
        }
        // no other pass values should happen -- canceled by startPass.
        return false;
    }
    endPass(_pass) { return true; }
}
exports.StrokeCountMapVisitorApplyMaxCurveLength = StrokeCountMapVisitorApplyMaxCurveLength;
/**
 * class `StrokeCountChain` contains:
 * * `maps` = an array of `StrokeCountMap`
 * * `parent` = parent CurveCollection.
 *
 * An instance is normally created with either a `Path` or `Loop` as the parent.
 */
class StrokeCountChain {
    constructor(parent, options) {
        this.parent = parent;
        this.maps = [];
        this.options = options;
    }
    static createForCurveChain(chain, options) {
        const result = new StrokeCountChain(chain, options);
        result.parent = chain;
        // A chain can only contain primitives !!!!
        for (const p of chain.children) {
            p.computeAndAttachRecursiveStrokeCounts(options);
            if (p.strokeData)
                result.maps.push(p.strokeData);
        }
        return result;
    }
    getStrokes() {
        const ls = LineString3d_1.LineString3d.create();
        if (this.options) {
            if (this.options.needNormals || this.options.needParams) {
                ls.ensureEmptyFractions();
                ls.ensureEmptyDerivatives();
                ls.ensureEmptyUVParams();
            }
        }
        for (const m of this.maps) {
            if (m.primitive)
                m.primitive.addMappedStrokesToLineString3D(m, ls);
        }
        return ls;
    }
    /** internal form of  */
    static applySummed01LimitsWithinArray(maps, incomingSum) {
        let movingSum = incomingSum;
        for (const m of maps) {
            m.a0 += movingSum;
            if (m.componentData) {
                m.a1 = this.applySummed01LimitsWithinArray(m.componentData, m.a0);
            }
            else {
                m.a1 += movingSum;
            }
            movingSum = m.a1;
        }
        return movingSum;
    }
    /**
     * walk the maps in the array.
     * * in maps with no component data
     *   * increment map.a0 and map.a1 by the incoming distance a0
     * * in maps with component data:
     *   * recurse through the component array.
     *   * increment map.a0 by the incoming a0.
     *   * returned a1 from the componentData array becomes a1
     * @returns upper value of a1 in final map.
     * @param maps
     * @param incomingSum lower value to add to a0 for first map.
     */
    applySummed01Limits(incomingSum) {
        return StrokeCountChain.applySummed01LimitsWithinArray(this.maps, incomingSum);
    }
}
exports.StrokeCountChain = StrokeCountChain;
/**
 * class `StrokeCountSection`\
 * * contains an array of `StrokeCountChain`.
 * * Hence it is the internal node level of a (1-level-deep) tree of `StrokeCountChain`
 * @internal
 */
class StrokeCountSection {
    constructor(parent) { this.parent = parent; this.chains = []; }
    /**
     * construct array of arrays of `StrokeCountMap`s
     * @param parent
     */
    static createForParityRegionOrChain(parent, options) {
        const result = new StrokeCountSection(parent);
        if (parent instanceof ParityRegion_1.ParityRegion) {
            for (const child of parent.children) {
                const p = StrokeCountChain.createForCurveChain(child, options);
                result.chains.push(p);
            }
        }
        else if (parent instanceof CurveCollection_1.CurveChain) {
            result.chains.push(StrokeCountChain.createForCurveChain(parent, options));
        }
        return result;
    }
    /** test if all sections have the same structure. */
    static areSectionsCompatible(sections, enforceCounts) {
        if (sections.length < 2)
            return true; // hm.. don't know if that is useful, but nothing to check here.
        const numChains = sections[0].chains.length;
        for (let i = 1; i < sections.length; i++) {
            // first level: must match number of paths or loops
            if (sections[i].chains.length !== numChains)
                return false;
            // second level: must have same number of primitives in each path or loop
            for (let j = 0; j < sections[0].chains.length; j++) {
                const numPrimitive = sections[0].chains[j].maps.length;
                if (sections[i].chains[j].maps.length !== numPrimitive)
                    return false;
                for (let k = 0; k < numPrimitive; k++) {
                    if (!sections[0].chains[j].maps[k].isCompatibleComponentStructure(sections[i].chains[j].maps[k], enforceCounts))
                        return false;
                }
            }
        }
        return true;
    }
    /** Within each section, sweep accumulate curveLength field, recording entry and exit sum in each map.
     * * In expected use, (a0,a1) are (0,a) where a is the (previously computed) max length among corresponding maps up and down the section arrays.
     */
    static remapa0a1WithinEachChain(sections) {
        for (const section of sections) {
            for (const chain of section.chains) {
                chain.applySummed01Limits(0.0);
            }
        }
    }
    static applyMultipassVisitorCallbackNoComponents(sections, chainIndex, primitiveIndex, componentIndex, callback) {
        const numSection = sections.length;
        if (!callback.startSweeps(chainIndex, primitiveIndex, componentIndex))
            return false;
        if (componentIndex === undefined) {
            // there are corresponding primitives directly at the section, chain, primitive index:
            for (let pass = 0;; pass++) {
                if (!callback.startPass(pass))
                    break;
                for (let sectionIndex = 0; sectionIndex < numSection; sectionIndex++)
                    if (!callback.visit(pass, sections[sectionIndex].chains[chainIndex].maps[primitiveIndex]))
                        return false;
                if (!callback.endPass(pass))
                    return false;
            }
        }
        else {
            // there are corresponding primitives at the section, chain, primitive,componentIndex
            // there are corresponding primitives directly at the section, chain, primitive index:
            for (let pass = 0;; pass++) {
                if (!callback.startPass(pass))
                    break;
                for (let sectionIndex = 0; sectionIndex < numSection; sectionIndex++)
                    if (!callback.visit(pass, sections[sectionIndex].chains[chainIndex].maps[primitiveIndex].componentData[componentIndex]))
                        return false;
                if (!callback.endPass(pass))
                    return false;
            }
        }
        if (!callback.endSweeps(chainIndex, primitiveIndex, componentIndex))
            return false;
        return true;
    }
    /**
     * Walk through the sections, emitting callbacks delimiting groups of corresponding primitives.
     * @param sections array of sections (possibly a single path or loop at each section, or possibly a set of parity loops.)
     * @param callback object to be notified during the traversal
     */
    static runMultiPassVisitorAtCorrespondingPrimitives(sections, callback) {
        const numChainPerSection = sections[0].chains.length;
        for (let chainIndex = 0; chainIndex < numChainPerSection; chainIndex++) {
            const numPrimitive = sections[0].chains[chainIndex].maps.length;
            for (let primitiveIndex = 0; primitiveIndex < numPrimitive; primitiveIndex++) {
                if (sections[0].chains[chainIndex].maps[primitiveIndex].componentData) {
                    const numComponent = sections[0].chains[chainIndex].maps[primitiveIndex].componentData.length;
                    for (let i = 0; i < numComponent; i++)
                        if (!this.applyMultipassVisitorCallbackNoComponents(sections, chainIndex, primitiveIndex, i, callback))
                            return false;
                }
                else {
                    if (!this.applyMultipassVisitorCallbackNoComponents(sections, chainIndex, primitiveIndex, undefined, callback))
                        return false;
                }
            }
        }
        return true;
    }
    /**
     * * Confirm that all sections in the array have the same structure.
     * * Within each corresponding set of entries, apply the max count to all.
     * @param sections array of per-section stroke count entries
     */
    static enforceStrokeCountCompatibility(sections) {
        if (sections.length < 2)
            return true;
        if (!StrokeCountSection.areSectionsCompatible(sections, false))
            return false;
        const visitor = new StrokeCountMapVisitorApplyMaxCount();
        this.runMultiPassVisitorAtCorrespondingPrimitives(sections, visitor);
        return true;
    }
    /**
     * * Confirm that all sections in the array have the same structure.
     * * Within each corresponding set of entries up and down the sections, set curveLength as the maximum of the respective curve lengths.
     * * Along each section, sum curveLengths (which were just reset) to get consistent along-chain parameters
     * @param sections array of per-section stroke count entries
     */
    static enforceCompatibleDistanceSums(sections) {
        if (sections.length < 2)
            return true;
        if (!StrokeCountSection.areSectionsCompatible(sections, false))
            return false;
        const visitor = new StrokeCountMapVisitorApplyMaxCurveLength();
        this.runMultiPassVisitorAtCorrespondingPrimitives(sections, visitor);
        this.remapa0a1WithinEachChain(sections);
        return true;
    }
    /**
     * Return stroked form of the section.
     */
    getStrokes() {
        if (this.chains.length === 1) {
            return this.chains[0].getStrokes();
        }
        else {
            const region = ParityRegion_1.ParityRegion.create();
            for (const c of this.chains) {
                const strokes = c.getStrokes();
                if (strokes instanceof LineString3d_1.LineString3d)
                    region.tryAddChild(Loop_1.Loop.create(strokes));
            }
            return region;
        }
    }
    /**
     * Given two compatible stroke sets (as returned by getStrokes) extend a range
     * with the distances between corresponding points.
     * * Each set of strokes may be:
     *   * linestring
     *   * ParityRegion
     *   * CurveChain (Loop or Path)
     * @param strokeA first set of strokes
     * @param strokeB second set of strokes
     * @param rangeToExtend caller-allocated range to be extended.
     * @returns true if structures are compatible.
     */
    static extendDistanceRangeBetweenStrokes(strokeA, strokeB, rangeToExtend) {
        if (!strokeA.isSameGeometryClass(strokeB))
            return false;
        if (strokeA instanceof LineString3d_1.LineString3d) {
            if (!(strokeB instanceof LineString3d_1.LineString3d))
                return false;
            if (strokeA.numPoints() === strokeB.numPoints()) {
                const n = strokeA.numPoints();
                const pointA = Point3dVector3d_1.Point3d.create();
                const pointB = Point3dVector3d_1.Point3d.create();
                const allPointA = strokeA.packedPoints;
                const allPointB = strokeB.packedPoints;
                for (let i = 0; i < n; i++) {
                    allPointA.getPoint3dAtCheckedPointIndex(i, pointA);
                    allPointB.getPoint3dAtCheckedPointIndex(i, pointB);
                    rangeToExtend.extendX(pointA.distance(pointB));
                }
                return true;
            }
        }
        else if (strokeA instanceof ParityRegion_1.ParityRegion) {
            if (!(strokeB instanceof ParityRegion_1.ParityRegion))
                return false;
            const childrenA = strokeA.children;
            const childrenB = strokeB.children;
            const n = childrenA.length;
            if (n === childrenB.length) {
                for (let i = 0; i < n; i++) {
                    if (!this.extendDistanceRangeBetweenStrokes(childrenA[i], childrenB[i], rangeToExtend))
                        return false;
                }
                return true;
            }
        }
        else if (strokeA instanceof CurveCollection_1.CurveChain) {
            if (!(strokeB instanceof CurveCollection_1.CurveChain))
                return false;
            const childrenA = strokeA.children;
            const childrenB = strokeB.children;
            const n = childrenA.length;
            if (n === childrenB.length) {
                for (let i = 0; i < n; i++) {
                    if (!this.extendDistanceRangeBetweenStrokes(childrenA[i], childrenB[i], rangeToExtend))
                        return false;
                }
                return true;
            }
        }
        return false;
    }
}
exports.StrokeCountSection = StrokeCountSection;


/***/ }),

/***/ "./lib/curve/Query/StrokeCountMap.js":
/*!*******************************************!*\
  !*** ./lib/curve/Query/StrokeCountMap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ../../Geometry */ "./lib/Geometry.js");
/** @module Curve */
/**
 * data carrier interface for per-primitive stroke counts and distances used by PolyfaceBuilder.
 * * For a simple primitive (Line segment or arc) that is stroked with uniform fraction, the members are:
 *   * `numStroke` = total number of strokes
 *   * `curveLength` = length of this curve
 *   * `a0` = external mapped coordinate for fraction 0 on this primitive or component
 *   * `a1` = external mapped coordinate for fraction 1 on this primitive or component
 *
 * * For linestring and bspline curve, those numbers are totals for the overall curve, and breakdown within
 *     the components (line segments or bezier spans) is recorded on the optional array `componentData[]`
 *   * Members of the array are annotated with componentIndex within the linestring or bspline curve
 * @public
 */
class StrokeCountMap {
    /**
     * Constructor.  Initialize all fields from arguments.
     * * Callers that expect to announce numStroke and curveLength for multiple components send an empty componentData array.
     * * Callers that do not have multiple components send undefined component data.
     * @param numStroke
     * @param curveLength
     * @param a0
     * @param a1
     * @param componentData
     */
    constructor(numStroke, curveLength, a0, a1, componentData) {
        this.numStroke = numStroke;
        this.curveLength = curveLength;
        this.a0 = a0;
        this.a1 = a1;
        this.componentData = componentData;
    }
    /**
     * Create a `StrokeCountMap` with curve primitive and optional componentData array.
     * @param primitive
     * @param numStroke
     * @param curveLength
     * @param a0
     * @param a1
     * @param componentData
     */
    static createWithCurvePrimitive(primitive, numStroke, curveLength, a0, a1, componentData) {
        const result = new StrokeCountMap(numStroke, curveLength, a0, a1, componentData);
        result.primitive = primitive;
        return result;
    }
    /**
     * Create a `StrokeCountMap` with `componentIndex` (but no primitive or componentData array)
     * @param index
     * @param numStroke
     * @param curveLength
     * @param a0
     * @param a1
     */
    static createWithComponentIndex(componentIndex = 0, numStroke = 0, curveLength = 0, a0 = 0, a1 = 0) {
        const result = new StrokeCountMap(numStroke, curveLength, a0, a1);
        result.componentIndex = componentIndex;
        return result;
    }
    /**
     * create a StrokeCountMap, optionally
     * * (a) use parent a1 as new a0
     * * (b) attach a (usually empty) array for component counts.
     * @param parentMap optional map whose a1 becomes a0 in the new map.
     * @param componentData optional array of component StrokeCountMaps.
     */
    static createWithCurvePrimitiveAndOptionalParent(curvePrimitive, parentMap, componentData) {
        const a0 = parentMap ? parentMap.a1 : 0.0;
        const result = new StrokeCountMap(0, 0, a0, a0, componentData);
        result.primitive = curvePrimitive;
        return result;
    }
    /**
     * Apply stroke count and curve length from a component to a parent map.
     * If componentData is present, install the new count and length with distance limits
     * @param parentMap map to be updated.
     * @param numStroke number of strokes on new child curve
     * @param curveLength curve length for new child curve.
     */
    addToCountAndLength(numStroke, curveLength) {
        const a2 = this.a1 + curveLength;
        if (this.componentData) {
            this.componentData.push(new StrokeCountMap(numStroke, curveLength, this.a1, a2));
        }
        this.numStroke += numStroke;
        this.curveLength += curveLength;
        this.a1 = a2;
    }
    /** return true if `other` has the same component structure as `this`
     * * testing recurses through corresponding members of componentData arrays.
     */
    isCompatibleComponentStructure(other, enforceCounts) {
        if (enforceCounts && this.numStroke !== other.numStroke)
            return false;
        if (this.componentData === undefined && other.componentData === undefined)
            return true;
        if (this.componentData && other.componentData) {
            // both have components. Recurse . . ..
            if (this.componentData.length !== other.componentData.length)
                return false;
            const n = this.componentData.length;
            for (let i = 0; i < n; i++)
                if (!this.componentData[i].isCompatibleComponentStructure(other.componentData[i], enforceCounts))
                    return false;
            return true;
        }
        // one has componentData, the other not.
        return false;
    }
    /**
     * * clone all data from root.
     * * clone componentData arrays recursively.
     */
    clone() {
        const a = new StrokeCountMap(this.numStroke, this.curveLength, this.a0, this.a1);
        if (this.componentData) {
            a.componentData = [];
            for (const child of this.componentData)
                a.componentData.push(child.clone());
        }
        return a;
    }
    /**
     * interpolate in the a0,a1 mapping.
     * @param fraction fractional position between a0 and a1
     */
    fractionToA(fraction) {
        return Geometry_1.Geometry.interpolate(this.a0, fraction, this.a1);
    }
}
exports.StrokeCountMap = StrokeCountMap;


/***/ }),

/***/ "./lib/curve/RegionMomentsXY.js":
/*!**************************************!*\
  !*** ./lib/curve/RegionMomentsXY.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
// import { Geometry, Angle, AngleSweep } from "../Geometry";
const MomentData_1 = __webpack_require__(/*! ../geometry4d/MomentData */ "./lib/geometry4d/MomentData.js");
const GeometryHandler_1 = __webpack_require__(/*! ../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
const Loop_1 = __webpack_require__(/*! ./Loop */ "./lib/curve/Loop.js");
const StrokeOptions_1 = __webpack_require__(/*! ./StrokeOptions */ "./lib/curve/StrokeOptions.js");
/**
 * Implementation class for computing XY area moments.
 * @internal
 */
class RegionMomentsXY extends GeometryHandler_1.NullGeometryHandler {
    constructor() {
        super(...arguments);
        this._point0 = Point3dVector3d_1.Point3d.create();
        this._point1 = Point3dVector3d_1.Point3d.create();
    }
    /** Accumulate (independent) integrations over
     * * origin to chord of the arc.
     * * origin to the "cap" between the chord and arc.
     */
    handleArc3d(arc) {
        const momentData = this._activeMomentData;
        const sweepRadians = arc.sweep.sweepRadians;
        const alphaRadians = sweepRadians * 0.5;
        // from https://apps.dtic.mil/dtic/tr/fulltext/u2/274936.pdf page 71  for radius = 1
        let s = Math.sin(alphaRadians);
        let c = Math.cos(alphaRadians);
        let s1 = Math.sin(sweepRadians);
        if (Angle_1.Angle.isFullCircleRadians(sweepRadians)) {
            s = 0.0;
            c = -1.0;
            s1 = 0.0;
        }
        const q = 2 * s * s * s * c / (alphaRadians - s * c);
        const s3 = s * s * s;
        const s6 = s3 * s3;
        const area = 0.5 * (sweepRadians - s1);
        const inertiaXX = 0.25 * area * (1.0 - q / 3.0);
        const inertiaYY1 = 0.25 * area * (1.0 + q);
        const inertiaYY = inertiaYY1 - 4.0 * s6 / (9.0 * area);
        const productXX = inertiaYY;
        const productYY = inertiaXX;
        const centerToCentroid = 4.0 * s * s * s / (3.0 * (sweepRadians - s1));
        const midRadians = arc.sweep.fractionToRadians(0.5);
        const centralPlane = arc.radiansToRotatedBasis(midRadians);
        const centroid = centralPlane.origin.plusScaled(centralPlane.vectorU, centerToCentroid);
        momentData.accumulateXYProductsInCentroidalFrame(productXX, 0.0, productYY, area, centroid, centralPlane.vectorU, centralPlane.vectorV);
        const pointB = arc.fractionToPoint(0.0);
        const pointC = arc.fractionToPoint(1.0);
        momentData.accumulateTriangleMomentsXY(undefined, pointB, pointC);
    }
    /** Accumulate integrals over the (triangular) areas from the origin to each line segment */
    handleLineString3d(ls) {
        const momentData = this._activeMomentData;
        momentData.accumulateTriangleToLineStringMomentsXY(undefined, ls.packedPoints);
    }
    /** Accumulate integrals over the (triangular) area from the origin to this line segment */
    handleLineSegment3d(segment) {
        const momentData = this._activeMomentData;
        segment.startPoint(this._point0);
        segment.endPoint(this._point1);
        momentData.accumulateTriangleMomentsXY(undefined, this._point0, this._point1);
    }
    /** Accumulate integrals from origin to all primitives in the chain. */
    handleLoop(loop) {
        const momentData = this._activeMomentData = MomentData_1.MomentData.create();
        momentData.needOrigin = false;
        for (const child of loop.children)
            child.dispatchToGeometryHandler(this);
        this._activeMomentData = undefined;
        return momentData;
    }
    /**
     * ASSUMPTIONS FOR ORIENTATION AND CONTAINMENT ISSUES
     * * Largest area is outer
     * * All others are interior (and not overlapping)
     * Hence
     * * Outer area sign must be positive -- negate all integrations as needed
     * * Outer area signs must be positive -- negate all integrations as needed
     * @param region
     */
    handleParityRegion(region) {
        const allChildMoments = [];
        let maxAbsArea = 0.0;
        let largestChildMoments;
        for (const child of region.children) {
            if (child instanceof Loop_1.Loop) {
                const childMoments = this.handleLoop(child);
                if (childMoments) {
                    allChildMoments.push(childMoments);
                    const q = Math.abs(childMoments.quantitySum);
                    if (q > maxAbsArea) {
                        maxAbsArea = q;
                        largestChildMoments = childMoments;
                    }
                }
            }
        }
        if (largestChildMoments) {
            const summedMoments = MomentData_1.MomentData.create();
            const sign0 = largestChildMoments.signFactor(1.0);
            summedMoments.accumulateProducts(largestChildMoments, sign0);
            for (const childMoments of allChildMoments) {
                if (childMoments !== largestChildMoments) {
                    const sign1 = childMoments.signFactor(-1.0);
                    summedMoments.accumulateProducts(childMoments, sign1);
                }
            }
            return summedMoments;
        }
        return undefined;
    }
    /** Accumulate (as simple addition) products over each component of the union region. */
    handleUnionRegion(region) {
        const summedMoments = MomentData_1.MomentData.create();
        for (const child of region.children) {
            const childMoments = child.dispatchToGeometryHandler(this);
            if (childMoments) {
                const sign0 = childMoments.signFactor(1.0);
                summedMoments.accumulateProducts(childMoments, sign0);
            }
        }
        return summedMoments;
    }
    getStrokeOptions() {
        if (this._strokeOptions)
            return this._strokeOptions;
        const options = StrokeOptions_1.StrokeOptions.createForCurves();
        // this is unusually fine for stroking, but appropriate for sum.
        options.angleTol = Angle_1.Angle.createDegrees(5.0);
        this._strokeOptions = options;
        return options;
    }
    /** Single curve primitive (not loop . . .).
     * * stroke the curve
     * * accumulate stroke array.
     */
    handleCurvePrimitive(cp) {
        const strokes = LineString3d_1.LineString3d.create();
        const options = this.getStrokeOptions();
        cp.emitStrokes(strokes, options);
        this.handleLineString3d(strokes);
    }
    /** handle strongly typed  BSplineCurve3d  as generic curve primitive */
    handleBSplineCurve3d(g) { return this.handleCurvePrimitive(g); }
    /** handle strongly typed  BSplineCurve3dH  as generic curve primitive */
    handleBSplineCurve3dH(g) { return this.handleCurvePrimitive(g); }
    /** handle strongly typed  TransitionSpiral as generic curve primitive  */
    handleTransitionSpiral(g) { return this.handleCurvePrimitive(g); }
}
exports.RegionMomentsXY = RegionMomentsXY;


/***/ }),

/***/ "./lib/curve/RegionOps.js":
/*!********************************!*\
  !*** ./lib/curve/RegionOps.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const MomentData_1 = __webpack_require__(/*! ../geometry4d/MomentData */ "./lib/geometry4d/MomentData.js");
const RegionMomentsXY_1 = __webpack_require__(/*! ./RegionMomentsXY */ "./lib/curve/RegionMomentsXY.js");
const Graph_1 = __webpack_require__(/*! ../topology/Graph */ "./lib/topology/Graph.js");
const Triangulation_1 = __webpack_require__(/*! ../topology/Triangulation */ "./lib/topology/Triangulation.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const IndexedXYZCollection_1 = __webpack_require__(/*! ../geometry3d/IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js");
const RegularizeFace_1 = __webpack_require__(/*! ../topology/RegularizeFace */ "./lib/topology/RegularizeFace.js");
const Merging_1 = __webpack_require__(/*! ../topology/Merging */ "./lib/topology/Merging.js");
const HalfEdgeGraphSearch_1 = __webpack_require__(/*! ../topology/HalfEdgeGraphSearch */ "./lib/topology/HalfEdgeGraphSearch.js");
const PolyfaceBuilder_1 = __webpack_require__(/*! ../polyface/PolyfaceBuilder */ "./lib/polyface/PolyfaceBuilder.js");
const PolygonOffsetContext_1 = __webpack_require__(/*! ./PolygonOffsetContext */ "./lib/curve/PolygonOffsetContext.js");
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
const CurveWireMomentsXYZ_1 = __webpack_require__(/*! ./CurveWireMomentsXYZ */ "./lib/curve/CurveWireMomentsXYZ.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const Loop_1 = __webpack_require__(/*! ./Loop */ "./lib/curve/Loop.js");
const Path_1 = __webpack_require__(/*! ./Path */ "./lib/curve/Path.js");
const InOutTests_1 = __webpack_require__(/*! ./Query/InOutTests */ "./lib/curve/Query/InOutTests.js");
const CurveSplitContext_1 = __webpack_require__(/*! ./Query/CurveSplitContext */ "./lib/curve/Query/CurveSplitContext.js");
const ChainCollectorContext_1 = __webpack_require__(/*! ./ChainCollectorContext */ "./lib/curve/ChainCollectorContext.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Point3dArrayCarrier_1 = __webpack_require__(/*! ../geometry3d/Point3dArrayCarrier */ "./lib/geometry3d/Point3dArrayCarrier.js");
const PolylineCompressionByEdgeOffset_1 = __webpack_require__(/*! ../geometry3d/PolylineCompressionByEdgeOffset */ "./lib/geometry3d/PolylineCompressionByEdgeOffset.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const ConsolidateAdjacentPrimitivesContext_1 = __webpack_require__(/*! ./Query/ConsolidateAdjacentPrimitivesContext */ "./lib/curve/Query/ConsolidateAdjacentPrimitivesContext.js");
/**
 * base class for callbacks during region sweeps.
 * * At start of a component, `startComponent(node)` is called announcing a representative node on the outermost face.
 *   * A Component in this usage is a component that is edge connected when ignoring "exterior bridge edges".
 * * As each face is entered, `enterFace(facePathStack, newFaceNode)` is called
 *   * facePathStack[0] is the outermost node of the path from the outer face.
 *   * facePathStack[1] is its inside mate.
 *   * facePathStack[2k] is the outside node at crossing to face at depth k.
 *   * facePathStack[2k+1] is the node where face at depth k was entered.
 *   * newFaceNode is the entry node (redundant of stack tip)
 *  * On retreat from a face, `leaveFace(facePathStack, faceNode)` is called.
 *  * At end of component, `finishComponent (node)` is called.
 * * The base class is fully implemented to do nothing during the sweep.
 */
class RegionOpsFaceToFaceSearchCallbacks {
    /** Announce a representative node on the outer face of a component */
    startComponent(_node) { return true; }
    /** Announce return to outer face */
    finishComponent(_node) { return true; }
    /** Announce face entry */
    enterFace(_facePathStack, _newFaceNode) { return true; }
    /** Announce face exit */
    leaveFace(_facePathStack, _newFaceNode) { return true; }
}
/**
 * Implementations of `RegionOpsFaceToFaceSearchCallbacks` for binary boolean sweep.
 * * This assumes the each node in the graph has edgeTag set to:
 *   * `edgeTag === undefined` if the edge crossing the edge does not change classification.
 *     * for example, an edge added by regularization
 *   * `edgeTag === 1` if this is a boundary for the first of the boolean input regions
 *   * `edgeTag === 2` if this is a boundary for the first of the boolean input regions
 * * constructor
 *    * takes caller-supplied function to decide whether to accept a face given its state relative to the two boolean terms.
 *    * sets the in/out status of both terms to false.
 * * `startComponent` marks the entire outer face as `EXTERIOR`
 * * `enterFace`
 *    * if this is a bounding edge (according to `node.faceTag`) toggle the in/out status if this boolean term.
 *    * ask the faceAcceptFunction if the current term states combine to in/out for the result
 *    * if out, set the `EXTERIOR` mask around the face.
 * * `leaveFace`
 *    * if this is a bounding edge (according to `node.faceTag`) toggle the in/out status if this boolean term.
 * * `finishComponent` is not reimplemented.
 */
class RegionOpsBooleanSweepCallbacks extends RegionOpsFaceToFaceSearchCallbacks {
    constructor(acceptFaceFunction, exteriorMask) {
        super();
        this._inComponent = [false, false, false]; // entry 0 is never reused.
        this._exteriorMask = exteriorMask;
        this._faceSelectFunction = acceptFaceFunction;
    }
    /** Mark this face as exterior */
    startComponent(node) { node.setMaskAroundFace(this._exteriorMask); return true; }
    /**
     * * If necessary, toggle a term state.
     * * if indicated, mark this face exterior.
     */
    enterFace(_facePathStack, node) {
        const thisFaceIndex = node.edgeTag;
        if (node.edgeTag === 1 || node.edgeTag === 2)
            this._inComponent[thisFaceIndex] = !this._inComponent[thisFaceIndex];
        if (!this._faceSelectFunction(this._inComponent[1], this._inComponent[2]))
            node.setMaskAroundFace(this._exteriorMask);
        return true;
    }
    /**
     * * If necessary, toggle a term state.
     */
    leaveFace(_facePathStack, node) {
        const thisFaceIndex = node.edgeTag;
        if (node.edgeTag === 1 || node.edgeTag === 2)
            this._inComponent[thisFaceIndex] = !this._inComponent[thisFaceIndex];
        return true;
    }
}
/**
 * run a DFS with face-to-face step announcements.
 * * false return from any function terminates search immediately.
 * * all reachable nodes assumed to have both visit masks clear.
 * @param graph containing graph.
 * @param seed first node to visit.
 * @param faceHasBeenVisited mask marking faces that have been seen.
 * @param nodeHasBeenVisited mask marking node-to-node step around face.
 *
 */
function faceToFaceSearchFromOuterLoop(_graph, seed, faceHasBeenVisited, nodeHasBeenVisited, callbacks) {
    if (seed.isMaskSet(faceHasBeenVisited))
        return;
    if (!callbacks.startComponent(seed))
        return;
    const facePathStack = [];
    seed.setMaskAroundFace(faceHasBeenVisited);
    let faceWalker = seed;
    do {
        let entryNode = faceWalker;
        let mate = faceWalker.edgeMate;
        if (!mate.isMaskSet(faceHasBeenVisited)) {
            // the faceWalker seed is always on the base of the stack.
            // the stack then contains even-odd pairs of (entryNode, currentNode)
            // * entryNode is the node where a face was entered.
            // * faceNode is another node around that face.
            facePathStack.push(faceWalker);
            facePathStack.push(mate);
            let faceNode = mate.faceSuccessor;
            mate.setMaskAroundFace(faceHasBeenVisited);
            if (callbacks.enterFace(facePathStack, mate)) {
                for (;;) {
                    mate = faceNode.edgeMate;
                    if (!mate.isMaskSet(faceHasBeenVisited)) {
                        mate.setMaskAroundFace(faceHasBeenVisited);
                        if (!callbacks.enterFace(facePathStack, mate))
                            return;
                        facePathStack.push(faceNode);
                        facePathStack.push(mate);
                        faceNode = mate;
                        entryNode = mate;
                    }
                    faceNode.setMask(nodeHasBeenVisited);
                    faceNode = faceNode.faceSuccessor;
                    if (faceNode === entryNode) {
                        callbacks.leaveFace(facePathStack, faceNode);
                        if (facePathStack.length <= 2) {
                            break;
                        }
                        facePathStack.pop();
                        faceNode = facePathStack[facePathStack.length - 1];
                        facePathStack.pop();
                        entryNode = facePathStack[facePathStack.length - 1];
                    }
                    if (faceNode.isMaskSet(nodeHasBeenVisited)) {
                        // this is disaster !!!
                        return;
                    }
                }
            }
        }
        // continue at outermost level .....
        faceWalker = faceWalker.faceSuccessor;
    } while (faceWalker !== seed);
    callbacks.finishComponent(seed);
}
/** Complete multi-step process for polygon binary booleans starting with arrays of coordinates.
 * * Each of the binary input terms is a collection of loops
 *   * Within the binary term, in/out is determined by edge-crossing parity rules.
 * * Processing steps are
 *   * Build the loops for each set.
 *      * Each edge labeled with 1 or 2 as binary term identifier.
 *   * find crossings among the edges.
 *      * Edges are split as needed, but split preserves the edgeTag
 *   * sort edges around vertices
 *   * add regularization edges so holes are connected to their parent.
 */
function doPolygonBoolean(loopsA, loopsB, faceSelectFunction, graphCheckPoint) {
    const graph = new Graph_1.HalfEdgeGraph();
    const baseMask = Graph_1.HalfEdgeMask.BOUNDARY_EDGE | Graph_1.HalfEdgeMask.PRIMARY_EDGE;
    const seedA = RegionOps.addLoopsWithEdgeTagToGraph(graph, loopsA, baseMask, 1);
    const seedB = RegionOps.addLoopsWithEdgeTagToGraph(graph, loopsB, baseMask, 2);
    if (graphCheckPoint)
        graphCheckPoint("unmerged loops", graph, "U");
    if (seedA && seedB) {
        // split edges where they cross . . .
        Merging_1.HalfEdgeGraphMerge.splitIntersectingEdges(graph);
        if (graphCheckPoint)
            graphCheckPoint("After splitIntersectingEdges", graph, "U");
        // sort radially around vertices.
        Merging_1.HalfEdgeGraphMerge.clusterAndMergeXYTheta(graph);
        if (graphCheckPoint)
            graphCheckPoint("After clusterAndMergeXYTheta", graph, "M");
        // add edges to connect various components  (e.g. holes!!!)
        const context = new RegularizeFace_1.RegularizationContext(graph);
        context.regularizeGraph(true, true);
        if (graphCheckPoint)
            graphCheckPoint("After regularize", graph, "MR");
        const exteriorHalfEdge = HalfEdgeGraphSearch_1.HalfEdgeGraphSearch.findMinimumAreaFace(graph);
        const exteriorMask = Graph_1.HalfEdgeMask.EXTERIOR;
        const faceVisitedMask = graph.grabMask();
        const nodeVisitedMask = graph.grabMask();
        const allMasksToClear = exteriorMask | faceVisitedMask | nodeVisitedMask;
        graph.clearMask(allMasksToClear);
        const callbacks = new RegionOpsBooleanSweepCallbacks(faceSelectFunction, exteriorMask);
        faceToFaceSearchFromOuterLoop(graph, exteriorHalfEdge, faceVisitedMask, nodeVisitedMask, callbacks);
        if (graphCheckPoint)
            graphCheckPoint("After faceToFaceSearchFromOuterLoop", graph, "MRX");
        graph.dropMask(faceVisitedMask);
        graph.dropMask(nodeVisitedMask);
        return PolyfaceBuilder_1.PolyfaceBuilder.graphToPolyface(graph);
    }
    return undefined;
}
/**
 * class `RegionOps` has static members for calculations on regions (areas).
 * * Regions are represented by these `CurveCollection` subclasses:
 * * `Loop` -- a single loop
 * * `ParityRegion` -- a collection of loops, interpreted by parity rules.
 *    * The common "One outer loop and many Inner loops" is a parity region.
 * * `UnionRegion` -- a collection of `Loop` and `ParityRegion` objects understood as a (probably disjoint) union.
 * @beta
 */
class RegionOps {
    /**
     * Return moment sums for a loop, parity region, or union region.
     * * If `rawMomentData` is the MomentData returned by computeXYAreaMoments, convert to principal axes and moments with
     *    call `principalMomentData = MomentData.inertiaProductsToPrincipalAxes (rawMomentData.origin, rawMomentData.sums);`
     * @param root any Loop, ParityRegion, or UnionRegion.
     */
    static computeXYAreaMoments(root) {
        const handler = new RegionMomentsXY_1.RegionMomentsXY();
        const result = root.dispatchToGeometryHandler(handler);
        if (result instanceof MomentData_1.MomentData) {
            result.shiftOriginAndSumsToCentroidOfSums();
            return result;
        }
        return undefined;
    }
    /** Return MomentData with the sums of wire moments.
     * * If `rawMomentData` is the MomentData returned by computeXYAreaMoments, convert to principal axes and moments with
     *    call `principalMomentData = MomentData.inertiaProductsToPrincipalAxes (rawMomentData.origin, rawMomentData.sums);`
     */
    static computeXYZWireMomentSums(root) {
        const handler = new CurveWireMomentsXYZ_1.CurveWireMomentsXYZ();
        handler.visitLeaves(root);
        const result = handler.momentData;
        result.shiftOriginAndSumsToCentroidOfSums();
        return result;
    }
    /**
     * * create loops in the graph.
     * @internal
     */
    static addLoopsToGraph(graph, data, announceIsolatedLoop) {
        if (data instanceof IndexedXYZCollection_1.IndexedXYZCollection) {
            const loopSeed = Triangulation_1.Triangulator.directCreateFaceLoopFromCoordinates(graph, data);
            if (loopSeed !== undefined)
                announceIsolatedLoop(graph, loopSeed);
        }
        else if (Array.isArray(data)) {
            if (data.length > 0) {
                if (Point3dVector3d_1.Point3d.isXAndY(data[0])) {
                    const loopSeed = Triangulation_1.Triangulator.directCreateFaceLoopFromCoordinates(graph, data);
                    if (loopSeed !== undefined)
                        announceIsolatedLoop(graph, loopSeed);
                }
                else if (data[0] instanceof IndexedXYZCollection_1.IndexedXYZCollection) {
                    for (const loop of data) {
                        const loopSeed = Triangulation_1.Triangulator.directCreateFaceLoopFromCoordinates(graph, loop);
                        if (loopSeed !== undefined)
                            announceIsolatedLoop(graph, loopSeed);
                    }
                }
            }
        }
    }
    /** Add multiple loops to a graph.
     * * Apply edgeTag and mask to each edge.
     * @internal
     */
    static addLoopsWithEdgeTagToGraph(graph, data, mask, edgeTag) {
        const loopSeeds = [];
        this.addLoopsToGraph(graph, data, (_graph, seed) => {
            if (seed) {
                loopSeeds.push(seed);
                seed.setMaskAndEdgeTagAroundFace(mask, edgeTag, true);
            }
        });
        if (loopSeeds.length > 0)
            return loopSeeds;
        return undefined;
    }
    /**
     * return a polyface containing the area union of two XY regions.
     * * Within each region, in and out is determined by parity rules.
     *   * Any face that is an odd number of crossings from the far outside is IN
     *   * Any face that is an even number of crossings from the far outside is OUT
     * @param loopsA first set of loops
     * @param loopsB second set of loops
     */
    static polygonXYAreaIntersectLoopsToPolyface(loopsA, loopsB) {
        return doPolygonBoolean(loopsA, loopsB, (inA, inB) => (inA && inB), this._graphCheckPointFunction);
    }
    /**
     * return a polyface containing the area intersection of two XY regions.
     * * Within each region, in and out is determined by parity rules.
     *   * Any face that is an odd number of crossings from the far outside is IN
     *   * Any face that is an even number of crossings from the far outside is OUT
     * @param loopsA first set of loops
     * @param loopsB second set of loops
     */
    static polygonXYAreaUnionLoopsToPolyface(loopsA, loopsB) {
        return doPolygonBoolean(loopsA, loopsB, (inA, inB) => (inA || inB), this._graphCheckPointFunction);
    }
    /**
     * return a polyface containing the area difference of two XY regions.
     * * Within each region, in and out is determined by parity rules.
     *   * Any face that is an odd number of crossings from the far outside is IN
     *   * Any face that is an even number of crossings from the far outside is OUT
     * @param loopsA first set of loops
     * @param loopsB second set of loops
     */
    static polygonXYAreaDifferenceLoopsToPolyface(loopsA, loopsB) {
        return doPolygonBoolean(loopsA, loopsB, (inA, inB) => (inA && !inB), this._graphCheckPointFunction);
    }
    /** Construct a wire (not area!!) that is offset from given polyline or polygon.
     * * This is a simple wire offset, not an area.
     * * The construction algorithm attempts to eliminate some self-intersections within the offsets, but does not guarantee a simple area offset.
     * * The construction algorithm is subject to being changed, resulting in different (hopefully better) self-intersection behavior on the future.
     * @param points a single loop or path
     * @param wrap true to include wraparound
     * @param offsetDistance distance of offset from wire.  Positive is left.
     * @beta
     */
    static constructPolygonWireXYOffset(points, wrap, offsetDistance) {
        const context = new PolygonOffsetContext_1.PolygonWireOffsetContext();
        return context.constructPolygonWireXYOffset(points, wrap, offsetDistance);
    }
    /**
     * Construct curves that are offset from a Path or Loop
     * * The construction will remove "some" local effects of features smaller than the offset distance, but will not detect self intersection among widely separated edges.
     * * Offset distance is defined as positive to the left.
     * * If offsetDistanceOrOptions is given as a number, default options are applied.
     * * When the offset needs to do an "outside" turn, the first applicable construction is applied:
     *   * If the turn is larger than `options.minArcDegrees`, a circular arc is constructed.
     *   * if the turn is larger than `options.maxChamferDegrees`, the turn is constructed as a sequence of straight lines that are
     *      * outside the arc
     *      * have uniform turn angle less than `options.maxChamferDegrees`
     *      * each line segment (except first and last) touches the arc at its midpoint.
     *   * Otherwise the prior and successor curves are extended to simple intersection.
     * @param curves input curves
     * @param offsetDistanceOrOptions offset controls.
     */
    static constructCurveXYOffset(curves, offsetDistanceOrOptions) {
        const options = PolygonOffsetContext_1.JointOptions.create(offsetDistanceOrOptions);
        return PolygonOffsetContext_1.CurveChainWireOffsetContext.constructCurveXYOffset(curves, options);
    }
    /**
     * Test if point (x,y) is IN, OUT or ON a polygon.
     * @return (1) for in, (-1) for OUT, (0) for ON
     * @param x x coordinate
     * @param y y coordinate
     * @param points array of xy coordinates.
     */
    static testPointInOnOutRegionXY(curves, x, y) {
        return InOutTests_1.PointInOnOutContext.testPointInOnOutRegionXY(curves, x, y);
    }
    /** Create curve collection of subtype determined by gaps between the input curves.
     * * If (a) wrap is requested and (b) all curves connect head-to-tail (including wraparound), assemble as a `loop`.
     * * If all curves connect head-to-tail except for closure, return a `Path`.
     * * If there are internal gaps, return a `BagOfCurves`
     * * If input array has zero length, return undefined.
     */
    static createLoopPathOrBagOfCurves(curves, wrap = true) {
        const n = curves.length;
        if (n === 0)
            return undefined;
        let maxGap = 0.0;
        if (wrap)
            maxGap = Geometry_1.Geometry.maxXY(maxGap, curves[0].startPoint().distance(curves[n - 1].endPoint()));
        for (let i = 0; i + 1 < n; i++)
            maxGap = Geometry_1.Geometry.maxXY(maxGap, curves[i].endPoint().distance(curves[i + 1].startPoint()));
        let collection;
        if (Geometry_1.Geometry.isSmallMetricDistance(maxGap)) {
            collection = wrap ? Loop_1.Loop.create() : Path_1.Path.create();
        }
        else {
            collection = CurveCollection_1.BagOfCurves.create();
        }
        for (const c of curves)
            collection.tryAddChild(c);
        return collection;
    }
    /**
     * Announce Checkpoint function for use during booleans
     * @internal
     */
    static setCheckPointFunction(f) { this._graphCheckPointFunction = f; }
    /**
     * * Find all intersections among curves in `curvesToCut` and `cutterCurves`
     * * Return fragments of `curvesToCut`.
     * * For a  `Loop`, `ParityRegion`, or `UnionRegion` in `curvesToCut`
     *    * if it is never cut by any `cutter` curve, it will be left unchanged.
     *    * if cut, the input is downgraded to a set of `Path` curves joining at the cut points.
     * * All cutting is "as viewed in the xy plane"
     */
    static cloneCurvesWithXYSplitFlags(curvesToCut, cutterCurves) {
        return CurveSplitContext_1.CurveSplitContext.cloneCurvesWithXYSplitFlags(curvesToCut, cutterCurves);
    }
    /**
     * Create paths assembled from many curves.
     * * Assemble consecutive curves NOT separated by either end flags or gaps into paths.
     * * Return simplest form -- single primitive, single path, or bag of curves.
     * @param curves
     */
    static splitToPathsBetweenFlagBreaks(source, makeClones) {
        if (source === undefined)
            return undefined;
        if (source instanceof CurvePrimitive_1.CurvePrimitive)
            return source;
        // source is a collection .  ..
        const primitives = source.collectCurvePrimitives();
        const chainCollector = new ChainCollectorContext_1.ChainCollectorContext(makeClones);
        for (const primitive of primitives) {
            chainCollector.announceCurvePrimitive(primitive);
        }
        return chainCollector.grabResult();
    }
    /**
     * * Find intersections of `curvesToCut` with boundaries of `region`.
     * * Break `curvesToCut` into parts inside, outside, and coincident.
     * * Return all fragments, split among `insideParts`, `outsideParts`, and `coincidentParts` in the output object.
     */
    static splitPathsByRegionInOnOutXY(curvesToCut, region) {
        const result = { insideParts: [], outsideParts: [], coincidentParts: [] };
        const pathWithIntersectionMarkup = RegionOps.cloneCurvesWithXYSplitFlags(curvesToCut, region);
        const splitPaths = RegionOps.splitToPathsBetweenFlagBreaks(pathWithIntersectionMarkup, true);
        if (splitPaths instanceof CurveCollection_1.CurveCollection) {
            for (const child of splitPaths.children) {
                const pointOnChild = CurveCollection_1.CurveCollection.createCurveLocationDetailOnAnyCurvePrimitive(child);
                if (pointOnChild) {
                    const inOnOut = RegionOps.testPointInOnOutRegionXY(region, pointOnChild.point.x, pointOnChild.point.y);
                    pushToInOnOutArrays(child, inOnOut, result.outsideParts, result.coincidentParts, result.insideParts);
                }
            }
        }
        else if (splitPaths instanceof CurvePrimitive_1.CurvePrimitive) {
            const pointOnChild = CurveCollection_1.CurveCollection.createCurveLocationDetailOnAnyCurvePrimitive(splitPaths);
            if (pointOnChild) {
                const inOnOut = RegionOps.testPointInOnOutRegionXY(region, pointOnChild.point.x, pointOnChild.point.y);
                pushToInOnOutArrays(splitPaths, inOnOut, result.outsideParts, result.coincidentParts, result.insideParts);
            }
        }
        return result;
    }
    /** Test if `data` is one of several forms of a rectangle.
     * * If so, return transform with
     *   * origin at one corner
     *   * x and y columns extend along two adjacent sides
     *   * z column is unit normal.
     * * The recognized data forms for simple analysis of points are:
     *   * LineString
     *   * Loop containing rectangle content
     *   * Path containing rectangle content
     *   * Array of Point3d[]
     *   * IndexedXYZCollection
     * * Points are considered a rectangle if
     *   * Within the first 4 points
     *     * vectors from 0 to 1 and 0 to 3 are perpendicular and have a non-zero cross product
     *     * vectors from 0 to 3 and 1 to 2 are the same
     *  * optionally require a 5th point that closes back to point0
     *  * If there are other than the basic number of points (4 or 5) the data
     */
    static rectangleEdgeTransform(data, requireClosurePoint = true) {
        if (data instanceof LineString3d_1.LineString3d) {
            return this.rectangleEdgeTransform(data.packedPoints);
        }
        else if (data instanceof IndexedXYZCollection_1.IndexedXYZCollection) {
            let dataToUse;
            if (requireClosurePoint && data.length === 5) {
                if (!Geometry_1.Geometry.isSmallMetricDistance(data.distanceIndexIndex(0, 4)))
                    return undefined;
                dataToUse = data;
            }
            else if (!requireClosurePoint && data.length === 4)
                dataToUse = data;
            else if (data.length < (requireClosurePoint ? 5 : 4)) {
                return undefined;
            }
            else {
                dataToUse = GrowableXYZArray_1.GrowableXYZArray.create(data);
                PolylineCompressionByEdgeOffset_1.PolylineCompressionContext.compressInPlaceByShortEdgeLength(dataToUse, Geometry_1.Geometry.smallMetricDistance);
            }
            const vector01 = dataToUse.vectorIndexIndex(0, 1);
            const vector03 = dataToUse.vectorIndexIndex(0, 3);
            const vector12 = dataToUse.vectorIndexIndex(1, 2);
            const normalVector = vector01.crossProduct(vector03);
            if (normalVector.normalizeInPlace()
                && vector12.isAlmostEqual(vector03)
                && vector01.isPerpendicularTo(vector03)) {
                return Transform_1.Transform.createOriginAndMatrixColumns(dataToUse.getPoint3dAtUncheckedPointIndex(0), vector01, vector03, normalVector);
            }
        }
        else if (Array.isArray(data)) {
            return this.rectangleEdgeTransform(new Point3dArrayCarrier_1.Point3dArrayCarrier(data), requireClosurePoint);
        }
        else if (data instanceof Loop_1.Loop && data.children.length === 1 && data.children[0] instanceof LineString3d_1.LineString3d) {
            return this.rectangleEdgeTransform(data.children[0].packedPoints, true);
        }
        else if (data instanceof Path_1.Path && data.children.length === 1 && data.children[0] instanceof LineString3d_1.LineString3d) {
            return this.rectangleEdgeTransform(data.children[0].packedPoints, requireClosurePoint);
        }
        else if (data instanceof CurveCollection_1.CurveChain) {
            if (!data.checkForNonLinearPrimitives()) {
                // const linestring = LineString3d.create();
                const strokes = data.getPackedStrokes();
                if (strokes) {
                    return this.rectangleEdgeTransform(strokes);
                }
            }
        }
        return undefined;
    }
    /**
     * Look for and simplify:
     * * Contiguous `LineSegment3d` and `LineString3d` objects.
     *   * collect all points
     *   * eliminate duplicated points
     *   * eliminate points colinear with surrounding points.
     *  * Contigous concentric circular or elliptic arcs
     *   * combine angular ranges
     * @param curves Path or loop (or larger collection containing paths and loops) to be simplified
     * @param options options for tolerance and selective simplification.
     */
    static consolidateAdjacentPrimitives(curves, options) {
        const context = new ConsolidateAdjacentPrimitivesContext_1.ConsolidateAdjacentCurvePrimitivesContext(options);
        curves.dispatchToGeometryHandler(context);
    }
}
exports.RegionOps = RegionOps;
function pushToInOnOutArrays(curve, select, arrayNegative, array0, arrayPositive) {
    if (select > 0)
        arrayPositive.push(curve);
    else if (select < 0)
        arrayNegative.push(curve);
    else
        array0.push(curve);
}


/***/ }),

/***/ "./lib/curve/StrokeOptions.js":
/*!************************************!*\
  !*** ./lib/curve/StrokeOptions.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
/* tslint:disable:variable-name no-empty */
/** tolerance blob for various stroking methods.
 *
 * * Across many applications, the critical concepts are:   chordTol, angleTol, maxEdgeLength
 * * Chord error is an distance measured from a curve or facet to its approximating stroke or facet.
 * * angle is the angle between two contiguous strokes or across a facet edge.
 * * maxEdgeLength is the length of a stroke or a edge of a facet.
 *
 * It is rare for all three to be active at once:
 * * Nearly all stroke and facet use cases will apply an angle tolerance.
 * * * For curves, 15 degrees is typical
 * * * For facets, 22.5 degrees is typical.
 * * * Halving the angle tolerance will (roughly) make curves get twice as many strokes, and surfaces get 4 times as many facets.
 * * * The angle tolerance has the useful property that its effect is independent of scale of that data.  If data is suddenly scaled into millimeters rather than meters, the facet counts remain the same.
 * * When creating output for devices such as 3D printing will want a chord tolerance.
 * * For graphics display, use an angle tolerance of around 15 degrees and an chord tolerance which is the size of several pixels.
 * * Analysis meshes (e.g. Finite Elements) commonly need to apply maxEdgeLength.
 * * * Using maxEdgeLength for graphics probably produces too many facets.   For example, it causes long cylinders to get many nearly-square facets instead of the small number of long quads usually used for graphics.
 * * Facet tolerances are, as the Pirates' Code, guidelines, not absolute rules.   Facet and stroke code may ignore tolerances in awkward situations.
 * * If multiple tolerances are in effect, the actual count will usually be based on the one that demands the most strokes or facets, unless it is so high that it violates some upper limit on the number of facets on an arc or a section of a curve.
 * @public
 */
class StrokeOptions {
    constructor() {
        /** whether or not to triangulate each added facet */
        this.shouldTriangulate = false;
        /** default number of strokes for a circle. */
        this.defaultCircleStrokes = 16;
    }
    /** ask if params are requested. */
    get needParams() { return this._needParams !== undefined ? this._needParams : false; }
    /** set the params request flag */
    set needParams(value) { this._needParams = value; }
    /** ask if normals are requested */
    get needNormals() { return this._needNormals !== undefined ? this._needNormals : false; }
    /** set the normals request flag */
    set needNormals(value) { this._needNormals = value; }
    /** set request for two-sided facets. */
    set needTwoSided(value) { this._needTwoSided = value; }
    /** ask if twoSided is requested. */
    get needTwoSided() { return this._needTwoSided !== undefined ? this._needTwoSided : false; }
    /** ask if maxEdgeLength is specified */
    get hasMaxEdgeLength() { return this.maxEdgeLength !== undefined && this.maxEdgeLength > 0.0; }
    /** return stroke count which is the larger of the minCount or count needed for edge length condition. */
    applyMaxEdgeLength(minCount, totalLength) {
        if (this.maxEdgeLength && this.maxEdgeLength > 0.0 && minCount * this.maxEdgeLength < totalLength) {
            minCount = Geometry_1.Geometry.stepCount(this.maxEdgeLength, totalLength, minCount);
        }
        return minCount;
    }
    /**
     * return stroke count which is the larger of the existing count or count needed for angle condition for given sweepRadians
     * * defaultStepRadians is assumed to be larger than zero.
     */
    applyAngleTol(minCount, sweepRadians, defaultStepRadians) {
        return StrokeOptions.applyAngleTol(this, minCount, sweepRadians, defaultStepRadians);
    }
    /**
     * return stroke count which is the larger of minCount and the count required to turn sweepRadians, using tolerance from the options.
     */
    static applyAngleTol(options, minCount, sweepRadians, defaultStepRadians) {
        sweepRadians = Math.abs(sweepRadians);
        let stepRadians = defaultStepRadians ? defaultStepRadians : Math.PI / 8.0;
        if (options && options.angleTol && options.angleTol.radians > 0.0)
            stepRadians = options.angleTol.radians;
        if (minCount * stepRadians < sweepRadians)
            minCount = Geometry_1.Geometry.stepCount(stepRadians, sweepRadians, minCount);
        return minCount;
    }
    /**
     * Return the number of strokes needed for given edgeLength curve.
     * @param options
     * @param minCount smallest allowed count
     * @param edgeLength
     */
    static applyMaxEdgeLength(options, minCount, edgeLength) {
        if (edgeLength < 0)
            edgeLength = -edgeLength;
        if (minCount < 1)
            minCount = 1;
        if (options && options.maxEdgeLength && options.maxEdgeLength * minCount < edgeLength) {
            minCount = Geometry_1.Geometry.stepCount(options.maxEdgeLength, edgeLength, minCount);
        }
        return minCount;
    }
    /**
     * Determine a stroke count for a (partial) circular arc of given radius. This considers angle, maxEdgeLength, chord, and minimum stroke.
     */
    applyTolerancesToArc(radius, sweepRadians = Math.PI * 2) {
        let numStrokes = 1;
        numStrokes = this.applyAngleTol(numStrokes, sweepRadians, Math.PI * 0.25);
        numStrokes = this.applyMaxEdgeLength(numStrokes, sweepRadians * radius);
        numStrokes = this.applyChordTol(numStrokes, radius, sweepRadians);
        numStrokes = this.applyMinStrokesPerPrimitive(numStrokes);
        return numStrokes;
    }
    /** return stroke count which is the larger of existing count or count needed for circular arc chord tolerance condition. */
    applyChordTol(minCount, radius, sweepRadians) {
        if (this.chordTol && this.chordTol > 0.0 && this.chordTol < radius) {
            const a = this.chordTol;
            const stepRadians = 2.0 * Math.acos((1.0 - a / radius));
            minCount = Geometry_1.Geometry.stepCount(stepRadians, sweepRadians, minCount);
        }
        return minCount;
    }
    /** return stroke count which is the larger of existing count or count needed for circular arc chord tol with given arc length and radians
     */
    applyChordTolToLengthAndRadians(minCount, length, sweepRadians) {
        if (this.chordTol && this.chordTol > 0.0) {
            const radius = Geometry_1.Geometry.conditionalDivideFraction(length, sweepRadians);
            if (radius !== undefined)
                return this.applyChordTol(minCount, radius, sweepRadians);
        }
        return minCount;
    }
    /** return stroke count which is the larger of existing count or `this.minStrokesPerPrimitive` */
    applyMinStrokesPerPrimitive(minCount) {
        if (this.minStrokesPerPrimitive !== undefined && Number.isFinite(this.minStrokesPerPrimitive)
            && this.minStrokesPerPrimitive > minCount)
            minCount = this.minStrokesPerPrimitive;
        return minCount;
    }
    /** create `StrokeOptions` with defaults appropriate for curves.
     * * angle tolerance of 15 degrees.
     * * all others inactive.
     */
    static createForCurves() {
        const options = new StrokeOptions();
        options.angleTol = Angle_1.Angle.createDegrees(15.0);
        return options;
    }
    /** create `StrokeOptions` with defaults appropriate for surfaces facets
     * * angle tolerance of 22.5 degrees.
     * * all others inactive.
     */
    static createForFacets() {
        const options = new StrokeOptions();
        options.angleTol = Angle_1.Angle.createDegrees(22.5);
        return options;
    }
}
exports.StrokeOptions = StrokeOptions;


/***/ }),

/***/ "./lib/curve/TransitionSpiral.js":
/*!***************************************!*\
  !*** ./lib/curve/TransitionSpiral.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Curve */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Quadrature_1 = __webpack_require__(/*! ../numerics/Quadrature */ "./lib/numerics/Quadrature.js");
const StrokeOptions_1 = __webpack_require__(/*! ./StrokeOptions */ "./lib/curve/StrokeOptions.js");
const CurvePrimitive_1 = __webpack_require__(/*! ./CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const LineString3d_1 = __webpack_require__(/*! ./LineString3d */ "./lib/curve/LineString3d.js");
// import {} from "./";
/** A transition spiral is a curve defined by its curvature, with the curvature function symmetric about midpoint.
 * * The symmetry condition creates a relationship among the following 4 quantities:
 * ** curvature0 = curvature (i.e. 1/radius) at start
 * ** curvature1 = curvature (i.e. 1/radius) at end
 * ** sweepRadians = signed turning angle from start to end
 * ** arcLength = length of curve
 * * The relationship is the equation
 * ** `sweepRadians = arcLength * average Curvature = arcLength * 0.5 * (curvature0 + curvature1)`
 * * That is, regardless of any curvature properties other than symmetry, specifying any 3 of the quantities fully determines the remaining one.
 * @alpha
 */
class TransitionConditionalProperties {
    /**
     * capture numeric or undefined values
     * @param radius0 start radius or undefined
     * @param radius1 end radius or undefined
     * @param bearing0 start bearing or undefined
     * @param bearing1 end bearing or undefined
     * @param arcLength arc length or undefined
     */
    constructor(radius0, radius1, bearing0, bearing1, arcLength) {
        this.radius0 = radius0;
        this.radius1 = radius1;
        this.bearing0 = bearing0;
        this.bearing1 = bearing1;
        this.curveLength = arcLength;
    }
    /** return the number of defined values among the 5 properties. */
    numDefinedProperties() {
        return Geometry_1.Geometry.defined01(this.radius0)
            + Geometry_1.Geometry.defined01(this.radius1)
            + Geometry_1.Geometry.defined01(this.bearing0)
            + Geometry_1.Geometry.defined01(this.bearing1)
            + Geometry_1.Geometry.defined01(this.curveLength);
    }
    /** clone with all properties (i.e. preserve undefined states) */
    clone() {
        return new TransitionConditionalProperties(this.radius0, this.radius1, this.bearing0 === undefined ? undefined : this.bearing0.clone(), this.bearing1 === undefined ? undefined : this.bearing1.clone(), this.curveLength);
    }
    /** Examine which properties are defined and compute the (single) undefined.
     * @returns Return true if the input state had precisely one undefined member.
     */
    tryResolveAnySingleUnknown() {
        if (this.bearing0 && this.bearing1) {
            const sweepRadians = this.bearing1.radians - this.bearing0.radians;
            if (this.curveLength === undefined && this.radius0 !== undefined && this.radius1 !== undefined) {
                this.curveLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(this.radius0, this.radius1, sweepRadians);
                return true;
            }
            if (this.curveLength !== undefined && this.radius0 === undefined && this.radius1 !== undefined) {
                this.radius0 = TransitionSpiral3d.radius1LengthSweepRadiansToRadius0(this.radius1, this.curveLength, sweepRadians);
                return true;
            }
            if (this.curveLength !== undefined && this.radius0 !== undefined && this.radius1 === undefined) {
                this.radius1 = TransitionSpiral3d.radius0LengthSweepRadiansToRadius1(this.radius0, this.curveLength, sweepRadians);
                return true;
            }
            return false;
        }
        // at least one bearing is undefined ...
        if (this.curveLength === undefined || this.radius0 === undefined || this.radius1 === undefined)
            return false;
        if (this.bearing0) { // bearing 1 is undefined
            this.bearing1 = Angle_1.Angle.createRadians(this.bearing0.radians + TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));
            return true;
        }
        if (this.bearing1) { // bearing 0 is undefined
            this.bearing0 = Angle_1.Angle.createRadians(this.bearing1.radians - TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));
            return true;
        }
        return false;
    }
    almostEqualCoordinate(a, b) {
        if (a === undefined && b === undefined)
            return true;
        if (a !== undefined && b !== undefined)
            return Geometry_1.Geometry.isSameCoordinate(a, b);
        return false;
    }
    almostEqualBearing(a, b) {
        if (a === undefined && b === undefined)
            return true;
        if (a !== undefined && b !== undefined)
            return a.isAlmostEqualNoPeriodShift(b);
        return false;
    }
    /**
     * Test if this and other have matching numeric and undefined members.
     */
    isAlmostEqual(other) {
        if (!this.almostEqualCoordinate(this.radius0, other.radius0))
            return false;
        if (!this.almostEqualCoordinate(this.radius1, other.radius1))
            return false;
        if (!this.almostEqualBearing(this.bearing0, other.bearing0))
            return false;
        if (!this.almostEqualBearing(this.bearing1, other.bearing1))
            return false;
        if (!this.almostEqualCoordinate(this.curveLength, other.curveLength))
            return false;
        return true;
    }
    /** Apply a NONZERO scale factor to all distances. */
    applyScaleFactor(a) {
        if (this.radius0 !== undefined)
            this.radius0 *= a;
        if (this.radius1 !== undefined)
            this.radius1 *= a;
        if (this.curveLength !== undefined)
            this.curveLength *= a;
    }
}
exports.TransitionConditionalProperties = TransitionConditionalProperties;
/**
 * A transition spiral is a curve defined by its curvature, with the curvature function symmetric about midpoint.
 * * `TransitionConditionalProperties` implements the computations of the interrelationship of radii, bearing, and length.
 * @alpha
 */
class TransitionSpiral3d extends CurvePrimitive_1.CurvePrimitive {
    // constructor demands all bearing, radius, and length data -- caller determines usual dependency of "any 4 determine the 5th"
    constructor(spiralType, radius01, bearing01, activeFractionInterval, localToWorld, arcLength, properties) {
        super();
        /** String name for schema properties */
        this.curvePrimitiveType = "transitionSpiral";
        this._spiralType = spiralType;
        this.localToWorld = localToWorld;
        this.radius01 = radius01;
        this.bearing01 = bearing01;
        this.localToWorld = localToWorld;
        this.activeFractionInterval = activeFractionInterval;
        this._arcLength01 = arcLength;
        this._globalStrokes = LineString3d_1.LineString3d.create();
        // initialize for compiler -- but this will be recomputed in refreshComputeProperties ...
        this._curvature01 = Segment1d_1.Segment1d.create(0, 1);
        this.refreshComputedProperties();
        this._properties = properties;
    }
    /** Return 1/r with convention that if true zero is given as radius it represents infinite radius (0 curvature, straight line) */
    static radiusToCurvature(radius) { return (radius === 0.0) ? 0.0 : 1.0 / radius; }
    /** Return 1/k with convention that if near-zero is given as curvature, its infinite radius is returned as 0 */
    static curvatureToRadius(curvature) {
        if (Math.abs(curvature) < Geometry_1.Geometry.smallAngleRadians)
            return 0.0;
        return 1.0 / curvature;
    }
    /** Return the average of the start and end curvatures. */
    static averageCurvature(radiusLimits) {
        return 0.5 * (TransitionSpiral3d.radiusToCurvature(radiusLimits.x0) + TransitionSpiral3d.radiusToCurvature(radiusLimits.x1));
    }
    /**
     * Given two radii (or zeros for 0 curvature) return the average curvature
     * @param r0 start radius, or 0 for line
     * @param r1 end radius, or 0 for line
     */
    static averageCurvatureR0R1(r0, r1) {
        return 0.5 * (TransitionSpiral3d.radiusToCurvature(r0) + TransitionSpiral3d.radiusToCurvature(r1));
    }
    /** Return the arc length of a transition spiral with given sweep and radius pair. */
    static radiusRadiusSweepRadiansToArcLength(radius0, radius1, sweepRadians) {
        return Math.abs(sweepRadians / TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1));
    }
    /** Return the turn angle for spiral of given length between two radii */
    static radiusRadiusLengthToSweepRadians(radius0, radius1, arcLength) {
        return TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1) * arcLength;
    }
    /** Return the end radius for spiral of given start radius, length, and turn angle. */
    static radius0LengthSweepRadiansToRadius1(radius0, arcLength, sweepRadians) {
        return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius0));
    }
    /** Return the start radius for spiral of given end radius, length, and turn angle. */
    static radius1LengthSweepRadiansToRadius0(radius1, arcLength, sweepRadians) {
        return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius1));
    }
    /** Return the internal stroked form of the (possibly partial) spiral   */
    get activeStrokes() { return this._activeStrokes !== undefined ? this._activeStrokes : this._globalStrokes; }
    /** Return the original defining properties (if any) saved by the constructor. */
    get originalProperties() { return this._properties; }
    /** return the spiral type as a string (undefined resolves to default type "clothoid") */
    getSpiralType() { if (this._spiralType === undefined)
        return TransitionSpiral3d.defaultSpiralType; return this._spiralType; }
    /** Return the bearing at given fraction .... */
    globalFractionToBearingRadians(fraction) {
        return this.bearing01.startRadians + fraction * this._arcLength01 * (this._curvature01.x0 + 0.5 * fraction * (this._curvature01.x1 - this._curvature01.x0));
    }
    /** Return the curvature at given fraction ... */
    globalFractionToCurvature(fraction) {
        // BUG? active interval
        return this._curvature01.fractionToPoint(fraction);
    }
    /** Return the bearing at given fraction of the active interval .... */
    fractionToBearingRadians(activeFraction) {
        const fraction = this.activeFractionInterval.fractionToPoint(activeFraction);
        return this.bearing01.startRadians + fraction * this._arcLength01 * (this._curvature01.x0 + 0.5 * fraction * (this._curvature01.x1 - this._curvature01.x0));
    }
    /** Return the curvature at given fraction of the active interval ... */
    fractionToCurvature(activeFraction) {
        // BUG? active interval
        return this._curvature01.fractionToPoint(this.activeFractionInterval.fractionToPoint(activeFraction));
    }
    /** Initialize class level work arrays. */
    static initWorkSpace() {
        TransitionSpiral3d._gaussFraction = new Float64Array(5);
        TransitionSpiral3d._gaussWeight = new Float64Array(5);
        TransitionSpiral3d._gaussMapper = Quadrature_1.Quadrature.setupGauss5;
    }
    /** Evaluate and sum the gauss quadrature formulas to integrate cos(theta), sin(theta) fractional subset of a reference length.
     * (recall that theta is a nonlinear function of the fraction.)
     * * This is a single interval of gaussian integration.
     * * The fraction is on the full spiral (not in the mapped active interval)
     * @param xyz advancing integrated point.
     * @param fractionA fraction at start of interval
     * @param fractionB fraction at end of interval.
     * @param unitArcLength length of curve for 0 to 1 fractional
     */
    fullSpiralIncrementalIntegral(xyz, fractionA, fractionB, applyMatrix) {
        const gaussFraction = TransitionSpiral3d._gaussFraction;
        const gaussWeight = TransitionSpiral3d._gaussWeight;
        const numEval = TransitionSpiral3d._gaussMapper(fractionA, fractionB, gaussFraction, gaussWeight);
        const deltaL = this._arcLength01;
        let w = 0;
        let dx = 0.0;
        let dy = 0.0;
        for (let k = 0; k < numEval; k++) {
            const radians = this.globalFractionToBearingRadians(gaussFraction[k]);
            w = gaussWeight[k] * deltaL;
            dx += w * Math.cos(radians);
            dy += w * Math.sin(radians);
        }
        if (applyMatrix)
            Matrix3d_1.Matrix3d.xyzPlusMatrixTimesXYZ(xyz, this.localToWorld.matrix, { x: dx, y: dy, z: 0.0 }, xyz);
        else
            xyz.addXYZInPlace(dx, dy, 0.0);
    }
    /** Recompute strokes */
    refreshComputedProperties() {
        this._curvature01 = Segment1d_1.Segment1d.create(TransitionSpiral3d.radiusToCurvature(this.radius01.x0), TransitionSpiral3d.radiusToCurvature(this.radius01.x1));
        this._globalStrokes.clear();
        const currentPoint = Point3dVector3d_1.Point3d.create();
        this._globalStrokes.appendStrokePoint(currentPoint);
        const numInterval = 16;
        const fractionStep = 1.0 / numInterval;
        for (let i = 1; i <= numInterval; i++) {
            const fraction0 = (i - 1) * fractionStep;
            const fraction1 = i * fractionStep;
            this.fullSpiralIncrementalIntegral(currentPoint, fraction0, fraction1, false);
            this._globalStrokes.appendStrokePoint(currentPoint);
        }
        this._globalStrokes.tryTransformInPlace(this.localToWorld);
        if (!this.activeFractionInterval.isExact01) {
            if (this._activeStrokes === undefined)
                this._activeStrokes = LineString3d_1.LineString3d.create();
            this._activeStrokes.clear();
            // finer strokes in the active interval ... same fraction step, but mapped
            // This assumes factionToPoint acts normally within refreshComputedProperties -- that depends on the global strokes we just computed, but not on the active strokes
            for (let i = 0; i <= numInterval; i++) {
                const localFraction = i * fractionStep;
                this._activeStrokes.addPoint(this.fractionToPoint(localFraction));
            }
        }
    }
    /**
     * Create a transition spiral with radius and bearing conditions.
     * @param radius01 radius (inverse curvature) at start and end. (radius of zero means straight line)
     * @param bearing01 bearing angles at start and end.  bearings are measured from the x axis, positive clockwise towards y axis
     * @param activeFractionInterval fractional limits of the active portion of the spiral.
     * @param localToWorld placement frame.  Fractional coordinate 0 is at the origin.
     */
    static createRadiusRadiusBearingBearing(radius01, bearing01, activeFractionInterval, localToWorld) {
        const arcLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(radius01.x0, radius01.x1, bearing01.sweepRadians);
        return new TransitionSpiral3d("clothoid", radius01.clone(), bearing01.clone(), activeFractionInterval.clone(), localToWorld.clone(), arcLength, new TransitionConditionalProperties(radius01.x0, radius01.x1, bearing01.startAngle.clone(), bearing01.endAngle.clone(), undefined));
    }
    /**
     * Create a transition spiral.
     * * Inputs must provide exactly 4 of the 5 values `[radius0,radius1,bearing0,bearing1,length`.
     * @param spiralType one of "clothoid", "bloss", "biquadratic", "cosine", "sine".  If undefined, "clothoid" is used.
     * @param radius0 radius (or 0 for tangent to line) at start
     * @param radius1 radius (or 0 for tangent to line) at end
     * @param bearing0 bearing, measured CCW from x axis at start.
     * @param bearing1 bearing, measured CCW from x axis at end.
     * @param fractionInterval optional fractional interval for an "active" portion of the curve.   if omitted, the full [0,1] is used.
     * @param localToWorld placement transform
     */
    static create(spiralType, radius0, radius1, bearing0, bearing1, arcLength, fractionInterval, localToWorld) {
        const data = new TransitionConditionalProperties(radius0, radius1, bearing0, bearing1, arcLength);
        const data1 = data.clone();
        if (!data.tryResolveAnySingleUnknown())
            return undefined;
        if (fractionInterval === undefined)
            fractionInterval = Segment1d_1.Segment1d.create(0, 1);
        return new TransitionSpiral3d(spiralType, Segment1d_1.Segment1d.create(data.radius0, data.radius1), AngleSweep_1.AngleSweep.createStartEnd(data.bearing0, data.bearing1), fractionInterval ? fractionInterval.clone() : Segment1d_1.Segment1d.create(0, 1), localToWorld, data.curveLength, data1);
    }
    /** Copy all defining data from another spiral. */
    setFrom(other) {
        this.localToWorld.setFrom(other.localToWorld);
        this.radius01.setFrom(other.radius01);
        this._curvature01.setFrom(other._curvature01);
        this.bearing01.setFrom(other.bearing01);
        this.localToWorld.setFrom(other.localToWorld);
        this.activeFractionInterval.setFrom(other.activeFractionInterval);
        this._arcLength01 = other._arcLength01;
        return this;
    }
    /** Deep clone of this spiral */
    clone() {
        return TransitionSpiral3d.createRadiusRadiusBearingBearing(this.radius01, this.bearing01, this.activeFractionInterval, this.localToWorld);
    }
    /** apply `transform` to this spiral's local to world transform. */
    tryTransformInPlace(transformA) {
        const rigidData = transformA.matrix.factorRigidWithSignedScale();
        if (rigidData !== undefined) {
            // [sQ a][R b] = [sQ*R sQb+a]
            // but we save it as [Q*R sQb+a] with spiral data scaled by s.
            const transformC0 = transformA.multiplyTransformTransform(this.localToWorld);
            // BUT pull the scale part out of the matrix ...
            const matrixC = rigidData.rigidAxes.multiplyMatrixMatrix(this.localToWorld.matrix);
            this.localToWorld = Transform_1.Transform.createOriginAndMatrix(transformC0.origin, matrixC);
            this._curvature01.x0 /= rigidData.scale;
            this._curvature01.x1 /= rigidData.scale;
            this.radius01.x0 *= rigidData.scale;
            this.radius01.x1 *= rigidData.scale;
            this._arcLength01 *= rigidData.scale;
            if (this.originalProperties)
                this.originalProperties.applyScaleFactor(rigidData.scale);
        }
        this.refreshComputedProperties();
        return true;
    }
    /** Clone with a transform applied  */
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform); // ok, we're confident it will always work.
        return result;
    }
    /** Return the spiral start point. */
    startPoint() { return this.activeStrokes.startPoint(); }
    /** return the spiral end point. */
    endPoint() { return this.activeStrokes.endPoint(); }
    /** test if the local to world transform places the spiral xy plane into `plane` */
    isInPlane(plane) {
        return plane.isPointInPlane(this.localToWorld.origin)
            && Geometry_1.Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnX(plane.getNormalRef()))
            && Geometry_1.Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnY(plane.getNormalRef()));
    }
    /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */
    quickLength() { return this._arcLength01; }
    /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */
    curveLength() { return this._arcLength01; }
    /** Test if `other` is an instance of `TransitionSpiral3d` */
    isSameGeometryClass(other) { return other instanceof TransitionSpiral3d; }
    /** Add strokes from this spiral to `dest`.
     * * Linestrings will usually stroke as just their points.
     * * If maxEdgeLength is given, this will sub-stroke within the linestring -- not what we want.
     */
    emitStrokes(dest, options) { this.activeStrokes.emitStrokes(dest, options); }
    /** emit stroke fragments to `dest` handler. */
    emitStrokableParts(dest, options) {
        const n = this.computeStrokeCountForOptions(options);
        const activeStrokes = this.activeStrokes;
        dest.startParentCurvePrimitive(this);
        if (n <= activeStrokes.numPoints()) {
            this.activeStrokes.emitStrokableParts(dest, options);
        }
        else {
            dest.announceIntervalForUniformStepStrokes(this, n, 0.0, 1.0);
        }
        dest.endParentCurvePrimitive(this);
    }
    /**
     * return the stroke count required for given options.
     * @param options StrokeOptions that determine count
     */
    computeStrokeCountForOptions(options) {
        let numStroke = 1;
        if (options) {
            const rMin = Math.min(Math.abs(this.radius01.x0), Math.abs(this.radius01.x1));
            numStroke = options.applyTolerancesToArc(rMin, this.bearing01.sweepRadians);
            numStroke = options.applyMaxEdgeLength(numStroke, this.curveLength());
            numStroke = options.applyMinStrokesPerPrimitive(numStroke);
        }
        else {
            numStroke = StrokeOptions_1.StrokeOptions.applyAngleTol(undefined, 4, this.bearing01.sweepRadians);
        }
        return numStroke;
    }
    /** Reverse the active interval and active strokes.
     * * Primary defining data remains unchanged !!!
     */
    reverseInPlace() {
        this.activeFractionInterval.reverseInPlace();
        if (this._activeStrokes === undefined)
            this._activeStrokes = this._globalStrokes.clone();
        this._activeStrokes.reverseInPlace();
    }
    /** Evaluate curve point with respect to fraction. */
    fractionToPoint(activeFraction, result) {
        let globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);
        globalFraction = Geometry_1.Geometry.clampToStartEnd(globalFraction, 0, 1);
        const numStrokes = this._globalStrokes.packedPoints.length - 1;
        const index0 = Math.trunc(globalFraction * numStrokes); // This indexes the point to the left of the query
        const globalFraction0 = index0 / numStrokes;
        result = this._globalStrokes.packedPoints.getPoint3dAtUncheckedPointIndex(index0, result);
        this.fullSpiralIncrementalIntegral(result, globalFraction0, globalFraction, true);
        return result;
    }
    /** Evaluate curve point and derivative with respect to fraction. */
    fractionToPointAndDerivative(activeFraction, result) {
        const globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);
        result = result ? result : Ray3d_1.Ray3d.createZero();
        this.fractionToPoint(activeFraction, result.origin);
        const radians = this.globalFractionToBearingRadians(globalFraction);
        const a = this._arcLength01 * this.activeFractionInterval.signedDelta();
        this.localToWorld.matrix.multiplyXY(a * Math.cos(radians), a * Math.sin(radians), result.direction);
        return result;
    }
    /** Return the frenet frame at fractional position. */
    fractionToFrenetFrame(activeFraction, result) {
        const globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);
        result = result ? result : Transform_1.Transform.createIdentity();
        result.origin.setFrom(this.fractionToPoint(activeFraction));
        Matrix3d_1.Matrix3d.createRigidFromMatrix3d(this.localToWorld.matrix, Geometry_1.AxisOrder.XYZ, result.matrix);
        const radians = this.globalFractionToBearingRadians(globalFraction);
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        result.matrix.applyGivensColumnOp(0, 1, c, -s);
        return result;
    }
    /** Return a plane with
     *
     * * origin at fractional position along the curve
     * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.
     * * vectorV is the second derivative, i.e.derivative of vectorU.
     */
    fractionToPointAnd2Derivatives(activeFraction, result) {
        const globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);
        const origin = this.fractionToPoint(activeFraction);
        const radians = this.globalFractionToBearingRadians(globalFraction);
        const c = Math.cos(radians);
        const s = Math.sin(radians);
        const delta = this.activeFractionInterval.signedDelta();
        const a = this._arcLength01 * delta;
        const b = a * delta;
        const vectorX = this.localToWorld.matrix.multiplyXY(a * c, a * s);
        const vectorY = this.localToWorld.matrix.multiplyXY(-b * s, b * c);
        vectorY.scaleInPlace(this.globalFractionToCurvature(globalFraction));
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createCapture(origin, vectorX, vectorY, result);
    }
    /** Second step of double dispatch:  call `handler.handleTransitionSpiral(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleTransitionSpiral(this);
    }
    /** extend the range by the strokes of the spiral */
    extendRange(rangeToExtend, transform) {
        this.activeStrokes.extendRange(rangeToExtend, transform);
    }
    /** compare various coordinate quantities */
    isAlmostEqual(other) {
        if (other instanceof TransitionSpiral3d) {
            return this.radius01.isAlmostEqual(other.radius01)
                && this.bearing01.isAlmostEqualAllowPeriodShift(other.bearing01)
                && this.localToWorld.isAlmostEqual(other.localToWorld)
                && Geometry_1.Geometry.isSameCoordinate(this._arcLength01, other._arcLength01)
                && this.activeFractionInterval.isAlmostEqual(other.activeFractionInterval)
                && this._curvature01.isAlmostEqual(other._curvature01);
        }
        return false;
    }
}
exports.TransitionSpiral3d = TransitionSpiral3d;
/** default spiral type name. (clothoid) */
TransitionSpiral3d.defaultSpiralType = "clothoid";
// at load time, initialize gauss quadrature workspace
TransitionSpiral3d.initWorkSpace();


/***/ }),

/***/ "./lib/curve/UnionRegion.js":
/*!**********************************!*\
  !*** ./lib/curve/UnionRegion.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurveCollection_1 = __webpack_require__(/*! ./CurveCollection */ "./lib/curve/CurveCollection.js");
const Loop_1 = __webpack_require__(/*! ./Loop */ "./lib/curve/Loop.js");
const ParityRegion_1 = __webpack_require__(/*! ./ParityRegion */ "./lib/curve/ParityRegion.js");
/**
 * * A `UnionRegion` is a collection of other planar region types -- `Loop` and `ParityRegion`.
 * * The composite is the union of the contained regions.
 * * A point is "in" the composite if it is "in" one or more of the contained regions.
 * @public
 */
class UnionRegion extends CurveCollection_1.CurveCollection {
    /** Constructor -- initialize with no children */
    constructor() {
        super();
        /** String name for schema properties */
        this.curveCollectionType = "unionRegion";
        this._children = [];
    }
    /** test if `other` is a `UnionRegion` */
    isSameGeometryClass(other) { return other instanceof UnionRegion; }
    /** Return the array of regions */
    get children() { return this._children; }
    /** Create a `UnionRegion` with given region children */
    static create(...data) {
        const result = new UnionRegion();
        for (const child of data) {
            result.tryAddChild(child);
        }
        return result;
    }
    /** Return the boundary type (5) of a corresponding  MicroStation CurveVector */
    dgnBoundaryType() { return 5; }
    /** dispatch to more strongly typed  `processor.announceUnionRegion(this, indexInParent)` */
    announceToCurveProcessor(processor, indexInParent = -1) {
        return processor.announceUnionRegion(this, indexInParent);
    }
    /** Return structural clone with stroked primitives. */
    cloneStroked(options) {
        const clone = new UnionRegion();
        let child;
        for (child of this._children) {
            const childStrokes = child.cloneStroked(options);
            if (childStrokes)
                clone.children.push(childStrokes);
        }
        return clone;
    }
    /** Return new empty `UnionRegion` */
    cloneEmptyPeer() { return new UnionRegion(); }
    /** add a child.
     * * Returns false if the `AnyCurve` child is not a region type.
     */
    tryAddChild(child) {
        if (child && child instanceof ParityRegion_1.ParityRegion || child instanceof Loop_1.Loop) {
            this._children.push(child);
            return true;
        }
        return false;
    }
    /** Return a child identified by index. */
    getChild(i) {
        if (i < this._children.length)
            return this._children[i];
        return undefined;
    }
    /** Second step of double dispatch:  call `handler.handleUnionRegion(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleUnionRegion(this);
    }
}
exports.UnionRegion = UnionRegion;


/***/ }),

/***/ "./lib/geometry-core.js":
/*!******************************!*\
  !*** ./lib/geometry-core.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Utility */
// REMARK:
// The docs-group-description comments are followed by empty classes with names corresponding to the doc-group.
// Normally (in committed code) these are commented out.
// The comments have distinctive strings so that simple search and replace can make the "real".
// This is useful when working on the documentation:  When the empty classes are present, VSCode will format the doc comments
// for and display them when the mouse hovers over the class name.
/**
 * @docs-package-description
 * The geometry-core package contains classes for working with geometry:  points, vectors, curves, surfaces, and analytic solids
 */
/**
 * @docs-group-description CartesianGeometry
 * Points, Vectors, Planes, and Transformations for x,y,z geometry.
 * * Fundamental cartesian geometry objects:
 *   * Point2d, Point3d -- points with x,y,z coordinates
 *   * Vector2d, Vector3d -- vectors with x,y,z coordinates
 *   * Matrix3d -- 3x3 matrix
 *   * * commonly used for pure rotations
 *   * * scale and skew entries are also allowed.
 *   * Transform -- an origin and axes.
 *   * Range1d, Range2d, Range3d -- subsets of 1d, 2d, and 3d space bounded by low and high values.
 *   * Ray3d -- a ray defined by origin and direction vector
 *   * Plane3dByOriginAndUnitNormal -- a plane defined by an origin and a single vector which is perpendicular to the plane
 *   * plane3dByOriginAndVectors -- a plane defined by an origin and two vectors in the plane.
 * * Angles
 *   * Angle -- a strongly typed angle object whose method names make it clear whether input and outputs are degrees or radians.
 *   * AngleSweep -- an angular interval
 *   * YawPitchAndRollAngles -- 3 angles that define a rotated coordinate system.
 * * Utility classes
 *   * FrameBuilder -- construction of coordinate frames from mixed data sources.
 *   * ClipPlane -- a single plane
 *   * ConvexClipPlaneSet -- an array of planes bounding a convex volume
 *   * ClipPlaneSet -- an array of ConvexClipPlaneSet, defining the union of their volumes
 *   * BilinearPatch -- twisted quadrilateral defined by 4 points
 *   * BarycentricTriangle -- triangle defined by 3 points.
 *   * Constant -- various numeric values exported as readonly constants
 */
// doc:export class CartesianGeometryDoc { }
/**
 * @docs-group-description ArraysAndInterfaces
 * These classes support array operations and inheritance-based algorithms.
 * * Arrays
 *   * GrowableArray -- A carrier for a Float64Array, with methods that hide reallocation of the underlying array as contents are added.
 *   * Point2dArray, Point3dArray, Point4dArray, Vector3dArray -- miscellaneous operations on arrays of 2d and 3d points.
 * * Interfaces
 *   * GeometryHandler -- a double-dispatch protocol used for efficient implementation of algorithms that work on many geometry types.
 *
 */
// doc:export class ArraysAndInterfacesDoc { }
/**
 * @docs-group-description Bspline
 * A bspline curve or surface is used for curved freeform geometry defined by controls points (sometimes called poles).
 * * BSplineCurve --  a curve in XYZ coordinates
 * * BSplineSurfaceXYZ -- a surface with XYZ
 * * BsplineSurfaceXYZW -- a surface with weighted (rational) XYZ coordinates
 * * KnotVector -- vector of breakpoints in bspline definitions.
 */
// doc:export class BsplineDoc { }
/**
 * @docs-group-description Curve
 * Curves in the GeometryQuery hierarchy: LineSegment3d, LineString3d, Arc3d, TransitionSpiral3d
 * * CurvePrimitive -- base class for parametric curves
 *   * LineSegment3d -- a (bounded) portion of an unbounded line
 *   * Arc3d -- a circular or elliptic arc
 *   * LineString3d -- a sequence of points joined by line segments
 *   * TransitionSpiral -- controlled transition between curvatures
 * * Support classes
 * * PointString3d -- a sequence of isolated points
 * * StrokeOptions -- tolerances to describe stroking accuracy
 * * RecursiveCurveProcessor, RecursiveCurveProcessorWithStack -- algorithmic support for trees with CurvePrimitives at the leaf level.
 */
// doc:export class CurveDoc { }
/**
 * @docs-group-description Numerics
 * The Numerics classes have geometric and numeric methods used during large algorithms in other classes.
 */
// doc:export class NumericsDoc { }
/**
 * @docs-group-description Polyface
 * A Polyface is a mesh structure with arrays of points that are shared among multiple incident facets.
 */
// doc:export class PolyfaceDoc { }
/**
 * @docs-group-description Serialization
 * These classes are related to serialization of geometry classes.
 * * IModelJson.Reader, IModelJson.Writer -- Conversion of in-memory geometry objects to json objects for persistence and transmission.
 */
// doc:export class SerializationDoc { }
/**
 * @docs-group-description Solid
 * Analytic Solids in the GeometryQuery hierarchy: Box, Sphere, Cone, TorusPipe, LinearSweep, RotationalSweep, RuledSweep
 * * Box -- a box solid.  This is usually rectangular on all faces, but can in one directly like a view frustum
 * * Sphere -- a sphere
 * * Cone -- a cone or cylinder
 * * TorusPipe -- a pipe elbow
 * * LinearSweep -- a linear sweep of a base contour
 * * RotationalSweep -- a rotational sweep of a base contour
 * * RuledSweep -- two or more similarly structured contours joined by linear rule lines.
 */
// doc:export class SolidDOc { }
/**
 * @docs-group-description Topology
 * The Topology classes provide adjacency structures used in triangulations.
 */
// doc:export class TopologyDoc { }
__export(__webpack_require__(/*! ./geometry3d/Angle */ "./lib/geometry3d/Angle.js"));
__export(__webpack_require__(/*! ./geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js"));
__export(__webpack_require__(/*! ./geometry3d/BarycentricTriangle */ "./lib/geometry3d/BarycentricTriangle.js"));
__export(__webpack_require__(/*! ./geometry3d/BilinearPatch */ "./lib/geometry3d/BilinearPatch.js"));
__export(__webpack_require__(/*! ./geometry3d/FrameBuilder */ "./lib/geometry3d/FrameBuilder.js"));
__export(__webpack_require__(/*! ./geometry3d/FrustumAnimation */ "./lib/geometry3d/FrustumAnimation.js"));
__export(__webpack_require__(/*! ./geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js"));
__export(__webpack_require__(/*! ./geometry3d/GrowableBlockedArray */ "./lib/geometry3d/GrowableBlockedArray.js"));
__export(__webpack_require__(/*! ./geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js"));
__export(__webpack_require__(/*! ./geometry3d/GrowableXYArray */ "./lib/geometry3d/GrowableXYArray.js"));
__export(__webpack_require__(/*! ./geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js"));
__export(__webpack_require__(/*! ./geometry3d/IndexedCollectionInterval */ "./lib/geometry3d/IndexedCollectionInterval.js"));
__export(__webpack_require__(/*! ./geometry3d/IndexedXYCollection */ "./lib/geometry3d/IndexedXYCollection.js"));
__export(__webpack_require__(/*! ./geometry3d/IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js"));
__export(__webpack_require__(/*! ./geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js"));
__export(__webpack_require__(/*! ./geometry3d/OrderedRotationAngles */ "./lib/geometry3d/OrderedRotationAngles.js"));
__export(__webpack_require__(/*! ./geometry3d/Plane3dByOriginAndUnitNormal */ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js"));
__export(__webpack_require__(/*! ./geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js"));
__export(__webpack_require__(/*! ./geometry3d/Point2dArrayCarrier */ "./lib/geometry3d/Point2dArrayCarrier.js"));
__export(__webpack_require__(/*! ./geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js"));
__export(__webpack_require__(/*! ./geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js"));
__export(__webpack_require__(/*! ./geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js"));
__export(__webpack_require__(/*! ./geometry3d/Point3dArrayCarrier */ "./lib/geometry3d/Point3dArrayCarrier.js"));
__export(__webpack_require__(/*! ./geometry3d/PolylineOps */ "./lib/geometry3d/PolylineOps.js"));
__export(__webpack_require__(/*! ./geometry3d/PolygonOps */ "./lib/geometry3d/PolygonOps.js"));
__export(__webpack_require__(/*! ./geometry3d/Range */ "./lib/geometry3d/Range.js"));
__export(__webpack_require__(/*! ./geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js"));
__export(__webpack_require__(/*! ./geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js"));
__export(__webpack_require__(/*! ./geometry3d/Transform */ "./lib/geometry3d/Transform.js"));
__export(__webpack_require__(/*! ./geometry3d/YawPitchRollAngles */ "./lib/geometry3d/YawPitchRollAngles.js"));
__export(__webpack_require__(/*! ./Geometry */ "./lib/Geometry.js"));
__export(__webpack_require__(/*! ./Constant */ "./lib/Constant.js"));
__export(__webpack_require__(/*! ./clipping/ClipPlane */ "./lib/clipping/ClipPlane.js"));
__export(__webpack_require__(/*! ./clipping/ConvexClipPlaneSet */ "./lib/clipping/ConvexClipPlaneSet.js"));
__export(__webpack_require__(/*! ./clipping/UnionOfConvexClipPlaneSets */ "./lib/clipping/UnionOfConvexClipPlaneSets.js"));
__export(__webpack_require__(/*! ./clipping/ClipPrimitive */ "./lib/clipping/ClipPrimitive.js"));
__export(__webpack_require__(/*! ./clipping/ClipVector */ "./lib/clipping/ClipVector.js"));
__export(__webpack_require__(/*! ./clipping/ClipUtils */ "./lib/clipping/ClipUtils.js"));
__export(__webpack_require__(/*! ./numerics/ConvexPolygon2d */ "./lib/numerics/ConvexPolygon2d.js"));
__export(__webpack_require__(/*! ./geometry4d/PlaneByOriginAndVectors4d */ "./lib/geometry4d/PlaneByOriginAndVectors4d.js"));
__export(__webpack_require__(/*! ./geometry4d/Point4d */ "./lib/geometry4d/Point4d.js"));
__export(__webpack_require__(/*! ./geometry4d/Matrix4d */ "./lib/geometry4d/Matrix4d.js"));
__export(__webpack_require__(/*! ./geometry4d/Map4d */ "./lib/geometry4d/Map4d.js"));
__export(__webpack_require__(/*! ./geometry4d/MomentData */ "./lib/geometry4d/MomentData.js"));
__export(__webpack_require__(/*! ./numerics/BezierPolynomials */ "./lib/numerics/BezierPolynomials.js"));
__export(__webpack_require__(/*! ./numerics/ClusterableArray */ "./lib/numerics/ClusterableArray.js"));
__export(__webpack_require__(/*! ./numerics/Newton */ "./lib/numerics/Newton.js"));
__export(__webpack_require__(/*! ./numerics/Complex */ "./lib/numerics/Complex.js"));
__export(__webpack_require__(/*! ./numerics/ConvexPolygon2d */ "./lib/numerics/ConvexPolygon2d.js"));
__export(__webpack_require__(/*! ./numerics/Newton */ "./lib/numerics/Newton.js"));
__export(__webpack_require__(/*! ./numerics/PascalCoefficients */ "./lib/numerics/PascalCoefficients.js"));
__export(__webpack_require__(/*! ./numerics/Polynomials */ "./lib/numerics/Polynomials.js"));
__export(__webpack_require__(/*! ./numerics/Quadrature */ "./lib/numerics/Quadrature.js"));
__export(__webpack_require__(/*! ./numerics/Range1dArray */ "./lib/numerics/Range1dArray.js"));
__export(__webpack_require__(/*! ./numerics/TriDiagonalSystem */ "./lib/numerics/TriDiagonalSystem.js"));
__export(__webpack_require__(/*! ./curve/Arc3d */ "./lib/curve/Arc3d.js"));
__export(__webpack_require__(/*! ./curve/ConstructCurveBetweenCurves */ "./lib/curve/ConstructCurveBetweenCurves.js"));
__export(__webpack_require__(/*! ./curve/CoordinateXYZ */ "./lib/curve/CoordinateXYZ.js"));
__export(__webpack_require__(/*! ./curve/CurveChainWithDistanceIndex */ "./lib/curve/CurveChainWithDistanceIndex.js"));
__export(__webpack_require__(/*! ./curve/CurveExtendMode */ "./lib/curve/CurveExtendMode.js"));
__export(__webpack_require__(/*! ./curve/CurveCollection */ "./lib/curve/CurveCollection.js"));
__export(__webpack_require__(/*! ./curve/CurveCurve */ "./lib/curve/CurveCurve.js"));
__export(__webpack_require__(/*! ./curve/CurveCurveIntersectXY */ "./lib/curve/CurveCurveIntersectXY.js"));
__export(__webpack_require__(/*! ./curve/CurveCurveIntersectXYZ */ "./lib/curve/CurveCurveIntersectXYZ.js"));
__export(__webpack_require__(/*! ./curve/CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js"));
__export(__webpack_require__(/*! ./curve/CurveFactory */ "./lib/curve/CurveFactory.js"));
__export(__webpack_require__(/*! ./curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js"));
__export(__webpack_require__(/*! ./curve/CurveProcessor */ "./lib/curve/CurveProcessor.js"));
__export(__webpack_require__(/*! ./curve/GeometryQuery */ "./lib/curve/GeometryQuery.js"));
__export(__webpack_require__(/*! ./curve/LineSegment3d */ "./lib/curve/LineSegment3d.js"));
__export(__webpack_require__(/*! ./curve/LineString3d */ "./lib/curve/LineString3d.js"));
__export(__webpack_require__(/*! ./curve/Loop */ "./lib/curve/Loop.js"));
__export(__webpack_require__(/*! ./curve/ParityRegion */ "./lib/curve/ParityRegion.js"));
__export(__webpack_require__(/*! ./curve/Path */ "./lib/curve/Path.js"));
__export(__webpack_require__(/*! ./curve/RegionMomentsXY */ "./lib/curve/RegionMomentsXY.js"));
__export(__webpack_require__(/*! ./curve/RegionOps */ "./lib/curve/RegionOps.js"));
__export(__webpack_require__(/*! ./curve/PolygonOffsetContext */ "./lib/curve/PolygonOffsetContext.js"));
__export(__webpack_require__(/*! ./curve/PointString3d */ "./lib/curve/PointString3d.js"));
__export(__webpack_require__(/*! ./curve/StrokeOptions */ "./lib/curve/StrokeOptions.js"));
__export(__webpack_require__(/*! ./curve/TransitionSpiral */ "./lib/curve/TransitionSpiral.js"));
__export(__webpack_require__(/*! ./curve/UnionRegion */ "./lib/curve/UnionRegion.js"));
__export(__webpack_require__(/*! ./curve/Query/StrokeCountMap */ "./lib/curve/Query/StrokeCountMap.js"));
__export(__webpack_require__(/*! ./solid/Box */ "./lib/solid/Box.js"));
__export(__webpack_require__(/*! ./solid/Cone */ "./lib/solid/Cone.js"));
__export(__webpack_require__(/*! ./solid/LinearSweep */ "./lib/solid/LinearSweep.js"));
__export(__webpack_require__(/*! ./solid/RotationalSweep */ "./lib/solid/RotationalSweep.js"));
__export(__webpack_require__(/*! ./solid/RuledSweep */ "./lib/solid/RuledSweep.js"));
__export(__webpack_require__(/*! ./solid/SolidPrimitive */ "./lib/solid/SolidPrimitive.js"));
__export(__webpack_require__(/*! ./solid/Sphere */ "./lib/solid/Sphere.js"));
__export(__webpack_require__(/*! ./solid/SweepContour */ "./lib/solid/SweepContour.js"));
__export(__webpack_require__(/*! ./solid/TorusPipe */ "./lib/solid/TorusPipe.js"));
__export(__webpack_require__(/*! ./bspline/Bezier1dNd */ "./lib/bspline/Bezier1dNd.js"));
__export(__webpack_require__(/*! ./bspline/BezierCurveBase */ "./lib/bspline/BezierCurveBase.js"));
__export(__webpack_require__(/*! ./bspline/BezierCurve3d */ "./lib/bspline/BezierCurve3d.js"));
__export(__webpack_require__(/*! ./bspline/BezierCurve3dH */ "./lib/bspline/BezierCurve3dH.js"));
__export(__webpack_require__(/*! ./bspline/BSplineCurve */ "./lib/bspline/BSplineCurve.js"));
__export(__webpack_require__(/*! ./bspline/BSpline1dNd */ "./lib/bspline/BSpline1dNd.js"));
__export(__webpack_require__(/*! ./bspline/BSplineCurve3dH */ "./lib/bspline/BSplineCurve3dH.js"));
__export(__webpack_require__(/*! ./bspline/BSplineSurface */ "./lib/bspline/BSplineSurface.js"));
__export(__webpack_require__(/*! ./bspline/KnotVector */ "./lib/bspline/KnotVector.js"));
__export(__webpack_require__(/*! ./polyface/AuxData */ "./lib/polyface/AuxData.js"));
__export(__webpack_require__(/*! ./polyface/BoxTopology */ "./lib/polyface/BoxTopology.js"));
__export(__webpack_require__(/*! ./polyface/FacetFaceData */ "./lib/polyface/FacetFaceData.js"));
__export(__webpack_require__(/*! ./polyface/Polyface */ "./lib/polyface/Polyface.js"));
__export(__webpack_require__(/*! ./polyface/PolyfaceBuilder */ "./lib/polyface/PolyfaceBuilder.js"));
__export(__webpack_require__(/*! ./polyface/PolyfaceData */ "./lib/polyface/PolyfaceData.js"));
__export(__webpack_require__(/*! ./polyface/PolyfaceQuery */ "./lib/polyface/PolyfaceQuery.js"));
__export(__webpack_require__(/*! ./polyface/PolyfaceClip */ "./lib/polyface/PolyfaceClip.js"));
__export(__webpack_require__(/*! ./topology/Graph */ "./lib/topology/Graph.js"));
__export(__webpack_require__(/*! ./topology/Triangulation */ "./lib/topology/Triangulation.js"));
__export(__webpack_require__(/*! ./serialization/IModelJsonSchema */ "./lib/serialization/IModelJsonSchema.js"));
__export(__webpack_require__(/*! ./serialization/DeepCompare */ "./lib/serialization/DeepCompare.js"));
__export(__webpack_require__(/*! ./serialization/GeometrySamples */ "./lib/serialization/GeometrySamples.js"));
if (( true) && (typeof window !== "undefined") && window) {
    if (!window.iModelJsVersions)
        window.iModelJsVersions = new Map();
    window.iModelJsVersions.set("geometry-core", "1.7.0");
}


/***/ }),

/***/ "./lib/geometry3d/Angle.js":
/*!*********************************!*\
  !*** ./lib/geometry3d/Angle.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/** @module CartesianGeometry */
/**
 * An `Angle` carries the numeric value of an angle, with methods to allow (require!) callers to be clear about whether their angle is degrees or radians.
 * * The numeric value is private, and callers should not know or care whether it is in degrees or radians.
 * * The various access method are named so that callers can specify whether untyped numbers passed in or out are degrees or radians.
 * @public
 */
class Angle {
    constructor(radians = 0, degrees) {
        this._radians = radians;
        this._degrees = degrees;
    }
    /** Return a new angle with the same content. */
    clone() { return new Angle(this._radians, this._degrees); }
    /** Freeze this instance so it can be considered read-only */
    freeze() { Object.freeze(this); }
    /**
     * Return a new Angle object for angle given in degrees.
     * @param degrees angle in degrees
     */
    static createDegrees(degrees) { return new Angle(Angle.degreesToRadians(degrees), degrees); }
    /**
     * Return a (new) Angle object for a value given in radians.
     * @param radians angle in radians
     */
    static createRadians(radians) { return new Angle(radians); }
    /**
     * Return a (new) Angle object, with angle scaled from existing angle.
     * @param scale scale factor to apply to angle.
     */
    cloneScaled(scale) { return new Angle(this.radians * scale); }
    /**
     * Set this angle to a value given in radians.
     * @param radians angle given in radians
     */
    setRadians(radians) { this._radians = radians; this._degrees = undefined; }
    /**
     * Set this angle to a value given in degrees.
     * @param degrees angle given in degrees.
     */
    setDegrees(degrees) { this._radians = Angle.degreesToRadians(degrees); this._degrees = degrees; }
    /** Create an angle for a full circle. */
    static create360() { return new Angle(Math.PI * 2.0, 360.0); }
    /**
     * @return a (strongly typed) Angle whose tangent is `numerator/denominator`, using the signs of both in determining the (otherwise ambiguous)
     * quadrant.
     * @param numerator numerator for tangent
     * @param denominator denominator for tangent
     */
    static createAtan2(numerator, denominator) { return new Angle(Math.atan2(numerator, denominator)); }
    /**
     * Copy all contents of `other` to this Angle.
     * @param other source data
     */
    setFrom(other) { this._radians = other._radians; this._degrees = other._degrees; }
    /**
     * Create an Angle from a JSON object
     * @param json object from JSON.parse. If a number, value is in *DEGREES*
     * @param defaultValRadians if json is undefined, default value in radians.
     * @return a new Angle
     */
    static fromJSON(json, defaultValRadians) {
        const val = new Angle();
        val.setFromJSON(json, defaultValRadians);
        return val;
    }
    /**
     * set an Angle from a JSON object
     * * A simple number is degrees.
     * * specified `json.degrees` or `json._degrees` is degree value.
     * * specified `son.radians` or `json._radians` is radians value.
     * @param json object from JSON.parse. If a number, value is in *DEGREES*
     * @param defaultValRadians if json is undefined, default value in radians.
     */
    setFromJSON(json, defaultValRadians) {
        this._radians = defaultValRadians ? defaultValRadians : 0;
        if (!json)
            return;
        if (typeof json === "number") {
            this.setDegrees(json);
        }
        else if (typeof json.degrees === "number") {
            this.setDegrees(json.degrees);
        }
        else if (typeof json._degrees === "number") {
            this.setDegrees(json._degrees);
        }
        else if (typeof json.radians === "number") {
            this.setRadians(json.radians);
        }
        else if (typeof json._radians === "number") {
            this.setRadians(json._radians);
        }
    }
    /** Convert an Angle to a JSON object as a number in degrees */
    toJSON() { return this.degrees; }
    /** Return a json object with radians keyword, e.g. `{ radians: 0.10}` */
    toJSONRadians() { return { radians: this.radians }; }
    /**  Return the angle measured in radians. */
    get radians() { return this._radians; }
    /**  Return the angle measured in degrees. */
    get degrees() { return this._degrees !== undefined ? this._degrees : Angle.radiansToDegrees(this._radians); }
    /**
     * Convert an angle in degrees to radians.
     * @param degrees angle in degrees
     */
    static degreesToRadians(degrees) { return degrees * Math.PI / 180; }
    /**
     * Convert an angle in radians to degrees.
     * @param degrees angle in radians
     */
    static radiansToDegrees(radians) {
        if (radians < 0)
            return -Angle.radiansToDegrees(-radians);
        // Now radians is positive ...
        const pi = Math.PI;
        const factor = 180.0 / pi;
        if (radians <= 0.25 * pi)
            return factor * radians;
        if (radians < 0.75 * pi)
            return 90.0 + 180 * ((radians - 0.5 * pi) / pi);
        if (radians <= 1.25 * pi)
            return 180.0 + 180 * ((radians - pi) / pi);
        if (radians <= 1.75 * pi)
            return 270.0 + 180 * ((radians - 1.5 * pi) / pi);
        // all larger radians reference from 360 degrees (2PI)
        return 360.0 + 180 * ((radians - 2.0 * pi) / pi);
    }
    /**
     * Return the cosine of this Angle object's angle.
     */
    cos() { return Math.cos(this._radians); }
    /**
     * Return the sine of this Angle object's angle.
     */
    sin() { return Math.sin(this._radians); }
    /**
     * Return the tangent of this Angle object's angle.
     */
    tan() { return Math.tan(this._radians); }
    /** Test if a radians value is nearly 2PI or larger (!) */
    static isFullCircleRadians(radians) { return Math.abs(radians) >= Geometry_1.Geometry.fullCircleRadiansMinusSmallAngle; }
    /** Test if the radians value  is a complete circle */
    static isHalfCircleRadians(radians) { return (Math.abs(Math.abs(radians)) - Math.PI) <= Geometry_1.Geometry.smallAngleRadians; }
    /** test if the angle is aa full circle */
    get isFullCircle() { return Angle.isFullCircleRadians(this._radians); }
    /** test if the angle is a half circle (in either direction) */
    get isHalfCircle() { return Angle.isHalfCircleRadians(this._radians); }
    /** Adjust a radians value so it is positive in 0..360 */
    static adjustDegrees0To360(degrees) {
        if (degrees >= 0) {
            const period = 360.0;
            if (degrees < period)
                return degrees;
            const numPeriods = Math.floor(degrees / period);
            return degrees - numPeriods * period;
        }
        // negative angle ...
        const radians1 = Angle.adjustDegrees0To360(-degrees);
        return 360.0 - radians1;
    }
    /** Adjust a radians value so it is positive in -180..180 */
    static adjustDegreesSigned180(degrees) {
        if (Math.abs(degrees) <= 180.0)
            return degrees;
        if (degrees >= 0) {
            const period = 360.0;
            const numPeriods = 1 + Math.floor((degrees - 180.0) / period);
            return degrees - numPeriods * period;
        }
        // negative angle ...
        return -Angle.adjustDegreesSigned180(-degrees);
    }
    /** Adjust a radians value so it is positive in 0..2Pi */
    static adjustRadians0To2Pi(radians) {
        if (radians >= 0) {
            const period = Math.PI * 2.0;
            if (radians < period)
                return radians;
            const numPeriods = Math.floor(radians / period);
            return radians - numPeriods * period;
        }
        // negative angle ...
        const radians1 = Angle.adjustRadians0To2Pi(-radians);
        return Math.PI * 2.0 - radians1;
    }
    /** Adjust a radians value so it is positive in -PI..PI */
    static adjustRadiansMinusPiPlusPi(radians) {
        if (Math.abs(radians) <= Math.PI)
            return radians;
        if (radians >= 0) {
            const period = Math.PI * 2.0;
            const numPeriods = 1 + Math.floor((radians - Math.PI) / period);
            return radians - numPeriods * period;
        }
        // negative angle ...
        return -Angle.adjustRadiansMinusPiPlusPi(-radians);
    }
    /** return a (newly allocated) Angle object with value 0 radians */
    static zero() { return new Angle(0); }
    /** Test if the angle is exactly zero. */
    get isExactZero() { return this.radians === 0; }
    /** Test if the angle is almost zero (within tolerance `Geometry.smallAngleRadians`) */
    get isAlmostZero() { return Math.abs(this.radians) < Geometry_1.Geometry.smallAngleRadians; }
    /** Create an angle object with degrees adjusted into 0..360. */
    static createDegreesAdjustPositive(degrees) { return Angle.createDegrees(Angle.adjustDegrees0To360(degrees)); }
    /** Create an angle object with degrees adjusted into -180..180. */
    static createDegreesAdjustSigned180(degrees) { return Angle.createDegrees(Angle.adjustDegreesSigned180(degrees)); }
    /**
     * Test if two radians values are equivalent, allowing shift by full circle (i.e. by a multiple of `2*PI`)
     * @param radiansA first radians value
     * @param radiansB second radians value
     */
    static isAlmostEqualRadiansAllowPeriodShift(radiansA, radiansB) {
        // try to get simple conclusions with un-shifted radians ...
        const delta = Math.abs(radiansA - radiansB);
        if (delta <= Geometry_1.Geometry.smallAngleRadians)
            return true;
        const period = Math.PI * 2.0;
        if (Math.abs(delta - period) <= Geometry_1.Geometry.smallAngleRadians)
            return true;
        const numPeriod = Math.round(delta / period);
        const delta1 = delta - numPeriod * period;
        return Math.abs(delta1) <= Geometry_1.Geometry.smallAngleRadians;
    }
    /**
     * Test if this angle and other are equivalent, allowing shift by full circle (i.e. by a multiple of 360 degrees)
     */
    isAlmostEqualAllowPeriodShift(other) {
        return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians, other._radians);
    }
    /**
     * Test if two this angle and other are almost equal, NOT allowing shift by full circle multiples of 360 degrees.
     */
    isAlmostEqualNoPeriodShift(other) { return Math.abs(this._radians - other._radians) < Geometry_1.Geometry.smallAngleRadians; }
    /**
     * Test if two angle (in radians)  almost equal, NOT allowing shift by full circle multiples of `2 * PI`.
     * * (Same test as isAlmostEqualRadiansNoPeriodShift)
     */
    isAlmostEqual(other) { return this.isAlmostEqualNoPeriodShift(other); }
    /**
     * Test if two angle (in radians)  almost equal, NOT allowing shift by full circle multiples of `2 * PI`.
     */
    static isAlmostEqualRadiansNoPeriodShift(radiansA, radiansB) { return Math.abs(radiansA - radiansB) < Geometry_1.Geometry.smallAngleRadians; }
    /**
     * Test if dot product values indicate non-zero length perpendicular vectors.
     * @param dotUU dot product of vectorU with itself
     * @param dotVV dot product of vectorV with itself
     * @param dotUV dot product of vectorU with vectorV
     */
    static isPerpendicularDotSet(dotUU, dotVV, dotUV) {
        return dotUU > Geometry_1.Geometry.smallMetricDistanceSquared
            && dotVV > Geometry_1.Geometry.smallMetricDistanceSquared
            && dotUV * dotUV <= Geometry_1.Geometry.smallAngleRadiansSquared * dotUU * dotVV;
    }
    /**
     * Return cosine, sine, and radians for the half angle of a cosine,sine pair.
     * @param rCos2A cosine value (scaled by radius) for initial angle.
     * @param rSin2A sine value (scaled by radius) for final angle.
     */
    static trigValuesToHalfAngleTrigValues(rCos2A, rSin2A) {
        const r = Geometry_1.Geometry.hypotenuseXY(rCos2A, rSin2A);
        if (r < Geometry_1.Geometry.smallMetricDistance) {
            return { c: 1.0, s: 0.0, radians: 0.0 };
        }
        else {
            /* If the caller really gave you sine and cosine values, r should be 1.  However,*/
            /* to allow scaled values -- e.g. the x and y components of any vector -- we normalize*/
            /* right here.  This adds an extra sqrt and 2 divides to the whole process, but improves*/
            /* both the usefulness and robustness of the computation.*/
            let cosA = 1.0;
            let sinA = 0.0;
            const cos2A = rCos2A / r;
            const sin2A = rSin2A / r;
            if (cos2A >= 0.0) {
                /* Original angle in NE and SE quadrants.  Half angle in same quadrant */
                cosA = Math.sqrt(0.5 * (1.0 + cos2A));
                sinA = sin2A / (2.0 * (cosA));
            }
            else {
                if (sin2A > 0.0) {
                    /* Original angle in NW quadrant. Half angle in NE quadrant */
                    sinA = Math.sqrt(0.5 * (1.0 - cos2A));
                }
                else {
                    /* Original angle in SW quadrant. Half angle in SE quadrant*/
                    /* cosA comes out positive because both sines are negative. */
                    sinA = -Math.sqrt(0.5 * (1.0 - cos2A));
                }
                cosA = sin2A / (2.0 * (sinA));
            }
            return { c: cosA, s: sinA, radians: Math.atan2(sinA, cosA) };
        }
    }
    /** If value is close to -1, -0.5, 0, 0.5, 1, adjust it to the exact value. */
    static cleanupTrigValue(value, tolerance = 1.0e-15) {
        const absValue = Math.abs(value);
        if (absValue <= tolerance)
            return 0;
        let a = Math.abs(absValue - 0.5);
        if (a <= tolerance)
            return value < 0.0 ? -0.5 : 0.5;
        a = Math.abs(absValue - 1.0);
        if (a <= tolerance)
            return value < 0.0 ? -1.0 : 1.0;
        return value;
    }
    /**
     * Return the half angle cosine, sine, and radians for given dot products between vectors.
     * @param dotUU dot product of vectorU with itself
     * @param dotVV dot product of vectorV with itself
     * @param dotUV dot product of vectorU with vectorV
     */
    static dotProductsToHalfAngleTrigValues(dotUU, dotVV, dotUV, favorZero = true) {
        const rCos = dotUU - dotVV;
        const rSin = 2.0 * dotUV;
        if (favorZero && Math.abs(rSin) < Geometry_1.Geometry.smallAngleRadians * (Math.abs(dotUU) + Math.abs(dotVV)))
            return { c: 1.0, s: 0.0, radians: 0.0 };
        return Angle.trigValuesToHalfAngleTrigValues(rCos, rSin);
    }
    /**
     * * Returns the angle between two vectors, with the vectors given as xyz components
     * * The returned angle is between 0 and PI
     *
     * @param ux x component of vector u
     * @param uy y component of vector u
     * @param uz z component of vector u
     * @param vx x component of vector v
     * @param vy y component of vector v
     * @param vz z component of vector v
     */
    static radiansBetweenVectorsXYZ(ux, uy, uz, vx, vy, vz) {
        //  const uu = ux * ux + uy * uy + uz * uz;
        const uDotV = ux * vx + uy * vy + uz * vz; // magU magV cos(theta)
        //    const vv = vx * vx + vy * vy + vz * vz;
        return Math.atan2(Geometry_1.Geometry.crossProductMagnitude(ux, uy, uz, vx, vy, vz), uDotV);
    }
    /**
     * Add a multiple of a full circle angle (360 degrees, 2PI) in place.
     * @param multiple multiplier factor
     */
    addMultipleOf2PiInPlace(multiple) {
        if (this._degrees !== undefined) {
            this._degrees += multiple * 360.0;
            this._radians = Angle.degreesToRadians(this._degrees);
        }
        else {
            this._radians += multiple * Angle.pi2Radians;
        }
    }
}
exports.Angle = Angle;
/** maximal accuracy value of pi/4 ( 45 degrees), in radians */
Angle.piOver4Radians = 7.85398163397448280000e-001;
/** maximal accuracy value of pi/2 ( 90 degrees), in radians */
Angle.piOver2Radians = 1.57079632679489660000e+000;
/** maximal accuracy value of pi ( 180 degrees), in radians */
Angle.piRadians = 3.14159265358979310000e+000;
/** maximal accuracy value of 2*pi (360 degrees), in radians */
Angle.pi2Radians = 6.28318530717958620000e+000;
/** scale factor for converting degrees to radians */
Angle.degreesPerRadian = (45.0 / Angle.piOver4Radians);
/** scale factor for converting radians to degrees */
Angle.radiansPerDegree = (Angle.piOver4Radians / 45.0);
/** maximal accuracy value of pi/12 ( 15 degrees), in radians */
Angle.piOver12Radians = 0.26179938779914943653855361527329;


/***/ }),

/***/ "./lib/geometry3d/AngleSweep.js":
/*!**************************************!*\
  !*** ./lib/geometry3d/AngleSweep.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/** @module CartesianGeometry */
/**
 * An `AngleSweep` is a pair of angles at start and end of an interval.
 *
 * *  For stroking purposes, the "included interval" is all angles numerically reached by theta = start + f*(end-start), where f is between 0 and 1.
 * *  This stroking formula is simple numbers -- 2PI shifts are not involved.
 * *  2PI shifts do become important in the reverse mapping of an angle to a fraction.
 * *  If (start < end) the angle proceeds CCW around the unit circle.
 * *  If (end < start) the angle proceeds CW around the unit circle.
 * *  Angles beyond 360 are fine as endpoints.
 *   *  (350,370) covers the same unit angles as (-10,10).
 *   *  (370,350) covers the same unit angles as (10,-10).
 * @public
 */
class AngleSweep {
    /** (private) constructor with start and end angles in radians.
     *  * Use explicitly named static methods to clarify intent and units of inputs:
     *
     * * createStartEndRadians (startRadians:number, endRadians:number)
     * * createStartEndDegrees (startDegrees:number, endDegrees:number)
     * * createStartEnd (startAngle:Angle, endAngle:Angle)
     * * createStartSweepRadians (startRadians:number, sweepRadians:number)
     * * createStartSweepDegrees (startDegrees:number, sweepDegrees:number)
     * * createStartSweep (startAngle:Angle, sweepAngle:Angle)
     */
    constructor(startRadians = 0, endRadians = 0) { this._radians0 = startRadians; this._radians1 = endRadians; }
    /** Read-property for degrees at the start of this AngleSweep. */
    get startDegrees() { return Angle_1.Angle.radiansToDegrees(this._radians0); }
    /** Read-property for degrees at the end of this AngleSweep. */
    get endDegrees() { return Angle_1.Angle.radiansToDegrees(this._radians1); }
    /** Read-property for signed start-to-end sweep in degrees. */
    get sweepDegrees() { return Angle_1.Angle.radiansToDegrees(this._radians1 - this._radians0); }
    /** Read-property for degrees at the start of this AngleSweep. */
    get startRadians() { return this._radians0; }
    /** Read-property for degrees at the end of this AngleSweep. */
    get endRadians() { return this._radians1; }
    /** Read-property for signed start-to-end sweep in radians. */
    get sweepRadians() { return this._radians1 - this._radians0; }
    /** Return the (strongly typed) start angle */
    get startAngle() { return Angle_1.Angle.createRadians(this._radians0); }
    /** Return the (strongly typed) end angle */
    get endAngle() { return Angle_1.Angle.createRadians(this._radians1); }
    /** create an AngleSweep from start and end angles given in radians. */
    static createStartEndRadians(startRadians = 0, endRadians = 2.0 * Math.PI, result) {
        result = result ? result : new AngleSweep();
        result.setStartEndRadians(startRadians, endRadians);
        return result;
    }
    /** Return the angle obtained by subtracting radians from this angle. */
    cloneMinusRadians(radians) { return new AngleSweep(this._radians0 - radians, this._radians1 - radians); }
    /** create an AngleSweep from start and end angles given in degrees. */
    static createStartEndDegrees(startDegrees = 0, endDegrees = 360, result) {
        return AngleSweep.createStartEndRadians(Angle_1.Angle.degreesToRadians(startDegrees), Angle_1.Angle.degreesToRadians(endDegrees), result);
    }
    /** create an angle sweep from strongly typed start and end angles */
    static createStartEnd(startAngle, endAngle, result) {
        result = result ? result : new AngleSweep();
        result.setStartEndRadians(startAngle.radians, endAngle.radians);
        return result;
    }
    /** Create an angle sweep with limits given as (strongly typed) angles for start and sweep */
    static createStartSweep(startAngle, sweepAngle, result) {
        return AngleSweep.createStartSweepRadians(startAngle.radians, sweepAngle.radians, result);
    }
    /** Return a sweep with limits interpolated between this and other. */
    interpolate(fraction, other) {
        return new AngleSweep(Geometry_1.Geometry.interpolate(this._radians0, fraction, other._radians0), Geometry_1.Geometry.interpolate(this._radians1, fraction, other._radians1));
    }
    /** create an AngleSweep from start and end angles given in radians. */
    static createStartSweepRadians(startRadians = 0, sweepRadians = Math.PI, result) {
        result = result ? result : new AngleSweep();
        result.setStartEndRadians(startRadians, startRadians + sweepRadians);
        return result;
    }
    /** create an AngleSweep from start and sweep given in degrees.  */
    static createStartSweepDegrees(startDegrees = 0, sweepDegrees = 360, result) {
        return AngleSweep.createStartEndRadians(Angle_1.Angle.degreesToRadians(startDegrees), Angle_1.Angle.degreesToRadians(startDegrees + sweepDegrees), result);
    }
    /** directly set the start and end angles in radians */
    setStartEndRadians(startRadians = 0, endRadians = 2.0 * Math.PI) {
        const delta = endRadians - startRadians;
        if (Angle_1.Angle.isFullCircleRadians(delta)) {
            endRadians = startRadians + (delta > 0 ? 2.0 : -2.0) * Math.PI;
        }
        this._radians0 = startRadians;
        this._radians1 = endRadians;
    }
    /** directly set the start and end angles in degrees */
    setStartEndDegrees(startDegrees = 0, endDegrees = 360.0) {
        this.setStartEndRadians(Angle_1.Angle.degreesToRadians(startDegrees), Angle_1.Angle.degreesToRadians(endDegrees));
    }
    /** copy from other AngleSweep. */
    setFrom(other) { this._radians0 = other._radians0; this._radians1 = other._radians1; }
    /** create a full circle sweep (CCW). startRadians defaults to 0 */
    static create360(startRadians) {
        startRadians = startRadians ? startRadians : 0.0;
        return new AngleSweep(startRadians, startRadians + 2.0 * Math.PI);
    }
    /** create a sweep from the south pole to the north pole. */
    static createFullLatitude() { return AngleSweep.createStartEndRadians(-0.5 * Math.PI, 0.5 * Math.PI); }
    /** Reverse the start and end angle in place. */
    reverseInPlace() { const a = this._radians0; this._radians0 = this._radians1; this._radians1 = a; }
    /** Restrict start and end angles into the range (-90,+90) in degrees. */
    capLatitudeInPlace() {
        const limit = 0.5 * Math.PI;
        this._radians0 = Geometry_1.Geometry.clampToStartEnd(this._radians0, -limit, limit);
        this._radians1 = Geometry_1.Geometry.clampToStartEnd(this._radians1, -limit, limit);
    }
    /** Ask if the sweep is counterclockwise, i.e. positive sweep */
    get isCCW() { return this._radians1 >= this._radians0; }
    /** Ask if the sweep is a full circle. */
    get isFullCircle() { return Angle_1.Angle.isFullCircleRadians(this.sweepRadians); }
    /** Ask if the sweep is a full sweep from south pole to north pole. */
    get isFullLatitudeSweep() {
        const a = Math.PI * 0.5;
        return Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, -a)
            && Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1, a);
    }
    /** return a clone of this sweep. */
    clone() { return new AngleSweep(this._radians0, this._radians1); }
    /** Convert fractional position in the sweep to radians. */
    fractionToRadians(fraction) {
        return fraction < 0.5 ?
            this._radians0 + fraction * (this._radians1 - this._radians0)
            : this._radians1 + (fraction - 1.0) * (this._radians1 - this._radians0);
    }
    /** Convert fractional position in the sweep to strongly typed Angle object. */
    fractionToAngle(fraction) {
        return Angle_1.Angle.createRadians(this.fractionToRadians(fraction));
    }
    /** return 2PI divided by the sweep radians (i.e. 360 degrees divided by sweep angle).
     * This is the number of fractional intervals required to cover a whole circle.
     */
    fractionPeriod() {
        return Geometry_1.Geometry.safeDivideFraction(Math.PI * 2.0, Math.abs(this._radians1 - this._radians0), 1.0);
    }
    /** return the fractionalized position of the angle,
     * computed without consideration of 2PI period.
     * That is, an angle that is numerically much beyond than the end angle
     * will produce a large fraction and an angle much beyond the start angle
     * will produce a large negative fraction.
     *
     */
    angleToUnboundedFraction(theta) {
        return Geometry_1.Geometry.safeDivideFraction(theta.radians - this._radians0, this._radians1 - this._radians0, 1.0);
    }
    /** map an angle to a fractional coordinate which is:
     *
     * *  the start angle is at fraction 0
     * *  the end angle is at fraction 1
     * *  interior angles are between 0 and 1
     * *  all exterior angles are at fractions greater than 1
     * *  the periodic jump is at full wraparound to the start angle
     */
    angleToPositivePeriodicFraction(theta) { return this.radiansToPositivePeriodicFraction(theta.radians); }
    /**
     * Convert each value in an array from radians to fraction.
     * @param data array that is input as radians, output as fractions
     */
    radiansArraytoPositivePeriodicFractions(data) {
        const n = data.length;
        for (let i = 0; i < n; i++) {
            data.reassign(i, this.radiansToPositivePeriodicFraction(data.atUncheckedIndex(i)));
        }
    }
    /**
     * Convert a radians value to a fraction that is always positive and can wrap.  See `angleToPositivePeriodicFraction` for detailed description.
     * @param radians
     */
    radiansToPositivePeriodicFraction(radians) {
        if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))
            return 0.0;
        if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))
            return 1.0;
        const sweep = this._radians1 - this._radians0;
        const delta = radians - this._radians0;
        if (sweep > 0) {
            const delta1 = Angle_1.Angle.adjustRadians0To2Pi(delta);
            const fraction1 = Geometry_1.Geometry.safeDivideFraction(delta1, sweep, 0.0);
            return fraction1;
        }
        const delta2 = Angle_1.Angle.adjustRadians0To2Pi(-delta);
        const fraction2 = Geometry_1.Geometry.safeDivideFraction(delta2, -sweep, 0.0);
        return fraction2;
    }
    /** map an angle to a fractional coordinate which is:
     *
     * *  the start angle is at fraction 0
     * *  the end angle is at fraction 1
     * *  interior angles are between 0 and 1
     * *  small negative for angles just "before" the start angle
     * *  more than one for angles just "after" the end angle
     * *  the periodic jump is at the middle of the "outside" interval
     */
    angleToSignedPeriodicFraction(theta) {
        return this.radiansToSignedPeriodicFraction(theta.radians);
    }
    /**
     * Convert a radians value to a fraction, allowing wraparound.  See `angleToSignedPeriodicFraction` for detailed description.
     */
    radiansToSignedPeriodicFraction(radians) {
        if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))
            return 0.0;
        if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))
            return 1.0;
        const sweep = this._radians1 - this._radians0;
        // measure from middle of interval ...
        const delta = radians - this._radians0 - 0.5 * sweep;
        if (sweep > 0) {
            const delta1 = Angle_1.Angle.adjustRadiansMinusPiPlusPi(delta);
            const fraction1 = 0.5 + Geometry_1.Geometry.safeDivideFraction(delta1, sweep, 0.0);
            return fraction1;
        }
        const delta2 = Angle_1.Angle.adjustRadiansMinusPiPlusPi(-delta);
        const fraction = 0.5 + Geometry_1.Geometry.safeDivideFraction(delta2, -sweep, 0.0);
        return fraction;
    }
    /** test if an angle is within the sweep */
    isAngleInSweep(angle) { return this.isRadiansInSweep(angle.radians); }
    /** test if radians are within sweep  */
    isRadiansInSweep(radians) {
        // quick out for simple inside ...
        const delta0 = radians - this._radians0;
        const delta1 = radians - this._radians1;
        if (delta0 * delta1 <= 0.0)
            return true;
        return this.radiansToPositivePeriodicFraction(radians) <= 1.0;
    }
    /** set this AngleSweep from various sources:
     *
     * * if json is undefined, a full-circle sweep is returned.
     * * If json is an AngleSweep object it is is cloned
     * * If json is an array of 2 numbers, those numbers are start and end angles in degrees.
     * * If `json.degrees` is an array of 2 numbers, those numbers are start and end angles in degrees.
     * * If `json.radians` is an array of 2 numbers, those numbers are start and end angles in radians.
     */
    setFromJSON(json) {
        if (!json)
            this.setStartEndRadians(); // default full circle
        else if (json instanceof AngleSweep)
            this.setFrom(json);
        else if (Geometry_1.Geometry.isNumberArray(json.degrees, 2))
            this.setStartEndDegrees(json.degrees[0], json.degrees[1]);
        else if (Geometry_1.Geometry.isNumberArray(json.radians, 2))
            this.setStartEndRadians(json.radians[0], json.radians[1]);
        else if (Geometry_1.Geometry.isNumberArray(json, 2))
            this.setStartEndDegrees(json[0], json[1]);
    }
    /** create an AngleSweep from a json object. */
    static fromJSON(json) {
        const result = AngleSweep.create360();
        result.setFromJSON(json);
        return result;
    }
    /**
     * Convert an AngleSweep to a JSON object.
     * @return {*} {degrees: [startAngleInDegrees, endAngleInDegrees}
     */
    toJSON() {
        // return { degrees: [this.startDegrees, this.endDegrees] };
        return [this.startDegrees, this.endDegrees];
    }
    /** test if start and end angles match, with explicit name to clarify that there is no test for 360-degree shifts. */
    isAlmostEqualAllowPeriodShift(other) {
        return Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians0, other._radians0)
            && Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);
    }
    /** test if start and end angles match, explicit name to clarify that 360-degree shifts are allowed. */
    isAlmostEqualNoPeriodShift(other) {
        return Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, other._radians0)
            && Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);
    }
    /** test if start and end angles match with radians tolerance.
     * * This is equivalent to isAlmostEqualNoPeriodShift.
     * * it is present for consistency with other classes
     * * It is recommended that all callers use one of he longer names to be clear of their intentions:
     * * * isAlmostEqualAllowPeriodShift
     * * * isAlmostEqualRadiansNoPeriodShift
     */
    isAlmostEqual(other) { return this.isAlmostEqualNoPeriodShift(other); }
}
exports.AngleSweep = AngleSweep;


/***/ }),

/***/ "./lib/geometry3d/BarycentricTriangle.js":
/*!***********************************************!*\
  !*** ./lib/geometry3d/BarycentricTriangle.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module CartesianGeometry */
/**
 * 3 points defining a triangle to be evaluated with Barycentric coordinates.
 * @public
 */
class BarycentricTriangle {
    /** Constructor.
     * * Point references are CAPTURED
     */
    constructor(point0, point1, point2) {
        this.points = [];
        this.points.push(point0);
        this.points.push(point1);
        this.points.push(point2);
    }
    /**
     * Return a `BarycentricTriangle` with coordinates given by enumerated x,y,z of the 3 points.
     * @param result optional pre-allocated triangle.
     */
    static createXYZXYZXYZ(x0, y0, z0, x1, y1, z1, x2, y2, z2, result) {
        if (!result)
            return new this(Point3dVector3d_1.Point3d.create(x0, y0, z0), Point3dVector3d_1.Point3d.create(x1, y1, z1), Point3dVector3d_1.Point3d.create(x2, y2, z2));
        result.points[0].set(x0, y0, z0);
        result.points[1].set(x1, y1, z1);
        result.points[2].set(x2, y2, z2);
        return result;
    }
    /** create a triangle with coordinates cloned from given points. */
    static create(point0, point1, point2, result) {
        if (!result)
            return new this(point0.clone(), point1.clone(), point2.clone());
        result.set(point0, point1, point2);
        return result;
    }
    /** Return a new `BarycentricTriangle` with the same coordinates. */
    clone(result) {
        return BarycentricTriangle.create(this.points[0], this.points[1], this.points[2], result);
    }
    /** Return area divided by sum of squared lengths. */
    get aspectRatio() {
        return Geometry_1.Geometry.safeDivideFraction(0.5 * this.points[0].crossProductToPointsMagnitude(this.points[1], this.points[2]), (this.points[0].distanceSquared(this.points[1]) + this.points[1].distanceSquared(this.points[2]) + this.points[2].distanceSquared(this.points[0])), 0);
    }
    /** Return the area of the triangle. */
    get area() {
        return 0.5 * this.points[0].crossProductToPointsMagnitude(this.points[1], this.points[2]);
    }
    /** Sum the points with given scales.
     * * In normal use, the scales will add to 1 and the result point is in the plane of the triangle.
     * * If scales do not add to 1, the point is in the triangle scaled (by the scale sum) from the origin.
     */
    fractionToPoint(a0, a1, a2, result) {
        return Point3dVector3d_1.Point3d.createAdd3Scaled(this.points[0], a0, this.points[1], a1, this.points[2], a2, result);
    }
    /** Copy all values from `other`
     */
    setFrom(other) {
        this.points[0].setFromPoint3d(other.points[0]);
        this.points[1].setFromPoint3d(other.points[1]);
        this.points[2].setFromPoint3d(other.points[2]);
    }
    /** copy contents of (not pointers to) the given points. */
    set(point0, point1, point2) {
        this.points[0].setFromPoint3d(point0);
        this.points[1].setFromPoint3d(point1);
        this.points[2].setFromPoint3d(point2);
    }
    /**
     * * For `this` and `other` BarycentricTriangles, compute cross products of vectors from point0 to point1 and from point0 to point2.
     * * return the dot product of those two
     */
    dotProductOfCrossProductsFromOrigin(other) {
        BarycentricTriangle._workVector0 = this.points[0].crossProductToPoints(this.points[1], this.points[2], BarycentricTriangle._workVector0);
        BarycentricTriangle._workVector1 = other.points[0].crossProductToPoints(other.points[1], other.points[2], BarycentricTriangle._workVector1);
        return BarycentricTriangle._workVector0.dotProduct(BarycentricTriangle._workVector1);
    }
    /** Return the centroid of the 3 points. */
    centroid(result) {
        // write it out to get single scale application.
        // Do the scale as true division (rather than multiply by precomputed 1/3).  This might protect one bit of result.
        return Point3dVector3d_1.Point3d.create((this.points[0].x + this.points[1].x + this.points[2].x) / 3.0, (this.points[0].y + this.points[1].y + this.points[2].y) / 3.0, (this.points[0].z + this.points[1].z + this.points[2].z) / 3.0, result);
    }
    /** test for point-by-point `isAlmostEqual` relationship. */
    isAlmostEqual(other) {
        return this.points[0].isAlmostEqual(other.points[0])
            && this.points[1].isAlmostEqual(other.points[1])
            && this.points[2].isAlmostEqual(other.points[2]);
    }
}
exports.BarycentricTriangle = BarycentricTriangle;


/***/ }),

/***/ "./lib/geometry3d/BilinearPatch.js":
/*!*****************************************!*\
  !*** ./lib/geometry3d/BilinearPatch.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Solid */
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ./Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ../curve/CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const SurfaceLocationDetail_1 = __webpack_require__(/*! ../bspline/SurfaceLocationDetail */ "./lib/bspline/SurfaceLocationDetail.js");
/**
 * * A Bilinear patch is defined by its 4 corner points.
 * * the corner points do not have to be coplanar
 *
 * *    v direction (up)
 *      |
 *      |
 *      |
 *  point01---A1-----------point11
 *      |     |             |
 *      B0----X------------B1
 *      |     |             |
 *  point00--A0-----------point10 -----------> u direction
 *
 * * To evaluate aa point at (u,v), the following are equivalent:
 *   * interpolate with u to get both A0 and A1, viz
 *      * A0 = interpolate between point00 and point10 at fraction u
 *      * A1 = interpolate between point01 and point11 at fraction u
 *      * X = interpolate between A0 and A1 at fraction v
 *   * interpolate first with v to get B0 and B1, viz
 *      * B0 = interpolate between point00 and point01 at fraction v
 *      * B1 = interpolate between point10 and point11 at fraction v
 *      * X = interpolate between B0 and B1 at fraction u
 *   * sum all at once as
 *      * X = (1-u)* (1-v) *point00 + (1-u)*v * point01 + u * (1-v) *point10 + u* v * point11
 *
 * @internal
 */
class BilinearPatch {
    /**
     * Capture (not clone) corner points, in u direction at v=0, then in same direction at v=1
     * @param point00 Point at uv=0,0
     * @param point10 Point at uv=1,0
     * @param point10 Point at uv=0,1
     * @param point11 Point at uv=11
     */
    constructor(point00, point10, point01, point11) {
        this.point00 = point00;
        this.point10 = point10;
        this.point01 = point01;
        this.point11 = point11;
    }
    /** clone (not capture) corners to create a new BilinearPatch
     * @param point00 Point at uv=0,0
     * @param point10 Point at uv=1,0
     * @param point10 Point at uv=0,1
     * @param point11 Point at uv=11
     */
    static create(point00, point10, point01, point11) {
        return new BilinearPatch(point00.clone(), point10.clone(), point01.clone(), point11.clone());
    }
    /** create a patch with from xyz values of the 4 corners
     */
    static createXYZ(x00, y00, z00, x10, y10, z10, x01, y01, z01, x11, y11, z11) {
        return new BilinearPatch(Point3dVector3d_1.Point3d.create(x00, y00, z00), Point3dVector3d_1.Point3d.create(x10, y10, z10), Point3dVector3d_1.Point3d.create(x01, y01, z01), Point3dVector3d_1.Point3d.create(x11, y11, z11));
    }
    /** return a clone with same coordinates */
    clone() {
        return new BilinearPatch(this.point00.clone(), this.point10.clone(), this.point01.clone(), this.point11.clone());
    }
    /** test equality of the 4 points */
    isAlmostEqual(other) {
        return this.point00.isAlmostEqual(other.point00)
            && this.point10.isAlmostEqual(other.point10)
            && this.point01.isAlmostEqual(other.point01)
            && this.point11.isAlmostEqual(other.point11);
    }
    /** Apply the transform to each point */
    tryTransformInPlace(transform) {
        transform.multiplyPoint3d(this.point00, this.point00);
        transform.multiplyPoint3d(this.point10, this.point10);
        transform.multiplyPoint3d(this.point01, this.point01);
        transform.multiplyPoint3d(this.point11, this.point11);
        return true;
    }
    /**
     * return a cloned and transformed patch.
     * @param transform
     */
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    /** Extend a range by the range of the(optionally transformed) patch
     */
    extendRange(range, transform) {
        if (transform) {
            range.extendTransformedPoint(transform, this.point00);
            range.extendTransformedPoint(transform, this.point10);
            range.extendTransformedPoint(transform, this.point01);
            range.extendTransformedPoint(transform, this.point11);
        }
        else {
            range.extendPoint(this.point00);
            range.extendPoint(this.point10);
            range.extendPoint(this.point01);
            range.extendPoint(this.point11);
        }
    }
    /** Evaluate as a uv surface
     * @param u fractional position in minor (phi)
     * @param v fractional position on major (theta) arc
     */
    uvFractionToPoint(u, v, result) {
        const f00 = (1.0 - u) * (1.0 - v);
        const f10 = u * (1.0 - v);
        const f01 = (1.0 - u) * v;
        const f11 = u * v;
        return Point3dVector3d_1.Point3d.create(f00 * this.point00.x + f10 * this.point10.x + f01 * this.point01.x + f11 * this.point11.x, f00 * this.point00.y + f10 * this.point10.y + f01 * this.point01.y + f11 * this.point11.y, f00 * this.point00.z + f10 * this.point10.z + f01 * this.point01.z + f11 * this.point11.z, result);
    }
    /** Evaluate as a uv surface, returning point and two derivative vectors.
     * @param u fractional position
     * @param v fractional position
     */
    uvFractionToPointAndTangents(u, v, result) {
        const u0 = 1.0 - u;
        const v0 = 1.0 - v;
        const f00 = u0 * v0;
        const f10 = u * v0;
        const f01 = u0 * v;
        const f11 = u * v;
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(f00 * this.point00.x + f10 * this.point10.x + f01 * this.point01.x + f11 * this.point11.x, f00 * this.point00.y + f10 * this.point10.y + f01 * this.point01.y + f11 * this.point11.y, f00 * this.point00.z + f10 * this.point10.z + f01 * this.point01.z + f11 * this.point11.z, 
        // u derivative ..
        v0 * (this.point10.x - this.point00.x) + v * (this.point11.x - this.point01.x), v0 * (this.point10.y - this.point00.y) + v * (this.point11.y - this.point01.y), v0 * (this.point10.z - this.point00.z) + v * (this.point11.z - this.point01.z), 
        // v derivative ..
        u0 * (this.point01.x - this.point00.x) + u * (this.point11.x - this.point10.x), u0 * (this.point01.y - this.point00.y) + u * (this.point11.y - this.point10.y), u0 * (this.point01.z - this.point00.z) + u * (this.point11.z - this.point10.z), result);
    }
    /** if data[ib][pivotColumn] is larger (abs) than data[ia][pivotColumn] swap the iA and iB arrays */
    static conditionalPivot(pivotColumn, data, iA, iB) {
        if (Math.abs(data[iB][pivotColumn]) > Math.abs(data[iA][pivotColumn])) {
            const q = data[iA];
            data[iA] = data[iB];
            data[iB] = q;
        }
    }
    /**
     * Compute the (points of) intersection with a ray.
     * @param ray ray in space
     * @returns 1 or 2 points if there are intersections, undefined if no intersections
     */
    intersectRay(ray) {
        const vectorU = this.point10.minus(this.point00);
        const vectorV = this.point01.minus(this.point00);
        const vectorW = this.point11.minus(this.point10);
        vectorW.subtractInPlace(vectorV);
        // coefficients of (each component of)
        //    `ray.origin + t * ray.direction = point00 + u * vectorU + v * vectorV + u*v*vectorW`
        // for x as typical direction as x, the scalar equation with coefficient order for arrays is
        //    `0 = -ray.origin.x * t + (point00.x - ray.origin.x) + u * vectorU.x + v * vectorV.x + u * v * vectorW.x`
        // (and that particular equation is invoked to isolate t when uv is known)
        const coffs = [
            new Float64Array([-ray.direction.x, this.point00.x - ray.origin.x, vectorU.x, vectorV.x, vectorW.x]),
            new Float64Array([-ray.direction.y, this.point00.y - ray.origin.y, vectorU.y, vectorV.y, vectorW.y]),
            new Float64Array([-ray.direction.z, this.point00.z - ray.origin.z, vectorU.z, vectorV.z, vectorW.z])
        ];
        // bring the largest ray.direction coefficient to the 0 equation.
        BilinearPatch.conditionalPivot(0, coffs, 0, 1);
        BilinearPatch.conditionalPivot(0, coffs, 0, 2);
        Polynomials_1.SmallSystem.eliminateFromPivot(coffs[0], 0, coffs[1], -1.0);
        Polynomials_1.SmallSystem.eliminateFromPivot(coffs[0], 0, coffs[2], -1.0);
        const uvArray = Polynomials_1.SmallSystem.solveBilinearPair(coffs[1][1], coffs[1][2], coffs[1][3], coffs[1][4], coffs[2][1], coffs[2][2], coffs[2][3], coffs[2][4]);
        if (uvArray) {
            const result = [];
            for (const uv of uvArray) {
                const t = -(coffs[0][1] + coffs[0][2] * uv.x + (coffs[0][3] + coffs[0][4] * uv.x) * uv.y) / coffs[0][0];
                const point = ray.fractionToPoint(t);
                result.push(new SurfaceLocationDetail_1.CurveAndSurfaceLocationDetail(CurveLocationDetail_1.CurveLocationDetail.createRayFractionPoint(ray, t, point), SurfaceLocationDetail_1.UVSurfaceLocationDetail.createSurfaceUVPoint(this, uv, point)));
            }
            return result;
        }
        return undefined;
    }
    /**
     * Returns the larger of the u-direction edge lengths at v=0 and v=1
     */
    maxUEdgeLength() {
        return Geometry_1.Geometry.maxXY(this.point00.distance(this.point10), this.point01.distance(this.point11));
    }
    /**
     * Returns the larger of the v-direction edge lengths at u=0 and u=1
     */
    maxVEdgeLength() {
        return Geometry_1.Geometry.maxXY(this.point00.distance(this.point01), this.point10.distance(this.point11));
    }
}
exports.BilinearPatch = BilinearPatch;


/***/ }),

/***/ "./lib/geometry3d/FrameBuilder.js":
/*!****************************************!*\
  !*** ./lib/geometry3d/FrameBuilder.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const BSplineCurve_1 = __webpack_require__(/*! ../bspline/BSplineCurve */ "./lib/bspline/BSplineCurve.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const LineSegment3d_1 = __webpack_require__(/*! ../curve/LineSegment3d */ "./lib/curve/LineSegment3d.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const PointHelpers_1 = __webpack_require__(/*! ./PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const PolygonOps_1 = __webpack_require__(/*! ./PolygonOps */ "./lib/geometry3d/PolygonOps.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ./GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
/**
 * Helper class to accumulate points and vectors until there is enough data to define a coordinate system.
 *
 * * For the common case of building a right handed frame:
 *   * create the FrameBuilder and make calls to announcePoint and announceVector.
 *   * the frame will be fully determined by an origin and two vectors.
 *   * the first call to announcePoint will set the origin.
 *   *  additional calls to announcePoint will produce announceVector call with the vector from the origin.
 *   * After each announcement, call getValidatedFrame(false)
 *   * getValidatedFrame will succeed when it has two independent vectors.
 * *  to build a left handed frame,
 *   *  an origin and 3 independent vectors are required.
 *   *  announce as above, but query with getValidatedFrame (true).
 *   *  this will use the third vector to select right or left handed frame.
 * @public
 */
class FrameBuilder {
    constructor() { this.clear(); }
    // test if both vectors are defined and have significant angle between.
    areStronglyIndependentVectors(vector0, vector1, radiansTolerance = Geometry_1.Geometry.smallAngleRadians) {
        if (vector0 !== undefined && vector1 !== undefined) {
            const q = vector0.smallerUnorientedRadiansTo(vector1);
            return q > radiansTolerance;
        }
        return false;
    }
    /** clear all accumulated point and vector data */
    clear() { this._origin = undefined; this._vector0 = undefined; this._vector1 = undefined; this._vector2 = undefined; }
    /** Try to assemble the data into a non-singular transform.
     *
     * * If allowLeftHanded is false, vector0 and vector1 determine a right handed coordinate system.
     * * if allowLeftHanded is true, the z vector of the right handed system can be flipped to agree with vector2 direction.
     */
    getValidatedFrame(allowLeftHanded = false) {
        if (this._origin && this._vector0 && this._vector1) {
            if (!allowLeftHanded) {
                const matrix = Matrix3d_1.Matrix3d.createRigidFromColumns(this._vector0, this._vector1, Geometry_1.AxisOrder.XYZ);
                if (matrix)
                    return Transform_1.Transform.createOriginAndMatrix(this._origin, matrix);
                // uh oh -- vector1 was not really independent.  clear everything after vector0.
                this._vector1 = this._vector2 = undefined;
            }
            else if (this._vector2) {
                const matrix = Matrix3d_1.Matrix3d.createRigidFromColumns(this._vector0, this._vector1, Geometry_1.AxisOrder.XYZ);
                if (matrix) {
                    if (this._vector0.tripleProduct(this._vector1, this._vector2) < 0)
                        matrix.scaleColumns(1.0, 1.0, -1.0);
                    return Transform_1.Transform.createOriginAndMatrix(this._origin, matrix);
                }
                // uh oh again -- clear vector1 and vector2, re-announce vector2 as possible vector1??
                const vector2 = this._vector2;
                this._vector1 = this._vector2 = undefined;
                this.announceVector(vector2);
            }
        }
        return undefined;
    }
    /**If vector0 is known but vector1 is not, make vector1 the cross of the up-vector and vector0 */
    applyDefaultUpVector(vector) {
        if (vector && this._vector0 && !this._vector1 && !vector.isParallelTo(this._vector0)) {
            this._vector1 = vector.crossProduct(this._vector0);
        }
    }
    /** Ask if there is a defined origin for the evolving frame */
    get hasOrigin() { return this._origin !== undefined; }
    /** Return the number of vectors saved.   Because the save process checks numerics, this should be the rank of the system.
     */
    savedVectorCount() {
        if (!this._vector0)
            return 0;
        if (!this._vector1)
            return 1;
        if (!this._vector2)
            return 2;
        return 3;
    }
    /** announce a new point.  If this point is different from the origin, also compute and announce the vector from the origin.*/
    announcePoint(point) {
        if (!this._origin) {
            this._origin = point.clone();
            return this.savedVectorCount();
        }
        // the new point may provide an additional vector
        if (this._origin.isAlmostEqual(point))
            return this.savedVectorCount();
        return this.announceVector(this._origin.vectorTo(point));
    }
    /** announce a new vector. */
    announceVector(vector) {
        if (vector.isAlmostZero)
            return this.savedVectorCount();
        if (!this._vector0) {
            this._vector0 = vector.clone(this._vector0);
            return 1;
        }
        if (!this._vector1) {
            if (this.areStronglyIndependentVectors(vector, this._vector0, 1.0e-5)) {
                this._vector1 = vector.clone(this._vector1);
                return 2;
            }
            return 1;
        }
        // vector0 and vector1 are independent.
        if (!this._vector2) {
            const unitPerpendicular = this._vector0.unitCrossProduct(this._vector1);
            if (unitPerpendicular && !Geometry_1.Geometry.isSameCoordinate(0, unitPerpendicular.dotProduct(vector))) {
                this._vector2 = vector.clone(this._vector2);
                return 3;
            }
            return 2;
        }
        // fall through if prior vectors are all there -- no need for the new one.
        return 3;
    }
    /** Inspect the content of the data.  Announce points and vectors.   Return when savedVectorCount becomes
     * sufficient for a coordinate system.
     */
    announce(data) {
        if (this.savedVectorCount() > 1)
            return;
        if (data instanceof Point3dVector3d_1.Point3d)
            this.announcePoint(data);
        else if (data instanceof Point3dVector3d_1.Vector3d)
            this.announceVector(data);
        else if (Array.isArray(data)) {
            for (const child of data) {
                if (this.savedVectorCount() > 1)
                    break;
                this.announce(child);
            }
        }
        else if (data instanceof CurvePrimitive_1.CurvePrimitive) {
            if (data instanceof LineSegment3d_1.LineSegment3d) {
                this.announcePoint(data.startPoint());
                this.announcePoint(data.endPoint());
            }
            else if (data instanceof Arc3d_1.Arc3d) {
                const ray = data.fractionToPointAndDerivative(0.0);
                this.announcePoint(ray.origin);
                this.announceVector(ray.direction);
                this.announceVector(data.matrix.columnZCrossVector(ray.direction));
            }
            else if (data instanceof LineString3d_1.LineString3d) {
                for (const point of data.points) {
                    this.announcePoint(point);
                    if (this.savedVectorCount() > 1)
                        break;
                }
            }
            else if (data instanceof BSplineCurve_1.BSplineCurve3d) {
                const point = Point3dVector3d_1.Point3d.create();
                for (let i = 0; this.savedVectorCount() < 2; i++) {
                    if (data.getPolePoint3d(i, point) instanceof Point3dVector3d_1.Point3d)
                        this.announcePoint(point);
                    else
                        break;
                }
            }
            // TODO: unknown curve type.  Stroke? FrenetFrame?
        }
        else if (data instanceof CurveCollection_1.CurveCollection) {
            if (data.children)
                for (const child of data.children) {
                    this.announce(child);
                    if (this.savedVectorCount() > 1)
                        break;
                }
        }
        else if (data instanceof GrowableXYZArray_1.GrowableXYZArray) {
            const point = Point3dVector3d_1.Point3d.create();
            for (let i = 0; this.savedVectorCount() < 2; i++) {
                if (data.getPoint3dAtCheckedPointIndex(i, point) instanceof Point3dVector3d_1.Point3d)
                    this.announcePoint(point);
                else
                    break;
            }
        }
    }
    /** create a localToWorld frame for the given data.
     *
     * *  origin is at first point
     * *  x axis in direction of first nonzero vector present or implied by the input.
     * *  y axis is perpendicular to x and contains (in positive side) the next vector present or implied by the input.
     */
    static createRightHandedFrame(defaultUpVector, ...params) {
        const builder = new FrameBuilder();
        for (const data of params) {
            builder.announce(data);
            builder.applyDefaultUpVector(defaultUpVector);
            const result = builder.getValidatedFrame(false);
            if (result !== undefined) {
                if (defaultUpVector) {
                    if (result.matrix.dotColumnZ(defaultUpVector) < 0.0)
                        result.matrix.scaleColumnsInPlace(1, -1, -1);
                }
                return result;
            }
        }
        // try direct evaluation of curve primitives?
        for (const data of params) {
            if (data instanceof CurveCollection_1.CurveCollection) {
                const children = data.children;
                if (children) {
                    for (const curve of children) {
                        if (curve instanceof CurvePrimitive_1.CurvePrimitive) {
                            const frenetFrame = curve.fractionToFrenetFrame(0.0);
                            if (frenetFrame)
                                return frenetFrame;
                        }
                    }
                }
            }
        }
        return undefined;
    }
    /** create a transform containing points or vectors in the given data.
     * * The xy columns of the transform contain the first points or vectors of the data.
     * * The z column is perpendicular to that xy plane.
     * * The calculation favors the first points found.  It does not try to get a "best" plane.
     */
    static createRightHandedLocalToWorld(...params) {
        const builder = new FrameBuilder();
        for (const data of params) {
            builder.announce(data);
            const localToWorld = builder.getValidatedFrame(false);
            if (localToWorld !== undefined)
                return localToWorld;
        }
        return undefined;
    }
    /**
     * try to create a frame whose xy plane is through points.
     *
     * *  if 3 or more distinct points are present, the x axis is from the first point to the most distance, and y direction is toward the
     * point most distant from that line.
     * @param points array of points
     */
    static createFrameToDistantPoints(points) {
        if (points.length > 2) {
            const origin = points[0].clone();
            const vector01 = Point3dVector3d_1.Vector3d.create();
            PointHelpers_1.Point3dArray.indexOfMostDistantPoint(points, points[0], vector01);
            const vector02 = Point3dVector3d_1.Vector3d.create();
            PointHelpers_1.Point3dArray.indexOfPointWithMaxCrossProductMagnitude(points, origin, vector01, vector02);
            const matrix = Matrix3d_1.Matrix3d.createRigidFromColumns(vector01, vector02, Geometry_1.AxisOrder.XYZ);
            if (matrix)
                return Transform_1.Transform.createRefs(origin, matrix);
        }
        return undefined;
    }
    /**
     * try to create a frame whose xy plane is through points, with the points appearing CCW in the local frame.
     *
     * *  if 3 or more distinct points are present, the x axis is from the first point to the most distance, and y direction is toward the
     * point most distant from that line.
     * @param points array of points
     */
    static createFrameWithCCWPolygon(points) {
        if (points.length > 2) {
            const ray = PolygonOps_1.PolygonOps.centroidAreaNormal(points);
            if (ray) {
                return ray.toRigidZFrame();
            }
        }
        return undefined;
    }
    /**
     * Create the localToWorld transform from a range to axes of its parent coordinate system.
     * @param range [in] range to inspect
     * @param fractionX  [in] fractional coordinate of frame origin x
     * @param fractionY [in] fractional coordinate of frame origin y
     * @param fractionZ [in] fractional coordinate of frame origin z
     * @param scaleSelect [in] selects size of localToWorld axes.
     * @param defaultAxisLength [in] if true and any axis length is 0, that axis vector takes this physical length.
     */
    static createLocalToWorldTransformInRange(range, scaleSelect = Geometry_1.AxisScaleSelect.NonUniformRangeContainment, fractionX = 0, fractionY = 0, fractionZ = 0, defaultAxisLength = 1.0) {
        if (range.isNull)
            return Transform_1.Transform.createIdentity();
        let a = 1.0;
        let b = 1.0;
        let c = 1.0;
        if (scaleSelect === Geometry_1.AxisScaleSelect.LongestRangeDirection) {
            a = b = c = Geometry_1.Geometry.correctSmallMetricDistance(range.maxLength(), defaultAxisLength);
        }
        else if (scaleSelect === Geometry_1.AxisScaleSelect.NonUniformRangeContainment) {
            a = Geometry_1.Geometry.correctSmallMetricDistance(range.xLength(), defaultAxisLength) * Geometry_1.Geometry.maxAbsDiff(fractionX, 0, 1);
            b = Geometry_1.Geometry.correctSmallMetricDistance(range.yLength(), defaultAxisLength) * Geometry_1.Geometry.maxAbsDiff(fractionY, 0, 1);
            c = Geometry_1.Geometry.correctSmallMetricDistance(range.zLength(), defaultAxisLength) * Geometry_1.Geometry.maxAbsDiff(fractionZ, 0, 1);
        }
        return Transform_1.Transform.createRefs(range.fractionToPoint(fractionX, fractionY, fractionZ), Matrix3d_1.Matrix3d.createScale(a, b, c));
    }
}
exports.FrameBuilder = FrameBuilder;


/***/ }),

/***/ "./lib/geometry3d/FrustumAnimation.js":
/*!********************************************!*\
  !*** ./lib/geometry3d/FrustumAnimation.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Solid */
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
const PointHelpers_1 = __webpack_require__(/*! ./PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * context for constructing smooth motion a startFrustum and endFrustum.
 * The externally interesting calls are
 * * Create a context to shift corner0 to corner1, with the(NPC coordinate) point(fractionU, fractionV, fractionW) moving along its connecting segment, all other points rotating smoothly from the start orientation to end orientation:
 * `const context = SmoothTransformBetweenFrusta (cornerA, cornerB)`
 *  * Get any intermediate 8 corners(at fraction) with `context.fractionToWorldCorners(fraction)`
 * * Frustum corners are ordered by "x varies fastest, then y, then z", hence (xyz) order on nondimensional space is
 *   * (left lower rear) (000)
 *   * (right lower rear) (100)
 *   * (left upper rear) (010)
 *   * (right upper rear) (100)
 *   * (left lower front) (001)
 *   * (right lower front) (101)
 *   * (left upper front) (011)
 *   * (right upper front) (101)
 * * which uses names
 *    * (left,right) for horizontal (x)
 *    * (bottom, top) for vertical (y)
 *    * (rear, front) for back and front planes (z)
 * @public
 */
class SmoothTransformBetweenFrusta {
    /**
     * CAPTURE local corners, pickup and putdown frames, and rotation-around-vector data
     * @param localCornerA
     * @param localCornerB
     * @param localToWordA
     * @param localToWordB
     * @param rotationAxis
     * @param rotationAngle
     */
    constructor(localToWorldA, localCornerA, localToWorldB, localCornerB, rotationAxis, rotationAngle) {
        this._localCornerA = localCornerA;
        this._localCornerB = localCornerB;
        this._localToWorldA = localToWorldA;
        this._localToWorldB = localToWorldB;
        this._rotationAxis = rotationAxis;
        this._rotationAngle = rotationAngle;
    }
    /** (property accessor) rigid frame at start of motion */
    get localToWorldA() { return this._localToWorldA; }
    /** (property accessor) rigid frame at end of motion */
    get localToWorldB() { return this._localToWorldB; }
    /**
     * Set up rotation data for smooth transition from 8 point frusta cornerA and cornerB
     * @param cornerA
     * @param cornerB
     */
    static create(cornerA, cornerB, preferSimpleRotation = true) {
        const localToWorldA = PointHelpers_1.Point3dArray.evaluateTrilinearDerivativeTransform(cornerA, 0.5, 0.5, 0.5);
        const localToWorldB = PointHelpers_1.Point3dArray.evaluateTrilinearDerivativeTransform(cornerB, 0.5, 0.5, 0.5);
        const rigidA = Transform_1.Transform.createOriginAndMatrix(localToWorldA.origin, Matrix3d_1.Matrix3d.createRigidFromMatrix3d(localToWorldA.matrix, Geometry_1.AxisOrder.ZXY));
        const rigidB = Transform_1.Transform.createOriginAndMatrix(localToWorldB.origin, Matrix3d_1.Matrix3d.createRigidFromMatrix3d(localToWorldB.matrix, Geometry_1.AxisOrder.ZXY));
        if (rigidA.matrix.computeCachedInverse(true) && rigidB.matrix.computeCachedInverse(true)) {
            const spinMatrix = rigidB.matrix.multiplyMatrixMatrixInverse(rigidA.matrix);
            const spinAxis = spinMatrix.getAxisAndAngleOfRotation();
            const localCornerA = rigidA.multiplyInversePoint3dArray(cornerA);
            const localCornerB = rigidB.multiplyInversePoint3dArray(cornerB);
            /** Is this a pure rotation -- i.e. no clip volume resizing for camera or clip changes */
            if (preferSimpleRotation && PointHelpers_1.Point3dArray.isAlmostEqual(localCornerA, localCornerB) && !spinAxis.angle.isAlmostZero) {
                // world vectors
                const worldOriginShift = Point3dVector3d_1.Vector3d.createStartEnd(localToWorldA.origin, localToWorldB.origin);
                const chordMidPoint = localToWorldA.getOrigin().interpolate(0.5, localToWorldB.getOrigin());
                const bisector = spinAxis.axis.unitCrossProduct(worldOriginShift);
                if (bisector) {
                    const halfChordLength = 0.5 * worldOriginShift.magnitude();
                    const alpha = Geometry_1.Geometry.conditionalDivideFraction(halfChordLength, Math.tan(spinAxis.angle.radians * 0.5));
                    if (alpha !== undefined) {
                        const spinCenter = chordMidPoint.plusScaled(bisector, alpha);
                        const rigidA1 = Transform_1.Transform.createOriginAndMatrix(spinCenter, rigidA.matrix);
                        const rigidB1 = Transform_1.Transform.createOriginAndMatrix(spinCenter, rigidB.matrix);
                        const localCornerA1 = rigidA1.multiplyInversePoint3dArray(cornerA);
                        const localCornerB1 = rigidB1.multiplyInversePoint3dArray(cornerB);
                        return new SmoothTransformBetweenFrusta(rigidA1, localCornerA1, rigidB1, localCornerB1, spinAxis.axis, spinAxis.angle);
                    }
                }
            }
            return new SmoothTransformBetweenFrusta(rigidA, localCornerA, rigidB, localCornerB, spinAxis.axis, spinAxis.angle);
        }
        return undefined;
    }
    /** interpolate local corner coordinates at fractional move from m_localFrustum0 to m_localFrustum1 */
    interpolateLocalCorners(fraction, result) {
        result = result || [];
        result.length = 0;
        const n = this._localCornerA.length;
        for (let i = 0; i < n; i++) {
            result.push(this._localCornerA[i].interpolate(fraction, this._localCornerB[i]));
        }
        return result;
    }
    /**
     * After initialization, call this for various intermediate fractions.
     * The returned corner points are in world coordinates "between" start and end positions.
     */
    fractionToWorldCorners(fraction, result) {
        const corners = this.interpolateLocalCorners(fraction, result);
        const fractionalRotation = Matrix3d_1.Matrix3d.createRotationAroundVector(this._rotationAxis, this._rotationAngle.cloneScaled(fraction));
        const axes0 = this._localToWorldA.matrix;
        const fractionalAxes = fractionalRotation.multiplyMatrixMatrix(axes0);
        const fractionalOrigin = this._localToWorldA.getOrigin().interpolate(fraction, this._localToWorldB.origin);
        const putdownFrame = Transform_1.Transform.createOriginAndMatrix(fractionalOrigin, fractionalAxes);
        putdownFrame.multiplyPoint3dArray(corners, corners);
        return corners;
    }
}
exports.SmoothTransformBetweenFrusta = SmoothTransformBetweenFrusta;


/***/ }),

/***/ "./lib/geometry3d/GeometryHandler.js":
/*!*******************************************!*\
  !*** ./lib/geometry3d/GeometryHandler.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * * `GeometryHandler` defines the base abstract methods for double-dispatch geometry computation.
 * * User code that wants to handle one or all of the commonly known geometry types implements a handler class.
 * * User code that does not handle all types is most likely to start with `NullGeometryHandler`, which will provide no-action implementations for all types.
 * @public
 */
class GeometryHandler {
    /** handle strongly typed  CurveCollection  */
    handleCurveCollection(_g) { }
    /** handle strongly typed Path (base class method calls handleCurveCollection) */
    handlePath(g) { return this.handleCurveCollection(g); }
    /** handle strongly typed  Loop (base class method calls handleCurveCollection) */
    handleLoop(g) { return this.handleCurveCollection(g); }
    /** handle strongly typed  ParityRegion (base class method calls handleCurveCollection) */
    handleParityRegion(g) { return this.handleCurveCollection(g); }
    /** handle strongly typed  UnionRegion (base class method calls handleCurveCollection) */
    handleUnionRegion(g) { return this.handleCurveCollection(g); }
    /** handle strongly typed  BagOfCurves (base class method calls handleCurveCollection) */
    handleBagOfCurves(g) { return this.handleCurveCollection(g); }
}
exports.GeometryHandler = GeometryHandler;
/**
 * `NullGeometryHandler` is a base class for dispatching various geometry types to
 * application specific implementation of some service.
 *
 * To use:
 * * Derive a class from `NullGeometryHandler`
 * * Reimplement any or all of the specific `handleXXXX` methods
 * * Create a handler instance `myHandler`
 * * To send a `GeometryQuery` object `candidateGeometry` through the (fast) dispatch, invoke   `candidateGeometry.dispatchToHandler (myHandler)
 * * The appropriate method or methods will get called with a strongly typed `_g ` value.
 * @public
 */
class NullGeometryHandler extends GeometryHandler {
    /** no-action implementation */
    handleLineSegment3d(_g) { return undefined; }
    /** no-action implementation */
    handleLineString3d(_g) { return undefined; }
    /** no-action implementation */
    handleArc3d(_g) { return undefined; }
    /** no-action implementation */
    handleCurveCollection(_g) { return undefined; }
    /** no-action implementation */
    handleBSplineCurve3d(_g) { return undefined; }
    /** no-action implementation */
    handleBSplineCurve3dH(_g) { return undefined; }
    /** no-action implementation */
    handleBSplineSurface3d(_g) { return undefined; }
    /** no-action implementation */
    handleCoordinateXYZ(_g) { return undefined; }
    /** no-action implementation */
    handleBSplineSurface3dH(_g) { return undefined; }
    /** no-action implementation */
    handleIndexedPolyface(_g) { return undefined; }
    /** no-action implementation
     * @alpha
     */
    handleTransitionSpiral(_g) { return undefined; }
    /** no-action implementation */
    handlePath(_g) { return undefined; }
    /** no-action implementation */
    handleLoop(_g) { return undefined; }
    /** no-action implementation */
    handleParityRegion(_g) { return undefined; }
    /** no-action implementation */
    handleUnionRegion(_g) { return undefined; }
    /** no-action implementation */
    handleBagOfCurves(_g) { return undefined; }
    /** no-action implementation */
    handleSphere(_g) { return undefined; }
    /** no-action implementation */
    handleCone(_g) { return undefined; }
    /** no-action implementation */
    handleBox(_g) { return undefined; }
    /** no-action implementation */
    handleTorusPipe(_g) { return undefined; }
    /** no-action implementation */
    handleLinearSweep(_g) { return undefined; }
    /** no-action implementation */
    handleRotationalSweep(_g) { return undefined; }
    /** no-action implementation */
    handleRuledSweep(_g) { return undefined; }
    /** no-action implementation */
    handlePointString3d(_g) { return undefined; }
    /** no-action implementation */
    handleBezierCurve3d(_g) { return undefined; }
    /** no-action implementation */
    handleBezierCurve3dH(_g) { return undefined; }
}
exports.NullGeometryHandler = NullGeometryHandler;
/**
 * Implement GeometryHandler methods, with all curve collection methods recursing to children.
 * @public
 */
class RecurseToCurvesGeometryHandler extends GeometryHandler {
    /** no-action implementation */
    handleLineSegment3d(_g) { return undefined; }
    /** no-action implementation */
    handleLineString3d(_g) { return undefined; }
    /** no-action implementation */
    handleArc3d(_g) { return undefined; }
    /** no-action implementation */
    handleBSplineCurve3d(_g) { return undefined; }
    /** no-action implementation */
    handleBSplineCurve3dH(_g) { return undefined; }
    /** no-action implementation */
    handleBSplineSurface3d(_g) { return undefined; }
    /** no-action implementation */
    handleCoordinateXYZ(_g) { return undefined; }
    /** no-action implementation */
    handleBSplineSurface3dH(_g) { return undefined; }
    /** no-action implementation */
    handleIndexedPolyface(_g) { return undefined; }
    /** no-action implementation
     * @alpha
     */
    handleTransitionSpiral(_g) { return undefined; }
    /** Invoke `child.dispatchToGeometryHandler(this)` for each child in the array returned by the query `g.children` */
    handleChildren(g) {
        const children = g.children;
        if (children)
            for (const child of children) {
                child.dispatchToGeometryHandler(this);
            }
    }
    /** Recurse to children */
    handleCurveCollection(g) { return this.handleChildren(g); }
    /** Recurse to children */
    handlePath(g) { return this.handleChildren(g); }
    /** Recurse to children */
    handleLoop(g) { return this.handleChildren(g); }
    /** Recurse to children */
    handleParityRegion(g) { return this.handleChildren(g); }
    /** Recurse to children */
    handleUnionRegion(g) { return this.handleChildren(g); }
    /** Recurse to children */
    handleBagOfCurves(g) { return this.handleChildren(g); }
    /** no-action implementation */
    handleSphere(_g) { return undefined; }
    /** no-action implementation */
    handleCone(_g) { return undefined; }
    /** no-action implementation */
    handleBox(_g) { return undefined; }
    /** no-action implementation */
    handleTorusPipe(_g) { return undefined; }
    /** no-action implementation */
    handleLinearSweep(_g) { return undefined; }
    /** no-action implementation */
    handleRotationalSweep(_g) { return undefined; }
    /** no-action implementation */
    handleRuledSweep(_g) { return undefined; }
    /** no-action implementation */
    handlePointString3d(_g) { return undefined; }
    /** no-action implementation */
    handleBezierCurve3d(_g) { return undefined; }
    /** no-action implementation */
    handleBezierCurve3dH(_g) { return undefined; }
}
exports.RecurseToCurvesGeometryHandler = RecurseToCurvesGeometryHandler;


/***/ }),

/***/ "./lib/geometry3d/GrowableBlockedArray.js":
/*!************************************************!*\
  !*** ./lib/geometry3d/GrowableBlockedArray.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @module ArraysAndInterfaces */
/**
 * Array of contiguous doubles, indexed by block number and index within block.
 * * This is essentially a rectangular matrix (two dimensional array), with each block being a row of the matrix.
 * @public
 */
class GrowableBlockedArray {
    constructor(blockSize, initialBlocks = 8) {
        /** array contents in blocked (row-major) order, possibly with extra capacity
         * Total capacity is `this._data.length`
         * Actual in-use count is `this._inUse * this._blockSize`
         */
        this._data = new Float64Array(initialBlocks * blockSize);
        this._inUse = 0;
        this._blockSize = blockSize;
    }
    /** computed property: length (in blocks, not doubles) */
    get numBlocks() { return this._inUse; }
    /** property: number of data values per block */
    get numPerBlock() { return this._blockSize; }
    /**
     * Return a single value indexed within a block
     * @param blockIndex index of block to read
     * @param indexInBlock  offset within the block
     */
    getWithinBlock(blockIndex, indexWithinBlock) {
        return this._data[blockIndex * this._blockSize + indexWithinBlock];
    }
    /** clear the block count to zero, but maintain the allocated memory */
    clear() { this._inUse = 0; }
    /** Return the capacity in blocks (not doubles) */
    blockCapacity() {
        return this._data.length / this._blockSize;
    }
    /** ensure capacity (in blocks, not doubles) */
    ensureBlockCapacity(blockCapacity) {
        if (blockCapacity > this.blockCapacity()) {
            const newData = new Float64Array(blockCapacity * this._blockSize);
            for (let i = 0; i < this._data.length; i++) {
                newData[i] = this._data[i];
            }
            this._data = newData;
        }
    }
    /** Add a new block of data.
     * * If newData has fewer than numPerBlock entries, the remaining part of the new block is zeros.
     * * If newData has more entries, only the first numPerBlock are taken.
     */
    addBlock(newData) {
        const k0 = this.newBlockIndex();
        let numValue = newData.length;
        if (numValue > this._blockSize)
            numValue = this._blockSize;
        for (let i = 0; i < numValue; i++)
            this._data[k0 + i] = newData[i];
    }
    /**
     * Return the starting index of a block of (zero-initialized) doubles at the end.
     *
     * * this.data is reallocated if needed to include the new block.
     * * The inUse count is incremented to include the new block.
     * * The returned block is an index to the Float64Array (not a block index)
     */
    newBlockIndex() {
        const index = this._blockSize * this._inUse;
        if ((index + 1) > this._data.length)
            this.ensureBlockCapacity(1 + 2 * this._inUse);
        this._inUse++;
        for (let i = index; i < index + this._blockSize; i++)
            this._data[i] = 0.0;
        return index;
    }
    /** reduce the block count by one. */
    popBlock() {
        if (this._inUse > 0)
            this._inUse--;
    }
    /** convert a block index to the simple index to the underlying Float64Array. */
    blockIndexToDoubleIndex(blockIndex) { return this._blockSize * blockIndex; }
    /** Access a single double at offset within a block, with index checking and return undefined if indexing is invalid. */
    checkedComponent(blockIndex, componentIndex) {
        if (blockIndex >= this._inUse || blockIndex < 0 || componentIndex < 0 || componentIndex >= this._blockSize)
            return undefined;
        return this._data[this._blockSize * blockIndex + componentIndex];
    }
    /** Access a single double at offset within a block.  This has no index checking. */
    component(blockIndex, componentIndex) {
        return this._data[this._blockSize * blockIndex + componentIndex];
    }
    /** compare two blocks in simple lexical order.
     * @param data data array
     * @param blockSize number of items to compare
     * @param ia raw index (not block index) of first block
     * @param ib raw index (not block index) of second block
     */
    static compareLexicalBlock(data, blockSize, ia, ib) {
        let ax = 0;
        let bx = 0;
        for (let i = 0; i < blockSize; i++) {
            ax = data[ia + i];
            bx = data[ib + i];
            if (ax > bx)
                return 1;
            if (ax < bx)
                return -1;
        }
        return ia - ib; // so original order is maintained among duplicates !!!!
    }
    /** Return an array of block indices sorted per compareLexicalBlock function */
    sortIndicesLexical(compareBlocks = GrowableBlockedArray.compareLexicalBlock) {
        const n = this._inUse;
        // let numCompare = 0;
        const result = new Uint32Array(n);
        const data = this._data;
        const blockSize = this._blockSize;
        for (let i = 0; i < n; i++)
            result[i] = i;
        result.sort((blockIndexA, blockIndexB) => {
            // numCompare++;
            return compareBlocks(data, blockSize, blockIndexA * blockSize, blockIndexB * blockSize);
        });
        // console.log (n, numCompare);
        return result;
    }
    /** Return the distance (hypotenuse=sqrt(summed squares)) between indicated blocks */
    distanceBetweenBlocks(blockIndexA, blockIndexB) {
        let dd = 0.0;
        let iA = this.blockIndexToDoubleIndex(blockIndexA);
        let iB = this.blockIndexToDoubleIndex(blockIndexB);
        let a = 0;
        const data = this._data;
        for (let i = 0; i < this._blockSize; i++) {
            a = data[iA++] - data[iB++];
            dd += a * a;
        }
        return Math.sqrt(dd);
    }
    /** Return the distance (hypotenuse=sqrt(summed squares)) between block entries `iBegin <= i < iEnd` of indicated blocks */
    distanceBetweenSubBlocks(blockIndexA, blockIndexB, iBegin, iEnd) {
        let dd = 0.0;
        const iA = this.blockIndexToDoubleIndex(blockIndexA);
        const iB = this.blockIndexToDoubleIndex(blockIndexB);
        let a = 0;
        const data = this._data;
        for (let i = iBegin; i < iEnd; i++) {
            a = data[iA + i] - data[iB + i];
            dd += a * a;
        }
        return Math.sqrt(dd);
    }
}
exports.GrowableBlockedArray = GrowableBlockedArray;


/***/ }),

/***/ "./lib/geometry3d/GrowableFloat64Array.js":
/*!************************************************!*\
  !*** ./lib/geometry3d/GrowableFloat64Array.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A `GrowableFloat64Array` is Float64Array accompanied by a count of how many of the array's entries are considered in use.
 * * In C++ terms, this is like an std::vector
 * * As entries are added to the array, the buffer is reallocated as needed to accommodate.
 * * The reallocations leave unused space to accept further additional entries without reallocation.
 * * The `length` property returns the number of entries in use.
 * * the `capacity` property returns the (usually larger) length of the (over-allocated) Float64Array.
 * @public
 */
class GrowableFloat64Array {
    constructor(initialCapacity = 8) {
        this._data = new Float64Array(initialCapacity);
        this._inUse = 0;
    }
    /**
     * Create a GrowableFloat64Array with given contents.
     * @param contents data to copy into the array
     */
    static create(contents) {
        const result = new GrowableFloat64Array(contents.length);
        for (const a of contents) {
            result.push(a);
        }
        return result;
    }
    /** sort-compatible comparison.
     * * Returns `(a-b)` which is
     *   * negative if `a<b`
     *   * zero if `a === b` (with exact equality)
     *   * positive if `a>b`
     */
    static compare(a, b) {
        return a - b;
    }
    /** Return a new array with
     * * All active entries copied from this instance
     * * optionally trimmed capacity to the active length or replicate the capacity and unused space.
     */
    clone(maintainExcessCapacity = false) {
        const n = this._inUse;
        const data = this._data;
        const out = new GrowableFloat64Array(maintainExcessCapacity ? this.capacity() : n);
        for (let i = 0; i < n; i++)
            out.push(data[i]);
        return out;
    }
    /**
     * Returns the number of entries in use.
     * * Note that this is typically smaller than the length of the length of the supporting `Float64Array`
     */
    get length() {
        return this._inUse;
    }
    /**
     * Set the value at specified index.
     * @param index index of entry to set
     * @param value value to set
     */
    setAtUncheckedIndex(index, value) {
        this._data[index] = value;
    }
    /**
     * Move the value at index i to index j.
     * @param i source index
     * @param j destination index.
     */
    move(i, j) {
        this._data[j] = this._data[i];
    }
    /**
     * swap the values at indices i and j
     * @param i first index
     * @param j second index
     */
    swap(i, j) {
        const a = this._data[i];
        this._data[i] = this._data[j];
        this._data[j] = a;
    }
    /**
     * append a single value to the array.
     * @param toPush value to append to the active array.
     */
    push(toPush) {
        if (this._inUse + 1 <= this._data.length) {
            this._data[this._inUse] = toPush;
            this._inUse++;
        }
        else {
            // Make new array (double size), copy values, then push toPush
            const newData = new Float64Array(4 + this._inUse * 2);
            for (let i = 0; i < this._inUse; i++) {
                newData[i] = this._data[i];
            }
            this._data = newData;
            this._data[this._inUse] = toPush;
            this._inUse++;
        }
    }
    /** Push a `numToCopy` consecutive values starting at `copyFromIndex` to the end of the array. */
    pushBlockCopy(copyFromIndex, numToCopy) {
        const newLength = this._inUse + numToCopy;
        this.ensureCapacity(newLength);
        const limit = copyFromIndex + numToCopy;
        for (let i = copyFromIndex; i < limit; i++)
            this._data[this._inUse++] = this._data[i];
    }
    /** Clear the array to 0 length.  The underlying memory remains allocated for reuse. */
    clear() {
        while (this._inUse > 0)
            this.pop();
    }
    /**
     * Returns the number of entries in the supporting Float64Array buffer.
     * * This number can be larger than the `length` property.
     */
    capacity() {
        return this._data.length;
    }
    /**
     * * If the capacity (Float64Array length) is less than or equal to the requested newCapacity, do nothing
     * * If the requested newCapacity is larger than the existing capacity, reallocate (and copy existing values) with the larger capacity.
     * @param newCapacity
     */
    ensureCapacity(newCapacity) {
        if (newCapacity > this.capacity()) {
            const oldInUse = this._inUse;
            const newData = new Float64Array(newCapacity);
            for (let i = 0; i < oldInUse; i++)
                newData[i] = this._data[i];
            this._data = newData;
        }
    }
    /**
     * * If newLength is less than current (active) length, just set (active) length.
     * * If newLength is greater, ensureCapacity (newSize) and pad with padValue up to newSize;
     * @param newLength new data count
     * @param padValue value to use for padding if the length increases.
     */
    resize(newLength, padValue = 0) {
        // quick out for easy case ...
        if (newLength <= this._inUse) {
            this._inUse = newLength;
            return;
        }
        const oldLength = this._inUse;
        this.ensureCapacity(newLength);
        for (let i = oldLength; i < newLength; i++)
            this._data[i] = padValue;
        this._inUse = newLength;
    }
    /**
     * * Reduce the length by one.
     * * Note that there is no method return value -- use `back` to get that value before `pop()`
     * * (As with std::vector, separating the `pop` from the value access eliminates error testing from `pop` call)
     */
    pop() {
        // Could technically access outside of array, if filled and then reduced using pop (similar to C
        // and accessing out of bounds), but with adjusted inUse counter, that data will eventually be overwritten
        if (this._inUse > 0) {
            this._inUse--;
        }
    }
    /** Access by index, without bounds check */
    atUncheckedIndex(index) {
        return this._data[index];
    }
    /** Access the 0-index member, without bounds check */
    front() {
        return this._data[0];
    }
    /** Access the final member, without bounds check */
    back() {
        return this._data[this._inUse - 1];
    }
    /** set a value by index */
    reassign(index, value) {
        this._data[index] = value;
    }
    /**
     * * Sort the array entries.
     * * Uses insertion sort -- fine for small arrays (less than 30), slow for larger arrays
     * @param compareMethod comparison method
     */
    sort(compareMethod = GrowableFloat64Array.compare) {
        for (let i = 0; i < this._inUse; i++) {
            for (let j = i + 1; j < this._inUse; j++) {
                const tempI = this._data[i];
                const tempJ = this._data[j];
                if (compareMethod(tempI, tempJ) > 0) {
                    this._data[i] = tempJ;
                    this._data[j] = tempI;
                }
            }
        }
    }
    /**
     * * compress out values not within the [a,b] interval.
     * * Note that if a is greater than b all values are rejected.
     * @param a low value for accepted interval
     * @param b high value for accepted interval
     */
    restrictToInterval(a, b) {
        const data = this._data;
        const n = data.length;
        let numAccept = 0;
        let q = 0;
        for (let i = 0; i < n; i++) {
            q = data[i];
            if (q >= a && q <= b)
                data[numAccept++] = q;
        }
        this._inUse = numAccept;
    }
    /**
     * * compress out multiple copies of values.
     * * this is done in the current order of the array.
     */
    compressAdjacentDuplicates(tolerance = 0.0) {
        const data = this._data;
        const n = this._inUse;
        if (n === 0)
            return;
        let numAccepted = 1;
        let a = data[0];
        let b;
        for (let i = 1; i < n; i++) {
            b = data[i];
            if (Math.abs(b - a) > tolerance) {
                data[numAccepted++] = b;
                a = b;
            }
        }
        this._inUse = numAccepted;
    }
}
exports.GrowableFloat64Array = GrowableFloat64Array;


/***/ }),

/***/ "./lib/geometry3d/GrowableXYArray.js":
/*!*******************************************!*\
  !*** ./lib/geometry3d/GrowableXYArray.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module ArraysAndInterfaces */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const IndexedXYCollection_1 = __webpack_require__(/*! ./IndexedXYCollection */ "./lib/geometry3d/IndexedXYCollection.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ./GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const PointStreaming_1 = __webpack_require__(/*! ./PointStreaming */ "./lib/geometry3d/PointStreaming.js");
/** `GrowableXYArray` manages a (possibly growing) Float64Array to pack xy coordinates.
 * @public
 */
class GrowableXYArray extends IndexedXYCollection_1.IndexedXYCollection {
    /** Construct a new GrowablePoint2d array.
     * @param numPoints [in] initial capacity.
     */
    constructor(numPoints = 8) {
        super();
        this._data = new Float64Array(numPoints * 2); // 8 Points to start (2 values each)
        this._xyInUse = 0;
        this._xyzCapacity = numPoints;
    }
    /** Return the number of points in use. */
    get length() { return this._xyInUse; }
    /** Set number of points.
     * Pad zeros if length grows.
     */
    set length(newLength) {
        let oldLength = this.length;
        if (newLength < oldLength) {
            this._xyInUse = newLength;
        }
        else if (newLength > oldLength) {
            this.ensureCapacity(newLength);
            while (oldLength++ < newLength)
                this.pushXY(0, 0);
        }
    }
    /** Return the number of float64 in use. */
    get float64Length() { return this._xyInUse * 2; }
    /** Return the raw packed data.
     * * Note that the length of the returned Float64Array is a count of doubles, and includes the excess capacity
     */
    float64Data() { return this._data; }
    /** If necessary, increase the capacity to a new pointCount.  Current coordinates and point count (length) are unchanged. */
    ensureCapacity(pointCapacity) {
        if (pointCapacity > this._xyzCapacity) {
            const newData = new Float64Array(pointCapacity * 2);
            const numCopy = this.length * 2;
            for (let i = 0; i < numCopy; i++)
                newData[i] = this._data[i];
            this._data = newData;
            this._xyzCapacity = pointCapacity;
        }
    }
    /** Resize the actual point count, preserving excess capacity. */
    resize(pointCount) {
        if (pointCount < this.length) {
            this._xyInUse = pointCount >= 0 ? pointCount : 0;
        }
        else if (pointCount > this._xyzCapacity) {
            const newArray = new Float64Array(pointCount * 2);
            // Copy contents
            for (let i = 0; i < this._data.length; i += 2) {
                newArray[i] = this._data[i];
                newArray[i + 1] = this._data[i + 1];
                newArray[i + 2] = this._data[i + 2];
            }
            this._data = newArray;
            this._xyzCapacity = pointCount;
            this._xyInUse = pointCount;
        }
    }
    /**
     * Make a copy of the (active) points in this array.
     * (The clone does NOT get excess capacity)
     */
    clone() {
        const newPoints = new GrowableXYArray(this.length);
        const numValue = this.length * 2;
        const newData = newPoints._data;
        const data = this._data;
        for (let i = 0; i < numValue; i++)
            newData[i] = data[i];
        newPoints._xyInUse = this.length;
        return newPoints;
    }
    /** Create an array populated from
     * * An array of Point2d
     * * An array of Point3d (hidden as XAndY)
     * * An array of objects with keyed values, et `{x:1, y:1}`
     * * A `GrowableXYZArray`
     */
    static create(data) {
        const newPoints = new GrowableXYArray(data.length);
        if (data instanceof GrowableXYZArray_1.GrowableXYZArray) {
            newPoints.pushAllXYAndZ(data);
        }
        else {
            newPoints.pushAll(data);
        }
        return newPoints;
    }
    /** Restructure MultiLineStringDataVariant as array of GrowableXYZArray */
    static createArrayOfGrowableXYZArray(data) {
        const collector = new PointStreaming_1.PointStreamGrowableXYZArrayCollector();
        PointStreaming_1.VariantPointDataStream.streamXYZ(data, collector);
        return collector.claimArrayOfGrowableXYZArray();
    }
    /** push a point to the end of the array */
    push(toPush) {
        this.pushXY(toPush.x, toPush.y);
    }
    /** push all points of an array */
    pushAll(points) {
        for (const p of points)
            this.push(p);
    }
    /** push all points of an array */
    pushAllXYAndZ(points) {
        if (points instanceof GrowableXYZArray_1.GrowableXYZArray) {
            const xyzBuffer = points.float64Data();
            const n = points.length * 3;
            for (let i = 0; i + 2 < n; i += 3) {
                this.pushXY(xyzBuffer[i], xyzBuffer[i + 1]);
            }
        }
        else {
            for (const p of points)
                this.pushXY(p.x, p.y);
        }
    }
    /**
     * Replicate numWrap xyz values from the front of the array as new values at the end.
     * @param numWrap number of xyz values to replicate
     */
    pushWrap(numWrap) {
        if (this._xyInUse > 0) {
            let k;
            for (let i = 0; i < numWrap; i++) {
                k = 2 * i;
                this.pushXY(this._data[k], this._data[k + 1]);
            }
        }
    }
    /** push a point given by x,y coordinates */
    pushXY(x, y) {
        const index = this._xyInUse * 2;
        if (index >= this._data.length)
            this.ensureCapacity(this.length === 0 ? 4 : this.length * 2);
        this._data[index] = x;
        this._data[index + 1] = y;
        this._xyInUse++;
    }
    /** Remove one point from the back.
     * * NOTE that (in the manner of std::vector native) this is "just" removing the point -- no point is NOT returned.
     * * Use `back ()` to get the last x,y,z assembled into a `Point3d `
     */
    pop() {
        if (this._xyInUse > 0)
            this._xyInUse--;
    }
    /**
     * Test if index is valid for an xyz (point or vector) within this array
     * @param index xyz index to test.
     */
    isIndexValid(index) {
        if (index >= this._xyInUse || index < 0)
            return false;
        return true;
    }
    /**
     * Clear all xyz data, but leave capacity unchanged.
     */
    clear() {
        this._xyInUse = 0;
    }
    /**
     * Get a point by index, strongly typed as a Point2d.  This is unchecked.  Use atPoint2dIndex to have validity test.
     * @param pointIndex index to access
     * @param result optional result
     */
    getPoint2dAtUncheckedPointIndex(pointIndex, result) {
        const index = 2 * pointIndex;
        return Point2dVector2d_1.Point2d.create(this._data[index], this._data[index + 1], result);
    }
    /**
     * Get x coordinate by point index, with no index checking
     * @param pointIndex index to access
     */
    getXAtUncheckedPointIndex(pointIndex) {
        return this._data[2 * pointIndex];
    }
    /**
     * Get y coordinate by index, with no index checking
     * @param pointIndex index to access
     */
    getYAtUncheckedPointIndex(pointIndex) {
        return this._data[2 * pointIndex + 1];
    }
    /**
     * Gather all points as a Point2d[]
     */
    getPoint2dArray() {
        const n = 2 * this._xyInUse;
        const result = [];
        const data = this._data;
        for (let i = 0; i < n; i += 2)
            result.push(Point2dVector2d_1.Point2d.create(data[i], data[i + 1]));
        return result;
    }
    /** copy xyz into strongly typed Point2d */
    getPoint2dAtCheckedPointIndex(pointIndex, result) {
        const index = 2 * pointIndex;
        if (this.isIndexValid(pointIndex)) {
            return Point2dVector2d_1.Point2d.create(this._data[index], this._data[index + 1], result);
        }
        return undefined;
    }
    /** copy xyz into strongly typed Vector2d */
    getVector2dAtCheckedVectorIndex(vectorIndex, result) {
        const index = 2 * vectorIndex;
        if (this.isIndexValid(vectorIndex)) {
            return Point2dVector2d_1.Vector2d.create(this._data[index], this._data[index + 1], result);
        }
        return undefined;
    }
    /**
     * Read coordinates from source array, place them at index within this array.
     * @param destIndex point index where coordinates are to be placed in this array
     * @param source source array
     * @param sourceIndex point index in source array
     * @returns true if destIndex and sourceIndex are both valid.
     */
    transferFromGrowableXYArray(destIndex, source, sourceIndex) {
        if (this.isIndexValid(destIndex) && source.isIndexValid(sourceIndex)) {
            const i = destIndex * 2;
            const j = sourceIndex * 2;
            this._data[i] = source._data[j];
            this._data[i + 1] = source._data[j + 1];
            this._data[i + 2] = source._data[j + 2];
            return true;
        }
        return false;
    }
    /**
     * push coordinates from the source array to the end of this array.
     * @param source source array
     * @param sourceIndex xyz index within the source.  If undefined, push entire contents of source
     * @returns true if sourceIndex is valid.
     */
    pushFromGrowableXYArray(source, sourceIndex) {
        if (sourceIndex === undefined) {
            const numPresent = this.length;
            const numPush = source.length;
            this.ensureCapacity(numPresent + numPush);
            const numFloatPresent = 2 * numPresent;
            const numFloatAdd = 2 * numPush;
            for (let i = 0; i < numFloatAdd; i++)
                this._data[numFloatPresent + i] = source._data[i];
            this._xyInUse += numPush;
            return numPush;
        }
        if (source.isIndexValid(sourceIndex)) {
            const j = sourceIndex * 2;
            this.pushXY(source._data[j], source._data[j + 1]);
            return 1;
        }
        return 0;
    }
    /**
     * * Compute a point at fractional coordinate between points i and j of source
     * * push onto this array.
     */
    pushInterpolatedFromGrowableXYArray(source, i, fraction, j) {
        if (source.isIndexValid(i) && source.isIndexValid(j)) {
            const data = source._data;
            i = 3 * i;
            j = 3 * j;
            this.pushXY(Geometry_1.Geometry.interpolate(data[i], fraction, data[j]), Geometry_1.Geometry.interpolate(data[i + 1], fraction, data[j + 1]));
        }
    }
    /**
     * push coordinates from the source array to the end of this array.
     * @param source source array
     * @param transform optional transform to apply to points.
     * @param dest optional result.
     */
    static createFromGrowableXYZArray(source, transform, dest) {
        const packedXYZ = source.float64Data();
        const numXYZ = source.length; // this is in xyz points
        const nDouble = 3 * numXYZ;
        if (!dest)
            dest = new GrowableXYArray(numXYZ);
        dest.clear();
        let x;
        let y;
        let z;
        if (transform) {
            for (let i = 0; i < nDouble; i += 3) {
                x = packedXYZ[i];
                y = packedXYZ[i + 1];
                z = packedXYZ[i + 2];
                dest.pushXY(transform.multiplyComponentXYZ(0, x, y, z), transform.multiplyComponentXYZ(1, x, y, z));
            }
        }
        else {
            for (let i = 0; i < nDouble; i += 3) {
                x = packedXYZ[i];
                y = packedXYZ[i + 1];
                dest.pushXY(x, y);
            }
        }
        return dest;
    }
    /**
     * Return the first point, or undefined if the array is empty.
     */
    front(result) {
        if (this._xyInUse === 0)
            return undefined;
        return this.getPoint2dAtUncheckedPointIndex(0, result);
    }
    /**
     * Return the last point, or undefined if the array is empty.
     */
    back(result) {
        if (this._xyInUse < 1)
            return undefined;
        return this.getPoint2dAtUncheckedPointIndex(this._xyInUse - 1, result);
    }
    /**
     * Set the coordinates of a single point.
     * @param pointIndex index of point to set
     * @param value coordinates to set
     */
    setAtCheckedPointIndex(pointIndex, value) {
        if (!this.isIndexValid(pointIndex))
            return false;
        const index = pointIndex * 2;
        this._data[index] = value.x;
        this._data[index + 1] = value.y;
        return true;
    }
    /**
     * Set the coordinates of a single point given as coordinates
     * @param pointIndex index of point to set
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     */
    setXYZAtCheckedPointIndex(pointIndex, x, y) {
        if (!this.isIndexValid(pointIndex))
            return false;
        const index = pointIndex * 2;
        this._data[index] = x;
        this._data[index + 1] = y;
        return true;
    }
    /**
     * Copy all points into a simple array of Point3D with given z.
     */
    getPoint3dArray(z = 0) {
        const result = [];
        const data = this._data;
        const n = this.length;
        for (let i = 0; i < n; i++) {
            result.push(Point3dVector3d_1.Point3d.create(data[i * 2], data[i * 2 + 1], z));
        }
        return result;
    }
    /** multiply each point by the transform, replace values. */
    multiplyTransformInPlace(transform) {
        const data = this._data;
        const nDouble = this.float64Length;
        const coffs = transform.matrix.coffs;
        const origin = transform.origin;
        const x0 = origin.x;
        const y0 = origin.y;
        let x = 0;
        let y = 0;
        for (let i = 0; i + 2 <= nDouble; i += 2) {
            x = data[i];
            y = data[i + 1];
            data[i] = coffs[0] * x + coffs[1] * y + x0;
            data[i + 1] = coffs[3] * x + coffs[4] * y + y0;
        }
    }
    /** multiply each xyz (as a vector) by matrix, replace values. */
    multiplyMatrix3dInPlace(matrix) {
        const data = this._data;
        const nDouble = this.float64Length;
        const coffs = matrix.coffs;
        let x = 0;
        let y = 0;
        for (let i = 0; i + 2 <= nDouble; i += 2) {
            x = data[i];
            y = data[i + 1];
            data[i] = coffs[0] * x + coffs[1] * y;
            data[i + 1] = coffs[3] * x + coffs[4] * y;
        }
    }
    /** multiply each point by the transform, replace values. */
    tryTransformInverseInPlace(transform) {
        const data = this._data;
        const nDouble = this.float64Length;
        const matrix = transform.matrix;
        matrix.computeCachedInverse(true);
        const coffs = matrix.inverseCoffs;
        if (!coffs)
            return false;
        const origin = transform.origin;
        const x0 = origin.x;
        const y0 = origin.y;
        let x = 0;
        let y = 0;
        for (let i = 0; i + 2 <= nDouble; i += 2) {
            x = data[i] - x0;
            y = data[i + 1] - y0;
            data[i] = coffs[0] * x + coffs[1] * y;
            data[i + 1] = coffs[3] * x + coffs[4] * y;
            data[i + 2] = coffs[6] * x + coffs[7] * y;
        }
        return true;
    }
    /** Extend a `Range2d`, optionally transforming the points. */
    extendRange(rangeToExtend, transform) {
        const numDouble = this.float64Length;
        const data = this._data;
        if (transform) {
            for (let i = 0; i + 2 <= numDouble; i += 2)
                rangeToExtend.extendTransformedXY(transform, data[i], data[i + 1]);
        }
        else {
            for (let i = 0; i + 2 <= numDouble; i += 2)
                rangeToExtend.extendXY(data[i], data[i + 1]);
        }
    }
    /** sum the lengths of segments between points. */
    sumLengths() {
        let sum = 0.0;
        const n = 2 * (this._xyInUse - 1); // Length already takes into account what specifically is in use
        const data = this._data;
        for (let i = 0; i < n; i += 2)
            sum += Geometry_1.Geometry.hypotenuseXY(data[i + 2] - data[i], data[i + 3] - data[i + 1]);
        return sum;
    }
    /**
     * Multiply each x,y,z by the scale factor.
     * @param factor
     */
    scaleInPlace(factor) {
        if (this._data) {
            const numFloat = this.float64Length;
            for (let i = 0; i < numFloat; i++)
                this._data[i] = this._data[i] * factor;
        }
    }
    /** Compute a point at fractional coordinate between points i and j */
    interpolate(i, fraction, j, result) {
        if (this.isIndexValid(i) && this.isIndexValid(j)) {
            const fraction0 = 1.0 - fraction;
            const data = this._data;
            i = 2 * i;
            j = 2 * j;
            return Point2dVector2d_1.Point2d.create(fraction0 * data[i] + fraction * data[j], fraction0 * data[i + 1] + fraction * data[j + 1], result);
        }
        return undefined;
    }
    /** Sum the signed areas of the projection to xy plane */
    areaXY() {
        let area = 0.0;
        const n = 2 * this._xyInUse; // float count !!
        if (n > 4) {
            const x0 = this._data[n - 2];
            const y0 = this._data[n - 1];
            let dx1 = this._data[0] - x0;
            let dy1 = this._data[1] - y0;
            let dx2 = 0;
            let dy2 = 0;
            for (let i = 2; i < n; i += 2, dx1 = dx2, dy1 = dy2) {
                dx2 = this._data[i] - x0;
                dy2 = this._data[i + 1] - y0;
                area += Geometry_1.Geometry.crossProductXYXY(dx1, dy1, dx2, dy2);
            }
        }
        return 0.5 * area;
    }
    /** Compute a vector from index origin i to indexed target j  */
    vectorIndexIndex(i, j, result) {
        if (!this.isIndexValid(i) || !this.isIndexValid(j))
            return undefined;
        const data = this._data;
        i = 2 * i;
        j = 2 * j;
        return Point2dVector2d_1.Vector2d.create(data[j] - data[i], data[j + 1] - data[i + 1], result);
    }
    /** Compute a vector from origin to indexed target j */
    vectorXAndYIndex(origin, j, result) {
        if (this.isIndexValid(j)) {
            const data = this._data;
            j = 2 * j;
            return Point2dVector2d_1.Vector2d.create(data[j] - origin.x, data[j + 1] - origin.y, result);
        }
        return undefined;
    }
    /** Compute the cross product of vectors from from indexed origin to indexed targets i and j */
    crossProductIndexIndexIndex(originIndex, targetAIndex, targetBIndex) {
        const i = originIndex * 2;
        const j = targetAIndex * 2;
        const k = targetBIndex * 2;
        const data = this._data;
        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            return Geometry_1.Geometry.crossProductXYXY(data[j] - data[i], data[j + 1] - data[i + 1], data[k] - data[i], data[k + 1] - data[i + 1]);
        return undefined;
    }
    /** Compute the cross product of vectors from from origin to indexed targets i and j */
    crossProductXAndYIndexIndex(origin, targetAIndex, targetBIndex) {
        const j = targetAIndex * 2;
        const k = targetBIndex * 2;
        const data = this._data;
        if (this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            return Geometry_1.Geometry.crossProductXYXY(data[j] - origin.x, data[j + 1] - origin.y, data[k] - origin.x, data[k + 1] - origin.y);
        return undefined;
    }
    /** Return the distance between two points in the array. */
    distance(i, j) {
        if (this.isIndexValid(i) && this.isIndexValid(j)) {
            const i0 = 2 * i;
            const j0 = 2 * j;
            return Geometry_1.Geometry.hypotenuseXY(this._data[j0] - this._data[i0], this._data[j0 + 1] - this._data[i0 + 1]);
        }
        return undefined;
    }
    /** Return the distance between an array point and the input point. */
    distanceIndexToPoint(i, spacePoint) {
        if (this.isIndexValid(i)) {
            const i0 = 2 * i;
            return Geometry_1.Geometry.hypotenuseXY(spacePoint.x - this._data[i0], spacePoint.y - this._data[i0 + 1]);
        }
        return undefined;
    }
    /** Test for nearly equal arrays. */
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (!dataA.getPoint2dAtUncheckedPointIndex(i).isAlmostEqual(dataB.getPoint2dAtUncheckedPointIndex(i)))
                    return false;
            return true;
        }
        // if both are null it is equal, otherwise unequal
        return (!dataA && !dataB);
    }
    /** Return an array of block indices sorted per compareLexicalBlock function */
    sortIndicesLexical() {
        const n = this._xyInUse;
        // let numCompare = 0;
        const result = new Uint32Array(n);
        for (let i = 0; i < n; i++)
            result[i] = i;
        result.sort((blockIndexA, blockIndexB) => {
            // numCompare++;
            return this.compareLexicalBlock(blockIndexA, blockIndexB);
        });
        // console.log (n, numCompare);
        return result;
    }
    /** compare two blocks in simple lexical order. */
    compareLexicalBlock(ia, ib) {
        let ax = 0;
        let bx = 0;
        for (let i = 0; i < 2; i++) {
            ax = this._data[ia * 2 + i];
            bx = this._data[ib * 2 + i];
            if (ax > bx)
                return 1;
            if (ax < bx)
                return -1;
        }
        return ia - ib; // so original order is maintained among duplicates !!!!
    }
    /** Access a single double at offset within a block.  This has no index checking. */
    component(pointIndex, componentIndex) {
        return this._data[2 * pointIndex + componentIndex];
    }
    /** Toleranced equality test */
    isAlmostEqual(other, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        const numXY = this._xyInUse;
        if (other._xyInUse !== numXY)
            return false;
        const dataA = this._data;
        const dataB = other._data;
        for (let i = 0; i < 2 * numXY; i++) {
            if (Math.abs(dataA[i] - dataB[i]) > tolerance)
                return false;
        }
        return true;
    }
}
exports.GrowableXYArray = GrowableXYArray;


/***/ }),

/***/ "./lib/geometry3d/GrowableXYZArray.js":
/*!********************************************!*\
  !*** ./lib/geometry3d/GrowableXYZArray.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module ArraysAndInterfaces */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ./Range */ "./lib/geometry3d/Range.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
const IndexedXYZCollection_1 = __webpack_require__(/*! ./IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
/** `GrowableXYArray` manages a (possibly growing) Float64Array to pack xy coordinates.
 * @public
 */
class GrowableXYZArray extends IndexedXYZCollection_1.IndexedReadWriteXYZCollection {
    /** Construct a new GrowablePoint3d array.
     * @param numPoints [in] initial capacity.
     */
    constructor(numPoints = 8) {
        super();
        this._data = new Float64Array(numPoints * 3); // 8 Points to start (3 values each)
        this._xyzInUse = 0;
        this._xyzCapacity = numPoints;
    }
    /** Return the number of points in use. */
    get length() { return this._xyzInUse; }
    /** Set number of points.
     * Pad zeros if length grows.
     */
    set length(newLength) {
        let oldLength = this.length;
        if (newLength < oldLength) {
            this._xyzInUse = newLength;
        }
        else if (newLength > oldLength) {
            this.ensureCapacity(newLength);
            while (oldLength++ < newLength)
                this.pushXYZ(0, 0, 0);
        }
    }
    /** Return the number of float64 in use. */
    get float64Length() { return this._xyzInUse * 3; }
    /** Return the raw packed data.
     * * Note that the length of the returned Float64Array is a count of doubles, and includes the excess capacity
     */
    float64Data() { return this._data; }
    /** If necessary, increase the capacity to a new pointCount.  Current coordinates and point count (length) are unchanged. */
    ensureCapacity(pointCapacity) {
        if (pointCapacity > this._xyzCapacity) {
            const newData = new Float64Array(pointCapacity * 3);
            const numCopy = this.length * 3;
            for (let i = 0; i < numCopy; i++)
                newData[i] = this._data[i];
            this._data = newData;
            this._xyzCapacity = pointCapacity;
        }
    }
    /** Resize the actual point count, preserving excess capacity. */
    resize(pointCount) {
        if (pointCount < this.length) {
            this._xyzInUse = pointCount >= 0 ? pointCount : 0;
        }
        else if (pointCount > this._xyzCapacity) {
            const newArray = new Float64Array(pointCount * 3);
            // Copy contents
            for (let i = 0; i < this._data.length; i += 3) {
                newArray[i] = this._data[i];
                newArray[i + 1] = this._data[i + 1];
                newArray[i + 2] = this._data[i + 2];
            }
            this._data = newArray;
            this._xyzCapacity = pointCount;
            this._xyzInUse = pointCount;
        }
    }
    /**
     * Make a copy of the (active) points in this array.
     * (The clone does NOT get excess capacity)
     */
    clone(result) {
        const numValue = this.length * 3;
        if (!result)
            result = new GrowableXYZArray(this.length);
        else {
            result.clear();
            result.ensureCapacity(this.length);
        }
        const newData = result._data;
        const data = this._data;
        for (let i = 0; i < numValue; i++)
            newData[i] = data[i];
        result._xyzInUse = this.length;
        return result;
    }
    /** Create an array from various point data formats.
     * Valid inputs are:
     * * Point2d
     * * point3d
     * * An array of 2 doubles
     * * An array of 3 doubles
     * * A GrowableXYZArray
     * * Any json object satisfying Point3d.isXYAndZ
     * * Any json object satisfying Point3d.isXAndY
     * * A Float64Array of doubles, interpreted as xyzxyz
     * * An array of any of the above
     * @param data source points.
     * @param result optional pre-allocated GrowableXYZArray to clear and fill.
     */
    static create(data, result) {
        if (result)
            result.clear();
        else
            result = new GrowableXYZArray(data.length);
        result.pushFrom(data);
        return result;
    }
    /** push a point to the end of the array */
    push(toPush) {
        this.pushXYZ(toPush.x, toPush.y, toPush.z);
    }
    /** push all points of an array */
    pushAll(points) {
        for (const p of points)
            this.push(p);
    }
    /** Push points from variant sources.
     * Valid inputs are:
     * * Point2d
     * * point3d
     * * An array of 2 doubles
     * * An array of 3 doubles
     * * A GrowableXYZArray
     * * Any json object satisfying Point3d.isXYAndZ
     * * Any json object satisfying Point3d.isXAndY
     * * A Float64Array of doubles, interpreted as xyzxyz
     * * An array of any of the above
     * @returns the number of points added.
     */
    pushFrom(p) {
        if (p instanceof Point3dVector3d_1.Point3d)
            this.pushXYZ(p.x, p.y, p.z);
        else if (p instanceof GrowableXYZArray)
            this.pushFromGrowableXYZArray(p);
        else if (p instanceof Point2dVector2d_1.Point2d)
            this.pushXYZ(p.x, p.y, 0.0);
        else if (Geometry_1.Geometry.isNumberArray(p, 4)) {
            const n = p.length;
            for (let i = 0; i + 2 < n; i += 3)
                this.pushXYZ(p[i], p[i + 1], p[i + 2]);
        }
        else if (Geometry_1.Geometry.isNumberArray(p, 3))
            this.pushXYZ(p[0], p[1], p[2]);
        else if (Geometry_1.Geometry.isNumberArray(p, 2))
            this.pushXYZ(p[0], p[1], 0.0);
        else if (Array.isArray(p)) {
            // direct recursion re-wraps p and goes infinite.  unroll here .
            for (const q of p)
                this.pushFrom(q);
        }
        else if (Point3dVector3d_1.Point3d.isXYAndZ(p))
            this.pushXYZ(p.x, p.y, p.z);
        else if (Point3dVector3d_1.Point3d.isXAndY(p))
            this.pushXYZ(p.x, p.y, 0.0);
        else if (p instanceof Float64Array) {
            const n = p.length;
            for (let i = 0; i + 2 < n; i += 3)
                this.pushXYZ(p[i], p[i + 1], p[i + 2]);
        }
        else if (p instanceof IndexedXYZCollection_1.IndexedXYZCollection) {
            for (let i = 0; i < p.length; i++)
                this.pushXYZ(p.getXAtUncheckedPointIndex(i), p.getYAtUncheckedPointIndex(i), p.getZAtUncheckedPointIndex(i));
        }
    }
    /**
     * Replicate numWrap xyz values from the front of the array as new values at the end.
     * @param numWrap number of xyz values to replicate
     */
    pushWrap(numWrap) {
        if (this._xyzInUse > 0) {
            let k;
            for (let i = 0; i < numWrap; i++) {
                k = 3 * i;
                this.pushXYZ(this._data[k], this._data[k + 1], this._data[k + 2]);
            }
        }
    }
    /** append a new point with given x,y,z */
    pushXYZ(x, y, z) {
        const index = this._xyzInUse * 3;
        if (index >= this._data.length)
            this.ensureCapacity(this.length === 0 ? 4 : this.length * 2);
        this._data[index] = x;
        this._data[index + 1] = y;
        this._data[index + 2] = z;
        this._xyzInUse++;
    }
    /** move the coordinates at fromIndex to toIndex.
     * * No action if either index is invalid.
     */
    moveIndexToIndex(fromIndex, toIndex) {
        if (this.isIndexValid(fromIndex) && this.isIndexValid(toIndex)) {
            let iA = fromIndex * 3;
            let iB = toIndex * 3;
            this._data[iB++] = this._data[iA++];
            this._data[iB++] = this._data[iA++];
            this._data[iB] = this._data[iA];
        }
    }
    /** Remove one point from the back.
     * * NOTE that (in the manner of std::vector native) this is "just" removing the point -- no point is NOT returned.
     * * Use `back ()` to get the last x,y,z assembled into a `Point3d `
     */
    pop() {
        if (this._xyzInUse > 0)
            this._xyzInUse--;
    }
    /**
     * Test if index is valid for an xyz (point or vector) within this array
     * @param index xyz index to test.
     */
    isIndexValid(index) {
        if (index >= this._xyzInUse || index < 0)
            return false;
        return true;
    }
    /**
     * Clear all xyz data, but leave capacity unchanged.
     */
    clear() {
        this._xyzInUse = 0;
    }
    /**
     * Get a point by index, strongly typed as a Point3d.  This is unchecked.  Use getPoint3dAtCheckedPointIndex to have validity test.
     * @param pointIndex index to access
     * @param result optional result
     */
    getPoint3dAtUncheckedPointIndex(pointIndex, result) {
        const index = 3 * pointIndex;
        return Point3dVector3d_1.Point3d.create(this._data[index], this._data[index + 1], this._data[index + 2], result);
    }
    /**
     * Get a point by index, strongly typed as a Point2d.  This is unchecked.  Use getPoint2dAtCheckedPointIndex to have validity test.
     * @param pointIndex index to access
     * @param result optional result
     */
    getPoint2dAtUncheckedPointIndex(pointIndex, result) {
        const index = 3 * pointIndex;
        return Point2dVector2d_1.Point2d.create(this._data[index], this._data[index + 1], result);
    }
    /** copy xyz into strongly typed Point3d */
    getPoint3dAtCheckedPointIndex(pointIndex, result) {
        const index = 3 * pointIndex;
        if (this.isIndexValid(pointIndex)) {
            if (!result)
                result = Point3dVector3d_1.Point3d.create();
            result.x = this._data[index];
            result.y = this._data[index + 1];
            result.z = this._data[index + 2];
            return result;
        }
        return undefined;
    }
    /** access x of indexed point */
    getXAtUncheckedPointIndex(pointIndex) {
        const index = 3 * pointIndex;
        return this._data[index];
    }
    /** access y of indexed point */
    getYAtUncheckedPointIndex(pointIndex) {
        const index = 3 * pointIndex;
        return this._data[index + 1];
    }
    /** access y of indexed point */
    getZAtUncheckedPointIndex(pointIndex) {
        const index = 3 * pointIndex;
        return this._data[index + 2];
    }
    /** copy xy into strongly typed Point2d */
    getPoint2dAtCheckedPointIndex(pointIndex, result) {
        const index = 3 * pointIndex;
        if (this.isIndexValid(pointIndex)) {
            if (!result)
                result = Point2dVector2d_1.Point2d.create();
            result.x = this._data[index];
            result.y = this._data[index + 1];
            return result;
        }
        return undefined;
    }
    /** copy xyz into strongly typed Vector3d */
    getVector3dAtCheckedVectorIndex(vectorIndex, result) {
        const index = 3 * vectorIndex;
        if (vectorIndex >= 0 && vectorIndex < this._xyzInUse) {
            if (!result)
                result = Point3dVector3d_1.Vector3d.create();
            result.x = this._data[index];
            result.y = this._data[index + 1];
            result.z = this._data[index + 2];
            return result;
        }
        return undefined;
    }
    /**
     * Read coordinates from source array, place them at index within this array.
     * @param destIndex point index where coordinates are to be placed in this array
     * @param source source array
     * @param sourceIndex point index in source array
     * @returns true if destIndex and sourceIndex are both valid.
     */
    transferFromGrowableXYZArray(destIndex, source, sourceIndex) {
        if (this.isIndexValid(destIndex) && source.isIndexValid(sourceIndex)) {
            const i = destIndex * 3;
            const j = sourceIndex * 3;
            this._data[i] = source._data[j];
            this._data[i + 1] = source._data[j + 1];
            this._data[i + 2] = source._data[j + 2];
            return true;
        }
        return false;
    }
    /**
     * push coordinates from the source array to the end of this array.
     * @param source source array
     * @param sourceIndex xyz index within the source.  If undefined, entire source is pushed.
     * @returns number of points pushed.
     */
    pushFromGrowableXYZArray(source, sourceIndex) {
        // full array push  . . .
        if (sourceIndex === undefined) {
            const numXYZAdd = source.length;
            this.ensureCapacity(this.length + numXYZAdd);
            const nXAdd = source.length * 3;
            const i0 = this._xyzInUse * 3;
            for (let i = 0; i < nXAdd; i++)
                this._data[i0 + i] = source._data[i];
            this._xyzInUse += numXYZAdd;
            return numXYZAdd;
        }
        // single point push . . .
        if (source.isIndexValid(sourceIndex)) {
            const j = sourceIndex * 3;
            this.pushXYZ(source._data[j], source._data[j + 1], source._data[j + 2]);
            return 1;
        }
        return 0;
    }
    /**
     * Return the first point, or undefined if the array is empty.
     */
    front(result) {
        if (this._xyzInUse === 0)
            return undefined;
        return this.getPoint3dAtUncheckedPointIndex(0, result);
    }
    /**
     * Return the last point, or undefined if the array is empty.
     */
    back(result) {
        if (this._xyzInUse < 1)
            return undefined;
        return this.getPoint3dAtUncheckedPointIndex(this._xyzInUse - 1, result);
    }
    /**
     * Set the coordinates of a single point.
     * @param pointIndex index of point to set
     * @param value coordinates to set
     */
    setAtCheckedPointIndex(pointIndex, value) {
        if (!this.isIndexValid(pointIndex))
            return false;
        let index = pointIndex * 3;
        this._data[index++] = value.x;
        this._data[index++] = value.y;
        this._data[index] = value.z;
        return true;
    }
    /**
     * Set the coordinates of a single point given as coordinates
     * @param pointIndex index of point to set
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     */
    setXYZAtCheckedPointIndex(pointIndex, x, y, z) {
        if (!this.isIndexValid(pointIndex))
            return false;
        let index = pointIndex * 3;
        this._data[index++] = x;
        this._data[index++] = y;
        this._data[index] = z;
        return true;
    }
    /**
     * Copy all points into a simple array of Point3d
     */
    getPoint3dArray() {
        const result = [];
        const data = this._data;
        const n = this.length;
        for (let i = 0; i < n; i++) {
            result.push(Point3dVector3d_1.Point3d.create(data[i * 3], data[i * 3 + 1], data[i * 3 + 2]));
        }
        return result;
    }
    /** multiply each point by the transform, replace values. */
    multiplyTransformInPlace(transform) {
        const data = this._data;
        const nDouble = this.float64Length;
        const coffs = transform.matrix.coffs;
        const origin = transform.origin;
        const x0 = origin.x;
        const y0 = origin.y;
        const z0 = origin.z;
        let x = 0;
        let y = 0;
        let z = 0;
        for (let i = 0; i + 2 <= nDouble; i += 3) {
            x = data[i];
            y = data[i + 1];
            z = data[i + 2];
            data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z + x0;
            data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z + y0;
            data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z + z0;
        }
    }
    /** reverse the order of points. */
    reverseInPlace() {
        const n = this.length;
        let j0, j1;
        let a;
        const data = this._data;
        for (let i0 = 0, i1 = n - 1; i0 < i1; i0++, i1--) {
            j0 = 3 * i0;
            j1 = 3 * i1;
            a = data[j0];
            data[j0] = data[j1];
            data[j1] = a;
            j0++;
            j1++;
            a = data[j0];
            data[j0] = data[j1];
            data[j1] = a;
            j0++;
            j1++;
            a = data[j0];
            data[j0] = data[j1];
            data[j1] = a;
        }
    }
    /** multiply each xyz (as a vector) by matrix, replace values. */
    multiplyMatrix3dInPlace(matrix) {
        const data = this._data;
        const nDouble = this.float64Length;
        const coffs = matrix.coffs;
        let x = 0;
        let y = 0;
        let z = 0;
        for (let i = 0; i + 2 <= nDouble; i += 3) {
            x = data[i];
            y = data[i + 1];
            z = data[i + 2];
            data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z;
            data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z;
            data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z;
        }
    }
    /** multiply each xyz (as a vector) by matrix inverse transpose, renormalize the vector, replace values.
     * * This is the way to apply a matrix (possibly with skew and scale) to a surface normal, and
     *      have it end up perpendicular to the transformed in-surface vectors.
     * * Return false if matrix is not invertible or if any normalization fails.
     */
    multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(matrix) {
        const data = this._data;
        const nDouble = this.float64Length;
        if (!matrix.computeCachedInverse(true))
            return false;
        const coffs = matrix.inverseCoffs;
        const tol = 1.0e-15;
        let x = 0;
        let y = 0;
        let z = 0;
        let x1;
        let y1;
        let z1;
        let q;
        let a;
        let numFail = 0;
        for (let i = 0; i + 2 <= nDouble; i += 3) {
            x = data[i];
            y = data[i + 1];
            z = data[i + 2];
            x1 = coffs[0] * x + coffs[3] * y + coffs[6] * z;
            y1 = coffs[1] * x + coffs[4] * y + coffs[7] * z;
            z1 = coffs[2] * x + coffs[5] * y + coffs[8] * z;
            a = x1 * x1 + y1 * y1 + z1 * z1;
            if (a < tol) {
                // put the originals back ..
                x1 = x;
                y1 = y;
                z1 = z;
                numFail++;
            }
            else if (Math.abs(a - 1.0) > tol) {
                q = 1.0 / Math.sqrt(a);
                x1 *= q;
                y1 *= q;
                z1 *= q;
            } // else -- q is near 1, no need to do the division !!
            data[i] = x1;
            data[i + 1] = y1;
            data[i + 2] = z1;
        }
        return numFail === 0;
    }
    /** multiply each point by the transform, replace values. */
    tryTransformInverseInPlace(transform) {
        const data = this._data;
        const nDouble = this.float64Length;
        const matrix = transform.matrix;
        matrix.computeCachedInverse(true);
        const coffs = matrix.inverseCoffs;
        if (!coffs)
            return false;
        const origin = transform.origin;
        const x0 = origin.x;
        const y0 = origin.y;
        const z0 = origin.z;
        let x = 0;
        let y = 0;
        let z = 0;
        for (let i = 0; i + 3 <= nDouble; i += 3) {
            x = data[i] - x0;
            y = data[i + 1] - y0;
            z = data[i + 2] - z0;
            data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z;
            data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z;
            data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z;
        }
        return true;
    }
    /** Extend `range` to extend by all points. */
    extendRange(rangeToExtend, transform) {
        const numDouble = this.float64Length;
        const data = this._data;
        if (transform) {
            for (let i = 0; i + 3 <= numDouble; i += 3)
                rangeToExtend.extendTransformedXYZ(transform, data[i], data[i + 1], data[i + 2]);
        }
        else {
            for (let i = 0; i + 3 <= numDouble; i += 3)
                rangeToExtend.extendXYZ(data[i], data[i + 1], data[i + 2]);
        }
    }
    /** get range of points. */
    getRange(transform) {
        const range = Range_1.Range3d.createNull();
        this.extendRange(range, transform);
        return range;
    }
    /** Initialize `range` with coordinates in this array. */
    setRange(range, transform) {
        range.setNull();
        this.extendRange(range, transform);
    }
    /** Sum the lengths of segments between points. */
    sumLengths() {
        let sum = 0.0;
        const n = 3 * (this._xyzInUse - 1); // Length already takes into account what specifically is in use
        const data = this._data;
        for (let i = 0; i < n; i += 3)
            sum += Geometry_1.Geometry.hypotenuseXYZ(data[i + 3] - data[i], data[i + 4] - data[i + 1], data[i + 5] - data[i + 2]);
        return sum;
    }
    /**
     * Multiply each x,y,z by the scale factor.
     * @param factor
     */
    scaleInPlace(factor) {
        if (this._data) {
            const numFloat = this.float64Length;
            for (let i = 0; i < numFloat; i++)
                this._data[i] = this._data[i] * factor;
        }
    }
    /** test if all points are within tolerance of a plane. */
    isCloseToPlane(plane, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        const numCoordinate = 3 * this._xyzInUse;
        const data = this._data;
        for (let i = 0; i < numCoordinate; i += 3)
            if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)
                return false;
        return true;
    }
    /** Compute a point at fractional coordinate between points i and j */
    interpolate(i, fraction, j, result) {
        if (this.isIndexValid(i) && this.isIndexValid(j)) {
            const fraction0 = 1.0 - fraction;
            const data = this._data;
            i = 3 * i;
            j = 3 * j;
            return Point3dVector3d_1.Point3d.create(fraction0 * data[i] + fraction * data[j], fraction0 * data[i + 1] + fraction * data[j + 1], fraction0 * data[i + 2] + fraction * data[j + 2], result);
        }
        return undefined;
    }
    /**
     * * Compute a point at fractional coordinate between points i and j of source
     * * push onto this array.
     */
    pushInterpolatedFromGrowableXYZArray(source, i, fraction, j) {
        if (source.isIndexValid(i) && source.isIndexValid(j)) {
            const fraction0 = 1.0 - fraction;
            const data = source._data;
            i = 3 * i;
            j = 3 * j;
            this.pushXYZ(fraction0 * data[i] + fraction * data[j], fraction0 * data[i + 1] + fraction * data[j + 1], fraction0 * data[i + 2] + fraction * data[j + 2]);
        }
    }
    /** Sum the signed areas of the projection to xy plane */
    areaXY() {
        let area = 0.0;
        const n = 3 * this._xyzInUse; // float count !!
        if (n > 6) {
            const x0 = this._data[n - 3];
            const y0 = this._data[n - 2];
            let dx1 = this._data[0] - x0;
            let dy1 = this._data[1] - y0;
            let dx2 = 0;
            let dy2 = 0;
            for (let i = 3; i < n; i += 3, dx1 = dx2, dy1 = dy2) {
                dx2 = this._data[i] - x0;
                dy2 = this._data[i + 1] - y0;
                area += Geometry_1.Geometry.crossProductXYXY(dx1, dy1, dx2, dy2);
            }
        }
        return 0.5 * area;
    }
    /** Compute a vector from index origin i to indexed target j  */
    vectorIndexIndex(i, j, result) {
        if (!this.isIndexValid(i) || !this.isIndexValid(j))
            return undefined;
        if (!result)
            result = Point3dVector3d_1.Vector3d.create();
        const data = this._data;
        i = 3 * i;
        j = 3 * j;
        result.x = data[j] - data[i];
        result.y = data[j + 1] - data[i + 1];
        result.z = data[j + 2] - data[i + 2];
        return result;
    }
    /** Compute a vector from origin to indexed target j */
    vectorXYAndZIndex(origin, j, result) {
        if (this.isIndexValid(j)) {
            const data = this._data;
            j = 3 * j;
            return Point3dVector3d_1.Vector3d.create(data[j] - origin.x, data[j + 1] - origin.y, data[j + 2] - origin.z, result);
        }
        return undefined;
    }
    /** Compute the cross product of vectors from from indexed origin to indexed targets i and j */
    crossProductIndexIndexIndex(originIndex, targetAIndex, targetBIndex, result) {
        const i = originIndex * 3;
        const j = targetAIndex * 3;
        const k = targetBIndex * 3;
        const data = this._data;
        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            return Geometry_1.Geometry.crossProductXYZXYZ(data[j] - data[i], data[j + 1] - data[i + 1], data[j + 2] - data[i + 2], data[k] - data[i], data[k + 1] - data[i + 1], data[k + 2] - data[i + 2], result);
        return undefined;
    }
    /** Compute the dot product of pointIndex with [x,y,z] */
    evaluateUncheckedIndexDotProductXYZ(pointIndex, x, y, z) {
        const i = pointIndex * 3;
        const data = this._data;
        return data[i] * x + data[i + 1] * y + data[i + 2] * z;
    }
    /** Compute the dot product of pointIndex with [x,y,z] */
    evaluateUncheckedIndexPlaneAltitude(pointIndex, plane) {
        const i = pointIndex * 3;
        const data = this._data;
        return plane.altitudeXYZ(data[i], data[i + 1], data[i + 2]);
    }
    /**
     * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.
     * * accumulate it to the result.
     */
    accumulateCrossProductIndexIndexIndex(originIndex, targetAIndex, targetBIndex, result) {
        const i = originIndex * 3;
        const j = targetAIndex * 3;
        const k = targetBIndex * 3;
        const data = this._data;
        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            result.addCrossProductToTargetsInPlace(data[i], data[i + 1], data[i + 2], data[j], data[j + 1], data[j + 2], data[k], data[k + 1], data[k + 2]);
        return undefined;
    }
    /**
     * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.
     * * accumulate it to the result.
     */
    accumulateScaledXYZ(index, scale, sum) {
        const i = index * 3;
        const data = this._data;
        if (this.isIndexValid(index)) {
            sum.x += scale * data[i];
            sum.y += scale * data[i + 1];
            sum.z += scale * data[i + 2];
        }
    }
    /** Compute the cross product of vectors from from origin to indexed targets i and j */
    crossProductXYAndZIndexIndex(origin, targetAIndex, targetBIndex, result) {
        const j = targetAIndex * 3;
        const k = targetBIndex * 3;
        const data = this._data;
        if (this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))
            return Geometry_1.Geometry.crossProductXYZXYZ(data[j] - origin.x, data[j + 1] - origin.y, data[j + 2] - origin.z, data[k] - origin.x, data[k + 1] - origin.y, data[k + 2] - origin.z, result);
        return undefined;
    }
    /** Return the distance between two points in the array.
     * @deprecated use distanceIndexIndex
     */
    distance(i, j) {
        if (i >= 0 && i < this._xyzInUse && j >= 0 && j <= this._xyzInUse) {
            const i0 = 3 * i;
            const j0 = 3 * j;
            return Geometry_1.Geometry.hypotenuseXYZ(this._data[j0] - this._data[i0], this._data[j0 + 1] - this._data[i0 + 1], this._data[j0 + 2] - this._data[i0 + 2]);
        }
        return undefined;
    }
    /** Return the distance between an array point and the input point. */
    distanceIndexToPoint(i, spacePoint) {
        if (i >= 0 && i < this._xyzInUse) {
            const i0 = 3 * i;
            return Geometry_1.Geometry.hypotenuseXYZ(spacePoint.x - this._data[i0], spacePoint.y - this._data[i0 + 1], spacePoint.z - this._data[i0 + 2]);
        }
        return undefined;
    }
    /**
     * Return distance squared between indicated points.
     * * Concrete classes may be able to implement this without creating a temporary.
     * @param index0 first point index
     * @param index1 second point index
     * @param defaultDistanceSquared distance squared to return if either point index is invalid.
     *
     */
    distanceSquaredIndexIndex(i, j) {
        if (i >= 0 && i < this._xyzInUse && j >= 0 && j <= this._xyzInUse) {
            const i0 = 3 * i;
            const j0 = 3 * j;
            return Geometry_1.Geometry.hypotenuseSquaredXYZ(this._data[j0] - this._data[i0], this._data[j0 + 1] - this._data[i0 + 1], this._data[j0 + 2] - this._data[i0 + 2]);
        }
        return undefined;
    }
    /**
     * Return distance between indicated points.
     * * Concrete classes may be able to implement this without creating a temporary.
     * @param index0 first point index
     * @param index1 second point index
     * @param defaultDistanceSquared distance squared to return if either point index is invalid.
     */
    distanceIndexIndex(i, j) {
        if (i >= 0 && i < this._xyzInUse && j >= 0 && j <= this._xyzInUse) {
            const i0 = 3 * i;
            const j0 = 3 * j;
            return Geometry_1.Geometry.hypotenuseXYZ(this._data[j0] - this._data[i0], this._data[j0 + 1] - this._data[i0 + 1], this._data[j0 + 2] - this._data[i0 + 2]);
        }
        return undefined;
    }
    /** Return the distance between points in distinct arrays. */
    static distanceBetweenPointsIn2Arrays(arrayA, i, arrayB, j) {
        if (i >= 0 && i < arrayA._xyzInUse && j >= 0 && j <= arrayB._xyzInUse) {
            const i0 = 3 * i;
            const j0 = 3 * j;
            return Geometry_1.Geometry.hypotenuseXYZ(arrayB._data[j0] - arrayA._data[i0], arrayB._data[j0 + 1] - arrayA._data[i0 + 1], arrayB._data[j0 + 2] - arrayA._data[i0 + 2]);
        }
        return undefined;
    }
    /** test for near equality between two `GrowableXYZArray`. */
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (!dataA.getPoint3dAtUncheckedPointIndex(i).isAlmostEqual(dataB.getPoint3dAtUncheckedPointIndex(i)))
                    return false;
            return true;
        }
        // if both are null it is equal, otherwise unequal
        return (!dataA && !dataB);
    }
    /** Return an array of block indices sorted per compareLexicalBlock function */
    sortIndicesLexical() {
        const n = this._xyzInUse;
        // let numCompare = 0;
        const result = new Uint32Array(n);
        for (let i = 0; i < n; i++)
            result[i] = i;
        result.sort((blockIndexA, blockIndexB) => {
            // numCompare++;
            return this.compareLexicalBlock(blockIndexA, blockIndexB);
        });
        // console.log (n, numCompare);
        return result;
    }
    /** compare two blocks in simple lexical order. */
    compareLexicalBlock(ia, ib) {
        let ax = 0;
        let bx = 0;
        for (let i = 0; i < 3; i++) {
            ax = this._data[ia * 3 + i];
            bx = this._data[ib * 3 + i];
            if (ax > bx)
                return 1;
            if (ax < bx)
                return -1;
        }
        return ia - ib; // so original order is maintained among duplicates !!!!
    }
    /** Access a single double at offset within a block.  This has no index checking. */
    component(pointIndex, componentIndex) {
        return this._data[3 * pointIndex + componentIndex];
    }
    /**
     * add points at regular steps from `other`
     * @param source
     * @param pointIndex0
     * @param step
     * @param numAdd
     */
    addSteppedPoints(other, pointIndex0, step, numAdd) {
        const dataB = other._data;
        let b0 = pointIndex0 * 3;
        const nb = other.length * 3;
        let numAdded = 0;
        while (b0 >= 0 && b0 + 2 < nb && numAdded < numAdd) {
            this.pushXYZ(dataB[b0], dataB[b0 + 1], dataB[b0 + 2]);
            b0 += step * 3;
            numAdded++;
        }
    }
    /**
     * find the min and max distance between corresponding indexed points.   Excess points are ignored.
     * @param arrayA first array
     * @param arrayB second array
     */
    static distanceRangeBetweenCorrespondingPoints(arrayA, arrayB) {
        const dataA = arrayA._data;
        const dataB = arrayB._data;
        const n = Math.min(arrayA.length, arrayB.length);
        let i = 0;
        let k0;
        const range = Range_1.Range1d.createNull();
        while (i < n) {
            k0 = 3 * i;
            range.extendX(Geometry_1.Geometry.hypotenuseXYZ(dataA[k0] - dataB[k0], dataA[k0 + 1] - dataB[k0 + 1], dataA[k0 + 2] - dataB[k0 + 2]));
            i++;
        }
        return range;
    }
    /**
     * * Triangle for (unchecked!) for three points identified by index
     * * z direction of frame is 001.
     * * Transform axes from origin to targetX and targetY
     * * in local coordinates (u,v,w) the xy interior of the triangle is `u>=0, v>= 0, w>= 0, u+v+w<1`
     * * Return undefined if transform is invertible (i.e. points are not in a vertical plane.)
     */
    fillLocalXYTriangleFrame(originIndex, targetAIndex, targetBIndex, result) {
        if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex)) {
            let i0 = originIndex * 3;
            const data = this._data;
            const ax = data[i0++];
            const ay = data[i0++];
            const az = data[i0++];
            i0 = targetAIndex * 3;
            const ux = data[i0++] - ax;
            const uy = data[i0++] - ay;
            const uz = data[i0++] - az;
            i0 = targetBIndex * 3;
            const vx = data[i0++] - ax;
            const vy = data[i0++] - ay;
            const vz = data[i0++] - az;
            result = Transform_1.Transform.createRowValues(ux, vx, 0, ax, uy, vy, 0, ay, uz, vz, 1, az, result);
            return result.computeCachedInverse() ? result : undefined;
        }
        return undefined;
    }
    /**
     * Pass the (x,y,z) of each point to a function which returns a replacement for of of the 3 components.
     * @param componentIndex Index (0,1,2) of component to be replaced.
     * @param func function to be called as `func(x,y,z)`, returning a replacement value for componentIndex
     */
    mapComponent(componentIndex, func) {
        const n = this._data.length;
        let q;
        for (let i = 0; i + 2 < n; i += 3) {
            q = func(this._data[i], this._data[i + 1], this._data[i + 2]);
            this._data[i + componentIndex] = q;
        }
    }
}
exports.GrowableXYZArray = GrowableXYZArray;


/***/ }),

/***/ "./lib/geometry3d/IndexedCollectionInterval.js":
/*!*****************************************************!*\
  !*** ./lib/geometry3d/IndexedCollectionInterval.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Object describing a (contiguous) subset of indices to an IndexedXYZCollection
 * @public
 */
class IndexedCollectionInterval {
    constructor(points, base, limit) {
        this.points = points;
        this.begin = base;
        this.end = limit;
    }
    /** Create an interval which matches a complete indexed collection. */
    static createComplete(points) {
        return new this(points, 0, points.length);
    }
    /** Create an interval which matches a collection from `start <= i < end`. */
    static createBeginEnd(points, begin, end) {
        return new this(points, begin, end);
    }
    /** Create an interval which matches a collection from `start <= i < end`. */
    static createBeginLength(points, begin, length) {
        return new this(points, begin, begin + length);
    }
    /** Add one to this.begin.  Return true if the interval is still live. */
    advanceBegin() {
        this.begin++;
        return this.begin < this.end;
    }
    /** advance this.end (but do not go beyond this.points.length)   return true if the interval is still live. */
    advanceEnd() {
        this.end++;
        if (this.end > this.points.length)
            this.end = this.points.length;
        return this.begin < this.end;
    }
    /** Return (if possible) the parent index corresponding to `localIndex` */
    localIndexToParentIndex(localIndex) {
        if (localIndex >= 0) {
            const parentIndex = this.begin + localIndex;
            if (parentIndex < this.points.length)
                return parentIndex;
        }
        return undefined;
    }
    /** Return true if
     * * the interval is empty (the empty set is a subset of all sets!)
     * * all indices in its range are valid.
     */
    get isValidSubset() {
        return this.length === 0
            || (this.localIndexToParentIndex(0) !== undefined
                && this.localIndexToParentIndex(this.length - 1) !== undefined);
    }
    /** restrict this.end to this.points.length */
    restrictEnd() {
        if (this.end > this.points.length)
            this.end = this.points.length;
    }
    /** Return true if length is 1 or more */
    get isNonEmpty() {
        return this.begin < this.end;
    }
    /** Advance this.begin to (other.end-1), i.e. catch the last member of other. */
    advanceToTail(other) {
        this.begin = other.end - 1;
        return this.isNonEmpty;
    }
    /** Advance this.begin to (other.begin), i.e. catch the first member of other. */
    advanceToHead(other) {
        this.begin = other.begin;
        return this.isNonEmpty;
    }
    /** Set this interval from another, with conditional replacements:
     * * Always reference the same points as other.
     * * use optional begin and end arguments if present; if not take begin and and from other.
     * * cap end at points.length.
     */
    setFrom(other, base, limit) {
        this.points = other.points;
        this.begin = base === undefined ? other.begin : base;
        this.end = limit === undefined ? other.end : limit;
        this.restrictEnd();
    }
    /** Return the number of steps possible with current begin and end */
    get length() {
        return this.end > this.begin ? this.end - this.begin : 0;
    }
    /** Return true if the length is exactly 1 */
    get isSingleton() {
        return this.begin + 1 === this.end;
    }
}
exports.IndexedCollectionInterval = IndexedCollectionInterval;
/**
 * Reference to an interval of the indices of an IndexedXYZCollection.
 * @public
 */
class IndexedXYZCollectionInterval extends IndexedCollectionInterval {
}
exports.IndexedXYZCollectionInterval = IndexedXYZCollectionInterval;


/***/ }),

/***/ "./lib/geometry3d/IndexedXYCollection.js":
/*!***********************************************!*\
  !*** ./lib/geometry3d/IndexedXYCollection.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * abstract base class for access to XYZ data with indexed reference.
 * * This allows algorithms to work with Point2d[] or GrowableXYZ.
 * ** GrowableXYZArray implements these for its data.
 * ** Point2dArrayCarrier carries a (reference to) a Point2d[] and implements the methods with calls on that array reference.
 * * In addition to "point by point" accessors, there abstract members compute commonly useful vector data "between points".
 * * Methods that create vectors among multiple indices allow callers to avoid creating temporaries.
 * @public
 */
class IndexedXYCollection {
}
exports.IndexedXYCollection = IndexedXYCollection;


/***/ }),

/***/ "./lib/geometry3d/IndexedXYZCollection.js":
/*!************************************************!*\
  !*** ./lib/geometry3d/IndexedXYZCollection.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ./Range */ "./lib/geometry3d/Range.js");
class PointsIterator {
    constructor(collection) {
        this._curIndex = -1;
        this._collection = collection;
    }
    next() {
        if (++this._curIndex >= this._collection.length) {
            // The ECMAScript spec states that value=undefined is valid if done=true. The TypeScript interface violates the spec hence the cast to any and back below.
            return { done: true };
        }
        return {
            value: this._collection.getPoint3dAtUncheckedPointIndex(this._curIndex),
            done: false,
        };
    }
    [Symbol.iterator]() { return this; }
}
/**
 * abstract base class for read-only access to XYZ data with indexed reference.
 * * This allows algorithms to work with Point3d[] or GrowableXYZ.
 * ** GrowableXYZArray implements these for its data.
 * ** Point3dArrayCarrier carries a (reference to) a Point3d[] and implements the methods with calls on that array reference.
 * * In addition to "point by point" accessors, there abstract members compute commonly useful vector data "between points".
 * * Methods that create vectors among multiple indices allow callers to avoid creating temporaries.
 * @public
 */
class IndexedXYZCollection {
    /** Adjust index into range by modulo with the length. */
    cyclicIndex(i) {
        return (i % this.length);
    }
    /** Return the range of the points. */
    getRange() {
        const range = Range_1.Range3d.createNull();
        const n = this.length;
        const point = Point3dVector3d_1.Point3d.create();
        for (let i = 0; i < n; i++) {
            this.getPoint3dAtUncheckedPointIndex(i, point);
            range.extendPoint(point);
        }
        return range;
    }
    /** Return iterator over the points in this collection. Usage:
     * ```ts
     *  for (const point: Point3d of collection.points) { ... }
     * ```
     */
    get points() {
        return new PointsIterator(this);
    }
}
exports.IndexedXYZCollection = IndexedXYZCollection;
/**
 * abstract base class extends IndexedXYZCollection, adding methods to push, peek, and pop, and rewrite.
 * @public
 */
class IndexedReadWriteXYZCollection extends IndexedXYZCollection {
}
exports.IndexedReadWriteXYZCollection = IndexedReadWriteXYZCollection;


/***/ }),

/***/ "./lib/geometry3d/Matrix3d.js":
/*!************************************!*\
  !*** ./lib/geometry3d/Matrix3d.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
/** @module CartesianGeometry */
/* tslint:disable:prefer-get */
/**
 * PackedMatrix3dOps contains static methods for matrix operations where the matrix is a Float64Array.
 * * The Float64Array contains the matrix entries in row-major order
 */
class PackedMatrix3dOps {
    /**
     * Load 9 doubles into the packed format.
     * @param dest destination, allocated by caller
     * @param a00 row 0, column 0 entry
     * @param a01 row 0, column 1 entry
     * @param a02 row 0, column 2 entry
     * @param a10 row 1, column 0 entry
     * @param a11 row 1, column 1 entry
     * @param a12 row 1, column 2 entry
     * @param a20 row 2, column 0 entry
     * @param a21 row 2, column 1 entry
     * @param a22 row 2, column 2 entry
     */
    static loadMatrix(dest, a00, a01, a02, a10, a11, a12, a20, a21, a22) {
        dest[0] = a00;
        dest[1] = a01;
        dest[2] = a02;
        dest[3] = a10;
        dest[4] = a11;
        dest[5] = a12;
        dest[6] = a20;
        dest[7] = a21;
        dest[8] = a22;
    }
    /**
     * * multiply 3x3 matrix `a*b`, store in c.
     * * All params assumed length 9, allocated by caller.
     * * c may alias either input.
     */
    static multiplyMatrixMatrix(a, b, result) {
        if (!result)
            result = new Float64Array(9);
        PackedMatrix3dOps.loadMatrix(result, (a[0] * b[0] + a[1] * b[3] + a[2] * b[6]), (a[0] * b[1] + a[1] * b[4] + a[2] * b[7]), (a[0] * b[2] + a[1] * b[5] + a[2] * b[8]), (a[3] * b[0] + a[4] * b[3] + a[5] * b[6]), (a[3] * b[1] + a[4] * b[4] + a[5] * b[7]), (a[3] * b[2] + a[4] * b[5] + a[5] * b[8]), (a[6] * b[0] + a[7] * b[3] + a[8] * b[6]), (a[6] * b[1] + a[7] * b[4] + a[8] * b[7]), (a[6] * b[2] + a[7] * b[5] + a[8] * b[8]));
        return result;
    }
    /**
     * * multiply 3x3 matrix `a*bTranspose`, store in c.
     * * All params assumed length 9, allocated by caller.
     * * c may alias either input.
     */
    static multiplyMatrixMatrixTranspose(a, b, result) {
        if (!result)
            result = new Float64Array(9);
        PackedMatrix3dOps.loadMatrix(result, (a[0] * b[0] + a[1] * b[1] + a[2] * b[2]), (a[0] * b[3] + a[1] * b[4] + a[2] * b[5]), (a[0] * b[6] + a[1] * b[7] + a[2] * b[8]), (a[3] * b[0] + a[4] * b[1] + a[5] * b[2]), (a[3] * b[3] + a[4] * b[4] + a[5] * b[5]), (a[3] * b[6] + a[4] * b[7] + a[5] * b[8]), (a[6] * b[0] + a[7] * b[1] + a[8] * b[2]), (a[6] * b[3] + a[7] * b[4] + a[8] * b[5]), (a[6] * b[6] + a[7] * b[7] + a[8] * b[8]));
        return result;
    }
    /**
     * * multiply 3x3 matrix `a*bTranspose`, store in c.
     * * All params assumed length 9, allocated by caller.
     * * c may alias either input.
     */
    static multiplyMatrixTransposeMatrix(a, b, result) {
        if (!result)
            result = new Float64Array(9);
        PackedMatrix3dOps.loadMatrix(result, (a[0] * b[0] + a[3] * b[3] + a[6] * b[6]), (a[0] * b[1] + a[3] * b[4] + a[6] * b[7]), (a[0] * b[2] + a[3] * b[5] + a[6] * b[8]), (a[1] * b[0] + a[4] * b[3] + a[7] * b[6]), (a[1] * b[1] + a[4] * b[4] + a[7] * b[7]), (a[1] * b[2] + a[4] * b[5] + a[7] * b[8]), (a[2] * b[0] + a[5] * b[3] + a[8] * b[6]), (a[2] * b[1] + a[5] * b[4] + a[8] * b[7]), (a[2] * b[2] + a[5] * b[5] + a[8] * b[8]));
        return result;
    }
    /** transpose 3x3 coefficients in place */
    static transposeInPlace(a) {
        let q = a[1];
        a[1] = a[3];
        a[3] = q;
        q = a[2];
        a[2] = a[6];
        a[6] = q;
        q = a[5];
        a[5] = a[7];
        a[7] = q;
    }
    /** transpose 3x3 coefficients in place */
    static copyTransposed(a, dest) {
        if (dest === a) {
            PackedMatrix3dOps.transposeInPlace(a);
        }
        else {
            if (!dest)
                dest = new Float64Array(9);
            dest[0] = a[0];
            dest[1] = a[3];
            dest[2] = a[6];
            dest[3] = a[1];
            dest[4] = a[4];
            dest[5] = a[7];
            dest[6] = a[2];
            dest[7] = a[5];
            dest[8] = a[8];
        }
        return dest;
    }
}
/** A Matrix3d is tagged indicating one of the following states:
 * * unknown: it is not know if the matrix is invertible.
 * * inverseStored: the matrix has its inverse stored
 * * singular: the matrix is known to be singular.
 * @public
 */
var InverseMatrixState;
(function (InverseMatrixState) {
    /**
     * * The invertibility of the  `coffs` array has not been determined.
     * * Any `inverseCoffs` contents are random.
     */
    InverseMatrixState[InverseMatrixState["unknown"] = 0] = "unknown";
    /** An inverse was computed and stored as the `inverseCoffs` */
    InverseMatrixState[InverseMatrixState["inverseStored"] = 1] = "inverseStored";
    /**
     * * The `coffs` array is known to be singular.
     * * Any `inverseCoffs` contents are random.
     */
    InverseMatrixState[InverseMatrixState["singular"] = 2] = "singular";
})(InverseMatrixState = exports.InverseMatrixState || (exports.InverseMatrixState = {}));
/** A Matrix3d is a 3x3 matrix.
 * * A very common use is to hold a rigid body rotation (which has no scaling or skew), but the 3x3 contents can
 * also hold scaling and skewing.
 * * The 9 entries are stored in row-major order in the coffs array.
 * * If the matrix inverse is known it is stored in the inverseCoffs array.
 * * The inverse status (unknown, inverseStored, singular) status is indicated by the inverseState property.
 * * constructions method that are able to determine the inverse store it immediately and
 *     note that in the inverseState.
 * * constructions (e.g. createRowValues) for which the inverse is not immediately known mark the
 *     inverseState as unknown.
 * * Later queries for the inverse trigger full computation if needed at that time.
 * * Most matrix queries are present with both "column" and "row" variants.
 * * Usage elsewhere in the library is typically "column" based.  For example, in a Transform
 *     that carries a coordinate frame the matrix columns are the unit vectors for the axes.
 * @public
 */
class Matrix3d {
    /**
     *
     * @param coffs optional coefficient array.  This is captured.
     */
    constructor(coffs) {
        this.coffs = coffs ? coffs : new Float64Array(9);
        this.inverseCoffs = undefined;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** The identity Matrix3d. Value is frozen and cannot be modified. */
    static get identity() {
        if (undefined === this._identity) {
            this._identity = Matrix3d.createIdentity();
            this._identity.freeze();
        }
        return this._identity;
    }
    /** Freeze this Matrix3d. */
    freeze() {
        this.computeCachedInverse(true);
        /* hm.. can't freeze the Float64Arrays . . .
        Object.freeze(this.coffs);
        if (this.inverseCoffs)
          Object.freeze(this.inverseCoffs);
        */
        Object.freeze(this);
    }
    /** Return a json object containing the 9 numeric entries as a single array in row major order,
     * `[ [1, 2, 3],[ 4, 5, 6], [7, 8, 9] ]`
     */
    toJSON() {
        return [[this.coffs[0], this.coffs[1], this.coffs[2]],
            [this.coffs[3], this.coffs[4], this.coffs[5]],
            [this.coffs[6], this.coffs[7], this.coffs[8]]];
    }
    /** copy data from various input forms to this matrix:
     * * Another `Matrix3d`
     * * An array of 3 arrays, each of which has the 3 numbers for a row of the matrix.
     * * An array of 9 numbers in row major order.
     */
    setFromJSON(json) {
        this.inverseCoffs = undefined;
        if (!json) {
            this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0);
            return;
        }
        if (!Array.isArray(json)) {
            if (json instanceof Matrix3d)
                this.setFrom(json);
            return;
        }
        if (Geometry_1.Geometry.isArrayOfNumberArray(json, 3, 3)) {
            const data = json;
            this.setRowValues(data[0][0], data[0][1], data[0][2], data[1][0], data[1][1], data[1][2], data[2][0], data[2][1], data[2][2]);
            return;
        }
        if (json.length === 9) {
            const data = json;
            this.setRowValues(data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7], data[8]);
        }
        else if (json.length === 4) {
            const data = json;
            this.setRowValues(data[0], data[1], 0, data[2], data[3], 0, 0, 0, 1);
        }
    }
    /** Return a new Matrix3d constructed from contents of the json value. Se `setFromJSON` for layout rules */
    static fromJSON(json) { const result = Matrix3d.createIdentity(); result.setFromJSON(json); return result; }
    /** Test if this Matrix3d and other are within tolerance in all numeric entries.
     * @param tol optional tolerance for comparisons by Geometry.isDistanceWithinTol
     */
    isAlmostEqual(other, tol) {
        if (tol)
            return Geometry_1.Geometry.isDistanceWithinTol(this.maxDiff(other), tol);
        return Geometry_1.Geometry.isSmallMetricDistance(this.maxDiff(other));
    }
    /** Test for exact (bitwise) equality with other. */
    isExactEqual(other) { return this.maxDiff(other) === 0.0; }
    /** test if all entries in the z row and column are exact 001, i.e. the matrix only acts in 2d */
    get isXY() {
        return this.coffs[2] === 0.0
            && this.coffs[5] === 0.0
            && this.coffs[6] === 0.0
            && this.coffs[7] === 0.0
            && this.coffs[8] === 1.0;
    }
    // !! does not clear supplied result !!
    static _create(result) { return result ? result : new Matrix3d(); }
    /** Returns a Matrix3d populated by numeric values given in row-major order.
     *  set all entries in the matrix from call parameters appearing in row - major order.
     * @param axx Row x, column x(0, 0) entry
     * @param axy Row x, column y(0, 1) entry
     * @param axz Row x, column z(0, 2) entry
     * @param ayx Row y, column x(1, 0) entry
     * @param ayy Row y, column y(1, 1) entry
     * @param ayz Row y, column z(1, 2) entry
     * @param azx Row z, column x(2, 0) entry
     * @param azy Row z, column y(2, 2) entry
     * @param azz row z, column z(2, 3) entry
     */
    static createRowValues(axx, axy, axz, ayx, ayy, ayz, azx, azy, azz, result) {
        result = result ? result : new Matrix3d();
        result.inverseState = InverseMatrixState.unknown;
        result.coffs[0] = axx;
        result.coffs[1] = axy;
        result.coffs[2] = axz;
        result.coffs[3] = ayx;
        result.coffs[4] = ayy;
        result.coffs[5] = ayz;
        result.coffs[6] = azx;
        result.coffs[7] = azy;
        result.coffs[8] = azz;
        return result;
    }
    /**
     * Create a Matrix3d with caller-supplied coefficients and optional inverse coefficients.
     * * The inputs are captured into the new Matrix3d.
     * * The caller is responsible for validity of the inverse coefficients.
     * @param coffs (required) array of 9 coefficients.
     * @param inverseCoffs (optional) array of 9 coefficients.
     * @returns a Matrix3d populated by a coffs array.
     */
    static createCapture(coffs, inverseCoffs) {
        const result = new Matrix3d(coffs);
        if (inverseCoffs) {
            result.inverseCoffs = inverseCoffs;
            result.inverseState = InverseMatrixState.inverseStored;
        }
        else {
            result.inverseState = InverseMatrixState.unknown;
        }
        return result;
    }
    /**
     * create a matrix by distributing vectors to columns in one of 6 orders.
     * @param axisOrder identifies where the columns are placed.
     * @param columnA vector to place in the first column named by the axis order.
     * @param columnB vector to place in the second column named by the axis order.
     * @param columnC vector to place in the third column named by the axis order.
     * @param result
     */
    static createColumnsInAxisOrder(axisOrder, columnA, columnB, columnC, result) {
        if (!result)
            result = new Matrix3d();
        if (axisOrder === Geometry_1.AxisOrder.YZX) {
            result.setColumns(columnC, columnA, columnB);
        }
        else if (axisOrder === Geometry_1.AxisOrder.ZXY) {
            result.setColumns(columnB, columnC, columnA);
        }
        else if (axisOrder === Geometry_1.AxisOrder.XZY) {
            result.setColumns(columnA, columnC, columnB);
        }
        else if (axisOrder === Geometry_1.AxisOrder.YXZ) {
            result.setColumns(columnB, columnA, columnC);
        }
        else if (axisOrder === Geometry_1.AxisOrder.ZYX) {
            result.setColumns(columnC, columnB, columnA);
        }
        else { // fallthrough should only happen for AxisOrder.XYZ
            result.setColumns(columnA, columnB, columnC);
        }
        return result;
    }
    /**
     *  set all entries in the matrix from call parameters appearing in row-major order.
     * @param axx Row x, column x (0,0) entry
     * @param axy Row x, column y (0,1) entry
     * @param axz Row x, column z (0,2) entry
     * @param ayx Row y, column x (1,0) entry
     * @param ayy Row y, column y (1,1) entry
     * @param ayz Row y, column z (1,2) entry
     * @param azx Row z, column x (2,0) entry
     * @param azy Row z, column y (2,2) entry
     * @param azz row z, column z (2,3) entry
     */
    setRowValues(axx, axy, axz, ayx, ayy, ayz, azx, azy, azz) {
        this.coffs[0] = axx;
        this.coffs[1] = axy;
        this.coffs[2] = axz;
        this.coffs[3] = ayx;
        this.coffs[4] = ayy;
        this.coffs[5] = ayz;
        this.coffs[6] = azx;
        this.coffs[7] = azy;
        this.coffs[8] = azz;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** Set the matrix to an identity. */
    setIdentity() { this.setRowValues(1, 0, 0, 0, 1, 0, 0, 0, 1); this.setupInverseTranspose(); }
    /** Set the matrix to all zeros. */
    setZero() { this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0); this.inverseState = InverseMatrixState.singular; }
    /** copy contents from another matrix. */
    setFrom(other) {
        for (let i = 0; i < 9; i++)
            this.coffs[i] = other.coffs[i];
        this.inverseState = InverseMatrixState.unknown; // we don't trust the other .. . .
    }
    /** return a clone of this matrix.
     * * coefficients are copied.
     * * inverse coefficients are NOT copied.
     * * inverse status is set to unknown
     */
    clone(result) {
        result = result ? result : new Matrix3d();
        result.setFrom(this);
        return result;
    }
    /** create a matrix with all zeros.
     * * Note that for geometry transformations "all zeros" is not a useful default state.
     * * Hence almost always use `createIdentity` for graphics transformations.
     * * "all zeros" is appropriate for summing moment data.
     */
    static createZero() {
        const retVal = new Matrix3d();
        retVal.inverseState = InverseMatrixState.singular;
        return retVal;
    }
    /** create an identity matrix
     * * all diagonal entries (xx,yy,zz) are one
     * * all others are zero.
     * * This (rather than all zeros) is the useful state for most graphics transformations.
     */
    static createIdentity(result) {
        result = result ? result : new Matrix3d();
        result.setIdentity();
        return result;
    }
    /** Create a matrix with uniform scale factors */
    static createUniformScale(scaleFactor) {
        return Matrix3d.createScale(scaleFactor, scaleFactor, scaleFactor);
    }
    /**
     *
     * *  use createHeadsUpPerpendicular to generate a vectorV perpendicular to vectorA
     * *  construct a frame using createRigidFromColumns (vectorA, vectorB, axisOrder)
     */
    static createRigidHeadsUp(vectorA, axisOrder = Geometry_1.AxisOrder.ZXY, result) {
        const vectorB = Matrix3d.createPerpendicularVectorFavorXYPlane(vectorA);
        const matrix = Matrix3d.createRigidFromColumns(vectorA, vectorB, axisOrder, result);
        if (matrix) {
            matrix.setupInverseTranspose();
            return matrix;
        }
        return Matrix3d.createIdentity(result);
    }
    /**
     *
     * * return a vector that is perpendicular to the input direction.
     * * Among the infinite number of perpendiculars possible, this method
     * favors having one in the xy plane.
     * * Hence, when vectorA is NOT close to the Z axis, the returned vector is Z cross vectorA.
     * * But vectorA is close to the Z axis, the returned vector is unitY cross vectorA.
     */
    static createPerpendicularVectorFavorXYPlane(vector, result) {
        const a = vector.magnitude();
        const b = a / 64.0; // A constant from the dawn of time in the CAD industry.
        if (Math.abs(vector.x) < b && Math.abs(vector.y) < b) {
            return Point3dVector3d_1.Vector3d.createCrossProduct(vector.x, vector.y, vector.z, 0, -1, 0, result);
        }
        return Point3dVector3d_1.Vector3d.createCrossProduct(0, 0, 1, vector.x, vector.y, vector.z, result);
    }
    /**
     *
     * * return a vector that is perpendicular to the input direction.
     * * Among the infinite number of perpendiculars possible, this method
     * favors having one near the Z.
     * That is achieved by crossing "this" vector with the result of createHeadsUpPerpendicularFavorXYPlane.
     */
    static createPerpendicularVectorFavorPlaneContainingZ(vector, result) {
        result = Matrix3d.createPerpendicularVectorFavorXYPlane(vector, result);
        return vector.crossProduct(result, result);
    }
    /** Create a matrix with distinct x,y,z diagonal (scale) entries */
    static createScale(scaleFactorX, scaleFactorY, scaleFactorZ, result) {
        if (result)
            result.setZero();
        else
            result = new Matrix3d();
        result.coffs[0] = scaleFactorX;
        result.coffs[4] = scaleFactorY;
        result.coffs[8] = scaleFactorZ;
        if (scaleFactorX === 0 || scaleFactorY === 0 || scaleFactorZ === 0) {
            result.inverseState = InverseMatrixState.singular;
        }
        else {
            result.inverseState = InverseMatrixState.inverseStored;
            result.inverseCoffs = Float64Array.from([1 / scaleFactorX, 0, 0,
                0, 1 / scaleFactorY, 0,
                0, 0, 1 / scaleFactorZ]);
        }
        return result;
    }
    /** return a rotation of specified angle around an axis */
    static createRotationAroundVector(axis, angle, result) {
        const c = angle.cos();
        const s = angle.sin();
        const v = 1.0 - c;
        const unit = axis.normalize();
        if (unit) {
            const retVal = Matrix3d.createRowValues(unit.x * unit.x * v + c, unit.x * unit.y * v - s * unit.z, unit.x * unit.z * v + s * unit.y, unit.y * unit.x * v + s * unit.z, unit.y * unit.y * v + c, unit.y * unit.z * v - s * unit.x, unit.z * unit.x * v - s * unit.y, unit.z * unit.y * v + s * unit.x, unit.z * unit.z * v + c, result);
            retVal.setupInverseTranspose();
            return retVal;
        }
        return undefined;
    }
    /** Returns a rotation of specified angle around an axis
     * @param axisIndex index of axis (AxisIndex.X, AxisIndex.Y, AxisIndex.Z) kept fixed by the rotation.
     * @param angle angle of rotation
     * @param result optional result matrix.
     */
    static createRotationAroundAxisIndex(axisIndex, angle, result) {
        const c = angle.cos();
        const s = angle.sin();
        let myResult;
        if (axisIndex === Geometry_1.AxisIndex.X) {
            myResult = Matrix3d.createRowValues(1, 0, 0, 0, c, -s, 0, s, c, result);
        }
        else if (axisIndex === Geometry_1.AxisIndex.Y) {
            myResult = Matrix3d.createRowValues(c, 0, s, 0, 1, 0, -s, 0, c, result);
        }
        else {
            myResult = Matrix3d.createRowValues(c, -s, 0, s, c, 0, 0, 0, 1, result);
        }
        myResult.setupInverseTranspose();
        return myResult;
    }
    /** Create a matrix with
     * * ColumnX points in the rightVector direction
     * * ColumnY points in in the upVectorDirection
     * * ColumnZ is a unit cross product.
     * Optionally rotate the standard cube by 45 to bring its left or right vertical edge to center
     * * leftNoneRight = [-1,0,1] respectively for left edge, no rotation, or right edge
     * * bottomNoneTop = [-1,0,1] respectively for isometric rotation to view the bottom, no isometric rotation, and isometric rotation to view the top
     * This is expected to be used with various principal unit vectors that are perpendicular to each other.
     *  * STANDARD TOP VIEW: (Vector3d.UnitX (), Vector3d.UnitY (), 0, 0)
     *  * STANDARD FRONT VIEW: (Vector3d.UnitX (), Vector3d.UnitZ (), 0, 0)
     *  * STANDARD BACK VIEW: (Vector3d.UnitX (-1), Vector3d.UnitZ (), 0, 0)
     *  * STANDARD RIGHT VIEW: (Vector3d.UnitY (1), Vector3d.UnitZ (), 0, 0)
     *  * STANDARD LEFT VIEW: (Vector3d.UnitY (-1), Vector3d.UnitZ (), 0, 0)
     *  * STANDARD BOTTOM VIEW: (Vector3d.UnitX (1), Vector3d.UnitY (-1), 0, 0)
     * @param leftNoneRight Normally one of {-1,0,1}, where (-1) indicates the left vertical is rotated to center and (1) for right.  Other numbers are used as multiplier for this 45 degree rotation
     * @returns undefined if columnX, columnY are coplanar.
     */
    static createViewedAxes(rightVector, upVector, leftNoneRight = 0, topNoneBottom = 0) {
        const columnZ = rightVector.crossProduct(upVector);
        if (columnZ.normalizeInPlace()) {
            const geometry = Matrix3d.createColumns(rightVector, upVector, columnZ);
            if (leftNoneRight !== 0.0) {
                let c = Math.sqrt(0.5);
                let s = leftNoneRight < 0.0 ? -c : c;
                if (Math.abs(leftNoneRight) !== 1.0) {
                    const radians = Angle_1.Angle.degreesToRadians(45.0 * leftNoneRight);
                    c = Math.cos(radians);
                    s = Math.sin(radians);
                }
                geometry.applyGivensColumnOp(2, 0, c, s); // rotate around Y
            }
            if (topNoneBottom !== 0.0) {
                const theta = topNoneBottom * Math.atan(Math.sqrt(0.5));
                const c = Math.cos(theta);
                const s = Math.sin(theta);
                geometry.applyGivensColumnOp(1, 2, c, -s); // rotate around X
            }
            return geometry;
        }
        return undefined;
    }
    /**
     * Create a rotation matrix for one of the 8 standard views.
     * * With `invert === false` the return is such that `matrix.multiply(worldVector)` returns the vector as seen in the xy (projected) coordinates of the view.
     * * With invert === true the matrix is transposed so that `matrix.multiply(viewVector` maps the "in view" vector to a world vector.
     *
     * @param index standard view index `StandardViewIndex.Top, Bottom, LEft, Right, Front, Back, Iso, LeftIso`
     * @param invert if false (default), the returned Matrix3d "projects" world vectors into XY view vectors.  If true, it is inverted to map view vectors to world.
     * @param result optional result.
     */
    static createStandardWorldToView(index, invert = false, result) {
        switch (index) {
            case Geometry_1.StandardViewIndex.Bottom:
                result = Matrix3d.createRowValues(1, 0, 0, 0, -1, 0, 0, 0, -1);
                break;
            case Geometry_1.StandardViewIndex.Left:
                result = Matrix3d.createRowValues(0, -1, 0, 0, 0, 1, -1, 0, 0);
                break;
            case Geometry_1.StandardViewIndex.Right:
                result = Matrix3d.createRowValues(0, 1, 0, 0, 0, 1, 1, 0, 0);
                break;
            case Geometry_1.StandardViewIndex.Front: // 0-based 4
                result = Matrix3d.createRowValues(1, 0, 0, 0, 0, 1, 0, -1, 0);
                break;
            case Geometry_1.StandardViewIndex.Back: // 0-based 5
                result = Matrix3d.createRowValues(-1, 0, 0, 0, 0, 1, 0, 1, 0);
                break;
            case Geometry_1.StandardViewIndex.Iso:
                result = Matrix3d.createRowValues(0.707106781186548, -0.70710678118654757, 0.00000000000000000, 0.408248290463863, 0.40824829046386302, 0.81649658092772603, -0.577350269189626, -0.57735026918962573, 0.57735026918962573);
                break;
            case Geometry_1.StandardViewIndex.RightIso:
                result = Matrix3d.createRowValues(0.707106781186548, 0.70710678118654757, 0.00000000000000000, -0.408248290463863, 0.40824829046386302, 0.81649658092772603, 0.577350269189626, -0.57735026918962573, 0.57735026918962573);
                break;
            case Geometry_1.StandardViewIndex.Top:
            default:
                result = Matrix3d.createIdentity(result);
        }
        if (invert)
            result.transposeInPlace();
        return result;
    }
    /*
    // this implementation has problems distinguishing failure (normalize) from small angle.
    public getAxisAndAngleOfRotation(): { axis: Vector3d, angle: Angle, error: boolean } {
  
      const result = { axis: Vector3d.unitZ(), angle: Angle.createRadians(0), error: true };
      if (this.isIdentity) {
        result.error = false;
        return result;
      }
      if (!this.isRigid())
        return result;
      const QMinusI = this.clone();
      QMinusI.coffs[0] -= 1.0;
      QMinusI.coffs[4] -= 1.0;
      QMinusI.coffs[8] -= 1.0;
      // Each column of (Q - I) is the motion of the corresponding axis vector
      // during the rotation.
      // Only one of the three axes can really be close to the rotation axis.
      const delta0 = QMinusI.columnX();
      const delta1 = QMinusI.columnY();
      const delta2 = QMinusI.columnZ();
      const cross01 = delta0.crossProduct(delta1);
      const cross12 = delta1.crossProduct(delta2);
      const cross20 = delta2.crossProduct(delta0);
  
      const aa01 = cross01.magnitudeSquared();
      const aa12 = cross12.magnitudeSquared();
      const aa20 = cross20.magnitudeSquared();
  
      const cross = cross01.clone(); // This will end up as the biggest cross product
      const v0 = delta0.clone();  // This will end up as one of the two largest delta vectors
      let aaMax = aa01;
      if (aa12 > aaMax) {
        cross.setFrom(cross12);
        aaMax = aa12;
        v0.setFrom(delta1);
      }
      if (aa20 > aaMax) {
        cross.setFrom(cross20);
        aaMax = aa20;
        v0.setFrom(delta2);
      }
  
      if (aaMax === 0.0) {
        // The vectors did not move.  Just accept the zero rotation, with error flag set.
        return result;
      }
  
      v0.normalizeInPlace();
      // V0 is a unit vector perpendicular to the rotation axis.
      // Rotate it.   Its image V1 is also a unit vector, and the angle from V0 to V1 is the quat angle.
      // CrossProduct is axis vector times sine of angle.
      // Dot Product is cosine of angle.
      // V2 is zero in 180 degree case, so we use the Cross from the search as the axis
      //   as direction, being careful to keep sine positive.
      const v1 = this.multiplyVector(v0);
      const v2 = v0.crossProduct(v1);
      const sine = v2.magnitude();
      if (v2.dotProduct(cross) < 0.0)
        cross.scaleInPlace(-1.0);
      const cosine = v0.dotProduct(v1);
      result.angle.setRadians(Math.atan2(sine, cosine));
      result.axis.setFrom(cross);
      result.error = !result.axis.tryNormalizeInPlace();
      return result
    }
  */
    /**
     * Compute the (unit vector) axis and angle of rotation.
     * @returns Returns with result.ok === true when the conversion succeeded.
     */
    getAxisAndAngleOfRotation() {
        const trace = this.coffs[0] + this.coffs[4] + this.coffs[8];
        // trace = (xx + yy * zz) * (1-c) + 3 * c = 1 + 2c ==> c = (trace-1) / 2
        const skewXY = this.coffs[3] - this.coffs[1]; // == 2sz
        const skewYZ = this.coffs[7] - this.coffs[5]; // == 2sx
        const skewZX = this.coffs[2] - this.coffs[6]; // == 2sy
        const c = (trace - 1.0) / 2.0;
        const s = Geometry_1.Geometry.hypotenuseXYZ(skewXY, skewYZ, skewZX) / 2.0;
        const e = c * c + s * s - 1.0;
        if (Math.abs(e) > Geometry_1.Geometry.smallAngleRadians) {
            // the sine and cosine are not a unit circle point.   bad matrix . ..
            return { axis: Point3dVector3d_1.Vector3d.create(0, 0, 1), angle: Angle_1.Angle.createRadians(0), ok: false };
        }
        if (Math.abs(s) < Geometry_1.Geometry.smallAngleRadians) {
            // There is no significant skew.
            // The matrix is symmetric
            // So it has simple eigenvalues -- either (1,1,1) or (1,-1,-1).
            if (c > 0) // no rotation
                return { axis: Point3dVector3d_1.Vector3d.create(0, 0, 1), angle: Angle_1.Angle.createRadians(0), ok: true };
            // 180 degree flip around some axis ?
            // Look for the simple case of a principal rotation ...
            // look for a pair of (-1) entries on the diagonal ...
            const axx = this.coffs[0];
            const ayy = this.coffs[4];
            const azz = this.coffs[8];
            const theta180 = Angle_1.Angle.createDegrees(180);
            // Look for principal axis flips as a special case . ..
            if (Geometry_1.Geometry.isAlmostEqualNumber(-1.0, ayy) && Geometry_1.Geometry.isAlmostEqualNumber(-1, azz)) {
                // rotate around
                return { axis: Point3dVector3d_1.Vector3d.create(1, 0, 0), angle: theta180, ok: true };
            }
            else if (Geometry_1.Geometry.isAlmostEqualNumber(-1.0, axx) && Geometry_1.Geometry.isAlmostEqualNumber(-1, azz)) {
                return { axis: Point3dVector3d_1.Vector3d.create(0, 1, 0), angle: theta180, ok: true };
            }
            else if (Geometry_1.Geometry.isAlmostEqualNumber(-1.0, axx) && Geometry_1.Geometry.isAlmostEqualNumber(-1, ayy)) {
                return { axis: Point3dVector3d_1.Vector3d.create(0, 0, 1), angle: theta180, ok: true };
            }
            // 180 degree flip around some other axis ...
            // eigenvalues will have 1.0 once, -1.0 twice.
            // These cases look for each place (x,y,z) that the 1.0 might appear.
            // But fastSymmetricEigenvalues reliably always seems to put the 1.0 as the x eigenvalue.
            // so only the getColumn(0) return seems reachable in unit tests.
            const eigenvectors = Matrix3d.createIdentity();
            const eigenvalues = Point3dVector3d_1.Vector3d.create(0, 0, 0);
            if (this.fastSymmetricEigenvalues(eigenvectors, eigenvalues)) {
                for (let axisIndex = 0; axisIndex < 2; axisIndex++) {
                    const lambda = eigenvalues.at(axisIndex);
                    if (Geometry_1.Geometry.isAlmostEqualNumber(1, lambda))
                        return { axis: eigenvectors.getColumn(axisIndex), angle: theta180, ok: true };
                }
                // Don't know if this can be reached ....
                return { axis: Point3dVector3d_1.Vector3d.create(0, 0, 1), angle: Angle_1.Angle.createRadians(0), ok: false };
            }
            return { axis: Point3dVector3d_1.Vector3d.create(0, 0, 1), angle: Angle_1.Angle.createRadians(0), ok: false };
        }
        const a = 1.0 / (2.0 * s);
        const result = { axis: Point3dVector3d_1.Vector3d.create(skewYZ * a, skewZX * a, skewXY * a), angle: Angle_1.Angle.createAtan2(s, c), ok: true };
        return result;
    }
    /**
     * Returns a matrix that rotates from vectorA to vectorB.
     */
    static createRotationVectorToVector(vectorA, vectorB, result) {
        return this.createPartialRotationVectorToVector(vectorA, 1.0, vectorB, result);
    }
    /**
     * Return a matrix that rotates a fraction of the angular sweep from vectorA to vectorB.
     * @param vectorA initial vector position
     * @param fraction fractional rotation.  1.0 is "all the way"
     * @param vectorB final vector position
     * @param result optional result matrix.
     */
    static createPartialRotationVectorToVector(vectorA, fraction, vectorB, result) {
        let upVector = vectorA.unitCrossProduct(vectorB);
        if (upVector) { // the usual case --
            return Matrix3d.createRotationAroundVector(upVector, Angle_1.Angle.createRadians(fraction * vectorA.planarAngleTo(vectorB, upVector).radians));
        }
        // fail if either vector is zero ...
        if (Geometry_1.Geometry.isSmallMetricDistance(vectorA.magnitude())
            || Geometry_1.Geometry.isSmallMetricDistance(vectorB.magnitude()))
            return undefined;
        // nonzero but aligned vectors ...
        if (vectorA.dotProduct(vectorB) > 0.0)
            return Matrix3d.createIdentity(result);
        // nonzero opposing vectors ..
        upVector = Matrix3d.createPerpendicularVectorFavorPlaneContainingZ(vectorA, upVector);
        return Matrix3d.createRotationAroundVector(upVector, Angle_1.Angle.createRadians(fraction * Math.PI));
    }
    /** Create a 90 degree rotation around a principal axis */
    static create90DegreeRotationAroundAxis(axisIndex) {
        axisIndex = Geometry_1.Geometry.cyclic3dAxis(axisIndex);
        if (axisIndex === 0) {
            const retVal = Matrix3d.createRowValues(1, 0, 0, 0, 0, -1, 0, 1, 0);
            retVal.setupInverseTranspose();
            return retVal;
        }
        else if (axisIndex === 1) {
            const retVal = Matrix3d.createRowValues(0, 0, 1, 0, 1, 0, -1, 0, 0);
            retVal.setupInverseTranspose();
            return retVal;
        }
        else {
            const retVal = Matrix3d.createRowValues(0, -1, 0, 1, 0, 0, 0, 0, 1);
            retVal.setupInverseTranspose();
            return retVal;
        }
    }
    /** Return (a copy of) the X column */
    columnX(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[0], this.coffs[3], this.coffs[6], result); }
    /** Return (a copy of)the Y column */
    columnY(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[1], this.coffs[4], this.coffs[7], result); }
    /** Return (a copy of)the Z column */
    columnZ(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[2], this.coffs[5], this.coffs[8], result); }
    /** Return the X column magnitude squared */
    columnXMagnitudeSquared() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[0], this.coffs[3], this.coffs[6]); }
    /** Return the Y column magnitude squared */
    columnYMagnitudeSquared() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[1], this.coffs[4], this.coffs[7]); }
    /** Return the Z column magnitude squared */
    columnZMagnitudeSquared() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[2], this.coffs[5], this.coffs[8]); }
    /** Return the X column magnitude */
    columnXMagnitude() { return Geometry_1.Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[3], this.coffs[6]); }
    /** Return the Y column magnitude */
    columnYMagnitude() { return Geometry_1.Geometry.hypotenuseXYZ(this.coffs[1], this.coffs[4], this.coffs[7]); }
    /** Return the Z column magnitude */
    columnZMagnitude() { return Geometry_1.Geometry.hypotenuseXYZ(this.coffs[2], this.coffs[5], this.coffs[8]); }
    /** Return magnitude of columnX cross columnY. */
    columnXYCrossProductMagnitude() {
        return Geometry_1.Geometry.crossProductMagnitude(this.coffs[0], this.coffs[3], this.coffs[6], this.coffs[1], this.coffs[4], this.coffs[7]);
    }
    /** Return the X row magnitude d */
    rowXMagnitude() { return Geometry_1.Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[1], this.coffs[2]); }
    /** Return the Y row magnitude  */
    rowYMagnitude() { return Geometry_1.Geometry.hypotenuseXYZ(this.coffs[3], this.coffs[4], this.coffs[5]); }
    /** Return the Z row magnitude  */
    rowZMagnitude() { return Geometry_1.Geometry.hypotenuseXYZ(this.coffs[6], this.coffs[7], this.coffs[8]); }
    /** Return the dot product of column X with column Y */
    /** Return the dot product of column X with column Y */
    columnXDotColumnY() {
        return this.coffs[0] * this.coffs[1]
            + this.coffs[3] * this.coffs[4]
            + this.coffs[6] * this.coffs[7];
    }
    /** Return (a copy of) the X row */
    rowX(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[0], this.coffs[1], this.coffs[2], result); }
    /** Return (a copy of) the Y row */
    rowY(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[3], this.coffs[4], this.coffs[5], result); }
    /** Return (a copy of) the Z row */
    rowZ(result) { return Point3dVector3d_1.Vector3d.create(this.coffs[6], this.coffs[7], this.coffs[8], result); }
    /** Return the dot product of the vector parameter with the X column. */
    dotColumnX(vector) { return vector.x * this.coffs[0] + vector.y * this.coffs[3] + vector.z * this.coffs[6]; }
    /** Return the dot product of the vector parameter with the Y column. */
    dotColumnY(vector) { return vector.x * this.coffs[1] + vector.y * this.coffs[4] + vector.z * this.coffs[7]; }
    /** Return the dot product of the vector parameter with the Z column. */
    dotColumnZ(vector) { return vector.x * this.coffs[2] + vector.y * this.coffs[5] + vector.z * this.coffs[8]; }
    /** Return the dot product of the vector parameter with the X row. */
    dotRowX(vector) { return vector.x * this.coffs[0] + vector.y * this.coffs[1] + vector.z * this.coffs[2]; }
    /** Return the dot product of the vector parameter with the Y row. */
    dotRowY(vector) { return vector.x * this.coffs[3] + vector.y * this.coffs[4] + vector.z * this.coffs[5]; }
    /** Return the dot product of the vector parameter with the Z row. */
    dotRowZ(vector) { return vector.x * this.coffs[6] + vector.y * this.coffs[7] + vector.z * this.coffs[8]; }
    // cSpell:words XXYZ YXYZ ZXYZ XYZAs Eigen
    /** Return the dot product of the x,y,z with the X row. */
    dotRowXXYZ(x, y, z) { return x * this.coffs[0] + y * this.coffs[1] + z * this.coffs[2]; }
    /** Return the dot product of the x,y,z with the Y row. */
    dotRowYXYZ(x, y, z) { return x * this.coffs[3] + y * this.coffs[4] + z * this.coffs[5]; }
    /** Return the dot product of the x,y,z with the Z row. */
    dotRowZXYZ(x, y, z) { return x * this.coffs[6] + y * this.coffs[7] + z * this.coffs[8]; }
    /** Return the (vector) cross product of the Z column with the vector parameter. */
    columnZCrossVector(vector, result) {
        return Geometry_1.Geometry.crossProductXYZXYZ(this.coffs[2], this.coffs[5], this.coffs[8], vector.x, vector.y, vector.z, result);
    }
    /**
     * Replace current rows Ui Uj with (c*Ui - s*Uj) and (c*Uj + s*Ui)
     * @param i first row index.  must be 0,1,2 (unchecked)
     * @param j second row index. must be 0,1,2 (unchecked)
     * @param c fist coefficient
     * @param s second coefficient
     */
    applyGivensRowOp(i, j, c, s) {
        let ii = 3 * i;
        let jj = 3 * j;
        const limit = ii + 3;
        for (; ii < limit; ii++, jj++) {
            const a = this.coffs[ii];
            const b = this.coffs[jj];
            this.coffs[ii] = a * c + b * s;
            this.coffs[jj] = -a * s + b * c;
        }
    }
    /**
     * Replace current columns Ui Uj with (c*Ui - s*Uj) and (c*Uj + s*Ui)
     * This is used in compute intensive inner loops -- there is no
     * checking for i,j being 0,1,2
     * @param i first row index.  must be 0,1,2 (unchecked)
     * @param j second row index. must be 0,1,2 (unchecked)
     * @param c fist coefficient
     * @param s second coefficient
     */
    applyGivensColumnOp(i, j, c, s) {
        const limit = i + 9;
        for (; i < limit; i += 3, j += 3) {
            const a = this.coffs[i];
            const b = this.coffs[j];
            this.coffs[i] = a * c + b * s;
            this.coffs[j] = -a * s + b * c;
        }
    }
    /**
     * create a rigid coordinate frame with:
     * * column z points from origin to x,y,z
     * * column x is perpendicular and in the xy plane
     * * column y is perpendicular to both.  It is the "up" vector on the view plane.
     * * Multiplying a world vector times the transpose of this matrix transforms into the view xy
     * * Multiplying the matrix times the an in-view vector transforms the vector to world.
     * @param x eye x coordinate
     * @param y eye y coordinate
     * @param z eye z coordinate
     * @param result
     */
    static createRigidViewAxesZTowardsEye(x, y, z, result) {
        result = Matrix3d.createIdentity(result);
        const rxy = Geometry_1.Geometry.hypotenuseXY(x, y);
        if (Geometry_1.Geometry.isSmallMetricDistance(rxy)) {
            // special case for top or bottom view.
            if (z < 0.0)
                result.scaleColumnsInPlace(1.0, -1, -1.0);
        }
        else {
            //      const d = Geometry.hypotenuseSquaredXYZ(x, y, z);
            const c = x / rxy;
            const s = y / rxy;
            result.setRowValues(-s, 0, c, c, 0, s, 0, 1, 0);
            if (z !== 0.0) {
                const r = Geometry_1.Geometry.hypotenuseXYZ(x, y, z);
                const s1 = z / r;
                const c1 = rxy / r;
                result.applyGivensColumnOp(1, 2, c1, -s1);
            }
        }
        return result;
    }
    /** Rotate so columns i and j become perpendicular */
    applyJacobiColumnRotation(i, j, matrixU) {
        const uDotU = this.coffs[i] * this.coffs[i] + this.coffs[i + 3] * this.coffs[i + 3] + this.coffs[i + 6] * this.coffs[i + 6];
        const vDotV = this.coffs[j] * this.coffs[j] + this.coffs[j + 3] * this.coffs[j + 3] + this.coffs[j + 6] * this.coffs[j + 6];
        const uDotV = this.coffs[i] * this.coffs[j] + this.coffs[i + 3] * this.coffs[j + 3] + this.coffs[i + 6] * this.coffs[j + 6];
        // const c2 = uDotU - vDotV;
        // const s2 = 2.0 * uDotV;
        const jacobi = Angle_1.Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);
        // const h = Math.hypot(c2, s2);
        // console.log(" c2 s2", c2 / h, s2 / h);
        // console.log(" C S ", Math.cos(2 * jacobi.radians), Math.sin(2 * jacobi.radians));
        // console.log("i j uDotV", i, j, uDotV);
        if (Math.abs(jacobi.s) < 2.0e-15)
            return 0.0;
        this.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);
        matrixU.applyGivensRowOp(i, j, jacobi.c, jacobi.s);
        // const BTB = this.multiplyMatrixTransposeMatrix(this);
        // console.log("BTB", BTB.at(0, 0), BTB.at(1, 1), BTB.at(2, 2), "       off", BTB.at(0, 1), BTB.at(0, 2), BTB.at(1, 2), "  at(i,j)", BTB.at(i, j));
        return Math.abs(uDotV);
    }
    /**
     * Factor this as a product C * U where C has mutually perpendicular columns and
     * U is orthogonal.
     * @param matrixC (allocate by caller, computed here)
     * @param factor  (allocate by caller, computed here)
     */
    factorPerpendicularColumns(matrixC, matrixU) {
        matrixC.setFrom(this);
        matrixU.setIdentity();
        const ss = this.sumSquares();
        const tolerance = 1.0e-12 * ss;
        for (let iteration = 0; iteration < 7; iteration++) {
            const sum = matrixC.applyJacobiColumnRotation(0, 1, matrixU)
                + matrixC.applyJacobiColumnRotation(0, 2, matrixU)
                + matrixC.applyJacobiColumnRotation(1, 2, matrixU);
            // console.log ("   sum", sum);
            if (sum < tolerance) {
                // console.log("jacobi iterations", iteration);
                return true;
            }
        }
        return false;
    }
    /** Apply a jacobi step to lambda which evolves towards diagonal. */
    applySymmetricJacobi(i, j, lambda) {
        const uDotU = lambda.at(i, i);
        const vDotV = lambda.at(j, j);
        const uDotV = lambda.at(i, j);
        if (Math.abs(uDotV) < 1.0e-15 * (uDotU + vDotV))
            return 0.0;
        // const c2 = uDotU - vDotV;
        // const s2 = 2.0 * uDotV;
        const jacobi = Angle_1.Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);
        // const h = Math.hypot(c2, s2);
        // console.log(" c2 s2", c2 / h, s2 / h);
        // console.log(" C S ", Math.cos(2 * jacobi.radians), Math.sin(2 * jacobi.radians));
        // console.log("i j uDotV", i, j, uDotV);
        if (Math.abs(jacobi.s) < 2.0e-15)
            return 0.0;
        // Factored form is this *lambda * thisTranspose
        // Let Q be the rotation matrix.  Q*QT is inserted, viz
        //          this*Q * QT * lambda * Q*thisTranspose
        this.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);
        lambda.applyGivensRowOp(i, j, jacobi.c, jacobi.s);
        lambda.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);
        // const BTB = this.multiplyMatrixTransposeMatrix(this);
        // console.log("BTB", BTB.at(0, 0), BTB.at(1, 1), BTB.at(2, 2), "       off", BTB.at(0, 1), BTB.at(0, 2), BTB.at(1, 2), "  at(i,j)", BTB.at(i, j));
        return Math.abs(uDotV);
    }
    /**
     * Factor this (symmetrized) as a product U * lambda * UT where U is orthogonal, lambda is diagonal.
     * The upper triangle is mirrored to lower triangle to enforce symmetry.
     * @param matrixC (allocate by caller, computed here)
     * @param factor  (allocate by caller, computed here)
     */
    symmetricEigenvalues(leftEigenvectors, lambda) {
        const matrix = this.clone();
        leftEigenvectors.setIdentity();
        matrix.coffs[3] = matrix.coffs[1];
        matrix.coffs[6] = matrix.coffs[2];
        matrix.coffs[7] = matrix.coffs[5];
        const ss = this.sumSquares();
        const tolerance = 1.0e-12 * ss;
        for (let iteration = 0; iteration < 7; iteration++) {
            const sum = leftEigenvectors.applySymmetricJacobi(0, 1, matrix)
                + leftEigenvectors.applySymmetricJacobi(0, 2, matrix)
                + leftEigenvectors.applySymmetricJacobi(1, 2, matrix);
            // console.log("symmetric sum", sum);
            // console.log ("   sum", sum);
            if (sum < tolerance) {
                // console.log("symmetric iterations", iteration);
                lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));
                return true;
            }
        }
        return false;
    }
    /** Apply (in place a jacobi update that zeros out this.at(i,j).
     *
     */
    applyFastSymmetricJacobiUpdate(i, // row index of zeroed member
    j, // column index of zeroed member
    k, // other row/column index (different from i and j)
    leftEigenVectors) {
        const indexII = 4 * i;
        const indexJJ = 4 * j;
        const indexIJ = 3 * i + j;
        const indexIK = 3 * i + k;
        const indexJK = 3 * j + k;
        const dotUU = this.coffs[indexII];
        const dotVV = this.coffs[indexJJ];
        const dotUV = this.coffs[indexIJ];
        const jacobi = Angle_1.Angle.trigValuesToHalfAngleTrigValues(dotUU - dotVV, 2.0 * dotUV);
        if (Math.abs(dotUV) < 1.0e-15 * (dotUU + dotVV))
            return 0.0;
        const c = jacobi.c;
        const s = jacobi.s;
        const cc = c * c;
        const ss = s * s;
        const sc2 = 2.0 * c * s;
        this.coffs[indexII] = cc * dotUU + sc2 * dotUV + ss * dotVV;
        this.coffs[indexJJ] = ss * dotUU - sc2 * dotUV + cc * dotVV;
        this.coffs[indexIJ] = 0.0;
        const a = this.coffs[indexIK];
        const b = this.coffs[indexJK];
        this.coffs[indexIK] = a * c + b * s;
        this.coffs[indexJK] = -s * a + c * b;
        this.coffs[3 * j + i] = 0.0;
        this.coffs[3 * k + i] = this.coffs[indexIK];
        this.coffs[3 * k + j] = this.coffs[indexJK];
        leftEigenVectors.applyGivensColumnOp(i, j, c, s);
        return Math.abs(dotUV);
    }
    /**
     * Factor this (symmetrized) as a product U * lambda * UT where U is orthogonal, lambda is diagonal.
     * The upper triangle is mirrored to lower triangle to enforce symmetry.
     * @param matrixC (allocate by caller, computed here)
     * @param factor  (allocate by caller, computed here)
     */
    fastSymmetricEigenvalues(leftEigenvectors, lambda) {
        const matrix = this.clone();
        leftEigenvectors.setIdentity();
        const ss = this.sumSquares();
        const tolerance = 1.0e-12 * ss;
        for (let iteration = 0; iteration < 7; iteration++) {
            const sum = matrix.applyFastSymmetricJacobiUpdate(0, 1, 2, leftEigenvectors)
                + matrix.applyFastSymmetricJacobiUpdate(0, 2, 1, leftEigenvectors)
                + matrix.applyFastSymmetricJacobiUpdate(1, 2, 0, leftEigenvectors);
            // console.log("symmetric sum", sum);
            // console.log ("   sum", sum);
            if (sum < tolerance) {
                // console.log("symmetric iterations", iteration);
                lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));
                return true;
            }
        }
        return false;
    }
    /** Create a matrix from column vectors. */
    static createColumns(vectorU, vectorV, vectorW, result) {
        return Matrix3d.createRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, vectorU.z, vectorV.z, vectorW.z, result);
    }
    /** Create a matrix from column vectors.
     * Each column gets x and y from given XAndY, and z from w.
     */
    static createColumnsXYW(vectorU, uz, vectorV, vz, vectorW, wz, result) {
        return Matrix3d.createRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, uz, vz, wz, result);
    }
    /** Install data from xyz parts of Point4d  (w part of Point4d ignored) */
    setColumnsPoint4dXYZ(vectorU, vectorV, vectorW) {
        this.inverseState = InverseMatrixState.unknown;
        this.setRowValues(vectorU.x, vectorV.x, vectorW.x, vectorU.y, vectorV.y, vectorW.y, vectorU.z, vectorV.z, vectorW.z);
    }
    /**
     * set entries in one column of the matrix.
     * @param columnIndex column index. this is interpreted cyclically.
     * @param value x,yz, values for column.  If undefined, zeros are installed.
     */
    setColumn(columnIndex, value) {
        const index = Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        this.inverseState = InverseMatrixState.unknown;
        if (value) {
            this.coffs[index] = value.x;
            this.coffs[index + 3] = value.y;
            this.coffs[index + 6] = value.z;
        }
        else {
            this.coffs[index] = 0.0;
            this.coffs[index + 3] = 0.0;
            this.coffs[index + 6] = 0.0;
        }
    }
    /** Set all columns of the matrix. Any undefined vector is zeros. */
    setColumns(vectorX, vectorY, vectorZ) {
        this.setColumn(0, vectorX);
        this.setColumn(1, vectorY);
        this.setColumn(2, vectorZ);
    }
    /**
     * set entries in one row of the matrix.
     * @param rowIndex row index. this is interpreted cyclically.
     * @param value x,yz, values for row.  If undefined, zeros are installed.
     */
    setRow(rowIndex, value) {
        const index = 3 * Geometry_1.Geometry.cyclic3dAxis(rowIndex);
        this.coffs[index] = value.x;
        this.coffs[index + 1] = value.y;
        this.coffs[index + 2] = value.z;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** Return a (copy of) a column of the matrix.
     * @param i column index.  This is corrected to 012 by Geometry.cyclic3dAxis.
     */
    getColumn(columnIndex, result) {
        const index = Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        return Point3dVector3d_1.Vector3d.create(this.coffs[index], this.coffs[index + 3], this.coffs[index + 6], result);
    }
    /** Return a (copy of) a row of the matrix.
     * @param i row index.  This is corrected to 012 by Geometry.cyclic3dAxis.
     */
    getRow(columnIndex, result) {
        const index = 3 * Geometry_1.Geometry.cyclic3dAxis(columnIndex);
        return Point3dVector3d_1.Vector3d.create(this.coffs[index], this.coffs[index + 1], this.coffs[index + 2], result);
    }
    /** Create a matrix from column vectors, shuffled into place per AxisTriple */
    static createShuffledColumns(vectorU, vectorV, vectorW, axisOrder, result) {
        const target = Matrix3d._create(result);
        target.setColumn(Geometry_1.Geometry.axisOrderToAxis(axisOrder, 0), vectorU);
        target.setColumn(Geometry_1.Geometry.axisOrderToAxis(axisOrder, 1), vectorV);
        target.setColumn(Geometry_1.Geometry.axisOrderToAxis(axisOrder, 2), vectorW);
        return target;
    }
    /** Create a matrix from row vectors. */
    static createRows(vectorU, vectorV, vectorW, result) {
        return Matrix3d.createRowValues(vectorU.x, vectorU.y, vectorU.z, vectorV.x, vectorV.y, vectorV.z, vectorW.x, vectorW.y, vectorW.z, result);
    }
    /** Create a matrix that scales along a specified direction. The scale factor can be negative. for instance scale of -1.0 (negative one) is a mirror. */
    static createDirectionalScale(direction, scale, result) {
        const unit = direction.normalize();
        if (unit) {
            const x = unit.x;
            const y = unit.y;
            const z = unit.z;
            const a = (scale - 1);
            return Matrix3d.createRowValues(1 + a * x * x, a * x * y, a * x * z, a * y * x, 1 + a * y * y, a * y * z, a * z * x, a * z * y, 1 + a * z * z, result);
        }
        return Matrix3d.createUniformScale(scale);
    }
    /* Create a matrix with the indicated column in the (normalized) direction, and the other two columns perpendicular. All columns are normalized.
     * * The direction vector is normalized and appears in column axisIndex
     * * If the direction vector is not close to Z, the "next" column ((axisIndex + 1) mod 3) will be in the XY plane in the direction of (direction cross Z)
     * * If the direction vector is close to Z, the "next" column ((axisIndex + 1) mode 3) will be in the direction of (direction cross Y)
    */
    // static create1Vector(direction: Vector3d, axisIndex: number): Matrix3d;
    // static createFromXYVectors(vectorX: Vector3d, vectorY: Vector3d, axisIndex: number): Matrix3d;
    /** Multiply the matrix * vector, i.e. the vector is a column vector on the right.
     * @return the vector result
     */
    multiplyVector(vector, result) {
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        return Point3dVector3d_1.Vector3d.create((this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z), (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z), (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z), result);
    }
    /** Multiply the matrix * vector, i.e. the vector is a column vector on the right.
     * @return the vector result
     */
    multiplyVectorArrayInPlace(data) {
        for (const v of data)
            v.set((this.coffs[0] * v.x + this.coffs[1] * v.y + this.coffs[2] * v.z), (this.coffs[3] * v.x + this.coffs[4] * v.y + this.coffs[5] * v.z), (this.coffs[6] * v.x + this.coffs[7] * v.y + this.coffs[8] * v.z));
    }
    /** compute `origin - matrix * vector` */
    static xyzMinusMatrixTimesXYZ(origin, matrix, vector, result) {
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        return Point3dVector3d_1.Point3d.create(origin.x - (matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z), origin.y - (matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z), origin.z - (matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z), result);
    }
    /** compute  `origin + matrix * vector`  using only the xy parts of the inputs. */
    static xyPlusMatrixTimesXY(origin, matrix, vector, result) {
        const x = vector.x;
        const y = vector.y;
        return Point2dVector2d_1.Point2d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y, result);
    }
    /** compute  `origin + matrix * vector`  using all xyz parts of the inputs. */
    static xyzPlusMatrixTimesXYZ(origin, matrix, vector, result) {
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        return Point3dVector3d_1.Point3d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, result);
    }
    /** compute  `origin + matrix * vector`  using all xyz parts of the inputs. */
    static xyzPlusMatrixTimesXYZInPlace(origin, matrix, vector) {
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        vector.x = origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;
        vector.y = origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;
        vector.z = origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;
    }
    /** compute `origin + matrix * vector` where the final vector is given as direct x,y,z coordinates */
    static xyzPlusMatrixTimesCoordinates(origin, matrix, x, y, z, result) {
        return Point3dVector3d_1.Point3d.create(origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, result);
    }
    /**
     * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.
     * Multiply times point with coordinates `[x,y,z,w]`
     * @param origin translation part (xyz in column 3)
     * @param matrix matrix part (leading 3x3)
     * @param x x part of multiplied point
     * @param y y part of multiplied point
     * @param z z part of multiplied point
     * @param w w part of multiplied point
     * @param result optional result.
     */
    static xyzPlusMatrixTimesWeightedCoordinates(origin, matrix, x, y, z, w, result) {
        return Point4d_1.Point4d.create(w * origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z, w * origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z, w * origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z, w, result);
    }
    /**
     * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.
     * Multiply times point with coordinates `[x,y,z,w]`
     * @param origin translation part (xyz in column 3)
     * @param matrix matrix part (leading 3x3)
     * @param x x part of multiplied point
     * @param y y part of multiplied point
     * @param z z part of multiplied point
     * @param w w part of multiplied point
     * @param result optional result.
     */
    static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(origin, matrix, x, y, z, w, result) {
        if (!result)
            result = new Float64Array(4);
        result[0] = w * origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;
        result[1] = w * origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;
        result[2] = w * origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;
        result[3] = w;
        return result;
    }
    /**
     * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.
     * Multiply times point with coordinates `[x,y,z,w]`
     * @param origin translation part (xyz in column 3)
     * @param matrix matrix part (leading 3x3)
     * @param x x part of multiplied point
     * @param y y part of multiplied point
     * @param z z part of multiplied point
     * @param w w part of multiplied point
     * @param result optional result.
     */
    static xyzPlusMatrixTimesCoordinatesToFloat64Array(origin, matrix, x, y, z, result) {
        if (!result)
            result = new Float64Array(3);
        result[0] = origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;
        result[1] = origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;
        result[2] = origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;
        return result;
    }
    /** Multiply transpose of this matrix times a vector. */
    multiplyTransposeVector(vector, result) {
        result = result ? result : new Point3dVector3d_1.Vector3d();
        const x = vector.x;
        const y = vector.y;
        const z = vector.z;
        result.x = (this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z);
        result.y = (this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z);
        result.z = (this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z);
        return result;
    }
    /** Multiply the matrix * (x,y,z), i.e. the vector (x,y,z) is a column vector on the right.
     * @return the vector result
     */
    multiplyXYZ(x, y, z, result) {
        result = result ? result : new Point3dVector3d_1.Vector3d();
        result.x = (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z);
        result.y = (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z);
        result.z = (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z);
        return result;
    }
    /** Multiply the matrix * xyz, place result in (required) return value.
     *   @param xyz right side
     *   @param result result.
     */
    multiplyXYZtoXYZ(xyz, result) {
        const x = xyz.x;
        const y = xyz.y;
        const z = xyz.z;
        result.x = (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z);
        result.y = (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z);
        result.z = (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z);
        return result;
    }
    /** Multiply the matrix * (x,y,0), i.e. the vector (x,y,z) is a column vector on the right.
     *   @return the vector result
     */
    multiplyXY(x, y, result) {
        result = result ? result : new Point3dVector3d_1.Vector3d();
        result.x = (this.coffs[0] * x + this.coffs[1] * y);
        result.y = (this.coffs[3] * x + this.coffs[4] * y);
        result.z = (this.coffs[6] * x + this.coffs[7] * y);
        return result;
    }
    /** compute `origin + this*[x,y,0]`  */
    originPlusMatrixTimesXY(origin, x, y, result) {
        return Point3dVector3d_1.Point3d.create(origin.x + this.coffs[0] * x + this.coffs[1] * y, origin.y + this.coffs[3] * x + this.coffs[4] * y, origin.z + this.coffs[6] * x + this.coffs[7] * y, result);
    }
    /** Multiply matrix * (x, y, z) using any 3d object given containing those members */
    multiplyVectorInPlace(xyzData) {
        const x = xyzData.x;
        const y = xyzData.y;
        const z = xyzData.z;
        const coffs = this.coffs;
        xyzData.x = (coffs[0] * x + coffs[1] * y + coffs[2] * z);
        xyzData.y = (coffs[3] * x + coffs[4] * y + coffs[5] * z);
        xyzData.z = (coffs[6] * x + coffs[7] * y + coffs[8] * z);
    }
    /** Multiply matrix * (x, y, z) using any 3d object given containing those members */
    multiplyTransposeVectorInPlace(xyzData) {
        const x = xyzData.x;
        const y = xyzData.y;
        const z = xyzData.z;
        const coffs = this.coffs;
        xyzData.x = (coffs[0] * x + coffs[3] * y + coffs[6] * z);
        xyzData.y = (coffs[1] * x + coffs[4] * y + coffs[7] * z);
        xyzData.z = (coffs[2] * x + coffs[5] * y + coffs[8] * z);
    }
    /** Multiply the (x,y,z) * matrix, i.e. the vector (x,y,z) is a row vector on the left.
     *   @return the vector result
     */
    multiplyTransposeXYZ(x, y, z, result) {
        result = result ? result : new Point3dVector3d_1.Vector3d();
        result.x = (this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z);
        result.y = (this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z);
        result.z = (this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z);
        return result;
    }
    /** Solve matrix * result = vector, i.e. multiply result = matrixInverse * rightHandSide  */
    multiplyInverse(vector, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            const x = vector.x;
            const y = vector.y;
            const z = vector.z;
            return Point3dVector3d_1.Vector3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z), (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z), (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /** Solve matrix * result = vector, i.e. multiply result = matrixInverse * rightHandSide  */
    multiplyInverseTranspose(vector, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            const x = vector.x;
            const y = vector.y;
            const z = vector.z;
            return Point3dVector3d_1.Vector3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[3] * y + this.inverseCoffs[6] * z), (this.inverseCoffs[1] * x + this.inverseCoffs[4] * y + this.inverseCoffs[7] * z), (this.inverseCoffs[2] * x + this.inverseCoffs[5] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /**
     *
     * *  multiply matrixInverse * [x,y,z]
     * *  Equivalent to solving matrix * result = [x,y,z]
     * *  return as a Vector3d.
     */
    multiplyInverseXYZAsVector3d(x, y, z, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            return Point3dVector3d_1.Vector3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z), (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z), (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /**
     *
     * *  multiply matrixInverse * [x,y,z]
     * *  Equivalent to solving matrix * result = [x,y,z]
     * *  return as a Point3d.
     */
    multiplyInverseXYZAsPoint3d(x, y, z, result) {
        this.computeCachedInverse(true);
        if (this.inverseCoffs) {
            return Point3dVector3d_1.Point3d.create((this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z), (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z), (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z), result);
        }
        return undefined;
    }
    /** Multiply two matrices.
     *   @return the matrix result
     */
    multiplyMatrixMatrix(other, result) {
        result = result ? result : new Matrix3d();
        PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs, other.coffs, result.coffs);
        return result;
    }
    /** Multiply this matrix times inverse of other
     *   @return the matrix result
     */
    multiplyMatrixMatrixInverse(other, result) {
        if (!other.computeCachedInverse(true))
            return undefined;
        result = result ? result : new Matrix3d();
        PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs, other.inverseCoffs, result.coffs);
        return result;
    }
    /** Matrix multiplication `this * otherTranspose`
     * @return the matrix result
     */
    multiplyMatrixMatrixTranspose(other, result) {
        result = result ? result : new Matrix3d();
        PackedMatrix3dOps.multiplyMatrixMatrixTranspose(this.coffs, other.coffs, result.coffs);
        return result;
    }
    /** Matrix multiplication `thisTranspose * other`
     *   @return the matrix result
     */
    multiplyMatrixTransposeMatrix(other, result) {
        result = result ? result : new Matrix3d();
        PackedMatrix3dOps.multiplyMatrixTransposeMatrix(this.coffs, other.coffs, result.coffs);
        return result;
    }
    //   [Q 0][R A] = [QR QA]
    //   [0 1][0 1]   [0  1]
    /** multiply this Matrix3d (considered as a transform with 0 translation) times other Transform.
     * @param other right hand Matrix3d for multiplication.
     * @param result optional preallocated result to reuse.
     */
    multiplyMatrixTransform(other, result) {
        if (!result)
            return Transform_1.Transform.createRefs(this.multiplyXYZ(other.origin.x, other.origin.y, other.origin.z), this.multiplyMatrixMatrix(other.matrix));
        // be sure to do the point multiplication first before aliasing changes the matrix ..
        this.multiplyXYZtoXYZ(other.origin, result.origin);
        this.multiplyMatrixMatrix(other.matrix, result.matrix);
        return result;
    }
    /** return the transposed matrix */
    transpose(result) {
        if (!result)
            result = new Matrix3d();
        PackedMatrix3dOps.copyTransposed(this.coffs, result.coffs);
        if (this.inverseCoffs !== undefined) {
            result.inverseState = InverseMatrixState.inverseStored;
            result.inverseCoffs = PackedMatrix3dOps.copyTransposed(this.inverseCoffs, result.inverseCoffs);
        }
        else {
            result.inverseState = this.inverseState; // singular or unknown.
            result.inverseCoffs = undefined;
        }
        return result;
    }
    /** return the transposed matrix */
    transposeInPlace() {
        PackedMatrix3dOps.transposeInPlace(this.coffs);
        if (this.inverseCoffs)
            PackedMatrix3dOps.transposeInPlace(this.inverseCoffs);
    }
    /** return the inverse matrix.  The return is  null if the matrix is singular (has columns that are coplanar or colinear) */
    inverse(result) {
        this.computeCachedInverse(true);
        if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs)
            return Matrix3d.createRowValues(this.inverseCoffs[0], this.inverseCoffs[1], this.inverseCoffs[2], this.inverseCoffs[3], this.inverseCoffs[4], this.inverseCoffs[5], this.inverseCoffs[6], this.inverseCoffs[7], this.inverseCoffs[8], result);
        return undefined;
    }
    /** copy the transpose of the coffs to the inverseCoffs.
     * * mark the matrix as inverseStored.
     */
    setupInverseTranspose() {
        const coffs = this.coffs;
        this.inverseState = InverseMatrixState.inverseStored;
        this.inverseCoffs = Float64Array.from([coffs[0], coffs[3], coffs[6],
            coffs[1], coffs[4], coffs[7],
            coffs[2], coffs[5], coffs[8]]);
    }
    /* Alternate implementation of computedCachedInverse - more direct addressing of arrays.
       This is indeed 10% faster than using static work areas. */
    // take the cross product of two rows of source.
    // store as a column of dest.
    static indexedRowCrossProduct(source, rowStart0, rowStart1, dest, columnStart) {
        dest[columnStart] = source[rowStart0 + 1] * source[rowStart1 + 2] - source[rowStart0 + 2] * source[rowStart1 + 1];
        dest[columnStart + 3] = source[rowStart0 + 2] * source[rowStart1] - source[rowStart0] * source[rowStart1 + 2];
        dest[columnStart + 6] = source[rowStart0] * source[rowStart1 + 1] - source[rowStart0 + 1] * source[rowStart1];
    }
    // take the cross product of two columns of source.
    // store as third column in same Matrix3d.
    // This is private because the columnStart values are unchecked raw indices into the coffs
    indexedColumnCrossProductInPlace(colStart0, colStart1, colStart2) {
        const coffs = this.coffs;
        coffs[colStart2] = coffs[colStart0 + 3] * coffs[colStart1 + 6] - coffs[colStart0 + 6] * coffs[colStart1 + 3];
        coffs[colStart2 + 3] = coffs[colStart0 + 6] * coffs[colStart1] - coffs[colStart0] * coffs[colStart1 + 6];
        coffs[colStart2 + 6] = coffs[colStart0] * coffs[colStart1 + 3] - coffs[colStart0 + 3] * coffs[colStart1];
    }
    /** Form cross products among axes in axisOrder.
     * For axis order ABC,
     * * form cross product of column A and B, store in C
     * * form cross product of column C and A, store in B.
     * This means that in the final matrix:
     * * column A is strictly parallel to original column A
     * * column B is linear combination of only original A and B
     * * column C is perpendicular to A and B of both the original and final.
     * * original column C does not participate in the result.
     */
    axisOrderCrossProductsInPlace(axisOrder) {
        switch (axisOrder) {
            case Geometry_1.AxisOrder.XYZ: {
                this.indexedColumnCrossProductInPlace(0, 1, 2);
                this.indexedColumnCrossProductInPlace(2, 0, 1);
                break;
            }
            case Geometry_1.AxisOrder.YZX: {
                this.indexedColumnCrossProductInPlace(1, 2, 0);
                this.indexedColumnCrossProductInPlace(0, 1, 2);
                break;
            }
            case Geometry_1.AxisOrder.ZXY: {
                this.indexedColumnCrossProductInPlace(2, 0, 1);
                this.indexedColumnCrossProductInPlace(1, 2, 0);
                break;
            }
            case Geometry_1.AxisOrder.XZY: {
                this.indexedColumnCrossProductInPlace(0, 2, 1);
                this.indexedColumnCrossProductInPlace(1, 0, 2);
                break;
            }
            case Geometry_1.AxisOrder.YXZ: {
                this.indexedColumnCrossProductInPlace(1, 0, 2);
                this.indexedColumnCrossProductInPlace(2, 1, 0);
                break;
            }
            case Geometry_1.AxisOrder.ZYX: {
                this.indexedColumnCrossProductInPlace(2, 1, 0);
                this.indexedColumnCrossProductInPlace(0, 2, 1);
                break;
            }
        }
    }
    /** Normalize each column in place.
     * * For false return the magnitudes are stored in the originalMagnitudes vector but no columns are altered.
     * @returns Return true if all columns had nonzero lengths.
     * @param originalMagnitudes optional vector to receive original column magnitudes.
     */
    normalizeColumnsInPlace(originalMagnitudes) {
        const ax = this.columnXMagnitude();
        const ay = this.columnYMagnitude();
        const az = this.columnZMagnitude();
        if (originalMagnitudes)
            originalMagnitudes.set(ax, ay, az);
        if (Geometry_1.Geometry.isSmallMetricDistance(ax) || Geometry_1.Geometry.isSmallMetricDistance(ay) || Geometry_1.Geometry.isSmallMetricDistance(az))
            return false;
        this.scaleColumns(1.0 / ax, 1.0 / ay, 1.0 / az, this);
        return true;
    }
    /** Normalize each row in place */
    normalizeRowsInPlace(originalMagnitudes) {
        const ax = this.rowXMagnitude();
        const ay = this.rowYMagnitude();
        const az = this.rowZMagnitude();
        if (originalMagnitudes)
            originalMagnitudes.set(ax, ay, az);
        if (Geometry_1.Geometry.isSmallMetricDistance(ax) || Geometry_1.Geometry.isSmallMetricDistance(ay) || Geometry_1.Geometry.isSmallMetricDistance(az))
            return false;
        this.scaleRows(1.0 / ax, 1.0 / ay, 1.0 / az, this);
        return true;
    }
    // take the cross product of two rows of source.
    // store as a column of dest.
    static rowColumnDot(coffA, rowStartA, coffB, columnStartB) {
        return coffA[rowStartA] * coffB[columnStartB] + coffA[rowStartA + 1] * coffB[columnStartB + 3] + coffA[rowStartA + 2] * coffB[columnStartB + 6];
    }
    /**
     * Returns true if the matrix is singular (i.e. collapses data to a plane, line, or point)
     */
    isSingular() {
        return !this.computeCachedInverse(true);
    }
    /**
     * Mark this matrix as singular.
     */
    markSingular() {
        this.inverseState = InverseMatrixState.singular;
    }
    /** compute the inverse of this Matrix3d. The inverse is stored for later use.
     * @returns Return true if the inverse computed.  (False if the columns collapse to a point, line or plane.)
     */
    computeCachedInverse(useCacheIfAvailable) {
        if (useCacheIfAvailable && Matrix3d.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {
            Matrix3d.numUseCache++;
            return this.inverseState === InverseMatrixState.inverseStored;
        }
        this.inverseState = InverseMatrixState.unknown;
        if (this.inverseCoffs === undefined)
            this.inverseCoffs = new Float64Array(9);
        const coffs = this.coffs;
        const inverseCoffs = this.inverseCoffs;
        Matrix3d.indexedRowCrossProduct(coffs, 3, 6, inverseCoffs, 0);
        Matrix3d.indexedRowCrossProduct(coffs, 6, 0, inverseCoffs, 1);
        Matrix3d.indexedRowCrossProduct(coffs, 0, 3, inverseCoffs, 2);
        Matrix3d.numComputeCache++;
        const d = Matrix3d.rowColumnDot(coffs, 0, inverseCoffs, 0);
        if (d === 0.0) { // better test?
            this.inverseState = InverseMatrixState.singular;
            this.inverseCoffs = undefined;
            return false;
        }
        const f = 1.0 / d;
        for (let i = 0; i < 9; i++)
            inverseCoffs[i] *= f;
        this.inverseState = InverseMatrixState.inverseStored;
        // verify inverse
        // const p = new Float64Array(9);
        // for (let i = 0; i < 9; i += 3)
        //   for (let j = 0; j < 3; j++)
        //    p[i + j] = Matrix3d.rowColumnDot (coffs, i, inverseCoffs, j);
        return true;
    }
    /* "Classic" inverse implementation with temporary vectors.
      private static rowX: Vector3d = Vector3d.create();
      private static rowY: Vector3d = Vector3d.create();
      private static rowZ: Vector3d = Vector3d.create();
      private static crossXY: Vector3d = Vector3d.create();
      private static crossZX: Vector3d = Vector3d.create();
      private static crossYZ: Vector3d = Vector3d.create();
    private computeCachedInverse(useCacheIfAvailable: boolean) {
        if (useCacheIfAvailable && Matrix3d.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {
          Matrix3d.numUseCache++;
          return this.inverseState === InverseMatrixState.inverseStored;
        }
        this.inverseState = InverseMatrixState.unknown;
        Matrix3d.numComputeCache++;
        const rowX = this.rowX(Matrix3d.rowX);
        const rowY = this.rowY(Matrix3d.rowY);
        const rowZ = this.rowZ(Matrix3d.rowZ);
        const crossXY = rowX.crossProduct(rowY, Matrix3d.crossXY);
        const crossYZ = rowY.crossProduct(rowZ, Matrix3d.crossYZ);
        const crossZX = rowZ.crossProduct(rowX, Matrix3d.crossZX);
        const d = rowX.dotProduct(crossYZ);  // that's the determinant
        if (d === 0.0) {     // better test?
          this.inverseState = InverseMatrixState.singular;
          this.inverseCoffs = undefined;
          return false;
        }
        const f = 1.0 / d;
        this.inverseState = InverseMatrixState.inverseStored;   // Currently just lists that the inverse has been stored... singular case not handled
        this.inverseCoffs = Float64Array.from([crossYZ.x * f, crossZX.x * f, crossXY.x * f,
        crossYZ.y * f, crossZX.y * f, crossXY.y * f,
        crossYZ.z * f, crossZX.z * f, crossXY.z * f]);
        return true;
      }
    */
    /** convert a (row,column) index pair to the single index within flattened array of 9 numbers in row-major-order  */
    static flatIndexOf(row, column) {
        return 3 * Geometry_1.Geometry.cyclic3dAxis(row) + Geometry_1.Geometry.cyclic3dAxis(column);
    }
    /** Get a column by index (0,1,2), packaged as a Point4d with given weight.   Out of range index is interpreted cyclically.  */
    indexedColumnWithWeight(index, weight, result) {
        index = Geometry_1.Geometry.cyclic3dAxis(index);
        return Point4d_1.Point4d.create(this.coffs[index], this.coffs[index + 3], this.coffs[index + 6], weight, result);
    }
    /** return the entry at specific row and column */
    at(row, column) {
        return this.coffs[Matrix3d.flatIndexOf(row, column)];
    }
    /** Set the entry at specific row and column */
    setAt(row, column, value) {
        this.coffs[Matrix3d.flatIndexOf(row, column)] = value;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** create a Matrix3d whose columns are scaled copies of this Matrix3d.
     * @param scaleX scale factor for columns x
     * @param scaleY scale factor for column y
     * @param scaleZ scale factor for column z
     * @param result optional result.
     */
    scaleColumns(scaleX, scaleY, scaleZ, result) {
        return Matrix3d.createRowValues(this.coffs[0] * scaleX, this.coffs[1] * scaleY, this.coffs[2] * scaleZ, this.coffs[3] * scaleX, this.coffs[4] * scaleY, this.coffs[5] * scaleZ, this.coffs[6] * scaleX, this.coffs[7] * scaleY, this.coffs[8] * scaleZ, result);
    }
    /** create a Matrix3d whose columns are scaled copies of this Matrix3d.
     * @param scaleX scale factor for columns x
     * @param scaleY scale factor for column y
     * @param scaleZ scale factor for column z
     * @param result optional result.
     */
    scaleColumnsInPlace(scaleX, scaleY, scaleZ) {
        this.coffs[0] *= scaleX;
        this.coffs[1] *= scaleY;
        this.coffs[2] *= scaleZ;
        this.coffs[3] *= scaleX;
        this.coffs[4] *= scaleY;
        this.coffs[5] *= scaleZ;
        this.coffs[6] *= scaleX;
        this.coffs[7] *= scaleY;
        this.coffs[8] *= scaleZ;
        if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs !== undefined) {
            // apply reciprocal scales to the ROWS of the inverse .  . .
            const divX = Geometry_1.Geometry.conditionalDivideFraction(1.0, scaleX);
            const divY = Geometry_1.Geometry.conditionalDivideFraction(1.0, scaleY);
            const divZ = Geometry_1.Geometry.conditionalDivideFraction(1.0, scaleZ);
            if (divX !== undefined && divY !== undefined && divZ !== undefined) {
                this.inverseCoffs[0] *= divX;
                this.inverseCoffs[1] *= divX;
                this.inverseCoffs[2] *= divX;
                this.inverseCoffs[3] *= divY;
                this.inverseCoffs[4] *= divY;
                this.inverseCoffs[5] *= divY;
                this.inverseCoffs[6] *= divZ;
                this.inverseCoffs[7] *= divZ;
                this.inverseCoffs[8] *= divZ;
            }
            else
                this.inverseState = InverseMatrixState.singular;
        }
    }
    /** create a Matrix3d whose rows are scaled copies of this Matrix3d.
     * @param scaleX scale factor for row x
     * @param scaleY scale factor for row y
     * @param scaleZ scale factor for row z
     * @param result optional result.
     */
    scaleRows(scaleX, scaleY, scaleZ, result) {
        return Matrix3d.createRowValues(this.coffs[0] * scaleX, this.coffs[1] * scaleX, this.coffs[2] * scaleX, this.coffs[3] * scaleY, this.coffs[4] * scaleY, this.coffs[5] * scaleY, this.coffs[6] * scaleZ, this.coffs[7] * scaleZ, this.coffs[8] * scaleZ, result);
    }
    /**
     * add scaled values from other Matrix3d to this Matrix3d
     * @param other Matrix3d with values to be added
     * @param scale scale factor to apply to th eadded values.
     */
    addScaledInPlace(other, scale) {
        for (let i = 0; i < 9; i++)
            this.coffs[i] += scale * other.coffs[i];
        this.inverseState = InverseMatrixState.unknown;
    }
    /**
     * add scaled values from other Matrix3d to this Matrix3d
     * @param other Matrix3d with values to be added
     * @param scale scale factor to apply to th eadded values.
     */
    addScaledOuterProductInPlace(vectorU, vectorV, scale) {
        this.coffs[0] += scale * vectorU.x * vectorV.x;
        this.coffs[1] += scale * vectorU.x * vectorV.y;
        this.coffs[2] += scale * vectorU.x * vectorV.z;
        this.coffs[3] += scale * vectorU.y * vectorV.x;
        this.coffs[4] += scale * vectorU.y * vectorV.y;
        this.coffs[5] += scale * vectorU.y * vectorV.z;
        this.coffs[6] += scale * vectorU.z * vectorV.x;
        this.coffs[7] += scale * vectorU.z * vectorV.y;
        this.coffs[8] += scale * vectorU.z * vectorV.z;
        this.inverseState = InverseMatrixState.unknown;
    }
    /** create a Matrix3d whose values are uniformly scaled from this.
     * @param scale scale factor to apply.
     * @param result optional result.
     * @returns Return the new or repopulated matrix
     */
    scale(scale, result) {
        return Matrix3d.createRowValues(this.coffs[0] * scale, this.coffs[1] * scale, this.coffs[2] * scale, this.coffs[3] * scale, this.coffs[4] * scale, this.coffs[5] * scale, this.coffs[6] * scale, this.coffs[7] * scale, this.coffs[8] * scale, result);
    }
    /** Return the determinant of this matrix. */
    determinant() {
        return this.coffs[0] * this.coffs[4] * this.coffs[8]
            - this.coffs[0] * this.coffs[7] * this.coffs[5]
            + this.coffs[3] * this.coffs[7] * this.coffs[2]
            - this.coffs[3] * this.coffs[1] * this.coffs[8]
            + this.coffs[6] * this.coffs[1] * this.coffs[5]
            - this.coffs[6] * this.coffs[4] * this.coffs[2];
    }
    /** Return an estimate of how independent the columns are.  Near zero is bad. Near 1 is good
     */
    conditionNumber() {
        const determinant = this.determinant();
        const columnMagnitudeProduct = Geometry_1.Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[3], this.coffs[6])
            + Geometry_1.Geometry.hypotenuseXYZ(this.coffs[1], this.coffs[4], this.coffs[7])
            + Geometry_1.Geometry.hypotenuseXYZ(this.coffs[2], this.coffs[5], this.coffs[8]);
        return Geometry_1.Geometry.safeDivideFraction(determinant, columnMagnitudeProduct, 0.0);
    }
    /** Return the sum of squares of all entries */
    sumSquares() {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i++)
            a += this.coffs[i] * this.coffs[i];
        return a;
    }
    /** Return the sum of squares of diagonal entries */
    sumDiagonalSquares() {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i += 4)
            a += this.coffs[i] * this.coffs[i];
        return a;
    }
    /** Return the sum of diagonal entries (also known as the trace) */
    sumDiagonal() {
        return this.coffs[0] + this.coffs[4] + this.coffs[8];
    }
    /** Return the Maximum absolute value of any single entry */
    maxAbs() {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i++)
            a = Math.max(a, Math.abs(this.coffs[i]));
        return a;
    }
    /** Return the maximum absolute difference between corresponding entries */
    maxDiff(other) {
        let i = 0;
        let a = 0;
        for (i = 0; i < 9; i++)
            a = Math.max(a, Math.abs(this.coffs[i] - other.coffs[i]));
        return a;
    }
    /** Test if the matrix is (very near to) an identity */
    get isIdentity() {
        return this.maxDiff(Matrix3d.identity) < Geometry_1.Geometry.smallAngleRadians;
    }
    /** Test if the off diagonal entries are all nearly zero */
    get isDiagonal() {
        const sumAll = this.sumSquares();
        const sumDiagonal = this.sumDiagonalSquares();
        const sumOff = Math.abs(sumAll - sumDiagonal);
        return Math.sqrt(sumOff) <= Geometry_1.Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));
    }
    /** Test if the below diagonal entries are all nearly zero */
    get isUpperTriangular() {
        const sumAll = this.sumSquares();
        const sumLow = Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[3], this.coffs[6], this.coffs[7]);
        return Math.sqrt(sumLow) <= Geometry_1.Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));
    }
    /** If the matrix is diagonal and all diagonals are within tolerance, return the first diagonal.  Otherwise return undefined.
     */
    sameDiagonalScale() {
        const sumAll = this.sumSquares();
        const sumDiagonal = this.sumDiagonalSquares();
        const sumOff = Math.abs(sumAll - sumDiagonal);
        if (Math.sqrt(sumOff) <= Geometry_1.Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll))
            && Geometry_1.Geometry.isSameCoordinate(this.coffs[0], this.coffs[4]) && Geometry_1.Geometry.isSameCoordinate(this.coffs[0], this.coffs[8]))
            return this.coffs[0];
        return undefined;
    }
    /** Sum of squared differences between symmetric pairs */
    sumSkewSquares() {
        return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.coffs[1] - this.coffs[3], this.coffs[2] - this.coffs[6], this.coffs[5] - this.coffs[7]);
    }
    /** Test if the matrix is a pure rotation. */
    isRigid(allowMirror = false) {
        return this.testPerpendicularUnitRowsAndColumns() && (allowMirror || this.determinant() > 0);
    }
    /** Test if all rows and columns are perpendicular to each other and have equal length.
     * If so, the length (or its negative) is the scale factor from a set of rigid axes to these axes.
     * * result.rigidAxes is the rigid axes (with the scale factor removed)
     * * result.scale is the scale factor
     */
    factorRigidWithSignedScale() {
        const product = this.multiplyMatrixMatrixTranspose(this);
        const ss = product.sameDiagonalScale();
        if (ss === undefined || ss <= 0.0)
            return undefined;
        const s = this.determinant() > 0 ? Math.sqrt(ss) : -Math.sqrt(ss);
        const divS = 1.0 / s;
        const result = { rigidAxes: this.scaleColumns(divS, divS, divS), scale: s };
        return result;
    }
    /** Test if the matrix is shuffles and negates columns. */
    get isSignedPermutation() {
        let count = 0;
        for (let row = 0; row < 3; row++)
            for (let col = 0; col < 3; col++) {
                const q = this.at(row, col);
                if (q === 0) { // This comment makes the block non-empty
                }
                else if (q === 1 || q === -1) {
                    // the rest of this row and column should be 0.
                    // "at" will apply cyclic indexing.
                    count++;
                    if (this.at(row + 1, col) !== 0)
                        return false;
                    if (this.at(row + 2, col) !== 0)
                        return false;
                    if (this.at(row, col + 1) !== 0)
                        return false;
                    if (this.at(row, col + 2) !== 0)
                        return false;
                }
                else { // entry is not from 0,1,-1 . . .
                    return false;
                }
            }
        return count === 3;
    }
    /** Test if all rows and columns are length 1 and are perpendicular to each other.  (I.e. the matrix is either a pure rotation with uniform scale factor of 1 or -1) */
    testPerpendicularUnitRowsAndColumns() {
        const product = this.multiplyMatrixMatrixTranspose(this);
        return product.isIdentity;
    }
    /** create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse)
     * vectorA is placed in the first column of the axis order.
     * vectorB is projected perpendicular to vectorA within their plane and placed in the second column.
     */
    static createRigidFromColumns(vectorA, vectorB, axisOrder, result) {
        const vectorA1 = vectorA.normalize();
        if (vectorA1) {
            const vectorC1 = vectorA1.unitCrossProduct(vectorB);
            if (vectorC1) {
                const vectorB1 = vectorC1.unitCrossProduct(vectorA);
                if (vectorB1) {
                    const retVal = Matrix3d.createShuffledColumns(vectorA1, vectorB1, vectorC1, axisOrder, result);
                    retVal.setupInverseTranspose();
                    return retVal;
                }
            }
        }
        return undefined;
    }
    /** create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse)
     * columns are taken from the source Matrix3d in order indicated by the axis order.
     */
    static createRigidFromMatrix3d(source, axisOrder = Geometry_1.AxisOrder.XYZ, result) {
        result = source.clone(result);
        result.axisOrderCrossProductsInPlace(axisOrder);
        if (result.normalizeColumnsInPlace())
            return result;
        return undefined;
    }
    static computeQuatTerm(numerator, denomCoff, reciprocal, diagSum) {
        let coff;
        const diagTol = 0.500;
        if (diagSum > diagTol) {
            coff = Math.sqrt(diagSum) * 0.5;
            if (denomCoff * numerator < 0.0)
                coff = -coff;
        }
        else {
            coff = numerator * reciprocal;
        }
        return coff;
    }
    /** create a matrix from a quaternion.
     * WARNING: There is frequent confusion over whether a "from quaternion" matrix is organized by rows and columns.
     * WARNING: If you find that the matrix seems to rotate by the opposite angle expect it, transpose it.
     */
    static createFromQuaternion(quat) {
        const qqx = quat.x * quat.x;
        const qqy = quat.y * quat.y;
        const qqz = quat.z * quat.z;
        const qqw = quat.w * quat.w;
        const mag2 = qqx + qqy + qqz + qqw;
        if (mag2 === 0.0) {
            return Matrix3d.createIdentity();
        }
        else {
            const a = 1.0 / mag2;
            const matrix = Matrix3d.createRowValues(a * (qqw + qqx - qqy - qqz), 2.0 * a * (quat.w * quat.z + quat.x * quat.y), 2.0 * a * (quat.x * quat.z - quat.w * quat.y), 2.0 * a * (quat.x * quat.y - quat.w * quat.z), a * (qqw - qqx + qqy - qqz), 2.0 * a * (quat.w * quat.x + quat.y * quat.z), 2.0 * a * (quat.x * quat.z + quat.w * quat.y), 2.0 * a * (quat.y * quat.z - quat.w * quat.x), a * (qqw - qqx - qqy + qqz));
            return matrix;
        }
    }
    /** convert the matrix to a quaternion.
     * @note This calculation requires the matrix to have unit length rows and columns.
     * WARNING: There is frequent confusion over whether a "from quaternion" matrix is organized by rows and columns.
     * WARNING: If you find that the matrix seems to rotate by the opposite angle expect it, transpose it.
     */
    toQuaternion() {
        const result = Point4d_1.Point4d.createZero();
        const props = [[this.coffs[0], this.coffs[3], this.coffs[6]],
            [this.coffs[1], this.coffs[4], this.coffs[7]],
            [this.coffs[2], this.coffs[5], this.coffs[8]]];
        const xx = props[0][0];
        const yy = props[1][1];
        const zz = props[2][2];
        const dSum = [];
        let denom, maxIndex, i;
        dSum[0] = 1.0 + xx - yy - zz;
        dSum[1] = 1.0 - xx + yy - zz;
        dSum[2] = 1.0 - xx - yy + zz;
        dSum[3] = 1.0 + xx + yy + zz;
        maxIndex = 0;
        for (i = 1; i < 4; i++) {
            if (dSum[i] > dSum[maxIndex])
                maxIndex = i;
        }
        if (maxIndex === 0) {
            result.x = 0.5 * Math.sqrt(dSum[0]);
            denom = 1.0 / (4.0 * result.x);
            result.y = Matrix3d.computeQuatTerm(props[0][1] + props[1][0], result.x, denom, dSum[1]);
            result.z = Matrix3d.computeQuatTerm(props[0][2] + props[2][0], result.x, denom, dSum[2]);
            result.w = Matrix3d.computeQuatTerm(props[2][1] - props[1][2], result.x, denom, dSum[3]);
        }
        else if (maxIndex === 1) {
            result.y = 0.5 * Math.sqrt(dSum[1]);
            denom = 1.0 / (4.0 * result.y);
            result.x = Matrix3d.computeQuatTerm(props[0][1] + props[1][0], result.y, denom, dSum[0]);
            result.z = Matrix3d.computeQuatTerm(props[1][2] + props[2][1], result.y, denom, dSum[2]);
            result.w = Matrix3d.computeQuatTerm(props[0][2] - props[2][0], result.y, denom, dSum[3]);
        }
        else if (maxIndex === 2) {
            result.z = 0.5 * Math.sqrt(dSum[2]);
            denom = 1.0 / (4.0 * result.z);
            result.x = Matrix3d.computeQuatTerm(props[0][2] + props[2][0], result.z, denom, dSum[0]);
            result.y = Matrix3d.computeQuatTerm(props[1][2] + props[2][1], result.z, denom, dSum[1]);
            result.w = Matrix3d.computeQuatTerm(props[1][0] - props[0][1], result.z, denom, dSum[3]);
        }
        else {
            result.w = 0.5 * Math.sqrt(dSum[3]);
            denom = 1.0 / (4.0 * result.w);
            result.x = Matrix3d.computeQuatTerm(props[2][1] - props[1][2], result.w, denom, dSum[0]);
            result.y = Matrix3d.computeQuatTerm(props[0][2] - props[2][0], result.w, denom, dSum[1]);
            result.z = Matrix3d.computeQuatTerm(props[1][0] - props[0][1], result.w, denom, dSum[2]);
        }
        return result;
    }
}
exports.Matrix3d = Matrix3d;
/** Control flag for whether this class uses cached inverse of matrices. */
Matrix3d.useCachedInverse = true; // cached inverse can be suppressed for testing.
/** total number of times a cached inverse was used to avoid recompute */
Matrix3d.numUseCache = 0;
/** total number of times a cached inverse was computed. */
Matrix3d.numComputeCache = 0;


/***/ }),

/***/ "./lib/geometry3d/OrderedRotationAngles.js":
/*!*************************************************!*\
  !*** ./lib/geometry3d/OrderedRotationAngles.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
/**
 * * OrderedRotationAngles represents a non-trivial rotation using three simple axis rotation angles, and an order in which to apply them.
 * * This class accommodates application-specific interpretation of "Multiplying 3 rotation matrices" with regard to
 *   * Whether a "vector" is a "row" or a "column"
 *   * The order in which the X,Y, Z rotations are applied.
 * * Within the imodel geometry library, the preferred rotation order is encapsulated in `YawPitchRollAngles`.
 * @alpha
 */
class OrderedRotationAngles {
    constructor(x, y, z, axisOrder) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = axisOrder;
    }
    /** (Property accessor) Return the `AxisOrder` controlling matrix multiplication order. */
    get order() { return this._order; }
    /** (Property accessor) Return the strongly typed angle of rotation around x. */
    get xAngle() { return this._x.clone(); }
    /** (Property accessor) Return the strongly typed angle of rotation around y. */
    get yAngle() { return this._y.clone(); }
    /** (Property accessor) Return the strongly typed angle of rotation around z. */
    get zAngle() { return this._z.clone(); }
    /** (Property accessor) Return the angle of rotation around x, in degrees */
    get xDegrees() { return this._x.degrees; }
    /** (Property accessor) Return the angle of rotation around y, in degrees */
    get xRadians() { return this._x.radians; }
    /** (Property accessor) Return the angle of rotation around z, in degrees */
    get yDegrees() { return this._y.degrees; }
    /** (Property accessor) Return the angle of rotation around x, in radians */
    get yRadians() { return this._y.radians; }
    /** (Property accessor) Return the angle of rotation around y, in radians */
    get zDegrees() { return this._z.degrees; }
    /** (Property accessor) Return the angle of rotation around z, in radians */
    get zRadians() { return this._z.radians; }
    /** (Property accessor) flag controlling whether vectors are treated as rows or as columns */
    static get treatVectorsAsColumns() { return OrderedRotationAngles._sTreatVectorsAsColumns; }
    /** (Property set) flag controlling whether vectors are treated as rows or as columns */
    static set treatVectorsAsColumns(value) { OrderedRotationAngles._sTreatVectorsAsColumns = value; }
    /** Create an OrderedRotationAngles from three angles and an ordering in which to apply them when rotating.
     * @param xRotation rotation around x
     * @param yRotation rotation around y
     * @param zRotation rotation around z
     * @param axisOrder right to left order of axis names identifies the order that rotations are applied to xyz data.
     */
    static createAngles(xRotation, yRotation, zRotation, order, result) {
        if (result) {
            result._x.setFrom(xRotation);
            result._y.setFrom(yRotation);
            result._z.setFrom(zRotation);
            result._order = order;
            return result;
        }
        return new OrderedRotationAngles(xRotation.clone(), yRotation.clone(), zRotation.clone(), order);
    }
    /** Create an OrderedRotationAngles from three angles (in radians) and an ordering in which to apply them when rotating. */
    static createRadians(xRadians, yRadians, zRadians, order, result) {
        if (result) {
            result._x.setRadians(xRadians);
            result._y.setRadians(yRadians);
            result._z.setRadians(zRadians);
            result._order = order;
            return result;
        }
        return new OrderedRotationAngles(Angle_1.Angle.createRadians(xRadians), Angle_1.Angle.createRadians(yRadians), Angle_1.Angle.createRadians(zRadians), order);
    }
    /** Create an OrderedRotationAngles from three angles (in degrees) and an ordering in which to apply them when rotating. */
    static createDegrees(xDegrees, yDegrees, zDegrees, order, result) {
        if (result) {
            result._x.setDegrees(xDegrees);
            result._y.setDegrees(yDegrees);
            result._z.setDegrees(zDegrees);
            result._order = order;
            return result;
        }
        return new OrderedRotationAngles(Angle_1.Angle.createDegrees(xDegrees), Angle_1.Angle.createDegrees(yDegrees), Angle_1.Angle.createDegrees(zDegrees), order);
    }
    /** Create an OrderedRotationAngles from a 3x3 rotational matrix, given the ordering of axis rotations that the matrix derives from. */
    static createFromMatrix3d(matrix, order, result) {
        let m11 = matrix.coffs[0], m12 = matrix.coffs[3], m13 = matrix.coffs[6];
        let m21 = matrix.coffs[1], m22 = matrix.coffs[4], m23 = matrix.coffs[7];
        let m31 = matrix.coffs[2], m32 = matrix.coffs[5], m33 = matrix.coffs[8];
        if (OrderedRotationAngles.treatVectorsAsColumns) {
            // the formulas are from row order .. flip the mIJ
            m11 = matrix.coffs[0], m12 = matrix.coffs[1], m13 = matrix.coffs[2];
            m21 = matrix.coffs[3], m22 = matrix.coffs[4], m23 = matrix.coffs[5];
            m31 = matrix.coffs[6], m32 = matrix.coffs[7], m33 = matrix.coffs[8];
        }
        let xRad;
        let yRad;
        let zRad;
        switch (order) {
            case Geometry_1.AxisOrder.XYZ: {
                yRad = Math.asin(Math.max(-1, Math.min(1, m13)));
                if (Math.abs(m13) < 0.99999) {
                    xRad = Math.atan2(-m23, m33);
                    zRad = Math.atan2(-m12, m11);
                }
                else {
                    xRad = Math.atan2(m32, m22);
                    zRad = 0;
                }
                break;
            }
            case Geometry_1.AxisOrder.YXZ: {
                xRad = Math.asin(-Math.max(-1, Math.min(1, m23)));
                if (Math.abs(m23) < 0.99999) {
                    yRad = Math.atan2(m13, m33);
                    zRad = Math.atan2(m21, m22);
                }
                else {
                    yRad = Math.atan2(-m31, m11);
                    zRad = 0;
                }
                break;
            }
            case Geometry_1.AxisOrder.ZXY: {
                xRad = Math.asin(Math.max(-1, Math.min(1, m32)));
                if (Math.abs(m32) < 0.99999) {
                    yRad = Math.atan2(-m31, m33);
                    zRad = Math.atan2(-m12, m22);
                }
                else {
                    yRad = 0;
                    zRad = Math.atan2(m21, m11);
                }
                break;
            }
            case Geometry_1.AxisOrder.ZYX: {
                yRad = -Math.asin(Math.max(-1, Math.min(1, m31)));
                if (Math.abs(m31) < 0.99999) {
                    xRad = Math.atan2(m32, m33);
                    zRad = Math.atan2(m21, m11);
                }
                else {
                    xRad = 0;
                    zRad = Math.atan2(-m12, m22);
                }
                break;
            }
            case Geometry_1.AxisOrder.YZX: {
                zRad = Math.asin(Math.max(-1, Math.min(1, m21)));
                if (Math.abs(m21) < 0.99999) {
                    xRad = Math.atan2(-m23, m22);
                    yRad = Math.atan2(-m31, m11);
                }
                else {
                    xRad = 0;
                    yRad = Math.atan2(m13, m33);
                }
                break;
            }
            case Geometry_1.AxisOrder.XZY: {
                zRad = -Math.asin(Math.max(-1, Math.min(1, m12)));
                if (Math.abs(m12) < 0.99999) {
                    xRad = Math.atan2(m32, m22);
                    yRad = Math.atan2(m13, m11);
                }
                else {
                    xRad = Math.atan2(-m23, m33);
                    yRad = 0;
                }
                break;
            }
            default: {
                xRad = yRad = zRad = 0;
            }
        }
        if (OrderedRotationAngles.treatVectorsAsColumns)
            return OrderedRotationAngles.createRadians(-xRad, -yRad, -zRad, order, result);
        return OrderedRotationAngles.createRadians(xRad, yRad, zRad, order, result);
    }
    /** Create a 3x3 rotational matrix from this OrderedRotationAngles. */
    toMatrix3d(result) {
        const rot = result !== undefined ? result : new Matrix3d_1.Matrix3d();
        const axisOrder = this.order;
        const x = this.xAngle, y = this.yAngle, z = this.zAngle;
        const a = x.cos();
        let b = x.sin();
        const c = y.cos();
        let d = y.sin();
        const e = z.cos();
        let f = z.sin();
        if (OrderedRotationAngles.treatVectorsAsColumns) {
            b = -b;
            d = -d;
            f = -f;
        }
        if (axisOrder === Geometry_1.AxisOrder.XYZ) {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            rot.setRowValues(c * e, af + be * d, bf - ae * d, -c * f, ae - bf * d, be + af * d, d, -b * c, a * c);
        }
        else if (axisOrder === Geometry_1.AxisOrder.YXZ) {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            rot.setRowValues(ce + df * b, a * f, cf * b - de, de * b - cf, a * e, df + ce * b, a * d, -b, a * c);
        }
        else if (axisOrder === Geometry_1.AxisOrder.ZXY) {
            const ce = c * e, cf = c * f, de = d * e, df = d * f;
            rot.setRowValues(ce - df * b, cf + de * b, -a * d, -a * f, a * e, b, de + cf * b, df - ce * b, a * c);
        }
        else if (axisOrder === Geometry_1.AxisOrder.ZYX) {
            const ae = a * e, af = a * f, be = b * e, bf = b * f;
            rot.setRowValues(c * e, c * f, -d, be * d - af, bf * d + ae, b * c, ae * d + bf, af * d - be, a * c);
        }
        else if (axisOrder === Geometry_1.AxisOrder.YZX) {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            rot.setRowValues(c * e, f, -d * e, bd - ac * f, a * e, ad * f + bc, bc * f + ad, -b * e, ac - bd * f);
        }
        else if (axisOrder === Geometry_1.AxisOrder.XZY) {
            const ac = a * c, ad = a * d, bc = b * c, bd = b * d;
            rot.setRowValues(c * e, ac * f + bd, bc * f - ad, -f, a * e, b * e, d * e, ad * f - bc, bd * f + ac);
        }
        if (OrderedRotationAngles.treatVectorsAsColumns)
            rot.transposeInPlace();
        return rot;
    }
}
exports.OrderedRotationAngles = OrderedRotationAngles;
OrderedRotationAngles._sTreatVectorsAsColumns = false;


/***/ }),

/***/ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js":
/*!********************************************************!*\
  !*** ./lib/geometry3d/Plane3dByOriginAndUnitNormal.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
/**
 * A plane defined by
 *
 * * Any point on the plane.
 * * a unit normal.
 * @public
 */
class Plane3dByOriginAndUnitNormal {
    // constructor captures references !!!
    constructor(origin, normal) {
        this._origin = origin;
        this._normal = normal;
    }
    // This is private because it does not check validity of the unit vector.
    static _create(x, y, z, u, v, w) {
        return new Plane3dByOriginAndUnitNormal(Point3dVector3d_1.Point3d.create(x, y, z), Point3dVector3d_1.Vector3d.create(u, v, w));
    }
    /**
     * Create a plane parallel to the XY plane
     * @param origin optional plane origin.  If omitted, the origin is placed at 000
     */
    static createXYPlane(origin) {
        if (origin)
            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 0, 1);
        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 0, 1);
    }
    /**
     * Create a plane parallel to the YZ plane
     * @param origin optional plane origin.  If omitted, the origin is placed at 000
     */
    static createYZPlane(origin) {
        if (origin)
            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 1, 0, 0);
        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 1, 0, 0);
    }
    /**
     * Create a plane parallel to the ZX plane
     * @param origin optional plane origin.  If omitted, the origin is placed at 000
     */
    static createZXPlane(origin) {
        if (origin)
            return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 1, 0);
        return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 1, 0);
    }
    /** create a new  Plane3dByOriginAndUnitNormal with given origin and normal.
     * * The inputs are NOT captured.
     * * Returns undefined if the normal vector is all zeros.
     */
    static create(origin, normal, result) {
        const normalized = normal.normalize();
        if (!normalized)
            return undefined;
        if (result) {
            result.set(origin, normalized);
            return result;
        }
        return new Plane3dByOriginAndUnitNormal(origin.clone(), normalized);
    }
    /** create a new  Plane3dByOriginAndUnitNormal with direct coordinates of origin and normal.
     * * Returns undefined if the normal vector is all zeros.
     * * If unable to normalize return undefined. (And if result is given it is left unchanged)
     */
    static createXYZUVW(ax, ay, az, ux, uy, uz, result) {
        const magU = Geometry_1.Geometry.hypotenuseXYZ(ux, uy, uz);
        if (magU < Geometry_1.Geometry.smallMetricDistance)
            return undefined;
        if (result) {
            result._origin.set(ax, ay, az);
            result._normal.set(ux / magU, uy / magU, uz / magU);
            return result;
        }
        return new Plane3dByOriginAndUnitNormal(Point3dVector3d_1.Point3d.create(ax, ay, az), Point3dVector3d_1.Vector3d.create(ux / magU, uy / magU, uz / magU));
    }
    /** create a new  Plane3dByOriginAndUnitNormal with xy origin (at z=0) and normal angle in xy plane.
     * * Returns undefined if the normal vector is all zeros.
     */
    static createXYAngle(x, y, normalAngleFromX, result) {
        if (result) {
            result._origin.set(x, y, 0.0);
            result._normal.set(normalAngleFromX.cos(), normalAngleFromX.sin(), 0.0);
            return result;
        }
        return new Plane3dByOriginAndUnitNormal(Point3dVector3d_1.Point3d.create(x, y, 0), Point3dVector3d_1.Vector3d.create(normalAngleFromX.cos(), normalAngleFromX.sin()));
    }
    /** Create a plane defined by two points and an in-plane vector.
     * @param pointA any point in the plane
     * @param pointB any other point in the plane
     * @param vector any vector in the plane but not parallel to the vector from pointA to pointB
     */
    static createPointPointVectorInPlane(pointA, pointB, vector) {
        const cross = vector.crossProductStartEnd(pointA, pointB);
        if (cross.tryNormalizeInPlace())
            return new Plane3dByOriginAndUnitNormal(pointA, cross);
        return undefined;
    }
    /** test for (toleranced) equality with `other` */
    isAlmostEqual(other) {
        return this._origin.isAlmostEqual(other._origin) && this._normal.isAlmostEqual(other._normal);
    }
    /** Parse a json fragment `{origin: [x,y,z], normal: [ux,uy,uz]}`  */
    setFromJSON(json) {
        if (!json) {
            this._origin.set(0, 0, 0);
            this._normal.set(0, 0, 1);
        }
        else {
            this._origin.setFromJSON(json.origin);
            this._normal.setFromJSON(json.normal);
        }
    }
    /**
     * Convert to a JSON object.
     * @return {*} [origin,normal]
     */
    toJSON() { return { origin: this._origin.toJSON(), normal: this._normal.toJSON() }; }
    /**  create a new Plane3dByOriginAndUnitNormal from json fragment.
     * * See `Plane3dByOriginAndUnitNormal.setFromJSON`
     */
    static fromJSON(json) {
        const result = Plane3dByOriginAndUnitNormal.createXYPlane();
        result.setFromJSON(json);
        return result;
    }
    /** Return a reference to the origin. */
    getOriginRef() { return this._origin; }
    /** Return a reference to the unit normal. */
    getNormalRef() { return this._normal; }
    /** Return coordinate axes (as a transform) with
     * * origin at plane origin
     * * z axis in direction of plane normal.
     * * x,y axes in plane.
     */
    getLocalToWorld() {
        const axes = Matrix3d_1.Matrix3d.createRigidHeadsUp(this._normal, Geometry_1.AxisOrder.ZXY);
        return Transform_1.Transform.createRefs(this._origin.clone(), axes);
    }
    /** Return a (singular) transform which projects points to this plane.
     */
    getProjectionToPlane() {
        const axes = Matrix3d_1.Matrix3d.createIdentity();
        axes.addScaledOuterProductInPlace(this._normal, this._normal, -1.0);
        axes.markSingular();
        return Transform_1.Transform.createFixedPointAndMatrix(this._origin, axes);
    }
    /** Copy coordinates from the given origin and normal. */
    set(origin, normal) {
        this._origin.setFrom(origin);
        this._normal.setFrom(normal);
    }
    /** return a deep clone (point and normal cloned) */
    clone(result) {
        if (result) {
            result.set(this._origin, this._normal);
            return result;
        }
        return new Plane3dByOriginAndUnitNormal(this._origin.clone(), this._normal.clone());
    }
    /** Create a clone and return the transform of the clone. */
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyPoint3d(result._origin, result._origin);
        if (transform.matrix.multiplyInverseTranspose(result._normal, result._normal) !== undefined
            && result._normal.normalizeInPlace())
            return result;
        return undefined;
    }
    /** Copy data from the given plane. */
    setFrom(source) {
        this.set(source._origin, source._normal);
    }
    /** Return the altitude of spacePoint above or below the plane.  (Below is negative) */
    altitude(spacePoint) { return this._normal.dotProductStartEnd(this._origin, spacePoint); }
    /** Return the altitude of weighted spacePoint above or below the plane.  (Below is negative) */
    weightedAltitude(spacePoint) {
        return this._normal.dotProductStart3dEnd4d(this._origin, spacePoint);
    }
    /** return a point at specified (signed) altitude */
    altitudeToPoint(altitude, result) {
        return this._origin.plusScaled(this._normal, altitude, result);
    }
    /** Return the dot product of spaceVector with the plane's unit normal.  This tells the rate of change of altitude
     * for a point moving at speed one along the spaceVector.
     */
    velocityXYZ(x, y, z) { return this._normal.dotProductXYZ(x, y, z); }
    /** Return the dot product of spaceVector with the plane's unit normal.  This tells the rate of change of altitude
     * for a point moving at speed one along the spaceVector.
     */
    velocity(spaceVector) { return this._normal.dotProduct(spaceVector); }
    /** Return the altitude of a point given as separate x,y,z components. */
    altitudeXYZ(x, y, z) {
        return this._normal.dotProductStartEndXYZ(this._origin, x, y, z);
    }
    /** Return the altitude of a point given as separate x,y,z,w components. */
    altitudeXYZW(x, y, z, w) {
        return this._normal.dotProductStartEndXYZW(this._origin, x, y, z, w);
    }
    /** Return the projection of spacePoint onto the plane. */
    projectPointToPlane(spacePoint, result) {
        return spacePoint.plusScaled(this._normal, -this._normal.dotProductStartEnd(this._origin, spacePoint), result);
    }
    /** Returns true of spacePoint is within distance tolerance of the plane. */
    isPointInPlane(spacePoint) { return Geometry_1.Geometry.isSmallMetricDistance(this.altitude(spacePoint)); }
}
exports.Plane3dByOriginAndUnitNormal = Plane3dByOriginAndUnitNormal;


/***/ }),

/***/ "./lib/geometry3d/Plane3dByOriginAndVectors.js":
/*!*****************************************************!*\
  !*** ./lib/geometry3d/Plane3dByOriginAndVectors.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * A Point3dVector3dVector3d is an origin and a pair of vectors.
 * This defines a plane with a (possibly skewed) uv coordinate grid
 * * The grid directions (`vectorU` and `vectorV`)
 *   * are NOT required to be unit vectors.
 *   * are NOT required to be perpendicular vectors.
 * @public
 */
class Plane3dByOriginAndVectors {
    constructor(origin, vectorU, vectorV) {
        this.origin = origin;
        this.vectorU = vectorU;
        this.vectorV = vectorV;
    }
    /** create a new plane from origin and vectors. */
    static createOriginAndVectors(origin, vectorU, vectorV, result) {
        if (result) {
            result.origin.setFrom(origin);
            result.vectorU.setFrom(vectorU);
            result.vectorV.setFrom(vectorV);
            return result;
        }
        return new Plane3dByOriginAndVectors(origin.clone(), vectorU.clone(), vectorV.clone());
    }
    /**
     * Return a Plane3dByOriginAndVectors, with
     * * origin is the translation (aka origin) from the Transform
     * * vectorU is the X column of the transform
     * * vectorV is the Y column of the transform.
     * @param transform source transform
     * @param xLength optional length to impose on vectorU.
     * @param yLength optional length to impose on vectorV.
     * @param result optional preexisting result
     */
    static createFromTransformColumnsXYAndLengths(transform, xLength, yLength, result) {
        if (result) {
            result.origin.setFrom(transform.getOrigin());
            transform.matrix.columnX(result.vectorU);
            transform.matrix.columnY(result.vectorV);
        }
        else {
            result = new Plane3dByOriginAndVectors(transform.getOrigin(), transform.matrix.columnX(), transform.matrix.columnY());
        }
        if (xLength !== undefined)
            result.vectorU.scaleToLength(xLength, result.vectorU);
        if (yLength !== undefined)
            result.vectorV.scaleToLength(yLength, result.vectorV);
        return result;
    }
    /** Capture origin and directions in a new plane. */
    static createCapture(origin, vectorU, vectorV, result) {
        if (!result)
            return new Plane3dByOriginAndVectors(origin, vectorU, vectorV);
        result.origin = origin;
        result.vectorU = vectorU;
        result.vectorV = vectorV;
        return result;
    }
    /** Set all origin and both vectors from direct numeric parameters */
    setOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz) {
        this.origin.set(x0, y0, z0);
        this.vectorU.set(ux, uy, uz);
        this.vectorV.set(vx, vy, vz);
        return this;
    }
    /** Set all origin and both vectors from coordinates in given origin and vectors.
     * * Note that coordinates are copied out of the parameters -- the given parameters are NOT retained by reference.
     */
    setOriginAndVectors(origin, vectorU, vectorV) {
        this.origin.setFrom(origin);
        this.vectorU.setFrom(vectorU);
        this.vectorV.setFrom(vectorV);
        return this;
    }
    /** Create a new plane from direct numeric parameters */
    static createOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz, result) {
        if (result)
            return result.setOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz);
        return new Plane3dByOriginAndVectors(Point3dVector3d_1.Point3d.create(x0, y0, z0), Point3dVector3d_1.Vector3d.create(ux, uy, uz), Point3dVector3d_1.Vector3d.create(vx, vy, vz));
    }
    /** Define a plane by three points in the plane.
     * @param origin origin for the parameterization.
     * @param targetU target point for the vectorU starting at the origin.
     * @param targetV target point for the vectorV originating at the origin.
     * @param result optional result.
     */
    static createOriginAndTargets(origin, targetU, targetV, result) {
        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin.x, origin.y, origin.z, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, result);
    }
    /** Create a plane with origin at 000, unit vectorU in x direction, and unit vectorV in the y direction. */
    static createXYPlane(result) {
        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(0, 0, 0, 1, 0, 0, 0, 1, 0, result);
    }
    /** create a plane from data presented as Float64Arrays.
     * @param origin x,y,z of origin.
     * @param vectorU x,y,z of vectorU
     * @param vectorV x,y,z of vectorV
     */
    static createOriginAndVectorsArrays(origin, vectorU, vectorV, result) {
        return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin[0], origin[1], origin[2], vectorU[0], vectorU[1], vectorU[2], vectorV[0], vectorV[1], vectorV[2], result);
    }
    /** create a plane from data presented as Float64Array with weights
     * @param origin x,y,z,w of origin.
     * @param vectorU x,y,z,w of vectorU
     * @param vectorV x,y,z,w of vectorV
     */
    static createOriginAndVectorsWeightedArrays(originW, vectorUw, vectorVw, result) {
        const w = originW[3];
        result = Plane3dByOriginAndVectors.createXYPlane(result);
        if (Geometry_1.Geometry.isSmallMetricDistance(w))
            return result;
        const dw = 1.0 / w;
        const au = vectorUw[3] * dw * dw;
        const av = vectorVw[3] * dw * dw;
        // for homogeneous function X, with w its weight:
        // (X/w) is the cartesian point.
        // (X/w)' = (X' w - X w')/(w*w)
        //        = X'/w  - (X/w)(w'/w)
        //        = X'/w  - X w'/w^2)
        // The w parts of the formal xyzw sums are identically 0.
        // Here the X' and its w' are taken from each vectorUw and vectorVw
        result.origin.set(originW[0] * dw, originW[1] * dw, originW[2] * dw);
        Point3dVector3d_1.Vector3d.createAdd2ScaledXYZ(vectorUw[0], vectorUw[1], vectorUw[2], dw, originW[0], originW[1], originW[2], -au, result.vectorU);
        Point3dVector3d_1.Vector3d.createAdd2ScaledXYZ(vectorVw[0], vectorVw[1], vectorVw[2], dw, originW[0], originW[1], originW[2], -av, result.vectorV);
        return result;
    }
    /**
     * Evaluate a point a grid coordinates on the plane.
     * * The computed point is `origin + vectorU * u + vectorV * v`
     * @param u coordinate along vectorU
     * @param v coordinate along vectorV
     * @param result optional result destination.
     * @returns Return the computed coordinate.
     */
    fractionToPoint(u, v, result) {
        return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);
    }
    /** Return the vector from the plane origin to parametric coordinate (u.v) */
    fractionToVector(u, v, result) {
        return Point3dVector3d_1.Vector3d.createAdd2Scaled(this.vectorU, u, this.vectorV, v, result);
    }
    /** Set coordinates from a json object such as `{origin: [1,2,3], vectorU:[4,5,6], vectorV[3,2,1]}` */
    setFromJSON(json) {
        if (!json || !json.origin || !json.vectorV) {
            this.origin.set(0, 0, 0);
            this.vectorU.set(1, 0, 0);
            this.vectorV.set(0, 1, 0);
        }
        else {
            this.origin.setFromJSON(json.origin);
            this.vectorU.setFromJSON(json.vectorU);
            this.vectorV.setFromJSON(json.vectorV);
        }
    }
    /**
     * Convert an Angle to a JSON object.
     * @return {*} [origin,normal]
     */
    toJSON() {
        return {
            origin: this.origin.toJSON(),
            vectorU: this.vectorU.toJSON(),
            vectorV: this.vectorV.toJSON(),
        };
    }
    /** create a new plane.   See `setFromJSON` for layout example. */
    static fromJSON(json) {
        const result = Plane3dByOriginAndVectors.createXYPlane();
        result.setFromJSON(json);
        return result;
    }
    /** Test origin and vectors for isAlmostEqual with `other` */
    isAlmostEqual(other) {
        return this.origin.isAlmostEqual(other.origin)
            && this.vectorU.isAlmostEqual(other.vectorU)
            && this.vectorV.isAlmostEqual(other.vectorV);
    }
}
exports.Plane3dByOriginAndVectors = Plane3dByOriginAndVectors;


/***/ }),

/***/ "./lib/geometry3d/Point2dArrayCarrier.js":
/*!***********************************************!*\
  !*** ./lib/geometry3d/Point2dArrayCarrier.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module CartesianGeometry */
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:variable-name jsdoc-format no-empty */
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const IndexedXYCollection_1 = __webpack_require__(/*! ./IndexedXYCollection */ "./lib/geometry3d/IndexedXYCollection.js");
/**
 * Helper object to access members of a Point2d[] in geometric calculations.
 * * The collection holds only a reference to the actual array.
 * * The actual array may be replaced by the user as needed.
 * * When replaced, there is no cached data to be updated.
 * @public
*/
class Point2dArrayCarrier extends IndexedXYCollection_1.IndexedXYCollection {
    /** CAPTURE caller supplied array ... */
    constructor(data) {
        super();
        this.data = data;
    }
    /** test if index is valid  */
    isValidIndex(index) {
        return index >= 0 && index < this.data.length;
    }
    /**
     * Access by index, returning strongly typed Point2d
     * @param index index of point within the array
     * @param result caller-allocated destination
     * @returns undefined if the index is out of bounds
     */
    getPoint2dAtCheckedPointIndex(index, result) {
        if (this.isValidIndex(index)) {
            const source = this.data[index];
            return Point2dVector2d_1.Point2d.create(source.x, source.y, result);
        }
        return undefined;
    }
    /**
     * Access by index, returning strongly typed Vector2d
     * @param index index of point within the array
     * @param result caller-allocated destination
     * @returns undefined if the index is out of bounds
     */
    getVector2dAtCheckedVectorIndex(index, result) {
        if (this.isValidIndex(index)) {
            const source = this.data[index];
            return Point2dVector2d_1.Vector2d.create(source.x, source.y, result);
        }
        return undefined;
    }
    /**
     * Return a vector from the point at indexA to the point at indexB
     * @param indexA index of point within the array
     * @param indexB index of point within the array
     * @param result caller-allocated vector.
     * @returns undefined if either index is out of bounds
     */
    vectorIndexIndex(indexA, indexB, result) {
        if (this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return Point2dVector2d_1.Vector2d.createStartEnd(this.data[indexA], this.data[indexB], result);
        return undefined;
    }
    /**
     * Return a vector from given origin to point at indexB
     * @param origin origin for vector
     * @param indexB index of point within the array
     * @param result caller-allocated vector.
     * @returns undefined if index is out of bounds
     */
    vectorXAndYIndex(origin, indexB, result) {
        if (this.isValidIndex(indexB))
            return Point2dVector2d_1.Vector2d.createStartEnd(origin, this.data[indexB], result);
        return undefined;
    }
    /**
     * Return the cross product of vectors from origin to points at indexA and indexB
     * @param origin origin for vector
     * @param indexA index of first target within the array
     * @param indexB index of second target within the array
     * @param result caller-allocated vector.
     * @returns undefined if either index is out of bounds
     */
    crossProductXAndYIndexIndex(origin, indexA, indexB) {
        if (this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return Point2dVector2d_1.XY.crossProductToPoints(origin, this.data[indexA], this.data[indexB]);
        return undefined;
    }
    /**
   * Return the cross product of vectors from point at originIndex to points at indexA and indexB
   * @param originIndex index of origin
   * @param indexA index of first target within the array
   * @param indexB index of second target within the array
   * @param result caller-allocated vector.
   * @returns return true if indexA, indexB both valid
   */
    crossProductIndexIndexIndex(originIndex, indexA, indexB) {
        if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return Point2dVector2d_1.XY.crossProductToPoints(this.data[originIndex], this.data[indexA], this.data[indexB]);
        return undefined;
    }
    /**
     * read-only property for number of XYZ in the collection.
     */
    get length() {
        return this.data.length;
    }
}
exports.Point2dArrayCarrier = Point2dArrayCarrier;


/***/ }),

/***/ "./lib/geometry3d/Point2dVector2d.js":
/*!*******************************************!*\
  !*** ./lib/geometry3d/Point2dVector2d.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
// cspell:word JSONXY
// cspell:word CWXY
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
/** Minimal object containing x,y and operations that are meaningful without change in both point and vector.
 *  * `XY` is not instantiable.
 *  * The derived (instantiable) classes are
 *    * `Point2d`
 *    * `Vector2d`
 * @public
 */
class XY {
    constructor(x = 0, y = 0) { this.x = x; this.y = y; }
    /** Set both x and y. */
    set(x = 0, y = 0) { this.x = x; this.y = y; }
    /** Set both x and y to zero */
    setZero() { this.x = 0; this.y = 0; }
    /** Set both x and y from other. */
    setFrom(other) {
        if (other) {
            this.x = other.x;
            this.y = other.y;
        }
        else {
            this.x = 0;
            this.y = 0;
        }
    }
    /** Freeze this instance (and its deep content) so it can be considered read-only */
    freeze() { Object.freeze(this); }
    /** Returns true if this and other have equal x,y parts within Geometry.smallMetricDistance. */
    isAlmostEqual(other, tol) { return Geometry_1.Geometry.isSameCoordinate(this.x, other.x, tol) && Geometry_1.Geometry.isSameCoordinate(this.y, other.y, tol); }
    /** Returns true if this and other have equal x,y parts within Geometry.smallMetricDistance. */
    isAlmostEqualXY(x, y, tol) { return Geometry_1.Geometry.isSameCoordinate(this.x, x, tol) && Geometry_1.Geometry.isSameCoordinate(this.y, y, tol); }
    /** return a json array  `[x,y]`   */
    toJSON() { return [this.x, this.y]; }
    /** return a json object `{x: 1, y:2}`  */
    toJSONXY() { return { x: this.x, y: this.y }; }
    /** Set x and y from a JSON source such as `[1,2]` or `{x:1, y:2}` */
    setFromJSON(json) {
        if (Array.isArray(json)) {
            this.set(json[0] || 0, json[1] || 0);
            return;
        }
        if (json) {
            this.set(json.x || 0, json.y || 0);
            return;
        }
        this.set(0, 0);
    }
    /** Return the distance from this point to other */
    distance(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (Math.sqrt(xDist * xDist + yDist * yDist));
    }
    /** Return squared distance from this point to other */
    distanceSquared(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (xDist * xDist + yDist * yDist);
    }
    /** Return the largest absolute distance between corresponding components */
    maxDiff(other) {
        return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y));
    }
    /** returns true if the x,y components are both small by metric metric tolerance */
    get isAlmostZero() {
        return Geometry_1.Geometry.isSmallMetricDistance(this.x) && Geometry_1.Geometry.isSmallMetricDistance(this.y);
    }
    /** Return the largest absolute value of any component */
    maxAbs() { return Math.max(Math.abs(this.x), Math.abs(this.y)); }
    /** Return the magnitude of the vector */
    magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    /** Return the squared magnitude of the vector.  */
    magnitudeSquared() { return this.x * this.x + this.y * this.y; }
    /** returns true if the x,y components are exactly equal. */
    isExactEqual(other) { return this.x === other.x && this.y === other.y; }
    /** returns true if x,y match `other` within metric tolerance */
    isAlmostEqualMetric(other) { return this.maxDiff(other) <= Geometry_1.Geometry.smallMetricDistance; }
    /** Return a (full length) vector from this point to other */
    vectorTo(other, result) {
        return Vector2d.create(other.x - this.x, other.y - this.y, result);
    }
    /** Return a unit vector from this point to other */
    unitVectorTo(target, result) {
        return this.vectorTo(target, result).normalize(result);
    }
    /** cross product of vectors from origin to targets */
    static crossProductToPoints(origin, targetA, targetB) {
        return Geometry_1.Geometry.crossProductXYXY(targetA.x - origin.x, targetA.y - origin.y, targetB.x - origin.x, targetB.y - origin.y);
    }
}
exports.XY = XY;
/** 2D point with `x`,`y` as properties
 * @public
 */
class Point2d extends XY {
    /** Constructor for Point2d */
    constructor(x = 0, y = 0) { super(x, y); }
    /** return a new Point2d with x,y coordinates from this. */
    clone() { return new Point2d(this.x, this.y); }
    /**
     * Return a point (newly created unless result provided) with given x,y coordinates
     * @param x x coordinate
     * @param y y coordinate
     * @param result optional result
     */
    static create(x = 0, y = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            return result;
        }
        return new Point2d(x, y);
    }
    /** Convert JSON `[1,2]` or `{x:1, y:2}` to a Point2d instance */
    static fromJSON(json) { const val = new Point2d(); val.setFromJSON(json); return val; }
    /** Create (or optionally reuse) a Point2d from another object with fields x and y */
    static createFrom(xy, result) {
        if (xy)
            return Point2d.create(xy.x, xy.y, result);
        return Point2d.create(0, 0, result);
    }
    /** Create a Point2d with both coordinates zero. */
    static createZero(result) { return Point2d.create(0, 0, result); }
    /** Starting at this point, move along vector by tangentFraction of the vector length, and to the left by leftFraction of
     * the perpendicular vector length.
     * @param tangentFraction distance to move along the vector, as a fraction of vector
     * @param leftFraction distance to move perpendicular to the vector, as a fraction of the rotated vector
     */
    addForwardLeft(tangentFraction, leftFraction, vector) {
        const dx = vector.x;
        const dy = vector.y;
        return Point2d.create(this.x + tangentFraction * dx - leftFraction * dy, this.y + tangentFraction * dy + leftFraction * dx);
    }
    /** Interpolate at tangentFraction between this instance and point.   Move by leftFraction along the xy perpendicular
     * of the vector between the points.
     */
    forwardLeftInterpolate(tangentFraction, leftFraction, point) {
        const dx = point.x - this.x;
        const dy = point.y - this.y;
        return Point2d.create(this.x + tangentFraction * dx - leftFraction * dy, this.y + tangentFraction * dy + leftFraction * dx);
    }
    /** Return a point interpolated between this point and the right param. */
    interpolate(fraction, other, result) {
        if (fraction <= 0.5)
            return Point2d.create(this.x + fraction * (other.x - this.x), this.y + fraction * (other.y - this.y), result);
        const t = fraction - 1.0;
        return Point2d.create(other.x + t * (other.x - this.x), other.y + t * (other.y - this.y), result);
    }
    /** Return a point with independent x,y fractional interpolation. */
    interpolateXY(fractionX, fractionY, other, result) {
        return Point2d.create(Geometry_1.Geometry.interpolate(this.x, fractionX, other.x), Geometry_1.Geometry.interpolate(this.y, fractionY, other.y), result);
    }
    /** Return this point minus vector */
    minus(vector, result) {
        return Point2d.create(this.x - vector.x, this.y - vector.y, result);
    }
    /** Return point plus vector */
    plus(vector, result) {
        return Point2d.create(this.x + vector.x, this.y + vector.y, result);
    }
    /** Return point plus vector */
    plusXY(dx = 0, dy = 0, result) {
        return Point2d.create(this.x + dx, this.y + dy, result);
    }
    /** Return point + vector * scalar */
    plusScaled(vector, scaleFactor, result) {
        return Point2d.create(this.x + vector.x * scaleFactor, this.y + vector.y * scaleFactor, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point2d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB, this.y + vectorA.y * scalarA + vectorB.y * scalarB, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point2d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC, this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC, result);
    }
    /**
     * Return the dot product of vector from this to targetA and vector from this to targetB
     * @param targetA target of first vector
     * @param targetB target of second vector
     */
    dotVectorsToTargets(targetA, targetB) {
        return (targetA.x - this.x) * (targetB.x - this.x) +
            (targetA.y - this.y) * (targetB.y - this.y);
    }
    /** Returns the (scalar) cross product of two points/vectors, computed from origin to target1 and target2 */
    crossProductToPoints(target1, target2) {
        const x1 = target1.x - this.x;
        const y1 = target1.y - this.y;
        const x2 = target2.x - this.x;
        const y2 = target2.y - this.y;
        return x1 * y2 - y1 * x2;
    }
    /** Return the fractional coordinate of the projection of this instance x,y onto the line from startPoint to endPoint.
     * @param startPoint start point of line
     * @param endPoint end point of line
     * @param defaultFraction fraction to return if startPoint and endPoint are equal.
     */
    fractionOfProjectionToLine(startPoint, endPoint, defaultFraction) {
        const denominator = startPoint.distanceSquared(endPoint);
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction ? defaultFraction : 0;
        return startPoint.dotVectorsToTargets(endPoint, this) / denominator;
    }
}
exports.Point2d = Point2d;
/** 2D vector with `x`,`y` as properties
 * @public
 */
class Vector2d extends XY {
    constructor(x = 0, y = 0) { super(x, y); }
    /** Return a new Vector2d with the same x,y */
    clone() { return new Vector2d(this.x, this.y); }
    /** Return a new Vector2d with given x and y */
    static create(x = 0, y = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            return result;
        }
        return new Vector2d(x, y);
    }
    /** Return a (new) Vector2d with components 1,0 */
    static unitX(scale = 1) { return new Vector2d(scale, 0); }
    /** Return a (new) Vector2d with components 0,1 */
    static unitY(scale = 1) { return new Vector2d(0, scale); }
    /** Return a Vector2d with components 0,0 */
    static createZero(result) { return Vector2d.create(0, 0, result); }
    /** copy contents from another Point3d, Point2d, Vector2d, or Vector3d, or leading entries of Float64Array */
    static createFrom(data, result) {
        if (data instanceof Float64Array) {
            if (data.length >= 2)
                return Vector2d.create(data[0], data[1]);
            if (data.length >= 1)
                return Vector2d.create(data[0], 0);
            return Vector2d.create(0, 0);
        }
        return Vector2d.create(data.x, data.y, result);
    }
    /** Return a new Vector2d from json structured as `[1,2]` or `{x:1,y:2}` */
    static fromJSON(json) { const val = new Vector2d(); val.setFromJSON(json); return val; }
    /** Return a new Vector2d from polar coordinates for radius and Angle from x axis */
    static createPolar(r, theta) {
        return Vector2d.create(r * theta.cos(), r * theta.sin());
    }
    /** Return a new Vector2d extending from point0 to point1 */
    static createStartEnd(point0, point1, result) {
        return Vector2d.create(point1.x - point0.x, point1.y - point0.y, result);
    }
    /**
     * Return a vector that bisects the angle between two normals and extends to the intersection of two offset lines
     * @param unitPerpA unit perpendicular to incoming direction
     * @param unitPerpB  unit perpendicular to outgoing direction
     * @param offset offset distance
     */
    static createOffsetBisector(unitPerpA, unitPerpB, offset) {
        let bisector = unitPerpA.plus(unitPerpB);
        bisector = bisector.normalize();
        if (bisector) {
            const c = offset * bisector.dotProduct(unitPerpA);
            return bisector.safeDivideOrNull(c);
        }
        return undefined;
    }
    /** Return a (new or optionally reused) vector which is `this` divided by denominator
     * * return undefined if denominator is zero.
     */
    safeDivideOrNull(denominator, result) {
        if (denominator !== 0.0) {
            return this.scale(1.0 / denominator, result);
        }
        return undefined;
    }
    /** Return a unit vector in direction of this instance (undefined if this instance has near zero length) */
    normalize(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        result = result ? result : new Vector2d();
        return this.safeDivideOrNull(mag, result);
    }
    /** return the fractional projection of spaceVector onto this */
    fractionOfProjectionToVector(target, defaultFraction) {
        const numerator = this.dotProduct(target);
        const denominator = target.magnitudeSquared();
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction ? defaultFraction : 0;
        return numerator / denominator;
    }
    /** Return a new vector with components negated from this instance. */
    negate(result) {
        result = result ? result : new Vector2d();
        result.x = -this.x;
        result.y = -this.y;
        return result;
    }
    /** Return a vector same length as this but rotated 90 degrees counter clockwise */
    rotate90CCWXY(result) {
        result = result ? result : new Vector2d();
        // save x,y to allow aliasing ..
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        return result;
    }
    /** Return a vector same length as this but rotated 90 degrees clockwise */
    rotate90CWXY(result) {
        result = result ? result : new Vector2d();
        // save x,y to allow aliasing ..
        const xx = this.x;
        const yy = this.y;
        result.x = yy;
        result.y = -xx;
        return result;
    }
    /** Return a unit vector perpendicular to this instance. */
    unitPerpendicularXY(result) {
        result = result ? result : new Vector2d();
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        const d2 = xx * xx + yy * yy;
        if (d2 !== 0.0) {
            const a = 1.0 / Math.sqrt(d2);
            result.x *= a;
            result.y *= a;
        }
        return result;
    }
    /** return a new Vector2d rotated CCW by given angle */
    rotateXY(angle, result) {
        const s = angle.sin();
        const c = angle.cos();
        const xx = this.x;
        const yy = this.y;
        result = result ? result : new Vector2d();
        result.x = xx * c - yy * s;
        result.y = xx * s + yy * c;
        return result;
    }
    /** return the interpolation {this + fraction * (right - this)} */
    interpolate(fraction, right, result) {
        result = result ? result : new Vector2d();
        /* For best last-bit behavior, if fraction is below 0.5, use this as base point.   If above 0.5, use right as base point.   */
        if (fraction <= 0.5) {
            result.x = this.x + fraction * (right.x - this.x);
            result.y = this.y + fraction * (right.y - this.y);
        }
        else {
            const t = fraction - 1.0;
            result.x = right.x + t * (right.x - this.x);
            result.y = right.y + t * (right.y - this.y);
        }
        return result;
    }
    /** return {this + vector}. */
    plus(vector, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vector.x;
        result.y = this.y + vector.y;
        return result;
    }
    /** return {this - vector}. */
    minus(vector, result) {
        result = result ? result : new Vector2d();
        result.x = this.x - vector.x;
        result.y = this.y - vector.y;
        return result;
    }
    /** Return {point + vector \* scalar} */
    plusScaled(vector, scaleFactor, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vector.x * scaleFactor;
        result.y = this.y + vector.y * scaleFactor;
        return result;
    }
    /** Return {point + vectorA \* scalarA + vectorB \* scalarB} */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;
        return result;
    }
    /** Return {this + vectorA \* scalarA + vectorB \* scalarB + vectorC \* scalarC} */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        result = result ? result : new Vector2d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;
        return result;
    }
    /** Return {this * scale} */
    scale(scale, result) {
        result = result ? result : new Vector2d();
        result.x = this.x * scale;
        result.y = this.y * scale;
        return result;
    }
    /** return a vector parallel to this but with specified length */
    scaleToLength(length, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        if (mag === 0)
            return undefined;
        return this.scale(length / mag, result);
    }
    /** return the dot product of this with vectorB */
    dotProduct(vectorB) { return this.x * vectorB.x + this.y * vectorB.y; }
    /** dot product with vector from pointA to pointB */
    dotProductStartEnd(pointA, pointB) {
        return this.x * (pointB.x - pointA.x)
            + this.y * (pointB.y - pointA.y);
    }
    /** vector cross product {this CROSS vectorB} */
    crossProduct(vectorB) { return this.x * vectorB.y - this.y * vectorB.x; }
    /** return the (signed) angle from this to vectorB.   This is positive if the shortest turn is counterclockwise, negative if clockwise. */
    angleTo(vectorB) {
        return Angle_1.Angle.createAtan2(this.crossProduct(vectorB), this.dotProduct(vectorB));
    }
    /*  smallerUnorientedAngleTo(vectorB: Vector2d): Angle { }
      signedAngleTo(vectorB: Vector2d, upVector: Vector2d): Angle { }
      planarAngleTo(vectorB: Vector2d, planeNormal: Vector2d): Angle { }
      // sectors
      isInSmallerSector(vectorA: Vector2d, vectorB: Vector2d): boolean { }
      isInCCWSector(vectorA: Vector2d, vectorB: Vector2d, upVector: Vector2d): boolean { }
      */
    /**
     * Test if `this` and `other` area parallel, with angle tolerance `Geometry.smallAngleRadiansSquared`.
     * @param other second vector for comparison.
     * @param oppositeIsParallel if true, treat vectors 180 opposite as parallel.  If false, treat those as non-parallel.
     */
    isParallelTo(other, oppositeIsParallel = false) {
        const a2 = this.magnitudeSquared();
        const b2 = other.magnitudeSquared();
        // we know both are 0 or positive -- no need for
        if (a2 < Geometry_1.Geometry.smallMetricDistanceSquared || b2 < Geometry_1.Geometry.smallMetricDistanceSquared)
            return false;
        const dot = this.dotProduct(other);
        if (dot < 0.0 && !oppositeIsParallel)
            return false;
        const cross = this.crossProduct(other);
        /* a2,b2,cross2 are squared lengths of respective vectors */
        /* cross2 = sin^2(theta) * a2 * b2 */
        /* For small theta, sin^2(theta)~~theta^2 */
        return cross * cross <= Geometry_1.Geometry.smallAngleRadiansSquared * a2 * b2;
    }
    /**
     * Returns `true` if `this` vector is perpendicular to `other`.
     * @param other second vector.
     */
    isPerpendicularTo(other) {
        return Angle_1.Angle.isPerpendicularDotSet(this.magnitudeSquared(), other.magnitudeSquared(), this.dotProduct(other));
    }
}
exports.Vector2d = Vector2d;


/***/ }),

/***/ "./lib/geometry3d/Point3dArrayCarrier.js":
/*!***********************************************!*\
  !*** ./lib/geometry3d/Point3dArrayCarrier.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const IndexedXYZCollection_1 = __webpack_require__(/*! ./IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js");
/** @module ArraysAndInterfaces */
/**
 * Helper object to access members of a Point3d[] in geometric calculations.
 * * The collection holds only a reference to the actual array.
 * * The actual array may be replaced by the user as needed.
 * * When replaced, there is no cached data to be updated.
 * @public
 */
class Point3dArrayCarrier extends IndexedXYZCollection_1.IndexedReadWriteXYZCollection {
    /** CAPTURE caller supplied array ... */
    constructor(data) {
        super();
        this.data = data;
    }
    /** test if `index` is a valid index into the array. */
    isValidIndex(index) {
        return index >= 0 && index < this.data.length;
    }
    /**
     * Access by index, returning strongly typed Point3d
     * @param index index of point within the array
     * @param result caller-allocated destination
     * @returns undefined if the index is out of bounds
     */
    getPoint3dAtCheckedPointIndex(index, result) {
        if (this.isValidIndex(index)) {
            const source = this.data[index];
            return Point3dVector3d_1.Point3d.create(source.x, source.y, source.z, result);
        }
        return undefined;
    }
    /**
     * Access by index, returning strongly typed Point3d
     * * This returns the xyz value but NOT reference to the point in the "carried" array.
     * @param index index of point within the array
     * @param result caller-allocated destination
     * @returns undefined if the index is out of bounds
     */
    getPoint3dAtUncheckedPointIndex(index, result) {
        const source = this.data[index];
        return Point3dVector3d_1.Point3d.create(source.x, source.y, source.z, result);
    }
    /**
     * Access by index, returning strongly typed Vector3d
     * @param index index of point within the array
     * @param result caller-allocated destination
     * @returns undefined if the index is out of bounds
     */
    getVector3dAtCheckedVectorIndex(index, result) {
        if (this.isValidIndex(index)) {
            const source = this.data[index];
            return Point3dVector3d_1.Vector3d.create(source.x, source.y, source.z, result);
        }
        return undefined;
    }
    /** access x of indexed point */
    getXAtUncheckedPointIndex(pointIndex) {
        return this.data[pointIndex].x;
    }
    /** access y of indexed point */
    getYAtUncheckedPointIndex(pointIndex) {
        return this.data[pointIndex].y;
    }
    /** access z of indexed point */
    getZAtUncheckedPointIndex(pointIndex) {
        return this.data[pointIndex].z;
    }
    /**
     * Return a vector from the point at indexA to the point at indexB
     * @param indexA index of point within the array
     * @param indexB index of point within the array
     * @param result caller-allocated vector.
     * @returns undefined if either index is out of bounds
     */
    vectorIndexIndex(indexA, indexB, result) {
        if (this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return Point3dVector3d_1.Vector3d.createStartEnd(this.data[indexA], this.data[indexB], result);
        return undefined;
    }
    /**
     * Return a vector from given origin to point at indexB
     * @param origin origin for vector
     * @param indexB index of point within the array
     * @param result caller-allocated vector.
     * @returns undefined if index is out of bounds
     */
    vectorXYAndZIndex(origin, indexB, result) {
        if (this.isValidIndex(indexB))
            return Point3dVector3d_1.Vector3d.createStartEnd(origin, this.data[indexB], result);
        return undefined;
    }
    /**
     * Return the cross product of vectors from origin to points at indexA and indexB
     * @param origin origin for vector
     * @param indexA index of first target within the array
     * @param indexB index of second target within the array
     * @param result caller-allocated vector.
     * @returns undefined if either index is out of bounds
     */
    crossProductXYAndZIndexIndex(origin, indexA, indexB, result) {
        if (this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return Point3dVector3d_1.Vector3d.createCrossProductToPoints(origin, this.data[indexA], this.data[indexB], result);
        return undefined;
    }
    /**
     * Return the cross product of vectors from point at originIndex to points at indexA and indexB
     * @param originIndex index of origin
     * @param indexA index of first target within the array
     * @param indexB index of second target within the array
     * @param result caller-allocated vector.
     * @returns return true if indexA, indexB both valid
     */
    crossProductIndexIndexIndex(originIndex, indexA, indexB, result) {
        if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))
            return Point3dVector3d_1.Vector3d.createCrossProductToPoints(this.data[originIndex], this.data[indexA], this.data[indexB], result);
        return undefined;
    }
    /**
     * Compute the cross product of vectors from point at originIndex to points at indexA and indexB, and accumulate it to the result.
     * @param origin index of origin
     * @param indexA index of first target within the array
     * @param indexB index of second target within the array
     * @param result caller-allocated vector.
     * @returns return true if indexA, indexB both valid
     */
    accumulateCrossProductIndexIndexIndex(originIndex, indexA, indexB, result) {
        const data = this.data;
        if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))
            result.addCrossProductToTargetsInPlace(data[originIndex].x, data[originIndex].y, data[originIndex].z, data[indexA].x, data[indexA].y, data[indexA].z, data[indexB].x, data[indexB].y, data[indexB].z);
    }
    /**
     * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.
     * * accumulate it to the result.
     */
    accumulateScaledXYZ(index, scale, sum) {
        if (this.isValidIndex(index)) {
            const point = this.data[index];
            sum.x += scale * point.x;
            sum.y += scale * point.y;
            sum.z += scale * point.z;
        }
    }
    /**
     * read-only property for number of XYZ in the collection.
     */
    get length() {
        return this.data.length;
    }
    /** push a (clone of) point onto the collection
     * * point itself is not pushed -- xyz data is extracted into the native form of the collection.
     */
    push(data) {
        this.data.push(data.clone());
    }
    /**
     * push a new point (given by coordinates) onto the collection
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     */
    pushXYZ(x, y, z) {
        this.data.push(Point3dVector3d_1.Point3d.create(x === undefined ? 0.0 : x, y === undefined ? 0.0 : y, z === undefined ? 0.0 : z));
    }
    /** extract (copy) the final point */
    back(result) {
        if (this.data.length > 0) {
            return this.data[this.data.length - 1].clone(result);
        }
        return undefined;
    }
    /** extract (copy) the first point */
    front(result) {
        if (this.data.length > 0) {
            return this.data[0].clone(result);
        }
        return undefined;
    }
    /** remove the final point. */
    pop() {
        if (this.data.length > 0)
            this.data.pop();
    }
    /** remove all points. */
    clear() {
        this.data.length = 0;
    }
    /** Reverse the points in place */
    reverseInPlace() {
        this.data.reverse();
    }
    /**
     * Return distance squared between indicated points.
     * * Concrete classes may be able to implement this without creating a temporary.
     * @param index0 first point index
     * @param index1 second point index
     * @param defaultDistanceSquared distance squared to return if either point index is invalid.
     *
     */
    distanceSquaredIndexIndex(index0, index1) {
        const n = this.data.length;
        if (index0 >= 0 && index0 < n && index1 >= 0 && index1 < n) {
            return this.data[index0].distanceSquared(this.data[index1]);
        }
        return undefined;
    }
    /**
     * Return distance between indicated points.
     * * Concrete classes may be able to implement this without creating a temporary.
     * @param index0 first point index
     * @param index1 second point index
     * @param defaultDistanceSquared distance squared to return if either point index is invalid.
     */
    distanceIndexIndex(index0, index1) {
        const n = this.data.length;
        if (index0 >= 0 && index0 < n && index1 >= 0 && index1 < n) {
            return this.data[index0].distance(this.data[index1]);
        }
        return undefined;
    }
    /** Adjust index into range by modulo with the length. */
    cyclicIndex(i) {
        return (i % this.length);
    }
}
exports.Point3dArrayCarrier = Point3dArrayCarrier;


/***/ }),

/***/ "./lib/geometry3d/Point3dVector3d.js":
/*!*******************************************!*\
  !*** ./lib/geometry3d/Point3dVector3d.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
const Ray3d_1 = __webpack_require__(/*! ./Ray3d */ "./lib/geometry3d/Ray3d.js");
/** @module CartesianGeometry */
/**
 *  * `XYZ` is a minimal object containing x,y,z and operations that are meaningful without change in both point and vector.
 *  * `XYZ` is not instantiable.
 *  * The derived (instantiable) classes are
 *    * `Point3d`
 *    * `Vector3d`
 * @public
 */
class XYZ {
    constructor(x = 0, y = 0, z = 0) { this.x = x; this.y = y; this.z = z; }
    /**
     * Set the x,y,z  parts.
     * @param x (optional) x part
     * @param y (optional) y part
     * @param z (optional) z part
     */
    set(x = 0, y = 0, z = 0) { this.x = x; this.y = y; this.z = z; }
    /** Set the x,y,z parts to zero. */
    setZero() { this.x = 0; this.y = 0; this.z = 0; }
    /** Type guard for XAndY.
     * @note this will return true for an XYAndZ. If you wish to distinguish between the two, call isXYAndZ first.
     */
    static isXAndY(arg) { return arg.x !== undefined && arg.y !== undefined; }
    /** Type guard to determine whether an object has a member called "z" */
    static hasZ(arg) { return arg.z !== undefined; }
    /** Type guard for XYAndZ.  */
    static isXYAndZ(arg) { return this.isXAndY(arg) && this.hasZ(arg); }
    /** Test if arg is any of:
     * * XAndY
     * * XYAndZ
     * * [number,number]
     * * [number,number,number]
     */
    static isAnyImmediatePointType(arg) {
        return Point3d.isXAndY(arg) || Geometry_1.Geometry.isNumberArray(arg, 2);
    }
    /** Look for (in order) an x coordinate present as:
     * * arg.x
     * * arg[0]
     */
    static accessX(arg, defaultValue) {
        if (arg.x !== undefined)
            return arg.x;
        if (Array.isArray(arg) && arg.length > 0 && Number.isFinite(arg[0]))
            return arg[0];
        return defaultValue;
    }
    /** Look for (in order) an x coordinate present as:
     * * arg.y
     * * arg[1]
     */
    static accessY(arg, defaultValue) {
        if (arg.y !== undefined)
            return arg.y;
        if (Array.isArray(arg) && arg.length > 1 && Number.isFinite(arg[1]))
            return arg[1];
        return defaultValue;
    }
    /** Look for (in order) an x coordinate present as:
     * * arg.z
     * * arg[2]
     */
    static accessZ(arg, defaultValue) {
        if (arg.z !== undefined)
            return arg.z;
        if (Array.isArray(arg) && arg.length > 2 && Number.isFinite(arg[2]))
            return arg[2];
        return defaultValue;
    }
    /**
     * Set the x,y,z parts from one of these input types
     *
     * * XYZ -- copy the x,y,z parts
     * * Float64Array -- Copy from indices 0,1,2 to x,y,z
     * * XY -- copy the x, y parts and set z=0
     */
    setFrom(other) {
        if (other === undefined) {
            this.setZero();
        }
        else if (XYZ.isXAndY(other)) {
            this.x = other.x;
            this.y = other.y;
            this.z = XYZ.hasZ(other) ? other.z : 0;
        }
        else {
            this.x = other[0];
            this.y = other[1];
            this.z = other[2];
        }
    }
    /**
     * Set the x,y,z parts from a Point3d.
     * This is the same effect as `setFrom(other)` with no pretesting of variant input type
     * * Set to zeros if `other` is undefined.
     */
    setFromPoint3d(other) {
        if (other) {
            this.x = other.x;
            this.y = other.y;
            this.z = other.z;
        }
        else {
            this.setZero();
        }
    }
    /**
     * Set the x,y,z parts from a Vector3d
     * This is the same effect as `setFrom(other)` with no pretesting of variant input type
     */
    setFromVector3d(other) {
        if (other) {
            this.x = other.x;
            this.y = other.y;
            this.z = other.z;
        }
        else {
            this.setZero();
        }
    }
    /** Returns true if this and other have equal x,y,z parts within Geometry.smallMetricDistance.
     * @param other The other XYAndZ to compare
     * @param tol The tolerance for the comparison. If undefined, use [[Geometry.smallMetricDistance]]
     */
    isAlmostEqual(other, tol) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, other.x, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.y, other.y, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.z, other.z, tol);
    }
    /** Return true if this and other have equal x,y,z parts within Geometry.smallMetricDistance. */
    isAlmostEqualXYZ(x, y, z, tol) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, x, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.y, y, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.z, z, tol);
    }
    /** Return true if this and other have equal x,y parts within Geometry.smallMetricDistance. */
    isAlmostEqualXY(other, tol) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, other.x, tol)
            && Geometry_1.Geometry.isSameCoordinate(this.y, other.y, tol);
    }
    /** Return a JSON object as array `[x,y,z]` */
    toJSON() { return [this.x, this.y, this.z]; }
    /** Return a JSON object as key value pairs `{x: value, y: value, z: value}` */
    toJSONXYZ() { return { x: this.x, y: this.y, z: this.z }; }
    /** Pack the x,y,z values in a Float64Array. */
    toFloat64Array() { return Float64Array.of(this.x, this.y, this.z); }
    /**
     * Set the x,y,z properties from one of several json forms:
     *
     * *  array of numbers: [x,y,z]
     * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}
     */
    setFromJSON(json) {
        if (Array.isArray(json)) {
            this.set(json[0] || 0, json[1] || 0, json[2] || 0);
            return;
        }
        if (json) {
            this.set(json.x || 0, json.y || 0, json.z || 0);
            return;
        }
        this.set(0, 0, 0);
    }
    /** Return the distance from this point to other */
    distance(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        const zDist = other.z - this.z;
        return (Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist));
    }
    /** Return squared distance from this point to other */
    distanceSquared(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        const zDist = other.z - this.z;
        return (xDist * xDist + yDist * yDist + zDist * zDist);
    }
    /** Return the XY distance from this point to other */
    distanceXY(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (Math.sqrt(xDist * xDist + yDist * yDist));
    }
    /** Return squared XY distance from this point to other */
    distanceSquaredXY(other) {
        const xDist = other.x - this.x;
        const yDist = other.y - this.y;
        return (xDist * xDist + yDist * yDist);
    }
    /** Return the largest absolute distance between corresponding components */
    maxDiff(other) {
        return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y), Math.abs(this.z - other.z));
    }
    /**
     * Return the x,y, z component corresponding to 0,1,2.
     */
    at(index) {
        if (index < 0.5)
            return this.x;
        if (index > 1.5)
            return this.z;
        return this.y;
    }
    /** Return the index (0,1,2) of the x,y,z component with largest absolute value */
    indexOfMaxAbs() {
        let index = 0;
        let a = Math.abs(this.x);
        let b = Math.abs(this.y);
        if (b > a) {
            index = 1;
            a = b;
        }
        b = Math.abs(this.z);
        if (b > a) {
            index = 2;
            a = b;
        }
        return index;
    }
    /** Return true if the if x,y,z components are all nearly zero to tolerance Geometry.smallMetricDistance */
    get isAlmostZero() {
        return Geometry_1.Geometry.isSmallMetricDistance(this.x) && Geometry_1.Geometry.isSmallMetricDistance(this.y) && Geometry_1.Geometry.isSmallMetricDistance(this.z);
    }
    /** Return the largest absolute value of any component */
    maxAbs() { return Math.max(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z)); }
    /** Return the sqrt of the sum of squared x,y,z parts */
    magnitude() { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }
    /** Return the sum of squared x,y,z parts */
    magnitudeSquared() { return this.x * this.x + this.y * this.y + this.z * this.z; }
    /** Return sqrt of the sum of squared x,y parts */
    magnitudeXY() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    /** Return the sum of squared x,y parts */
    magnitudeSquaredXY() { return this.x * this.x + this.y * this.y; }
    /** exact equality test. */
    isExactEqual(other) { return this.x === other.x && this.y === other.y && this.z === other.z; }
    /** equality test with Geometry.smallMetricDistance tolerance */
    isAlmostEqualMetric(other) { return this.maxDiff(other) <= Geometry_1.Geometry.smallMetricDistance; }
    /** add x,y,z from other in place. */
    addInPlace(other) { this.x += other.x; this.y += other.y; this.z += other.z; }
    /** add x,y,z from other in place. */
    subtractInPlace(other) { this.x -= other.x; this.y -= other.y; this.z -= other.z; }
    /** add (in place) the scaled x,y,z of other */
    addScaledInPlace(other, scale) {
        this.x += scale * other.x;
        this.y += scale * other.y;
        this.z += scale * other.z;
    }
    /** Multiply the x, y, z parts by scale. */
    scaleInPlace(scale) { this.x *= scale; this.y *= scale; this.z *= scale; }
    /** add to x, y, z parts */
    addXYZInPlace(dx = 0.0, dy = 0.0, dz = 0.0) { this.x += dx; this.y += dy; this.z += dz; }
    /** Clone strongly typed as Point3d */
    cloneAsPoint3d() { return Point3d.create(this.x, this.y, this.z); }
    /** Return a (full length) vector from this point to other */
    vectorTo(other, result) {
        return Vector3d.create(other.x - this.x, other.y - this.y, other.z - this.z, result);
    }
    /** Return a multiple of a the (full length) vector from this point to other */
    scaledVectorTo(other, scale, result) {
        return Vector3d.create(scale * (other.x - this.x), scale * (other.y - this.y), scale * (other.z - this.z), result);
    }
    /** Return a unit vector from this vector to other. Return a 000 vector if the input is too small to normalize.
     * @param other target of created vector.
     * @param result optional result vector.
     */
    unitVectorTo(target, result) { return this.vectorTo(target, result).normalize(result); }
    /** Freeze this XYZ */
    freeze() { Object.freeze(this); }
}
exports.XYZ = XYZ;
/** 3D point with `x`,`y`,`z` as properties
 * @public
 */
class Point3d extends XYZ {
    /** Constructor for Point3d */
    constructor(x = 0, y = 0, z = 0) { super(x, y, z); }
    /**
     * Convert json to Point3d.  Accepted forms are:
     * * `[1,2,3]` --- array of numbers
     * *  array of numbers: [x,y,z]
     * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}
     * @param json json value.
     */
    static fromJSON(json) { const val = new Point3d(); val.setFromJSON(json); return val; }
    /** Return a new Point3d with the same coordinates */
    clone(result) { return Point3d.create(this.x, this.y, this.z, result); }
    /** Create a new Point3d with given coordinates
     * @param x x part
     * @param y y part
     * @param z z part
     */
    static create(x = 0, y = 0, z = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        }
        return new Point3d(x, y, z);
    }
    /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */
    static createFrom(data, result) {
        if (data instanceof Float64Array) {
            let x = 0;
            let y = 0;
            let z = 0;
            if (data.length > 0)
                x = data[0];
            if (data.length > 1)
                y = data[1];
            if (data.length > 2)
                z = data[2];
            return Point3d.create(x, y, z, result);
        }
        return Point3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0, result);
    }
    /**
     * Copy x,y,z from
     * @param xyzData flat array of xyzxyz for multiple points
     * @param pointIndex index of point to extract.   This index is multiplied by 3 to obtain starting index in the array.
     * @param result optional result point.
     */
    static createFromPacked(xyzData, pointIndex, result) {
        const indexX = pointIndex * 3;
        if (indexX >= 0 && indexX + 2 < xyzData.length)
            return Point3d.create(xyzData[indexX], xyzData[indexX + 1], xyzData[indexX + 2], result);
        return undefined;
    }
    /**
     * Copy and unweight xyzw.
     * @param xyzData flat array of x,y,z,w,x,y,z,w for multiple points
     * @param pointIndex index of point to extract.   This index is multiplied by 4 to obtain starting index in the array.
     * @param result optional result point.
     */
    static createFromPackedXYZW(xyzData, pointIndex, result) {
        const indexX = pointIndex * 4;
        if (indexX >= 0 && indexX + 3 < xyzData.length) {
            const w = xyzData[indexX + 3];
            if (!Geometry_1.Geometry.isSmallMetricDistance(w)) {
                const divW = 1.0 / w;
                return Point3d.create(divW * xyzData[indexX], divW * xyzData[indexX + 1], divW * xyzData[indexX + 2], result);
            }
        }
        return undefined;
    }
    /** Create a new point with 000 xyz */
    static createZero(result) { return Point3d.create(0, 0, 0, result); }
    /** Return the cross product of the vectors from this to pointA and pointB
     *
     * *  the result is a vector
     * *  the result is perpendicular to both vectors, with right hand orientation
     * *  the magnitude of the vector is twice the area of the triangle.
     */
    crossProductToPoints(pointA, pointB, result) {
        return Vector3d.createCrossProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, result);
    }
    /** Return the magnitude of the cross product of the vectors from this to pointA and pointB
     */
    crossProductToPointsMagnitude(pointA, pointB) {
        return Geometry_1.Geometry.crossProductMagnitude(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z);
    }
    /** Return the triple product of the vectors from this to pointA, pointB, pointC
     *
     * * This is a scalar (number)
     * *  This is 6 times the (signed) volume of the tetrahedron on the 4 points.
     */
    tripleProductToPoints(pointA, pointB, pointC) {
        return Geometry_1.Geometry.tripleProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, pointC.x - this.x, pointC.y - this.y, pointC.z - this.z);
    }
    /** Return the cross product of the vectors from this to pointA and pointB
     *
     * *  the result is a scalar
     * *  the magnitude of the vector is twice the signed area of the triangle.
     * *  this is positive for counter-clockwise order of the points, negative for clockwise.
     */
    crossProductToPointsXY(pointA, pointB) {
        return Geometry_1.Geometry.crossProductXYXY(pointA.x - this.x, pointA.y - this.y, pointB.x - this.x, pointB.y - this.y);
    }
    /** Return a point interpolated between this point and the right param. */
    interpolate(fraction, other, result) {
        if (fraction <= 0.5)
            return Point3d.create(this.x + fraction * (other.x - this.x), this.y + fraction * (other.y - this.y), this.z + fraction * (other.z - this.z), result);
        const t = fraction - 1.0;
        return Point3d.create(other.x + t * (other.x - this.x), other.y + t * (other.y - this.y), other.z + t * (other.z - this.z), result);
    }
    /**
     * Return a ray whose ray.origin is interpolated, and ray.direction is the vector between points with a
     * scale factor applied.
     * @param fraction fractional position between points.
     * @param other endpoint of interpolation
     * @param tangentScale scale factor to apply to the startToEnd vector
     * @param result  optional receiver.
     */
    interpolatePointAndTangent(fraction, other, tangentScale, result) {
        result = result ? result : Ray3d_1.Ray3d.createZero();
        const dx = other.x - this.x;
        const dy = other.y - this.y;
        const dz = other.z - this.z;
        result.direction.set(tangentScale * dx, tangentScale * dy, tangentScale * dz);
        if (fraction <= 0.5)
            result.origin.set(this.x + fraction * dx, this.y + fraction * dy, this.z + fraction * dz);
        else {
            const t = fraction - 1.0;
            result.origin.set(other.x + t * dx, other.y + t * dy, other.z + t * dz);
        }
        return result;
    }
    /** Return a point with independent x,y,z fractional interpolation. */
    interpolateXYZ(fractionX, fractionY, fractionZ, other, result) {
        return Point3d.create(Geometry_1.Geometry.interpolate(this.x, fractionX, other.x), Geometry_1.Geometry.interpolate(this.y, fractionY, other.y), Geometry_1.Geometry.interpolate(this.z, fractionZ, other.z), result);
    }
    /** Interpolate between points, then add a shift in the xy plane by a fraction of the XY projection perpendicular. */
    interpolatePerpendicularXY(fraction, pointB, fractionXYPerp, result) {
        result = result ? result : new Point3d();
        const vector = pointB.minus(this);
        this.interpolate(fraction, pointB, result);
        result.x -= fractionXYPerp * vector.y;
        result.y += fractionXYPerp * vector.x;
        return result;
    }
    /** Return point minus vector */
    minus(vector, result) {
        return Point3d.create(this.x - vector.x, this.y - vector.y, this.z - vector.z, result);
    }
    /** Return point plus vector */
    plus(vector, result) {
        return Point3d.create(this.x + vector.x, this.y + vector.y, this.z + vector.z, result);
    }
    /** Return point plus vector */
    plusXYZ(dx = 0, dy = 0, dz = 0, result) {
        return Point3d.create(this.x + dx, this.y + dy, this.z + dz, result);
    }
    /** Return point + vector * scalar */
    plusScaled(vector, scaleFactor, result) {
        return Point3d.create(this.x + vector.x * scaleFactor, this.y + vector.y * scaleFactor, this.z + vector.z * scaleFactor, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point3d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB, this.y + vectorA.y * scalarA + vectorB.y * scalarB, this.z + vectorA.z * scalarA + vectorB.z * scalarB, result);
    }
    /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point3d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC, this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC, this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC, result);
    }
    /**
     * Return a point that is scaled from the source point.
     * @param source existing point
     * @param scale scale factor to apply to its x,y,z parts
     * @param result optional point to receive coordinates
     */
    static createScale(source, scale, result) {
        return Point3d.create(source.x * scale, source.y * scale, source.z * scale, result);
    }
    /** create a point that is a linear combination (weighted sum) of 2 input points.
     * @param pointA first input point
     * @param scaleA scale factor for pointA
     * @param pointB second input point
     * @param scaleB scale factor for pointB
     */
    static createAdd2Scaled(pointA, scaleA, pointB, scaleB, result) {
        return Point3d.create(pointA.x * scaleA + pointB.x * scaleB, pointA.y * scaleA + pointB.y * scaleB, pointA.z * scaleA + pointB.z * scaleB, result);
    }
    /** Create a point that is a linear combination (weighted sum) of 3 input points.
     * @param pointA first input point
     * @param scaleA scale factor for pointA
     * @param pointB second input point
     * @param scaleB scale factor for pointB
     * @param pointC third input point.
     * @param scaleC scale factor for pointC
     */
    static createAdd3Scaled(pointA, scaleA, pointB, scaleB, pointC, scaleC, result) {
        return Point3d.create(pointA.x * scaleA + pointB.x * scaleB + pointC.x * scaleC, pointA.y * scaleA + pointB.y * scaleB + pointC.y * scaleC, pointA.z * scaleA + pointB.z * scaleB + pointC.z * scaleC, result);
    }
    /**
     * Return the dot product of vectors from this to pointA and this to pointB.
     * @param targetA target point for first vector
     * @param targetB target point for second vector
     */
    dotVectorsToTargets(targetA, targetB) {
        return (targetA.x - this.x) * (targetB.x - this.x) +
            (targetA.y - this.y) * (targetB.y - this.y) +
            (targetA.z - this.z) * (targetB.z - this.z);
    }
    /** Return the fractional projection of this onto a line between points.
     *
     */
    fractionOfProjectionToLine(startPoint, endPoint, defaultFraction = 0) {
        const denominator = startPoint.distanceSquared(endPoint);
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction;
        return startPoint.dotVectorsToTargets(endPoint, this) / denominator;
    }
}
exports.Point3d = Point3d;
/** 3D vector with `x`,`y`,`z` as properties
 * @public
 */
class Vector3d extends XYZ {
    constructor(x = 0, y = 0, z = 0) { super(x, y, z); }
    /**
     * Copy xyz from this instance to a new (or optionally reused) Vector3d
     * @param result optional instance to reuse.
     */
    clone(result) { return Vector3d.create(this.x, this.y, this.z, result); }
    /**
     * return a Vector3d (new or reused from optional result)
     * @param x x component
     * @param y y component
     * @param z z component
     * @param result optional instance to reuse
     */
    static create(x = 0, y = 0, z = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            result.z = z;
            return result;
        }
        return new Vector3d(x, y, z);
    }
    /**
     * Create a vector which is cross product of two vectors supplied as separate arguments
     * @param ux x coordinate of vector u
     * @param uy y coordinate of vector u
     * @param uz z coordinate of vector u
     * @param vx x coordinate of vector v
     * @param vy y coordinate of vector v
     * @param vz z coordinate of vector v
     * @param result optional result vector.
     */
    static createCrossProduct(ux, uy, uz, vx, vy, vz, result) {
        return Vector3d.create(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx, result);
    }
    /**
     * Accumulate a vector which is cross product vectors from origin (ax,ay,az) to targets (bx,by,bz) and (cx,cy,cz)
     * @param ax x coordinate of origin
     * @param ay y coordinate of origin
     * @param az z coordinate of origin
     * @param bx x coordinate of target point b
     * @param by y coordinate of target point b
     * @param bz z coordinate of target point b
     * @param cx x coordinate of target point c
     * @param cy y coordinate of target point c
     * @param cz z coordinate of target point c
     */
    addCrossProductToTargetsInPlace(ax, ay, az, bx, by, bz, cx, cy, cz) {
        const ux = bx - ax;
        const uy = by - ay;
        const uz = bz - az;
        const vx = cx - ax;
        const vy = cy - ay;
        const vz = cz - az;
        this.x += uy * vz - uz * vy;
        this.y += uz * vx - ux * vz;
        this.z += ux * vy - uy * vx;
    }
    /**
     * Return the cross product of the vectors from origin to pointA and pointB.
     *
     * * the result is a vector
     * * the result is perpendicular to both vectors, with right hand orientation
     * * the magnitude of the vector is twice the area of the triangle.
     */
    static createCrossProductToPoints(origin, pointA, pointB, result) {
        return Vector3d.createCrossProduct(pointA.x - origin.x, pointA.y - origin.y, pointA.z - origin.z, pointB.x - origin.x, pointB.y - origin.y, pointB.z - origin.z, result);
    }
    /**
     * Return a vector defined by polar coordinates distance and angle from x axis
     * @param r distance measured from origin
     * @param theta angle from x axis to the vector (in xy plane)
     * @param z optional z coordinate
     */
    static createPolar(r, theta, z) {
        return Vector3d.create(r * theta.cos(), r * theta.sin(), z);
    }
    /**
     * Return a vector defined in spherical coordinates.
     * @param r sphere radius
     * @param theta angle in xy plane
     * @param phi angle from xy plane to the vector
     */
    static createSpherical(r, theta, phi) {
        const cosPhi = phi.cos();
        return Vector3d.create(cosPhi * r * theta.cos(), cosPhi * r * theta.sin(), phi.sin());
    }
    /**
     * Convert json to Vector3d.  Accepted forms are:
     * * `[1,2,3]` --- array of numbers
     * *  array of numbers: [x,y,z]
     * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}
     * @param json json value.
     */
    static fromJSON(json) { const val = new Vector3d(); val.setFromJSON(json); return val; }
    /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */
    static createFrom(data, result) {
        if (data instanceof Float64Array) {
            let x = 0;
            let y = 0;
            let z = 0;
            if (data.length > 0)
                x = data[0];
            if (data.length > 1)
                y = data[1];
            if (data.length > 2)
                z = data[2];
            return Vector3d.create(x, y, z, result);
        }
        return Vector3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0.0, result);
    }
    /**
     * Return a vector defined by start and end points (end - start).
     * @param start start point for vector
     * @param end end point for vector
     * @param result optional result
     */
    static createStartEnd(start, end, result) {
        if (result) {
            result.set(end.x - start.x, end.y - start.y, end.z - start.z);
            return result;
        }
        return new Vector3d(end.x - start.x, end.y - start.y, end.z - start.z);
    }
    /**
     * Return a vector (optionally in preallocated result, otherwise newly created) from [x0,y0,z0] to [x1,y1,z1]
     * @param x0 start point x coordinate
     * @param y0 start point y coordinate
     * @param z0 start point z coordinate
     * @param x1 end point x coordinate
     * @param y1 end point y coordinate
     * @param z1 end point z coordinate
     * @param result optional result vector
     */
    static createStartEndXYZXYZ(x0, y0, z0, x1, y1, z1, result) {
        return this.create(x1 - x0, y1 - y0, z1 - z0, result);
    }
    /**
     * Return a vector which is the input vector rotated around the axis vector.
     * @param vector initial vector
     * @param axis axis of rotation
     * @param angle angle of rotation.  If undefined, 90 degrees is implied
     * @param result optional result vector
     * @returns undefined if axis has no length.
     */
    static createRotateVectorAroundVector(vector, axis, angle) {
        // Rodriguez formula, https://en.wikipedia.org/wiki/Rodrigues'_rotation_formula
        const unitAxis = axis.normalize();
        if (unitAxis) {
            const xProduct = unitAxis.crossProduct(vector);
            let c, s;
            if (angle) {
                c = angle.cos();
                s = angle.sin();
            }
            else {
                c = 0.0;
                s = 1.0;
            }
            return Vector3d.createAdd3Scaled(vector, c, xProduct, s, unitAxis, unitAxis.dotProduct(vector) * (1.0 - c));
        }
        return undefined;
    }
    /**
     * Set (replace) xzz components so they are a vector from point0 to point1
     * @param point0 start point of computed vector
     * @param point1 end point of computed vector.
     */
    setStartEnd(point0, point1) {
        this.x = point1.x - point0.x;
        this.y = point1.y - point0.y;
        this.z = point1.z - point0.z;
    }
    /** Return a vector with 000 xyz parts. */
    static createZero(result) { return Vector3d.create(0, 0, 0, result); }
    /** Return a unit X vector optionally multiplied by a scale  */
    static unitX(scale = 1) { return new Vector3d(scale, 0, 0); }
    /** Return a unit Y vector  */
    static unitY(scale = 1) { return new Vector3d(0, scale, 0); }
    /** Return a unit Z vector  */
    static unitZ(scale = 1) { return new Vector3d(0, 0, scale); }
    /** Divide by denominator, but return undefined if denominator is zero. */
    safeDivideOrNull(denominator, result) {
        if (denominator !== 0.0) {
            return this.scale(1.0 / denominator, result);
        }
        return undefined;
    }
    /**
     * Return a pair object containing (a) property `v` which is a unit vector in the direction
     * of the input and (b) property mag which is the magnitude (length) of the input (instance) prior to normalization.
     * If the instance (input) is a near zero length the `v` property of the output is undefined.
     * @param result optional result.
     */
    normalizeWithLength(result) {
        const magnitude = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        result = result ? result : new Vector3d();
        return { v: this.safeDivideOrNull(magnitude, result), mag: magnitude };
    }
    /**
     * Return a unit vector parallel with this.  Return undefined if this.magnitude is near zero.
     * @param result optional result.
     */
    normalize(result) { return this.normalizeWithLength(result).v; }
    /**
     * If this vector has nonzero length, divide by the length to change to a unit vector.
     * @returns true if normalization completed.
     */
    normalizeInPlace() {
        const a = Geometry_1.Geometry.inverseMetricDistance(this.magnitude());
        if (!a)
            return false;
        this.x *= a;
        this.y *= a;
        this.z *= a;
        return true;
    }
    /** Return the fractional projection of spaceVector onto this */
    fractionOfProjectionToVector(target, defaultFraction = 0) {
        const numerator = this.dotProduct(target);
        const denominator = target.magnitudeSquared();
        if (denominator < Geometry_1.Geometry.smallMetricDistanceSquared)
            return defaultFraction;
        return numerator / denominator;
    }
    /** Return a new vector with components negated from the calling instance.
     * @param result optional result vector.
     */
    negate(result) {
        result = result ? result : new Vector3d();
        result.x = -this.x;
        result.y = -this.y;
        result.z = -this.z;
        return result;
    }
    /** Return a vector same length as this but rotate 90 degrees CCW */
    rotate90CCWXY(result) {
        result = result ? result : new Vector3d();
        // save x,y to allow aliasing ..
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        result.z = this.z;
        return result;
    }
    /**
     * Return a vector which is in the xy plane, perpendicular ot the xy part of this vector, and of unit length.
     * * If the xy part is 00, the return is the rotated (but not normalized) xy parts of this vector.
     * @param result optional preallocated result.
     */
    unitPerpendicularXY(result) {
        result = result ? result : new Vector3d();
        const xx = this.x;
        const yy = this.y;
        result.x = -yy;
        result.y = xx;
        result.z = 0.0;
        const d2 = xx * xx + yy * yy;
        if (d2 !== 0.0) {
            const a = 1.0 / Math.sqrt(d2);
            result.x *= a;
            result.y *= a;
        }
        return result;
    }
    /**
     * Rotate the xy parts of this vector around the z axis.
     * * z is taken unchanged to the result.
     * @param angle angle to rotate
     * @param result optional preallocated result
     */
    rotateXY(angle, result) {
        const s = angle.sin();
        const c = angle.cos();
        const xx = this.x;
        const yy = this.y;
        result = result ? result : new Vector3d();
        result.x = xx * c - yy * s;
        result.y = xx * s + yy * c;
        result.z = this.z;
        return result;
    }
    /**
     * Return a (new or optionally preallocated) vector that is rotated 90 degrees in the plane of this vector and the target vector.
     * @param target Second vector which defines the plane of rotation.
     * @param result optional preallocated vector for result.
     * @returns rotated vector, or undefined if the cross product of this and the the target cannot be normalized (i.e. if the target and this are colinear)
     */
    rotate90Towards(target, result) {
        const normal = this.crossProduct(target).normalize();
        return normal ? normal.crossProduct(this, result) : undefined;
    }
    /** Rotate this vector 90 degrees around an axis vector.
     * @returns the (new or optionally reused result) rotated vector, or undefined if the axis vector cannot be normalized.
     */
    rotate90Around(axis, result) {
        const unitNormal = axis.normalize();
        return unitNormal ? unitNormal.crossProduct(this).plusScaled(unitNormal, unitNormal.dotProduct(this), result) : undefined;
    }
    /**
     * Return a vector computed at fractional position between this vector and vectorB
     * @param fraction fractional position.  0 is at `this`.  1 is at `vectorB`.  True fractions are "between", negatives are "before this", beyond 1 is "beyond vectorB".
     * @param vectorB second vector
     * @param result optional preallocated result.
     */
    interpolate(fraction, vectorB, result) {
        result = result ? result : new Vector3d();
        if (fraction <= 0.5) {
            result.x = this.x + fraction * (vectorB.x - this.x);
            result.y = this.y + fraction * (vectorB.y - this.y);
            result.z = this.z + fraction * (vectorB.z - this.z);
        }
        else {
            const t = fraction - 1.0;
            result.x = vectorB.x + t * (vectorB.x - this.x);
            result.y = vectorB.y + t * (vectorB.y - this.y);
            result.z = vectorB.z + t * (vectorB.z - this.z);
        }
        return result;
    }
    /**
     * Return the vector sum `this - vector`
     * @param vector right side of addition.
     * @param result optional preallocated result.
     */
    plus(vector, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vector.x;
        result.y = this.y + vector.y;
        result.z = this.z + vector.z;
        return result;
    }
    /**
     * Return the vector difference `this - vector`
     * @param vector right side of subtraction.
     * @param result optional preallocated result.
     */
    minus(vector, result) {
        result = result ? result : new Vector3d();
        result.x = this.x - vector.x;
        result.y = this.y - vector.y;
        result.z = this.z - vector.z;
        return result;
    }
    /** Return vector + vector * scalar */
    plusScaled(vector, scaleFactor, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vector.x * scaleFactor;
        result.y = this.y + vector.y * scaleFactor;
        result.z = this.z + vector.z * scaleFactor;
        return result;
    }
    /** Return the (strongly typed Vector3d) `this Vector3d + vectorA * scalarA + vectorB * scalarB` */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;
        result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB;
        return result;
    }
    /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        result = result ? result : new Vector3d();
        result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;
        result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;
        result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC;
        return result;
    }
    /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB` */
    static createAdd2Scaled(vectorA, scaleA, vectorB, scaleB, result) {
        return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB, vectorA.y * scaleA + vectorB.y * scaleB, vectorA.z * scaleA + vectorB.z * scaleB, result);
    }
    /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB` with all components presented as numbers */
    static createAdd2ScaledXYZ(ax, ay, az, scaleA, bx, by, bz, scaleB, result) {
        return Vector3d.create(ax * scaleA + bx * scaleB, ay * scaleA + by * scaleB, az * scaleA + bz * scaleB, result);
    }
    /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scaleA + vectorB * scaleB + vectorC * scaleC` */
    static createAdd3Scaled(vectorA, scaleA, vectorB, scaleB, vectorC, scaleC, result) {
        return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB + vectorC.x * scaleC, vectorA.y * scaleA + vectorB.y * scaleB + vectorC.y * scaleC, vectorA.z * scaleA + vectorB.z * scaleB + vectorC.z * scaleC, result);
    }
    /** Return vector * scalar */
    scale(scale, result) {
        result = result ? result : new Vector3d();
        result.x = this.x * scale;
        result.y = this.y * scale;
        result.z = this.z * scale;
        return result;
    }
    /**
     * Return a (optionally new or reused) vector in the direction of `this` but with specified length.
     * @param length desired length of vector
     * @param result optional preallocated result
     */
    scaleToLength(length, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitude());
        if (mag === 0)
            return undefined;
        return this.scale(length / mag, result);
    }
    /** Compute the cross product of this vector with `vectorB`.   Immediately pass it to `normalize`.
     * @param vectorB second vector for cross product.
     * @returns see `Vector3d` method `normalize()` for error condition.
     */
    unitCrossProduct(vectorB, result) {
        return this.crossProduct(vectorB, result).normalize(result);
    }
    /**
     * Compute the cross product of this vector with `vectorB`.   Normalize it, using given xyz as default if length is zero.
     * @param vectorB second vector of cross product
     * @param x x value for default result
     * @param y y value for default result
     * @param z z value for default result
     * @param result optional pre-allocated result.
     */
    unitCrossProductWithDefault(vectorB, x, y, z, result) {
        const unit = this.crossProduct(vectorB, result).normalize(result);
        if (unit === undefined)
            return Vector3d.create(x, y, z, result);
        return unit;
    }
    /**
     * Normalize this vector, using given xyz as default if length is zero.
     * * if this instance and x,y,z are both 000, return unit x vector.
     * @param x x value for default result
     * @param y y value for default result
     * @param z z value for default result
     * @param result optional pre-allocated result.
     */
    normalizeWithDefault(x, y, z, result) {
        const unit = this.normalize(result);
        if (unit)
            return unit;
        // try back to x,y,z
        result = Vector3d.create(x, y, z, result);
        if (result.normalizeInPlace())
            return result;
        return Vector3d.create(1, 0, 0, result);
    }
    /**
     * Try to normalize (divide by magnitude), storing the result in place.
     * @param smallestMagnitude smallest magnitude allowed as divisor.
     * @returns false if magnitude is too small.  In this case the vector is unchanged.
     */
    tryNormalizeInPlace(smallestMagnitude = Geometry_1.Geometry.smallMetricDistance) {
        const a = this.magnitude();
        if (a < smallestMagnitude || a === 0.0)
            return false;
        this.scaleInPlace(1.0 / a);
        return true;
    }
    /**
     * Compute cross product with `vectorB`.
     * @param vectorB second vector for cross product.
     * @param productLength desired length of result vector.
     * @param result optional preallocated vector
     * @return undefined if the cross product is near zero length.
     */
    sizedCrossProduct(vectorB, productLength, result) {
        result = this.crossProduct(vectorB, result);
        if (result.tryNormalizeInPlace()) {
            result.scaleInPlace(productLength);
            return result;
        }
        return undefined;
    }
    /**
     * Compute the squared magnitude of a cross product (without allocating a temporary vector object)
     * @param vectorB second vector of cross product
     * @returns the squared magnitude of the cross product of this instance with vectorB.
     */
    crossProductMagnitudeSquared(vectorB) {
        const xx = this.y * vectorB.z - this.z * vectorB.y;
        const yy = this.z * vectorB.x - this.x * vectorB.z;
        const zz = this.x * vectorB.y - this.y * vectorB.x;
        return xx * xx + yy * yy + zz * zz;
    }
    /**
     * Compute the  magnitude of a cross product (without allocating a temporary vector object)
     * @param vectorB second vector of cross product
     * @returns the  magnitude of the cross product of this instance with vectorB.
     */
    crossProductMagnitude(vectorB) {
        return Math.sqrt(this.crossProductMagnitudeSquared(vectorB));
    }
    /** Return the dot product of this vector with vectorB.
     * @param vectorB second vector of cross product
     * @returns the dot product of this instance with vectorB
     */
    dotProduct(vectorB) {
        return this.x * vectorB.x + this.y * vectorB.y + this.z * vectorB.z;
    }
    /**
     * Returns the dot product of this vector with the with vector from pointA to pointB
     * @param pointA start point of second vector of dot product
     * @param pointB end point of second vector of dot product
     */
    dotProductStartEnd(pointA, pointB) {
        return this.x * (pointB.x - pointA.x)
            + this.y * (pointB.y - pointA.y)
            + this.z * (pointB.z - pointA.z);
    }
    /**
     * Returns the dot product with vector (pointB - pointA * pointB.w)
     * * That is, pointA is weighted to weight of pointB.
     * * If pointB.w is zero, the homogeneous pointB is a simple vector
     * * If pointB.w is nonzero, the vector "from A to B" is not physical length.
     */
    dotProductStart3dEnd4d(pointA, pointB) {
        const w = pointB.w;
        return this.x * (pointB.x - pointA.x * w)
            + this.y * (pointB.y - pointA.y * w)
            + this.z * (pointB.z - pointA.z * w);
    }
    /** Cross product with vector from pointA to pointB */
    crossProductStartEnd(pointA, pointB, result) {
        return Vector3d.createCrossProduct(this.x, this.y, this.z, pointB.x - pointA.x, pointB.y - pointA.y, pointB.z - pointA.z, result);
    }
    /** Cross product (xy parts only) with vector from pointA to pointB */
    crossProductStartEndXY(pointA, pointB) {
        return Geometry_1.Geometry.crossProductXYXY(this.x, this.y, pointB.x - pointA.x, pointB.y - pointA.y);
    }
    /** Dot product with vector from pointA to pointB, with pointB given as x,y,z */
    dotProductStartEndXYZ(pointA, x, y, z) {
        return this.x * (x - pointA.x)
            + this.y * (y - pointA.y)
            + this.z * (z - pointA.z);
    }
    /** Dot product with vector from pointA to pointB, with pointB given as (weighted) x,y,z,w
     * * pointB is a homogeneous point that has to be unweighted
     * * if the weight is near zero metric, the return is zero.
     */
    dotProductStartEndXYZW(pointA, x, y, z, w) {
        if (Geometry_1.Geometry.isSmallMetricDistance(w))
            return 0.0;
        const dw = 1.0 / w;
        return this.x * (dw * x - pointA.x)
            + this.y * (dw * y - pointA.y)
            + this.z * (dw * z - pointA.z);
    }
    /** Return the dot product of the instance and vectorB, using only the x and y parts. */
    dotProductXY(vectorB) {
        return this.x * vectorB.x + this.y * vectorB.y;
    }
    /**
     * Dot product with vector (x,y,z)
     * @param x x component for dot product
     * @param y y component for dot product
     * @param z z component for dot product
     */
    dotProductXYZ(x, y, z = 0) {
        return this.x * x + this.y * y + this.z * z;
    }
    /** Return the triple product of the instance, vectorB, and vectorC  */
    tripleProduct(vectorB, vectorC) {
        return Geometry_1.Geometry.tripleProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, vectorC.x, vectorC.y, vectorC.z);
    }
    /** Return the cross product of the instance and vectorB, using only the x and y parts. */
    crossProductXY(vectorB) {
        return this.x * vectorB.y - this.y * vectorB.x;
    }
    /**
     * Return the cross product of this vector and vectorB.
     * @param vectorB second vector of cross product
     * @param result optional preallocated result.
     */
    crossProduct(vectorB, result) {
        return Vector3d.createCrossProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, result);
    }
    /**
     * return cross product of `this` with the vector `(x, y, z)`
     * @param x x component of second vector
     * @param y y component of second vector
     * @param z z component of second vector
     * @param result computed cross product (new Vector3d).
     */
    crossProductXYZ(x, y, z, result) {
        return Vector3d.createCrossProduct(this.x, this.y, this.z, x, y, z, result);
    }
    /**
     * Return the (Strongly typed) angle from this vector to vectorB.
     * * The returned angle is always positive and no larger than 180 degrees (PI radians)
     * * The returned angle is "in the plane containing the two vectors"
     * * Use `planarAngleTo`, `signedAngleTo`, `angleToXY` to take have angle measured in specific plane.
     * @param vectorB target vector of rotation.
     */
    angleTo(vectorB) {
        return Angle_1.Angle.createAtan2(this.crossProductMagnitude(vectorB), this.dotProduct(vectorB));
    }
    /**
     * Return the (Strongly typed) angle from this vector to the plane perpendicular to planeNormal.
     * * The returned vector is signed
     * * The returned vector is (as degrees) always less than or equal to 90 degrees.
     * @param planeNormal a normal vector to the plane
     */
    angleFromPerpendicular(vectorB) {
        return Angle_1.Angle.createAtan2(this.dotProduct(vectorB), this.crossProductMagnitude(vectorB));
    }
    /**
     * Return the (Strongly typed) angle from this vector to vectorB,using only the xy parts.
     * * The returned angle can range from negative 180 degrees (negative PI radians) to positive 180 degrees (positive PI radians), not closed on the negative side.
     * * Use `planarAngleTo`, `signedAngleTo`, `angleToXY` to take have angle measured in other planes.
     * @param vectorB target vector of rotation.
     */
    angleToXY(vectorB) {
        return Angle_1.Angle.createAtan2(this.crossProductXY(vectorB), this.dotProductXY(vectorB));
    }
    /**
     * Return the (radians as a simple number, not strongly typed Angle) radians from this vector to vectorB.
     * * The returned angle can be positive or negative, with magnitude no larger than PI radians
     * * Use signedRadiansTo` to take have angle measured in other planes.
     * @param vectorB target vector of rotation.
     */
    planarRadiansTo(vector, planeNormal) {
        const square = planeNormal.dotProduct(planeNormal);
        if (square === 0.0)
            return 0.0;
        const factor = 1.0 / square;
        const projection0 = this.plusScaled(planeNormal, -this.dotProduct(planeNormal) * factor);
        const projection1 = vector.plusScaled(planeNormal, -vector.dotProduct(planeNormal) * factor);
        return projection0.signedRadiansTo(projection1, planeNormal);
    }
    /**
     * Return the (as strongly typed Angle) Angle from this vector to vectorB.
     * * The returned angle can range from negative PI to positive PI (not closed on negative side)
     * * Use signedRadiansTo` to take have angle measured in other planes.
     * @param vectorB target vector of rotation.
     */
    planarAngleTo(vector, planeNormal) {
        return Angle_1.Angle.createRadians(this.planarRadiansTo(vector, planeNormal));
    }
    /**
     * Return the (simple number of radians, not Strongly typed Angle) angle from this vector to vectorB, measured in the plane containing both, with vectorW indicating which side to view to control sign of the angle.
     * * The returned angle can range from negative PI to positive PI (not closed on negative side)
     * * The returned angle is "in the plane containing the two vectors"
     * * `vectorW` distinguishes between the sides of the plane, but does not have to be perpendicular.
     * * The returned angle has the same sign as vectorW dot product (thisVector cross vectorB)
     * @param vectorB target vector of rotation.
     */
    signedRadiansTo(vector1, vectorW) {
        const p = this.crossProduct(vector1);
        const theta = Math.atan2(p.magnitude(), this.dotProduct(vector1));
        if (vectorW.dotProduct(p) < 0.0)
            return -theta;
        else
            return theta;
    }
    /**
     * Return the (strongly typed Angle) angle from this vector to vectorB, measured in the plane containing both, with vectorW indicating which side to view to control sign of the angle.
     * * The returned angle can range from negative 180 degrees (negative PI radians) to positive 180 degrees (positive PI radians), not closed on the negative side.
     * * The returned angle is "in the plane containing the two vectors"
     * * `vectorW` distinguishes between the sides of the plane, but does not have to be perpendicular.
     * * The returned angle has the same sign as vectorW dot product (thisVector cross vectorB)
     * @param vectorB target vector of rotation.
     */
    signedAngleTo(vector1, vectorW) { return Angle_1.Angle.createRadians(this.signedRadiansTo(vector1, vectorW)); }
    /** Return the smallest (strongly typed) angle from the (bidirectional) line containing `this` to the (bidirectional) line containing `vectorB` */
    smallerUnorientedAngleTo(vectorB) {
        return Angle_1.Angle.createRadians(this.smallerUnorientedRadiansTo(vectorB));
    }
    /** Return the smallest angle (in radians) from the (bidirectional) line containing `this` to the (bidirectional) line containing `vectorB` */
    smallerUnorientedRadiansTo(vectorB) {
        const c = this.dotProduct(vectorB);
        const s = this.crossProductMagnitude(vectorB);
        return Math.atan2(Math.abs(s), Math.abs(c));
    }
    /*
      signedAngleTo(vectorB: Vector3d, upVector: Vector3d): Angle { }
      // sectors
      isInSmallerSector(vectorA: Vector3d, vectorB: Vector3d): boolean { }
      isInCCWSector(vectorA: Vector3d, vectorB: Vector3d, upVector: Vector3d): boolean { }
      */
    /**
     * Test if this vector is parallel to other.
     * @param other second vector in comparison
     * @param oppositeIsParallel if the vectors are on the same line but in opposite directions, return this value.
     * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.
     */
    isParallelTo(other, oppositeIsParallel = false, returnValueIfAnInputIsZeroLength = false) {
        const a2 = this.magnitudeSquared();
        const b2 = other.magnitudeSquared();
        // we know both are 0 or positive -- no need for
        if (a2 < Geometry_1.Geometry.smallMetricDistanceSquared || b2 < Geometry_1.Geometry.smallMetricDistanceSquared)
            return returnValueIfAnInputIsZeroLength;
        const dot = this.dotProduct(other);
        if (dot < 0.0 && !oppositeIsParallel)
            return returnValueIfAnInputIsZeroLength;
        const cross2 = this.crossProductMagnitudeSquared(other);
        /* a2,b2,cross2 are squared lengths of respective vectors */
        /* cross2 = sin^2(theta) * a2 * b2 */
        /* For small theta, sin^2(theta)~~theta^2 */
        return cross2 <= Geometry_1.Geometry.smallAngleRadiansSquared * a2 * b2;
    }
    /**
     * Test if this vector is perpendicular to other.
     * @param other second vector in comparison
     * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.
     */
    isPerpendicularTo(other, returnValueIfAnInputIsZeroLength = false) {
        const aa = this.magnitudeSquared();
        if (aa < Geometry_1.Geometry.smallMetricDistanceSquared)
            return returnValueIfAnInputIsZeroLength;
        const bb = other.magnitudeSquared();
        if (bb < Geometry_1.Geometry.smallMetricDistanceSquared)
            return returnValueIfAnInputIsZeroLength;
        const ab = this.dotProduct(other);
        return ab * ab <= Geometry_1.Geometry.smallAngleRadiansSquared * aa * bb;
    }
}
exports.Vector3d = Vector3d;


/***/ }),

/***/ "./lib/geometry3d/PointHelpers.js":
/*!****************************************!*\
  !*** ./lib/geometry3d/PointHelpers.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
/* tslint:disable:variable-name jsdoc-format no-empty */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const IndexedXYZCollection_1 = __webpack_require__(/*! ./IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js");
const PointStreaming_1 = __webpack_require__(/*! ./PointStreaming */ "./lib/geometry3d/PointStreaming.js");
const Range_1 = __webpack_require__(/*! ./Range */ "./lib/geometry3d/Range.js");
/**
 * The `NumberArray` class contains static methods that act on arrays of numbers.
 * @public
 */
class NumberArray {
    /** return the sum of values in an array,   The summation is done with correction terms which
     * improves last-bit numeric accuracy.
     */
    static preciseSum(data) {
        const n = data.length;
        if (n === 0)
            return 0.0;
        let sum = data[0];
        let c = 0.0;
        let y;
        let t;
        for (let i = 1; i < n; i++) {
            y = data[i] - c;
            t = sum + y;
            c = (t - sum) - y;
            sum = t;
        }
        return sum;
    }
    /** Return true if arrays have identical counts and equal entries (using `!==` comparison) */
    static isExactEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (dataA[i] !== dataB[i])
                    return false;
            return true;
        }
        return (dataA === undefined && dataB === undefined);
    }
    /** Return true if arrays have identical counts and entries equal within tolerance */
    static isAlmostEqual(dataA, dataB, tolerance) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (Math.abs(dataA[i] - dataB[i]) >= tolerance)
                    return false;
            return true;
        }
        return (dataA === undefined && dataB === undefined);
    }
    /** return the sum of numbers in an array.  Note that "PreciseSum" may be more accurate. */
    static sum(data) {
        let sum = 0;
        for (const x of data) {
            sum += x;
        }
        return sum;
    }
    /** test if coordinate x appears (to tolerance by `Geometry.isSameCoordinate`) in this array of numbers */
    static isCoordinateInArray(x, data) {
        if (data) {
            for (const y of data) {
                if (Geometry_1.Geometry.isSameCoordinate(x, y))
                    return true;
            }
        }
        return false;
    }
    /** Return the max absolute value in a array of numbers. */
    static maxAbsArray(values) {
        const arrLen = values.length;
        if (arrLen === 0) {
            return 0.0;
        }
        let a = Math.abs(values[0]);
        for (let i = 1; i < arrLen; i++) {
            const b = Math.abs(values[i]);
            if (a < b) {
                a = b;
            }
        }
        return a;
    }
    /** return the max absolute value of a pair of numbers */
    static maxAbsTwo(a1, a2) {
        a1 = Math.abs(a1);
        a2 = Math.abs(a2);
        return (a1 > a2) ? a1 : a2;
    }
    /** Return the max absolute difference between corresponding entries in two arrays of numbers
     * * If sizes are mismatched, only the smaller length is tested.
     */
    static maxAbsDiff(dataA, dataB) {
        let a = 0.0;
        const n = Math.min(dataA.length, dataB.length);
        for (let i = 0; i < n; i++) {
            a = Math.max(a, Math.abs(dataA[i] - dataB[i]));
        }
        return a;
    }
    /** Return the max absolute difference between corresponding entries in two Float64Array
     * * If sizes are mismatched, only the smaller length is tested.
     */
    static maxAbsDiffFloat64(dataA, dataB) {
        let a = 0.0;
        const n = Math.min(dataA.length, dataB.length);
        for (let i = 0; i < n; i++) {
            a = Math.max(a, Math.abs(dataA[i] - dataB[i]));
        }
        return a;
    }
}
exports.NumberArray = NumberArray;
/**
 * The `Point2dArray` class contains static methods that act on arrays of 2d points.
 * @public
 */
class Point2dArray {
    /** Return true if arrays have same length and matching coordinates. */
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++) {
                if (!dataA[i].isAlmostEqual(dataB[i]))
                    return false;
            }
            return true;
        }
        return (dataA === undefined && dataB === undefined);
    }
    /**
     * Return an array containing clones of the Point3d data[]
     * @param data source data
     */
    static clonePoint2dArray(data) {
        return data.map((p) => p.clone());
    }
    /**
     * Return the number of points when trailing points that match point 0 are excluded.
     * @param data array of XAndY points.
     */
    static pointCountExcludingTrailingWraparound(data) {
        let n = data.length;
        if (n < 2)
            return n;
        const x0 = data[0].x;
        const y0 = data[0].y;
        while (n > 1) {
            if (!Geometry_1.Geometry.isSameCoordinate(data[n - 1].x, x0) || !Geometry_1.Geometry.isSameCoordinate(data[n - 1].y, y0))
                return n;
            n--;
        }
        return n;
    }
}
exports.Point2dArray = Point2dArray;
/**
 * The `Vector3ddArray` class contains static methods that act on arrays of 2d vectors.
 * @public
 */
class Vector3dArray {
    /** Return true if arrays have same length and matching coordinates. */
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            for (let i = 0; i < dataA.length; i++)
                if (!dataA[i].isAlmostEqual(dataB[i]))
                    return false;
            return true;
        }
        return (dataA === undefined && dataB === undefined);
    }
    /**
     * Return an array containing clones of the Vector3d data[]
     * @param data source data
     */
    static cloneVector3dArray(data) {
        return data.map((p) => Point3dVector3d_1.Vector3d.create(p.x, p.y, p.z));
    }
}
exports.Vector3dArray = Vector3dArray;
/**
 * The `Point4dArray` class contains static methods that act on arrays of 4d points.
 * @public
 */
class Point4dArray {
    /** pack each point and its corresponding weight into a buffer of xyzw xyzw ... */
    static packPointsAndWeightsToFloat64Array(points, weights, result) {
        result = result ? result : new Float64Array(4 * points.length);
        let i = 0;
        let k = 0;
        for (k = 0; k < points.length; k++) {
            result[i++] = points[k].x;
            result[i++] = points[k].y;
            result[i++] = points[k].z;
            result[i++] = weights[k];
        }
        return result;
    }
    /** pack x,y,z,w in Float64Array. */
    static packToFloat64Array(data, result) {
        result = result ? result : new Float64Array(4 * data.length);
        let i = 0;
        for (const p of data) {
            result[i++] = p.x;
            result[i++] = p.y;
            result[i++] = p.z;
            result[i++] = p.w;
        }
        return result;
    }
    /** unpack from  ... to array of Point4d */
    static unpackToPoint4dArray(data) {
        const result = [];
        for (let i = 0; i + 3 < data.length; i += 4) {
            result.push(Point4d_1.Point4d.create(data[i], data[i + 1], data[i + 2], data[i + 3]));
        }
        return result;
    }
    /** unpack from xyzw xyzw... array to array of Point3d and array of weight.
     */
    static unpackFloat64ArrayToPointsAndWeights(data, points, weights, pointFormatter = Point3dVector3d_1.Point3d.create) {
        points.length = 0;
        weights.length = 0;
        for (let i = 0; i + 3 < data.length; i += 4) {
            points.push(pointFormatter(data[i], data[i + 1], data[i + 2]));
            weights.push(data[i + 3]);
        }
    }
    /**
     * Multiply (and replace) each block of 4 values as a Point4d.
     * @param transform transform to apply
     * @param xyzw array of x,y,z,w points.
     */
    static multiplyInPlace(transform, xyzw) {
        const numXYZW = xyzw.length;
        const xyzw1 = Point4dArray._workPoint4d;
        for (let i = 0; i + 3 < numXYZW; i += 4) {
            transform.multiplyXYZW(xyzw[i], xyzw[i + 1], xyzw[i + 2], xyzw[i + 3], xyzw1);
            xyzw[i] = xyzw1.x;
            xyzw[i + 1] = xyzw1.y;
            xyzw[i + 2] = xyzw1.z;
            xyzw[i + 3] = xyzw1.w;
        }
    }
    /** test for near equality of all corresponding numeric values, treated as coordinates. */
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            if (dataA instanceof Float64Array && dataB instanceof Float64Array) {
                for (let i = 0; i < dataA.length; i++)
                    if (!Geometry_1.Geometry.isSameCoordinate(dataA[i], dataB[i]))
                        return false;
            }
            else if (Array.isArray(dataA) && Array.isArray(dataB)) {
                for (let i = 0; i < dataA.length; i++)
                    if (!dataA[i].isAlmostEqual(dataB[i]))
                        return false;
            }
            return true;
        }
        // if both are null it is equal, otherwise unequal
        return (dataA === undefined && dataB === undefined);
    }
    /** return true iff all xyzw points' altitudes are within tolerance of the plane.*/
    static isCloseToPlane(data, plane, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        if (Array.isArray(data)) {
            for (const xyzw of data) {
                if (Math.abs(plane.altitudeXYZW(xyzw.x, xyzw.y, xyzw.z, xyzw.w)) > tolerance)
                    return false;
            }
        }
        else if (data instanceof Float64Array) {
            const numXYZ = data.length;
            for (let i = 0; i + 2 < numXYZ; i += 4) {
                if (Math.abs(plane.altitudeXYZW(data[i], data[i + 1], data[i + 2], data[i + 3])) > tolerance)
                    return false;
            }
        }
        return true;
    }
}
exports.Point4dArray = Point4dArray;
Point4dArray._workPoint4d = Point4d_1.Point4d.create();
/**
 * The `Point3dArray` class contains static methods that act on arrays of 3d points.
 * @public
 */
class Point3dArray {
    /** pack x,y,z to `Float64Array` */
    static packToFloat64Array(data) {
        const result = new Float64Array(3 * data.length);
        let i = 0;
        for (const p of data) {
            result[i++] = p.x;
            result[i++] = p.y;
            result[i++] = p.z;
        }
        return result;
    }
    /**
     * Compute the 8 weights of trilinear mapping
     * By appropriate choice of weights, this can be used for both point and derivative mappings.
     * @param weights preallocated array to receive weights.
     * @param u0 low u weight
     * @param u1 high u weight
     * @param v0 low v weight
     * @param v1 high v weight
     * @param w0 low w weight
     * @param w1 high w weight
     */
    static evaluateTrilinearWeights(weights, u0, u1, v0, v1, w0, w1) {
        weights[0] = u0 * v0 * w0;
        weights[1] = u1 * v0 * w0;
        weights[2] = u0 * v1 * w0;
        weights[3] = u1 * v1 * w0;
        weights[4] = u0 * v0 * w1;
        weights[5] = u1 * v0 * w1;
        weights[6] = u0 * v1 * w1;
        weights[7] = u1 * v1 * w1;
    }
    /**
     * sum the weighted x components from a point array.
     * * weights.length is the number of summed terms
     * * points must have at least that length
     * @param weights
     * @param points
     */
    static sumWeightedX(weights, points) {
        let sum = 0.0;
        const n = weights.length;
        for (let i = 0; i < n; i++)
            sum += weights[i] * points[i].x;
        return sum;
    }
    /**
     * sum the weighted x components from a point array.
     * * weights.length is the number of summed terms
     * * points must have at least that length
     * @param weights
     * @param points
     */
    static sumWeightedY(weights, points) {
        let sum = 0.0;
        const n = weights.length;
        for (let i = 0; i < n; i++)
            sum += weights[i] * points[i].y;
        return sum;
    }
    /**
     * sum the weighted x components from a point array.
     * * weights.length is the number of summed terms
     * * points must have at least that length
     * @param weights
     * @param points
     */
    static sumWeightedZ(weights, points) {
        let sum = 0.0;
        const n = weights.length;
        for (let i = 0; i < n; i++)
            sum += weights[i] * points[i].z;
        return sum;
    }
    /**
     * Compute a point by trilinear mapping.
     * @param points array of 8 points at corners, with x index varying fastest.
     * @param result optional result point
     */
    static evaluateTrilinearPoint(points, u, v, w, result) {
        if (!result)
            result = Point3dVector3d_1.Point3d.create(0, 0, 0);
        this.evaluateTrilinearWeights(this._weightUVW, 1 - u, u, 1 - v, v, 1 - w, w);
        let a;
        for (let i = 0; i < 8; i++) {
            a = this._weightUVW[i];
            result.x += a * points[i].x;
            result.y += a * points[i].y;
            result.z += a * points[i].z;
        }
        return result;
    }
    /**
     * Compute a point and derivatives wrt uvw by trilinear mapping.
     * * evaluated point is the point part of the transform
     * * u,v,w derivatives are the respective columns of the matrix part of the transform.
     * @param points array of 8 points at corners, with x index varying fastest.
     * @param result optional result transform
     */
    static evaluateTrilinearDerivativeTransform(points, u, v, w, result) {
        this.evaluateTrilinearWeights(this._weightUVW, 1 - u, u, 1 - v, v, 1 - w, w);
        this.evaluateTrilinearWeights(this._weightDU, -1, 1, 1 - v, v, 1 - w, w);
        this.evaluateTrilinearWeights(this._weightDV, 1 - u, u, -1, 1, 1 - w, w);
        this.evaluateTrilinearWeights(this._weightDW, 1 - u, u, 1 - v, v, -1, 1);
        return Transform_1.Transform.createRowValues(this.sumWeightedX(this._weightDU, points), this.sumWeightedX(this._weightDV, points), this.sumWeightedX(this._weightDW, points), this.sumWeightedX(this._weightUVW, points), this.sumWeightedY(this._weightDU, points), this.sumWeightedY(this._weightDV, points), this.sumWeightedY(this._weightDW, points), this.sumWeightedY(this._weightUVW, points), this.sumWeightedZ(this._weightDU, points), this.sumWeightedZ(this._weightDV, points), this.sumWeightedZ(this._weightDW, points), this.sumWeightedZ(this._weightUVW, points), result);
    }
    /** unpack from a number array or Float64Array to an array of `Point3d` */
    static unpackNumbersToPoint3dArray(data) {
        const result = [];
        for (let i = 0; i + 2 < data.length; i += 3) {
            result.push(Point3dVector3d_1.Point3d.create(data[i], data[i + 1], data[i + 2]));
        }
        return result;
    }
    /**
     * return an 2-dimensional array containing all the values of `data` in arrays of numPerBlock
     * @param data simple array of numbers
     * @param numPerBlock number of values in each block at first level down
     */
    static unpackNumbersToNestedArrays(data, numPerBlock) {
        const result = [];
        const n = data.length;
        let i = 0;
        let i1 = 0;
        while (i < n) {
            // there is at least one more value for a block
            const row = [];
            i1 = i + numPerBlock;
            if (i1 > n)
                i1 = n;
            for (; i < i1; i++) {
                row.push(data[i]);
            }
            result.push(row);
        }
        return result;
    }
    /**
     * return an 3-dimensional array containing all the values of `data` in arrays numPerRow blocks of numPerBlock
     * @param data simple array of numbers
     * @param numPerBlock number of values in each block at first level down
     */
    static unpackNumbersToNestedArraysIJK(data, numPerBlock, numPerRow) {
        const result = [];
        const n = data.length;
        let i = 0;
        let i1 = 0;
        let i2;
        while (i < n) {
            const row = [];
            i2 = i + numPerBlock * numPerRow;
            while (i < i2) {
                const block = [];
                i1 = i + numPerBlock;
                if (i1 > n)
                    i1 = n;
                for (; i < i1; i++) {
                    block.push(data[i]);
                }
                row.push(block);
            }
            result.push(row);
        }
        return result;
    }
    /**  multiply a transform times each x,y,z triple and replace the x,y,z in the packed array */
    static multiplyInPlace(transform, xyz) {
        const xyz1 = Point3dVector3d_1.Point3d.create();
        const numXYZ = xyz.length;
        for (let i = 0; i + 2 < numXYZ; i += 3) {
            transform.multiplyXYZ(xyz[i], xyz[i + 1], xyz[i + 2], xyz1);
            xyz[i] = xyz1.x;
            xyz[i + 1] = xyz1.y;
            xyz[i + 2] = xyz1.z;
        }
    }
    /** Apply Geometry.isAlmostEqual to corresponding coordinates */
    static isAlmostEqual(dataA, dataB) {
        if (dataA && dataB) {
            if (dataA.length !== dataB.length)
                return false;
            if (dataA instanceof Float64Array && dataB instanceof Float64Array) {
                for (let i = 0; i < dataA.length; i++)
                    if (!Geometry_1.Geometry.isSameCoordinate(dataA[i], dataB[i]))
                        return false;
            }
            else if (Array.isArray(dataA) && Array.isArray(dataB)) {
                for (let i = 0; i < dataA.length; i++)
                    if (!dataA[i].isAlmostEqual(dataB[i]))
                        return false;
            }
            return true;
        }
        // if both are null it is equal, otherwise unequal
        return (dataA === undefined && dataB === undefined);
    }
    /** return simple average of all coordinates.   (000 if empty array) */
    static centroid(points, result) {
        result = Point3dVector3d_1.Point3d.create(0, 0, 0, result);
        const p = Point3dVector3d_1.Point3d.create();
        if (points.length > 0) {
            for (let i = 0; i < points.length; i++) {
                points.getPoint3dAtCheckedPointIndex(i, p);
                result.x += p.x;
                result.y += p.y;
                result.z += p.z;
            }
            result.scaleInPlace(1.0 / points.length);
        }
        return result;
    }
    /** Return the index of the point most distant from spacePoint */
    static indexOfMostDistantPoint(points, spacePoint, farVector) {
        if (points.length === 0)
            return undefined;
        let dMax = -1;
        let d;
        let result = -1;
        for (let i = 0; i < points.length; i++) {
            d = spacePoint.distance(points[i]);
            if (d > dMax) {
                spacePoint.vectorTo(points[i], farVector);
                dMax = d;
                result = i;
            }
        }
        return result;
    }
    /** return the index of the point whose vector from space point has the largest magnitude of cross product with given vector. */
    static indexOfPointWithMaxCrossProductMagnitude(points, spacePoint, vector, farVector) {
        if (points.length === 0)
            return undefined;
        let dMax = -1;
        let d;
        let result = -1;
        let vectorAB; // to be reused in loop !!!
        for (let i = 0; i < points.length; i++) {
            vectorAB = spacePoint.vectorTo(points[i], vectorAB);
            d = vectorAB.crossProductMagnitude(vector);
            if (d > dMax) {
                farVector.setFrom(vectorAB);
                dMax = d;
                result = i;
            }
        }
        return result;
    }
    /** Return the index of the closest point in the array (full xyz) */
    static closestPointIndex(data, spacePoint) {
        let index = -1;
        let dMin = Number.MAX_VALUE;
        let d;
        const x0 = spacePoint.x;
        const y0 = spacePoint.y;
        const z0 = spacePoint.z;
        for (let i = 0; i < data.length; i++) {
            d = Geometry_1.Geometry.distanceXYZXYZ(x0, y0, z0, data[i].x, data[i].y, data[i].z);
            if (d < dMin) {
                index = i;
                dMin = d;
            }
        }
        return index;
    }
    /** return true iff all points' altitudes are within tolerance of the plane.*/
    static isCloseToPlane(data, plane, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        if (Array.isArray(data)) {
            let xyz;
            for (xyz of data) {
                if (Math.abs(plane.altitude(xyz)) > tolerance)
                    return false;
            }
        }
        else if (data instanceof Float64Array) {
            const numXYZ = data.length;
            for (let i = 0; i + 2 < numXYZ; i += 3) {
                if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)
                    return false;
            }
        }
        return true;
    }
    /**
     * Sum lengths of edges.
     * @param data points.
     */
    static sumEdgeLengths(data, addClosureEdge = false) {
        let sum = 0.0;
        if (Array.isArray(data)) {
            const n = data.length - 1;
            for (let i = 0; i < n; i++)
                sum += data[i].distance(data[i + 1]);
            if (addClosureEdge && n > 0)
                sum += data[0].distance(data[n]);
        }
        else if (data instanceof Float64Array) {
            const numXYZ = data.length;
            let i = 0;
            for (; i + 5 < numXYZ; i += 3) { // final i points at final point x
                sum += Geometry_1.Geometry.hypotenuseXYZ(data[i + 3] - data[i], data[i + 4] - data[i + 1], data[i + 5] - data[i + 2]);
            }
            if (addClosureEdge && i >= 3) {
                sum += Geometry_1.Geometry.hypotenuseXYZ(data[0] - data[i], data[1] - data[i + 1], data[2] - data[i + 2]);
            }
        }
        return sum;
    }
    /**
     * Return an array containing clones of the Point3d data[]
     * @param data source data
     */
    static clonePoint3dArray(data) {
        return data.map((p) => Point3dVector3d_1.Point3d.create(p.x, p.y, p.z));
    }
    /**
     * Return an array containing Point2d with xy parts of each Point3d
     * @param data source data
     */
    static clonePoint2dArray(data) {
        return data.map((p) => Point2dVector2d_1.Point2d.create(p.x, p.y));
    }
    /**
     * clone points in the input array, inserting points within each edge to limit edge length.
     * @param points array of points
     * @param maxEdgeLength max length of an edge
     */
    static cloneWithMaxEdgeLength(points, maxEdgeLength) {
        if (points.length === 0)
            return [];
        const result = [points[0]];
        for (let i = 1; i < points.length; i++) {
            const a = points[i - 1].distance(points[i]);
            const n = Geometry_1.Geometry.stepCount(maxEdgeLength, a, 1);
            for (let k = 1; k < n; k++)
                result.push(points[i - 1].interpolate(k / n, points[i]));
            result.push(points[i]);
        }
        return result;
    }
    /** Pack isolated x,y,z args as a json `[x,y,z]` */
    static xyzToArray(x, y, z) { return [x, y, z]; }
    /**
     * return similarly-structured array, array of arrays, etc, with the lowest level point data specifically structured as arrays of 3 numbers `[1,2,3]`
     * @param data point data with various leaf forms such as `[1,2,3]`, `{x:1,y:2,z:3}`, `Point3d`
     */
    static cloneDeepJSONNumberArrays(data) {
        const collector = new PointStreaming_1.PointStringDeepXYZArrayCollector(this.xyzToArray);
        PointStreaming_1.VariantPointDataStream.streamXYZ(data, collector);
        return collector.claimResult();
    }
    /**
     * return similarly-structured array, array of arrays, etc, with the lowest level point data specifically structured as `Point3d`.
     * @param data point data with various leaf forms such as `[1,2,3]`, `{x:1,y:2,z:3}`, `Point3d`
     */
    static cloneDeepXYZPoint3dArrays(data) {
        const collector = new PointStreaming_1.PointStringDeepXYZArrayCollector(Point3dVector3d_1.Point3d.create);
        PointStreaming_1.VariantPointDataStream.streamXYZ(data, collector);
        return collector.claimResult();
    }
    /**
     * `Point3dArray.createRange(data)` is deprecated.  Used `Range3d.createFromVariantData(data: MultiLineStringDataVariant): Range3d`
     * @deprecated Use Range3d.createFromVariantData (data)
     * @param data
     */
    static createRange(data) { return Range_1.Range3d.createFromVariantData(data); }
    /**
     * `Point3dArray.streamXYZ` is deprecated -- use `VariantPointStream.streamXYZ (handler)`
     * @deprecated - use VariantPointStream.streamXYZ (handler)
     * Invoke a callback with each x,y,z from an array of points in variant forms.
     * @param startChainCallback called to announce the beginning of points (or recursion)
     * @param pointCallback (index, x,y,z) = function to receive point coordinates one by one
     * @param endChainCallback called to announce the end of handling of an array.
     */
    static streamXYZ(data, startChainCallback, pointCallback, endChainCallback) {
        let numPoint = 0;
        if (Array.isArray(data)) {
            // If the first entry is a point, expect the entire array to be points.
            // otherwise recurse to each member of this array.
            if (data.length > 0 && Point3dVector3d_1.Point3d.isAnyImmediatePointType(data[0])) {
                if (startChainCallback)
                    startChainCallback(data, true);
                for (const p of data) {
                    const x = Point3dVector3d_1.Point3d.accessX(p);
                    const y = Point3dVector3d_1.Point3d.accessY(p);
                    const z = Point3dVector3d_1.Point3d.accessZ(p, 0);
                    if (x !== undefined && y !== undefined)
                        pointCallback(x, y, z);
                    numPoint++;
                }
                if (endChainCallback)
                    endChainCallback(data, true);
            }
            else {
                // This is an array that does not immediately have points.
                if (startChainCallback)
                    startChainCallback(data, false);
                for (const child of data) {
                    // tslint:disable-next-line: deprecation
                    numPoint += this.streamXYZ(child, startChainCallback, pointCallback, endChainCallback);
                }
                if (endChainCallback)
                    endChainCallback(data, false);
            }
        }
        else if (data instanceof IndexedXYZCollection_1.IndexedXYZCollection) {
            if (startChainCallback)
                startChainCallback(data, true);
            const q = Point3dArray._workPoint = Point3dVector3d_1.Point3d.create(0, 0, 0, Point3dArray._workPoint);
            for (let i = 0; i < data.length; i++) {
                data.getPoint3dAtCheckedPointIndex(i, q);
                numPoint++;
                pointCallback(q.x, q.y, q.z);
            }
            if (endChainCallback)
                endChainCallback(data, true);
        }
        return numPoint;
    }
    /**
       * `Point3dArray.streamXYZXYZ` is deprecated -- use `VariantPointStream.streamXYZXYZ (handler)`
     * @deprecated - use VariantPointStream.streamXYZXYZ (handler)
     * Invoke a callback with each x,y,z from an array of points in variant forms.
     * @param startChainCallback callback of the form `startChainCallback (source, isLeaf)` to be called with the source array at each level.
     * @param segmentCallback callback of the form `segmentCallback (index0, x0,y0,z0, index1, x1,y1,z1)`
     * @param endChainCallback callback of the form `endChainCallback (source, isLeaf)` to be called with the source array at each level.
    */
    static streamXYZXYZ(data, startChainCallback, segmentCallback, endChainCallback) {
        let x0 = 0, y0 = 0, z0 = 0, x1, y1, z1;
        let point0Known = false;
        let numSegment = 0;
        if (Array.isArray(data)) {
            if (data.length > 0 && Point3dVector3d_1.Point3d.isAnyImmediatePointType(data[0])) {
                if (startChainCallback)
                    startChainCallback(data, true);
                for (const p of data) {
                    x1 = Point3dVector3d_1.Point3d.accessX(p);
                    y1 = Point3dVector3d_1.Point3d.accessY(p);
                    z1 = Point3dVector3d_1.Point3d.accessZ(p, 0);
                    if (x1 !== undefined && y1 !== undefined) {
                        if (point0Known) {
                            segmentCallback(x0, y0, z0, x1, y1, z1);
                            numSegment++;
                        }
                        point0Known = true;
                        x0 = x1;
                        y0 = y1;
                        z0 = z1;
                    }
                }
                if (endChainCallback)
                    endChainCallback(data, true);
            }
            else {
                // This is an array that does not immediately have points.
                if (startChainCallback)
                    startChainCallback(data, false);
                for (const child of data) {
                    // tslint:disable-next-line: deprecation
                    numSegment += this.streamXYZXYZ(child, startChainCallback, segmentCallback, endChainCallback);
                }
                if (endChainCallback)
                    endChainCallback(data, false);
            }
        }
        else if (data instanceof IndexedXYZCollection_1.IndexedXYZCollection) {
            if (startChainCallback)
                startChainCallback(data, true);
            const q = Point3dArray._workPoint = Point3dVector3d_1.Point3d.create(0, 0, 0, Point3dArray._workPoint);
            for (let i = 0; i < data.length; i++) {
                data.getPoint3dAtCheckedPointIndex(i, q);
                if (i > 0) {
                    numSegment++;
                    segmentCallback(x0, y0, z0, q.x, q.y, q.z);
                }
                x0 = q.x;
                y0 = q.y;
                z0 = q.z;
            }
            if (endChainCallback)
                endChainCallback(data, true);
        }
        return numSegment;
    }
    /** Computes the hull of the XY projection of points.
     * * Returns the hull as an array of Point3d
     * * Optionally returns non-hull points in `insidePoints[]`
     * * If both arrays empty if less than 3 points.
     * *
     */
    static computeConvexHullXY(points, hullPoints, insidePoints, addClosurePoint = false) {
        hullPoints.length = 0;
        insidePoints.length = 0;
        let n = points.length;
        // Get deep copy
        const xy1 = points.slice(0, n);
        xy1.sort(Geometry_1.Geometry.lexicalXYLessThan);
        if (n < 3) {
            for (const p of xy1)
                hullPoints.push(p);
            if (addClosurePoint && xy1.length > 0)
                hullPoints.push(xy1[0]);
            return;
        }
        hullPoints.push(xy1[0]); // This is sure to stay
        hullPoints.push(xy1[1]); // This one can be removed in loop.
        let numInside = 0;
        // First sweep creates upper hull
        for (let i = 2; i < n; i++) {
            const candidate = xy1[i];
            let top = hullPoints.length - 1;
            while (top >= 1 && hullPoints[top - 1].crossProductToPointsXY(hullPoints[top], candidate) <= 0.0) {
                xy1[numInside++] = hullPoints[top];
                top--;
                hullPoints.pop();
            }
            hullPoints.push(candidate);
        }
        const i0 = hullPoints.length - 1;
        xy1.length = numInside;
        xy1.push(hullPoints[0]); // force first point to be reconsidered as final hull point.
        xy1.sort(Geometry_1.Geometry.lexicalXYLessThan);
        n = xy1.length;
        // xy1.back () is already on stack.
        hullPoints.push(xy1[n - 1]);
        for (let i = n - 1; i-- > 0;) {
            const candidate = xy1[i];
            let top = hullPoints.length - 1;
            while (top > i0 && hullPoints[top - 1].crossProductToPointsXY(hullPoints[top], candidate) <= 0.0) {
                insidePoints.push(hullPoints[top]);
                top--;
                hullPoints.pop();
            }
            if (i > 0) // don't replicate start !!!
                hullPoints.push(candidate);
        }
        if (addClosurePoint)
            hullPoints.push(hullPoints[0]);
    }
    /**
     * Return (clones of) points in data[] with min and max x and y parts.
     * @param data array to examine.
     */
    static minMaxPoints(data) {
        if (data.length === 0)
            return undefined;
        const result = { minXPoint: data[0].clone(), maxXPoint: data[0].clone(), minYPoint: data[0].clone(), maxYPoint: data[0].clone() };
        let q;
        for (let i = 1; i < data.length; i++) {
            q = data[i];
            if (q.x < result.minXPoint.x)
                result.minXPoint.setFromPoint3d(q);
            if (q.x > result.maxXPoint.x)
                result.maxXPoint.setFromPoint3d(q);
            if (q.y < result.minYPoint.y)
                result.minYPoint.setFromPoint3d(q);
            if (q.y > result.maxYPoint.y)
                result.maxYPoint.setFromPoint3d(q);
        }
        return result;
    }
}
exports.Point3dArray = Point3dArray;
Point3dArray._weightUVW = new Float64Array(8);
Point3dArray._weightDU = new Float64Array(8);
Point3dArray._weightDV = new Float64Array(8);
Point3dArray._weightDW = new Float64Array(8);


/***/ }),

/***/ "./lib/geometry3d/PointStreaming.js":
/*!******************************************!*\
  !*** ./lib/geometry3d/PointStreaming.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
/* tslint:disable:variable-name jsdoc-format no-empty */
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const IndexedXYZCollection_1 = __webpack_require__(/*! ./IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js");
const Range_1 = __webpack_require__(/*! ./Range */ "./lib/geometry3d/Range.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ./GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
//
// remarks: point array variants . . .
//  * [[x,y,z], ...]
//  * [[Point3d, Point3d]
//  * [GrowableXYZArray, ..]
//
/**
 * "no-op" base class for stream handlers
 * @internal
 */
class PointStreamXYZHandlerBase {
    startChain(_chainData, _isLeaf) { }
    handleXYZ(_x, _y, _z) { }
    endChain(_chainData, _isLeaf) { }
}
exports.PointStreamXYZHandlerBase = PointStreamXYZHandlerBase;
/** Base class for handling points in pairs.
 * * Callers implement handleXYZXYZ to receive point pairs.
 * * Callers may implement startChain and endChain.
 *   * Beware that if startChain is implemented it must call super.startChain () to reset internal x0, y0,z0 to undefined.
 *   * If that is not done, a point pair will appear from the end of previous chain to start of new chain.
 *   * This (intermediate base) class does NOT override startChain
 */
class PointStreamXYZXYZHandlerBase extends PointStreamXYZHandlerBase {
    handleXYZ(x, y, z) {
        if (this._x0 !== undefined)
            this.handleXYZXYZ(this._x0, this._y0, this._z0, x, y, z);
        this._x0 = x;
        this._y0 = y;
        this._z0 = z;
    }
    startChain(_chainData, _isLeaf) {
        this._x0 = this._y0 = this._z0 = undefined;
    }
    /**
     * Handler function called successively for each point0, point1 pair.  Concrete class should implement this.
     * @param _x0 x coordinate at point 0
     * @param _y0 y coordinate of point 0
     * @param _z0 z coordinate of point 0
     * @param _x1 x coordinate of point 1
     * @param _y1 y coordinate of point 1
     * @param _z1 z coordinate of point 1
     */
    handleXYZXYZ(_x0, _y0, _z0, _x1, _y1, _z1) { }
}
exports.PointStreamXYZXYZHandlerBase = PointStreamXYZXYZHandlerBase;
/**
 * Concrete class to handle startChain, handleXYZ and endChain calls and return a (one-level deep array of
 * GrowableXYZArray
 */
class PointStreamGrowableXYZArrayCollector extends PointStreamXYZHandlerBase {
    startChain(_chainData, _isLeaf) {
        this._currentData = undefined;
    }
    handleXYZ(x, y, z) {
        if (!this._currentData)
            this._currentData = new GrowableXYZArray_1.GrowableXYZArray();
        this._currentData.pushXYZ(x, y, z);
    }
    endChain(_chainData, _isLeaf) {
        if (this._currentData !== undefined) {
            if (this._pointArrays === undefined)
                this._pointArrays = [];
            this._pointArrays.push(this._currentData);
            this._currentData = undefined;
        }
    }
    /** Return MultiLineStringDataVariant as an array of GrowableXYZArray */
    claimArrayOfGrowableXYZArray() {
        const result = this._pointArrays;
        this._pointArrays = undefined;
        return result;
    }
}
exports.PointStreamGrowableXYZArrayCollector = PointStreamGrowableXYZArrayCollector;
/**
 * PointStream handler to collect the range of points.
 */
class PointStreamRangeCollector extends PointStreamXYZHandlerBase {
    constructor() {
        super(...arguments);
        this._range = Range_1.Range3d.createNull();
    }
    handleXYZ(x, y, z) {
        if (!this._range)
            this._range = Range_1.Range3d.createNull();
        this._range.extendXYZ(x, y, z);
    }
    claimResult() {
        const range = this._range;
        this._range = undefined;
        if (!range)
            return Range_1.Range3d.createNull();
        return range;
    }
}
exports.PointStreamRangeCollector = PointStreamRangeCollector;
class PointStringDeepXYZArrayCollector {
    /**
     *
     * @param xyzFunction function to map (x,y,z) to the leaf object type in the arrays.
     */
    constructor(xyzFunction) {
        this._xyzFunction = xyzFunction;
        this._resultStack = [];
        // create the [0] placeholder.
        this._resultStack.push([]);
    }
    startChain(_chainData, _isLeaf) {
        this._resultStack.push([]);
    }
    handleXYZ(x, y, z) {
        this._resultStack[this._resultStack.length - 1].push(this._xyzFunction(x, y, z));
    }
    endChain(_chainData, _isLeaf) {
        const q = this._resultStack[this._resultStack.length - 1];
        this._resultStack.pop();
        this._resultStack[this._resultStack.length - 1].push(q);
    }
    claimResult() {
        const r = this._resultStack[0];
        if (r.length === 1)
            return r[0];
        return r;
    }
}
exports.PointStringDeepXYZArrayCollector = PointStringDeepXYZArrayCollector;
/**
 * class for converting variant point data into more specific forms.
 * @internal
 */
class VariantPointDataStream {
    /** Invoke a callback with each x,y,z from an array of points in variant forms.
     * @param startChainCallback called to announce the beginning of points (or recursion)
     * @param pointCallback (index, x,y,z) = function to receive point coordinates one by one
     * @param endChainCallback called to announce the end of handling of an array.
     */
    static streamXYZ(data, handler) {
        let numPoint = 0;
        if (Array.isArray(data)) {
            // If the first entry is a point, expect the entire array to be points.
            // otherwise recurse to each member of this array.
            if (data.length > 0 && Point3dVector3d_1.Point3d.isAnyImmediatePointType(data[0])) {
                handler.startChain(data, true);
                for (const p of data) {
                    const x = Point3dVector3d_1.Point3d.accessX(p);
                    const y = Point3dVector3d_1.Point3d.accessY(p);
                    const z = Point3dVector3d_1.Point3d.accessZ(p, 0);
                    if (x !== undefined && y !== undefined)
                        handler.handleXYZ(x, y, z);
                    numPoint++;
                }
                handler.endChain(data, true);
            }
            else {
                // This is an array that does not immediately have points.
                handler.startChain(data, false);
                for (const child of data) {
                    numPoint += this.streamXYZ(child, handler);
                }
                handler.endChain(data, false);
            }
        }
        else if (data instanceof IndexedXYZCollection_1.IndexedXYZCollection) {
            handler.startChain(data, true);
            const q = VariantPointDataStream._workPoint = Point3dVector3d_1.Point3d.create(0, 0, 0, VariantPointDataStream._workPoint);
            for (let i = 0; i < data.length; i++) {
                data.getPoint3dAtCheckedPointIndex(i, q);
                numPoint++;
                handler.handleXYZ(q.x, q.y, q.z);
            }
            handler.endChain(data, true);
        }
        return numPoint;
    }
}
exports.VariantPointDataStream = VariantPointDataStream;


/***/ }),

/***/ "./lib/geometry3d/PolygonOps.js":
/*!**************************************!*\
  !*** ./lib/geometry3d/PolygonOps.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Matrix4d_1 = __webpack_require__(/*! ../geometry4d/Matrix4d */ "./lib/geometry4d/Matrix4d.js");
const Ray3d_1 = __webpack_require__(/*! ./Ray3d */ "./lib/geometry3d/Ray3d.js");
const IndexedXYZCollection_1 = __webpack_require__(/*! ./IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js");
const Point3dArrayCarrier_1 = __webpack_require__(/*! ./Point3dArrayCarrier */ "./lib/geometry3d/Point3dArrayCarrier.js");
const XYParitySearchContext_1 = __webpack_require__(/*! ../topology/XYParitySearchContext */ "./lib/topology/XYParitySearchContext.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ./GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const Range_1 = __webpack_require__(/*! ./Range */ "./lib/geometry3d/Range.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
/** Static class for operations that treat an array of points as a polygon (with area!) */
/**
 * Various (static method) computations for arrays of points interpreted as a polygon.
 * @public
 */
class PolygonOps {
    /** Sum areas of triangles from points[0] to each far edge.
     * * Consider triangles from points[0] to each edge.
     * * Sum the areas(absolute, without regard to orientation) all these triangles.
     * @returns sum of absolute triangle areas.
     */
    static sumTriangleAreas(points) {
        let s = 0;
        const n = points.length;
        if (Array.isArray(points)) {
            if (n >= 3) {
                const origin = points[0];
                const vector0 = origin.vectorTo(points[1]);
                let vector1 = Point3dVector3d_1.Vector3d.create();
                // This will work with or without closure edge.  If closure is given, the last vector is 000.
                for (let i = 2; i < n; i++) {
                    vector1 = origin.vectorTo(points[i], vector1);
                    s += vector0.crossProductMagnitude(vector1);
                    vector0.setFrom(vector1);
                }
            }
            return s * 0.5;
        }
        const crossVector = Point3dVector3d_1.Vector3d.create();
        for (let i = 2; i < n; i++) {
            points.crossProductIndexIndexIndex(0, i - 1, i, crossVector);
            s += crossVector.magnitude();
        }
        return s * 0.5;
    }
    /** Sum areas of triangles from points[0] to each far edge.
     * * Consider triangles from points[0] to each edge.
     * * Sum the areas(absolute, without regard to orientation) all these triangles.
     * @returns sum of absolute triangle areas.
     */
    static sumTriangleAreasXY(points) {
        let s = 0.0;
        const n = points.length;
        if (n >= 3) {
            const origin = points[0];
            const vector0 = origin.vectorTo(points[1]);
            let vector1 = Point3dVector3d_1.Vector3d.create();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                vector1 = origin.vectorTo(points[i], vector1);
                s += vector0.crossProductXY(vector1);
                vector0.setFrom(vector1);
            }
        }
        s *= 0.5;
        // console.log ("polygon area ", s, points);
        return s;
    }
    /** return a vector which is perpendicular to the polygon and has magnitude equal to the polygon area. */
    static areaNormalGo(points, result) {
        if (!result)
            result = new Point3dVector3d_1.Vector3d();
        const n = points.length;
        if (n === 3) {
            points.crossProductIndexIndexIndex(0, 1, 2, result);
        }
        else if (n >= 3) {
            result.setZero();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                points.accumulateCrossProductIndexIndexIndex(0, i - 1, i, result);
            }
        }
        // ALL BRANCHES SUM FULL CROSS PRODUCTS AND EXPECT SCALE HERE
        result.scaleInPlace(0.5);
        return result;
    }
    /** return a vector which is perpendicular to the polygon and has magnitude equal to the polygon area. */
    static areaNormal(points, result) {
        if (!result)
            result = Point3dVector3d_1.Vector3d.create();
        PolygonOps.areaNormalGo(new Point3dArrayCarrier_1.Point3dArrayCarrier(points), result);
        return result;
    }
    /** return the area of the polygon.
     * * This assumes the polygon is planar
     * * This does NOT assume the polygon is on the xy plane.
     */
    static area(points) {
        return PolygonOps.areaNormal(points).magnitude();
    }
    /** return the projected XY area of the polygon. */
    static areaXY(points) {
        let area = 0.0;
        if (points instanceof IndexedXYZCollection_1.IndexedXYZCollection) {
            if (points.length > 2) {
                const x0 = points.getXAtUncheckedPointIndex(0);
                const y0 = points.getYAtUncheckedPointIndex(0);
                let u1 = points.getXAtUncheckedPointIndex(1) - x0;
                let v1 = points.getYAtUncheckedPointIndex(1) - y0;
                let u2, v2;
                for (let i = 1; i + 1 < points.length; i++, u1 = u2, v1 = v2) {
                    u2 = points.getXAtUncheckedPointIndex(i) - x0;
                    v2 = points.getYAtUncheckedPointIndex(i) - y0;
                    area += Geometry_1.Geometry.crossProductXYXY(u1, v1, u2, v2);
                }
            }
        }
        else {
            for (let i = 1; i + 1 < points.length; i++)
                area += points[0].crossProductToPointsXY(points[i], points[i + 1]);
        }
        return 0.5 * area;
    }
    /**
     * Return a Ray3d with (assuming the polygon is planar and not self-intersecting)
     * * origin at the centroid of the (3D) polygon
     * * normal is a unit vector perpendicular to the plane
     * * 'a' member is the area.
     * @param points
     */
    static centroidAreaNormal(points) {
        if (Array.isArray(points)) {
            const carrier = new Point3dArrayCarrier_1.Point3dArrayCarrier(points);
            return this.centroidAreaNormal(carrier);
        }
        else if (points instanceof IndexedXYZCollection_1.IndexedXYZCollection) {
            return this.centroidAreaNormalGo(points);
        }
        return undefined;
    }
    /**
     * Return a Ray3d with (assuming the polygon is planar and not self-intersecting)
     * * origin at the centroid of the (3D) polygon
     * * normal is a unit vector perpendicular to the plane
     * * 'a' member is the area.
     * @param points
     */
    static centroidAreaNormalGo(points) {
        if (Array.isArray(points)) {
            const carrier = new Point3dArrayCarrier_1.Point3dArrayCarrier(points);
            return this.centroidAreaNormal(carrier);
        }
        const n = points.length;
        if (n === 3) {
            const normal = points.crossProductIndexIndexIndex(0, 1, 2);
            const a = 0.5 * normal.magnitude();
            const centroid = points.getPoint3dAtCheckedPointIndex(0);
            points.accumulateScaledXYZ(1, 1.0, centroid);
            points.accumulateScaledXYZ(2, 1.0, centroid);
            centroid.scaleInPlace(1.0 / 3.0);
            const result = Ray3d_1.Ray3d.createCapture(centroid, normal);
            if (result.tryNormalizeInPlaceWithAreaWeight(a))
                return result;
            return undefined;
        }
        if (n >= 3) {
            const areaNormal = Point3dVector3d_1.Vector3d.createZero();
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                points.accumulateCrossProductIndexIndexIndex(0, i - 1, i, areaNormal);
            }
            areaNormal.normalizeInPlace();
            const origin = points.getPoint3dAtCheckedPointIndex(0);
            const vector0 = Point3dVector3d_1.Vector3d.create();
            const vector1 = Point3dVector3d_1.Vector3d.create();
            points.vectorXYAndZIndex(origin, 1, vector0);
            let cross = Point3dVector3d_1.Vector3d.create();
            const centroidSum = Point3dVector3d_1.Vector3d.createZero();
            const normalSum = Point3dVector3d_1.Vector3d.createZero();
            let signedTriangleArea;
            // This will work with or without closure edge.  If closure is given, the last vector is 000.
            for (let i = 2; i < n; i++) {
                points.vectorXYAndZIndex(origin, i, vector1);
                cross = vector0.crossProduct(vector1, cross);
                signedTriangleArea = areaNormal.dotProduct(cross); // well, actually twice the area.
                normalSum.addInPlace(cross); // this grows to twice the area
                const b = signedTriangleArea / 6.0;
                centroidSum.plus2Scaled(vector0, b, vector1, b, centroidSum);
                vector0.setFrom(vector1);
            }
            const area = 0.5 * normalSum.magnitude();
            const inverseArea = Geometry_1.Geometry.conditionalDivideFraction(1, area);
            if (inverseArea !== undefined) {
                const result = Ray3d_1.Ray3d.createCapture(origin.plusScaled(centroidSum, inverseArea), normalSum);
                result.tryNormalizeInPlaceWithAreaWeight(area);
                return result;
            }
        }
        return undefined;
    }
    // Has the potential to be combined with centroidAreaNormal for point3d array and Ray3d return listed above...
    // Returns undefined if given point array less than 3 or if not safe to divide at any point
    /**
     * * Return (in caller-allocated centroid) the centroid of the xy polygon.
     * * Return (as function value)  the area
     */
    static centroidAndAreaXY(points, centroid) {
        let area = 0.0;
        centroid.set(0, 0);
        if (points.length < 3)
            return undefined;
        const origin = points[0];
        let vectorSum = Point2dVector2d_1.Vector2d.create(0, 0); // == sum ((U+V)/3) * (U CROSS V)/2 -- but leave out divisions
        let areaSum = 0.0; // == sum (U CROSS V) / 2 -- but leave out divisions
        for (let i = 1; i + 1 < points.length; i++) {
            const vector0 = origin.vectorTo(points[i]);
            const vector1 = origin.vectorTo(points[i + 1]);
            const tempArea = vector0.crossProduct(vector1);
            vectorSum = vectorSum.plus(vector0.plus(vector1).scale(tempArea));
            areaSum += tempArea;
        }
        area = areaSum * 0.5;
        const a = Geometry_1.Geometry.conditionalDivideFraction(1.0, 6.0 * area);
        if (a === undefined) {
            centroid.setFrom(origin);
            return undefined;
        }
        centroid.setFrom(origin.plusScaled(vectorSum, a));
        return area;
    }
    /**
     * Return a unit normal to the plane of the polygon.
     * @param points array of points around the polygon.  This is assumed to NOT have closure edge.
     * @param result caller-allocated result vector.
     */
    static unitNormal(points, result) {
        const n = points.length;
        if (n === 3) {
            points.crossProductIndexIndexIndex(0, 1, 2, result);
            return result.normalizeInPlace();
        }
        if (n === 4) {
            // cross product of diagonals is more stable than from single of the points . . .
            points.vectorIndexIndex(0, 2, PolygonOps._vector0);
            points.vectorIndexIndex(1, 3, PolygonOps._vector1);
            PolygonOps._vector0.crossProduct(PolygonOps._vector1, result);
            return result.normalizeInPlace();
        }
        // more than 4 points  ... no shortcuts ...
        PolygonOps.areaNormalGo(points, result);
        return result.normalizeInPlace();
    }
    /** Accumulate to the matrix of area products of a polygon with respect to an origin.
     * The polygon is assumed to be planar and non-self-intersecting.
     */
    /** Accumulate to the matrix of area products of a polygon with respect to an origin.
     * * The polygon is assumed to be planar and non-self-intersecting.
     * * Accumulated values are integrals over triangles from point 0 of the polygon to other edges of the polygon.
     * * Integral over each triangle is transformed to integrals from the given origin.
     * @param points array of points around the polygon.   Final closure point is not needed.
     * @param origin origin for global accumulation.
     * @param moments 4x4 matrix where products are accumulated.
     */
    static addSecondMomentAreaProducts(points, origin, moments) {
        this.addSecondMomentTransformedProducts(PolygonOps._triangleMomentWeights, points, origin, 2, moments);
    }
    /** Accumulate to the matrix of volume products of a polygon with respect to an origin.
     * * The polygon is assumed to be planar and non-self-intersecting.
     * * Accumulated values are integrals over tetrahedra from the origin to triangles on the polygon.
     * @param points array of points around the polygon.   Final closure point is not needed.
     * @param origin origin for tetrahedra
     * @param moments 4x4 matrix where products are accumulated.
     */
    static addSecondMomentVolumeProducts(points, origin, moments) {
        this.addSecondMomentTransformedProducts(PolygonOps._tetrahedralMomentWeights, points, origin, 3, moments);
    }
    /** Return the matrix of area products of a polygon with respect to an origin.
     * The polygon is assumed to be planar and non-self-intersecting.
     * * `frameType===2` has xy vectors in the plane of the polygon, plus a unit normal z. (Used for area integrals)
     * * `frameType===3` has vectors from origin to 3 points in the triangle. (Used for volume integrals)
     */
    static addSecondMomentTransformedProducts(firstQuadrantMoments, points, origin, frameType, moments) {
        const unitNormal = PolygonOps._normal;
        if (PolygonOps.unitNormal(points, unitNormal)) {
            // The direction of the normal makes the various detJ values positive or negative so that non-convex polygons
            // sum correctly.
            const vector01 = PolygonOps._vector0;
            const vector02 = PolygonOps._vector1;
            const vector03 = PolygonOps._vector2;
            const placement = PolygonOps._matrixA;
            const matrixAB = PolygonOps._matrixB;
            const matrixABC = PolygonOps._matrixC;
            const vectorOrigin = points.vectorXYAndZIndex(origin, 0, PolygonOps._vectorOrigin);
            const numPoints = points.length;
            let detJ = 0;
            for (let i2 = 2; i2 < numPoints; i2++) {
                if (frameType === 2) {
                    points.vectorIndexIndex(0, i2 - 1, vector01);
                    points.vectorIndexIndex(0, i2, vector02);
                    detJ = unitNormal.tripleProduct(vector01, vector02);
                    placement.setOriginAndVectors(vectorOrigin, vector01, vector02, unitNormal);
                    placement.multiplyMatrixMatrix(firstQuadrantMoments, matrixAB);
                    matrixAB.multiplyMatrixMatrixTranspose(placement, matrixABC);
                    moments.addScaledInPlace(matrixABC, detJ);
                }
                else if (frameType === 3) {
                    points.vectorXYAndZIndex(origin, 0, vector01);
                    points.vectorXYAndZIndex(origin, i2 - 1, vector02);
                    points.vectorXYAndZIndex(origin, i2, vector03);
                    detJ = vector01.tripleProduct(vector02, vector03);
                    placement.setOriginAndVectors(origin, vector01, vector02, vector03);
                    placement.multiplyMatrixMatrix(firstQuadrantMoments, matrixAB);
                    matrixAB.multiplyMatrixMatrixTranspose(placement, matrixABC);
                    moments.addScaledInPlace(matrixABC, detJ);
                }
            }
        }
    }
    /** Test the direction of turn at the vertices of the polygon, ignoring z-coordinates.
     *
     * *  For a polygon without self intersections, this is a convexity and orientation test: all positive is convex and counterclockwise,
     * all negative is convex and clockwise
     * *  Beware that a polygon which turns through more than a full turn can cross itself and close, but is not convex
     * *  Returns 1 if all turns are to the left, -1 if all to the right, and 0 if there are any zero or reverse turns
     */
    static testXYPolygonTurningDirections(pPointArray) {
        // Reduce count by trailing duplicates; leaves iLast at final index
        let numPoint = pPointArray.length;
        let iLast = numPoint - 1;
        while (iLast > 1 && pPointArray[iLast].x === pPointArray[0].x && pPointArray[iLast].y === pPointArray[0].y) {
            numPoint = iLast--;
        }
        if (numPoint > 2) {
            let vector0 = Point2dVector2d_1.Point2d.create(pPointArray[iLast].x - pPointArray[iLast - 1].x, pPointArray[iLast].y - pPointArray[iLast - 1].y);
            const vector1 = Point2dVector2d_1.Point2d.create(pPointArray[0].x - pPointArray[iLast].x, pPointArray[0].y - pPointArray[iLast].y);
            const baseArea = vector0.x * vector1.y - vector0.y * vector1.x;
            // In a convex polygon, all successive-vector cross products will
            // have the same sign as the base area, hence all products will be
            // positive.
            for (let i1 = 1; i1 < numPoint; i1++) {
                vector0 = vector1.clone();
                Point2dVector2d_1.Point2d.create(pPointArray[i1].x - pPointArray[i1 - 1].x, pPointArray[i1].y - pPointArray[i1 - 1].y, vector1);
                const currArea = vector0.x * vector1.y - vector0.y * vector1.x;
                if (currArea * baseArea <= 0.0)
                    return 0;
            }
            // Fall out with all signs same as base area
            return baseArea > 0.0 ? 1 : -1;
        }
        return 0;
    }
    /**
     * Test if point (x,y) is IN, OUT or ON a polygon.
     * @return (1) for in, (-1) for OUT, (0) for ON
     * @param x x coordinate
     * @param y y coordinate
     * @param points array of xy coordinates.
     */
    static classifyPointInPolygon(x, y, points) {
        const context = new XYParitySearchContext_1.XYParitySearchContext(x, y);
        let i0 = 0;
        const n = points.length;
        let i1;
        let iLast = -1;
        // walk to an acceptable start index ...
        for (i0 = 0; i0 < n; i0 = i1) {
            i1 = i0 + 1;
            if (i1 >= n)
                i1 = 0;
            if (context.tryStartEdge(points[i0].x, points[i0].y, points[i1].x, points[i1].y)) {
                iLast = i1;
                break;
            }
        }
        if (iLast < 0)
            return undefined;
        for (let i = 1; i <= n; i++) {
            i1 = iLast + i;
            if (i1 >= n)
                i1 -= n;
            if (!context.advance(points[i1].x, points[i1].y))
                return context.classifyCounts();
        }
        return context.classifyCounts();
    }
    /**
     * Test if point (x,y) is IN, OUT or ON a polygon.
     * @return (1) for in, (-1) for OUT, (0) for ON
     * @param x x coordinate
     * @param y y coordinate
     * @param points array of xy coordinates.
     */
    static classifyPointInPolygonXY(x, y, points) {
        const context = new XYParitySearchContext_1.XYParitySearchContext(x, y);
        let i0 = 0;
        const n = points.length;
        let i1;
        let iLast = -1;
        // walk to an acceptable start index ...
        for (i0 = 0; i0 < n; i0 = i1) {
            i1 = i0 + 1;
            if (i1 >= n)
                i1 = 0;
            if (context.tryStartEdge(points.getXAtUncheckedPointIndex(i0), points.getYAtUncheckedPointIndex(i0), points.getXAtUncheckedPointIndex(i1), points.getYAtUncheckedPointIndex(i1))) {
                iLast = i1;
                break;
            }
        }
        if (iLast < 0)
            return undefined;
        for (let i = 1; i <= n; i++) {
            i1 = iLast + i;
            if (i1 >= n)
                i1 -= n;
            if (!context.advance(points.getXAtUncheckedPointIndex(i1), points.getYAtUncheckedPointIndex(i1)))
                return context.classifyCounts();
        }
        return context.classifyCounts();
    }
    /**
     * Reverse loops as necessary to make them all have CCW orientation for given outward normal.
     * @param loops
     * @param outwardNormal
     * @return the number of loops reversed.
     */
    static orientLoopsCCWForOutwardNormalInPlace(loops, outwardNormal) {
        if (loops instanceof IndexedXYZCollection_1.IndexedXYZCollection)
            return this.orientLoopsCCWForOutwardNormalInPlace([loops], outwardNormal);
        const orientations = [];
        const unitNormal = Point3dVector3d_1.Vector3d.create();
        // orient individually ... (no hole analysis)
        let numReverse = 0;
        for (const loop of loops) {
            if (this.unitNormal(loop, unitNormal)) {
                const q = unitNormal.dotProduct(outwardNormal);
                orientations.push(q);
                if (q <= 0.0)
                    loop.reverseInPlace();
                numReverse++;
            }
            else {
                orientations.push(0.0);
            }
        }
        return numReverse;
    }
    /**
     * If reverse loops as necessary to make them all have CCW orientation for given outward normal.
     * * Return an array of arrays which capture the input pointers.
     * * In each first level array:
     *    * The first loop is an outer loop.
     *    * all subsequent loops are holes
     *    * The outer loop is CCW
     *    * The holes are CW.
     * @param loops multiple loops to sort and reverse.
     */
    static sortOuterAndHoleLoopsXY(loops) {
        const loopAndArea = [];
        for (const loop of loops) {
            SortablePolygon.pushLoop(loopAndArea, loop);
        }
        return SortablePolygon.assignParentsAndDepth(loopAndArea);
    }
}
exports.PolygonOps = PolygonOps;
/** These values are the integrated area moment products [xx,xy,xz, x]
 * for a right triangle in the first quadrant at the origin -- (0,0),(1,0),(0,1)
 */
PolygonOps._triangleMomentWeights = Matrix4d_1.Matrix4d.createRowValues(2.0 / 24.0, 1.0 / 24.0, 0, 4.0 / 24.0, 1.0 / 24.0, 2.0 / 24.0, 0, 4.0 / 24.0, 0, 0, 0, 0, 4.0 / 24.0, 4.0 / 24.0, 0, 12.0 / 24.0);
/** These values are the integrated volume moment products [xx,xy,xz, x, yx,yy,yz,y, zx,zy,zz,z,x,y,z,1]
 * for a tetrahedron in the first quadrant at the origin -- (0,00),(1,0,0),(0,1,0),(0,0,1)
 */
PolygonOps._tetrahedralMomentWeights = Matrix4d_1.Matrix4d.createRowValues(1.0 / 60.0, 1.0 / 120, 1.0 / 120, 1.0 / 24.0, 1.0 / 120, 1.0 / 60.0, 1.0 / 120, 1.0 / 24.0, 1.0 / 120, 1.0 / 120, 1.0 / 60.0, 1.0 / 24.0, 1.0 / 24.0, 1.0 / 24.0, 1.0 / 24.0, 1.0 / 6.0);
// statics for shared reuse.
// many methods use these.
// only use them in "leaf" methods that are certain not to call other users . . .
PolygonOps._vector0 = Point3dVector3d_1.Vector3d.create();
PolygonOps._vector1 = Point3dVector3d_1.Vector3d.create();
PolygonOps._vector2 = Point3dVector3d_1.Vector3d.create();
PolygonOps._vectorOrigin = Point3dVector3d_1.Vector3d.create();
PolygonOps._normal = Point3dVector3d_1.Vector3d.create();
PolygonOps._matrixA = Matrix4d_1.Matrix4d.createIdentity();
PolygonOps._matrixB = Matrix4d_1.Matrix4d.createIdentity();
PolygonOps._matrixC = Matrix4d_1.Matrix4d.createIdentity();
/**
 *  `IndexedXYZCollectionPolygonOps` class contains _static_ methods for typical operations on polygons carried as `IndexedXyZCollection`
 * @public
 */
class IndexedXYZCollectionPolygonOps {
    /**
     * Split a (convex) polygon into 2 parts based on altitude evaluations.
     * * POSITIVE ALTITUDE IS IN
     * @param plane any `PlaneAltitudeEvaluator` object that can evaluate `plane.altitude(xyz)` for distance from the plane.
     * @param xyz original polygon
     * @param xyzPositive array to receive inside part (altitude > 0)
     * @param xyzNegative array to receive outside part
     * @param altitudeRange min and max altitudes encountered.
     */
    static splitConvexPolygonInsideOutsidePlane(plane, xyz, xyzPositive, xyzNegative, altitudeRange) {
        const xyz0 = IndexedXYZCollectionPolygonOps._xyz0Work;
        const xyz1 = IndexedXYZCollectionPolygonOps._xyz1Work;
        const xyzInterpolated = IndexedXYZCollectionPolygonOps._xyz2Work;
        const n = xyz.length;
        xyzPositive.clear();
        xyzNegative.clear();
        // let numSplit = 0;
        const fractionTol = 1.0e-8;
        if (n > 2) {
            xyz.back(xyz0);
            altitudeRange.setNull();
            let a0 = plane.altitude(xyz0);
            altitudeRange.extendX(a0);
            //    if (a0 >= 0.0)
            //      work.push_back (xyz0);
            for (let i1 = 0; i1 < n; i1++) {
                xyz.getPoint3dAtUncheckedPointIndex(i1, xyz1);
                const a1 = plane.altitude(xyz1);
                altitudeRange.extendX(a1);
                let nearZero = false;
                if (a0 * a1 < 0.0) {
                    // simple crossing. . .
                    const f = -a0 / (a1 - a0);
                    if (f > 1.0 - fractionTol && a1 >= 0.0) {
                        // the endpoint will be saved -- avoid the duplicate
                        nearZero = true;
                    }
                    else {
                        xyz0.interpolate(f, xyz1, xyzInterpolated);
                        xyzPositive.push(xyzInterpolated);
                        xyzNegative.push(xyzInterpolated);
                    }
                    // numSplit++;
                }
                if (a1 >= 0.0 || nearZero)
                    xyzPositive.push(xyz1);
                if (a1 <= 0.0 || nearZero)
                    xyzNegative.push(xyz1);
                xyz0.setFromPoint3d(xyz1);
                a0 = a1;
            }
        }
    }
    /**
     * Clip a polygon to one side of a plane.
     * * Results with 2 or fewer points are ignored.
     * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.
     * * plane is passed as unrolled Point4d (ax,ay,az,aw) point (x,y,z) acts as homogeneous (x,y,z,1)
     *   * `keepPositive === true` selects positive altitudes.
     * @param plane any type that has `plane.altitude`
     * @param xyz input points.
     * @param work work buffer
     * @param tolerance tolerance for "on plane" decision.
     */
    static clipConvexPolygonInPlace(plane, xyz, work, keepPositive = true, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        work.clear();
        const s = keepPositive ? 1.0 : -1.0;
        const n = xyz.length;
        let numNegative = 0;
        const fractionTol = 1.0e-8;
        const b = -tolerance;
        if (xyz.length > 1) {
            let a1;
            let index0 = xyz.length - 1;
            let a0 = s * xyz.evaluateUncheckedIndexPlaneAltitude(index0, plane);
            //    if (a0 >= 0.0)
            //      work.push_back (xyz0);
            for (let index1 = 0; index1 < n; a0 = a1, index0 = index1++) {
                a1 = s * xyz.evaluateUncheckedIndexPlaneAltitude(index1, plane);
                if (a1 < 0)
                    numNegative++;
                if (a0 * a1 < 0.0) {
                    // simple crossing . . .
                    const f = -a0 / (a1 - a0);
                    if (f > 1.0 - fractionTol && a1 >= 0.0) {
                        // the endpoint will be saved -- avoid the duplicate
                    }
                    else {
                        work.pushInterpolatedFromGrowableXYZArray(xyz, index0, f, index1);
                    }
                }
                if (a1 >= b)
                    work.pushFromGrowableXYZArray(xyz, index1);
                index0 = index1;
                a0 = a1;
            }
        }
        if (work.length <= 2) {
            xyz.clear();
        }
        else if (numNegative > 0) {
            xyz.clear();
            xyz.pushFromGrowableXYZArray(work);
        }
        work.clear();
    }
    /**
     * Return the intersection of the plane with a range cube.
     * @param range
     * @param xyzOut intersection polygon.  This is convex.
     * @return reference to xyz if the polygon still has points; undefined if all points are clipped away.
     */
    static intersectRangeConvexPolygonInPlace(range, xyz) {
        if (range.isNull)
            return undefined;
        const work = new GrowableXYZArray_1.GrowableXYZArray();
        const plane = Point4d_1.Point4d.create();
        plane.set(0, 0, -1, range.high.z);
        this.clipConvexPolygonInPlace(plane, xyz, work, true);
        if (xyz.length === 0)
            return undefined;
        plane.set(0, 0, -1, -range.low.z);
        this.clipConvexPolygonInPlace(plane, xyz, work, true);
        if (xyz.length === 0)
            plane.set(0, -1, 0, -range.high.y);
        this.clipConvexPolygonInPlace(plane, xyz, work, true);
        if (xyz.length === 0)
            return undefined;
        plane.set(0, 1, 0, range.low.y);
        this.clipConvexPolygonInPlace(plane, xyz, work, true);
        if (xyz.length === 0)
            return undefined;
        plane.set(-1, 0, 0, range.high.x);
        this.clipConvexPolygonInPlace(plane, xyz, work, true);
        if (xyz.length === 0)
            return undefined;
        plane.set(1, 0, 0, -range.low.x);
        this.clipConvexPolygonInPlace(plane, xyz, work, true);
        if (xyz.length === 0)
            return undefined;
        return xyz;
    }
}
exports.IndexedXYZCollectionPolygonOps = IndexedXYZCollectionPolygonOps;
IndexedXYZCollectionPolygonOps._xyz0Work = Point3dVector3d_1.Point3d.create();
IndexedXYZCollectionPolygonOps._xyz1Work = Point3dVector3d_1.Point3d.create();
IndexedXYZCollectionPolygonOps._xyz2Work = Point3dVector3d_1.Point3d.create();
/**
 * `Point3dArrayPolygonOps` class contains _static_ methods for typical operations on polygons carried as `Point3d[]`
 * @public
 */
class Point3dArrayPolygonOps {
    //  private static _xyz1Work: Point3d = Point3d.create();
    //  private static _xyz2Work: Point3d = Point3d.create();
    /**
     * Split a (convex) polygon into 2 parts.
     * @param xyz original polygon
     * @param xyzIn array to receive inside part
     * @param xyzOut array to receive outside part
     * @param altitudeRange min and max altitudes encountered.
     */
    static convexPolygonSplitInsideOutsidePlane(plane, xyz, xyzIn, xyzOut, altitudeRange) {
        const xyzCarrier = new Point3dArrayCarrier_1.Point3dArrayCarrier(xyz);
        const xyzInCarrier = new Point3dArrayCarrier_1.Point3dArrayCarrier(xyzIn);
        const xyzOutCarrier = new Point3dArrayCarrier_1.Point3dArrayCarrier(xyzOut);
        IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(plane, xyzCarrier, xyzInCarrier, xyzOutCarrier, altitudeRange);
    }
    /** Return an array containing
     * * All points that are exactly on the plane.
     * * Crossing points between adjacent points that are (strictly) on opposite sides.
     */
    static polygonPlaneCrossings(plane, xyz, crossings) {
        crossings.length = 0;
        if (xyz.length >= 2) {
            const xyz0 = this._xyz0Work;
            xyz0.setFromPoint3d(xyz[xyz.length - 1]);
            let a0 = plane.altitude(xyz0);
            for (const xyz1 of xyz) {
                const a1 = plane.altitude(xyz1);
                if (a0 * a1 < 0.0) {
                    // simple crossing. . .
                    const f = -a0 / (a1 - a0);
                    crossings.push(xyz0.interpolate(f, xyz1));
                }
                if (a1 === 0.0) { // IMPORTANT -- every point is directly tested here
                    crossings.push(xyz1.clone());
                }
                xyz0.setFromPoint3d(xyz1);
                a0 = a1;
            }
        }
    }
    /**
     * Clip a polygon, returning the clip result in the same object.
     * @param xyz input/output polygon
     * @param work scratch object
     * @param tolerance tolerance for on-plane decision.
     */
    static convexPolygonClipInPlace(plane, xyz, work, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        if (work === undefined)
            work = [];
        work.length = 0;
        let numNegative = 0;
        const fractionTol = 1.0e-8;
        const b = -tolerance;
        if (xyz.length > 2) {
            let xyz0 = xyz[xyz.length - 1];
            let a0 = plane.altitude(xyz0);
            //    if (a0 >= 0.0)
            //      work.push_back (xyz0);
            for (const xyz1 of xyz) {
                const a1 = plane.altitude(xyz1);
                if (a1 < 0)
                    numNegative++;
                if (a0 * a1 < 0.0) {
                    // simple crossing . . .
                    const f = -a0 / (a1 - a0);
                    if (f > 1.0 - fractionTol && a1 >= 0.0) {
                        // the endpoint will be saved -- avoid the duplicate
                    }
                    else {
                        work.push(xyz0.interpolate(f, xyz1));
                    }
                }
                if (a1 >= b)
                    work.push(xyz1);
                xyz0 = Point3dVector3d_1.Point3d.createFrom(xyz1);
                a0 = a1;
            }
        }
        if (work.length <= 2) {
            xyz.length = 0;
        }
        else if (numNegative > 0) {
            xyz.length = 0;
            for (const xyzI of work) {
                xyz.push(xyzI);
            }
            work.length = 0;
        }
    }
}
exports.Point3dArrayPolygonOps = Point3dArrayPolygonOps;
Point3dArrayPolygonOps._xyz0Work = Point3dVector3d_1.Point3d.create();
/**
 * A `SortablePolygon` carries a (single) loop with data useful for sorting for inner-outer structure.
 * @internal
 */
class SortablePolygon {
    /**
     *
     * @param loop Loop to capture.
     */
    constructor(loop, range, signedArea) {
        this.loop = loop;
        this.range = range;
        this.signedArea = signedArea;
        this.sortKey = Math.abs(this.signedArea);
        this.isHole = false;
    }
    /** Push loop with sort data onto the array.
     * * No action if no clear normal.
     * * return true if pushed.
     */
    static pushLoop(loops, loop) {
        const areaXY = PolygonOps.areaXY(loop);
        if (areaXY > 0.0) {
            loops.push(new SortablePolygon(loop, Range_1.Range3d.createFromVariantData(loop), areaXY));
            return true;
        }
        return true;
    }
    /** Push loop with sort data onto the array.
     * * No action if no clear normal.
     * * return true if pushed.
     */
    static assignParentsAndDepth(loops) {
        const outputSets = [];
        // Sort largest to smallest ...
        loops.sort((loopA, loopB) => (loopB.sortKey - loopA.sortKey));
        outputSets.length = 0;
        // starting with smallest loop, point each loop to smallest containing parent.
        for (let i = loops.length; i-- > 0;) {
            const searchX = loops[i].loop.getXAtUncheckedPointIndex(0);
            const searchY = loops[i].loop.getYAtUncheckedPointIndex(0);
            // find smallest containing parent (search forward only to hit)
            loops[i].parentIndex = undefined;
            loops[i].outputSetIndex = undefined;
            for (let j = i; j-- > 0;) {
                if (loops[j].range.containsXY(searchX, searchY)
                    && 1 === PolygonOps.classifyPointInPolygonXY(searchX, searchY, loops[j].loop)) {
                    loops[i].parentIndex = j;
                    break;
                }
            }
        }
        // In large-to-small order:
        // If a loop has no parent or has a "hole" as parent it is outer.
        // otherwise (i.e. it has a non-hole parent) it becomes a hole in the parent.
        for (const loopData of loops) {
            loopData.isHole = false;
            const parentIndex = loopData.parentIndex;
            if (parentIndex !== undefined)
                loopData.isHole = !loops[parentIndex].isHole;
            if (!loopData.isHole) {
                loopData.reverseLoopForAreaSign(1.0);
                loopData.outputSetIndex = outputSets.length;
                outputSets.push([]);
                outputSets[loopData.outputSetIndex].push(loopData.loop);
            }
            else {
                loopData.reverseLoopForAreaSign(-1.0);
                const outputSetIndex = loops[parentIndex].outputSetIndex;
                outputSets[outputSetIndex].push(loopData.loop);
            }
        }
        return outputSets;
    }
    reverseLoopForAreaSign(areaSign) {
        if (areaSign * this.signedArea < 0.0) {
            this.loop.reverseInPlace();
            this.signedArea *= -1.0;
        }
    }
}


/***/ }),

/***/ "./lib/geometry3d/PolylineCompressionByEdgeOffset.js":
/*!***********************************************************!*\
  !*** ./lib/geometry3d/PolylineCompressionByEdgeOffset.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Point3dArrayCarrier_1 = __webpack_require__(/*! ./Point3dArrayCarrier */ "./lib/geometry3d/Point3dArrayCarrier.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
// cspell:word Puecker
/** context class for Puecker-Douglas polyline compression, viz https://en.wikipedia.org/wiki/RamerDouglasPeucker_algorithm
 * @internal
 */
class PolylineCompressionContext {
    /** Caller provides source and tolerance.
     * * pointer to source is retained, but contents of source are never modified.
     */
    constructor(source, dest, tolerance) {
        this._toleranceSquared = tolerance * tolerance;
        this._source = source;
        this._dest = dest;
    }
    /** push (clone of) the point at index i from the source to the growing result.
     * * index is adjusted cyclically to source index range by modulo.
     */
    acceptPointByIndex(i) {
        const point = this._source.getPoint3dAtCheckedPointIndex(this._source.cyclicIndex(i));
        if (point)
            this._dest.push(point);
    }
    /**
     * Return index of max magnitude of cross product of vectors (index to index+1) and (index to index+2)
     * * Return undefined if unable to find a nonzero cross product.
     * @param i0 first cross product central index.
     * @param i1 last cross product central index.
     */
    indexOfMaxCrossProduct(index0, index1) {
        let qMax = 0.0;
        let q;
        let indexMax;
        for (let index = index0; index <= index1; index++) {
            const iA = this._source.cyclicIndex(index);
            const iB = this._source.cyclicIndex(index + 1);
            const iC = this._source.cyclicIndex(index + 2);
            this._source.crossProductIndexIndexIndex(iA, iB, iC, PolylineCompressionContext._vectorQ);
            q = PolylineCompressionContext._vectorQ.magnitudeSquared();
            if (q > qMax) {
                qMax = q;
                indexMax = index;
            }
        }
        return indexMax;
    }
    /**
     * Return interior index where max deviation in excess of tolerance occurs.
     * @param i0 first index of interval
     * @param i1 INCLUSIVE final index
     */
    indexOfMaxDeviation(index0, index1) {
        const i0 = this._source.cyclicIndex(index0);
        const i1 = this._source.cyclicIndex(index1);
        let maxDeviation = this._toleranceSquared;
        let maxDeviationIndex;
        let numerator;
        let distanceSquared;
        let s;
        let i;
        this._source.vectorIndexIndex(i0, i1, PolylineCompressionContext._vector01);
        const denominator = PolylineCompressionContext._vector01.magnitudeSquared();
        for (let index = index0 + 1; index < index1; index++) {
            i = this._source.cyclicIndex(index);
            this._source.vectorIndexIndex(i0, i, PolylineCompressionContext._vectorQ);
            numerator = PolylineCompressionContext._vector01.dotProduct(PolylineCompressionContext._vectorQ);
            if (numerator <= 0) {
                distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared();
            }
            else if (numerator > denominator) {
                this._source.vectorIndexIndex(i1, i, PolylineCompressionContext._vectorQ);
                distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared();
            }
            else {
                s = numerator / denominator;
                distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared() - denominator * s * s;
            }
            if (distanceSquared > maxDeviation) {
                maxDeviation = distanceSquared;
                maxDeviationIndex = index;
            }
        }
        return maxDeviationIndex;
    }
    /**
     *
     * @param i0 first active point index
     * @param i1 last active point index (INCLUSIVE -- not "one beyond")
     * @param chordTolerance
     * @param result
     */
    // ASSUME index i0 is already saved.
    // ASSUME point i
    recursiveCompressByChordErrorGo(i0, i1) {
        if (i1 === i0 + 1) {
            this.acceptPointByIndex(i1);
            return;
        }
        const distantPointIndex = this.indexOfMaxDeviation(i0, i1);
        if (distantPointIndex === undefined) {
            this.acceptPointByIndex(i1); // which compresses out some points.
        }
        else {
            this.recursiveCompressByChordErrorGo(i0, distantPointIndex);
            this.recursiveCompressByChordErrorGo(distantPointIndex, i1);
        }
    }
    // cspell:word Peucker
    /**
     * Return a point array with a subset of the input points.
     * * This is a global analysis (Douglas-Peucker)
     * @param source input points.
     * @param chordTolerance Points less than this distance from a retained edge may be ignored.
     */
    static compressPoint3dArrayByChordError(source, chordTolerance) {
        const source1 = new Point3dArrayCarrier_1.Point3dArrayCarrier(source);
        const dest1 = new Point3dArrayCarrier_1.Point3dArrayCarrier([]);
        this.compressCollectionByChordError(source1, dest1, chordTolerance);
        return dest1.data;
    }
    /**
     * * Return a polyline with a subset of the input points.
     * * This is a global analysis (Douglas-Peucker)
     * * Global search for vertices that are close to edges between widely separated neighbors.
     * * Recurses to smaller subsets.
     * @param source input points
     * @param dest output points.  Must be different from source.
     * @param chordTolerance Points less than this distance from a retained edge may be ignored.
     */
    static compressCollectionByChordError(source, dest, chordTolerance) {
        dest.clear();
        const n = source.length;
        if (n === 1) {
            dest.push(source.getPoint3dAtCheckedPointIndex(0));
            return;
        }
        const context = new PolylineCompressionContext(source, dest, chordTolerance);
        // Do compression on inclusive interval from indexA to indexB, with indices interpreted cyclically if closed
        let indexA = 0;
        let indexB = n - 1;
        if (n > 2 && source.distanceIndexIndex(0, n - 1) <= chordTolerance) {
            // cyclic data. It is possible that the wrap point itself has to be seen as an internal point.
            // do the search from point index where there is a large triangle . ..
            const maxCrossProductIndex = context.indexOfMaxCrossProduct(0, n - 1);
            if (maxCrossProductIndex !== undefined) {
                indexA = maxCrossProductIndex + 1;
                indexB = indexA + n;
            }
        }
        context.acceptPointByIndex(indexA);
        context.recursiveCompressByChordErrorGo(indexA, indexB);
    }
    /** Copy points from source to dest, omitting those too close to predecessor.
     * * First and last points are always preserved.
     */
    static compressInPlaceByShortEdgeLength(data, edgeLength) {
        const n = data.length;
        if (n < 2)
            return;
        let lastAcceptedIndex = 0;
        // back up from final point ..
        let indexB = n - 1;
        while (indexB > 0 && data.distanceIndexIndex(indexB - 1, n - 1) < edgeLength)
            indexB--;
        if (indexB === 0) {
            // Theres only one point there.
            data.length = 1;
            return;
        }
        // we want the exact bits of the final point even if others were nearby ..
        if (indexB < n - 1)
            data.moveIndexToIndex(n - 1, indexB);
        let candidateIndex = lastAcceptedIndex + 1;
        while (candidateIndex <= indexB) {
            if (data.distanceIndexIndex(lastAcceptedIndex, candidateIndex) >= edgeLength) {
                data.moveIndexToIndex(candidateIndex, lastAcceptedIndex + 1);
                lastAcceptedIndex++;
            }
            candidateIndex++;
        }
        data.length = lastAcceptedIndex + 1;
    }
    /** Copy points from source to dest, omitting those too close to predecessor.
     * * First and last points are always preserved.
     */
    static compressInPlaceBySmallTriangleArea(data, triangleArea) {
        const n = data.length;
        if (n < 3)
            return;
        let lastAcceptedIndex = 0;
        const cross = Point3dVector3d_1.Vector3d.create();
        for (let i1 = 1; i1 + 1 < n; i1++) {
            data.crossProductIndexIndexIndex(lastAcceptedIndex, i1, i1 + 1, cross);
            if (0.5 * cross.magnitude() > triangleArea) {
                data.moveIndexToIndex(i1, ++lastAcceptedIndex);
            }
        }
        data.moveIndexToIndex(n - 1, ++lastAcceptedIndex);
        data.length = lastAcceptedIndex + 1;
    }
    /** Copy points from source to dest, omitting those too close to edge between neighbors.
     * * First and last points are always preserved.
     */
    static compressInPlaceByPerpendicularDistance(data, perpendicularDistance, maxExtensionFraction = 1.0001) {
        const n = data.length;
        if (n < 3)
            return;
        let lastAcceptedIndex = 0;
        const vector01 = PolylineCompressionContext._vector01;
        const vectorQ = PolylineCompressionContext._vectorQ;
        let distanceSquared;
        const perpendicularDistanceSquared = perpendicularDistance * perpendicularDistance;
        let denominator;
        let i1 = 1;
        for (; i1 + 1 < n; i1++) {
            data.vectorIndexIndex(lastAcceptedIndex, i1 + 1, vector01);
            data.vectorIndexIndex(lastAcceptedIndex, i1, vectorQ);
            denominator = vector01.magnitudeSquared();
            const s = Geometry_1.Geometry.conditionalDivideFraction(vectorQ.dotProduct(vector01), denominator);
            if (s !== undefined) {
                if (s >= 0.0 && s <= maxExtensionFraction) {
                    distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared() - denominator * s * s;
                    if (distanceSquared <= perpendicularDistanceSquared) {
                        // force accept of point i1+1 .
                        data.moveIndexToIndex(i1 + 1, ++lastAcceptedIndex);
                        i1 = i1 + 1;
                        continue;
                    }
                }
            }
            data.moveIndexToIndex(i1, ++lastAcceptedIndex);
        }
        if (i1 < n)
            data.moveIndexToIndex(i1, ++lastAcceptedIndex);
        data.length = lastAcceptedIndex + 1;
    }
}
exports.PolylineCompressionContext = PolylineCompressionContext;
/** work data used by find max deviation */
PolylineCompressionContext._vector01 = Point3dVector3d_1.Vector3d.create();
PolylineCompressionContext._vectorQ = Point3dVector3d_1.Vector3d.create();


/***/ }),

/***/ "./lib/geometry3d/PolylineOps.js":
/*!***************************************!*\
  !*** ./lib/geometry3d/PolylineOps.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Range_1 = __webpack_require__(/*! ./Range */ "./lib/geometry3d/Range.js");
const PolylineCompressionByEdgeOffset_1 = __webpack_require__(/*! ./PolylineCompressionByEdgeOffset */ "./lib/geometry3d/PolylineCompressionByEdgeOffset.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ./GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
// cspell:word Puecker
/** @module CartesianGeometry */
/**
 * PolylineOps is a collection of static methods operating on polylines.
 * @public
 */
class PolylineOps {
    /**
     * Return a Range1d with the shortest and longest edge lengths of the polyline.
     * @param points points to examine.
     */
    static edgeLengthRange(points) {
        const range = Range_1.Range1d.createNull();
        for (let i = 1; i < points.length; i++) {
            range.extendX(points[i - 1].distance(points[i]));
        }
        return range;
    }
    /**
     * Return a simplified subset of given points.
     * * Points are removed by the Douglas-Puecker algorithm, viz https://en.wikipedia.org/wiki/RamerDouglasPeucker_algorithm
     * * This is a global search, with multiple passes over the data.
     * @param source
     * @param chordTolerance
     */
    static compressByChordError(source, chordTolerance) {
        return PolylineCompressionByEdgeOffset_1.PolylineCompressionContext.compressPoint3dArrayByChordError(source, chordTolerance);
    }
    /**
     * Return a simplified subset of given points, omitting points if very close to their neighbors.
     * * This is a local search, with a single pass over the data.
     * @param source input points
     * @param maxEdgeLength
     */
    static compressShortEdges(source, maxEdgeLength) {
        const dest = GrowableXYZArray_1.GrowableXYZArray.create(source);
        PolylineCompressionByEdgeOffset_1.PolylineCompressionContext.compressInPlaceByShortEdgeLength(dest, maxEdgeLength);
        return dest.getPoint3dArray();
    }
    /**
     * Return a simplified subset of given points, omitting points of the triangle with adjacent points is small.
     * * This is a local search, with a single pass over the data.
     * @param source input points
     * @param maxEdgeLength
     */
    static compressSmallTriangles(source, maxTriangleArea) {
        const dest = GrowableXYZArray_1.GrowableXYZArray.create(source);
        PolylineCompressionByEdgeOffset_1.PolylineCompressionContext.compressInPlaceBySmallTriangleArea(dest, maxTriangleArea);
        return dest.getPoint3dArray();
    }
    /**
     * Return a simplified subset of given points, omitting points if close to the edge between neighboring points before and after
     * * This is a local search, with a single pass over the data for each pass.
     * @param source input points
     * @param maxDistance omit points if this close to edge between points before and after
     * @param numPass max number of times to run the filter.  numPass=2 is observed to behave well.
     *
     */
    static compressByPerpendicularDistance(source, maxDistance, numPass = 2) {
        const dest = GrowableXYZArray_1.GrowableXYZArray.create(source);
        let num0 = dest.length;
        for (let pass = 0; pass < numPass; pass++) {
            PolylineCompressionByEdgeOffset_1.PolylineCompressionContext.compressInPlaceByPerpendicularDistance(dest, maxDistance);
            const num1 = dest.length;
            if (num1 === num0)
                break;
            num0 = num1;
        }
        return dest.getPoint3dArray();
    }
}
exports.PolylineOps = PolylineOps;


/***/ }),

/***/ "./lib/geometry3d/Range.js":
/*!*********************************!*\
  !*** ./lib/geometry3d/Range.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
const PointStreaming_1 = __webpack_require__(/*! ./PointStreaming */ "./lib/geometry3d/PointStreaming.js");
/**
 * Base class for Range1d, Range2d, Range3d.
 * @public
 */
class RangeBase {
    /** Return 0 if high<= low, otherwise `1/(high-low)` for use in fractionalizing */
    static npcScaleFactor(low, high) { return (high <= low) ? 0.0 : 1.0 / (high - low); }
    /** Return true if x is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */
    static isExtremeValue(x) { return Math.abs(x) >= RangeBase._EXTREME_POSITIVE; }
    /** Return true if any x or y or z is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */
    static isExtremePoint3d(xyz) { return RangeBase.isExtremeValue(xyz.x) || RangeBase.isExtremeValue(xyz.y) || RangeBase.isExtremeValue(xyz.z); }
    /** Return true if either of x,y is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */
    static isExtremePoint2d(xy) { return RangeBase.isExtremeValue(xy.x) || RangeBase.isExtremeValue(xy.y); }
    /**
     * Return the min absolute distance from any point of `[lowA,highA]' to any point of `[lowB,highB]'.
     * * Both low,high pairs have order expectations:  The condition `high < low` means null interval.
     * * If there is interval overlap, the distance is zero.
     * @param lowA low of interval A
     * @param highA high of interval A
     * @param lowB low of interval B
     * @param highB high of interval B
     */
    static rangeToRangeAbsoluteDistance(lowA, highA, lowB, highB) {
        if (highA < lowA)
            return RangeBase._EXTREME_POSITIVE;
        if (highB < lowB)
            return RangeBase._EXTREME_POSITIVE;
        if (highB < lowA)
            return lowA - highB;
        if (highB <= highA)
            return 0.0;
        if (lowB <= highA)
            return 0.0;
        return lowB - highA;
    }
    /** Given a coordinate and pair of range limits, return the smallest distance to the range.
     * * This is zero for any point inside the range
     * * This is _EXTREME_POSITIVE if the range limits are inverted
     * * Otherwise (i.e. x is outside a finite range) the distance to the near endpoint.
     */
    static coordinateToRangeAbsoluteDistance(x, low, high) {
        if (high < low)
            return RangeBase._EXTREME_POSITIVE;
        if (x < low)
            return low - x;
        if (x > high)
            return x - high;
        return 0.0;
    }
}
exports.RangeBase = RangeBase;
/** Number considered impossibly large possibly for a coordinate in a range. */
RangeBase._EXTREME_POSITIVE = 1.0e200;
/** Number considered to be impossibly negative for a coordinate in a range. */
RangeBase._EXTREME_NEGATIVE = -1.0e200;
/**
 * Axis aligned range in 3D.
 * * member `low` contains minimum coordinate of range box
 * * member  `high` contains maximum coordinate of range box
 * * The range is considered null (empty) if any low member is larger than its high counterpart.
 * @public
 */
class Range3d extends RangeBase {
    // explicit ctor - no enforcement of value relationships
    constructor(lowX = RangeBase._EXTREME_POSITIVE, lowY = RangeBase._EXTREME_POSITIVE, lowZ = RangeBase._EXTREME_POSITIVE, highX = RangeBase._EXTREME_NEGATIVE, highY = RangeBase._EXTREME_NEGATIVE, highZ = RangeBase._EXTREME_NEGATIVE) {
        super();
        this.low = Point3dVector3d_1.Point3d.create(lowX, lowY, lowZ);
        this.high = Point3dVector3d_1.Point3d.create(highX, highY, highZ);
    }
    /** Set this transform to values that indicate it has no geometric contents. */
    setNull() {
        this.low.x = RangeBase._EXTREME_POSITIVE;
        this.low.y = RangeBase._EXTREME_POSITIVE;
        this.low.z = RangeBase._EXTREME_POSITIVE;
        this.high.x = RangeBase._EXTREME_NEGATIVE;
        this.high.y = RangeBase._EXTREME_NEGATIVE;
        this.high.z = RangeBase._EXTREME_NEGATIVE;
    }
    /** Freeze this instance (and its deep content) so it can be considered read-only */
    freeze() { Object.freeze(this); Object.freeze(this.low); Object.freeze(this.high); }
    /** Flatten the low and high coordinates of any json object with low.x .. high.z into an array of 6 doubles */
    static toFloat64Array(val) { return Float64Array.of(val.low.x, val.low.y, val.low.z, val.high.x, val.high.y, val.high.z); }
    /** Flatten the low and high coordinates of this into an array of 6 doubles */
    toFloat64Array() { return Range3d.toFloat64Array(this); }
    /**
     * Construct a Range3d from an array of double-precision values
     * @param f64 the array, which should contain exactly 6 values in this order: lowX, lowY, lowZ, highX, highY, highZ
     * @return a new Range3d object
     */
    static fromFloat64Array(f64) {
        if (f64.length !== 6)
            throw new Error("invalid array");
        return new this(f64[0], f64[1], f64[2], f64[3], f64[4], f64[5]);
    }
    /**
     * Construct a Range3d from an un-typed array. This mostly useful when interpreting ECSQL query results of the 'blob' type, where you know that that result is a Range3d.
     * @param buffer untyped array
     * @return a new Range3d object
     */
    static fromArrayBuffer(buffer) { return this.fromFloat64Array(new Float64Array(buffer)); }
    /** Returns true if this and other have equal low and high parts, or both are null ranges. */
    isAlmostEqual(other) {
        return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))
            || (this.isNull && other.isNull);
    }
    /** copy low and high values from other. */
    setFrom(other) { this.low.setFrom(other.low); this.high.setFrom(other.high); }
    /** Return a new Range3d copied from a range or derived type */
    static createFrom(other, result) {
        if (result) {
            result.setFrom(other);
            return result;
        }
        return this.createXYZXYZOrCorrectToNull(other.low.x, other.low.y, other.low.z, other.high.x, other.high.y, other.high.z, result);
    }
    /** set this range (in place) from json such as
     * * key-value pairs: `{low:[1,2,3], high:[4,5,6]}`
     * * array of points: `[[1,2,3],[9,3,4],[-2,1,3] ...]`
     * * Lowest level points can be `[1,2,3]` or `{x:1,y:2,z:3}`
     */
    setFromJSON(json) {
        if (!json)
            return;
        this.setNull();
        if (Array.isArray(json)) {
            const point = Point3dVector3d_1.Point3d.create();
            for (const value of json) {
                point.setFromJSON(value);
                this.extendPoint(point);
            }
            return;
        }
        const low = Point3dVector3d_1.Point3d.fromJSON(json.low);
        const high = Point3dVector3d_1.Point3d.fromJSON(json.high);
        if (!RangeBase.isExtremePoint3d(low) && !RangeBase.isExtremePoint3d(high)) {
            this.extendPoint(low);
            this.extendPoint(high);
        }
    }
    /** Return a JSON object `{low: ... , high: ...}`
     * with points formatted by `Point3d.toJSON()`
     */
    toJSON() { return { low: this.low.toJSON(), high: this.high.toJSON() }; }
    /** Use `setFromJSON` to parse `json` into a new Range3d instance. */
    static fromJSON(json) {
        const result = new this();
        result.setFromJSON(json);
        return result;
    }
    // internal use only -- directly set all coordinates, test only if directed.
    setDirect(xA, yA, zA, xB, yB, zB, correctToNull) {
        this.low.x = xA;
        this.low.y = yA;
        this.low.z = zA;
        this.high.x = xB;
        this.high.y = yB;
        this.high.z = zB;
        if (correctToNull) {
            if (this.low.x > this.high.x
                || this.low.y > this.high.y
                || this.low.z > this.high.z)
                this.setNull();
        }
    }
    /** Return a copy */
    clone(result) {
        result = result ? result : new this.constructor();
        result.setDirect(this.low.x, this.low.y, this.low.z, this.high.x, this.high.y, this.high.z, false);
        return result;
    }
    /** Return a range initialized to have no content. */
    static createNull(result) {
        result = result ? result : new this();
        result.setNull();
        return result;
    }
    /** Extend (modify in place) so that the range is large enough to include the supplied points. */
    extend(...point) {
        let p;
        for (p of point)
            this.extendPoint(p);
    }
    /** Return a range large enough to include the supplied points. If no points are given, the range is a null range */
    static create(...point) {
        const result = Range3d.createNull();
        let p;
        for (p of point)
            result.extendPoint(p);
        return result;
    }
    /** Create a range from freely structured MultiLineStringDataVariant. */
    static createFromVariantData(data) {
        const collector = new PointStreaming_1.PointStreamRangeCollector();
        PointStreaming_1.VariantPointDataStream.streamXYZ(data, collector);
        return collector.claimResult();
    }
    /** create a Range3d enclosing the transformed points. */
    static createTransformed(transform, ...point) {
        const result = this.createNull();
        let p;
        for (p of point)
            result.extendTransformedXYZ(transform, p.x, p.y, p.z);
        return result;
    }
    /** create a Range3d enclosing the transformed points. */
    static createTransformedArray(transform, points) {
        const result = this.createNull();
        result.extendArray(points, transform);
        return result;
    }
    /** create a Range3d enclosing the points after inverse transform. */
    static createInverseTransformedArray(transform, points) {
        const result = this.createNull();
        result.extendInverseTransformedArray(points, transform);
        return result;
    }
    /** Set the range to be a single point supplied as x,y,z values */
    setXYZ(x, y, z) {
        this.low.x = this.high.x = x;
        this.low.y = this.high.y = y;
        this.low.z = this.high.z = z;
    }
    /** Create a single point range */
    static createXYZ(x, y, z, result) {
        result = result ? result : new this();
        result.setDirect(x, y, z, x, y, z, false);
        return result;
    }
    /** Create a box with 2 pairs of xyz candidates. Theses are compared and shuffled as needed for the box. */
    static createXYZXYZ(xA, yA, zA, xB, yB, zB, result) {
        result = result ? result : new this();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB), Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), false);
        return result;
    }
    /** Create a box with 2 pairs of xyz candidates. If any direction has order flip, create null. */
    static createXYZXYZOrCorrectToNull(xA, yA, zA, xB, yB, zB, result) {
        result = result ? result : new this();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB), Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), true);
        return result;
    }
    /** Creates a 3d range from a 2d range's low and high members, setting the corresponding z values to the value given. */
    static createRange2d(range, z = 0, result) {
        const retVal = result ? result : new this();
        retVal.setNull();
        retVal.extendXYZ(range.low.x, range.low.y, z);
        retVal.extendXYZ(range.high.x, range.high.y, z);
        return retVal;
    }
    /** Create a range around an array of points. */
    static createArray(points, result) {
        result = result ? result : new this();
        result.setNull();
        let point;
        for (point of points)
            result.extendPoint(point);
        return result;
    }
    /** extend a range around an array of points (optionally transformed) */
    extendArray(points, transform) {
        if (Array.isArray(points))
            if (transform)
                for (const point of points)
                    this.extendTransformedXYZ(transform, point.x, point.y, point.z);
            else
                for (const point of points)
                    this.extendXYZ(point.x, point.y, point.z);
        else // growable array -- this should be implemented without point extraction !!!
         if (transform)
            for (let i = 0; i < points.length; i++)
                this.extendTransformedXYZ(transform, points.getXAtUncheckedPointIndex(i), points.getYAtUncheckedPointIndex(i), points.getZAtUncheckedPointIndex(i));
        else
            for (let i = 0; i < points.length; i++)
                this.extendXYZ(points.getXAtUncheckedPointIndex(i), points.getYAtUncheckedPointIndex(i), points.getZAtUncheckedPointIndex(i));
    }
    /** extend a range around an array of points (optionally transformed) */
    extendInverseTransformedArray(points, transform) {
        if (Array.isArray(points))
            for (const point of points)
                this.extendInverseTransformedXYZ(transform, point.x, point.y, point.z);
        else // growable array -- this should be implemented without point extraction !!!
            for (let i = 0; i < points.length; i++)
                this.extendInverseTransformedXYZ(transform, points.getXAtUncheckedPointIndex(i), points.getYAtUncheckedPointIndex(i), points.getZAtUncheckedPointIndex(i));
    }
    /** multiply the point x,y,z by transform and use the coordinate to extend this range.
     */
    extendTransformedXYZ(transform, x, y, z) {
        const origin = transform.origin;
        const coffs = transform.matrix.coffs;
        this.extendXYZ(origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);
    }
    /** multiply the point x,y,z,w by transform and use the coordinate to extend this range.
     */
    extendTransformedXYZW(transform, x, y, z, w) {
        const origin = transform.origin;
        const coffs = transform.matrix.coffs;
        this.extendXYZW(origin.x * w + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y * w + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z * w + coffs[6] * x + coffs[7] * y + coffs[8] * z, w);
    }
    /** multiply the point x,y,z by transform and use the coordinate to extend this range.
     */
    extendInverseTransformedXYZ(transform, x, y, z) {
        const origin = transform.origin;
        if (!transform.matrix.computeCachedInverse(true))
            return false;
        const coffs = transform.matrix.inverseCoffs;
        const xx = x - origin.x;
        const yy = y - origin.y;
        const zz = z - origin.z;
        this.extendXYZ(coffs[0] * xx + coffs[1] * yy + coffs[2] * zz, coffs[3] * xx + coffs[4] * yy + coffs[5] * zz, coffs[6] * xx + coffs[7] * yy + coffs[8] * zz);
        return true;
    }
    /** Extend the range by the two transforms applied to xyz */
    extendTransformTransformedXYZ(transformA, transformB, x, y, z) {
        const origin = transformB.origin;
        const coffs = transformB.matrix.coffs;
        this.extendTransformedXYZ(transformA, origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z, origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z, origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);
    }
    /** Test if the box has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */
    get isNull() {
        return this.high.x < this.low.x
            || this.high.y < this.low.y
            || this.high.z < this.low.z;
    }
    /** Test if  data has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */
    static isNull(data) {
        return data.high.x < data.low.x
            || data.high.y < data.low.y
            || data.high.z < data.low.z;
    }
    /** Test of the range contains a single point. */
    get isSinglePoint() {
        return this.high.x === this.low.x
            && this.high.y === this.low.y
            && this.high.z === this.low.z;
    }
    /** Return the midpoint of the diagonal.  No test for null range. */
    get center() { return this.low.interpolate(.5, this.high); }
    /** return the low x coordinate */
    get xLow() { return this.low.x; }
    /** return the low y coordinate */
    get yLow() { return this.low.y; }
    /** return the low z coordinate */
    get zLow() { return this.low.z; }
    /** return the high x coordinate */
    get xHigh() { return this.high.x; }
    /** return the high y coordinate */
    get yHigh() { return this.high.y; }
    /** return the high z coordinate */
    get zHigh() { return this.high.z; }
    /**  Return the length of the box in the x direction */
    xLength() { const a = this.high.x - this.low.x; return a > 0.0 ? a : 0.0; }
    /**  Return the length of the box in the y direction */
    yLength() { const a = this.high.y - this.low.y; return a > 0.0 ? a : 0.0; }
    /**  Return the length of the box in the z direction */
    zLength() { const a = this.high.z - this.low.z; return a > 0.0 ? a : 0.0; }
    /**  Return the largest of the x,y, z lengths of the range. */
    maxLength() { return Math.max(this.xLength(), this.yLength(), this.zLength()); }
    /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonal(result) { return this.low.vectorTo(this.high, result); }
    /**  Return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonalFractionToPoint(fraction, result) { return this.low.interpolate(fraction, this.high, result); }
    /**  Return a point given by fractional positions on the XYZ axes. This is done with no check for isNull !!! */
    fractionToPoint(fractionX, fractionY, fractionZ, result) {
        return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);
    }
    /**  Return a point given by fractional positions on the XYZ axes.
     *  Returns undefined if the range is null.
     */
    localXYZToWorld(fractionX, fractionY, fractionZ, result) {
        if (this.isNull)
            return undefined;
        return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);
    }
    /** Return a point given by fractional positions on the XYZ axes.
     * * Returns undefined if the range is null.
     */
    localToWorld(xyz, result) {
        return this.localXYZToWorld(xyz.x, xyz.y, xyz.z, result);
    }
    /** Replace fractional coordinates by world coordinates.
     * @returns false if null range.
     */
    localToWorldArrayInPlace(points) {
        if (this.isNull)
            return false;
        for (const p of points)
            this.low.interpolateXYZ(p.x, p.y, p.z, this.high, p);
        return false;
    }
    /** Return fractional coordinates of point within the range.
     * * returns undefined if the range is null.
     * * returns undefined if any direction (x,y,z) has zero length
     */
    worldToLocal(point, result) {
        const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);
        const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);
        const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);
        if (ax === 0.0 || ay === 0.0 || az === 0.0)
            return undefined;
        return Point3dVector3d_1.Point3d.create((point.x - this.low.x) * ax, (point.y - this.low.y) * ay, (point.z - this.low.z) * az, result);
    }
    /** Return fractional coordinates of point within the range.
     * * returns undefined if the range is null.
     * * returns undefined if any direction (x,y,z) has zero length
     */
    worldToLocalArrayInPlace(point) {
        const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);
        const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);
        const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);
        if (ax === 0.0 || ay === 0.0 || az === 0.0)
            return false;
        for (const p of point)
            Point3dVector3d_1.Point3d.create((p.x - this.low.x) * ax, (p.y - this.low.y) * ay, (p.z - this.low.z) * az, p);
        return true;
    }
    /** Return an array with the 8 corners on order wth "x varies fastest, then y, then z" */
    corners() {
        return [
            Point3dVector3d_1.Point3d.create(this.low.x, this.low.y, this.low.z),
            Point3dVector3d_1.Point3d.create(this.high.x, this.low.y, this.low.z),
            Point3dVector3d_1.Point3d.create(this.low.x, this.high.y, this.low.z),
            Point3dVector3d_1.Point3d.create(this.high.x, this.high.y, this.low.z),
            Point3dVector3d_1.Point3d.create(this.low.x, this.low.y, this.high.z),
            Point3dVector3d_1.Point3d.create(this.high.x, this.low.y, this.high.z),
            Point3dVector3d_1.Point3d.create(this.low.x, this.high.y, this.high.z),
            Point3dVector3d_1.Point3d.create(this.high.x, this.high.y, this.high.z)
        ];
    }
    /** Return an array with indices of the corners of a face
     * * face 0 has negative x normal
     * * face 1 has positive x normal
     * * face 2 has negative y normal
     * * face 3 has positive y normal
     * * face 4 has negative z normal
     * * face 5 has positive z normal
     * * Any other value returns face 5
     * * faces are CCW as viewed from outside.
     */
    static faceCornerIndices(index) {
        if (index === 0)
            return [0, 4, 6, 2];
        if (index === 1)
            return [1, 3, 7, 5];
        if (index === 2)
            return [0, 1, 5, 4];
        if (index === 3)
            return [3, 2, 6, 7];
        if (index === 4)
            return [0, 2, 3, 1];
        return [4, 5, 7, 6];
    }
    /** Return the largest absolute value among any coordinates in the box corners. */
    maxAbs() {
        if (this.isNull)
            return 0.0;
        return Math.max(this.low.maxAbs(), this.high.maxAbs());
    }
    /** returns true if the x direction size is nearly zero */
    get isAlmostZeroX() { return Geometry_1.Geometry.isSmallMetricDistance(this.xLength()); }
    /** returns true if the y direction size is nearly zero */
    get isAlmostZeroY() { return Geometry_1.Geometry.isSmallMetricDistance(this.yLength()); }
    /** returns true if the z direction size is nearly zero */
    get isAlmostZeroZ() { return Geometry_1.Geometry.isSmallMetricDistance(this.zLength()); }
    /** Test if a point given as x,y,z is within the range. */
    containsXYZ(x, y, z) {
        return x >= this.low.x
            && y >= this.low.y
            && z >= this.low.z
            && x <= this.high.x
            && y <= this.high.y
            && z <= this.high.z;
    }
    /** Test if a point given as x,y is within the range.  (Ignoring z of range) */
    containsXY(x, y) {
        return x >= this.low.x
            && y >= this.low.y
            && x <= this.high.x
            && y <= this.high.y;
    }
    /** Test if a point is within the range. */
    containsPoint(point) { return this.containsXYZ(point.x, point.y, point.z); }
    /** Test if the x,y coordinates of a point are within the range. */
    containsPointXY(point) {
        return point.x >= this.low.x
            && point.y >= this.low.y
            && point.x <= this.high.x
            && point.y <= this.high.y;
    }
    /** Test of other range is within this range */
    containsRange(other) {
        return other.low.x >= this.low.x
            && other.low.y >= this.low.y
            && other.low.z >= this.low.z
            && other.high.x <= this.high.x
            && other.high.y <= this.high.y
            && other.high.z <= this.high.z;
    }
    /** Test if there is any intersection with other range */
    intersectsRange(other) {
        return !(this.low.x > other.high.x
            || this.low.y > other.high.y
            || this.low.z > other.high.z
            || other.low.x > this.high.x
            || other.low.y > this.high.y
            || other.low.z > this.high.z);
    }
    /** Test if there is any intersection with other range */
    intersectsRangeXY(other) {
        return !(this.low.x > other.high.x
            || this.low.y > other.high.y
            || other.low.x > this.high.x
            || other.low.y > this.high.y);
    }
    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */
    distanceToPoint(point) {
        if (this.isNull)
            return RangeBase._EXTREME_POSITIVE;
        return Math.min(Geometry_1.Geometry.hypotenuseXYZ(RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x), RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y), RangeBase.coordinateToRangeAbsoluteDistance(point.z, this.low.z, this.high.z)), RangeBase._EXTREME_POSITIVE);
    }
    /** returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */
    distanceToRange(other) {
        return Math.min(Geometry_1.Geometry.hypotenuseXYZ(RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x), RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y), RangeBase.rangeToRangeAbsoluteDistance(this.low.z, this.high.z, other.low.z, other.high.z)), RangeBase._EXTREME_POSITIVE);
    }
    /** Expand this range by distances a (possibly signed) in all directions */
    extendXYZ(x, y, z) {
        if (x < this.low.x)
            this.low.x = x;
        if (x > this.high.x)
            this.high.x = x;
        if (y < this.low.y)
            this.low.y = y;
        if (y > this.high.y)
            this.high.y = y;
        if (z < this.low.z)
            this.low.z = z;
        if (z > this.high.z)
            this.high.z = z;
    }
    /** Expand this range by distances a (weighted and possibly signed) in all directions */
    extendXYZW(x, y, z, w) {
        if (!Geometry_1.Geometry.isSmallMetricDistance(w))
            this.extendXYZ(x / w, y / w, z / w);
    }
    /** Expand this range to include a point. */
    extendPoint(point) { this.extendXYZ(point.x, point.y, point.z); }
    /** Expand this range to include a transformed point. */
    extendTransformedPoint(transform, point) {
        this.extendTransformedXYZ(transform, point.x, point.y, point.z);
    }
    /** Expand this range to include a range. */
    extendRange(other) {
        if (!Range3d.isNull(other)) {
            this.extendXYZ(other.low.x, other.low.y, other.low.z);
            this.extendXYZ(other.high.x, other.high.y, other.high.z);
        }
    }
    /** Return the intersection of ranges. */
    intersect(other, result) {
        if (!this.intersectsRange(other))
            return Range3d.createNull(result);
        return Range3d.createXYZXYZOrCorrectToNull(Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y), Math.max(this.low.z, other.low.z), Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y), Math.min(this.high.z, other.high.z), result);
    }
    /** Return the union of ranges. */
    union(other, result) {
        if (this.isNull)
            return other.clone(result);
        if (other.isNull)
            return this.clone(result);
        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.
        return Range3d.createXYZXYZOrCorrectToNull(Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y), Math.min(this.low.z, other.low.z), Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y), Math.max(this.high.z, other.high.z), result);
    }
    /**
     * move low and high points by scaleFactor around the center point.
     * @param scaleFactor scale factor applied to low, high distance from center.
     */
    scaleAboutCenterInPlace(scaleFactor) {
        if (!this.isNull) {
            scaleFactor = Math.abs(scaleFactor);
            // do the scalar stuff to avoid making a temporary object ....
            const xMid = 0.5 * (this.low.x + this.high.x);
            const yMid = 0.5 * (this.low.y + this.high.y);
            const zMid = 0.5 * (this.low.z + this.high.z);
            this.high.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.high.x);
            this.high.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.high.y);
            this.high.z = Geometry_1.Geometry.interpolate(zMid, scaleFactor, this.high.z);
            this.low.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.low.x);
            this.low.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.low.y);
            this.low.z = Geometry_1.Geometry.interpolate(zMid, scaleFactor, this.low.z);
        }
    }
    /**
     * move all limits by a fixed amount.
     * * positive delta expands the range size
     * * negative delta reduces the range size
     * * if any dimension reduces below zero size, the whole range becomes null
     * @param delta shift to apply.
     */
    expandInPlace(delta) {
        this.setDirect(this.low.x - delta, this.low.y - delta, this.low.z - delta, this.high.x + delta, this.high.y + delta, this.high.z + delta, true);
    }
    /** Create a local to world transform from this range. */
    getLocalToWorldTransform(result) {
        return Transform_1.Transform.createOriginAndMatrix(Point3dVector3d_1.Point3d.create(this.low.x, this.low.y, this.low.z), Matrix3d_1.Matrix3d.createRowValues(this.high.x - this.low.x, 0, 0, 0, this.high.y - this.low.y, 0, 0, 0, this.high.z - this.low.z), result);
    }
    /**
     * Creates an NPC to world transformation to go from 000...111 to the globally aligned cube with diagonally opposite corners that are the
     * min and max of this range. The diagonal component for any degenerate direction is 1.
     */
    getNpcToWorldRangeTransform(result) {
        const transform = this.getLocalToWorldTransform(result);
        const matrix = transform.matrix;
        if (matrix.coffs[0] === 0)
            matrix.coffs[0] = 1;
        if (matrix.coffs[4] === 0)
            matrix.coffs[4] = 1;
        if (matrix.coffs[8] === 0)
            matrix.coffs[8] = 1;
        return transform;
    }
    /** Ensure that the length of each dimension of this AxisAlignedBox3d is at least a minimum size. If not, expand to minimum about the center.
     * @param min The minimum length for each dimension.
     */
    ensureMinLengths(min = .001) {
        let size = (min - this.xLength()) / 2.0;
        if (size > 0) {
            this.low.x -= size;
            this.high.x += size;
        }
        size = (min - this.yLength()) / 2.0;
        if (size > 0) {
            this.low.y -= size;
            this.high.y += size;
        }
        size = (min - this.zLength()) / 2.0;
        if (size > 0) {
            this.low.z -= size;
            this.high.z += size;
        }
    }
}
exports.Range3d = Range3d;
/**
 * Range on a 1d axis
 * * `low` and `high` members are always non-null objects
 * * having `low > high` indicates an empty range.
 * * the range contains x values for which `low <= x <= high`
 * @public
 */
class Range1d extends RangeBase {
    // explicit ctor - no enforcement of value relationships
    constructor(low = RangeBase._EXTREME_POSITIVE, high = RangeBase._EXTREME_NEGATIVE) {
        super();
        this.low = low;
        this.high = high; // duplicates set_direct, but compiler is not convinced they are set.
        this.setDirect(low, high);
    }
    /** reset the low and high to null range state. */
    setNull() {
        this.low = RangeBase._EXTREME_POSITIVE;
        this.high = RangeBase._EXTREME_NEGATIVE;
    }
    // internal use only -- directly set all coordinates, test only if directed.
    setDirect(low, high, correctToNull = false) {
        this.low = low;
        this.high = high;
        if (correctToNull && low > high)
            this.setNull();
    }
    /** Returns true if this and other have equal low and high parts, or both are null ranges. */
    isAlmostEqual(other) {
        return (Geometry_1.Geometry.isSameCoordinate(this.low, other.low) && Geometry_1.Geometry.isSameCoordinate(this.high, other.high))
            || (this.isNull && other.isNull);
    }
    /** copy contents from other Range1d. */
    setFrom(other) { this.low = other.low; this.high = other.high; }
    /** Convert from a JSON object of one of these forms:
     *
     * *  Any array of numbers: `[value,value, value]`
     * *  An object with low and high as properties: `{low:lowValue, high: highValue}`
     */
    setFromJSON(json) {
        this.setNull();
        if (Array.isArray(json)) {
            let value;
            for (value of json) {
                if (Number.isFinite(value))
                    this.extendX(value);
            }
        }
        else if (json.low !== undefined && Number.isFinite(json.low) && json.high !== undefined && Number.isFinite(json.high)) {
            this.extendX(json.low);
            this.extendX(json.high);
        }
    }
    /** Use `setFromJSON` to parse `json` into a new Range1d instance. */
    static fromJSON(json) {
        const result = new this();
        if (json)
            result.setFromJSON(json);
        return result;
    }
    /** Convert to a JSON object of form
     * ```
     *    [lowValue,highValue]
     * ```
     */
    toJSON() { if (this.isNull)
        return new Array();
    else
        return [this.low, this.high]; }
    /** return a new Range1d with contents of this.
     * @param result optional result.
     */
    clone(result) {
        result = result ? result : new this.constructor();
        result.setDirect(this.low, this.high);
        return result;
    }
    /** return a new Range1d with contents of this.
     * @param result optional result.
     */
    static createFrom(other, result) {
        result = result ? result : new this();
        result.setDirect(other.low, other.high);
        return result;
    }
    /** Create a range with no content.
     * @param result optional result.
     */
    static createNull(result) {
        result = result ? result : new this();
        result.setNull();
        return result;
    }
    /** create a range with `delta` added to low and high
     * * If `this` is a null range, return a null range.
     */
    cloneTranslated(delta, result) {
        result = result ? result : this.clone();
        if (!result.isNull) {
            result.low += delta;
            result.high += delta;
        }
        return result;
    }
    /**
     * Set this range to be a single value.
     * @param x value to use as both low and high.
     */
    setX(x) { this.low = this.high = x; }
    /** Create a single point box */
    static createX(x, result) {
        result = result ? result : new this();
        result.setDirect(x, x);
        return result;
    }
    /** Create a box from two values. Values are reversed if needed
     * @param xA first value
     * @param xB second value
     */
    static createXX(xA, xB, result) {
        result = result ? result : new this();
        result.setDirect(Math.min(xA, xB), Math.max(xA, xB));
        return result;
    }
    /** Create a box from two values, but null range if the values are reversed
     * @param xA first value
     * @param xB second value
     */
    static createXXOrCorrectToNull(xA, xB, result) {
        if (xB < xA)
            return Range1d.createNull(result);
        result = result ? result : new this();
        result.setDirect(Math.min(xA, xB), Math.max(xA, xB));
        return result;
    }
    /** Create a range containing all the values in an array.
     * @param values array of points to be contained in the range.
     * @param result optional result.
     */
    static createArray(values, result) {
        result = result ? result : new this();
        let x;
        for (x of values)
            result.extendX(x);
        return result;
    }
    /** extend to include an array of values */
    extendArray(values) {
        let x;
        for (x of values)
            this.extendX(x);
    }
    /** extend to include `values` at indices `beginIndex <= i < endIndex]`
     * @param values array of values
     * @param beginIndex first index to include
     * @param numValue number of values to access
     */
    extendArraySubset(values, beginIndex, numValue) {
        const endIndex = beginIndex + numValue;
        for (let i = beginIndex; i < endIndex; i++)
            this.extendX(values[i]);
    }
    /** Test if the box has high<low Note that a range around a single point is NOT null. */
    get isNull() {
        return this.high < this.low;
    }
    /** Test of the range contains a single point. */
    get isSinglePoint() {
        return this.high === this.low;
    }
    /** Return the length of the range in the x direction */
    length() { const a = this.high - this.low; return a > 0.0 ? a : 0.0; }
    /** return a point given by fractional positions within the range. This is done with no check for isNull !!! */
    fractionToPoint(fraction) {
        return Geometry_1.Geometry.interpolate(this.low, fraction, this.high);
    }
    /** Return the largest absolute value among the box limits. */
    maxAbs() {
        if (this.isNull)
            return 0.0;
        return Math.max(Math.abs(this.low), Math.abs(this.high));
    }
    /** Test if the x direction size is nearly zero */
    get isAlmostZeroLength() { return Geometry_1.Geometry.isSmallMetricDistance(this.length()); }
    /** Test if a number is within the range. */
    containsX(x) {
        return x >= this.low
            && x <= this.high;
    }
    /** Test of other range is within this range */
    containsRange(other) {
        return other.low >= this.low
            && other.high <= this.high;
    }
    /** Test if there is any intersection with other range */
    intersectsRange(other) {
        return !(this.low > other.high || other.low > this.high);
    }
    /** returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */
    distanceToRange(other) {
        return RangeBase.rangeToRangeAbsoluteDistance(this.low, this.high, other.low, other.high);
    }
    /** Return 0 if the point is within the range, otherwise the (unsigned) distance to the closest face or corner */
    distanceToX(x) {
        if (this.isNull)
            return RangeBase._EXTREME_POSITIVE;
        return RangeBase.coordinateToRangeAbsoluteDistance(x, this.low, this.high);
    }
    /** Expand this range by a single coordinate */
    extendX(x) {
        if (x < this.low)
            this.low = x;
        if (x > this.high)
            this.high = x;
    }
    /** Expand this range to include a range. */
    extendRange(other) {
        if (!other.isNull) {
            this.extendX(other.low);
            this.extendX(other.high);
        }
    }
    /** Return the intersection of ranges. */
    intersect(other, result) {
        if (!this.intersectsRange(other))
            return Range1d.createNull(result);
        return Range1d.createXXOrCorrectToNull(Math.max(this.low, other.low), Math.min(this.high, other.high), result);
    }
    /** Return the union of ranges. */
    /** Return the intersection of ranges. */
    union(other, result) {
        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.
        return Range1d.createXX(Math.min(this.low, other.low), Math.max(this.high, other.high), result);
    }
    /**
     * move low and high points by scaleFactor around the center point.
     * @param scaleFactor scale factor applied to low, high distance from center.
     */
    scaleAboutCenterInPlace(scaleFactor) {
        if (!this.isNull) {
            scaleFactor = Math.abs(scaleFactor);
            // do the scalar stuff to avoid making a temporary object ....
            const xMid = 0.5 * (this.low + this.high);
            this.high = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.high);
            this.low = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.low);
        }
    }
    /**
     * move all limits by a fixed amount.
     * * positive delta expands the range size
     * * negative delta reduces the range size
     * * if any dimension reduces below zero size, the whole range becomes null
     * @param delta shift to apply.
     */
    expandInPlace(delta) {
        this.setDirect(this.low - delta, this.high + delta, true);
    }
    /**
     * clip this range to a linear half space condition
     * * if `limitA > limitB` the limit space is empty
     *   * make this range null
     *   * return false;
     * * otherwise (i.e `limitA <= limitB`)
     *   * solve `a + u * f = limitA' and `a + u * f = limitA`
     *   * if unable to solve (i.e. u near zero), `a` alone determines whether to (a) leave this interval unchanged or (b) reduce to nothing.
     *   * the `f` values are an interval in the space of this `Range1d`
     *   * restrict the range to that interval (i.e intersect existing (low,high) with the fraction interval.
     *   * return true if the range is non-null after the clip.
     * @param a constant of linear map
     * @param u coefficient of linear map
     * @param limitA crossing value, assumed in range relation with limitB
     * @param limitB crossing value, assumed in range relation with limitB
     * @param limitIsHigh true if the limit is an upper limit on mapped values.
     *
     */
    clipLinearMapToInterval(a, u, limitA, limitB) {
        // f = (limit - a) / u
        if (limitB < limitA || this.high < this.low)
            return false;
        const fractionA = Geometry_1.Geometry.conditionalDivideFraction(limitA - a, u);
        const fractionB = Geometry_1.Geometry.conditionalDivideFraction(limitB - a, u);
        // single point case
        if (fractionA === undefined || fractionB === undefined) {
            if (limitA <= a && a <= limitB)
                return true;
            this.setNull();
            return false;
        }
        if (fractionA < fractionB) {
            if (fractionA > this.low)
                this.low = fractionA;
            if (fractionB < this.high)
                this.high = fractionB;
        }
        else {
            if (fractionA < this.high)
                this.high = fractionA;
            if (fractionB > this.low)
                this.low = fractionB;
        }
        if (this.high < this.low) {
            this.setNull();
            return false;
        }
        return true;
    }
}
exports.Range1d = Range1d;
/**
 * Range box in xy plane
 * @public
 */
class Range2d extends RangeBase {
    // explicit ctor - no enforcement of value relationships
    constructor(lowX = Range2d._EXTREME_POSITIVE, lowY = Range2d._EXTREME_POSITIVE, highX = Range2d._EXTREME_NEGATIVE, highY = Range2d._EXTREME_NEGATIVE) {
        super();
        this.low = Point2dVector2d_1.Point2d.create(lowX, lowY);
        this.high = Point2dVector2d_1.Point2d.create(highX, highY);
    }
    /** reset the low and high to null range state. */
    setNull() {
        this.low.x = RangeBase._EXTREME_POSITIVE;
        this.low.y = RangeBase._EXTREME_POSITIVE;
        this.high.x = RangeBase._EXTREME_NEGATIVE;
        this.high.y = RangeBase._EXTREME_NEGATIVE;
    }
    /** Flatten the low and high coordinates of any json object with low.x .. high.y into an array of 4 doubles */
    static toFloat64Array(val) { return Float64Array.of(val.low.x, val.low.y, val.high.x, val.high.y); }
    /** Flatten the low and high coordinates of this instance into an array of 4 doubles */
    toFloat64Array() { return Range2d.toFloat64Array(this); }
    /**
     * Construct a Range2d from an array of double-precision values
     * @param f64 the array, which should contain exactly 4 values in this order: lowX, lowY, highX, highY
     * @return a new Range2d object
     */
    static fromFloat64Array(f64) {
        if (f64.length !== 4)
            throw new Error("invalid array");
        return new this(f64[0], f64[1], f64[2], f64[3]);
    }
    /**
     * Construct a Range2d from an un-typed array. This mostly useful when interpreting ECSQL query results of the 'blob' type, where you know that that result is a Range3d.
     * @param buffer untyped array
     * @return a new Range2d object
     */
    static fromArrayBuffer(buffer) { return this.fromFloat64Array(new Float64Array(buffer)); }
    /** Returns true if this and other have equal low and high parts, or both are null ranges. */
    isAlmostEqual(other) {
        return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))
            || (this.isNull && other.isNull);
    }
    /** copy all content from any `other` that has low and high xy data. */
    setFrom(other) {
        this.low.set(other.low.x, other.low.y);
        this.high.set(other.high.x, other.high.y);
    }
    /** create a new Range2d from any `other` that has low and high xy data. */
    static createFrom(other, result) {
        if (result) {
            result.setFrom(other);
            return result;
        }
        return this.createXYXYOrCorrectToNull(other.low.x, other.low.y, other.high.x, other.high.y, result);
    }
    /** treat any array of numbers as numbers to be inserted !!! */
    setFromJSON(json) {
        this.setNull();
        if (Array.isArray(json)) {
            const point = Point2dVector2d_1.Point2d.create();
            for (const value of json) {
                point.setFromJSON(value);
                this.extendPoint(point);
            }
            return;
        }
        const low = Point2dVector2d_1.Point2d.fromJSON(json.low);
        const high = Point2dVector2d_1.Point2d.fromJSON(json.high);
        if (!RangeBase.isExtremePoint2d(low) && !RangeBase.isExtremePoint2d(high)) {
            this.extendPoint(low);
            this.extendPoint(high);
        }
    }
    /** Freeze this instance (and its deep content) so it can be considered read-only */
    freeze() { Object.freeze(this.low); Object.freeze(this.high); }
    /** return json array with two points as produced by `Point2d.toJSON` */
    toJSON() { return this.isNull ? [] : [this.low.toJSON(), this.high.toJSON()]; }
    /** Use `setFromJSON` to parse `json` into a new Range2d instance. */
    static fromJSON(json) {
        const result = new this();
        if (json)
            result.setFromJSON(json);
        return result;
    }
    // internal use only -- directly set all coordinates, without tests.
    setDirect(xA, yA, xB, yB, correctToNull) {
        this.low.x = xA;
        this.low.y = yA;
        this.high.x = xB;
        this.high.y = yB;
        if (correctToNull) {
            if (this.low.x > this.high.x || this.low.y > this.high.y)
                this.setNull();
        }
    }
    /** return a clone of this range (or copy to optional result) */
    clone(result) {
        result = result ? result : new this.constructor();
        result.setDirect(this.low.x, this.low.y, this.high.x, this.high.y, false);
        return result;
    }
    /** create a range with no content. */
    static createNull(result) {
        result = result ? result : new this();
        result.setNull();
        return result;
    }
    /** Set low and hight to a single xy value. */
    setXY(x, y) {
        this.low.x = this.high.x = x;
        this.low.y = this.high.y = y;
    }
    /** Create a single point box */
    static createXY(x, y, result) {
        result = result ? result : new this();
        result.setDirect(x, y, x, y, false);
        return result;
    }
    /** Create a box with 2 pairs of xy candidates. Theses are compared and shuffled as needed for the box. */
    static createXYXY(xA, yA, xB, yB, result) {
        result = result ? result : new this();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.max(xA, xB), Math.max(yA, yB), false);
        return result;
    }
    /** Create a box with 2 pairs of xy candidates. If any direction has order flip, create null. */
    static createXYXYOrCorrectToNull(xA, yA, xB, yB, result) {
        if (xA > xB || yA > yB)
            return this.createNull(result);
        result = result ? result : new this();
        result.setDirect(Math.min(xA, xB), Math.min(yA, yB), Math.max(xA, xB), Math.max(yA, yB), true);
        return result;
    }
    /** Create a range around an array of points. */
    static createArray(points, result) {
        result = result ? result : new this();
        let point;
        for (point of points)
            result.extendPoint(point);
        return result;
    }
    /** Test if the box has high<low for any of x,y, condition. Note that a range around a single point is NOT null. */
    get isNull() {
        return this.high.x < this.low.x
            || this.high.y < this.low.y;
    }
    /** Test if the box has high strictly less than low for any of x,y, condition. Note that a range around a single point is NOT null. */
    static isNull(range) {
        return range.high.x < range.low.x
            || range.high.y < range.low.y;
    }
    /** Test of the range contains a single point. */
    get isSinglePoint() {
        return this.high.x === this.low.x
            && this.high.y === this.low.y;
    }
    /** Return the midpoint of the diagonal.  No test for null range. */
    get center() { return this.low.interpolate(.5, this.high); }
    /** return the low x coordinate */
    get xLow() { return this.low.x; }
    /** return the low y coordinate */
    get yLow() { return this.low.y; }
    /** return the high x coordinate */
    get xHigh() { return this.high.x; }
    /** return the high y coordinate */
    get yHigh() { return this.high.y; }
    /** Length of the box in the x direction */
    xLength() { const a = this.high.x - this.low.x; return a > 0.0 ? a : 0.0; }
    /** Length of the box in the y direction */
    yLength() { const a = this.high.y - this.low.y; return a > 0.0 ? a : 0.0; }
    /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonal(result) { return this.low.vectorTo(this.high, result); }
    /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */
    diagonalFractionToPoint(fraction, result) { return this.low.interpolate(fraction, this.high, result); }
    /** return a point given by fractional positions on the XY axes. This is done with no check for isNull !!! */
    fractionToPoint(fractionX, fractionY, result) {
        return this.low.interpolateXY(fractionX, fractionY, this.high, result);
    }
    /** Return an array with the 4 corners.
     * * if asLoop is false, 4 corners are "x varies fastest, then y"
     * * if asLoop is true, 5 corners are in CCW order WITH CLOSURE
     */
    corners3d(asLoop = false, z = 0) {
        if (asLoop)
            return [
                Point3dVector3d_1.Point3d.create(this.low.x, this.low.y, z),
                Point3dVector3d_1.Point3d.create(this.high.x, this.low.y, z),
                Point3dVector3d_1.Point3d.create(this.high.x, this.high.y, z),
                Point3dVector3d_1.Point3d.create(this.low.x, this.high.y, z),
                Point3dVector3d_1.Point3d.create(this.low.x, this.low.y, z)
            ];
        return [
            Point3dVector3d_1.Point3d.create(this.low.x, this.low.y, z),
            Point3dVector3d_1.Point3d.create(this.high.x, this.low.y, z),
            Point3dVector3d_1.Point3d.create(this.low.x, this.high.y, z),
            Point3dVector3d_1.Point3d.create(this.high.x, this.high.y, z)
        ];
    }
    /** Largest absolute value among any coordinates in the box corners. */
    maxAbs() {
        if (this.isNull)
            return 0.0;
        return Math.max(this.low.maxAbs(), this.high.maxAbs());
    }
    /** Test if the x direction size is nearly zero */
    get isAlmostZeroX() { return Geometry_1.Geometry.isSmallMetricDistance(this.xLength()); }
    /** Test if the y direction size is nearly zero */
    get isAlmostZeroY() { return Geometry_1.Geometry.isSmallMetricDistance(this.yLength()); }
    /** Test if a point given as x,y is within the range. */
    containsXY(x, y) {
        return x >= this.low.x
            && y >= this.low.y
            && x <= this.high.x
            && y <= this.high.y;
    }
    /** Test if a point is within the range. */
    containsPoint(point) { return this.containsXY(point.x, point.y); }
    /** Test of other range is within this range */
    containsRange(other) {
        return other.low.x >= this.low.x
            && other.low.y >= this.low.y
            && other.high.x <= this.high.x
            && other.high.y <= this.high.y;
    }
    /** Test if there is any intersection with other range */
    intersectsRange(other) {
        return !(this.low.x > other.high.x
            || this.low.y > other.high.y
            || other.low.x > this.high.x
            || other.low.y > this.high.y);
    }
    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */
    distanceToPoint(point) {
        if (this.isNull)
            return Range2d._EXTREME_POSITIVE;
        return Math.min(Geometry_1.Geometry.hypotenuseXY(RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x), RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y)), Range2d._EXTREME_POSITIVE);
    }
    /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */
    distanceToRange(other) {
        return Math.min(Geometry_1.Geometry.hypotenuseXY(RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x), RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y)), Range2d._EXTREME_POSITIVE);
    }
    /** Expand this range to include a point given by x,y */
    extendXY(x, y) {
        if (x < this.low.x)
            this.low.x = x;
        if (x > this.high.x)
            this.high.x = x;
        if (y < this.low.y)
            this.low.y = y;
        if (y > this.high.y)
            this.high.y = y;
    }
    /** Expand this range to include a point given by x,y */
    extendTransformedXY(transform, x, y) {
        const x1 = transform.multiplyComponentXYZ(0, x, y, 0);
        const y1 = transform.multiplyComponentXYZ(1, x, y, 0);
        this.extendXY(x1, y1);
    }
    /** Expand this range to include a point. */
    extendPoint(point) { this.extendXY(point.x, point.y); }
    /** Expand this range to include a range. */
    extendRange(other) {
        if (!Range2d.isNull(other)) {
            this.extendXY(other.low.x, other.low.y);
            this.extendXY(other.high.x, other.high.y);
        }
    }
    /** Return the intersection of ranges. */
    intersect(other, result) {
        if (!this.intersectsRange(other))
            return Range2d.createNull(result);
        return Range2d.createXYXY(Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y), Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y), result);
    }
    /** Return the union of ranges. */
    union(other, result) {
        if (this.isNull)
            return Range2d.createFrom(other, result);
        if (Range2d.isNull(other))
            return this.clone(result);
        // we trust null ranges have EXTREME values, so a null in either input leads to expected results.
        return Range2d.createXYXY(Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y), Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y), result);
    }
    /**
     * move low and high points by scaleFactor around the center point.
     * @param scaleFactor scale factor applied to low, high distance from center.
     */
    scaleAboutCenterInPlace(scaleFactor) {
        if (!this.isNull) {
            scaleFactor = Math.abs(scaleFactor);
            // do the scalar stuff to avoid making a temporary object ....
            const xMid = 0.5 * (this.low.x + this.high.x);
            const yMid = 0.5 * (this.low.y + this.high.y);
            this.high.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.high.x);
            this.high.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.high.y);
            this.low.x = Geometry_1.Geometry.interpolate(xMid, scaleFactor, this.low.x);
            this.low.y = Geometry_1.Geometry.interpolate(yMid, scaleFactor, this.low.y);
        }
    }
    /**
     * move all limits by a fixed amount.
     * * positive delta expands the range size
     * * negative delta reduces the range size
     * * if any dimension reduces below zero size, the whole range becomes null
     * @param delta shift to apply.
     */
    expandInPlace(delta) {
        this.setDirect(this.low.x - delta, this.low.y - delta, this.high.x + delta, this.high.y + delta, true);
    }
}
exports.Range2d = Range2d;


/***/ }),

/***/ "./lib/geometry3d/Ray3d.js":
/*!*********************************!*\
  !*** ./lib/geometry3d/Ray3d.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ./Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const CurveLocationDetail_1 = __webpack_require__(/*! ../curve/CurveLocationDetail */ "./lib/curve/CurveLocationDetail.js");
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Range_1 = __webpack_require__(/*! ./Range */ "./lib/geometry3d/Range.js");
/** A Ray3d contains
 * * an origin point.
 * * a direction vector.  The vector is NOT required to be normalized.
 *  * an optional weight (number).
 * @public
 */
class Ray3d {
    // constructor captures references !!!
    constructor(origin, direction) {
        this.origin = origin;
        this.direction = direction;
        this.a = undefined;
    }
    static _create(x, y, z, u, v, w) {
        return new Ray3d(Point3dVector3d_1.Point3d.create(x, y, z), Point3dVector3d_1.Vector3d.create(u, v, w));
    }
    /** Create a ray on the x axis. */
    static createXAxis() { return Ray3d._create(0, 0, 0, 1, 0, 0); }
    /** Create a ray on the y axis. */
    static createYAxis() { return Ray3d._create(0, 0, 0, 0, 1, 0); }
    /** Create a ray on the z axis. */
    static createZAxis() { return Ray3d._create(0, 0, 0, 0, 0, 1); }
    /** Create a ray with all zeros. */
    static createZero(result) {
        if (result) {
            result.origin.setZero();
            result.direction.setZero();
            return result;
        }
        return new Ray3d(Point3dVector3d_1.Point3d.createZero(), Point3dVector3d_1.Vector3d.createZero());
    }
    /** Test for nearly equal rays. */
    isAlmostEqual(other) {
        return this.origin.isAlmostEqual(other.origin) && this.direction.isAlmostEqual(other.direction);
    }
    /** Create a ray from origin and direction. */
    static create(origin, direction, result) {
        if (result) {
            result.set(origin, direction);
            return result;
        }
        return new Ray3d(origin.clone(), direction.clone());
    }
    /**
     * Given a homogeneous point and its derivative components, construct a Ray3d with cartesian coordinates and derivatives.
     * @param weightedPoint `[x,y,z,w]` parts of weighted point.
     * @param weightedDerivative `[x,y,z,w]` derivatives
     * @param result
     */
    static createWeightedDerivative(weightedPoint, weightedDerivative, result) {
        const w = weightedPoint[3];
        const dw = weightedDerivative[3];
        const x = weightedPoint[0];
        const y = weightedPoint[1];
        const z = weightedPoint[2];
        const dx = weightedDerivative[0] * w - weightedPoint[0] * dw;
        const dy = weightedDerivative[1] * w - weightedPoint[1] * dw;
        const dz = weightedDerivative[2] * w - weightedPoint[2] * dw;
        if (Geometry_1.Geometry.isSmallMetricDistance(w))
            return undefined;
        const divW = 1.0 / w;
        const divWW = divW * divW;
        return Ray3d.createXYZUVW(x * divW, y * divW, z * divW, dx * divWW, dy * divWW, dz * divWW, result);
    }
    /** Create from coordinates of the origin and direction. */
    static createXYZUVW(originX, originY, originZ, directionX, directionY, directionZ, result) {
        if (result) {
            result.getOriginRef().set(originX, originY, originZ);
            result.getDirectionRef().set(directionX, directionY, directionZ);
            return result;
        }
        return new Ray3d(Point3dVector3d_1.Point3d.create(originX, originY, originZ), Point3dVector3d_1.Vector3d.create(directionX, directionY, directionZ));
    }
    /** Capture origin and direction in a new Ray3d. */
    static createCapture(origin, direction) {
        return new Ray3d(origin, direction);
    }
    /** Create from (clones of) origin, direction, and numeric weight. */
    static createPointVectorNumber(origin, direction, a, result) {
        if (result) {
            result.origin.setFrom(origin);
            result.direction.setFrom(direction);
            result.a = a;
            return result;
        }
        result = new Ray3d(origin.clone(), direction.clone());
        result.a = a;
        return result;
    }
    /** Create from origin and target.  The direction vector is the full length (non-unit) vector from origin to target. */
    static createStartEnd(origin, target, result) {
        if (result) {
            result.origin.setFrom(origin);
            result.direction.setStartEnd(origin, target);
            return result;
        }
        return new Ray3d(origin, Point3dVector3d_1.Vector3d.createStartEnd(origin, target));
    }
    /** Return a reference to the ray's origin. */
    getOriginRef() { return this.origin; }
    /** Return a reference to the ray's direction vector. */
    getDirectionRef() { return this.direction; }
    /** copy coordinates from origin and direction. */
    set(origin, direction) {
        this.origin.setFrom(origin);
        this.direction.setFrom(direction);
    }
    /** Clone the ray. */
    clone(result) {
        if (result) {
            result.set(this.origin.clone(), this.direction.clone());
            return result;
        }
        return new Ray3d(this.origin.clone(), this.direction.clone());
    }
    /** Create a clone and return the transform of the clone. */
    cloneTransformed(transform) {
        return new Ray3d(transform.multiplyPoint3d(this.origin), transform.multiplyVector(this.direction));
    }
    /** Apply a transform in place. */
    transformInPlace(transform) {
        transform.multiplyPoint3d(this.origin, this.origin);
        transform.multiplyVector(this.direction, this.direction);
    }
    /** Copy data from another ray. */
    setFrom(source) { this.set(source.origin, source.direction); }
    /** * fraction 0 is the ray origin.
     * * fraction 1 is at the end of the direction vector when placed at the origin.
     * @returns Return a point at fractional position along the ray.
     */
    fractionToPoint(fraction) { return this.origin.plusScaled(this.direction, fraction); }
    /** Return the dot product of the ray's direction vector with a vector from the ray origin to the space point. */
    dotProductToPoint(spacePoint) { return this.direction.dotProductStartEnd(this.origin, spacePoint); }
    /**
     * Return the fractional coordinate (along the direction vector) of the spacePoint projected to the ray.
     */
    pointToFraction(spacePoint) {
        return Geometry_1.Geometry.safeDivideFraction(this.direction.dotProductStartEnd(this.origin, spacePoint), this.direction.magnitudeSquared(), 0);
    }
    /**
     *
     * Return the spacePoint projected onto the ray.
     */
    projectPointToRay(spacePoint) {
        return this.origin.plusScaled(this.direction, this.pointToFraction(spacePoint));
    }
    /** Return a transform for rigid axes
     * at ray origin with z in ray direction.  If the direction vector is zero, axes default to identity (from createHeadsUpTriad)
     */
    toRigidZFrame() {
        const axes = Matrix3d_1.Matrix3d.createRigidHeadsUp(this.direction, Geometry_1.AxisOrder.ZXY);
        return Transform_1.Transform.createOriginAndMatrix(this.origin, axes);
    }
    /**
     * Convert {origin:[x,y,z], direction:[u,v,w]} to a Ray3d.
     */
    setFromJSON(json) {
        if (!json) {
            this.origin.set(0, 0, 0);
            this.direction.set(0, 0, 1);
            return;
        }
        this.origin.setFromJSON(json.origin);
        this.direction.setFromJSON(json.direction);
    }
    /**
     * try to scale the direction vector to a given magnitude.
     * @returns Returns false if ray direction is a zero vector.
     */
    trySetDirectionMagnitudeInPlace(magnitude = 1.0) {
        if (this.direction.tryNormalizeInPlace()) {
            this.direction.scaleInPlace(magnitude);
            return true;
        }
        this.direction.setZero();
        this.a = 0.0;
        return false;
    }
    /**
     * If parameter `a` is clearly nonzero and the direction vector can be normalized,
     * * save the parameter `a` as the optional `a` member of the ray.
     * * normalize the ray's direction vector
     * If parameter `a` is nearly zero,
     * * Set the `a` member to zero
     * * Set the ray's direction vector to zero.
     * @param a area to be saved.
     */
    // input a ray and "a" understood as an area.
    // if a is clearly nonzero metric squared and the vector can be normalized, install those and return true.
    // otherwise set ray.z to zero and zero the vector of the ray and return false.
    tryNormalizeInPlaceWithAreaWeight(a) {
        const tolerance = Geometry_1.Geometry.smallMetricDistanceSquared;
        this.a = a;
        if (Math.abs(a) > tolerance && this.direction.tryNormalizeInPlace(tolerance))
            return true;
        this.direction.setZero();
        this.a = 0.0;
        return false;
    }
    /**
     * Convert an Angle to a JSON object.
     * @return {*} [origin,normal]
     */
    toJSON() { return { origin: this.origin.toJSON(), direction: this.direction.toJSON() }; }
    /** Create a new ray from json object.  See `setFromJSON` for json structure; */
    static fromJSON(json) {
        const result = Ray3d.createXAxis();
        result.setFromJSON(json);
        return result;
    }
    /** return distance from the ray to point in space */
    distance(spacePoint) {
        const uu = this.direction.magnitudeSquared();
        const uv = this.dotProductToPoint(spacePoint);
        const aa = Geometry_1.Geometry.inverseMetricDistanceSquared(uu);
        if (aa)
            return Math.sqrt(this.origin.distanceSquared(spacePoint) - uv * uv * aa);
        else
            return Math.sqrt(this.origin.distanceSquared(spacePoint));
    }
    /**
     * Return the intersection of the unbounded ray with a plane.
     * Stores the point of intersection in the result point given as a parameter,
     * and returns the parameter along the ray where the intersection occurs.
     * Returns undefined if the ray and plane are parallel.
     */
    intersectionWithPlane(plane, result) {
        const vectorA = Point3dVector3d_1.Vector3d.createStartEnd(plane.getOriginRef(), this.origin);
        const uDotN = this.direction.dotProduct(plane.getNormalRef());
        const aDotN = vectorA.dotProduct(plane.getNormalRef());
        const division = Geometry_1.Geometry.conditionalDivideFraction(-aDotN, uDotN);
        if (undefined === division)
            return undefined;
        if (result) {
            this.origin.plusScaled(this.direction, division, result);
        }
        return division;
    }
    /**
     * * Find intersection of the ray with a Range3d.
     * * return the range of fractions (on the ray) which are "inside" the range.
     * * Note that a range is always returned;  if there is no intersection it is indicated by the test `result.sNull`
     */
    intersectionWithRange3d(range, result) {
        if (range.isNull)
            return Range_1.Range1d.createNull(result);
        const interval = Range_1.Range1d.createXX(-Geometry_1.Geometry.largeCoordinateResult, Geometry_1.Geometry.largeCoordinateResult, result);
        if (interval.clipLinearMapToInterval(this.origin.x, this.direction.x, range.low.x, range.high.x)
            && interval.clipLinearMapToInterval(this.origin.y, this.direction.y, range.low.y, range.high.y)
            && interval.clipLinearMapToInterval(this.origin.z, this.direction.z, range.low.z, range.high.z))
            return interval;
        return interval;
    }
    /** Construct a vector from `ray.origin` to target point.
     * * return the part of the vector that is perpendicular to `ray.direction`.
     *  * i.e. return the shortest vector from the ray to the point.
     */
    perpendicularPartOfVectorToTarget(targetPoint, result) {
        const vectorV = Point3dVector3d_1.Vector3d.createStartEnd(this.origin, targetPoint);
        const uu = this.direction.magnitudeSquared();
        const uv = this.direction.dotProductStartEnd(this.origin, targetPoint);
        const fraction = Geometry_1.Geometry.safeDivideFraction(uv, uu, 0.0);
        return vectorV.plusScaled(this.direction, -fraction, result);
    }
    /** Determine if two rays intersect, are fully overlapped, parallel but no coincident, or skew
     * * Return a CurveLocationDetailPair which
     * * contains fraction and point on each ray.
     * * has (in the CurveLocationDetailPair structure, as member approachType) annotation indicating one of these relationships
     *   * CurveCurveApproachType.Intersection -- the rays have a simple intersection, at fractions indicated in detailA and detailB
     *   * CurveCurveApproachType.PerpendicularChord -- there is pair of where the rays have closest approach.  The rays are skew in space.
     *   * CurveCurveApproachType.CoincidentGeometry -- the rays are the same unbounded line in space. The fractions and points are a representative single common point.
     *   * CurveCurveApproachType.Parallel -- the rays are parallel (and not coincident).   The two points are at the minimum distance
     */
    static closestApproachRay3dRay3d(rayA, rayB) {
        const intersectionFractions = Point2dVector2d_1.Vector2d.create();
        let fractionA, fractionB;
        let pointA, pointB;
        let pairType;
        if (Polynomials_1.SmallSystem.ray3dXYZUVWClosestApproachUnbounded(rayA.origin.x, rayA.origin.y, rayA.origin.z, rayA.direction.x, rayA.direction.y, rayA.direction.z, rayB.origin.x, rayB.origin.y, rayB.origin.z, rayB.direction.x, rayB.direction.y, rayB.direction.z, intersectionFractions)) {
            fractionA = intersectionFractions.x;
            fractionB = intersectionFractions.y;
            pointA = rayA.fractionToPoint(fractionA);
            pointB = rayB.fractionToPoint(fractionB);
            pairType = pointA.isAlmostEqualMetric(pointB) ? CurveLocationDetail_1.CurveCurveApproachType.Intersection : CurveLocationDetail_1.CurveCurveApproachType.PerpendicularChord;
        }
        else {
            fractionB = 0.0;
            fractionA = rayA.pointToFraction(rayB.origin);
            pointA = rayA.fractionToPoint(fractionA);
            pointB = rayB.fractionToPoint(fractionB);
            pairType = pointA.isAlmostEqualMetric(pointB) ? CurveLocationDetail_1.CurveCurveApproachType.CoincidentGeometry : CurveLocationDetail_1.CurveCurveApproachType.ParallelGeometry;
        }
        const pair = CurveLocationDetail_1.CurveLocationDetailPair.createCapture(CurveLocationDetail_1.CurveLocationDetail.createRayFractionPoint(rayA, fractionA, rayA.fractionToPoint(fractionA)), CurveLocationDetail_1.CurveLocationDetail.createRayFractionPoint(rayB, fractionB, rayB.fractionToPoint(fractionB)));
        pair.approachType = pairType;
        return pair;
    }
}
exports.Ray3d = Ray3d;


/***/ }),

/***/ "./lib/geometry3d/Segment1d.js":
/*!*************************************!*\
  !*** ./lib/geometry3d/Segment1d.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * * A Segment1d is an interval of an axis named x.
 * * The interval is defined by two values x0 and x1.
 * * The x0 and x1 values can be in either order.
 *   * if `x0 < x1` fractional coordinates within the segment move from left to right.
 *   * if `x0 > x1` fractional coordinates within the segment move from right to left.
 * * This differs from a Range1d in that:
 * * For a Range1d the reversed ordering of its limit values means "empty interval".
 * * For a Segment1d the reversed ordering is a real interval but fractional positions move backwards.
 * * The segment is parameterized with a fraction
 * * * Fraction 0 is the start (`x0`)
 * * * Fraction 1 is the end (`x1`)
 * * * The fraction equation is `x = x0 + fraction * (x1-x0)` or (equivalently) `x = (1-fraction) * x0 + fraction * x1`
 * @public
 */
class Segment1d {
    constructor(x0, x1) {
        this.x0 = x0;
        this.x1 = x1;
    }
    /**
     * replace both end values.
     * @param x0 new x0 value
     * @param x1 new y0 value
     */
    set(x0, x1) { this.x0 = x0, this.x1 = x1; }
    /**
     * shift (translate) the segment along its axis by adding `dx` to both `x0` and `x1`.
     * @param dx value to add to both x0 and x1
     */
    shift(dx) { this.x0 += dx, this.x1 += dx; }
    /**
     * create segment1d with given end values
     * @param x0 start value
     * @param x1 end value
     * @param result optional pre-existing result to be reinitialized.
     */
    static create(x0 = 0, x1 = 1, result) {
        if (!result)
            return new Segment1d(x0, x1);
        result.set(x0, x1);
        return result;
    }
    /**
     * Copy both end values from other Segment1d
     * @param other source Segment1d
     */
    setFrom(other) { this.x0 = other.x0; this.x1 = other.x1; }
    /**
     * clone this Segment1d, return as a separate object.
     */
    clone() { return new Segment1d(this.x0, this.x1); }
    /**
     * Returns true if both coordinates (`x0` and `x1`) are in the 0..1 range.
     */
    get isIn01() {
        return Geometry_1.Geometry.isIn01(this.x0) && Geometry_1.Geometry.isIn01(this.x1);
    }
    /**
     * Evaluate the segment at fractional position
     * @returns position within the segment
     * @param fraction fractional position within this segment
     */
    fractionToPoint(fraction) { return Geometry_1.Geometry.interpolate(this.x0, fraction, this.x1); }
    /**
     * Return the signed start-to-end shift (aka distance)
     */
    signedDelta() { return this.x1 - this.x0; }
    /**
     * * swap the x0 and x1 member values.
     * * This makes the fractionToPoint evaluates reverse direction.
     */
    reverseInPlace() { const x = this.x0; this.x0 = this.x1; this.x1 = x; }
    /**
     * Near equality test, using Geometry.isSameCoordinate for tolerances.
     */
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSameCoordinate(this.x0, other.x0) && Geometry_1.Geometry.isSameCoordinate(this.x1, other.x1);
    }
    /**
     * Return true if the segment limits are (exactly) 0 and 1
     */
    get isExact01() { return this.x0 === 0.0 && this.x1 === 1.0; }
    /**
     * Return true if the segment limits are (exactly) 1 and 0
     */
    get isExact01Reversed() { return this.x0 === 1.0 && this.x1 === 0.0; }
    /** On input, `this` is an interval of a line.  On output, the interval has been clipped to positive parts of a linear function
     * * f0 and f1 are values at parameter values 0 and 1 (which are in general NOT x0 and x1)
     * * From that determine where the segment crosses function value 0.
     * * The segment contains some interval in the same parameter space.
     * * Clip the segment to the positive part of the space.
     * * Return true (and modify the segment) if any of the segment remains.
     * * Return false (but without modifying the segment) if the active part is entirely out.
     */
    clipBy01FunctionValuesPositive(f0, f1) {
        const df01 = f1 - f0;
        const fA = f0 + this.x0 * df01;
        const fB = f0 + this.x1 * df01;
        const dfAB = fB - fA;
        if (fA > 0) {
            if (fB >= 0)
                return true; // inside at both ends
            /** There is an inside to outside crossing. The division is safe ... (and value between 0 and 1) */
            const u = -fA / dfAB;
            this.x1 = this.x0 + u * (this.x1 - this.x0);
            return true;
        }
        else if (fA < 0) {
            if (fB < 0)
                return false; // outside at both ends.
            /** There is an outside to inside crossing crossing. The division is safe ... (and value between 0 and 1) */
            const u = -fA / dfAB;
            this.x0 = this.x0 + u * (this.x1 - this.x0);
            return true;
        }
        /** fA is on the cut.   fB determines the entire segment. */
        return fB > 0;
    }
}
exports.Segment1d = Segment1d;


/***/ }),

/***/ "./lib/geometry3d/Transform.js":
/*!*************************************!*\
  !*** ./lib/geometry3d/Transform.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const Range_1 = __webpack_require__(/*! ./Range */ "./lib/geometry3d/Range.js");
const Point2dVector2d_1 = __webpack_require__(/*! ./Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
/** A transform is an origin and a Matrix3d.
 *
 * * This describes a coordinate frame with
 * this origin, with the columns of the Matrix3d being the
 * local x,y,z axis directions.
 * *  Beware that for common transformations (e.g. scale about point,
 * rotate around line, mirror across a plane) the "fixed point" that is used
 * when describing the transform is NOT the "origin" stored in the transform.
 * Setup methods (e.g createFixedPointAndMatrix, createScaleAboutPoint)
 * take care of determining the appropriate origin coordinates.
 * @public
 */
class Transform {
    // Constructor accepts and uses POINTER to content .. no copy here.
    constructor(origin, matrix) { this._origin = origin; this._matrix = matrix; }
    /** The identity Transform. Value is frozen and cannot be modified. */
    static get identity() {
        if (undefined === this._identity) {
            this._identity = Transform.createIdentity();
            this._identity.freeze();
        }
        return this._identity;
    }
    /** Freeze this instance (and its deep content) so it can be considered read-only */
    freeze() { Object.freeze(this); Object.freeze(this._origin); this._matrix.freeze(); }
    /**
     * Copy contents from other Transform into this Transform
     * @param other source transform
     */
    setFrom(other) { this._origin.setFrom(other._origin), this._matrix.setFrom(other._matrix); }
    /** Set this Transform to be an identity. */
    setIdentity() { this._origin.setZero(); this._matrix.setIdentity(); }
    /** Set this Transform instance from flexible inputs:
     * * Any object (such as another Transform) that has `origin` and `matrix` members accepted by Point3d.setFromJSON and Matrix3d.setFromJSON
     * * An array of 3 number arrays, each with 4 entries which are rows in a 3x4 matrix.
     * * An array of 12 numbers, each block of 4 entries as a row 3x4 matrix.
     */
    setFromJSON(json) {
        if (json) {
            if (json instanceof Object && json.origin && json.matrix) {
                this._origin.setFromJSON(json.origin);
                this._matrix.setFromJSON(json.matrix);
                return;
            }
            if (Geometry_1.Geometry.isArrayOfNumberArray(json, 3, 4)) {
                const data = json;
                this._matrix.setRowValues(data[0][0], data[0][1], data[0][2], data[1][0], data[1][1], data[1][2], data[2][0], data[2][1], data[2][2]);
                this._origin.set(data[0][3], data[1][3], data[2][3]);
                return;
            }
            if (Geometry_1.Geometry.isNumberArray(json, 12)) {
                const data = json;
                this._matrix.setRowValues(data[0], data[1], data[2], data[4], data[5], data[6], data[8], data[9], data[10]);
                this._origin.set(data[3], data[7], data[11]);
                return;
            }
        }
        this.setIdentity();
    }
    /**
     * Test for near equality with other Transform.  Comparison uses the isAlmostEqual methods on
     * the origin and matrix parts.
     * @param other Transform to compare to.
     */
    isAlmostEqual(other) { return this._origin.isAlmostEqual(other._origin) && this._matrix.isAlmostEqual(other._matrix); }
    /** Return a 3 by 4 matrix containing the rows of this Transform
     * * This transform's origin is the [3] entry of the json arrays
     */
    toJSON() {
        // return { origin: this._origin.toJSON(), matrix: this._matrix.toJSON() };
        return [
            [this._matrix.coffs[0], this._matrix.coffs[1], this._matrix.coffs[2], this._origin.x],
            [this._matrix.coffs[3], this._matrix.coffs[4], this._matrix.coffs[5], this._origin.y],
            [this._matrix.coffs[6], this._matrix.coffs[7], this._matrix.coffs[8], this._origin.z],
        ];
    }
    /** Return a new Transform initialized by `setFromJSON (json)` */
    static fromJSON(json) {
        const result = Transform.createIdentity();
        result.setFromJSON(json);
        return result;
    }
    /** Copy the contents of this transform into a new Transform (or to the result, if specified). */
    clone(result) {
        if (result) {
            result._matrix.setFrom(this._matrix);
            result._origin.setFrom(this._origin);
            return result;
        }
        return new Transform(Point3dVector3d_1.Point3d.createFrom(this._origin), this._matrix.clone());
    }
    /** Return a copy of this Transform, modified so that its axes are rigid
     * * The first axis direction named in axisOrder is preserved
     * * The plane of the first and second directions is preserved, and its vector in the rigid matrix has positive dot product with the corresponding vector if the instance
     * * The third named column is the cross product of the first and second.
     */
    cloneRigid(axisOrder = Geometry_1.AxisOrder.XYZ) {
        const axes0 = Matrix3d_1.Matrix3d.createRigidFromMatrix3d(this.matrix, axisOrder);
        if (!axes0)
            return undefined;
        return new Transform(this.origin.cloneAsPoint3d(), axes0);
    }
    /** Create a copy with the given origin and matrix captured as the Transform origin and Matrix3d. */
    static createRefs(origin, matrix, result) {
        if (result) {
            result._origin = origin;
            result._matrix = matrix;
            return result;
        }
        return new Transform(origin, matrix);
    }
    /** Create a transform with complete contents given */
    static createRowValues(qxx, qxy, qxz, ax, qyx, qyy, qyz, ay, qzx, qzy, qzz, az, result) {
        if (result) {
            result._origin.set(ax, ay, az);
            result._matrix.setRowValues(qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz);
            return result;
        }
        return new Transform(Point3dVector3d_1.Point3d.create(ax, ay, az), Matrix3d_1.Matrix3d.createRowValues(qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz));
    }
    /** Create a transform with all zeros.
     */
    static createZero(result) {
        return Transform.createRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, result);
    }
    /**
     * create a Transform with translation provided by x,y,z parts.
     * @param x x part of translation
     * @param y y part of translation
     * @param z z part of translation
     * @param result optional result
     * @returns new or updated transform.
     */
    static createTranslationXYZ(x = 0, y = 0, z = 0, result) {
        return Transform.createRefs(Point3dVector3d_1.Vector3d.create(x, y, z), Matrix3d_1.Matrix3d.createIdentity(), result);
    }
    /** Create a matrix with specified translation part.
     * @param XYZ x,y,z parts of the translation.
     * @returns new or updated transform.
     */
    static createTranslation(translation, result) {
        return Transform.createRefs(translation, Matrix3d_1.Matrix3d.createIdentity(), result);
    }
    /** Return a reference to the matrix within the transform.  (NOT a copy) */
    get matrix() { return this._matrix; }
    /** Return a reference to the origin within the transform.  (NOT a copy) */
    get origin() { return this._origin; }
    /** return a (clone of) the origin part of the transform, as a Point3d */
    getOrigin() { return Point3dVector3d_1.Point3d.createFrom(this._origin); }
    /** return a (clone of) the origin part of the transform, as a Vector3d */
    getTranslation() { return Point3dVector3d_1.Vector3d.createFrom(this._origin); }
    /** test if the transform has 000 origin and identity Matrix3d */
    get isIdentity() {
        return this._matrix.isIdentity && this._origin.isAlmostZero;
    }
    /** Return an identity transform, optionally filling existing transform.  */
    static createIdentity(result) {
        if (result) {
            result._origin.setZero();
            result._matrix.setIdentity();
            return result;
        }
        return Transform.createRefs(Point3dVector3d_1.Point3d.createZero(), Matrix3d_1.Matrix3d.createIdentity());
    }
    /** Create by directly installing origin and matrix
     * this is a the appropriate construction when the columns of the matrix are coordinate axes of a local-to-global mapping
     * Note there is a closely related createFixedPointAndMatrix whose point input is the fixed point of the global-to-global transformation.
     */
    static createOriginAndMatrix(origin, matrix, result) {
        return Transform.createRefs(origin ? origin.cloneAsPoint3d() : Point3dVector3d_1.Point3d.createZero(), matrix === undefined ? Matrix3d_1.Matrix3d.createIdentity() : matrix.clone(), result);
    }
    /** Create by directly installing origin and columns of the matrix
     */
    static createOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ, result) {
        if (result)
            result.setOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ);
        else
            result = Transform.createRefs(Point3dVector3d_1.Vector3d.createFrom(origin), Matrix3d_1.Matrix3d.createColumns(vectorX, vectorY, vectorZ));
        return result;
    }
    /** Reinitialize by directly installing origin and columns of the matrix
     */
    setOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ) {
        if (origin !== undefined)
            this._origin.setFrom(origin);
        this._matrix.setColumns(vectorX, vectorY, vectorZ);
    }
    /** Create a transform with the specified matrix. Compute an origin (different from the given fixedPoint)
     * so that the fixedPoint maps back to itself.
     */
    static createFixedPointAndMatrix(fixedPoint, matrix, result) {
        const origin = Matrix3d_1.Matrix3d.xyzMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);
        return Transform.createRefs(origin, matrix.clone(), result);
    }
    /** Create a transform with the specified matrix, acting on any `pointX `via
     * `pointY = matrix * (pointX - pointA) + pointB`
     * so that the fixedPoint maps back to itself.
     */
    static createMatrixPickupPutdown(matrix, pointA, pointB, result) {
        const origin = Matrix3d_1.Matrix3d.xyzMinusMatrixTimesXYZ(pointB, matrix, pointA);
        return Transform.createRefs(origin, matrix.clone(), result);
    }
    /** Create a Transform which leaves the fixedPoint unchanged and
     * scales everything else around it by a single scale factor.
     */
    static createScaleAboutPoint(fixedPoint, scale, result) {
        const matrix = Matrix3d_1.Matrix3d.createScale(scale, scale, scale);
        const origin = Matrix3d_1.Matrix3d.xyzMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);
        return Transform.createRefs(origin, matrix, result);
    }
    /** Transform the input 2d point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyPoint2d(source, result) {
        return Matrix3d_1.Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, source, result);
    }
    /** Transform the input 3d point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyPoint3d(point, result) {
        return Matrix3d_1.Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, point, result);
    }
    /** Transform the input object with x,y,z members */
    multiplyXYAndZInPlace(point) {
        return Matrix3d_1.Matrix3d.xyzPlusMatrixTimesXYZInPlace(this._origin, this._matrix, point);
    }
    /** Transform the input point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyXYZ(x, y, z = 0, result) {
        return Matrix3d_1.Matrix3d.xyzPlusMatrixTimesCoordinates(this._origin, this._matrix, x, y, z, result);
    }
    /** Multiply a specific row of the transform times xyz. Return the (number). */
    multiplyComponentXYZ(componentIndex, x, y, z = 0) {
        const coffs = this._matrix.coffs;
        const i0 = 3 * componentIndex;
        return this.origin.at(componentIndex) + coffs[i0] * x + coffs[i0 + 1] * y + coffs[i0 + 2] * z;
    }
    /** Multiply a specific row of the transform times (weighted!) xyzw. Return the (number). */
    multiplyComponentXYZW(componentIndex, x, y, z, w) {
        const coffs = this._matrix.coffs;
        const i0 = 3 * componentIndex;
        return this.origin.at(componentIndex) * w +
            coffs[i0] * x + coffs[i0 + 1] * y + coffs[i0 + 2] * z;
    }
    /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyXYZW(x, y, z, w, result) {
        return Matrix3d_1.Matrix3d.xyzPlusMatrixTimesWeightedCoordinates(this._origin, this._matrix, x, y, z, w, result);
    }
    /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyXYZWToFloat64Array(x, y, z, w, result) {
        return Matrix3d_1.Matrix3d.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin, this._matrix, x, y, z, w, result);
    }
    /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyXYZToFloat64Array(x, y, z, result) {
        return Matrix3d_1.Matrix3d.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin, this._matrix, x, y, z, result);
    }
    /** Multiply the transposed transform (as 4x4 with 0001 row) by Point4d given as xyzw..  Return as a new point or in the pre-allocated result (if result is given) */
    multiplyTransposeXYZW(x, y, z, w, result) {
        const coffs = this._matrix.coffs;
        const origin = this._origin;
        return Point4d_1.Point4d.create(x * coffs[0] + y * coffs[3] + z * coffs[6], x * coffs[1] + y * coffs[4] + z * coffs[7], x * coffs[2] + y * coffs[5] + z * coffs[8], x * origin.x + y * origin.y + z * origin.z + w, result);
    }
    /** for each point:  replace point by Transform*point */
    multiplyPoint3dArrayInPlace(points) {
        let point;
        for (point of points)
            Matrix3d_1.Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, point, point);
    }
    /** for each point:  replace point by Transform*point */
    multiplyPoint3dArrayArrayInPlace(chains) {
        for (const chain of chains)
            this.multiplyPoint3dArrayInPlace(chain);
    }
    /** Return product of the transform's inverse times a point. */
    multiplyInversePoint3d(point, result) {
        return this._matrix.multiplyInverseXYZAsPoint3d(point.x - this._origin.x, point.y - this._origin.y, point.z - this._origin.z, result);
    }
    /** Return product of the transform's inverse times a point (point given as x,y,z) */
    multiplyInverseXYZ(x, y, z, result) {
        return this._matrix.multiplyInverseXYZAsPoint3d(x - this._origin.x, y - this._origin.y, z - this._origin.z, result);
    }
    /**
     * *  for each point:   multiply    transform * point
     * *  if result is given, resize to match source and replace each corresponding pi
     * *  if result is not given, return a new array.
     */
    multiplyInversePoint3dArray(source, result) {
        if (!this._matrix.computeCachedInverse(true))
            return undefined;
        const originX = this.origin.x;
        const originY = this.origin.y;
        const originZ = this.origin.z;
        if (result) {
            const n = Transform.matchArrayLengths(source, result, Point3dVector3d_1.Point3d.createZero);
            for (let i = 0; i < n; i++)
                this._matrix.multiplyInverseXYZAsPoint3d(source[i].x - originX, source[i].y - originY, source[i].z - originZ, result[i]);
        }
        result = [];
        for (const p of source)
            result.push(this._matrix.multiplyInverseXYZAsPoint3d(p.x - originX, p.y - originY, p.z - originZ));
        return result;
    }
    /**
     * * for each point in source: multiply transformInverse * point in place in the point.
     * * return false if not invertible.
     */
    multiplyInversePoint3dArrayInPlace(source) {
        if (!this._matrix.computeCachedInverse(true))
            return false;
        const originX = this.origin.x;
        const originY = this.origin.y;
        const originZ = this.origin.z;
        const n = source.length;
        for (let i = 0; i < n; i++)
            this._matrix.multiplyInverseXYZAsPoint3d(source[i].x - originX, source[i].y - originY, source[i].z - originZ, source[i]);
        return true;
    }
    /**
     * * Compute (if needed) the inverse of the matrix part, thereby ensuring inverse operations can complete.
     * * Return true if matrix inverse completes.
     * @param useCached If true, accept prior cached inverse if available.
     */
    computeCachedInverse(useCached = true) {
        return this._matrix.computeCachedInverse(useCached);
    }
    /**
     * * If destination has more values than source, remove the extras.
     * * If destination has fewer values, use the constructionFunction to create new ones.
     * @param source array
     * @param dest destination array, to  be modified to match source length
     * @param constructionFunction function to call to create new entries.
     */
    // modify destination so it has non-null points for the same length as the source.
    // (ASSUME existing elements of dest are non-null, and that parameters are given as either Point2d or Point3d arrays)
    static matchArrayLengths(source, dest, constructionFunction) {
        const numSource = source.length;
        const numDest = dest.length;
        if (numSource > numDest) {
            for (let i = numDest; i < numSource; i++) {
                dest.push(constructionFunction());
            }
        }
        else if (numDest > numSource) {
            dest.length = numSource;
        }
        return numSource;
    }
    /**
     * *  for each point:   multiply    transform * point
     * *  if result is given, resize to match source and replace each corresponding pi
     * *  if result is not given, return a new array.
     */
    multiplyPoint2dArray(source, result) {
        if (result) {
            const n = Transform.matchArrayLengths(source, result, Point2dVector2d_1.Point2d.createZero);
            for (let i = 0; i < n; i++)
                Matrix3d_1.Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, source[i], result[i]);
            return result;
        }
        result = [];
        for (const p of source)
            result.push(Matrix3d_1.Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, p));
        return result;
    }
    /**
     * *  for each point:   multiply    transform * point
     * *  if result is given, resize to match source and replace each corresponding pi
     * *  if result is not given, return a new array.
     */
    multiplyPoint3dArray(source, result) {
        if (result) {
            const n = Transform.matchArrayLengths(source, result, Point3dVector3d_1.Point3d.createZero);
            for (let i = 0; i < n; i++)
                Matrix3d_1.Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, source[i], result[i]);
            return result;
        }
        result = [];
        for (const p of source)
            result.push(Matrix3d_1.Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, p));
        return result;
    }
    /** Multiply the vector by the Matrix3d part of the transform.
     *
     * *  The transform's origin is not used.
     * *  Return as new or result by usual optional result convention
     */
    multiplyVector(vector, result) {
        return this._matrix.multiplyVector(vector, result);
    }
    /** Multiply the vector (x,y,z) by the Matrix3d part of the transform.
     *
     * *  The transform's origin is not used.
     * *  Return as new or result by usual optional result convention
     */
    multiplyVectorXYZ(x, y, z, result) {
        return this._matrix.multiplyXYZ(x, y, z, result);
    }
    /** multiply this Transform times other Transform.
     * @param other right hand transform for multiplication.
     * @param result optional preallocated result to reuse.
     */
    multiplyTransformTransform(other, result) {
        if (!result)
            return Transform.createRefs(Matrix3d_1.Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, other._origin), this._matrix.multiplyMatrixMatrix(other._matrix));
        result.setMultiplyTransformTransform(this, other);
        return result;
    }
    /**
     * multiply transformA * transformB, store to calling instance.
     * @param transformA left operand
     * @param transformB right operand
     */
    setMultiplyTransformTransform(transformA, transformB) {
        if (Transform._scratchPoint === undefined)
            Transform._scratchPoint = Point3dVector3d_1.Point3d.create();
        Matrix3d_1.Matrix3d.xyzPlusMatrixTimesXYZ(transformA._origin, transformA._matrix, transformB._origin, Transform._scratchPoint);
        this._origin.setFrom(Transform._scratchPoint);
        transformA._matrix.multiplyMatrixMatrix(transformB._matrix, this._matrix);
    }
    //   [Q A][R 0] = [QR A]
    //   [0 1][0 1]   [0  1]
    /** multiply this Transform times other Matrix3d, with other considered to be a Transform with 0 translation.
     * @param other right hand Matrix3d for multiplication.
     * @param result optional preallocated result to reuse.
     */
    multiplyTransformMatrix3d(other, result) {
        if (!result)
            return Transform.createRefs(this._origin.cloneAsPoint3d(), this._matrix.multiplyMatrixMatrix(other));
        this._matrix.multiplyMatrixMatrix(other, result._matrix);
        result._origin.setFrom(this._origin);
        return result;
    }
    /** transform each of the 8 corners of a range. Return the range of the transformed corners */
    multiplyRange(range, result) {
        if (range.isNull)
            return range.clone(result);
        // snag current values to allow aliasing.
        const lowX = range.low.x;
        const lowY = range.low.y;
        const lowZ = range.low.z;
        const highX = range.high.x;
        const highY = range.high.y;
        const highZ = range.high.z;
        result = Range_1.Range3d.createNull(result);
        result.extendTransformedXYZ(this, lowX, lowY, lowZ);
        result.extendTransformedXYZ(this, highX, lowY, lowZ);
        result.extendTransformedXYZ(this, lowX, highY, lowZ);
        result.extendTransformedXYZ(this, highX, highY, lowZ);
        result.extendTransformedXYZ(this, lowX, lowY, highZ);
        result.extendTransformedXYZ(this, highX, lowY, highZ);
        result.extendTransformedXYZ(this, lowX, highY, highZ);
        result.extendTransformedXYZ(this, highX, highY, highZ);
        return result;
    }
    /**
     * * Return a Transform which is the inverse of this transform.
     * * Return undefined if this Transform's matrix is singular.
     */
    inverse() {
        const matrixInverse = this._matrix.inverse();
        if (!matrixInverse)
            return undefined;
        return Transform.createRefs(matrixInverse.multiplyXYZ(-this._origin.x, -this._origin.y, -this._origin.z), matrixInverse);
    }
    /** Initialize transforms that map each direction of a box (axis aligned) to `[0,1]`.
     * @param min the "000" corner of the box
     * @param max the "111" corner of the box
     * @param npcToGlobal (object created by caller, re-initialized) transform that carries 01 coordinates into the min,max box.
     * @param globalToNpc (object created by caller, re-initialized) transform that carries world coordinates into 01
     */
    static initFromRange(min, max, npcToGlobal, globalToNpc) {
        const diag = max.minus(min);
        if (diag.x === 0.0)
            diag.x = 1.0;
        if (diag.y === 0.0)
            diag.y = 1.0;
        if (diag.z === 0.0)
            diag.z = 1.0;
        const rMatrix = new Matrix3d_1.Matrix3d();
        if (npcToGlobal) {
            Matrix3d_1.Matrix3d.createScale(diag.x, diag.y, diag.z, rMatrix);
            Transform.createOriginAndMatrix(min, rMatrix, npcToGlobal);
        }
        if (globalToNpc) {
            const origin = new Point3dVector3d_1.Point3d(-min.x / diag.x, -min.y / diag.y, -min.z / diag.z);
            Matrix3d_1.Matrix3d.createScale(1.0 / diag.x, 1.0 / diag.y, 1.0 / diag.z, rMatrix);
            Transform.createOriginAndMatrix(origin, rMatrix, globalToNpc);
        }
    }
}
exports.Transform = Transform;


/***/ }),

/***/ "./lib/geometry3d/YawPitchRollAngles.js":
/*!**********************************************!*\
  !*** ./lib/geometry3d/YawPitchRollAngles.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module CartesianGeometry */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ./Angle */ "./lib/geometry3d/Angle.js");
const Matrix3d_1 = __webpack_require__(/*! ./Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ./Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
// cspell:word Tait
/** Three angles that determine the orientation of an object in space. Sometimes referred to as [TaitBryan angles](https://en.wikipedia.org/wiki/Euler_angles).
 * * The matrix construction can be replicated by this logic:
 * * xyz coordinates have
 *   * x forward
 *   * y to left
 *   * z up
 *   * Note that this is a right handed coordinate system.
 *   * yaw is a rotation of x towards y, i.e. around positive z:
 *     * `yawMatrix = Matrix3d.createRotationAroundAxisIndex(2, Angle.createDegrees(yawDegrees));`
 *   * pitch is a rotation that raises x towards z, i.e. rotation around negative y:
 *     * `pitchMatrix = Matrix3d.createRotationAroundAxisIndex(1, Angle.createDegrees(-pitchDegrees));`
 *   * roll is rotation of y towards z, i.e. rotation around positive x:
 *     * `rollMatrix = Matrix3d.createRotationAroundAxisIndex(0, Angle.createDegrees(rollDegrees));`
 *   * The YPR matrix is the product
 *     * `result = yawMatrix.multiplyMatrixMatrix(pitchMatrix.multiplyMatrixMatrix(rollMatrix));`
 *   * Note that this is for "column based" matrix, with vectors appearing to the right
 *     * Hence a vector is first rotated by roll, then the pitch, finally yaw.
 * @public
 */
class YawPitchRollAngles {
    constructor(yaw = Angle_1.Angle.zero(), pitch = Angle_1.Angle.zero(), roll = Angle_1.Angle.zero()) {
        this.yaw = yaw;
        this.pitch = pitch;
        this.roll = roll;
    }
    /** Freeze this YawPitchRollAngles */
    freeze() { Object.freeze(this.yaw); Object.freeze(this.pitch); Object.freeze(this.roll); }
    /** constructor for YawPitchRollAngles with angles in degrees. */
    static createDegrees(yawDegrees, pitchDegrees, rollDegrees) {
        return new YawPitchRollAngles(Angle_1.Angle.createDegrees(yawDegrees), Angle_1.Angle.createDegrees(pitchDegrees), Angle_1.Angle.createDegrees(rollDegrees));
    }
    /** constructor for YawPitchRollAngles with angles in radians. */
    static createRadians(yawRadians, pitchRadians, rollRadians) {
        return new YawPitchRollAngles(Angle_1.Angle.createRadians(yawRadians), Angle_1.Angle.createRadians(pitchRadians), Angle_1.Angle.createRadians(rollRadians));
    }
    /** construct a `YawPitchRoll` object from an object with 3 named angles */
    static fromJSON(json) {
        json = json ? json : {};
        return new YawPitchRollAngles(Angle_1.Angle.fromJSON(json.yaw), Angle_1.Angle.fromJSON(json.pitch), Angle_1.Angle.fromJSON(json.roll));
    }
    /** populate yaw, pitch and roll fields using `Angle.fromJSON` */
    setFromJSON(json) {
        json = json ? json : {};
        this.yaw = Angle_1.Angle.fromJSON(json.yaw);
        this.pitch = Angle_1.Angle.fromJSON(json.pitch);
        this.roll = Angle_1.Angle.fromJSON(json.roll);
    }
    /** Convert to a JSON object of form { pitch: 20 , roll: 29.999999999999996 , yaw: 10 }. Any values that are exactly zero (with tolerance `Geometry.smallAngleRadians`) are omitted. */
    toJSON() {
        const val = {};
        if (!this.pitch.isAlmostZero)
            val.pitch = this.pitch.toJSON();
        if (!this.roll.isAlmostZero)
            val.roll = this.roll.toJSON();
        if (!this.yaw.isAlmostZero)
            val.yaw = this.yaw.toJSON();
        return val;
    }
    /**
     * Install all rotations from `other` into `this`.
     * @param other YawPitchRollAngles source
     */
    setFrom(other) {
        this.yaw.setFrom(other.yaw);
        this.pitch.setFrom(other.pitch);
        this.roll.setFrom(other.roll);
    }
    /**
     * * Compare angles between `this` and `other`.
     * * Comparisons are via `isAlmostEqualAllowPeriodShift`.
     * @param other YawPitchRollAngles source
     */
    isAlmostEqual(other) {
        return this.yaw.isAlmostEqualAllowPeriodShift(other.yaw)
            && this.pitch.isAlmostEqualAllowPeriodShift(other.pitch)
            && this.roll.isAlmostEqualAllowPeriodShift(other.roll);
    }
    /**
     * Make a copy of this YawPitchRollAngles.
     */
    clone() { return new YawPitchRollAngles(this.yaw.clone(), this.pitch.clone(), this.roll.clone()); }
    /**
     * Expand the angles into a (rigid rotation) matrix.
     *
     * * The returned matrix is "rigid" -- unit length rows and columns, and its transpose is its inverse.
     * * The "rigid" matrix is always a right handed coordinate system.
     * @param result optional pre-allocated `Matrix3d`
     */
    toMatrix3d(result) {
        const c0 = Math.cos(this.yaw.radians);
        const s0 = Math.sin(this.yaw.radians);
        const c1 = Math.cos(this.pitch.radians);
        const s1 = Math.sin(this.pitch.radians);
        const c2 = Math.cos(this.roll.radians);
        const s2 = Math.sin(this.roll.radians);
        return Matrix3d_1.Matrix3d.createRowValues(c0 * c1, -(s0 * c2 + c0 * s1 * s2), (s0 * s2 - c0 * s1 * c2), s0 * c1, (c0 * c2 - s0 * s1 * s2), -(c0 * s2 + s0 * s1 * c2), s1, c1 * s2, c1 * c2, result);
    }
    /** Return the largest angle in radians */
    maxAbsRadians() {
        return Geometry_1.Geometry.maxAbsXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);
    }
    /** Return the sum of the angles in squared radians */
    sumSquaredRadians() {
        return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);
    }
    /** Returns true if this rotation does nothing.
     * * If allowPeriodShift is false, any nonzero angle is considered a non-identity
     * * If allowPeriodShift is true, all angles are individually allowed to be any multiple of 360 degrees.
     */
    isIdentity(allowPeriodShift = true) {
        if (allowPeriodShift)
            return Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.yaw.radians)
                && Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.pitch.radians)
                && Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.roll.radians);
        else
            return Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.yaw.radians)
                && Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.pitch.radians)
                && Angle_1.Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.roll.radians);
    }
    /** Return the largest difference of angles (in radians) between this and other */
    maxDiffRadians(other) {
        return Math.max(this.yaw.radians - other.yaw.radians, this.pitch.radians - other.pitch.radians, this.roll.radians - other.roll.radians);
    }
    /** Return the largest angle in degrees. */
    maxAbsDegrees() { return Geometry_1.Geometry.maxAbsXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees); }
    /** Return the sum of squared angles in degrees. */
    sumSquaredDegrees() { return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees); }
    /** Return an object from a Transform as an origin and YawPitchRollAngles. */
    static tryFromTransform(transform) {
        // bundle up the transform's origin with the angle data extracted from the transform
        return {
            angles: YawPitchRollAngles.createFromMatrix3d(transform.matrix),
            origin: Point3dVector3d_1.Point3d.createFrom(transform.origin),
        };
    }
    /** Attempts to create a YawPitchRollAngles object from an Matrix3d
     * * This conversion fails if the matrix is not rigid (unit rows and columns, transpose is inverse)
     * * In the failure case the method's return value is `undefined`.
     * * In the failure case, if the optional result was supplied, that result will nonetheless be filled with a set of angles.
     */
    static createFromMatrix3d(matrix, result) {
        const s1 = matrix.at(2, 0);
        const c1 = Math.sqrt(matrix.at(2, 1) * matrix.at(2, 1) + matrix.at(2, 2) * matrix.at(2, 2));
        const pitchA = Angle_1.Angle.createAtan2(s1, c1); // with positive cosine
        const pitchB = Angle_1.Angle.createAtan2(s1, -c1); // with negative cosine
        const angles = result ? result : new YawPitchRollAngles(); // default undefined . . .
        if (c1 < Geometry_1.Geometry.smallAngleRadians) { // This is a radians test !!!
            angles.yaw = Angle_1.Angle.createAtan2(-matrix.at(0, 1), matrix.at(1, 1));
            angles.pitch = pitchA;
            angles.roll = Angle_1.Angle.createRadians(0.0);
        }
        else {
            const yawA = Angle_1.Angle.createAtan2(matrix.at(1, 0), matrix.at(0, 0));
            const rollA = Angle_1.Angle.createAtan2(matrix.at(2, 1), matrix.at(2, 2));
            const yawB = Angle_1.Angle.createAtan2(-matrix.at(1, 0), -matrix.at(0, 0));
            const rollB = Angle_1.Angle.createAtan2(-matrix.at(2, 1), -matrix.at(2, 2));
            const yprA = new YawPitchRollAngles(yawA, pitchA, rollA);
            const yprB = new YawPitchRollAngles(yawB, pitchB, rollB);
            const absFactor = 0.95;
            const radiansA = yprA.maxAbsRadians();
            const radiansB = yprB.maxAbsRadians();
            if (radiansA < absFactor * radiansB) {
                angles.setFrom(yprA);
            }
            else if (radiansB < absFactor * radiansA) {
                angles.setFrom(yprB);
            }
            else {
                const sumA = yprA.sumSquaredRadians();
                const sumB = yprB.sumSquaredRadians();
                if (sumA <= sumB) {
                    angles.setFrom(yprA);
                }
                else {
                    angles.setFrom(yprB);
                }
            }
        }
        const matrix1 = angles.toMatrix3d();
        return matrix.maxDiff(matrix1) < Geometry_1.Geometry.smallAngleRadians ? angles : undefined;
    }
}
exports.YawPitchRollAngles = YawPitchRollAngles;


/***/ }),

/***/ "./lib/geometry4d/Map4d.js":
/*!*********************************!*\
  !*** ./lib/geometry4d/Map4d.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Matrix4d_1 = __webpack_require__(/*! ./Matrix4d */ "./lib/geometry4d/Matrix4d.js");
/** @module Numerics */
/** Map4 carries two Matrix4d which are inverses of each other.
 * @public
 */
class Map4d {
    constructor(matrix0, matrix1) {
        this._matrix0 = matrix0;
        this._matrix1 = matrix1;
    }
    /** Return a reference to (not copy of) the "forward" Matrix4d */
    get transform0() { return this._matrix0; }
    /** Return a reference to (not copy of) the "reverse" Matrix4d */
    get transform1() { return this._matrix1; }
    /** Create a Map4d, capturing the references to the two matrices. */
    static createRefs(matrix0, matrix1) {
        return new Map4d(matrix0, matrix1);
    }
    /** Create an identity map. */
    static createIdentity() { return new Map4d(Matrix4d_1.Matrix4d.createIdentity(), Matrix4d_1.Matrix4d.createIdentity()); }
    /** Create a Map4d with given transform pair.
     * @returns undefined if the transforms are not inverses of each other.
     */
    static createTransform(transform0, transform1) {
        if (transform1 === undefined) {
            transform1 = transform0.inverse();
            if (transform1 === undefined)
                return undefined;
        }
        else {
            const product = transform0.multiplyTransformTransform(transform1);
            if (!product.isIdentity)
                return undefined;
        }
        return new Map4d(Matrix4d_1.Matrix4d.createTransform(transform0), Matrix4d_1.Matrix4d.createTransform(transform1));
    }
    /**
     * Create a mapping the scales and translates (no rotation) between boxes.
     * @param lowA low point of box A
     * @param highA high point of box A
     * @param lowB low point of box B
     * @param highB high point of box B
     */
    static createBoxMap(lowA, highA, lowB, highB, result) {
        const t0 = Matrix4d_1.Matrix4d.createBoxToBox(lowA, highA, lowB, highB, result ? result.transform0 : undefined);
        const t1 = Matrix4d_1.Matrix4d.createBoxToBox(lowB, highB, lowA, highA, result ? result.transform1 : undefined);
        if (t0 && t1) {
            if (result)
                return result;
            return new Map4d(t0, t1);
        }
        return undefined;
    }
    /** Copy contents from another Map4d */
    setFrom(other) { this._matrix0.setFrom(other._matrix0), this._matrix1.setFrom(other._matrix1); }
    /** Return a clone of this Map4d */
    clone() { return new Map4d(this._matrix0.clone(), this._matrix1.clone()); }
    /** Reinitialize this Map4d as an identity. */
    setIdentity() { this._matrix0.setIdentity(); this._matrix1.setIdentity(); }
    /** Set this map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */
    setFromJSON(json) {
        if (json.matrix0 && json.matrix1) {
            this._matrix0.setFromJSON(json.matrix0);
            this._matrix1.setFromJSON(json.matrix1);
        }
        else
            this.setIdentity();
    }
    /** Create a map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */
    static fromJSON(json) {
        const result = new Map4d(Matrix4d_1.Matrix4d.createIdentity(), Matrix4d_1.Matrix4d.createIdentity());
        result.setFromJSON(json);
        return result;
    }
    /** Return a json object `{matrix0: value0, matrix1: value1}` */
    toJSON() { return { matrix0: this._matrix0.toJSON(), matrix1: this._matrix1.toJSON() }; }
    /** Test if both matrices are almost equal to those */
    isAlmostEqual(other) {
        return this._matrix0.isAlmostEqual(other._matrix0) && this._matrix1.isAlmostEqual(other._matrix1);
    }
    /** Create a map between a frustum and world coordinates.
     * @param origin lower left of frustum
     * @param uVector Vector from lower left rear to lower right rear
     * @param vVector Vector from lower left rear to upper left rear
     * @param wVector Vector from lower left rear to lower left front, i.e. lower left rear towards eye.
     * @param fraction front size divided by rear size.
     */
    static createVectorFrustum(origin, uVector, vVector, wVector, fraction) {
        fraction = Math.max(fraction, 1.0e-8);
        const slabToWorld = Transform_1.Transform.createOriginAndMatrix(origin, Matrix3d_1.Matrix3d.createColumns(uVector, vVector, wVector));
        const worldToSlab = slabToWorld.inverse();
        if (!worldToSlab)
            return undefined;
        const worldToSlabMap = new Map4d(Matrix4d_1.Matrix4d.createTransform(worldToSlab), Matrix4d_1.Matrix4d.createTransform(slabToWorld));
        const slabToNPCMap = new Map4d(Matrix4d_1.Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, fraction, 0, 0, 0, fraction - 1.0, 1), Matrix4d_1.Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1.0 / fraction, 0, 0, 0, (1.0 - fraction) / fraction, 1));
        const result = slabToNPCMap.multiplyMapMap(worldToSlabMap);
        /*
        let numIdentity = 0;
        const productA = worldToSlabMap.matrix0.multiplyMatrixMatrix(worldToSlabMap.matrix1);
        if (productA.isIdentity())
          numIdentity++;
        const productB = slabToNPCMap.matrix0.multiplyMatrixMatrix(slabToNPCMap.matrix1);
        if (productB.isIdentity())
          numIdentity++;
        const product = result.matrix0.multiplyMatrixMatrix(result.matrix1);
        if (product.isIdentity())
          numIdentity++;
        if (numIdentity === 3)
            return result;
          */
        return result;
    }
    /** multiply this*other. The output matrices are
     * * output matrix0 = `this.matrix0 * other.matrix0`
     * * output matrix1 = 'other.matrix1 * this.matrix1`
     */
    multiplyMapMap(other) {
        return new Map4d(this._matrix0.multiplyMatrixMatrix(other._matrix0), other._matrix1.multiplyMatrixMatrix(this._matrix1));
    }
    /** Exchange the two matrices of the map. */
    reverseInPlace() {
        const temp = this._matrix0;
        this._matrix0 = this._matrix1;
        this._matrix1 = temp;
    }
    /** return a Map4d whose transform0 is
     * other.transform0 * this.transform0 * other.transform1
     */
    sandwich0This1(other) {
        return new Map4d(other._matrix0.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(other._matrix1)), other._matrix0.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(other._matrix1)));
    }
    /** return a Map4d whose transform0 is
     * other.transform1 * this.transform0 * other.transform0
     */
    sandwich1This0(other) {
        return new Map4d(other._matrix1.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(other._matrix0)), other._matrix1.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(other._matrix0)));
    }
} // Map4d
exports.Map4d = Map4d;


/***/ }),

/***/ "./lib/geometry4d/Matrix4d.js":
/*!************************************!*\
  !*** ./lib/geometry4d/Matrix4d.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Point4d_1 = __webpack_require__(/*! ./Point4d */ "./lib/geometry4d/Point4d.js");
/**
 * * A Matrix4d is a matrix with 4 rows and 4 columns.
 * * The 4 rows may be described as the x,y,z,w rows.
 * * The 4 columns may be described as the x,y,z,w columns.
 * * The matrix is physically stored as a Float64Array with 16 numbers.
 * * The layout in the Float64Array is "by row"
 *   * indices 0,1,2,3 are the "x row".   They may be called the xx,xy,xz,xw entries
 *   * indices 4,5,6,7 are the "y row"    They may be called the yx,yy,yz,yw entries
 *   * indices 8,9,10,11 are the "z row"  They may be called the zx,zy,zz,zw entries
 *   * indices 12,13,14,15 are the "w row".  They may be called the wx,wy,wz,ww entries
 * * If "w row" contains numeric values 0,0,0,1, the Matrix4d is equivalent to a Transform with
 *  * The upper right 3x3 matrix (entries 0,1,2,4,5,6,8,9,10) are the 3x3 matrix part of the transform
 *  * The far right column entries xw,yw,zw are the "origin" (sometimes called "translation") part of the transform.
 * @public
 */
class Matrix4d {
    constructor() { this._coffs = new Float64Array(16); }
    /** Copy matrix entries from `other` */
    setFrom(other) {
        for (let i = 0; i < 16; i++)
            this._coffs[i] = other._coffs[i];
    }
    /** Return a deep clone. */
    clone(result) {
        if (result === this)
            return this;
        if (result === undefined)
            result = new Matrix4d();
        for (let i = 0; i < 16; i++)
            result._coffs[i] = this._coffs[i];
        return result;
    }
    /** zero this matrix4d in place. */
    setZero() {
        for (let i = 0; i < 16; i++)
            this._coffs[i] = 0;
    }
    /** set to identity. */
    setIdentity() {
        for (let i = 0; i < 16; i++)
            this._coffs[i] = 0;
        this._coffs[0] = this._coffs[5] = this._coffs[10] = this._coffs[15] = 1.0;
    }
    static is1000(a, b, c, d, tol) {
        return Math.abs(a - 1.0) <= tol
            && Math.abs(b) <= tol
            && Math.abs(c) <= tol
            && Math.abs(d) <= tol;
    }
    /** set to identity. */
    isIdentity(tol = 1.0e-10) {
        return Matrix4d.is1000(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3], tol)
            && Matrix4d.is1000(this._coffs[5], this._coffs[6], this._coffs[7], this._coffs[4], tol)
            && Matrix4d.is1000(this._coffs[10], this._coffs[11], this._coffs[8], this._coffs[9], tol)
            && Matrix4d.is1000(this._coffs[15], this._coffs[12], this._coffs[13], this._coffs[14], tol);
    }
    /** create a Matrix4d filled with zeros. */
    static createZero(result) {
        if (result) {
            result.setZero();
            return result;
        }
        return new Matrix4d(); // this is zero.
    }
    /** create a Matrix4d with values supplied "across the rows" */
    static createRowValues(cxx, cxy, cxz, cxw, cyx, cyy, cyz, cyw, czx, czy, czz, czw, cwx, cwy, cwz, cww, result) {
        result = result ? result : new Matrix4d();
        result._coffs[0] = cxx;
        result._coffs[1] = cxy;
        result._coffs[2] = cxz;
        result._coffs[3] = cxw;
        result._coffs[4] = cyx;
        result._coffs[5] = cyy;
        result._coffs[6] = cyz;
        result._coffs[7] = cyw;
        result._coffs[8] = czx;
        result._coffs[9] = czy;
        result._coffs[10] = czz;
        result._coffs[11] = czw;
        result._coffs[12] = cwx;
        result._coffs[13] = cwy;
        result._coffs[14] = cwz;
        result._coffs[15] = cww;
        return result;
    }
    /** Create a `Matrix4d` from 16 values appearing as `Point4d` for each row. */
    static createRows(rowX, rowY, rowZ, rowW, result) {
        return this.createRowValues(rowX.x, rowX.y, rowX.z, rowX.w, rowY.x, rowY.y, rowY.z, rowY.w, rowZ.x, rowZ.y, rowZ.z, rowZ.w, rowW.x, rowW.y, rowW.z, rowW.w, result);
    }
    /** directly set columns from typical 3d data:
     *
     * * vectorX, vectorY, vectorZ as columns 0,1,2, with weight0.
     * * origin as column3, with weight 1
     */
    setOriginAndVectors(origin, vectorX, vectorY, vectorZ) {
        this._coffs[0] = vectorX.x;
        this._coffs[1] = vectorY.x;
        this._coffs[2] = vectorZ.x;
        this._coffs[3] = origin.x;
        this._coffs[4] = vectorX.y;
        this._coffs[5] = vectorY.y;
        this._coffs[6] = vectorZ.y;
        this._coffs[7] = origin.y;
        this._coffs[8] = vectorX.z;
        this._coffs[9] = vectorY.z;
        this._coffs[10] = vectorZ.z;
        this._coffs[11] = origin.z;
        this._coffs[12] = 0.0;
        this._coffs[13] = 0.0;
        this._coffs[14] = 0.0;
        this._coffs[15] = 1.0;
    }
    /** promote a transform to full Matrix4d (with 0001 in final row) */
    static createTransform(source, result) {
        const matrix = source.matrix;
        const point = source.origin;
        return Matrix4d.createRowValues(matrix.coffs[0], matrix.coffs[1], matrix.coffs[2], point.x, matrix.coffs[3], matrix.coffs[4], matrix.coffs[5], point.y, matrix.coffs[6], matrix.coffs[7], matrix.coffs[8], point.z, 0, 0, 0, 1, result);
    }
    /** return an identity matrix. */
    static createIdentity(result) {
        result = Matrix4d.createZero(result);
        result._coffs[0] = 1.0;
        result._coffs[5] = 1.0;
        result._coffs[10] = 1.0;
        result._coffs[15] = 1.0;
        return result;
    }
    /** return matrix with translation directly inserted (along with 1 on diagonal) */
    static createTranslationXYZ(x, y, z, result) {
        result = Matrix4d.createZero(result);
        result._coffs[0] = 1.0;
        result._coffs[5] = 1.0;
        result._coffs[10] = 1.0;
        result._coffs[15] = 1.0;
        result._coffs[3] = x;
        result._coffs[7] = y;
        result._coffs[11] = z;
        return result;
    }
    /** return this matrix plus scale times matrixB. */
    plusScaled(matrixB, scale, result) {
        // If result is undefined, a real clone is created.
        // If result is "this" we get the pointer to this right back.
        // If result is other, "this" coffs are copied.
        // Then we can add matrixB.  (Which we assume is different from this?)
        result = this.clone(result);
        for (let i = 0; i < 16; i++)
            result._coffs[i] += scale * matrixB._coffs[i];
        return result;
    }
    /**
     * Create a Matrix4d with translation and scaling values directly inserted (along with 1 as final diagonal entry)
     * @param tx x entry for translation column
     * @param ty y entry for translation column
     * @param tz z entry for translation column
     * @param scaleX x diagonal entry
     * @param scaleY y diagonal entry
     * @param scaleZ z diagonal entry
     * @param result optional result.
     */
    static createTranslationAndScaleXYZ(tx, ty, tz, scaleX, scaleY, scaleZ, result) {
        return Matrix4d.createRowValues(scaleX, 0, 0, tx, 0, scaleY, 0, ty, 0, 0, scaleZ, tz, 0, 0, 0, 1, result);
    }
    /**
     * Create a mapping the scales and translates (no rotation) from box A to boxB
     * @param lowA low point of box A
     * @param highA high point of box A
     * @param lowB low point of box B
     * @param highB high point of box B
     */
    static createBoxToBox(lowA, highA, lowB, highB, result) {
        const ax = highA.x - lowA.x;
        const ay = highA.y - lowA.y;
        const az = highA.z - lowA.z;
        const bx = highB.x - lowB.x;
        const by = highB.y - lowB.y;
        const bz = highB.z - lowB.z;
        const abx = Geometry_1.Geometry.conditionalDivideFraction(bx, ax);
        const aby = Geometry_1.Geometry.conditionalDivideFraction(by, ay);
        const abz = Geometry_1.Geometry.conditionalDivideFraction(bz, az);
        if (abx !== undefined && aby !== undefined && abz !== undefined) {
            return Matrix4d.createTranslationAndScaleXYZ(lowB.x - abx * lowA.x, lowB.y - aby * lowA.y, lowB.z - abz * lowA.z, abx, aby, abz, result);
        }
        return undefined;
    }
    /** Set from nested array json e.g. `[[1,2,3,4],[0,1,2,4],[0,2,5,1],[0,0,1,2]]` */
    setFromJSON(json) {
        if (Geometry_1.Geometry.isArrayOfNumberArray(json, 4, 4))
            for (let i = 0; i < 4; ++i) {
                for (let j = 0; j < 4; ++j)
                    this._coffs[i * 4 + j] = json[i][j];
            }
        else
            this.setZero();
    }
    /**
     * Return the largest (absolute) difference between this and other Matrix4d.
     * @param other matrix to compare to
     */
    maxDiff(other) {
        let a = 0.0;
        for (let i = 0; i < 16; i++)
            a = Math.max(a, Math.abs(this._coffs[i] - other._coffs[i]));
        return a;
    }
    /**
     * Return the largest absolute value in the Matrix4d
     */
    maxAbs() {
        let a = 0.0;
        for (let i = 0; i < 16; i++)
            a = Math.max(a, Math.abs(this._coffs[i]));
        return a;
    }
    /** Test for near-equality with `other` */
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSmallMetricDistance(this.maxDiff(other));
    }
    /**
     * Convert an Matrix4d to a Matrix4dProps.
     */
    toJSON() {
        const value = [];
        for (let i = 0; i < 4; ++i) {
            const row = i * 4;
            value.push([this._coffs[row], this._coffs[row + 1], this._coffs[row + 2], this._coffs[row + 3]]);
        }
        return value;
    }
    /** Create from nested array json e.g. `[[1,2,3,4],[0,1,2,4],[0,2,5,1],[0,0,1,2]]` */
    static fromJSON(json) {
        const result = new Matrix4d();
        result.setFromJSON(json);
        return result;
    }
    /**
     * Return a point with entries from positions [i0, i0+step, i0+2*step, i0+3*step].
     * * There are no tests for index going out of the 0..15 range.
     * * Usual uses are:
     * * * i0 at left of row (0,4,8,12), step = 1 to extract a row.
     * * * i0 at top of row (0,1,2,3), step = 4 to extract a column
     * * * i0 = 0, step = 5 to extract the diagonal
     * @returns a Point4d with 4 entries taken from positions at steps in the flat 16-member array.
     * @param i0 start index (for 16 member array)
     * @param step step between members
     * @param result optional preallocated point.
     */
    getSteppedPoint(i0, step, result) {
        return Point4d_1.Point4d.create(this._coffs[i0], this._coffs[i0 + step], this._coffs[i0 + 2 * step], this._coffs[i0 + 3 * step], result);
    }
    /** Return column 0 as Point4d. */
    columnX() { return this.getSteppedPoint(0, 4); }
    /** Return column 1 as Point4d. */
    columnY() { return this.getSteppedPoint(1, 4); }
    /** Return column 2 as Point4d. */
    columnZ() { return this.getSteppedPoint(2, 4); }
    /** Return column 3 as Point4d. */
    columnW() { return this.getSteppedPoint(3, 4); }
    /** Return row 0 as Point4d. */
    rowX() { return this.getSteppedPoint(0, 1); }
    /** Return row 1 as Point4d. */
    rowY() { return this.getSteppedPoint(4, 1); }
    /** Return row 2 as Point4d. */
    rowZ() { return this.getSteppedPoint(8, 1); }
    /** Return row 3 as Point4d. */
    rowW() { return this.getSteppedPoint(12, 1); }
    /**
     * Returns true if the w row has content other than [0,0,0,1]
     */
    get hasPerspective() {
        return this._coffs[12] !== 0.0
            || this._coffs[13] !== 0.0
            || this._coffs[14] !== 0.0
            || this._coffs[15] !== 1.0;
    }
    /**
     * Return a Point4d with the diagonal entries of the matrix
     */
    diagonal() { return this.getSteppedPoint(0, 5); }
    /** return the weight component of this matrix */
    weight() { return this._coffs[15]; }
    /** return the leading 3x3 matrix part of this matrix */
    matrixPart() {
        return Matrix3d_1.Matrix3d.createRowValues(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[8], this._coffs[9], this._coffs[10]);
    }
    /**
     * Return the (affine, non-perspective) Transform with the upper 3 rows of this matrix
     * @return undefined if this Matrix4d has perspective effects in the w row.
     */
    get asTransform() {
        if (this.hasPerspective)
            return undefined;
        return Transform_1.Transform.createRowValues(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3], this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[7], this._coffs[8], this._coffs[9], this._coffs[10], this._coffs[11]);
    }
    /** multiply this * other. */
    multiplyMatrixMatrix(other, result) {
        result = (result && result !== this && result !== other) ? result : new Matrix4d();
        for (let i0 = 0; i0 < 16; i0 += 4) {
            for (let k = 0; k < 4; k++)
                result._coffs[i0 + k] =
                    this._coffs[i0] * other._coffs[k] +
                        this._coffs[i0 + 1] * other._coffs[k + 4] +
                        this._coffs[i0 + 2] * other._coffs[k + 8] +
                        this._coffs[i0 + 3] * other._coffs[k + 12];
        }
        return result;
    }
    /** multiply this * transpose(other). */
    multiplyMatrixMatrixTranspose(other, result) {
        result = (result && result !== this && result !== other) ? result : new Matrix4d();
        let j = 0;
        for (let i0 = 0; i0 < 16; i0 += 4) {
            for (let k = 0; k < 16; k += 4)
                result._coffs[j++] =
                    this._coffs[i0] * other._coffs[k] +
                        this._coffs[i0 + 1] * other._coffs[k + 1] +
                        this._coffs[i0 + 2] * other._coffs[k + 2] +
                        this._coffs[i0 + 3] * other._coffs[k + 3];
        }
        return result;
    }
    /** multiply transpose (this) * other. */
    multiplyMatrixTransposeMatrix(other, result) {
        result = (result && result !== this && result !== other) ? result : new Matrix4d();
        let j = 0;
        for (let i0 = 0; i0 < 4; i0 += 1) {
            for (let k0 = 0; k0 < 4; k0 += 1)
                result._coffs[j++] =
                    this._coffs[i0] * other._coffs[k0] +
                        this._coffs[i0 + 4] * other._coffs[k0 + 4] +
                        this._coffs[i0 + 8] * other._coffs[k0 + 8] +
                        this._coffs[i0 + 12] * other._coffs[k0 + 12];
        }
        return result;
    }
    /** Return a transposed matrix. */
    cloneTransposed(result) {
        return Matrix4d.createRowValues(this._coffs[0], this._coffs[4], this._coffs[8], this._coffs[12], this._coffs[1], this._coffs[5], this._coffs[9], this._coffs[13], this._coffs[2], this._coffs[6], this._coffs[10], this._coffs[14], this._coffs[3], this._coffs[7], this._coffs[11], this._coffs[15], result);
    }
    /** multiply matrix times column [x,y,z,w].  return as Point4d.   (And the returned value is NOT normalized down to unit w) */
    multiplyXYZW(x, y, z, w, result) {
        result = result ? result : Point4d_1.Point4d.createZero();
        return result.set(this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w, this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w, this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w, this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w);
    }
    /** multiply matrix times column vectors [x,y,z,w] where [x,y,z,w] appear in blocks in an array.
     * replace the xyzw in the block
     */
    multiplyBlockedFloat64ArrayInPlace(data) {
        const n = data.length;
        let x, y, z, w;
        for (let i = 0; i + 3 < n; i += 4) {
            x = data[i];
            y = data[i + 1];
            z = data[i + 2];
            w = data[i + 3];
            data[i] = this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w;
            data[i + 1] = this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w;
            data[i + 2] = this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w;
            data[i + 3] = this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w;
        }
    }
    /** multiply matrix times XYAndZ  and w. return as Point4d  (And the returned value is NOT normalized down to unit w) */
    multiplyPoint3d(pt, w, result) {
        return this.multiplyXYZW(pt.x, pt.y, pt.z, w, result);
    }
    /** multiply matrix times and array  of XYAndZ. return as array of Point4d  (And the returned value is NOT normalized down to unit w) */
    multiplyPoint3dArray(pts, results, w = 1.0) {
        pts.forEach((pt, i) => { results[i] = this.multiplyXYZW(pt.x, pt.y, pt.z, w, results[i]); });
    }
    /** multiply [x,y,z,w] times matrix.  return as Point4d.   (And the returned value is NOT normalized down to unit w) */
    multiplyTransposeXYZW(x, y, z, w, result) {
        result = result ? result : Point4d_1.Point4d.createZero();
        return result.set(this._coffs[0] * x + this._coffs[4] * y + this._coffs[8] * z + this._coffs[12] * w, this._coffs[1] * x + this._coffs[5] * y + this._coffs[9] * z + this._coffs[13] * w, this._coffs[2] * x + this._coffs[6] * y + this._coffs[10] * z + this._coffs[14] * w, this._coffs[3] * x + this._coffs[7] * y + this._coffs[11] * z + this._coffs[15] * w);
    }
    /** Returns dot product of row rowIndex of this with column columnIndex of other.
     */
    rowDotColumn(rowIndex, other, columnIndex) {
        const i = rowIndex * 4;
        const j = columnIndex;
        return this._coffs[i] * other._coffs[j]
            + this._coffs[i + 1] * other._coffs[j + 4]
            + this._coffs[i + 2] * other._coffs[j + 8]
            + this._coffs[i + 3] * other._coffs[j + 12];
    }
    /** Returns dot product of row rowIndexThis of this with row rowIndexOther of other.
     */
    rowDotRow(rowIndexThis, other, rowIndexOther) {
        const i = rowIndexThis * 4;
        const j = rowIndexOther * 4;
        return this._coffs[i] * other._coffs[j]
            + this._coffs[i + 1] * other._coffs[j + 1]
            + this._coffs[i + 2] * other._coffs[j + 2]
            + this._coffs[i + 3] * other._coffs[j + 3];
    }
    /** Returns dot product of row rowIndexThis of this with row rowIndexOther of other.
     */
    columnDotColumn(columnIndexThis, other, columnIndexOther) {
        const i = columnIndexThis;
        const j = columnIndexOther;
        return this._coffs[i] * other._coffs[j]
            + this._coffs[i + 4] * other._coffs[j + 4]
            + this._coffs[i + 8] * other._coffs[j + 8]
            + this._coffs[i + 12] * other._coffs[j + 12];
    }
    /** Returns dot product of column columnIndexThis of this with row rowIndexOther other.
     */
    columnDotRow(columnIndexThis, other, rowIndexOther) {
        const i = columnIndexThis;
        const j = 4 * rowIndexOther;
        return this._coffs[i] * other._coffs[j]
            + this._coffs[i + 4] * other._coffs[j + 1]
            + this._coffs[i + 8] * other._coffs[j + 2]
            + this._coffs[i + 12] * other._coffs[j + 3];
    }
    /** Return a matrix entry by row and column index.
     */
    atIJ(rowIndex, columnIndex) {
        return this._coffs[rowIndex * 4 + columnIndex];
    }
    /** Set a matrix entry by row and column index.
     */
    setAtIJ(rowIndex, columnIndex, value) {
        this._coffs[rowIndex * 4 + columnIndex] = value;
    }
    /** multiply matrix * [x,y,z,w]. immediately renormalize to return in a Point3d.
     * If zero weight appears in the result (i.e. input is on eyeplane) leave the mapped xyz untouched.
     */
    multiplyXYZWQuietRenormalize(x, y, z, w, result) {
        result = result ? result : Point3dVector3d_1.Point3d.createZero();
        result.set(this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w, this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w, this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w);
        const w1 = this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w;
        const qx = Geometry_1.Geometry.conditionalDivideCoordinate(result.x, w1);
        const qy = Geometry_1.Geometry.conditionalDivideCoordinate(result.y, w1);
        const qz = Geometry_1.Geometry.conditionalDivideCoordinate(result.z, w1);
        if (qx !== undefined && qy !== undefined && qz !== undefined) {
            result.x = qx;
            result.y = qy;
            result.z = qz;
        }
        return result;
    }
    /** multiply matrix * an array of Point4d. immediately renormalize to return in an array of Point3d. */
    multiplyPoint4dArrayQuietRenormalize(pts, results) {
        pts.forEach((pt, i) => { results[i] = this.multiplyXYZWQuietRenormalize(pt.x, pt.y, pt.z, pt.w, results[i]); });
    }
    /** multiply a Point4d, return with the optional result convention. */
    multiplyPoint4d(point, result) {
        return this.multiplyXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);
    }
    /** multiply a Point4d, return with the optional result convention. */
    multiplyTransposePoint4d(point, result) {
        return this.multiplyTransposeXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);
    }
    /** multiply matrix * point. This produces a weighted xyzw.
     * Immediately renormalize back to xyz and return (with optional result convention).
     * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.
     */
    multiplyPoint3dQuietNormalize(point, result) {
        return this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, result);
    }
    /** multiply each matrix * points[i].   This produces a weighted xyzw.
     * Immediately renormalize back to xyz and replace the original point.
     * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.
     */
    multiplyPoint3dArrayQuietNormalize(points) {
        points.forEach((point) => this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, point));
    }
    /**
     * Add the product terms [xx,xy,xz,xw, yx, yy, yz, yw, zx, zy, zz, zs, wx, wy, wz, ww] to respective entries in the matrix
     * @param x x component for products
     * @param y y component for products
     * @param z z component for products
     * @param w w component for products
     */
    addMomentsInPlace(x, y, z, w) {
        this._coffs[0] += x * x;
        this._coffs[1] += x * y;
        this._coffs[2] += x * z;
        this._coffs[3] += x * w;
        this._coffs[4] += y * x;
        this._coffs[5] += y * y;
        this._coffs[6] += y * z;
        this._coffs[7] += y * w;
        this._coffs[8] += z * x;
        this._coffs[9] += z * y;
        this._coffs[10] += z * z;
        this._coffs[11] += z * w;
        this._coffs[12] += w * x;
        this._coffs[13] += w * y;
        this._coffs[14] += w * z;
        this._coffs[15] += w * w;
    }
    /** accumulate all coefficients of other to this. */
    addScaledInPlace(other, scale = 1.0) {
        for (let i = 0; i < 16; i++)
            this._coffs[i] += scale * other._coffs[i];
    }
    /**
     * Add scale times rowA to rowB.
     * @param rowIndexA row that is not modified
     * @param rowIndexB row that is modified.
     * @param firstColumnIndex first column modified.  All from there to the right are updated
     * @param scale scale
     */
    rowOperation(rowIndexA, rowIndexB, firstColumnIndex, scale) {
        if (scale === 0.0)
            return;
        let iA = rowIndexA * 4 + firstColumnIndex;
        let iB = rowIndexB * 4 + firstColumnIndex;
        for (let i = firstColumnIndex; i < 4; i++, iA++, iB++)
            this._coffs[iB] += scale * this._coffs[iA];
    }
    /** Return the determinant of the matrix. */
    determinant() {
        const c = this._coffs;
        return Geometry_1.Geometry.determinant4x4(c[0], c[1], c[2], c[3], c[4], c[5], c[6], c[7], c[8], c[9], c[10], c[11], c[12], c[13], c[14], c[15]);
    }
    /** Compute an inverse matrix.
     * * This uses direct formulas with various determinants.
     * * If result is given, it is ALWAYS filled with values "prior to dividing by the determinant".
     * *
     * @returns undefined if dividing by the determinant looks unsafe.
     */
    createInverse(result) {
        const maxAbs0 = this.maxAbs();
        if (maxAbs0 === 0.0)
            return undefined;
        const divMaxAbs = 1.0 / maxAbs0;
        const columnA = this.columnX();
        const columnB = this.columnY();
        const columnC = this.columnZ();
        const columnD = this.columnW();
        columnA.scale(divMaxAbs, columnA);
        columnB.scale(divMaxAbs, columnB);
        columnC.scale(divMaxAbs, columnC);
        columnD.scale(divMaxAbs, columnD);
        const rowBCD = Point4d_1.Point4d.perpendicularPoint4dPlane(columnB, columnC, columnD);
        const rowCDA = Point4d_1.Point4d.perpendicularPoint4dPlane(columnA, columnD, columnC); // order for negation !
        const rowDAB = Point4d_1.Point4d.perpendicularPoint4dPlane(columnD, columnA, columnB);
        const rowABC = Point4d_1.Point4d.perpendicularPoint4dPlane(columnC, columnB, columnA); // order for negation !
        // The matrix is singular if the determinant is zero.
        // But what is the proper tolerance for zero?
        // The row values are generally cubes of entries. And the typical perspective matrix
        //    has very different magnitudes in various parts.  So a typical cube size is really hard.
        // Compute 4 different determinants.  They should match.
        // If they are near zero, maybe a sign change is a red flag for singular case.
        // (And there's a lot less work to do that than was done to make the rows)
        result = Matrix4d.createRows(rowBCD, rowCDA, rowDAB, rowABC, result);
        const determinantA = rowBCD.dotProduct(columnA);
        const determinantB = rowCDA.dotProduct(columnB);
        const determinantC = rowDAB.dotProduct(columnC);
        const determinantD = rowABC.dotProduct(columnD);
        const maxAbs1 = result.maxAbs();
        if (determinantA * determinantB > 0.0
            && determinantA * determinantC > 0.0
            && determinantA * determinantD > 0.0) {
            const divisionTest = Geometry_1.Geometry.conditionalDivideCoordinate(maxAbs1, determinantA);
            if (divisionTest !== undefined) {
                const b = divMaxAbs / determinantA;
                result.scaleRowsInPlace(b, b, b, b);
                return result;
            }
        }
        else {
            return undefined; // this is a useful spot to break to see if the 4 determinant test is effective.
        }
        return undefined;
    }
    /** Returns an array-of-arrays of the matrix rows, optionally passing each value through a function.
     * @param f optional function to provide alternate values for each entry (e.g. force fuzz to zero.)
     */
    rowArrays(f) {
        if (f)
            return [
                [f(this._coffs[0]), f(this._coffs[1]), f(this._coffs[2]), f(this._coffs[3])],
                [f(this._coffs[4]), f(this._coffs[5]), f(this._coffs[6]), f(this._coffs[7])],
                [f(this._coffs[8]), f(this._coffs[9]), f(this._coffs[10]), f(this._coffs[11])],
                [f(this._coffs[12]), f(this._coffs[13]), f(this._coffs[14]), f(this._coffs[15])]
            ];
        else
            return [
                [this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3]],
                [this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[7]],
                [this._coffs[8], this._coffs[9], this._coffs[10], this._coffs[11]],
                [this._coffs[12], this._coffs[13], this._coffs[14], this._coffs[15]]
            ];
    }
    /**
     * Scale each row by respective scale factors.
     * @param ax scale factor for row 0
     * @param ay scale factor for row 1
     * @param az scale factor for row 2
     * @param aw scale factor for row 3
     */
    scaleRowsInPlace(ax, ay, az, aw) {
        for (let i = 0; i < 4; i++)
            this._coffs[i] *= ax;
        for (let i = 4; i < 8; i++)
            this._coffs[i] *= ay;
        for (let i = 8; i < 12; i++)
            this._coffs[i] *= az;
        for (let i = 12; i < 16; i++)
            this._coffs[i] *= aw;
    }
    /**
     * add an outer product (single column times single row times scale factor) to this matrix.
     * @param vectorU column vector
     * @param vectorV row vector
     * @param scale scale factor
     */
    addScaledOuterProductInPlace(vectorU, vectorV, scale) {
        let a = vectorU.x * scale;
        this._coffs[0] += a * vectorV.x;
        this._coffs[1] += a * vectorV.y;
        this._coffs[2] += a * vectorV.z;
        this._coffs[3] += a * vectorV.w;
        a = vectorU.y * scale;
        this._coffs[4] += a * vectorV.x;
        this._coffs[5] += a * vectorV.y;
        this._coffs[6] += a * vectorV.z;
        this._coffs[7] += a * vectorV.w;
        a = vectorU.z * scale;
        this._coffs[8] += a * vectorV.x;
        this._coffs[9] += a * vectorV.y;
        this._coffs[10] += a * vectorV.z;
        this._coffs[11] += a * vectorV.w;
        a = vectorU.w * scale;
        this._coffs[12] += a * vectorV.x;
        this._coffs[13] += a * vectorV.y;
        this._coffs[14] += a * vectorV.z;
        this._coffs[15] += a * vectorV.w;
    }
    /**
     * ADD (n place) scale*A*B*AT where
     * * A is a pure translation with final column [x,y,z,1]
     * * B is the given `matrixB`
     * * AT is the transpose of A.
     * * scale is a multiplier.
     * @param matrixB the middle matrix.
     * @param ax x part of translation
     * @param ay y part of translation
     * @param az z part of translation
     * @param scale scale factor for entire product
     */
    addTranslationSandwichInPlace(matrixB, ax, ay, az, scale) {
        const bx = matrixB._coffs[3];
        const by = matrixB._coffs[7];
        const bz = matrixB._coffs[11];
        // matrixB can be non-symmetric!!
        const cx = matrixB._coffs[12];
        const cy = matrixB._coffs[13];
        const cz = matrixB._coffs[14];
        const beta = matrixB._coffs[15];
        const axBeta = ax * beta;
        const ayBeta = ay * beta;
        const azBeta = az * beta;
        this._coffs[0] += scale * (matrixB._coffs[0] + ax * bx + cx * ax + ax * axBeta);
        this._coffs[1] += scale * (matrixB._coffs[1] + ay * bx + cy * ax + ax * ayBeta);
        this._coffs[2] += scale * (matrixB._coffs[2] + az * bx + cz * ax + ax * azBeta);
        this._coffs[3] += scale * (bx + axBeta);
        this._coffs[4] += scale * (matrixB._coffs[4] + ax * by + cx * ay + ay * axBeta);
        this._coffs[5] += scale * (matrixB._coffs[5] + ay * by + cy * ay + ay * ayBeta);
        this._coffs[6] += scale * (matrixB._coffs[6] + az * by + cz * ay + ay * azBeta);
        this._coffs[7] += scale * (by + ayBeta);
        this._coffs[8] += scale * (matrixB._coffs[8] + ax * bz + cx * az + az * axBeta);
        this._coffs[9] += scale * (matrixB._coffs[9] + ay * bz + cy * az + az * ayBeta);
        this._coffs[10] += scale * (matrixB._coffs[10] + az * bz + cz * az + az * azBeta);
        this._coffs[11] += scale * (bz + azBeta);
        this._coffs[12] += scale * (cx + axBeta);
        this._coffs[13] += scale * (cy + ayBeta);
        this._coffs[14] += scale * (cz + azBeta);
        this._coffs[15] += scale * beta;
    }
    /**
     * Multiply and replace contents of this matrix by A*this*AT where
     * * A is a pure translation with final column [x,y,z,1]
     * * this is this matrix.
     * * AT is the transpose of A.
     * * scale is a multiplier.
     * @param matrixB the middle matrix.
     * @param ax x part of translation
     * @param ay y part of translation
     * @param az z part of translation
     * @param scale scale factor for entire product
     */
    multiplyTranslationSandwichInPlace(ax, ay, az) {
        const bx = this._coffs[3];
        const by = this._coffs[7];
        const bz = this._coffs[11];
        // matrixB can be non-symmetric!!
        const cx = this._coffs[12];
        const cy = this._coffs[13];
        const cz = this._coffs[14];
        const beta = this._coffs[15];
        const axBeta = ax * beta;
        const ayBeta = ay * beta;
        const azBeta = az * beta;
        this._coffs[0] += (ax * bx + cx * ax + ax * axBeta);
        this._coffs[1] += (ay * bx + cy * ax + ax * ayBeta);
        this._coffs[2] += (az * bx + cz * ax + ax * azBeta);
        this._coffs[3] += axBeta;
        this._coffs[4] += (ax * by + cx * ay + ay * axBeta);
        this._coffs[5] += (ay * by + cy * ay + ay * ayBeta);
        this._coffs[6] += (az * by + cz * ay + ay * azBeta);
        this._coffs[7] += ayBeta;
        this._coffs[8] += (ax * bz + cx * az + az * axBeta);
        this._coffs[9] += (ay * bz + cy * az + az * ayBeta);
        this._coffs[10] += (az * bz + cz * az + az * azBeta);
        this._coffs[11] += azBeta;
        this._coffs[12] += axBeta;
        this._coffs[13] += ayBeta;
        this._coffs[14] += azBeta;
        // coffs[15] is unchanged !!!
    }
}
exports.Matrix4d = Matrix4d;


/***/ }),

/***/ "./lib/geometry4d/MomentData.js":
/*!**************************************!*\
  !*** ./lib/geometry4d/MomentData.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty no-console*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Matrix4d_1 = __webpack_require__(/*! ./Matrix4d */ "./lib/geometry4d/Matrix4d.js");
const Point4d_1 = __webpack_require__(/*! ./Point4d */ "./lib/geometry4d/Point4d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * A MomentData structure carries data used in calculation of moments of inertia.
 * * origin = local origin used as moments are summed.
 * * sums = array of summed moments.
 *   * The [i,j] entry of the sums is a summed or integrated moment for product of axis i and j.
 *      * axes 0,1,2 are x,y,z
 *         * e.g. entry [0,1] is summed product xy
 *      * axis 3 is "w", which is 1 in sums.
 *         * e.g. entry 03 is summed x
 * @public
 */
class MomentData {
    constructor() {
        this._point0 = Point3dVector3d_1.Point3d.create();
        this._point1 = Point3dVector3d_1.Point3d.create();
        this.origin = Point3dVector3d_1.Point3d.createZero();
        this.sums = Matrix4d_1.Matrix4d.createZero();
        this.localToWorldMap = Transform_1.Transform.createIdentity();
        this.radiusOfGyration = Point3dVector3d_1.Vector3d.create();
        this.needOrigin = false;
    }
    /** Return the lower-right (3,3) entry in the sums.
     * * This is the quantity (i.e. length, area, or volume) summed
     */
    get quantitySum() { return this.sums.atIJ(3, 3); }
    /** Return a scale factor to make these sums match the target orientation sign.
     * * 1.0 if `this.quantitySum` has the same sign as `targetSign`.
     * * -1.0 if `this.quantitySum` has the opposite sign from `targetSign`
     */
    signFactor(targetSign) {
        return targetSign * this.quantitySum > 0 ? 1.0 : -1.0;
    }
    /**
     *  If `this.needOrigin` flag is set, copy `origin` to `this.origin` and clear the flag.
     *
     */
    setOriginIfNeeded(origin) {
        if (this.needOrigin) {
            this.origin.setFromPoint3d(origin);
            this.needOrigin = false;
        }
    }
    /**
     *  If `this.needOrigin` flag is set, copy `origin` to `this.origin` and clear the flag.
     *
     */
    setOriginFromGrowableXYZArrayIfNeeded(points) {
        if (this.needOrigin && points.length > 0) {
            points.getPoint3dAtCheckedPointIndex(0, this.origin);
            this.needOrigin = false;
        }
    }
    /**
     *  If `this.needOrigin` flag is set, copy `origin` to `this.origin` and clear the flag.
     *
     */
    setOriginXYZIfNeeded(x, y, z) {
        if (this.needOrigin) {
            this.origin.set(x, y, z);
            this.needOrigin = false;
        }
    }
    /** Create moments with optional origin.
     * * origin and needOrigin are quirky.
     *   * (undefined, true) sets up to use first incoming point as origin.
     *   * (origin) sets up to use that durable origin, set needsOrigin flag false
     *   * (origin, true) the "true" is meaningless
     *   * (undefined, false) makes 000 the durable origin
    */
    static create(origin, needOrigin = false) {
        const data = new MomentData();
        data.needOrigin = needOrigin;
        if (origin) {
            data.origin.setFromPoint3d(origin);
            data.needOrigin = false;
        }
        return data;
    }
    /**
     * Return the formal tensor of integrated values `[yy+zz,xy,xz][yx,xx+zz,yz][zx,xy,xx+yy]`
     * @param products matrix of (integrated) `[xx,xy,xz][yx,yy,yz][zx,xy,zz]`
     */
    static momentTensorFromInertiaProducts(products) {
        const rr = products.sumDiagonal();
        const result = Matrix3d_1.Matrix3d.createScale(rr, rr, rr);
        result.addScaledInPlace(products, -1.0);
        return result;
    }
    /** Sort the columns of the matrix for increasing moments. */
    static sortColumnsForIncreasingMoments(axes, moments) {
        const points = [
            axes.indexedColumnWithWeight(0, moments.x),
            axes.indexedColumnWithWeight(1, moments.y),
            axes.indexedColumnWithWeight(2, moments.z)
        ].sort((dataA, dataB) => {
            if (dataA.w < dataB.w)
                return -1;
            if (dataA.w > dataB.w)
                return 1;
            return 0;
        });
        axes.setColumnsPoint4dXYZ(points[0], points[1], points[2]);
        if (axes.determinant() < 0)
            axes.scaleColumnsInPlace(-1.0, -1.0, -1.0);
        // prefer x and z positive -- y falls wherever . ..
        if (axes.at(0, 0) < 0.0)
            axes.scaleColumnsInPlace(-1.0, -1.0, 1.0);
        if (axes.at(2, 2) < 0.0)
            axes.scaleColumnsInPlace(1.0, -1.0, -1.0);
        moments.set(points[0].w, points[1].w, points[2].w);
    }
    /**
     * Return the principal moment data for an array of points.
     * @param points array of points
     */
    static pointsToPrincipalAxes(points) {
        const moments = new MomentData();
        if (points.length === 0)
            return moments;
        moments.clearSums(points[0]);
        moments.accumulatePointMomentsFromOrigin(points);
        return this.inertiaProductsToPrincipalAxes(moments.origin, moments.sums);
    }
    /**
     * Compute principal axes from inertial products
     * * The radii of gyration are sorted smallest to largest
     * * Hence x axis is long direction
     * * Hence planar data generates large moment as Z
     * @param origin The origin used for the inertia products.
     * @param inertiaProducts The inertia products -- sums or integrals of [xx,xy,xz,xw; yx,yy, yz,yw; zx,zy,zz,zw; wx,wy,wz,w]
     */
    static inertiaProductsToPrincipalAxes(origin, inertiaProducts) {
        const moments = new MomentData();
        moments.sums.setFrom(inertiaProducts);
        moments.origin.setFrom(origin);
        if (!moments.shiftOriginAndSumsToCentroidOfSums())
            return undefined;
        const products = moments.sums.matrixPart();
        const tensor = MomentData.momentTensorFromInertiaProducts(products);
        const moment2 = Point3dVector3d_1.Vector3d.create();
        const axisVectors = Matrix3d_1.Matrix3d.createZero();
        tensor.fastSymmetricEigenvalues(axisVectors, moment2);
        MomentData.sortColumnsForIncreasingMoments(axisVectors, moment2);
        moments.localToWorldMap = Transform_1.Transform.createOriginAndMatrix(moments.origin, axisVectors);
        moments.radiusOfGyration.set(Math.sqrt(moment2.x), Math.sqrt(moment2.y), Math.sqrt(moment2.z));
        moments.radiusOfGyration.scaleInPlace(1.0 / Math.sqrt(moments.sums.weight()));
        return moments;
    }
    /**
     * Test for match among selected members as they exist after `inertiaProductsToPrincipalAxes`
     * * The members considered are
     *   * origin of local to world map (i.e. centroid)
     *   * radius of gyration
     *   * axes of localToWorldMap.
     * * Axis direction tests allow these quirks:
     *   * opposite orientation is considered matched.
     * * Full xyz symmetry: If x,y,z radii are matched, axes are not tested.
     * * Symmetry in xy plane: If x and y radii are matched, the x and y axes area allowed to spin freely.  Only Z direction is tested.
     * * If either or both are undefined, returns false.
     * @param dataA first set of moments
     * @param dataB second set of moments
     */
    static areEquivalentPrincipalAxes(dataA, dataB) {
        if (dataA && dataB
            && Geometry_1.Geometry.isSameCoordinate(dataA.quantitySum, dataB.quantitySum)) { // um.. need different tolerance for area, volume?)
            if (dataA.localToWorldMap.getOrigin().isAlmostEqual(dataB.localToWorldMap.getOrigin())
                && dataA.radiusOfGyration.isAlmostEqual(dataB.radiusOfGyration)) {
                if (Geometry_1.Geometry.isSameCoordinate(dataA.radiusOfGyration.x, dataA.radiusOfGyration.y)) {
                    // We have at least xy symmetry ....
                    if (Geometry_1.Geometry.isSameCoordinate(dataA.radiusOfGyration.x, dataA.radiusOfGyration.z))
                        return true;
                    // just xy.
                    // allow opposite z directions.
                    // If the z's are aligned, x an dy can spin freely.
                    const zA = dataA.localToWorldMap.matrix.columnZ();
                    const zB = dataB.localToWorldMap.matrix.columnZ();
                    if (zA.isParallelTo(zB, true))
                        return true;
                    return false;
                }
                // no symmetry.  Test all three axes.
                const vectorA = Point3dVector3d_1.Vector3d.create();
                const vectorB = Point3dVector3d_1.Vector3d.create();
                for (let i = 0; i < 3; i++) {
                    dataA.localToWorldMap.matrix.getColumn(i, vectorA);
                    dataB.localToWorldMap.matrix.getColumn(i, vectorB);
                    if (!vectorA.isParallelTo(vectorB, true))
                        return false;
                }
                return true;
            }
        }
        return false;
    }
    /** Clear the MomentData sums to zero, and establish a new origin. */
    clearSums(origin) {
        this.sums.setZero();
        if (origin)
            this.origin.setFrom(origin);
        else
            this.origin.setZero();
    }
    /** Accumulate products-of-components for given points. */
    accumulatePointMomentsFromOrigin(points) {
        for (const p of points) {
            this.sums.addMomentsInPlace(p.x - this.origin.x, p.y - this.origin.y, p.z - this.origin.z, 1.0);
        }
    }
    /** revise the accumulated sums to be "around the centroid" */
    shiftOriginAndSumsToCentroidOfSums() {
        const xyz = this.sums.columnW().realPoint();
        if (xyz) {
            this.shiftOriginAndSumsByXYZ(xyz.x, xyz.y, xyz.z);
            return true;
        }
        return false;
    }
    /** revise the accumulated sums
     * * add ax,ay,ax to the origin coordinates.
     * * apply the negative translation to the sums.
    */
    shiftOriginAndSumsByXYZ(ax, ay, az) {
        this.origin.addXYZInPlace(ax, ay, az);
        this.sums.multiplyTranslationSandwichInPlace(-ax, -ay, -az);
    }
    /** revise the accumulated sums so they are based at a specified origin. */
    shiftOriginAndSumsToNewOrigin(newOrigin) {
        this.shiftOriginAndSumsByXYZ(newOrigin.x - this.origin.x, newOrigin.y - this.origin.y, newOrigin.z - this.origin.z);
    }
    /** compute moments of a triangle from the origin to the given line.
     * Accumulate them to this.sums.
     * * If `pointA` is undefined, use `this.origin` as pointA.
     * * If `this.needOrigin` is set, pointB is used
    */
    accumulateTriangleMomentsXY(pointA, pointB, pointC) {
        this.setOriginXYZIfNeeded(pointB.x, pointB.y, 0.0);
        const x0 = this.origin.x;
        const y0 = this.origin.y;
        const vectorA = MomentData._vectorA =
            pointA !== undefined ? Point4d_1.Point4d.create(pointA.x - x0, pointA.y - y0, 0.0, 1.0, MomentData._vectorA)
                : Point4d_1.Point4d.create(this.origin.x, this.origin.y, 0.0, 1.0, MomentData._vectorA);
        const vectorB = MomentData._vectorB = Point4d_1.Point4d.create(pointB.x - x0, pointB.y - y0, 0.0, 1.0, MomentData._vectorB);
        const vectorC = MomentData._vectorC = Point4d_1.Point4d.create(pointC.x - x0, pointC.y - y0, 0.0, 1.0, MomentData._vectorC);
        // accumulate Return product integrals I(0<=u<=1) I (0<=v<= u)  (w*W + u *U + v * V)(w*W + u *U + v * V)^  du dv
        //  where w = 1-u-v
        //  W = column vector (point00.x, point00.y, point00.z, 1.0) etc.
        const detJ = Geometry_1.Geometry.crossProductXYXY(vectorB.x - vectorA.x, vectorB.y - vectorA.y, vectorC.x - vectorA.x, vectorC.y - vectorA.y);
        if (detJ !== 0.0) {
            const r1_12 = detJ / 12.0;
            const r1_24 = detJ / 24.0;
            this.sums.addScaledOuterProductInPlace(vectorA, vectorA, r1_12);
            this.sums.addScaledOuterProductInPlace(vectorA, vectorB, r1_24);
            this.sums.addScaledOuterProductInPlace(vectorA, vectorC, r1_24);
            this.sums.addScaledOuterProductInPlace(vectorB, vectorA, r1_24);
            this.sums.addScaledOuterProductInPlace(vectorB, vectorB, r1_12);
            this.sums.addScaledOuterProductInPlace(vectorB, vectorC, r1_24);
            this.sums.addScaledOuterProductInPlace(vectorC, vectorA, r1_24);
            this.sums.addScaledOuterProductInPlace(vectorC, vectorB, r1_24);
            this.sums.addScaledOuterProductInPlace(vectorC, vectorC, r1_12);
        }
    }
    /** add scaled outer product of (4d, unit weight) point to this.sums */
    accumulateScaledOuterProduct(point, scaleFactor) {
        this.setOriginXYZIfNeeded(point.x, point.y, 0.0);
        const vectorA = MomentData._vectorA = Point4d_1.Point4d.create(point.x - this.origin.x, point.y - this.origin.y, point.z - this.origin.z, 1.0, MomentData._vectorA);
        this.sums.addScaledOuterProductInPlace(vectorA, vectorA, scaleFactor);
    }
    /** Accumulate wire moment integral from pointA to pointB */
    accumulateLineMomentsXYZ(pointA, pointB) {
        this.setOriginXYZIfNeeded(pointA.x, pointA.y, pointA.z);
        const x0 = this.origin.x;
        const y0 = this.origin.y;
        const z0 = this.origin.z;
        const vectorA = MomentData._vectorA = Point4d_1.Point4d.create(pointA.x - x0, pointA.y - y0, pointA.z - z0, 1.0, MomentData._vectorA);
        const vectorB = MomentData._vectorB = Point4d_1.Point4d.create(pointB.x - x0, pointB.y - y0, pointB.z - z0, 1.0, MomentData._vectorB);
        const detJ = pointA.distance(pointB);
        const r1_3 = detJ / 3.0;
        const r1_6 = detJ / 6.0;
        this.sums.addScaledOuterProductInPlace(vectorA, vectorA, r1_3);
        this.sums.addScaledOuterProductInPlace(vectorA, vectorB, r1_6);
        this.sums.addScaledOuterProductInPlace(vectorB, vectorA, r1_6);
        this.sums.addScaledOuterProductInPlace(vectorB, vectorB, r1_3);
    }
    /** compute moments of triangles from a base point to the given linestring.
     * Accumulate them to this.sums.
     * * If `pointA` is undefined, use `this.origin` as pointA.
     * * If `this.needOrigin` is set, the first point of the array is captured as local origin for subsequent sums.
     *
     */
    accumulateTriangleToLineStringMomentsXY(sweepBase, points) {
        const n = points.length;
        if (n > 1) {
            points.getPoint3dAtUncheckedPointIndex(0, this._point0);
            for (let i = 1; i < n; i++) {
                points.getPoint3dAtUncheckedPointIndex(i, this._point1);
                this.accumulateTriangleMomentsXY(sweepBase, this._point0, this._point1);
                this._point0.setFromPoint3d(this._point1);
            }
        }
    }
    // cspell:word ABAT
    /**
     * * Assemble XX, YY, XY products into a full matrix form [xx,xy,0,0; xy,yy,0,0;0,0,0,0;0,0,0,1].
     * * Sandwich this between transforms with columns [vectorU, vectorV, 0000, origin].  (Column weights 0001) (only xy parts of vectors)
     * * scale by detJ for the xy-only determinant of the vectors.
     * @param productXX
     * @param productXY
     * @param productYY
     * @param area Area in caller's system
     * @param origin Caller's origin
     * @param vectorU Caller's U axis (not necessarily unit)
     * @param vectorV Caller's V axis (not necessarily unit)
     */
    accumulateXYProductsInCentroidalFrame(productXX, productXY, productYY, area, origin, vectorU, vectorV) {
        const centroidalProducts = Matrix4d_1.Matrix4d.createRowValues(productXX, productXY, 0, 0, productXY, productYY, 0, 0, 0, 0, 0, 0, 0, 0, 0, area);
        const detJ = Geometry_1.Geometry.crossProductXYXY(vectorU.x, vectorV.x, vectorU.y, vectorV.y);
        const placement = Matrix4d_1.Matrix4d.createRowValues(vectorU.x, vectorV.x, 0, origin.x - this.origin.x, vectorU.y, vectorV.y, 0, origin.y - this.origin.y, 0, 0, 0, 0, 0, 0, 0, 1);
        const AB = placement.multiplyMatrixMatrix(centroidalProducts);
        const ABAT = AB.multiplyMatrixMatrixTranspose(placement);
        this.sums.addScaledInPlace(ABAT, detJ);
    }
    /**
     * Accumulate sums from other moments.
     * * scale by given scaleFactor (e.g. sign to correct orientation)
     * * pull the origin from `other` if `this` needs an origin.
     * *
     */
    accumulateProducts(other, scale) {
        this.setOriginIfNeeded(other.origin);
        this.sums.addTranslationSandwichInPlace(other.sums, this.origin.x - other.origin.x, this.origin.y - other.origin.y, this.origin.z - other.origin.z, scale);
    }
    /**
   * Accumulate sums from Matrix4d and origin.
   * * scale by given scaleFactor (e.g. sign to correct orientation)
   * * trap the origin if `this` needs an origin.
   * *
   */
    accumulateProductsFromOrigin(origin, products, scale) {
        this.setOriginIfNeeded(origin);
        this.sums.addTranslationSandwichInPlace(products, this.origin.x - origin.x, this.origin.y - origin.y, this.origin.z - origin.z, scale);
    }
    /**
     * Convert to a json data object with:
     */
    toJSON() {
        return {
            origin: this.origin,
            sums: this.sums.toJSON(),
            radiusOfGyration: this.radiusOfGyration.toJSON(),
            localToWorld: this.localToWorldMap.toJSON(),
        };
    }
}
exports.MomentData = MomentData;


/***/ }),

/***/ "./lib/geometry4d/PlaneByOriginAndVectors4d.js":
/*!*****************************************************!*\
  !*** ./lib/geometry4d/PlaneByOriginAndVectors4d.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point4d_1 = __webpack_require__(/*! ./Point4d */ "./lib/geometry4d/Point4d.js");
/**
 * A Plane4dByOriginAndVectors is a 4d origin and pair of 4d "vectors" defining a 4d plane.
 * * The parameterization of the plane is    `X = origin + vectorU*u + vectorV * v`
 * * With particular weight values `origin.w === 1, vectorU.w === 0, vectorV.w === 0` this is like `Plane3dByOriginAndVectors`
 * * With other weights, the deweighted xyz coordinates of points on the 4d plane still form a 3d plane.
 * @public
 */
class PlaneByOriginAndVectors4d {
    constructor(origin, vectorU, vectorV) {
        this.origin = origin;
        this.vectorU = vectorU;
        this.vectorV = vectorV;
    }
    /** Return a clone of this plane */
    clone(result) {
        if (result) {
            result.setFrom(this);
            return result;
        }
        return new PlaneByOriginAndVectors4d(this.origin.clone(), this.vectorU.clone(), this.vectorV.clone());
    }
    /** copy all content from other plane */
    setFrom(other) {
        this.origin.setFrom(other.origin);
        this.vectorU.setFrom(other.vectorU);
        this.vectorV.setFrom(other.vectorV);
    }
    /** Return true if origin, vectorU, and vectorV pass isAlmostEqual. */
    isAlmostEqual(other) {
        return this.origin.isAlmostEqual(other.origin)
            && this.vectorU.isAlmostEqual(other.vectorU)
            && this.vectorV.isAlmostEqual(other.vectorV);
    }
    /** Create a plane with (copies of) origin, vectorU, vectorV parameters, all given as full 4d points.
     */
    static createOriginAndVectors(origin, vectorU, vectorV, result) {
        if (result) {
            result.setOriginAndVectors(origin, vectorU, vectorV);
            return result;
        }
        return new PlaneByOriginAndVectors4d(origin.clone(), vectorU.clone(), vectorV.clone());
    }
    /** Set all numeric data from complete list of (x,y,z,w) in origin, vectorU, and vectorV */
    setOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw) {
        this.origin.set(x0, y0, z0, w0);
        this.vectorU.set(ux, uy, uz, uw);
        this.vectorV.set(vx, vy, vz, vw);
        return this;
    }
    /** Copy the contents of origin, vectorU, vectorV parameters to respective member variables */
    setOriginAndVectors(origin, vectorU, vectorV) {
        this.origin.setFrom(origin);
        this.vectorU.setFrom(vectorU);
        this.vectorV.setFrom(vectorV);
        return this;
    }
    /** Create from complete list of (x,y,z,w) in origin, vectorU, and vectorV */
    static createOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw, result) {
        if (result)
            return result.setOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw);
        return new PlaneByOriginAndVectors4d(Point4d_1.Point4d.create(x0, y0, z0, w0), Point4d_1.Point4d.create(ux, uy, uz, uw), Point4d_1.Point4d.create(vx, vy, vz, uw));
    }
    /** create from origin point, (u=1,v=0) point, and (u=0,v=1) point. */
    static createOriginAndTargets3d(origin, targetU, targetV, result) {
        return PlaneByOriginAndVectors4d.createOriginAndVectorsXYZW(origin.x, origin.y, origin.z, 1.0, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, 0.0, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, 0.0, result);
    }
    /** evaluate plane point (full 3d) at given (u,v) coordinate. */
    fractionToPoint(u, v, result) {
        return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);
    }
    /** create a new plane which maps to the cartesian xy plane. */
    static createXYPlane(result) {
        return PlaneByOriginAndVectors4d.createOriginAndVectorsXYZW(0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, result);
    }
}
exports.PlaneByOriginAndVectors4d = PlaneByOriginAndVectors4d;


/***/ }),

/***/ "./lib/geometry4d/Point4d.js":
/*!***********************************!*\
  !*** ./lib/geometry4d/Point4d.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const Plane3dByOriginAndUnitNormal_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndUnitNormal */ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js");
/**
 *
 * @param ddg numerator second derivative
 * @param dh denominator derivative
 * @param ddh denominator second derivative
 * @param f primary function (g/h)
 * @param df derivative of (g/h)
 * @param divH = (1/h)
 * @internal
 */
function quotientDerivative2(ddg, dh, ddh, f, df, divH) {
    return divH * (ddg - 2.0 * df * dh - f * ddh);
}
/** 4 Dimensional point (x,y,z,w) used in perspective calculations.
 * * the coordinates are stored in a Float64Array of length 4.
 * * properties `x`, `y`, `z`, `w` access array members.
 * *
 * * The coordinates are physically stored as a single Float64Array with 4 entries. (w last)
 * *
 * @public
 */
class Point4d {
    /** Construct from coordinates. */
    constructor(x = 0, y = 0, z = 0, w = 0) {
        this.xyzw = new Float64Array(4);
        this.xyzw[0] = x;
        this.xyzw[1] = y;
        this.xyzw[2] = z;
        this.xyzw[3] = w;
    }
    /** Set x,y,z,w of this point.  */
    set(x = 0, y = 0, z = 0, w = 0) {
        this.xyzw[0] = x;
        this.xyzw[1] = y;
        this.xyzw[2] = z;
        this.xyzw[3] = w;
        return this;
    }
    /** Set a component by index.
     * * No change if index is out of range.
     */
    setComponent(index, value) {
        if (index >= 0 && index < 4) {
            this.xyzw[index] = value;
        }
    }
    /** Return the x component. */
    get x() { return this.xyzw[0]; }
    /** Set the x component. */
    set x(val) { this.xyzw[0] = val; }
    /** Return the y component. */
    get y() { return this.xyzw[1]; }
    /** Set the y component. */
    set y(val) { this.xyzw[1] = val; }
    /** Return the z component. */
    get z() { return this.xyzw[2]; }
    /** Set the z component. */
    set z(val) { this.xyzw[2] = val; }
    /** Return the w component of this point. */
    get w() { return this.xyzw[3]; }
    /** Set the w component. */
    set w(val) { this.xyzw[3] = val; }
    /** Return a Point4d with specified x,y,z,w */
    static create(x = 0, y = 0, z = 0, w = 0, result) {
        return result ? result.set(x, y, z, w) : new Point4d(x, y, z, w);
    }
    /** Copy coordinates from `other`. */
    setFrom(other) {
        this.xyzw[0] = other.xyzw[0];
        this.xyzw[1] = other.xyzw[1];
        this.xyzw[2] = other.xyzw[2];
        this.xyzw[3] = other.xyzw[3];
        return this;
    }
    /** Clone this point */
    clone(result) {
        return result ? result.setFrom(this) : new Point4d(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);
    }
    /** Set this point's xyzw from a json array `[x,y,z,w]` */
    setFromJSON(json) {
        if (Geometry_1.Geometry.isNumberArray(json, 4))
            this.set(json[0], json[1], json[2], json[3]);
        else
            this.set(0, 0, 0, 0);
    }
    /** Create a new point with coordinates from a json array `[x,y,z,w]` */
    static fromJSON(json) {
        const result = new Point4d();
        result.setFromJSON(json);
        return result;
    }
    /** Near-equality test, using `Geometry.isSameCoordinate` on all 4 x,y,z,w */
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, other.x)
            && Geometry_1.Geometry.isSameCoordinate(this.y, other.y)
            && Geometry_1.Geometry.isSameCoordinate(this.z, other.z)
            && Geometry_1.Geometry.isSameCoordinate(this.w, other.w);
    }
    /**
     * Test for same coordinate by direct x,y,z,w args
     * @param x x to test
     * @param y y to test
     * @param z z to test
     * @param w w to test
     */
    isAlmostEqualXYZW(x, y, z, w) {
        return Geometry_1.Geometry.isSameCoordinate(this.x, x)
            && Geometry_1.Geometry.isSameCoordinate(this.y, y)
            && Geometry_1.Geometry.isSameCoordinate(this.z, z)
            && Geometry_1.Geometry.isSameCoordinate(this.w, w);
    }
    /**
     * Convert an Angle to a JSON object.
     * @return {*} [x,y,z,w]
     */
    toJSON() {
        return [this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]];
    }
    /** Return the 4d distance from this point to other, with all 4 components squared into the hypotenuse.
     * * x,y,z,w all participate without normalization.
     */
    distanceXYZW(other) {
        return Geometry_1.Geometry.hypotenuseXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);
    }
    /** Return the squared 4d distance from this point to other, with all 4 components squared into the hypotenuse.
     * * x,y,z,w all participate without normalization.
     */
    distanceSquaredXYZW(other) {
        return Geometry_1.Geometry.hypotenuseSquaredXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);
    }
    /** Return the distance between the instance and other after normalizing by weights
     */
    realDistanceXY(other) {
        const wA = this.w;
        const wB = other.w;
        if (Geometry_1.Geometry.isSmallMetricDistance(wA) || Geometry_1.Geometry.isSmallMetricDistance(wB))
            return undefined;
        return Geometry_1.Geometry.hypotenuseXY(other.xyzw[0] / wB - this.xyzw[0] / wA, other.xyzw[1] / wB - this.xyzw[1] / wA);
    }
    /** Return the largest absolute distance between corresponding components
     * * x,y,z,w all participate without normalization.
     */
    maxDiff(other) {
        return Math.max(Math.abs(other.xyzw[0] - this.xyzw[0]), Math.abs(other.xyzw[1] - this.xyzw[1]), Math.abs(other.xyzw[2] - this.xyzw[2]), Math.abs(other.xyzw[3] - this.xyzw[3]));
    }
    /** Return the largest absolute entry of all 4 components x,y,z,w */
    maxAbs() {
        return Math.max(Math.abs(this.xyzw[0]), Math.abs(this.xyzw[1]), Math.abs(this.xyzw[2]), Math.abs(this.xyzw[3]));
    }
    /** Returns the magnitude including all 4 components x,y,z,w */
    magnitudeXYZW() {
        return Geometry_1.Geometry.hypotenuseXYZW(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);
    }
    /** Returns the magnitude of the leading xyz components.  w is ignored.  (i.e. the leading xyz are NOT divided by w.) */
    magnitudeSquaredXYZ() {
        return Geometry_1.Geometry.hypotenuseSquaredXYZ(this.xyzw[0], this.xyzw[1], this.xyzw[2]);
    }
    /** Return the difference (this-other) using all 4 components x,y,z,w */
    minus(other, result) {
        return Point4d.create(this.xyzw[0] - other.xyzw[0], this.xyzw[1] - other.xyzw[1], this.xyzw[2] - other.xyzw[2], this.xyzw[3] - other.xyzw[3], result);
    }
    /** Return `((other.w * this) -  (this.w * other))` */
    crossWeightedMinus(other, result) {
        const wa = this.xyzw[3];
        const wb = other.xyzw[3];
        return Point3dVector3d_1.Vector3d.create(wb * this.xyzw[0] - wa * other.xyzw[0], wb * this.xyzw[1] - wa * other.xyzw[1], wb * this.xyzw[2] - wa * other.xyzw[2], result);
    }
    /** Return the sum of this and other, using all 4 components x,y,z,w */
    plus(other, result) {
        return Point4d.create(this.xyzw[0] + other.xyzw[0], this.xyzw[1] + other.xyzw[1], this.xyzw[2] + other.xyzw[2], this.xyzw[3] + other.xyzw[3], result);
    }
    /** Test if all components are nearly zero. */
    get isAlmostZero() {
        return Geometry_1.Geometry.isSmallMetricDistance(this.maxAbs());
    }
    /** Create a point with zero in all coordinates. */
    static createZero() { return new Point4d(0, 0, 0, 0); }
    /**
     * Create plane coefficients for the plane containing pointA, pointB, and 0010.
     * @param pointA first point
     * @param pointB second point
     */
    static createPlanePointPointZ(pointA, pointB, result) {
        return Point4d.create(pointA.y * pointB.w - pointA.w * pointB.y, pointA.w * pointB.x - pointA.x * pointB.w, 0.0, pointA.x * pointB.y - pointA.y * pointB.x, result);
    }
    /**
     * extract 4 consecutive numbers from a Float64Array into a Point4d.
     * @param data buffer of numbers
     * @param xIndex first index for x,y,z,w sequence
     */
    static createFromPackedXYZW(data, xIndex = 0, result) {
        return Point4d.create(data[xIndex], data[xIndex + 1], data[xIndex + 2], data[xIndex + 3], result);
    }
    /** Create a `Point4d` with x,y,z from an `XYAndZ` input, and w from a separate number. */
    static createFromPointAndWeight(xyz, w) {
        return new Point4d(xyz.x, xyz.y, xyz.z, w);
    }
    /** Return `point + vector * scalar` */
    plusScaled(vector, scaleFactor, result) {
        return Point4d.create(this.xyzw[0] + vector.xyzw[0] * scaleFactor, this.xyzw[1] + vector.xyzw[1] * scaleFactor, this.xyzw[2] + vector.xyzw[2] * scaleFactor, this.xyzw[3] + vector.xyzw[3] * scaleFactor, result);
    }
    /** Return interpolation between instance and pointB at fraction
     */
    interpolate(fraction, pointB, result) {
        const v = 1.0 - fraction;
        return Point4d.create(this.xyzw[0] * v + pointB.xyzw[0] * fraction, this.xyzw[1] * v + pointB.xyzw[1] * fraction, this.xyzw[2] * v + pointB.xyzw[2] * fraction, this.xyzw[3] * v + pointB.xyzw[3] * fraction, result);
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB` */
    plus2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */
    plus3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);
    }
    /** Return `point + vectorA * scalarA + vectorB * scalarB` */
    static createAdd2Scaled(vectorA, scalarA, vectorB, scalarB, result) {
        return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);
    }
    /** Return `point + vectorA \ scalarA + vectorB * scalarB + vectorC * scalarC` */
    static createAdd3Scaled(vectorA, scalarA, vectorB, scalarB, vectorC, scalarC, result) {
        return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);
    }
    /** Return dot product of (4d) vectors from the instance to targetA and targetB */
    dotVectorsToTargets(targetA, targetB) {
        return (targetA.xyzw[0] - this.xyzw[0]) * (targetB.xyzw[0] - this.xyzw[0]) +
            (targetA.xyzw[1] - this.xyzw[1]) * (targetB.xyzw[1] - this.xyzw[1]) +
            (targetA.xyzw[2] - this.xyzw[2]) * (targetB.xyzw[2] - this.xyzw[2]) +
            (targetA.xyzw[3] - this.xyzw[3]) * (targetB.xyzw[3] - this.xyzw[3]);
    }
    /** return (4d) dot product of the instance and other point. */
    dotProduct(other) {
        return this.xyzw[0] * other.xyzw[0] + this.xyzw[1] * other.xyzw[1] + this.xyzw[2] * other.xyzw[2] + this.xyzw[3] * other.xyzw[3];
    }
    /** return (4d) dot product of the instance with xyzw */
    dotProductXYZW(x, y, z, w) {
        return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z + this.xyzw[3] * w;
    }
    /** dotProduct with (point.x, point.y, point.z, 1) Used in PlaneAltitudeEvaluator interface */
    altitude(point) {
        return this.xyzw[0] * point.x + this.xyzw[1] * point.y + this.xyzw[2] * point.z + this.xyzw[3];
    }
    /** dotProduct with (x, y, z, 1) Used in PlaneAltitudeEvaluator interface */
    altitudeXYZ(x, y, z) {
        return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z + this.xyzw[3];
    }
    /** dotProduct with (point.x, point.y, point.z, point.w) Used in PlaneAltitudeEvaluator interface */
    weightedAltitude(point) {
        return this.xyzw[0] * point.x + this.xyzw[1] * point.y + this.xyzw[2] * point.z + this.xyzw[3] * point.w;
    }
    /** dotProduct with (vector.x, vector.y, vector.z, 0).  Used in PlaneAltitudeEvaluator interface */
    velocity(vector) {
        return this.xyzw[0] * vector.x + this.xyzw[1] * vector.y + this.xyzw[2] * vector.z;
    }
    /** dotProduct with (x,y,z, 0).  Used in PlaneAltitudeEvaluator interface */
    velocityXYZ(x, y, z) {
        return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z;
    }
    /** unit X vector */
    static unitX() { return new Point4d(1, 0, 0, 0); }
    /** unit Y vector */
    static unitY() { return new Point4d(0, 1, 0, 0); }
    /** unit Z vector */
    static unitZ() { return new Point4d(0, 0, 1, 0); }
    /** unit W vector */
    static unitW() { return new Point4d(0, 0, 0, 1); }
    /** Divide by denominator, but return undefined if denominator is zero. */
    safeDivideOrNull(denominator, result) {
        if (denominator !== 0.0) {
            return this.scale(1.0 / denominator, result);
        }
        return undefined;
    }
    /** scale all components (including w!!) */
    scale(scale, result) {
        result = result ? result : new Point4d();
        result.xyzw[0] = this.xyzw[0] * scale;
        result.xyzw[1] = this.xyzw[1] * scale;
        result.xyzw[2] = this.xyzw[2] * scale;
        result.xyzw[3] = this.xyzw[3] * scale;
        return result;
    }
    /** Negate components (including w!!) */
    negate(result) {
        result = result ? result : new Point4d();
        result.xyzw[0] = -this.xyzw[0];
        result.xyzw[1] = -this.xyzw[1];
        result.xyzw[2] = -this.xyzw[2];
        result.xyzw[3] = -this.xyzw[3];
        return result;
    }
    /**
     * If `this.w` is nonzero, return a 4d point `(x/w,y/w,z/w, 1)`
     * If `this.w` is zero, return undefined.
     * @param result optional result
     */
    normalizeWeight(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.xyzw[3]);
        result = result ? result : new Point4d();
        return this.safeDivideOrNull(mag, result);
    }
    /**
     * If `this.w` is nonzero, return a 3d point `(x/w,y/w,z/w)`
     * If `this.w` is zero, return undefined.
     * @param result optional result
     */
    realPoint(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.xyzw[3]);
        if (mag === 0.0)
            return undefined;
        const a = 1.0 / mag; // in zero case everything multiplies right back to true zero.
        return Point3dVector3d_1.Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);
    }
    /**
     * * If w is nonzero, return Point3d with x/w,y/w,z/w.
     * * If w is zero, return 000
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     * @param w w coordinate
     * @param result optional result
     */
    static createRealPoint3dDefault000(x, y, z, w, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(w);
        const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.
        return Point3dVector3d_1.Point3d.create(x * a, y * a, z * a, result);
    }
    /**
     * * If w is nonzero, return Vector3d which is the derivative of the projected xyz with given w and 4d derivatives.
     * * If w is zero, return 000
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     * @param w w coordinate
     * @param dx x coordinate of derivative
     * @param dy y coordinate of derivative
     * @param dz z coordinate of derivative
     * @param dw w coordinate of derivative
     * @param result optional result
     */
    static createRealDerivativeRay3dDefault000(x, y, z, w, dx, dy, dz, dw, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(w);
        // real point is X/w.
        // real derivative is (X' * w - X *w) / ww, and weight is always 0 by cross products.
        const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.
        const aa = a * a;
        return Ray3d_1.Ray3d.createXYZUVW(x * a, y * a, z * a, (dx * w - dw * x) * aa, (dy * w - dw * y) * aa, (dz * w - dw * z) * aa, result);
    }
    /**
     * * If w is nonzero, return Vector3d which is the derivative of the projected xyz with given w and 4d derivatives.
     * * If w is zero, return 000
     * @param x x coordinate
     * @param y y coordinate
     * @param z z coordinate
     * @param w w coordinate
     * @param dx x coordinate of derivative
     * @param dy y coordinate of derivative
     * @param dz z coordinate of derivative
     * @param dw w coordinate of derivative
     * @param result optional result
     */
    static createRealDerivativePlane3dByOriginAndVectorsDefault000(x, y, z, w, dx, dy, dz, dw, ddx, ddy, ddz, ddw, result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(w);
        // real point is X/w.
        // real derivative is (X' * w - X *w) / ww, and weight is always 0 by cross products.
        const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.
        const aa = a * a;
        const fx = x * a;
        const fy = y * a;
        const fz = z * a;
        const dfx = (dx * w - dw * x) * aa;
        const dfy = (dy * w - dw * y) * aa;
        const dfz = (dz * w - dw * z) * aa;
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(fx, fy, fz, dfx, dfy, dfz, quotientDerivative2(ddx, dw, ddw, fx, dfx, a), quotientDerivative2(ddy, dw, ddw, fy, dfy, a), quotientDerivative2(ddz, dw, ddw, fz, dfz, a), result);
    }
    /**
     * * If this.w is nonzero, return Point3d with x/w,y/w,z/w.
     * * If this.w is zero, return 000
     */
    realPointDefault000(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.xyzw[3]);
        if (mag === 0.0)
            return Point3dVector3d_1.Point3d.create(0, 0, 0, result);
        result = result ? result : new Point3dVector3d_1.Point3d();
        const a = 1.0 / mag;
        return Point3dVector3d_1.Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);
    }
    /** divide all components (x,y,z,w) by the 4d magnitude.
     *
     * * This is appropriate for normalizing a quaternion
     * * Use normalizeWeight to divide by the w component.
     */
    normalizeXYZW(result) {
        const mag = Geometry_1.Geometry.correctSmallMetricDistance(this.magnitudeXYZW());
        result = result ? result : new Point4d();
        return this.safeDivideOrNull(mag, result);
    }
    /**
     * Return the determinant of the 3x3 matrix using components i,j,k of the 3 inputs.
     */
    static determinantIndexed3X3(pointA, pointB, pointC, i, j, k) {
        return Geometry_1.Geometry.tripleProduct(pointA.xyzw[i], pointA.xyzw[j], pointA.xyzw[k], pointB.xyzw[i], pointB.xyzw[j], pointB.xyzw[k], pointC.xyzw[i], pointC.xyzw[j], pointC.xyzw[k]);
    }
    /**
     * Return a Point4d perpendicular to all 3 inputs. (A higher level cross product concept)
     * @param pointA first point
     * @param pointB second point
     * @param pointC third point
     */
    static perpendicularPoint4dPlane(pointA, pointB, pointC) {
        return Point4d.create(Point4d.determinantIndexed3X3(pointA, pointB, pointC, 1, 2, 3), -Point4d.determinantIndexed3X3(pointA, pointB, pointC, 2, 3, 0), Point4d.determinantIndexed3X3(pointA, pointB, pointC, 3, 0, 1), -Point4d.determinantIndexed3X3(pointA, pointB, pointC, 0, 1, 2));
    }
    /** Treating this Point4d as plane coefficients, convert to origin and normal form. */
    toPlane3dByOriginAndUnitNormal(result) {
        const aa = this.magnitudeSquaredXYZ();
        const direction = Point3dVector3d_1.Vector3d.create(this.x, this.y, this.z);
        const w = this.w;
        const divW = Geometry_1.Geometry.conditionalDivideFraction(1.0, w);
        if (divW !== undefined) {
            const b = -w / aa;
            direction.scaleInPlace(1.0 / Math.sqrt(aa));
            return Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.create(Point3dVector3d_1.Point3d.create(this.x * b, this.y * b, this.z * b), direction, result);
        }
        return undefined;
    }
    /** Normalize so sum of squares of all 4 coordinates is 1. */
    normalizeQuaternion() {
        const magnitude = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        if (magnitude > 0.0) {
            const f = 1.0 / magnitude;
            this.x *= f;
            this.y *= f;
            this.z *= f;
            this.w *= f;
        }
        return magnitude;
    }
    /** Return a (normalized) quaternion interpolated between two quaternions. */
    static interpolateQuaternions(quaternion0, fractionParameter, quaternion1, result) {
        if (!result)
            result = new Point4d();
        const maxSafeCosine = 0.9995;
        // return exact quaternions for special values
        if (0.0 === fractionParameter) {
            result = quaternion0;
            return result;
        }
        if (1.0 === fractionParameter) {
            result = quaternion1;
            return result;
        }
        if (0.5 === fractionParameter) {
            quaternion0.plus(quaternion1, result);
            result.normalizeQuaternion();
            return result;
        }
        const q0 = quaternion0.clone();
        const q1 = quaternion1.clone();
        let dot = quaternion0.dotProduct(quaternion1);
        // prevent interpolation through the longer great arc
        if (dot < 0.0) {
            q1.negate(q1);
            dot = -dot;
        }
        // if nearly parallel, use interpolate and renormalize .
        if (dot > maxSafeCosine) {
            q0.interpolate(fractionParameter, q1, result);
            result.normalizeQuaternion();
            return result;
        }
        // safety check
        if (dot < -1.0)
            dot = -1.0;
        else if (dot > 1.0)
            dot = 1.0;
        // create orthonormal basis {q0, q2}
        const q2 = new Point4d();
        q1.plusScaled(q0, -dot, q2); //  bsiDPoint4d_addScaledDPoint4d(& q2, & q1, & q0, -dot);
        q2.normalizeQuaternion();
        const angle = Math.acos(dot);
        const angleOfInterpolation = angle * fractionParameter;
        result = Point4d.createAdd2Scaled(q0, Math.cos(angleOfInterpolation), q2, Math.sin(angleOfInterpolation));
        return result;
    }
    /** Measure the "angle" between two points, using all 4 components in the dot product that
     * gives the cosine of the angle.
     */
    radiansToPoint4dXYZW(other) {
        const magA = this.magnitudeXYZW();
        const magB = other.magnitudeXYZW();
        const dot = this.dotProduct(other); // == cos (theta) * magA * magB
        const cos = Geometry_1.Geometry.conditionalDivideFraction(dot, magA * magB);
        if (cos === undefined)
            return undefined;
        return Math.acos(cos);
    }
}
exports.Point4d = Point4d;


/***/ }),

/***/ "./lib/numerics/BezierPolynomials.js":
/*!*******************************************!*\
  !*** ./lib/numerics/BezierPolynomials.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
// import { Angle, AngleSweep, Geometry } from "../Geometry";
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const PascalCoefficients_1 = __webpack_require__(/*! ./PascalCoefficients */ "./lib/numerics/PascalCoefficients.js");
const Polynomials_1 = __webpack_require__(/*! ./Polynomials */ "./lib/numerics/Polynomials.js");
/* tslint:disable:variable-name*/
/**
 * * BezierCoffs is an abstract base class for one-dimensional (u to f(u)) Bezier polynomials.
 * * The base class carries a Float64Array with coefficients.
 * * The Float64Array is NOT Growable unless derived classes add logic to do so.  Its length is the Bezier polynomial order.
 * * The family of derived classes is starts with low order (at least linear through cubic) with highly optimized calculations.
 * * The general degree Bezier class also uses this as its base class.
 * * The length of the coefficient array is NOT always the bezier order.   Use the `order` property to access the order.
 * @internal
 */
class BezierCoffs {
    /**
     * * If `data` is a number, an array of that size is created with zeros.
     * * If `data` is a Float64Array, it is cloned (NOT CAPTURED)
     * * If `data` is a number array, its values are copied.
     */
    constructor(data) {
        if (data instanceof Float64Array) {
            this.coffs = data.slice();
        }
        else if (Array.isArray(data)) {
            this.coffs = new Float64Array(data.length);
            let i = 0;
            for (const a of data)
                this.coffs[i++] = a;
        }
        else {
            this.coffs = new Float64Array(data);
        }
    }
    /**
     * * Ensure the coefficient array size matches order.  (Reallocate as needed)
     * * fill with zeros.
     * @param order required order
     */
    allocateToOrder(order) {
        if (this.coffs.length !== order) {
            this.coffs = new Float64Array(order);
        }
        else {
            this.coffs.fill(0);
        }
    }
    /**
     * create an object of same order with zero coefficients.
     * The base implementation makes a generic Bezier of the same order.
     */
    createPeer() {
        const peer = new UnivariateBezier(this.order);
        return peer;
    }
    /** The order (number of coefficients) as a readable property  */
    get order() { return this.coffs.length; }
    /** Copy coefficients from other Bezier. Note that the coefficient count (order) of "this" can change. */
    copyFrom(other) {
        if (this.order === other.order)
            for (let i = 0; i < this.coffs.length; i++) {
                this.coffs[i] = other.coffs[i];
            }
        else
            this.coffs = other.coffs.slice();
    }
    /**
     * Apply a scale factor to all coefficients.
     * @param scale scale factor to apply to all coefficients.
     */
    scaleInPlace(scale) {
        for (let i = 0; i < this.coffs.length; i++)
            this.coffs[i] *= scale;
    }
    /** add a constant to each coefficient.
     * @param a constant to add.
     */
    addInPlace(a) {
        for (let i = 0; i < this.coffs.length; i++)
            this.coffs[i] += a;
    }
    /** Compute parameter values where the bezier value matches _targetValue.
     * * The base class finds roots only in 01.  (i.e. ignores _restrictTo01)
     * * Order-specific implementations apply special case  analytic logic, e.g. for degree 1,2,3,4.
     */
    roots(targetValue, _restrictTo01) {
        const bezier = UnivariateBezier.create(this);
        bezier.addInPlace(-targetValue);
        return UnivariateBezier.deflateRoots01(bezier);
    }
    /** Given an array of numbers, optionally remove those not in the 0..1 interval.
     * @param roots candidate values
     * @param restrictTo01 If false, no filtering occurs and the pointer to the original array is unchanged.
     *     If true, filtering is done and values are returned, possibly in a new array and possibly in the original.
     */
    filter01(roots, restrictTo01 = false) {
        if (!roots || !restrictTo01)
            return roots;
        let anyFound = false;
        for (const r of roots) {
            if (Geometry_1.Geometry.isIn01(r)) {
                anyFound = true;
                break;
            }
        }
        if (anyFound) {
            const roots01 = [];
            for (const r of roots) {
                if (Geometry_1.Geometry.isIn01(r))
                    roots01.push(r);
            }
            return roots01;
        }
        return undefined;
    }
    /** zero out all coefficients. */
    zero() { this.coffs.fill(0); }
    /** Subdivide -- write results into caller-supplied bezier coffs (which must be of the same order) */
    subdivide(u, left, right) {
        const order = this.order;
        if (left.order !== order || right.order !== order)
            return false;
        const v = 1.0 - u;
        right.copyFrom(this);
        // each left will be filled in directly, so there is no need to initialize it.
        let n1 = order - 1; // number of interpolations in inner loop.
        for (let i0 = 0; i0 < order; i0++) {
            left.coffs[i0] = right.coffs[0];
            for (let i = 0; i < n1; i++)
                right.coffs[i] = v * right.coffs[i] + u * right.coffs[i + 1];
            n1--;
        }
        return true;
    }
    /** Return the maximum absolute difference between coefficients of two sets of BezierCoffs */
    static maxAbsDiff(dataA, dataB) {
        const order = dataA.order;
        if (dataB.order !== order)
            return undefined;
        let d = 0.0;
        let d1;
        for (let i = 0; i < order; i++) {
            d1 = Math.abs(dataA.coffs[i] - dataB.coffs[i]);
            if (d1 > d)
                d = d1;
        }
        return d;
    }
}
exports.BezierCoffs = BezierCoffs;
/**
 * Static methods to operate on univariate bezier polynomials, with coefficients in simple Float64Array or as components of blocked arrays.
 * @internal
 */
class BezierPolynomialAlgebra {
    /**
     * * Univariate bezierA has its coefficients at offset indexA in each block within the array of blocks.
     * * Symbolically:   `product(s) += scale * (constA - polynomialA(s)) *polynomialB(s)`
     * * Where coefficients of polynomialA(s) are in column indexA and coefficients of polynomialB(s) are differences within column indexB.
     * * Treating data as 2-dimensional array:   `product = sum (iA) sum (iB)    (constA - basisFunction[iA} data[indexA][iA]) * basisFunction[iB] * (dataOrder-1)(data[iB + 1][indexB] - data[iB][indexB])`
     * * Take no action if product length is other than `dataOrder + dataOrder - 2`
     */
    static accumulateScaledShiftedComponentTimesComponentDelta(product, data, dataBlockSize, dataOrder, scale, indexA, constA, indexB) {
        const orderB = dataOrder - 1; // coefficients of the first difference are implicitly present as differences of adjacent entries.
        const orderA = dataOrder;
        const orderC = dataOrder + orderB - 1;
        if (product.length !== orderC)
            return;
        const coffA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const coffB = PascalCoefficients_1.PascalCoefficients.getRow(orderB - 1);
        const coffC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        let qA;
        for (let a = 0; a < orderA; a++) {
            qA = scale * (constA + data[indexA + a * dataBlockSize]) * coffA[a];
            for (let b = 0, k = indexB; b < orderB; b++, k += dataBlockSize) {
                product[a + b] += qA * coffB[b] * (data[k + dataBlockSize] - data[k]) / coffC[a + b];
            }
        }
    }
    /**
     * * Univariate bezierA has its coefficients at offset indexA in each block within the array of blocks.
     * * Univariate bezierB has its coefficients at offset indexB in each block within the array of blocks.
     * * return the sum coefficients for `constA * polynomialA + constB * polynomialB`
     * * Symbolically:   `product(s) = (constA * polynomialA(s) + constB * polynomialB(s)`
     * * The two polynomials are the same order, so this just direct sum of scaled coefficients.
     *
     * * Take no action if product length is other than `dataOrder + dataOrder - 2`
     */
    static scaledComponentSum(sum, data, dataBlockSize, dataOrder, indexA, constA, indexB, constB) {
        const orderA = dataOrder;
        if (sum.length !== orderA)
            return;
        for (let a = 0, rowBase = 0; a < orderA; a++, rowBase += dataBlockSize) {
            sum[a] = constA * data[rowBase + indexA] + constB * data[rowBase + indexB];
        }
    }
    /**
     * * Univariate bezier has its coefficients at offset index in each block within the array of blocks.
     * * return the (dataOrder - 1) differences,
     *
     * * Take no action if difference length is other than `dataOrder - 1`
     */
    static componentDifference(difference, data, dataBlockSize, dataOrder, index) {
        const orderA = dataOrder;
        const orderDiff = orderA - 1;
        if (difference.length !== orderDiff)
            return;
        for (let i = 0, k = index; i < orderDiff; k += dataBlockSize, i++)
            difference[i] = data[k + dataBlockSize] - data[k];
    }
    /**
     * * Univariate bezierA has its coefficients in dataA[i]
     * * Univariate bezierB has its coefficients in dataB[i]
     * * return the product coefficients for polynomialA(s) * polynomialB(s) * scale
     * * Take no action if product length is other than `orderA + orderB - 1`
     */
    static accumulateProduct(product, dataA, dataB, scale = 1.0) {
        const orderA = dataA.length;
        const orderB = dataB.length;
        const orderC = orderA + orderB - 1;
        if (product.length !== orderC)
            return;
        let a;
        let b;
        let qA;
        const coffA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const coffB = PascalCoefficients_1.PascalCoefficients.getRow(orderB - 1);
        const coffC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        for (a = 0; a < orderA; a++) {
            qA = scale * coffA[a] * dataA[a];
            for (b = 0; b < orderB; b++) {
                product[a + b] += qA * coffB[b] * dataB[b] / coffC[a + b];
            }
        }
    }
    /**
     * * Univariate bezierA has its coefficients in dataA[i]
     * * Univariate bezierB has its coefficients in dataB[i]
     * * return the product coefficients for polynomialADifferences(s) * polynomialB(s) * scale
     * * Take no action if product length is other than `orderA + orderB - 2`
     */
    static accumulateProductWithDifferences(product, dataA, dataB, scale = 1.0) {
        const orderA = dataA.length - 1; // We deal with its differences, which are lower order !!!
        const orderB = dataB.length;
        const orderC = orderA + orderB - 1;
        if (product.length !== orderC)
            return;
        let a;
        let b;
        let qA;
        const coffA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const coffB = PascalCoefficients_1.PascalCoefficients.getRow(orderB - 1);
        const coffC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        for (a = 0; a < orderA; a++) {
            qA = scale * coffA[a] * (dataA[a + 1] - dataA[a]);
            for (b = 0; b < orderB; b++) {
                product[a + b] += qA * coffB[b] * dataB[b] / coffC[a + b];
            }
        }
    }
    /**
     * * Univariate bezier has its coefficients in data[i]
     * * return the difference data[i+1]-data[i] in difference.
     * * Take no action if product length is other than `orderA + orderB - 1`
     */
    static univariateDifference(data, difference) {
        const differenceOrder = difference.length;
        if (difference.length + 1 !== differenceOrder)
            for (let i = 0; i < differenceOrder; i++) {
                difference[i] = data[i + 1] - data[i];
            }
    }
    /**
     * * Univariate bezierA has its coefficients in dataA[i]
     * * Univariate bezierB has its coefficients in resultB[i]
     * * add (with no scaling) bezierA to bezierB
     * * Take no action if resultB.length is other than dataA.length.
     */
    static accumulate(dataA, orderA, resultB) {
        if (resultB.length !== orderA)
            return;
        for (let i = 0; i < orderA; i++) {
            resultB[i] += dataA[i];
        }
    }
}
exports.BezierPolynomialAlgebra = BezierPolynomialAlgebra;
/**
 * * The UnivariateBezier class is a univariate bezier polynomial with no particular order.
 * * More specific classes -- Order2Bezier, Order3Bezier, Order4Bezier -- can be used when a fixed order is known and the more specialized implementations are appropriate.
 * * When working with xy and xyz curves whose order is the common 2,3,4, various queries (e.g. project point to curve)
 *     generate higher order one-dimensional bezier polynomials with order that is a small multiple of the
 *     curve order.   Hence those polynomials commonly reach degree 8 to 12.
 * * Higher order bezier polynomials are possible, but performance and accuracy issues become significant.
 * * Some machine-level constraints apply for curves of extremely high order, e.g. 70.   For instance, at that level use of
 *     Pascal triangle coefficients becomes inaccurate because IEEE doubles cannot represent integers that
 *     large.
 * @internal
 */
class UnivariateBezier extends BezierCoffs {
    constructor(data) {
        super(data);
        this._order = super.order;
    }
    /** Query the order of this bezier. */
    get order() { return this._order; }
    /** (Re) initialize with given order (and all coffs zero) */
    allocateOrder(order) {
        if (this._order !== order) {
            super.allocateToOrder(order);
            this._order = order;
        }
        this.coffs.fill(0);
    }
    /** Return a copy, optionally with coffs array length reduced to actual order. */
    clone(compressToMinimalAllocation = false) {
        if (compressToMinimalAllocation) {
            const result1 = new UnivariateBezier(this.order);
            result1.coffs = this.coffs.slice(0, this.order);
            return result1;
        }
        const result = new UnivariateBezier(this.coffs.length);
        result._order = this._order;
        result.coffs = this.coffs.slice();
        return result;
    }
    /** Create a new bezier which is a copy of other.
     * * Note that `other` may be a more specialized class such as `Order2Bezier`, but the result is general `Bezier`
     * @param other coefficients to copy.
     */
    static create(other) {
        const result = new UnivariateBezier(other.order);
        result.coffs = other.coffs.slice();
        return result;
    }
    /**
     * copy coefficients into a new bezier.
     * @param coffs coefficients for bezier
     */
    static createCoffs(data) {
        return new UnivariateBezier(data);
    }
    /**
     * copy coefficients into a new bezier.
     * * if result is omitted, a new UnivariateBezier is allocated and returned.
     * * if result is present but has other order, its coefficients are reallocated
     * * if result is present and has matching order, the values are replace.
     * @param coffs coefficients for bezier
     * @param index0 first index to access
     * @param order number of coefficients, i.e. order for the result
     * @param result optional result.
     *
     */
    static createArraySubset(coffs, index0, order, result) {
        if (!result)
            result = new UnivariateBezier(order);
        else if (result.order !== order)
            result.allocateToOrder(order);
        for (let i = 0; i < order; i++)
            result.coffs[i] = coffs[index0 + i];
        return result;
    }
    /**
     * Create a product of 2 bezier polynomials.
     * @param bezierA
     * @param bezierB
     */
    static createProduct(bezierA, bezierB) {
        const result = new UnivariateBezier(bezierA.order + bezierB.order - 1);
        const pascalA = PascalCoefficients_1.PascalCoefficients.getRow(bezierA.order - 1);
        const pascalB = PascalCoefficients_1.PascalCoefficients.getRow(bezierB.order - 1);
        const pascalC = PascalCoefficients_1.PascalCoefficients.getRow(bezierA.order + bezierB.order - 2);
        for (let iA = 0; iA < bezierA.order; iA++) {
            const a = bezierA.coffs[iA] * pascalA[iA];
            for (let iB = 0; iB < bezierB.order; iB++) {
                const b = bezierB.coffs[iB] * pascalB[iB];
                const iC = iA + iB;
                const c = pascalC[iC];
                result.coffs[iC] += a * b / c;
            }
        }
        return result;
    }
    /**
     * Add a squared bezier polynomial (given as simple coffs)
     * @param coffA coefficients of bezier to square
     * @param scale scale factor
     * @return false if order mismatch -- must have `2 * bezierA.length  === this.order + 1`
     */
    addSquaredSquaredBezier(coffA, scale) {
        const orderA = coffA.length;
        const orderC = this.order;
        if (orderA * 2 !== orderC + 1)
            return false;
        const pascalA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const pascalC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        const coffC = this.coffs;
        for (let iA = 0; iA < orderA; iA++) {
            const a = coffA[iA] * pascalA[iA] * scale;
            for (let iB = 0; iB < orderA; iB++) {
                const b = coffA[iB] * pascalA[iB];
                const iC = iA + iB;
                const c = pascalC[iC];
                coffC[iC] += a * b / c;
            }
        }
        return true;
    }
    /** Add a constant to each coefficient */
    addConstant(a) {
        for (let i = 0; i < this.coffs.length; i++) {
            this.coffs[i] += a;
        }
    }
    /** evaluate the basis functions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        this._basisValues = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);
        if (!result || result.length !== this.order)
            result = new Float64Array(this.order);
        let i = 0;
        for (const a of this._basisValues)
            result[i++] = a;
        return result;
    }
    /**
     * Sum weights[i] * data[...] in blocks of numPerBlock.
     * This is for low level use -- counts are not checked.
     * @param weights
     * @param data
     * @param numPerBlock
     */
    static sumWeightedBlocks(weights, numWeights, data, numPerBlock, result) {
        for (let k0 = 0; k0 < numPerBlock; k0++) {
            result[k0] = 0;
        }
        let k = 0;
        let i;
        for (let iWeight = 0; iWeight < numWeights; iWeight++) {
            const w = weights[iWeight];
            for (i = 0; i < numPerBlock; i++) {
                result[i] += w * data[k++];
            }
        }
    }
    /**
     * Given (multidimensional) control points, sum the control points weighted by the basis function values at parameter u.
     * @param u bezier parameter
     * @param polygon Array with coefficients in blocks.
     * @param blockSize size of blocks
     * @param result `blockSize` summed values.
     */
    sumBasisFunctions(u, polygon, blockSize, result) {
        const order = this._order;
        if (!result)
            result = new Float64Array(order);
        this._basisValues = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);
        UnivariateBezier.sumWeightedBlocks(this._basisValues, order, polygon, blockSize, result);
        return result;
    }
    /**
     * Given (multidimensional) control points, sum the control points weighted by the basis function derivative values at parameter u.
     * @param u bezier parameter
     * @param polygon Array with coefficients in blocks.
     * @param blockSize size of blocks
     * @param result `blockSize` summed values.
     */
    sumBasisFunctionDerivatives(u, polygon, blockSize, result) {
        const order = this._order;
        if (!result)
            result = new Float64Array(blockSize);
        this._basisValues = PascalCoefficients_1.PascalCoefficients.getBezierBasisDerivatives(this.order, u, this._basisValues);
        UnivariateBezier.sumWeightedBlocks(this._basisValues, order, polygon, blockSize, result);
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        this._basisValues = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);
        let sum = 0;
        for (let i = 0; i < this.order; i++)
            sum += this._basisValues[i] * this.coffs[i];
        return sum;
    }
    /**
     * Apply deflation from the left to a bezier.
     * * This assumes that the left coefficient is zero.
     */
    deflateLeft() {
        // coefficient 0 is zero (caller promises.)
        // get bezier coffs for both orders ...
        const order1 = this.order;
        const order0 = order1 - 1;
        const coff0 = PascalCoefficients_1.PascalCoefficients.getRow(order0 - 1);
        const coff1 = PascalCoefficients_1.PascalCoefficients.getRow(order1 - 1);
        let a;
        for (let i = 0; i < order0; i++) {
            a = this.coffs[i + 1];
            this.coffs[i] = a * coff1[i + 1] / coff0[i];
        }
        this._order--;
    }
    /**
     * Apply deflation from the right to a frame.
     * * This assumes that the right coefficient is zero.
     * @param frame frame description
     */
    deflateRight() {
        // final coefficient is zero (caller promises.)
        // get bezier coffs for both orders ...
        const order1 = this.order;
        const order0 = order1 - 1;
        const coff0 = PascalCoefficients_1.PascalCoefficients.getRow(order0 - 1);
        const coff1 = PascalCoefficients_1.PascalCoefficients.getRow(order1 - 1);
        let a, b;
        for (let i = 0; i < order0; i++) {
            a = this.coffs[i];
            b = a * coff1[i] / coff0[i];
            this.coffs[i] = b;
        }
        this._order--;
    }
    /**
     * * divide the polynomial by `(x-root)`.
     * * return the remainder
     * * If `root` truly is a root, the return is zero.
     * @param root root to remove
     */
    deflateRoot(root) {
        const orderA = this.order;
        const orderC = orderA - 1; // the order of the deflated bezier.
        if (orderA === 1) {
            this._order = 0;
            return this.coffs[0];
        }
        if (orderA < 1) {
            this._order = 0;
            return 0.0;
        }
        const pascalA = PascalCoefficients_1.PascalCoefficients.getRow(orderA - 1);
        const pascalC = PascalCoefficients_1.PascalCoefficients.getRow(orderC - 1);
        const b0 = -root;
        const b1 = 1.0 - root;
        let remainder = 0;
        if (root > 0.5) {
            let c0 = this.coffs[0] / b0;
            let c1;
            this.coffs[0] = c0;
            let a1 = this.coffs[1];
            for (let i = 1; i < orderC; i++) {
                a1 = this.coffs[i] * pascalA[i];
                c1 = (a1 - c0 * b1) / b0;
                this.coffs[i] = c1 / pascalC[i];
                c0 = c1;
            }
            remainder = this.coffs[orderA - 1] - c0 * b1;
        }
        else {
            // work backwards (to get division by larger of b0, b1)
            // replace coefficients of a starting with orderA -1 --
            // at end move them all forward.
            let c1 = this.coffs[orderA - 1] / b1;
            let c0;
            this.coffs[orderA - 1] = c1;
            let a1;
            for (let i = orderA - 2; i > 0; i--) {
                a1 = this.coffs[i] * pascalA[i];
                c0 = (a1 - c1 * b0) / b1;
                this.coffs[i] = c0 / pascalC[i - 1]; // pascalC index is from destination, which is not shifted.
                c1 = c0;
            }
            remainder = (this.coffs[0] - c1 * b0);
            for (let i = 0; i < orderC; i++)
                this.coffs[i] = this.coffs[i + 1];
        }
        this._order = orderC;
        // This should be zero !!!! (If not, `root` was not really a root!!)
        return remainder;
    }
    /**
     * Run a Newton iteration from startFraction.
     * @param startFraction [in] fraction for first iteration
     * @param tolerance [in] convergence tolerance.   The iteration is considered converged on the
     * second time the tolerance is satisfied.   For a typical iteration (not double root), the extra pass
     * will double the number of digits.  Hence this tolerance is normally set to 10 to 12 digits, trusting
     * that the final iteration will clean it up to nearly machine precision.
     * @returns final fraction of iteration if converged.  undefined if iteration failed to converge.
     */
    runNewton(startFraction, tolerance = 1.0e-11) {
        const derivativeFactor = this.order - 1;
        let numConverged = 0;
        let u = startFraction;
        let f, df;
        const bigStep = 10.0;
        const order = this.order;
        const coffs = this.coffs;
        const orderD = order - 1;
        for (let iterations = 0; iterations++ < 10;) {
            UnivariateBezier._basisBuffer = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(order, u, UnivariateBezier._basisBuffer);
            f = 0;
            for (let i = 0; i < order; i++)
                f += coffs[i] * UnivariateBezier._basisBuffer[i];
            UnivariateBezier._basisBuffer1 = PascalCoefficients_1.PascalCoefficients.getBezierBasisValues(orderD, u, UnivariateBezier._basisBuffer1);
            df = 0;
            for (let i = 0; i < orderD; i++)
                df += (coffs[i + 1] - coffs[i]) * UnivariateBezier._basisBuffer1[i];
            df *= derivativeFactor;
            if (Math.abs(f) > bigStep * Math.abs(df))
                return undefined;
            const du = f / df;
            if (Math.abs(du) < tolerance) {
                numConverged++;
                if (numConverged >= 2)
                    return u - du;
            }
            else {
                numConverged = 0;
            }
            u -= du;
        }
        return undefined;
    }
    // Deflation table.  b0, b1 are coefficients of term being divided out
    // Pascal coffs for b0,b1 are just 1.
    // Each ai is a coefficient of the (known) input, with its Pascal coefficient blended in.
    // each ci is a coefficient of the (unknown) result, with its coefficient blended in.
    // note b0, b1 are both nonzero, so the divisions are safe.
    // within the products, each c[i]*b0 pairs with c[i-1]*b1 (above and right diagonally) to make a[i]
    // first and last c0*b0 and c[orderC-1]*b1 make a0 and a[orderA-1]
    // |    |  b0    | b1      |   equivalence               | solve moving down
    // | c0 | c0* b0 | c0 * b1 |    a0 = c0 * b0             | c0 = a0 / b0
    // | c1 | c1* b0 | c1 * b1 |    a1 = c1 * b0 + c0 * b1   | c1 = (a1 - c0 * b1) / b0
    // | c2 | c2* b0 | c2 * b1
    // Each internal ci = (ai - c[i-1] * b1) /b0
    // first c0*b0 = a0
    // last c[orderC-1]*b1 = a[orderA-1]
    /** Find roots of a bezier polynomial
     * * Only look for roots in 0..1
     * * As roots are found, deflate the polynomial.
     * * bezier coffs are changed (and order reduced) at each step.
     */
    static deflateRoots01(bezier) {
        const roots = [];
        const coffs = bezier.coffs;
        let a0, a1, segmentFraction, globalStartFraction, newtonFraction;
        while (bezier.order > 1) {
            const order = bezier.order;
            // Find any crossing
            if (coffs[0] === 0.0) {
                bezier.deflateLeft();
                roots.push(0.0);
                continue;
            }
            let numCrossing = 0;
            let numNewtonOK = 0;
            for (let i = 1; i < order; i++) {
                a0 = coffs[i - 1];
                a1 = coffs[i];
                if (a0 * a1 <= 0.0) {
                    numCrossing++;
                    segmentFraction = -a0 / (a1 - a0);
                    globalStartFraction = (i - 1 + segmentFraction) / (order - 1);
                    newtonFraction = bezier.runNewton(globalStartFraction, 1.0e-10);
                    if (newtonFraction !== undefined) {
                        roots.push(newtonFraction);
                        bezier.deflateRoot(newtonFraction);
                        numNewtonOK++;
                        break;
                    }
                }
            }
            if (numNewtonOK)
                continue;
            // if any crossing was found and led to a good newton, the "continue" jumped past this.
            // if no crossings found, there are no roots to be had -- accept
            if (numCrossing === 0)
                return roots;
            // reach here if there were crossings but not roots.
            // is this just a local min?  or maybe a big problem?   Whatever, accept it
            return roots;
        }
        return roots;
    }
}
exports.UnivariateBezier = UnivariateBezier;
/** Bezier polynomial specialized to order 2 (2 coefficients, straight line function)\
 * @internal
 */
class Order2Bezier extends BezierCoffs {
    constructor(f0 = 0.0, f1 = 0.0) {
        super(2);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
    }
    /** return an Order2Bezier (linear) with the two coefficients from this Order2Bezier */
    clone() {
        return new Order2Bezier(this.coffs[0], this.coffs[1]);
    }
    /** normally, return fractional coordinate where bezier (a0,a1) has a root.
     * but if the fraction would exceed Geometry.largeFractionResult, return undefined.
     */
    static solveCoffs(a0, a1) {
        return Geometry_1.Geometry.conditionalDivideFraction(-a0, (a1 - a0));
    }
    /** evaluate the basis functions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        if (!result)
            result = new Float64Array(2);
        result[0] = 1.0 - u;
        result[1] = u;
        return result;
    }
    /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctions(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1.0 - u;
        for (let i = 0; i < n; i++) {
            result[i] = v * polygon[i] + u * polygon[i + n];
        }
        return result;
    }
    /** evaluate the blocked derivative at u.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctionDerivatives(_u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        for (let i = 0; i < n; i++) {
            result[i] = polygon[i + n] - polygon[i];
        }
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        return (1.0 - u) * this.coffs[0] + u * this.coffs[1];
    }
    /** Same as `roots` method but returns single numeric value instead of array. */
    solve(rightHandSide) {
        const df = this.coffs[1] - this.coffs[0];
        return Geometry_1.Geometry.conditionalDivideFraction(rightHandSide - this.coffs[0], df);
    }
    /**
     * Concrete implementation of the abstract roots method
     * @param targetValue target function value.
     * @param restrictTo01 flag for optional second step to eliminate root outside 0..1.
     * @returns If no roots, return undefined.  If single root, return an array with the root.
     */
    roots(targetValue, restrictTo01) {
        const x = this.solve(targetValue);
        if (x === undefined)
            return undefined;
        if (!restrictTo01 || Geometry_1.Geometry.isIn01(x))
            return [x];
        return undefined;
    }
}
exports.Order2Bezier = Order2Bezier;
/** Bezier polynomial specialized to order 3 (3 coefficients, parabola  function)
 * @internal
 */
class Order3Bezier extends BezierCoffs {
    constructor(f0 = 0, f1 = 0, f2 = 0) {
        super(3);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
        this.coffs[2] = f2;
    }
    /** Return a deep copy. */
    clone() {
        return new Order3Bezier(this.coffs[0], this.coffs[1], this.coffs[2]);
    }
    /** evaluate the basis functions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        if (!result)
            result = new Float64Array(3);
        const v = 1.0 - u;
        result[0] = v * v;
        result[1] = 2.0 * u * v;
        result[2] = u * u;
        return result;
    }
    /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctions(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1 - u;
        const b0 = v * v;
        const b1 = 2 * u * v;
        const b2 = u * u;
        for (let i = 0; i < n; i++) {
            result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n];
        }
        return result;
    }
    /** evaluate the blocked derivative at u.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctionDerivatives(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const f0 = 2 * (1 - u);
        const f1 = 2 * u;
        const n2 = 2 * n;
        for (let i = 0; i < n; i++) {
            const q = polygon[i + n];
            result[i] = f0 * (q - polygon[i]) + f1 * (polygon[i + n2] - q);
        }
        return result;
    }
    /**
     * Add the square of a linear bezier.
     * @param f0 linear factor value at u=0.
     * @param f1 linear factor value at u=1.
     * @param a  scale factor.
     */
    addSquareLinear(f0, f1, a) {
        this.coffs[0] += a * f0 * f0;
        this.coffs[1] += a * f0 * f1;
        this.coffs[2] += a * f1 * f1;
    }
    /**
     * Concrete implementation of the abstract roots method
     * @param targetValue target function value.
     * @param restrictTo01 flag for optional second step to eliminate root outside 0..1.
     * @returns If no roots, return undefined.  If roots exist, return as numeric array.
     */
    roots(targetValue, restrictTo01) {
        const a0 = this.coffs[0] - targetValue;
        const a1 = this.coffs[1] - targetValue;
        const a2 = this.coffs[2] - targetValue;
        const a01 = a1 - a0;
        const a12 = a2 - a1;
        const a012 = a12 - a01;
        const roots = Polynomials_1.Degree2PowerPolynomial.solveQuadratic(a012, 2.0 * a01, a0);
        return super.filter01(roots, restrictTo01);
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        const v = 1.0 - u;
        return this.coffs[0] * v * v + u * (2.0 * this.coffs[1] * v + this.coffs[2] * u);
    }
}
exports.Order3Bezier = Order3Bezier;
/** Bezier polynomial specialized to order 4 (4 coefficients, cubic  function)
 * @internal
 */
class Order4Bezier extends BezierCoffs {
    constructor(f0 = 0, f1 = 0, f2 = 0, f3 = 0) {
        super(4);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
        this.coffs[2] = f2;
        this.coffs[3] = f3;
    }
    /** return a deep copy */
    clone() {
        return new Order4Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3]);
    }
    /** Create a product of a quadratic and a cubic. */
    static createProductOrder3Order2(factorA, factorB) {
        return new Order4Bezier(factorA.coffs[0] * factorB.coffs[0], (factorA.coffs[0] * factorB.coffs[1] + 2.0 * factorA.coffs[1] * factorB.coffs[0]) / 3.0, (2.0 * factorA.coffs[1] * factorB.coffs[1] + factorA.coffs[2] * factorB.coffs[0]) / 3.0, factorA.coffs[2] * factorB.coffs[1]);
    }
    /** evaluate the basis functions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        if (!result)
            result = new Float64Array(4);
        const v = 1.0 - u;
        const uu = u * u;
        const vv = v * v;
        result[0] = vv * v;
        result[1] = 3.0 * vv * u;
        result[2] = 3.0 * v * uu;
        result[3] = u * uu;
        return result;
    }
    /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctions(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1 - u;
        const uu = u * u;
        const vv = v * v;
        const b0 = v * vv;
        const b1 = 3 * u * vv;
        const b2 = 3 * uu * v;
        const b3 = u * uu;
        for (let i = 0; i < n; i++) {
            result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n] + b3 * polygon[i + 3 * n];
        }
        return result;
    }
    /** evaluate the blocked derivative at u.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctionDerivatives(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1 - u;
        // QUADRATIC basis functions applied to differences ... (with factor 3 for derivative)
        const f0 = 3 * (v * v);
        const f1 = 6 * u * v;
        const f2 = 3 * u * u;
        for (let i = 0; i < n; i++) {
            const q0 = polygon[i];
            const q1 = polygon[i + n];
            const q2 = polygon[i + 2 * n];
            const q3 = polygon[i + 3 * n];
            result[i] = f0 * (q1 - q0) + f1 * (q2 - q1) + f2 * (q3 - q2);
        }
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        const v1 = 1.0 - u;
        const v2 = v1 * v1;
        const v3 = v2 * v1;
        return this.coffs[0] * v3
            + u * (3.0 * this.coffs[1] * v2
                + u * (3.0 * this.coffs[2] * v1
                    + u * this.coffs[3]));
    }
    /**
     * convert a power polynomial to bezier
     */
    static createFromDegree3PowerPolynomial(source) {
        const f0 = source.evaluate(0.0);
        const d0 = source.evaluateDerivative(0.0);
        const d1 = source.evaluateDerivative(1.0);
        const f1 = source.evaluate(1.0);
        const a = 3.0;
        return new Order4Bezier(f0, f0 + d0 / a, f1 - d1 / a, f1);
    }
    /** Find real roots, return in caller-allocated array. */
    realRoots(e, restrictTo01, roots) {
        // Get direct solutions in standard basis
        roots.clear();
        const cc = new Float64Array(4);
        const y0 = this.coffs[0];
        const y1 = this.coffs[1];
        const y2 = this.coffs[2];
        const y3 = this.coffs[3];
        const yMax = Math.max(y0, y1, y2, y3);
        const yMin = Math.min(y0, y1, y2, y3);
        const smallValue = Geometry_1.Geometry.smallMetricDistance;
        if (yMin > smallValue)
            return undefined;
        if (yMax < -smallValue)
            return undefined;
        if (yMin >= -smallValue && yMax < smallValue) {
            // all 4 are near zero . ..
            roots.push(0);
            roots.push(1.0 / 3.0);
            roots.push(2.0 / 3.0);
            roots.push(1.0);
            return; // p(x) == 0 has infinite roots .... return 4, which is a red flag for cubic
        }
        cc[0] = (y0 - e);
        cc[1] = 3.0 * (y1 - y0);
        cc[2] = 3.0 * (y0 - 2.0 * y1 + y2);
        cc[3] = -y0 + 3.0 * y1 - 3.0 * y2 + y3;
        Polynomials_1.AnalyticRoots.appendCubicRoots(cc, roots); // can't have zero solutions after passing min/max conditions . . .
        if (restrictTo01)
            roots.reassign(0, 1);
        return;
    }
}
exports.Order4Bezier = Order4Bezier;
/** Bezier polynomial specialized to order 5 (5 coefficients, quartic  function)
 * @internal
 */
class Order5Bezier extends BezierCoffs {
    constructor(f0 = 0, f1 = 0, f2 = 0, f3 = 0, f4 = 0) {
        super(5);
        this.coffs[0] = f0;
        this.coffs[1] = f1;
        this.coffs[2] = f2;
        this.coffs[3] = f3;
        this.coffs[4] = f4;
    }
    /** Return a deep copy */
    clone() {
        return new Order5Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3], this.coffs[4]);
    }
    /**
     * convert a power polynomial to bezier
     */
    static createFromDegree4PowerPolynomial(source) {
        const f0 = source.evaluate(0.0);
        const d0 = source.evaluateDerivative(0.0);
        const d4 = source.evaluateDerivative(1.0);
        const f4 = source.evaluate(1.0);
        const a = 0.25;
        const d0a = a * d0;
        const fa = f0 + d0a;
        const fm = 2.0 * fa - f0 + source.coffs[2] / 6.0;
        return new Order5Bezier(f0, fa, fm, f4 - d4 * a, f4);
    }
    /** evaluate the basis functions at specified u.
     * @param u bezier parameter for evaluation.
     * @returns Return a (newly allocated) array of basis function values.
     */
    basisFunctions(u, result) {
        if (!result)
            result = new Float64Array(5);
        const v = 1.0 - u;
        const uu = u * u;
        const uuu = uu * u;
        const vv = v * v;
        const vvv = vv * v;
        result[0] = vv * vv;
        result[1] = 4.0 * vvv * u;
        result[2] = 6.0 * vv * uu;
        result[3] = 4.0 * v * uuu;
        result[4] = uu * uu;
        return result;
    }
    /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctions(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1.0 - u;
        const uu = u * u;
        const uuu = uu * u;
        const vv = v * v;
        const vvv = vv * v;
        const b0 = vv * vv;
        const b1 = 4.0 * vvv * u;
        const b2 = 6.0 * vv * uu;
        const b3 = 4.0 * v * uuu;
        const b4 = uu * uu;
        for (let i = 0; i < n; i++) {
            result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n] + b3 * polygon[i + 3 * n] + b4 * polygon[i + 4 * n];
        }
        return result;
    }
    /** evaluate the blocked derivative at u.
     * @param u bezier parameter for evaluation.
     * @param n dimension of control points.
     * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.
     * @param result optional destination for values.   ASSUMED size `order`
     * @returns Return a (newly allocated) array of basis function values.
     */
    sumBasisFunctionDerivatives(u, polygon, n, result) {
        if (!result)
            result = new Float64Array(n);
        const v = 1 - u;
        // CUBIC basis functions applied to differences ...
        const uu = u * u;
        const vv = v * v;
        const f0 = 4 * v * vv;
        const f1 = 12 * u * vv;
        const f2 = 12 * uu * v;
        const f3 = 4 * u * uu;
        for (let i = 0; i < n; i++) {
            const q0 = polygon[i];
            const q1 = polygon[i + n];
            const q2 = polygon[i + 2 * n];
            const q3 = polygon[i + 3 * n];
            const q4 = polygon[i + 4 * n];
            result[i] = f0 * (q1 - q0) + f1 * (q2 - q1) + f2 * (q3 - q2) + f3 * (q4 - q3);
        }
        return result;
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluate(u) {
        const v1 = 1.0 - u;
        const v2 = v1 * v1;
        const v3 = v2 * v1;
        const v4 = v2 * v2;
        return this.coffs[0] * v4
            + u * (4.0 * this.coffs[1] * v3
                + u * (6.0 * this.coffs[2] * v2
                    + u * (4.0 * this.coffs[3] * v1
                        + u * this.coffs[4])));
    }
    /** Add the product of a pair of Order3Bezier to this one. */
    addProductOrder3BezierOrder3Bezier(f, g, a) {
        this.coffs[0] += a * f.coffs[0] * g.coffs[0];
        this.coffs[1] += a * (f.coffs[0] * g.coffs[1] + f.coffs[1] * g.coffs[0]) * 0.5;
        this.coffs[2] += a * (f.coffs[0] * g.coffs[2] + 4.0 * f.coffs[1] * g.coffs[1] + f.coffs[2] * g.coffs[0]) / 6.0;
        this.coffs[3] += a * (f.coffs[1] * g.coffs[2] + f.coffs[2] * g.coffs[1]) * 0.5;
        this.coffs[4] += a * f.coffs[2] * g.coffs[2];
    }
    /** Add a constant to all coefficients (thereby adding the constant to the evaluated bezier) */
    addConstant(a) {
        for (let i = 0; i < 5; i++)
            this.coffs[i] += a;
    }
    /** Find real roots, return in caller-allocated array. */
    realRoots(e, restrictTo01, roots) {
        roots.clear();
        const y0 = this.coffs[0] - e;
        const y1 = this.coffs[1] - e;
        const y2 = this.coffs[2] - e;
        const y3 = this.coffs[3] - e;
        const y4 = this.coffs[4] - e;
        // Get direct solutions in standard basis
        const yMax = Math.max(y0, y1, y2, y3, y4);
        const yMin = Math.min(y0, y1, y2, y3, y4);
        const smallValue = Geometry_1.Geometry.smallMetricDistance;
        if (yMin > smallValue)
            return undefined;
        if (yMax < -smallValue)
            return undefined;
        if (yMin >= -smallValue && yMax < smallValue) {
            // all 4 are near zero . ..
            roots.push(0);
            roots.push(0.25);
            roots.push(0.5);
            roots.push(0.75);
            roots.push(1.0);
            return; // p(x) == 0 has infinite roots .... return 5, which is a red flag for cubic ...
        }
        const cc = new Float64Array(5);
        cc[0] = (y0 - e);
        cc[1] = 4.0 * (-y0 + y1);
        cc[2] = 6.0 * (y0 - 2.0 * y1 + y2);
        cc[3] = 4.0 * (-y0 + 3.0 * y1 - 3.0 * y2 + y3);
        cc[4] = (y0 - 4.0 * y1 + 6.0 * y2 - 4.0 * y3 + y4);
        Polynomials_1.AnalyticRoots.appendQuarticRoots(cc, roots);
        if (restrictTo01)
            roots.reassign(0, 1);
        return;
    }
}
exports.Order5Bezier = Order5Bezier;


/***/ }),

/***/ "./lib/numerics/ClusterableArray.js":
/*!******************************************!*\
  !*** ./lib/numerics/ClusterableArray.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const GrowableBlockedArray_1 = __webpack_require__(/*! ../geometry3d/GrowableBlockedArray */ "./lib/geometry3d/GrowableBlockedArray.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
/**
 * Blocked array with operations to sort and cluster with a tolerance.
 * * Primary sorting is along an "arbitrary" sort vector.
 * @internal
 */
class ClusterableArray extends GrowableBlockedArray_1.GrowableBlockedArray {
    /**
     * @param numCoordinatePerPoint number of coordinates per point
     * @param  numExtraDataPerPoint of extra data values per point.
     * @param initialBlockCapacity predicted number of points.  (This does not have to be accurate)
     */
    constructor(numCoordinatePerPoint, numExtraDataPerPoint, initialBlockCapacity) {
        super(1 + numCoordinatePerPoint + numExtraDataPerPoint, initialBlockCapacity);
        this._numExtraDataPerPoint = numExtraDataPerPoint;
        this._numCoordinatePerPoint = numCoordinatePerPoint;
    }
    /** Return a component of the sort vector. */
    static sortVectorComponent(index) {
        let c = 1.0;
        for (let i = 1; i < index; i++)
            c *= ClusterableArray._vectorFactor;
        return c;
    }
    /** load a block, placing data[i] at block[i+1] to allow sort coordinate first.
     * @param data array of numDataPerBlock values.
     */
    addBlock(data) {
        const i0 = this.newBlockIndex() + 1;
        const n = Math.min(this.numPerBlock - 1, data.length);
        for (let i = 0; i < n; i++)
            this._data[i0 + i] = data[i];
    }
    /** add a block with directly 2 to 5 listed content parameters.
     * This assumes numDataPerPoint is sufficient for the parameters provided.
     */
    addDirect(x0, x1, x2, x3, x4) {
        const i0 = this.newBlockIndex();
        this._data[i0 + 1] = x0;
        this._data[i0 + 2] = x1;
        if (x2 !== undefined)
            this._data[i0 + 3] = x2;
        if (x3 !== undefined)
            this._data[i0 + 4] = x3;
        if (x4 !== undefined)
            this._data[i0 + 5] = x4;
    }
    /** add a block directly from a Point2d with 0 to 3 extras
     * This assumes numDataPerPoint is sufficient for the parameters provided.
     */
    addPoint2d(xy, a, b, c) {
        const i0 = this.newBlockIndex();
        this._data[i0 + 1] = xy.x;
        this._data[i0 + 2] = xy.y;
        if (a !== undefined)
            this._data[i0 + 3] = a;
        if (b !== undefined)
            this._data[i0 + 4] = b;
        if (c !== undefined)
            this._data[i0 + 5] = c;
    }
    /** add a block with directly from a Point2d with 0 to 3 extras
     * This assumes numDataPerPoint is sufficient for the parameters provided.
     */
    addPoint3d(xyz, a, b, c) {
        const i0 = this.newBlockIndex();
        this._data[i0 + 1] = xyz.x;
        this._data[i0 + 2] = xyz.y;
        this._data[i0 + 3] = xyz.z;
        if (a !== undefined)
            this._data[i0 + 4] = a;
        if (b !== undefined)
            this._data[i0 + 5] = b;
        if (c !== undefined)
            this._data[i0 + 6] = c;
    }
    /** Get the xy coordinates by point index. */
    getPoint2d(blockIndex, result) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return Point2dVector2d_1.Point2d.create(this._data[i0 + 1], this._data[i0 + 2], result);
    }
    /** Get the xyZ coordinates by point index. */
    getPoint3d(blockIndex, result) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return Point3dVector3d_1.Point3d.create(this._data[i0 + 1], this._data[i0 + 2], this._data[i0 + 3], result);
    }
    /** Return a single extra data value */
    getExtraData(blockIndex, i) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return this._data[i0 + 1 + this._numCoordinatePerPoint + i];
    }
    /** Return a single data value */
    getData(blockIndex, i) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        return this._data[i0 + i];
    }
    /** Set a single extra data value */
    setExtraData(blockIndex, i, value) {
        const i0 = this.blockIndexToDoubleIndex(blockIndex);
        this._data[i0 + 1 + this._numCoordinatePerPoint + i] = value;
    }
    /** Test if `x` is the cluster terminator value. */
    static isClusterTerminator(x) { return x === ClusterableArray.clusterTerminator; }
    /** Return an array giving clusters of blocks with similar coordinates.
     *
     * * The contents of each block is assumed to be set up so the primary sort coordinate is first.
     *
     * ** simple coordinate blocks (x,y) or (x,y,z) would work fine but have occasional performance problems because points with same x would generate big blocks of
     * candidates for clusters.
     * ** The usual solution is to u value which is a dot product along some skew direction and have the blocks contain (u,x,y) or (u,x,y,z) for 2d versus 3d.
     * ** apply setupPrimaryClusterSort to prepare that!!!
     * * After a simple lexical sort, consecutive blocks that are within tolerance in the 0 component
     * are inspected.  Within that candidate set, all blocks that are within tolerance for ALL components are clustered.
     * * In the output cluster array, clusters are terminated a invalid index. Test for the invalid index with GrowableBlockArray.isClusterTerminator (x)
     */
    clusterIndicesLexical(clusterTolerance = Geometry_1.Geometry.smallMetricDistance) {
        // install primary sort key
        this.setupPrimaryClusterSort();
        // presort by all coordinates ....
        const firstSort = this.sortIndicesLexical();
        const clusterIndices = new Uint32Array(2 * firstSort.length); // worst case: no duplicates, each index goes in followed by terminator.
        let m = 0; // number of cluster indices
        const n = this.numBlocks; // and this must match firstSort.length !!
        let clusterStartBlockIndex = 0;
        let candidateBlockIndex = 0;
        let barrierU = 0.0;
        let i = 0;
        let j = 0;
        const k0 = 1; // beginning of active column for distance
        const k1 = 1 + this._numCoordinatePerPoint;
        for (i = 0; i < n; i++) {
            clusterStartBlockIndex = firstSort[i];
            if (!ClusterableArray.isClusterTerminator(clusterStartBlockIndex)) {
                // unused block, so it becomes a cluster...
                clusterIndices[m++] = clusterStartBlockIndex;
                barrierU = this.component(clusterStartBlockIndex, 0) + clusterTolerance;
                firstSort[i] = ClusterableArray.clusterTerminator;
                for (j = i + 1; j < n; j++) {
                    candidateBlockIndex = firstSort[j];
                    if (candidateBlockIndex === ClusterableArray.clusterTerminator)
                        continue; // nearby in sort direction but already in a cluster.
                    if (this.component(candidateBlockIndex, 0) >= barrierU)
                        break;
                    if (this.distanceBetweenSubBlocks(clusterStartBlockIndex, candidateBlockIndex, k0, k1) < clusterTolerance) {
                        clusterIndices[m++] = candidateBlockIndex; // The candidate is in the block
                        firstSort[j] = ClusterableArray.clusterTerminator; // and it will not be reused as future block base
                    }
                }
                clusterIndices[m++] = ClusterableArray.clusterTerminator;
            }
        }
        // Alas, the clusterIndices array has fluff at the end.  So it has to be copied.
        return clusterIndices.slice(0, m);
    }
    /** setup (overwrite!!) the "0" component with the dot product of numClusterCoordinate later components with a non-axis aligned vector.
     * This is normally called before clusterIndicesLexical.
     */
    setupPrimaryClusterSort() {
        const nb = this.numBlocks;
        const nc = this._numCoordinatePerPoint;
        const vector = new Float64Array(nc);
        vector[0] = 1.0;
        for (let c = 1; c < nc; c++)
            vector[c] = vector[c - 1] * ClusterableArray._vectorFactor;
        let k = 0;
        let dot = 0.0;
        const data = this._data;
        for (let b = 0; b < nb; b++) {
            k = this.blockIndexToDoubleIndex(b);
            dot = 0.0;
            for (let c = 0; c < nc; c++) {
                dot += vector[c] * data[k + 1 + c];
            }
            data[k] = dot;
        }
    }
    /** Convert the cluster data to an array of tuples with point i in the form
     * `[i, primarySortCoordinate, [x,y,..], [extraData0, extraData1, ...]]`
     */
    toJSON() {
        const result = [];
        for (let b = 0; b < this.numBlocks; b++) {
            let i = this.blockIndexToDoubleIndex(b);
            const chunk = [b, this._data[i++]];
            const coordinates = [];
            for (let c = 0; c < this._numCoordinatePerPoint; c++)
                coordinates.push(this._data[i++]);
            chunk.push(coordinates);
            for (let c = 0; c < this._numExtraDataPerPoint; c++)
                chunk.push(this._data[i++]);
            result.push(chunk);
        }
        return result;
    }
    /**
     * Return an array of indices from block index to cluster index.
     * @param clusteredBlocks clusters of block indices followed by separators.
     */
    createIndexBlockToClusterIndex(clusteredBlocks) {
        const numBlocks = this.numBlocks;
        const blockToCluster = new Uint32Array(numBlocks);
        blockToCluster.fill(ClusterableArray.clusterTerminator);
        let numCluster = 0;
        for (const b of clusteredBlocks) {
            if (b >= numBlocks) {
                numCluster++;
            }
            else {
                blockToCluster[b] = numCluster;
            }
        }
        return blockToCluster;
    }
    /**
     * Return an array of indices from block index to index of its cluster's start in the cluster index array.
     * @param clusteredBlocks clusters of block indices followed by separators.
     */
    createIndexBlockToClusterStart(clusteredBlocks) {
        const n = clusteredBlocks.length;
        const numBlocks = this.numBlocks;
        const blockToClusterStart = new Uint32Array(numBlocks);
        const terminator = ClusterableArray.clusterTerminator;
        blockToClusterStart.fill(terminator);
        let clusterStart = 0;
        for (let i = 0; i < n; i++) {
            const k = clusteredBlocks[i];
            if (k > numBlocks) {
                clusterStart = i + 1;
            }
            else {
                blockToClusterStart[k] = clusterStart;
            }
        }
        return blockToClusterStart;
    }
    /** count the clusters in the clusteredBlocks array. */
    countClusters(clusteredBlocks) {
        let numClusters = 0;
        const terminator = ClusterableArray.clusterTerminator;
        for (const b of clusteredBlocks) {
            if (b === terminator)
                numClusters++;
        }
        return numClusters;
    }
    /** create a reverse index: given a cluster index k, clusterToClusterStart[k] is the place
     * the cluster's block indices appear in clusterBlocks
     */
    createIndexClusterToClusterStart(clusteredBlocks) {
        let numCluster = this.countClusters(clusteredBlocks);
        const clusterToClusterStart = new Uint32Array(numCluster);
        const terminator = ClusterableArray.clusterTerminator;
        clusterToClusterStart.fill(terminator);
        const n = clusteredBlocks.length;
        let clusterStart = 0;
        for (let i = 0; i < n; i++) {
            const k = clusteredBlocks[i];
            if (k === terminator) {
                clusterStart = i + 1;
            }
            else if (i === clusterStart) {
                clusterToClusterStart[numCluster++] = clusterStart;
            }
        }
        return clusterToClusterStart;
    }
    /**
     * Sort terminator-delimited subsets of an array of indices into the table, using a single extraData index as sort key.
     * @param blockedIndices [in] indices, organized as blocks of good indices terminated by the clusterTerminator.
     * @param extraDataIndex index of the extra data key.
     */
    sortSubsetsBySingleKey(blockedIndices, dataIndex) {
        const dataOffset = 1 + dataIndex;
        let kBegin = 0;
        let swap;
        let key0, key1;
        const numK = blockedIndices.length;
        for (let kEnd = 0; kEnd < numK; kEnd++) {
            if (blockedIndices[kEnd] === ClusterableArray.clusterTerminator) {
                // sort blockedIndices[kBegin ,= k < kEnd].
                //  (search for minimum remaining, swap  . . )
                for (let k0 = kBegin; k0 + 1 < kEnd; k0++) {
                    key0 = this.getWithinBlock(blockedIndices[k0], dataOffset);
                    for (let k1 = k0 + 1; k1 < kEnd; k1++) {
                        key1 = this.getWithinBlock(blockedIndices[k1], dataOffset);
                        if (key1 < key0) {
                            swap = blockedIndices[k0];
                            blockedIndices[k0] = blockedIndices[k1];
                            blockedIndices[k1] = swap;
                            key0 = key1;
                        }
                    }
                }
                kBegin = kEnd + 1;
            }
        }
    }
    /**
     * Returns packed points with indices mapping old to new.
     * @param data points to cluster.
     */
    static clusterPoint3dArray(data, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        const clusterArray = new ClusterableArray(3, 0, data.length);
        data.forEach((p) => {
            clusterArray.addDirect(p.x, p.y, p.z);
        });
        const order = clusterArray.clusterIndicesLexical(tolerance);
        const result = new PackedPointsWithIndex(data.length);
        let currentClusterIndex = 0;
        let numThisCluster = 0;
        order.forEach((k) => {
            if (ClusterableArray.isClusterTerminator(k)) {
                currentClusterIndex++;
                numThisCluster = 0;
            }
            else {
                if (numThisCluster === 0)
                    result.packedPoints.push(data[k].clone());
                result.oldToNew[k] = currentClusterIndex;
                numThisCluster++;
            }
        });
        return result;
    }
    /**
     * Returns packed points with indices mapping old to new.
     * @param data points to cluster.
     */
    static clusterGrowablePoint3dArray(source, tolerance = Geometry_1.Geometry.smallMetricDistance) {
        const clusterArray = new ClusterableArray(3, 0, source.length);
        const p = Point3dVector3d_1.Point3d.create();
        const numSourcePoint = source.length;
        for (let i = 0; i < numSourcePoint; i++) {
            source.getPoint3dAtUncheckedPointIndex(i, p);
            clusterArray.addDirect(p.x, p.y, p.z);
        }
        const order = clusterArray.clusterIndicesLexical(tolerance);
        const result = new PackedPointsWithIndex(source.length);
        const numPackedPoints = clusterArray.countClusters(order);
        result.growablePackedPoints = new GrowableXYZArray_1.GrowableXYZArray(numPackedPoints);
        let currentClusterIndex = 0;
        let numThisCluster = 0;
        order.forEach((k) => {
            if (ClusterableArray.isClusterTerminator(k)) {
                currentClusterIndex++;
                numThisCluster = 0;
            }
            else {
                if (numThisCluster === 0) // This is the first encounter with a new cluster
                    result.growablePackedPoints.pushFromGrowableXYZArray(source, k);
                result.oldToNew[k] = currentClusterIndex;
                numThisCluster++;
            }
        });
        return result;
    }
}
exports.ClusterableArray = ClusterableArray;
//  (This is pretty strange)
// The sort vector is (1,c, c*c, ...)
// Settint c = 1 makes it 1,1,1 which may be useful for visual scans during debug.
// c wuith some inobvious digits makes it unlikley tha there will be multiple points on a perpendicular to the sort vector.
ClusterableArray._vectorFactor = 0.8732; // use 1.0 to rig easy tests.
/** this value is used as cluster terminator in the Uint232rray of indcies. */
ClusterableArray.clusterTerminator = 0xFFffFFff;
/**
 * Data carrier class for
 * * packedPoints = an array of Point3d
 * * oldToNew = array of indices from some prior Point3d[] to the packed points.
 * @internal
 */
class PackedPointsWithIndex {
    /** construct a PackedPoints object with
     * * empty packedPoints array
     * * oldToNew indices all initialized to PackedPoints.invalidIndex
     */
    constructor(numOldIndexEntry) {
        this.packedPoints = [];
        this.oldToNew = new Uint32Array(numOldIndexEntry);
        for (let i = 0; i < numOldIndexEntry; i++) {
            this.oldToNew[i] = PackedPointsWithIndex.invalidIndex;
        }
    }
    /**
     * Use the oldToNew array to update an array of "old" indices.
     * @param indices array of indices into prepacked array.
     * @returns true if all input indices were valid for the oldToNew array.
     */
    updateIndices(indices) {
        let numErrors = 0;
        indices.forEach((value, i, data) => {
            if (value < this.oldToNew.length) {
                data[i] = this.oldToNew[value];
            }
            else
                numErrors++;
        });
        return numErrors === 0;
    }
}
/** integer value for unknown index. */
PackedPointsWithIndex.invalidIndex = 0xFFFFffff;


/***/ }),

/***/ "./lib/numerics/Complex.js":
/*!*********************************!*\
  !*** ./lib/numerics/Complex.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
/**
 * OPerations on a "complex number" class with real part `x` and complex part `y`
 * @internal
 */
class Complex {
    constructor(x = 0, y = 0) { this._x = x; this._y = y; }
    /** (propety set) Real part */
    set x(value) { this._x = value; }
    /** (propety get) Real part */
    get x() { return this._x; }
    /** (propety set) Imaginary part */
    set y(value) { this._y = value; }
    /** (propety get) Imaginary part */
    get y() { return this._y; }
    /** set x and y parts from args. */
    set(x = 0, y = 0) { this.x = x; this.y = y; }
    /** set `this.x` and `this.y` from `other.x` and `other.y` */
    setFrom(other) { this.x = other.x; this.y = other.y; }
    /** clone the complex x,y */
    clone() { return new Complex(this.x, this.y); }
    /** test for near equality using coordinate tolerances */
    isAlmostEqual(other) { return Geometry_1.Geometry.isAlmostEqualNumber(this.x, other.x) && Geometry_1.Geometry.isAlmostEqualNumber(this.x, other.x); }
    /** Create a new Complex instance from given x and y. */
    static create(x = 0, y = 0, result) {
        if (result) {
            result.x = x;
            result.y = y;
            return result;
        }
        return new Complex(x, y);
    }
    /** Return the complex sum `this+other` */
    plus(other, result) { return Complex.create(this.x + other.x, this.y + other.y, result); }
    /** Return the complex difference  `this-other` */
    minus(other, result) { return Complex.create(this.x - other.x, this.y - other.y, result); }
    /** Return the complex product  `this * other` */
    times(other, result) {
        return Complex.create(this.x * other.x - this.y * other.y, this.x * other.y + this.y * other.x, result);
    }
    /** Return the complex product `this * x+i*y`. That is, the second Complex value exists via the args without being formally created as an instance. */
    timesXY(x, y, result) {
        return Complex.create(this.x * x - this.y * y, this.x * y + this.y * x, result);
    }
    /** Return the mangitude of the complex number */
    magnitude() { return Geometry_1.Geometry.hypotenuseXY(this.x, this.y); }
    /** Return the angle from x axis to the vector (x,y) */
    angle() { return Angle_1.Angle.createAtan2(this.y, this.x); }
    /** Return the xy plane distance between this and other */
    distance(other) {
        return Geometry_1.Geometry.hypotenuseXY(this.x - other.x, this.y - other.y);
    }
    /** Return the squared xy plane distance between this and other. */
    magnitudeSquared() { return this.x * this.x + this.y * this.y; }
    /** Return the complex division `this / other` */
    divide(other, result) {
        const bb = other.magnitudeSquared();
        if (bb === 0.0)
            return undefined;
        const divbb = 1.0 / bb;
        return Complex.create((this.x * other.x + this.y * other.y) * divbb, (this.y * other.x - this.x * other.y) * divbb, result);
    }
    /** Return the complex square root of this. */
    sqrt(result) {
        if ((this.x === 0.0) && (this.y === 0.0))
            return Complex.create(0, 0, result);
        const x = Math.abs(this.x);
        const y = Math.abs(this.y);
        let r = 0;
        let w = 0;
        if (x >= y) {
            r = y / x;
            w = Math.sqrt(x) * Math.sqrt(0.5 * (1.0 + Math.sqrt(1.0 + r * r)));
        }
        else {
            r = x / y;
            w = Math.sqrt(y) * Math.sqrt(0.5 * (r + Math.sqrt(1.0 + r * r)));
        }
        if (this.x >= 0.0) {
            return Complex.create(w, this.y / (2.0 * w), result);
        }
        else {
            const y1 = (this.y >= 0) ? w : -w;
            return Complex.create(this.y / (2.0 * y1), y1, result);
        }
    }
    /** set the complex x,y from a json object of the form like
     * * x,y key value pairs:   `{x:1,y:2}`
     * * array of numbers:  `[1,2]`
     */
    setFromJSON(json) {
        if (Array.isArray(json) && json.length > 1) {
            this.set(json[0], json[1]);
        }
        else if (json && json.x && json.y) {
            this.set(json.x, json.y);
        }
        else {
            this.set(0, 0);
        }
    }
    /** Create a `Complex` instance from a json object. */
    static fromJSON(json) { const result = new Complex(); result.setFromJSON(json); return result; }
    /**
     * Convert an Complex to a JSON object.
     * @return {*} [x,y]
     */
    toJSON() { return [this.x, this.y]; }
}
exports.Complex = Complex;


/***/ }),

/***/ "./lib/numerics/ConvexPolygon2d.js":
/*!*****************************************!*\
  !*** ./lib/numerics/ConvexPolygon2d.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * Ray with xy origin and direction
 * @internal
 */
class Ray2d {
    constructor(origin, direction) {
        this._origin = origin;
        this._direction = direction;
    }
    /** Create from 2d `origin` and `target`.
     * * `target - origin` is the direction vector.
     */
    static createOriginAndTarget(origin, target) {
        return new Ray2d(origin.clone(), origin.vectorTo(target));
    }
    /** Create from (clones of) `origin` point and `direction` vector */
    static createOriginAndDirection(origin, direction) {
        return new Ray2d(origin.clone(), direction.clone());
    }
    /** Capture `origin` and `direction` as ray member variables. */
    static createOriginAndDirectionCapture(origin, direction) {
        return new Ray2d(origin, direction);
    }
    /** Get the (REFERENCE TO) the ray origin. */
    get origin() { return this._origin; }
    /** Get the (REFERENCE TO) the ray direction. */
    get direction() { return this._direction; }
    /**
     *  Return a ray that is parallel at distance to the left, specified as fraction of the ray's direction vector.
     */
    parallelRay(leftFraction) {
        return new Ray2d(this._origin.addForwardLeft(0.0, leftFraction, this._direction), this._direction);
    }
    /** Return a ray with same origin, direction rotated 90 degrees counterclockwise */
    ccwPerpendicularRay() {
        return new Ray2d(this._origin, this._direction.rotate90CCWXY());
    }
    /** Return a ray with same origin, direction rotated 90 degrees clockwise */
    cwPerpendicularRay() {
        return new Ray2d(this._origin, this._direction.rotate90CWXY());
    }
    /** Normalize the direction vector in place. */
    normalizeDirectionInPlace() {
        if (this._direction.normalize(this._direction)) {
            return true;
        }
        else {
            this._direction.x = 1.0;
            this._direction.y = 0.0;
            // magnitude = 0.0;
            return false;
        }
    }
    /**
     * Intersect this ray (ASSUMED NORMALIZED) with unbounded line defined by points.
     *  (The normalization assumption affects test for parallel vectors.)
     *  Fraction and dHds passed as number[] to use by reference... Sticking to return of true and false in the case fraction is zero after
     *  a true safe divide
     */
    intersectUnboundedLine(linePointA, linePointB, fraction, dHds) {
        const lineDirection = linePointA.vectorTo(linePointB);
        const vector0 = linePointA.vectorTo(this._origin);
        const h0 = vector0.crossProduct(lineDirection);
        dHds[0] = this._direction.crossProduct(lineDirection);
        // h = h0 + s * dh
        const ff = Geometry_1.Geometry.conditionalDivideFraction(-h0, dHds[0]);
        if (ff !== undefined) {
            fraction[0] = ff;
            return true;
        }
        else {
            fraction[0] = 0.0;
            return false;
        }
    }
    /** return the ray fraction where point projects to the ray */
    projectionFraction(point) {
        return this._origin.vectorTo(point).fractionOfProjectionToVector(this._direction);
    }
    /** return the fraction of projection to the perpendicular ray */
    perpendicularProjectionFraction(point) {
        const uv = this._direction.crossProduct(this._origin.vectorTo(point));
        const uu = this._direction.magnitudeSquared();
        // Want zero returned if failure case, not undefined
        return Geometry_1.Geometry.safeDivideFraction(uv, uu, 0.0);
    }
    /** Return point from origin plus a scaled vector */
    fractionToPoint(f) {
        return this._origin.plusScaled(this._direction, f);
    }
}
exports.Ray2d = Ray2d;
/**
 * Convex hull of points in 2d.
 * @internal
 */
class ConvexPolygon2d {
    constructor(points) {
        this._hullPoints = [];
        // Deep copy of points array given
        for (const point of points) {
            this._hullPoints.push(point);
        }
    }
    /** Create the hull */
    static createHull(points) {
        return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));
    }
    /** Create the hull. First try to use the points as given. */
    static createHullIsValidCheck(points) {
        if (ConvexPolygon2d.isValidConvexHull(points))
            return new ConvexPolygon2d(points);
        else
            return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));
    }
    /** Return a reference of the hull points. */
    get points() {
        return this._hullPoints;
    }
    /** Test if hull points are a convex, CCW polygon */
    static isValidConvexHull(points) {
        if (points.length < 3)
            return false;
        const n = points.length;
        for (let i = 0; i < n; i++) {
            const i1 = (i + 1) % n;
            const i2 = (i + 2) % n;
            if (points[i].crossProductToPoints(points[i1], points[i2]) < 0.0)
                return false;
        }
        return true;
    }
    /** Return true if the convex hull (to the left of the edges) contains the test point */
    containsPoint(point) {
        let xy0 = this._hullPoints[this._hullPoints.length - 1];
        // double tol = -1.0e-20;  negative tol!!
        for (const i of this._hullPoints) {
            const xy1 = i;
            const c = xy0.crossProductToPoints(xy1, point);
            if (c < 0.0)
                return false;
            xy0 = i;
        }
        return true;
    }
    /** Return the largest outside. (return 0 if in or on) */
    distanceOutside(xy) {
        let maxDistance = 0.0;
        const n = this._hullPoints.length;
        let xy0 = this._hullPoints[n - 1];
        // double tol = -1.0e-20;  // negative tol!!
        for (let i = 0; i < n; i++) {
            const xy1 = this._hullPoints[i];
            const c = xy0.crossProductToPoints(xy1, xy);
            if (c < 0.0) {
                const ray = Ray2d.createOriginAndTarget(xy0, xy1);
                const s = ray.projectionFraction(xy);
                let d = 0.0;
                if (s < 0.0)
                    d = xy0.distance(xy);
                else if (s > 1.0)
                    d = xy1.distance(xy);
                else
                    d = xy.distance(ray.fractionToPoint(s));
                if (d > maxDistance)
                    maxDistance = d;
            }
            xy0 = this._hullPoints[i];
        }
        return maxDistance;
    }
    /** Offset the entire hull (in place) by distance.
     * Returns false if an undefined occurred from normalizing (could occur after changing some hull points already)
     */
    offsetInPlace(distance) {
        const n = this._hullPoints.length;
        if (n >= 3) {
            const hullPoint0 = this._hullPoints[0];
            let edgeA = this._hullPoints[n - 1].vectorTo(hullPoint0);
            edgeA = edgeA.normalize();
            if (edgeA === undefined) {
                return false;
            }
            let perpA = edgeA.rotate90CWXY();
            let edgeB;
            let perpB;
            for (let i = 0; i < n; i++) {
                const j = i + 1;
                edgeB = this._hullPoints[i].vectorTo(j < n ? this._hullPoints[j] : hullPoint0);
                edgeB = edgeB.normalize();
                if (edgeB === undefined) {
                    return false;
                }
                perpB = edgeB.rotate90CWXY();
                const offsetBisector = Point2dVector2d_1.Vector2d.createOffsetBisector(perpA, perpB, distance);
                if (offsetBisector === undefined) {
                    return false;
                }
                this._hullPoints[i] = this._hullPoints[i].plus(offsetBisector);
                // PerpA takes up reference to perpB, as perpB will die in new iteration
                perpA = perpB;
            }
        }
        return true;
    }
    /**
     * Return 2 distances bounding the intersection of the ray with a convex hull.
     * ASSUME (for tolerance) the ray has normalized direction vector.
     * Both negative and positive distances along the ray are possible.
     * Returns range with extremities if less than 3 points, distanceA > distanceB, or if cross product < 0
     */
    clipRay(ray) {
        let distanceA = -Number.MAX_VALUE;
        let distanceB = Number.MAX_VALUE;
        const n = this._hullPoints.length;
        if (n < 3)
            return Range_1.Range1d.createNull();
        let xy0 = this._hullPoints[n - 1];
        for (const xy1 of this._hullPoints) {
            const distance = [];
            const dHds = [];
            if (ray.intersectUnboundedLine(xy0, xy1, distance, dHds)) {
                if (dHds[0] > 0.0) {
                    if (distance[0] < distanceB)
                        distanceB = distance[0];
                }
                else {
                    if (distance[0] > distanceA)
                        distanceA = distance[0];
                }
                if (distanceA > distanceB)
                    return Range_1.Range1d.createNull();
            }
            else {
                // ray is parallel to the edge.
                // Any single point out classifies it all . ..
                if (xy0.crossProductToPoints(xy1, ray.origin) < 0.0)
                    return Range_1.Range1d.createNull();
            }
            // xy1 is reassigned with each new loop
            xy0 = xy1;
        }
        const range = Range_1.Range1d.createNull();
        range.extendX(distanceA);
        range.extendX(distanceB);
        return range;
    }
    /** Return the range of (fractional) ray positions for projections of all points from the arrays. */
    rangeAlongRay(ray) {
        const range = Range_1.Range1d.createNull();
        for (const xy1 of this._hullPoints)
            range.extendX(ray.projectionFraction(xy1));
        return range;
    }
    /** Return the range of (fractional) ray positions for projections of all points from the arrays. */
    rangePerpendicularToRay(ray) {
        const range = Range_1.Range1d.createNull();
        for (const xy1 of this._hullPoints)
            range.extendX(ray.perpendicularProjectionFraction(xy1));
        return range;
    }
    /** Computes the hull of a convex polygon from points given. Returns the hull as a new Point2d array.
     *  Returns an empty hull if less than 3 points are given.
     */
    static computeConvexHull(points) {
        const hull = [];
        const n = points.length;
        if (n < 3)
            return hull;
        // Get deep copy
        const xy1 = points.slice(0, n);
        xy1.sort(Geometry_1.Geometry.lexicalXYLessThan);
        hull.push(xy1[0]); // This is sure to stay
        hull.push(xy1[1]); // This one can be removed in loop.
        // First sweep creates upper hull
        for (let i = 2; i < n; i++) {
            const candidate = xy1[i];
            let top = hull.length - 1;
            while (top > 0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {
                top--;
                hull.pop();
            }
            hull.push(candidate);
        }
        // Second sweep creates lower hull right to left
        const i0 = hull.length - 1;
        // xy1.back () is already on stack.
        hull.push(xy1[n - 2]);
        for (let i = n - 2; i-- > 0;) {
            const candidate = xy1[i];
            let top = hull.length - 1;
            while (top > i0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {
                top--;
                hull.pop();
            }
            if (i > 0) // don't replicate start point!!!
                hull.push(candidate);
        }
        return hull;
    }
}
exports.ConvexPolygon2d = ConvexPolygon2d;


/***/ }),

/***/ "./lib/numerics/Newton.js":
/*!********************************!*\
  !*** ./lib/numerics/Newton.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const Polynomials_1 = __webpack_require__(/*! ./Polynomials */ "./lib/numerics/Polynomials.js");
/** base class for Newton iterations in various dimensions.
 * Dimension-specific classes carry all dimension-related data and answer generalized queries
 * from this base class.
 * @internal
 */
class AbstractNewtonIterator {
    /**
     * @param stepSizeTarget tolerance to consider a single step converged.
     * This number should be "moderately" strict.   Because 2 successive convergences are required,
     * it is expected that a first "accept" for (say) 10 to 14 digit step will be followed by another
     * iteration.   A well behaved newton would then hypothetically double the number of digits to
     * 20 to 28.  Since the IEEE double only carries 16 digits, this second-convergence step will
     * typically achieve full precision.
     * @param successiveConvergenceTarget number of successive convergences required for acceptance.
     * @param maxIterations max number of iterations.   A typical newton step converges in 3 to 6 iterations.
     *     Allow 15 to 20 to catch difficult cases.
     */
    constructor(stepSizeTolerance = 1.0e-11, successiveConvergenceTarget = 2, maxIterations = 15) {
        /** Number of consecutive steps which passed convergence condition */
        this._numAccepted = 0;
        /** number of iterations (incremented at each step) */
        this.numIterations = 0;
        this._stepSizeTolerance = stepSizeTolerance;
        this._successiveConvergenceTarget = successiveConvergenceTarget;
        this._maxIterations = maxIterations;
    }
    /**
     * Test if a step is converged.
     * * Convergence is accepted with enough (_successiveConvergenceTarget) small steps (according to _stepSizeTolerance) occur in succession.
     * @param delta step size as reported by currentStepSize
     */
    testConvergence(delta) {
        if (Math.abs(delta) < this._stepSizeTolerance) {
            this._numAccepted++;
            return this._numAccepted >= this._successiveConvergenceTarget;
        }
        this._numAccepted = 0;
        return false;
    }
    /**
     * Run iterations, calling various methods from base and derived classes:
     * * computeStep -- typically evaluate derivatives and solve lineary system.
     * * currentStepSize -- return numeric measure of the step just computed by computeStep
     * * testConvergence -- test if the step from currentStepSize (along with recent steps) is converged.
     * * applyCurrentStep -- apply the step to the independent variables
     */
    runIterations() {
        this._numAccepted = 0;
        this.numIterations = 0;
        while (this.numIterations++ < this._maxIterations && this.computeStep()) {
            if (this.testConvergence(this.currentStepSize())
                && this.applyCurrentStep(true)) {
                return true;
            }
            this.applyCurrentStep(false);
        }
        return false;
    }
}
exports.AbstractNewtonIterator = AbstractNewtonIterator;
/** object to evaluate a newton function.  The object must retain most-recent function and derivative
 * values for immediate query.
 * @internal
 */
class NewtonEvaluatorRtoRD {
}
exports.NewtonEvaluatorRtoRD = NewtonEvaluatorRtoRD;
/**
 * Newton iterator for use when both function and derivative can be evaluated.
 * @internal
 */
class Newton1dUnbounded extends AbstractNewtonIterator {
    /**
     * Constructor for 1D newton iteration with approximate derivatives.
     * @param func function that returns both function and derivative.
     */
    constructor(func) {
        super();
        this._func = func;
        this.setTarget(0);
    }
    /** Set the independent variable */
    setX(x) { this._currentX = x; return true; }
    /** Get the independent variable */
    getX() { return this._currentX; }
    /** Set the target function value */
    setTarget(y) { this._target = y; }
    /** move the current X by the just-computed step */
    applyCurrentStep() { return this.setX(this._currentX - this._currentStep); }
    /** Compute the univariate newton step. */
    computeStep() {
        if (this._func.evaluate(this._currentX)) {
            const dx = Geometry_1.Geometry.conditionalDivideFraction(this._func.currentF - this._target, this._func.currentdFdX);
            if (dx !== undefined) {
                this._currentStep = dx;
                return true;
            }
        }
        return false;
    }
    /** Return the current step size as a relative number. */
    currentStepSize() {
        return Math.abs(this._currentStep / (1.0 + Math.abs(this._currentX)));
    }
}
exports.Newton1dUnbounded = Newton1dUnbounded;
/** object to evaluate a newton function (without derivative).  The object must retain most-recent function value.
 * @internal
 */
class NewtonEvaluatorRtoR {
}
exports.NewtonEvaluatorRtoR = NewtonEvaluatorRtoR;
/** Newton iteration for a univariate function, using approximate derivatives.
 * @internal
 */
class Newton1dUnboundedApproximateDerivative extends AbstractNewtonIterator {
    /**
     * Constructor for 1D newton iteration with approximate derivatives.
     * @param func function that returns both function and derivative.
     */
    constructor(func) {
        super();
        this._func = func;
        this.derivativeH = 1.0e-8;
    }
    /** Set the x (independent, iterated) value */
    setX(x) { this._currentX = x; return true; }
    /** Get the independent variable */
    getX() { return this._currentX; }
    /** move the current X by the just-computed step */
    applyCurrentStep() { return this.setX(this._currentX - this._currentStep); }
    /** Univariate newton step computed with APPROXIMATE derivative. */
    computeStep() {
        if (this._func.evaluate(this._currentX)) {
            const fA = this._func.currentF;
            if (this._func.evaluate(this._currentX + this.derivativeH)) {
                const fB = this._func.currentF;
                const dx = Geometry_1.Geometry.conditionalDivideFraction(fA, (fB - fA) / this.derivativeH);
                if (dx !== undefined) {
                    this._currentStep = dx;
                    return true;
                }
            }
        }
        return false;
    }
    /** Return the current step size as a relative number. */
    currentStepSize() {
        return Math.abs(this._currentStep / (1.0 + Math.abs(this._currentX)));
    }
}
exports.Newton1dUnboundedApproximateDerivative = Newton1dUnboundedApproximateDerivative;
/** object to evaluate a 2-parameter newton function (with derivatives!!).
 * @internal
 */
class NewtonEvaluatorRRtoRRD {
    /**
     * constructor.
     * * This creates a crrentF object to (repeatedly) receive function and derivatives.
     */
    constructor() {
        this.currentF = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
    }
}
exports.NewtonEvaluatorRRtoRRD = NewtonEvaluatorRRtoRRD;
/**
 * Implement evaluation steps for newton iteration in 2 dimensions, using caller supplied NewtonEvaluatorRRtoRRD object.
 * @internal
 */
class Newton2dUnboundedWithDerivative extends AbstractNewtonIterator {
    constructor(func) {
        super();
        this._func = func;
        this._currentStep = Point2dVector2d_1.Vector2d.createZero();
        this._currentUV = Point2dVector2d_1.Point2d.createZero();
    }
    /** Set the current uv coordinates for current iteration */
    setUV(x, y) { this._currentUV.set(x, y); return true; }
    /** Get the current u coordinate */
    getU() { return this._currentUV.x; }
    /** Get the current v coordinate */
    getV() { return this._currentUV.y; }
    /** Move the currentUV coordiante by currentStep. */
    applyCurrentStep() { return this.setUV(this._currentUV.x - this._currentStep.x, this._currentUV.y - this._currentStep.y); }
    /** Evaluate the functions and derivatives at this._currentUV
     * Invert the jacobian and compute the this._currentStep.
     */
    computeStep() {
        if (this._func.evaluate(this._currentUV.x, this._currentUV.y)) {
            const fA = this._func.currentF;
            if (Polynomials_1.SmallSystem.linearSystem2d(fA.vectorU.x, fA.vectorV.x, fA.vectorU.y, fA.vectorV.y, fA.origin.x, fA.origin.y, this._currentStep))
                return true;
        }
        return false;
    }
    /**
     * Return the largest relative step of the x,y, components of the current step.
     */
    currentStepSize() {
        return Geometry_1.Geometry.maxAbsXY(this._currentStep.x / (1.0 + Math.abs(this._currentUV.x)), this._currentStep.y / (1.0 + Math.abs(this._currentUV.y)));
    }
}
exports.Newton2dUnboundedWithDerivative = Newton2dUnboundedWithDerivative;


/***/ }),

/***/ "./lib/numerics/PascalCoefficients.js":
/*!********************************************!*\
  !*** ./lib/numerics/PascalCoefficients.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/**
 * PascalCoeffients class has static methods which return rows of the PascalTriangle.
 * @internal
 */
class PascalCoefficients {
    /**
     * * return a row of the pascal table.
     * * The contents must not be altered by the user !!!
     * * Hypothetically the request row can be any integer.
     * * BUT in practice, values 60 create integer entries that are too big for IEEE double.
     */
    static getRow(row) {
        const allRows = PascalCoefficients._allRows;
        if (allRows.length === 0) {
            // seed the table . . .
            allRows.push(new Float64Array([1]));
            allRows.push(new Float64Array([1, 1]));
            allRows.push(new Float64Array([1, 2, 1]));
            allRows.push(new Float64Array([1, 3, 3, 1]));
            allRows.push(new Float64Array([1, 4, 6, 4, 1]));
            allRows.push(new Float64Array([1, 5, 10, 10, 5, 1]));
            allRows.push(new Float64Array([1, 6, 15, 20, 15, 6, 1]));
            allRows.push(new Float64Array([1, 7, 21, 35, 35, 21, 7, 1]));
        }
        while (allRows.length <= row) {
            const k = allRows.length;
            const oldRow = allRows[k - 1];
            const newRow = new Float64Array(k + 1);
            newRow[0] = 1.0;
            for (let i = 1; i < k; i++)
                newRow[i] = oldRow[i - 1] + oldRow[i];
            newRow[k] = 1.0;
            allRows.push(newRow);
        }
        return allRows[row];
    }
    /** Return an array with Bezier weighted pascal coefficients
     * @param row row index in the pascal triangle.  (`row+1` entries)
     * @param u parameter value
     * @param result optional destination array.
     * @note if the destination array is undefined or too small, a new Float64Array is allocated.
     * @note if the destination array is larger than needed, its leading `row+1` values are filled,
     *     and the array is returned.
     */
    static getBezierBasisValues(order, u, result) {
        const row = order - 1;
        const pascalRow = PascalCoefficients.getRow(row);
        if (result === undefined || result.length < order)
            result = new Float64Array(order);
        for (let i = 0; i < order; i++)
            result[i] = pascalRow[i];
        // multiply by increasing powers of u ...
        let p = u;
        for (let i = 1; i < order; i++, p *= u) {
            result[i] *= p;
        }
        // multiply by powers of (1-u), working from right
        const v = 1.0 - u;
        p = v;
        for (let i = order - 2; i >= 0; i--, p *= v) {
            result[i] *= p;
        }
        return result;
    }
    /** Return an array with derivatives of Bezier weighted pascal coefficients
     * @param row row index in the pascal triangle.  (`row+1` entries)
     * @param u parameter value
     * @param result optional destination array.
     * @note if the destination array is undefined or too small, a new Float64Array is allocated.
     * @note if the destination array is larger than needed, its leading `row+1` values are filled,
     *     and the array is returned.
     */
    static getBezierBasisDerivatives(order, u, result) {
        result = this.getBezierBasisValues(order - 1, u, result);
        // derivative is df/du = (order-1 ) * sum ( q[i+1] - q[i])   summed on 0 <= i < order - 1.\
        // evaluate lower order basis, overwrite in place from right to left
        const f = order - 1;
        result[order - 1] = f * result[order - 2];
        for (let k = order - 2; k > 0; k--) {
            result[k] = f * (result[k - 1] - result[k]);
        }
        result[0] = -f * result[0];
        return result;
    }
}
exports.PascalCoefficients = PascalCoefficients;
PascalCoefficients._allRows = [];


/***/ }),

/***/ "./lib/numerics/Polynomials.js":
/*!*************************************!*\
  !*** ./lib/numerics/Polynomials.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
// import { Angle, AngleSweep, Geometry } from "../Geometry";
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
// import { Arc3d } from "../curve/Arc3d";
// cspell:word Cardano
// cspell:word CCminusSS
/* tslint:disable:variable-name*/
/**
 * degree 2 (quadratic) polynomial in for y = c0 + c1*x + c2*x^2
 * @internal
 */
class Degree2PowerPolynomial {
    constructor(c0 = 0, c1 = 0, c2 = 0) {
        this.coffs = [c0, c1, c2];
    }
    /**
     * * Return 2 duplicate roots in double root case.
     * @returns 0, 1, or 2 solutions of the usual quadratic (a*x*x + b * x + c = 0)
     */
    static solveQuadratic(a, b, c) {
        const b1 = Geometry_1.Geometry.conditionalDivideFraction(b, a);
        const c1 = Geometry_1.Geometry.conditionalDivideFraction(c, a);
        if (b1 !== undefined && c1 !== undefined) {
            // now solving xx + b1*x + c1 = 0 -- i.e. implied "a" coefficient is 1 . .
            const q = b1 * b1 - 4 * c1;
            if (q > 0) {
                const e = Math.sqrt(q);
                // e is positive, so this sorts algebraically
                return [0.5 * (-b1 - e), 0.5 * (-b1 + e)];
            }
            if (q < 0)
                return undefined;
            const root = -0.5 * b1;
            return [root, root];
        }
        // "divide by a" failed.  solve bx + c = 0
        const x = Geometry_1.Geometry.conditionalDivideFraction(-c, b);
        if (x !== undefined)
            return [x];
        return undefined;
    }
    /** Add `a` to the constant term. */
    addConstant(a) {
        this.coffs[0] += a;
    }
    /** Add  `s * (a + b*x)^2` to the quadratic coefficients */
    addSquaredLinearTerm(a, b, s = 1) {
        this.coffs[0] += s * (a * a);
        this.coffs[1] += s * (2.0 * a * b);
        this.coffs[2] += s * (b * b);
    }
    /** Return the real roots of this polynomial */
    realRoots() {
        const ss = Degree2PowerPolynomial.solveQuadratic(this.coffs[2], this.coffs[1], this.coffs[0]);
        if (ss && ss.length > 1) {
            if (ss[0] > ss[1]) {
                const temp = ss[0];
                ss[0] = ss[1];
                ss[1] = temp;
            }
        }
        return ss;
    }
    /** Evaluate the quadratic at x. */
    evaluate(x) {
        return this.coffs[0] + x * (this.coffs[1] + x * this.coffs[2]);
    }
    /**
     * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)
     * @param u parameter for evaluation
     */
    evaluateDerivative(x) {
        return this.coffs[1] + 2 * x * this.coffs[2];
    }
    /** Factor the polynomial in to the form `y0 + c * (x-x0)^2)`, i.e. complete the square. */
    tryGetVertexFactorization() {
        const x = Geometry_1.Geometry.conditionalDivideFraction(-this.coffs[1], 2.0 * this.coffs[2]);
        if (x !== undefined) {
            const y = this.evaluate(x);
            return { c: this.coffs[2], x0: x, y0: y };
        }
        return undefined;
    }
    /** Construct a quadratic from input form `c2 * (x-root0) * (x-root1)` */
    static fromRootsAndC2(root0, root1, c2 = 1) {
        return new Degree2PowerPolynomial(c2 * root0 * root1, -c2 * (root0 + root1), c2);
    }
}
exports.Degree2PowerPolynomial = Degree2PowerPolynomial;
/**
 * degree 3 (cubic) polynomial in for y = c0 + c1*x + c2*x^2 + c3*x^3
 * @internal
 */
class Degree3PowerPolynomial {
    constructor(c0 = 0, c1 = 0, c2 = 0, c3 = 1) {
        this.coffs = [c0, c1, c2, c3];
    }
    /** Add `a` to the constant term. */
    addConstant(a) {
        this.coffs[0] += a;
    }
    /** Add `s * (a + b*x)^2` to the cubic */
    addSquaredLinearTerm(a, b, s = 1) {
        this.coffs[0] += s * (a * a);
        this.coffs[1] += s * (2.0 * a * b);
        this.coffs[2] += s * (b * b);
    }
    /**
     * Evaluate the polynomial at x
     * @param u parameter for evaluation
     */
    evaluate(x) {
        return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * this.coffs[3]));
    }
    /**
     * Evaluate the polynomial derivative
     * @param u parameter for evaluation
     */
    evaluateDerivative(x) {
        return this.coffs[1] + x * (2.0 * this.coffs[2] + x * 3.0 * this.coffs[3]);
    }
    /** Construct a cubic from the form `c3 * (x-root0) * (x - root1) * (x- root2)` */
    static fromRootsAndC3(root0, root1, root2, c3 = 1.0) {
        return new Degree3PowerPolynomial(-c3 * root0 * root1 * root2, c3 * (root0 * root1 + root1 * root2 + root0 * root2), -c3 * (root0 + root1 + root2), c3);
    }
}
exports.Degree3PowerPolynomial = Degree3PowerPolynomial;
/**
 * degree 4 (quartic) polynomial in for y = c0 + c1*x + c2*x^2 + c4*x^4
 * @internal
 */
class Degree4PowerPolynomial {
    constructor(c0 = 0, c1 = 0, c2 = 0, c3 = 0, c4 = 0) {
        this.coffs = [c0, c1, c2, c3, c4];
    }
    /** Add `a` to the constant term. */
    addConstant(a) {
        this.coffs[0] += a;
    }
    /**
     * Evaluate the polynomial
     * @param x x coordinate for evaluation
     */
    evaluate(x) {
        return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * (this.coffs[3] + x * this.coffs[4])));
    }
    /**
     * Evaluate the derivative
     * @param x x coordinate for evaluation
     */
    evaluateDerivative(x) {
        return (this.coffs[1] + x * (2.0 * this.coffs[2] + x * (3.0 * this.coffs[3] + x * 4.0 * this.coffs[4])));
    }
    /** Construct a quartic from the form `c3 * (x-root0) * (x - root1) * (x- root2) * (x-root3)` */
    static fromRootsAndC4(root0, root1, root2, root3, c4 = 1) {
        return new Degree4PowerPolynomial(c4 * (root0 * root1 * root2 * root3), -c4 * (root0 * root1 * root2 + root0 * root1 * root3 + root0 * root2 * root3 + root1 * root2 * root3), c4 * (root0 * root1 + root0 * root2 + root0 * root3 + root1 * root2 + root1 * root3 + root2 * root3), -c4 * (root0 + root1 + root2 + root3), c4);
    }
}
exports.Degree4PowerPolynomial = Degree4PowerPolynomial;
/**
 * polynomial services for an implicit torus with
 * * z axis is "through the donut hole"
 * * `majorRadius` is the radius of the circle "around the z axis"
 * * `minorRadius` is the radius of circles around the major circle
 * * for simple xyz the implicit form is
 *   * `(x^2+y^2+z^2+(R^2-r^2))^2 = 4 R^2(x^2+y^2)`
 * * In weighted form
 *   * `(x^2+y^2+z^2+(R^2-r^2)w^2)^2 = 4 R^2 w^2 (x^2+y^2)`
 * @internal
 */
class TorusImplicit {
    constructor(majorRadius, minorRadius) {
        this.majorRadius = majorRadius;
        this.minorRadius = minorRadius;
    }
    /** Return sum of (absolute) major and minor radii, which is (half) the box size in x and y directions */
    boxSize() {
        return (Math.abs(this.majorRadius) + Math.abs(this.minorRadius));
    }
    /** Return scale factor appropriate to control the magnitude of the implicit function. */
    implicitFunctionScale() {
        const a = this.boxSize();
        if (a === 0.0)
            return 1.0;
        return 1.0 / (a * a * a * a);
    }
    /**
     * At space point (x,y,z) evaluate the implicit form of the torus (See `ImplicitTorus`)
     */
    evaluateImplicitFunctionXYZ(x, y, z) {
        const rho2 = x * x + y * y;
        const z2 = z * z;
        const R2 = this.majorRadius * this.majorRadius;
        const r2 = this.minorRadius * this.minorRadius;
        const f = rho2 + z2 + (R2 - r2);
        const g = 4.0 * R2 * rho2;
        return (f * f - g) * this.implicitFunctionScale();
    }
    /** Evaluate the implicit function at a point. */
    evaluateImplicitFunctionPoint(xyz) {
        return this.evaluateImplicitFunctionXYZ(xyz.x, xyz.y, xyz.z);
    }
    /** Evaluate the implicit function at homogeneous coordinates */
    evaluateImplicitFunctionXYZW(x, y, z, w) {
        const rho2 = x * x + y * y;
        const z2 = z * z;
        const w2 = w * w;
        const R2 = this.majorRadius * this.majorRadius;
        const r2 = this.minorRadius * this.minorRadius;
        const f = rho2 + z2 + w2 * (R2 - r2);
        const g = w2 * 4.0 * R2 * rho2;
        return (f * f - g) * this.implicitFunctionScale();
    }
    /** Evaluate the surface point at angles (in radians) on the major and minor circles. */
    evaluateThetaPhi(thetaRadians, phiRadians) {
        const c = Math.cos(thetaRadians);
        const s = Math.sin(thetaRadians);
        // theta=0 point
        const x0 = this.majorRadius + this.minorRadius * Math.cos(phiRadians);
        const z0 = this.minorRadius * Math.sin(phiRadians);
        return Point3dVector3d_1.Point3d.create(c * x0, s * x0, z0);
    }
    /** Evaluate partial derivatives at angles (int radians) on major and minor circles. */
    evaluateDerivativesThetaPhi(thetaRadians, phiRadians, dxdTheta, dxdPhi) {
        const cTheta = Math.cos(thetaRadians);
        const sTheta = Math.sin(thetaRadians);
        const bx = this.minorRadius * Math.cos(phiRadians);
        const bz = this.minorRadius * Math.sin(phiRadians);
        const x0 = this.majorRadius + bx;
        Point3dVector3d_1.Vector3d.create(-x0 * sTheta, x0 * cTheta, 0.0, dxdTheta);
        Point3dVector3d_1.Vector3d.create(-cTheta * bz, -sTheta * bz, bx, dxdPhi);
    }
    /** Evaluate space point at major and minor angles (in radians) and distance from major hoop. */
    evaluateThetaPhiDistance(thetaRadians, phiRadians, distance) {
        const c = Math.cos(thetaRadians);
        const s = Math.sin(thetaRadians);
        // theta=0 point
        const x0 = this.majorRadius + distance * Math.cos(phiRadians);
        const z0 = distance * Math.sin(phiRadians);
        return Point3dVector3d_1.Point3d.create(c * x0, s * x0, z0);
    }
    /** Given an xyz coordinate in the local system of the toroid, compute the torus parametrization
     * * theta = angular coordinate in xy plane
     * * phi = angular coordinate in minor circle.
     * * distance = distance from major circle
     * * rho = distance from origin to xy part of the input.
     * @param xyz space point in local coordinates.
     * @return object with properties theta, phi, distance, rho
     */
    xyzToThetaPhiDistance(xyz) {
        const rho = xyz.magnitudeXY();
        const majorRadiusFactor = Geometry_1.Geometry.conditionalDivideFraction(this.majorRadius, rho);
        let safeMajor;
        let majorCirclePoint;
        if (majorRadiusFactor) {
            safeMajor = true;
            majorCirclePoint = Point3dVector3d_1.Point3d.create(majorRadiusFactor * xyz.x, majorRadiusFactor * xyz.y, 0.0);
        }
        else {
            safeMajor = false;
            majorCirclePoint = Point3dVector3d_1.Point3d.create(xyz.x, xyz.y, 0.0);
        }
        const theta = safeMajor ? Math.atan2(xyz.y, xyz.x) : 0.0;
        const vectorFromMajorCircle = Point3dVector3d_1.Vector3d.createStartEnd(majorCirclePoint, xyz);
        const distance = vectorFromMajorCircle.magnitude();
        const dRho = rho - this.majorRadius;
        let safePhi;
        let phi;
        if (xyz.z === 0.0 && dRho === 0.0) {
            phi = 0.0;
            safePhi = false;
        }
        else {
            phi = Math.atan2(xyz.z, dRho);
            safePhi = true;
        }
        return { theta: (theta), phi: (phi), distance: (distance), rho: (rho), safePhi: safeMajor && safePhi };
    }
}
exports.TorusImplicit = TorusImplicit;
/**
 * evaluation methods for an implicit sphere
 * * xyz function `x*x + y*y + z*z - r*r = 0`.
 * * xyzw function `x*x + y*y + z*z - r*r*w*w = 0`.
 * @internal
 */
class SphereImplicit {
    constructor(r) { this.radius = r; }
    /** Evaluate the implicit function at coordinates x,y,z */
    evaluateImplicitFunction(x, y, z) {
        return x * x + y * y + z * z - this.radius * this.radius;
    }
    /** Evaluate the implicit function at homogeneous coordinates x,y,z,w */
    evaluateImplicitFunctionXYZW(wx, wy, wz, w) {
        return (wx * wx + wy * wy + wz * wz) - this.radius * this.radius * w * w;
    }
    /** Given an xyz coordinate in the local system of the toroid, compute the sphere parametrization
     * * theta = angular coordinate in xy plane
     * * phi = rotation from xy plane towards z axis.
     * @param xyz space point in local coordinates.
     * @return object with properties thetaRadians, phi, r
     */
    xyzToThetaPhiR(xyz) {
        const rhoSquared = xyz.x * xyz.x + xyz.y * xyz.y;
        const rho = Math.sqrt(rhoSquared);
        const r = Math.sqrt(rhoSquared + xyz.z * xyz.z);
        let theta;
        let phi;
        let valid;
        if (r === 0.0) {
            theta = phi = 0.0;
            valid = false;
        }
        else {
            phi = Math.atan2(xyz.z, rho); // At least one of these is nonzero
            if (rhoSquared !== 0.0) {
                theta = Math.atan2(xyz.y, xyz.x);
                valid = true;
            }
            else {
                theta = 0.0;
                valid = false;
            }
        }
        return { thetaRadians: (theta), phiRadians: (phi), r: (r), valid: (valid) };
    }
    // public intersectRay(ray: Ray3d, maxHit: number): {rayFractions: number, points: Point3d} {
    //   const q = new Degree2PowerPolynomial();
    //   // Ray is (origin.x + s * direction.x, etc)
    //   // squared distance from origin is (origin.x + s*direction.x)^2 + etc
    //   // sphere radius in local system is 1.
    //   q.addSquaredLinearTerm(ray.origin.x, ray.direction.x);
    //   q.addSquaredLinearTerm(ray.origin.y, ray.direction.y);
    //   q.addSquaredLinearTerm(ray.origin.z, ray.direction.z);
    //   q.addConstant(-this.radius * this.radius);
    //   let ss = [];
    //   let n = q.realRoots(ss);
    //   if (n > maxHit)
    //     n = maxHit;
    //   let rayFractions;
    //   let points;
    //   for (let i = 0; i < n; i++) {
    //     rayFractions[i] = ss[i];
    //     points[i] = Point3d. // What is the equivalent of FromSumOf in TS?
    //   }
    /** Compute the point on a sphere at angular coordinates.
     * @param thetaRadians latitude angle
     * @param phiRadians longitude angle
     */
    evaluateThetaPhi(thetaRadians, phiRadians) {
        const rc = this.radius * Math.cos(thetaRadians);
        const rs = this.radius * Math.sin(thetaRadians);
        const cosPhi = Math.cos(phiRadians);
        const sinPhi = Math.sin(phiRadians);
        return Point3dVector3d_1.Point3d.create(rc * cosPhi, rs * cosPhi, this.radius * sinPhi);
    }
    /** Compute the derivatives with respect to spherical angles.
     * @param thetaRadians latitude angle
     * @param phiRadians longitude angle
     */
    evaluateDerivativesThetaPhi(thetaRadians, phiRadians, dxdTheta, dxdPhi) {
        const rc = this.radius * Math.cos(thetaRadians);
        const rs = this.radius * Math.sin(thetaRadians);
        const cosPhi = Math.cos(phiRadians);
        const sinPhi = Math.sin(phiRadians);
        Point3dVector3d_1.Vector3d.create(-rs * cosPhi, rc * cosPhi, 0.0, dxdTheta);
        Point3dVector3d_1.Vector3d.create(-rc * sinPhi, -rs * sinPhi, this.radius * cosPhi, dxdPhi);
    }
}
exports.SphereImplicit = SphereImplicit;
/** AnalyticRoots has static methods for solving quadratic, cubic, and quartic equations.
 * @internal
 *
 */
class AnalyticRoots {
    /** Absolute zero test with a tolerance that has worked well for the analytic root use case . . . */
    static isZero(x) {
        return Math.abs(x) < this._EQN_EPS;
    }
    /** Without actually doing a division, test if (x/y) is small.
     * @param x numerator
     * @param y denominator
     * @param absTol absolute tolerance
     * @param relTol relative tolerance
     */
    static isSmallRatio(x, y, absTol = 1.0e-9, relTol = 8.0e-16) {
        return Math.abs(x) <= absTol || Math.abs(x) < relTol * Math.abs(y);
    }
    /** Return the (real, signed) principal cube root of x */
    static cbrt(x) {
        return ((x) > 0.0
            ? Math.pow((x), 1.0 / 3.0)
            : ((x) < 0.0
                ? -Math.pow(-(x), 1.0 / 3.0)
                : 0.0));
    }
    /**
     * Try to divide `numerator/denominator` and place the result (or defaultValue) in `values[offset]`
     * @param values array of values.  `values[offset]` will be replaced.
     * @param numerator numerator for division.
     * @param denominator denominator for division.
     * @param defaultValue value to save if denominator is too small to divide.
     * @param offset index of value to replace.
     */
    static safeDivide(values, numerator, denominator, defaultValue = 0.0, offset) {
        if (Math.abs(denominator) > (this._safeDivideFactor * Math.abs(numerator))) {
            values[offset] = numerator / denominator;
            return true;
        }
        values[offset] = defaultValue;
        return false;
    }
    // Used in NewtonMethod for testing if a root has been adjusted past its bounding region
    static checkRootProximity(roots, i) {
        if (i === 0) { // Case 1: Beginning Root (check root following it)
            return roots.atUncheckedIndex(i) < roots.atUncheckedIndex(i + 1);
        }
        else if (i > 0 && i + 1 < roots.length) { // Case 2: Middle Root (check roots before and after)
            return (roots.atUncheckedIndex(i) > roots.atUncheckedIndex(i - 1)) && (roots.atUncheckedIndex(i) < roots.atUncheckedIndex(i + 1));
        }
        else { // Case 3: End root (check preceding root)
            return (roots.atUncheckedIndex(i) > roots.atUncheckedIndex(i - 1));
        }
    }
    static newtonMethodAdjustment(coffs, root, degree) {
        let p = coffs[degree];
        let q = 0.0;
        for (let i = degree - 1; i >= 0; i--) {
            q = p + root * q;
            p = coffs[i] + root * p;
        }
        if (Math.abs(q) >= 1.0e-14 * (1.0 + Math.abs(root))) {
            return p / q;
        }
        return undefined;
    }
    static improveRoots(coffs, degree, roots, restrictOrderChanges) {
        const relTol = 1.0e-10;
        // Loop through each root
        for (let i = 0; i < roots.length; i++) {
            let dx = this.newtonMethodAdjustment(coffs, roots.atUncheckedIndex(i), degree);
            if (dx === undefined || dx === 0.0)
                continue; // skip if newton step had divide by zero.
            const originalValue = roots.atUncheckedIndex(i);
            let counter = 0;
            let convergenceCounter = 0;
            // Loop through applying changes to found root until dx is diminished or counter is hit
            while (dx !== undefined && dx !== 0.0 && (counter < 10)) {
                // consider it converged if two successive iterations satisfy the (not too demanding) tolerance.
                if (Math.abs(dx) < relTol * (1.0 + Math.abs(roots.atUncheckedIndex(i)))) {
                    if (++convergenceCounter > 1)
                        break;
                }
                else {
                    convergenceCounter = 0;
                }
                const rootDX = roots.atUncheckedIndex(i) - dx;
                roots.reassign(i, rootDX);
                // If root is thrown past one of its neighboring roots, unstable condition is assumed.. revert
                // to originally found root
                if (restrictOrderChanges && !this.checkRootProximity(roots, i)) {
                    roots.reassign(i, originalValue);
                    break;
                }
                dx = this.newtonMethodAdjustment(coffs, roots.atUncheckedIndex(i), degree);
                counter++;
            }
        }
    }
    /**
     * Append (if defined) value to results.
     * @param value optional value to append
     * @param results growing array
     */
    static appendSolution(value, results) {
        if (value !== undefined) {
            results.push(value);
        }
    }
    /**
     * Append 2 solutions -- note that both are required args, no option of omitting as in single solution case
     * @param value1
     * @param value2
     * @param results
     */
    static append2Solutions(valueA, valueB, results) {
        results.push(valueA);
        results.push(valueB);
    }
    /**
     * If `co/c1` is a safe division, append it to the values array.
     * @param c0 numerator
     * @param c1 denominator
     * @param values array to expand
     */
    static appendLinearRoot(c0, c1, values) {
        AnalyticRoots.appendSolution(Geometry_1.Geometry.conditionalDivideFraction(-c0, c1), values);
    }
    /**
     * * Compute the mean of all the entries in `data`
     * * Return the data value that is farthest away
     */
    static mostDistantFromMean(data) {
        if (!data || data.length === 0)
            return 0;
        let a = 0.0; // to become the sum and finally the average.
        for (let i = 0; i < data.length; i++)
            a += data.atUncheckedIndex(i);
        a /= data.length;
        let dMax = 0.0;
        let result = data.atUncheckedIndex(0);
        for (let i = 0; i < data.length; i++) {
            const d = Math.abs(data.atUncheckedIndex(i) - a);
            if (d > dMax) {
                dMax = d;
                result = data.atUncheckedIndex(i);
            }
        }
        return result;
    }
    /**
     * Append 0, 1, or 2 solutions of a quadratic to the values array.
     * @param c array of coefficients for quadratic `c[0] + c[1] * x + c[2] * x*x`
     * @param values array to be expanded.
     */
    static appendQuadraticRoots(c, values) {
        // Normal form: x^2 + 2px + q = 0
        const divFactor = Geometry_1.Geometry.conditionalDivideFraction(1.0, c[2]);
        if (!divFactor) {
            this.appendLinearRoot(c[0], c[1], values);
            return;
        }
        const p = 0.5 * c[1] * divFactor;
        const q = c[0] * divFactor;
        const D = p * p - q;
        if (this.isZero(D)) {
            this.appendSolution(-p, values);
            return;
        }
        else if (D < 0) {
            return;
        }
        else if (D > 0) {
            const sqrt_D = Math.sqrt(D);
            this.append2Solutions(sqrt_D - p, -sqrt_D - p, values);
            return;
        }
        return;
    }
    /** Add `a` to the constant term. */
    static addConstant(value, data) {
        for (let i = 0; i < data.length; i++)
            data.reassign(i, data.atUncheckedIndex(i) + value);
    }
    /** return roots of a cubic c0 + c1 *x + c2 * x^2 + c2 * x3.
     * In the usual case where c0 is non-zero, there are either 1 or 3 roots.
     * But if c0 is zero the (0, 1, or 2) roots of the lower order equation
     */
    static appendCubicRootsUnsorted(c, results) {
        let A;
        let B;
        let C;
        let sq_A;
        let p;
        let q;
        let cb_p;
        let D;
        // normal form: x^3 + Ax^2 + Bx + C = 0
        const scaleFactor = Geometry_1.Geometry.conditionalDivideFraction(1.0, c[3]);
        if (!scaleFactor) {
            this.appendQuadraticRoots(c, results);
            return;
        }
        // It is a real cubic.  There MUST be at least one real solution . . .
        A = c[2] * scaleFactor;
        B = c[1] * scaleFactor;
        C = c[0] * scaleFactor;
        /*  substitute x = y - A/3 to eliminate quadric term:
            f = y^3 +3py + 2q = 0
            f' = 3y^2 + p
                local min/max at Y = +-sqrt (-p)
                f(+Y) = -p sqrt(-p) + 3p sqrt (-p) + 2q = 2 p sqrt (-p) + 2q
        */
        sq_A = A * A;
        p = (3.0 * B - sq_A) / 9.0;
        q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);
        // Use Cardano formula
        cb_p = p * p * p;
        D = q * q + cb_p;
        const origin = A / (-3.0);
        if (D >= 0.0 && this.isZero(D)) {
            if (this.isZero(q)) {
                // One triple solution
                results.push(origin);
                results.push(origin);
                results.push(origin);
                return;
            }
            else {
                // One single and one double solution
                const u = this.cbrt(-q);
                if (u < 0) {
                    results.push(origin + 2 * u);
                    results.push(origin - u);
                    results.push(origin - u);
                    return;
                }
                else {
                    results.push(origin - u);
                    results.push(origin - u);
                    results.push(origin + 2 * u);
                    return;
                }
            }
        }
        else if (D <= 0) { // three real solutions
            const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));
            const t = 2 * Math.sqrt(-p);
            results.push(origin + t * Math.cos(phi));
            results.push(origin - t * Math.cos(phi + Math.PI / 3));
            results.push(origin - t * Math.cos(phi - Math.PI / 3));
            this.improveRoots(c, 3, results, false);
            return;
        }
        else { // One real solution
            const sqrt_D = Math.sqrt(D);
            const u = this.cbrt(sqrt_D - q);
            const v = -(this.cbrt(sqrt_D + q));
            results.push(origin + u + v);
            this.improveRoots(c, 3, results, false);
            return;
        }
    }
    /** Compute roots of cubic 'c[0] + c[1] * x + c[2] * x^2 + c[3] * x^3 */
    static appendCubicRoots(c, results) {
        this.appendCubicRootsUnsorted(c, results);
        results.sort();
    }
    /** Compute roots of quartic 'c[0] + c[1] * x + c[2] * x^2 + c[3] * x^3 + c[4] * x^4 */
    static appendQuarticRoots(c, results) {
        const coffs = new Float64Array(4); // at various times .. coefficients of quadratic an cubic intermediates.
        let u;
        let v;
        let A;
        let B;
        let C;
        let D;
        let sq_A;
        let p;
        let q;
        let r;
        // normal form: x^4 + Ax^3 + Bx^2 + Cx + D = 0
        const coffScale = new Float64Array(1);
        if (!this.safeDivide(coffScale, 1.0, c[4], 0.0, 0)) {
            this.appendCubicRoots(c, results);
            return;
        }
        A = c[3] * coffScale[0];
        B = c[2] * coffScale[0];
        C = c[1] * coffScale[0];
        D = c[0] * coffScale[0];
        const origin = -0.25 * A;
        /*  substitute x = y - A/4 to eliminate cubic term:
            x^4 + px^2 + qx + r = 0 */
        sq_A = A * A;
        p = -3.0 / 8 * sq_A + B;
        q = 0.125 * sq_A * A - 0.5 * A * B + C;
        r = -3.0 / 256 * sq_A * sq_A + 1.0 / 16 * sq_A * B - 1.0 / 4 * A * C + D;
        const tempStack = new GrowableFloat64Array_1.GrowableFloat64Array();
        if (this.isZero(r)) {
            // no absolute term: y(y^3 + py + q) = 0
            coffs[0] = q;
            coffs[1] = p;
            coffs[2] = 0;
            coffs[3] = 1;
            this.appendCubicRootsUnsorted(coffs, results);
            results.push(0); // APPLY ORIGIN ....
            this.addConstant(origin, results);
            return;
        }
        else {
            // Solve the resolvent cubic
            coffs[0] = 1.0 / 2 * r * p - 1.0 / 8 * q * q;
            coffs[1] = -r;
            coffs[2] = -1.0 / 2 * p;
            coffs[3] = 1;
            this.appendCubicRootsUnsorted(coffs, tempStack);
            const z = this.mostDistantFromMean(tempStack);
            // ... to build two quadric equations
            u = z * z - r;
            v = 2 * z - p;
            if (this.isSmallRatio(u, r)) {
                u = 0;
            }
            else if (u > 0) {
                u = Math.sqrt(u);
            }
            else {
                return;
            }
            if (this.isSmallRatio(v, p)) {
                v = 0;
            }
            else if (v > 0) {
                v = Math.sqrt(v);
            }
            else {
                for (let i = 0; i < tempStack.length; i++) {
                    results.push(tempStack.atUncheckedIndex(i));
                }
                return;
            }
            coffs[0] = z - u;
            coffs[1] = ((q < 0) ? (-v) : (v));
            coffs[2] = 1;
            this.appendQuadraticRoots(coffs, results);
            coffs[0] = z + u;
            coffs[1] = ((q < 0) ? (v) : (-v));
            coffs[2] = 1;
            this.appendQuadraticRoots(coffs, results);
        }
        // substitute
        this.addConstant(origin, results);
        results.sort();
        this.improveRoots(c, 4, results, true);
        return;
    }
    static appendCosSinRadians(c, s, cosValues, sinValues, radiansValues) {
        if (cosValues)
            cosValues.push(c);
        if (sinValues)
            sinValues.push(s);
        if (radiansValues)
            radiansValues.push(Math.atan2(s, c));
    }
    /**
     * * Solve the simultaneous equations in variables`c` and`s`:
     *   * A line: `alpha + beta*c + gamma*s = 0`
     *   * The unit circle 'c*c + s*s = 1`
     * * Solution values are returned as 0, 1, or 2(c, s) pairs
     * * Return value indicates one of these solution states:
     *   * -2 -- all coefficients identically 0.   The entire c, s plane-- and therefore the entire unit circle-- is a solution.
     *   * -1 -- beta, gamma are zero, alpha is not.There is no line defined.There are no solutions.
     *   * 0 -- the line is well defined, but passes completely outside the unit circle.
     *     * In this case, (c1, s1) is the circle point closest to the line and(c2, s2) is the line point closest to the circle.
     * * 1 -- the line is tangent to the unit circle.
     *   * Tangency is determined by tolerances, which calls a "close approach" point a tangency.
     *    * (c1, s1) is the closest circle point
     *    * (c2, s2) is the line point.
     * * 2 -- two simple intersections.
     * @param alpha constant coefficient on line
     * @param beta x cosine coefficient on line
     * @param gamma y sine coefficient on line
     * @param relTol relative tolerance for tangencies
     * @param cosValues (caller allocated) array to receive solution `c` values
     * @param sinValues (caller allocated) array to receive solution `s` values
     * @param radiansValues (caller allocated) array to receive solution radians values.
     */
    static appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosValues, sinValues, radiansValues, relTol = 1.0e-14) {
        let twoTol;
        const delta2 = beta * beta + gamma * gamma;
        const alpha2 = alpha * alpha;
        let solutionType = 0;
        if (relTol < 0.0) {
            twoTol = 0.0;
        }
        else {
            twoTol = 2.0 * relTol;
        }
        if (delta2 <= 0.0) {
            solutionType = (alpha === 0) ? -2 : -1;
        }
        else {
            const lambda = -alpha / delta2;
            const a2 = alpha2 / delta2;
            const D2 = 1.0 - a2;
            if (D2 < -twoTol) {
                const delta = Math.sqrt(delta2);
                const iota = (alpha < 0) ? (1.0 / delta) : (-1.0 / delta);
                this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);
                this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);
                solutionType = 0;
            }
            else if (D2 < twoTol) {
                const delta = Math.sqrt(delta2);
                const iota = (alpha < 0) ? (1.0 / delta) : (-1.0 / delta);
                this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);
                this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);
                solutionType = 1;
            }
            else {
                const mu = Math.sqrt(D2 / delta2);
                /* c0,s0 = closest approach of line to origin */
                const c0 = lambda * beta;
                const s0 = lambda * gamma;
                this.appendCosSinRadians(c0 - mu * gamma, s0 + mu * beta, cosValues, sinValues, radiansValues);
                this.appendCosSinRadians(c0 + mu * gamma, s0 - mu * beta, cosValues, sinValues, radiansValues);
                solutionType = 2;
            }
        }
        return solutionType;
    }
}
exports.AnalyticRoots = AnalyticRoots;
AnalyticRoots._EQN_EPS = 1.0e-9;
AnalyticRoots._safeDivideFactor = 1.0e-14;
/**
 * manipulations of polynomials with where `coff[i]` multiplies x^i
 * @internal
 */
class PowerPolynomial {
    /** Evaluate a standard basis polynomial at `x`, with `degree` possibly less than `coff.length` */
    static degreeKnownEvaluate(coff, degree, x) {
        if (degree < 0) {
            return 0.0;
        }
        let p = coff[degree];
        for (let i = degree - 1; i >= 0; i--)
            p = x * p + coff[i];
        return p;
    }
    /** Evaluate the standard basis polynomial of degree `coff.length` at `x` */
    static evaluate(coff, x) {
        const degree = coff.length - 1;
        return this.degreeKnownEvaluate(coff, degree, x);
    }
    /**
     * * Accumulate Q*scale into P.Both are treated as full degree.
     * * (Expect Address exceptions if P is smaller than Q)
     * * Returns degree of result as determined by comparing trailing coefficients to zero
     */
    static accumulate(coffP, coffQ, scaleQ) {
        let degreeP = coffP.length - 1;
        const degreeQ = coffQ.length - 1;
        for (let i = 0; i <= degreeQ; i++) {
            coffP[i] += scaleQ * coffQ[i];
        }
        while (degreeP >= 0 && coffP[degreeP] === 0.0) {
            degreeP--;
        }
        return degreeP;
    }
    /** Zero all coefficients */
    static zero(coff) {
        for (let i = 0; i < coff.length; i++) {
            coff[i] = 0.0;
        }
    }
}
exports.PowerPolynomial = PowerPolynomial;
/**
 * manipulation of polynomials with powers of sine and cosine
 * @internal
 */
class TrigPolynomial {
    /**
     *  Solve a polynomial created from trigonometric condition using
     * Trig.S, Trig.C, Trig.W.  Solution logic includes inferring angular roots
     * corresponding zero leading coefficients (roots at infinity)
     * @param coff Coefficients
     * @param nominalDegree degree of the polynomial under most complex
     *     root case.  If there are any zero coefficients up to this degree, a single root
     *     "at infinity" is recorded as its corresponding angular parameter at negative pi/2
     * @param referenceCoefficient A number which represents the size of coefficients
     *     at various stages of computation.  A small fraction of this will be used as a zero
     *     tolerance
     * @param angles Roots are placed here. Assumed preallocated with adequate size.
     * @param numRoots Number of roots  .  Zero roots is possible. (Passed as array of size
     * one to pass-by-reference)
     * Returns false if equation is all zeros.   This usually means any angle is a solution.
     */
    static solveAngles(coff, nominalDegree, referenceCoefficient, radians) {
        let maxCoff = Math.abs(referenceCoefficient);
        let a;
        radians.length = 0;
        const relTol = this._smallAngle;
        for (let i = 0; i <= nominalDegree; i++) {
            a = Math.abs(coff[i]);
            if (a > maxCoff) {
                maxCoff = a;
            }
        }
        const coffTol = relTol * maxCoff;
        let degree = nominalDegree;
        while (degree > 0 && (Math.abs(coff[degree]) <= coffTol)) {
            degree--;
        }
        // let status = false;
        const roots = new GrowableFloat64Array_1.GrowableFloat64Array();
        if (degree === -1) {
            // Umm.   Dunno.   Nothing there.
            // status = false;
        }
        else {
            // status = true;
            if (degree === 0) {
                // p(t) is a nonzero constant
                // No roots, but not degenerate.
                // status = true;
            }
            else if (degree === 1) {
                // p(t) = coff[1] * t + coff[0]...
                roots.push(-coff[0] / coff[1]);
            }
            else if (degree === 2) {
                AnalyticRoots.appendQuadraticRoots(coff, roots);
            }
            else if (degree === 3) {
                AnalyticRoots.appendCubicRoots(coff, roots);
            }
            else if (degree === 4) {
                AnalyticRoots.appendQuarticRoots(coff, roots);
            }
            else {
                // TODO: WILL WORK WITH BEZIER SOLVER
                // status = false;
            }
            if (roots.length > 0) {
                // Each solution t represents an angle with
                //  Math.Cos(theta)=C(t)/W(t),  ,sin(theta)=S(t)/W(t)
                // Division by W has no effect on Atan2 calculations, so we just compute S(t),C(t)
                for (let i = 0; i < roots.length; i++) {
                    const ss = PowerPolynomial.evaluate(this.S, roots.atUncheckedIndex(i));
                    const cc = PowerPolynomial.evaluate(this.C, roots.atUncheckedIndex(i));
                    radians.push(Math.atan2(ss, cc));
                }
                // Each leading zero at the front of the coefficients corresponds to a root at -PI/2.
                // Only make one entry....
                // for (int i = degree; i < nominalDegree; i++)
                if (degree < nominalDegree) {
                    radians.push(-0.5 * Math.PI);
                }
            }
        }
        return radians.length > 0;
    }
    /**
     * Compute intersections of unit circle `x ^ 2 + y 2 = 1` with general quadric
     * `axx * x ^ 2 + axy * x * y + ayy * y ^ 2 + ax * x + ay * y + a1 = 0`
     * Solutions are returned as angles.Sine and Cosine of the angles are the x, y results.
     * @param axx  Coefficient of x ^ 2
     * @param axy  Coefficient of xy
     * @param ayy  Coefficient of y ^ 2
     * @param ax  Coefficient of x
     * @param ay  Coefficient of y
     * @param a1  Constant coefficient
     * @param angles  solution angles
     * @param numAngle  number of solution angles(Passed as array to make changes to reference)
     */
    static solveUnitCircleImplicitQuadricIntersection(axx, axy, ayy, ax, ay, a1, radians) {
        const Coffs = new Float64Array(5);
        PowerPolynomial.zero(Coffs);
        let degree = 2;
        if (Geometry_1.Geometry.hypotenuseXYZ(axx, axy, ayy) > TrigPolynomial._coefficientRelTol * Geometry_1.Geometry.hypotenuseXYZ(ax, ay, a1)) {
            PowerPolynomial.accumulate(Coffs, this.CW, ax);
            PowerPolynomial.accumulate(Coffs, this.SW, ay);
            PowerPolynomial.accumulate(Coffs, this.WW, a1);
            PowerPolynomial.accumulate(Coffs, this.SS, ayy);
            PowerPolynomial.accumulate(Coffs, this.CC, axx);
            PowerPolynomial.accumulate(Coffs, this.SC, axy);
            degree = 4;
        }
        else {
            PowerPolynomial.accumulate(Coffs, this.C, ax);
            PowerPolynomial.accumulate(Coffs, this.S, ay);
            PowerPolynomial.accumulate(Coffs, this.W, a1);
            degree = 2;
        }
        let maxCoff = 0.0;
        maxCoff = Math.max(maxCoff, Math.abs(axx), Math.abs(ayy), Math.abs(axy), Math.abs(ax), Math.abs(ay), Math.abs(a1));
        const b = this.solveAngles(Coffs, degree, maxCoff, radians);
        /*
        for (const theta of angles) {
          const c = theta.cos();
          const s = theta.sin();
          console.log({
            angle: theta, co: c, si: s,
            f: axx * c * c + axy * c * s + ayy * s * s + ax * c + ay * s + a1});
      } */
        return b;
    }
    /**
     * Compute intersections of unit circle x^2 + y 2 = 1 with the ellipse
     *         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)
     * Solutions are returned as angles in the ellipse space.
     * @param cx center x
     * @param cy center y
     * @param ux 0 degree vector x
     * @param uy 0 degree vector y
     * @param vx 90 degree vector x
     * @param vy 90 degree vector y
     * @param ellipseRadians solution angles in ellipse parameter space
     * @param circleRadians solution angles in circle parameter space
     */
    static solveUnitCircleEllipseIntersection(cx, cy, ux, uy, vx, vy, ellipseRadians, circleRadians) {
        circleRadians.length = 0;
        const acc = ux * ux + uy * uy;
        const acs = 2.0 * (ux * vx + uy * vy);
        const ass = vx * vx + vy * vy;
        const ac = 2.0 * (ux * cx + uy * cy);
        const asi = 2.0 * (vx * cx + vy * cy);
        const a = cx * cx + cy * cy - 1.0;
        const status = this.solveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);
        for (const radians of ellipseRadians) {
            const cc = Math.cos(radians);
            const ss = Math.sin(radians);
            const x = cx + ux * cc + vx * ss;
            const y = cy + uy * cc + vy * ss;
            circleRadians.push(Math.atan2(y, x));
        }
        return status;
    }
    /**
     * Compute intersections of unit circle x^2 + y 2 = w^2 with the ellipse
     *         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)/ (cw + uw Math.Cos + vw * Math.Sin)
     * Solutions are returned as angles in the ellipse space.
     * @param cx center x
     * @param cy center y
     * @param cw center w
     * @param ux 0 degree vector x
     * @param uy 0 degree vector y
     * @param uw 0 degree vector w
     * @param vx 90 degree vector x
     * @param vy 90 degree vector y
     * @param vw 90 degree vector w
     * @param ellipseRadians solution angles in ellipse parameter space
     * @param circleRadians solution angles in circle parameter space
     */
    static solveUnitCircleHomogeneousEllipseIntersection(cx, cy, cw, ux, uy, uw, vx, vy, vw, ellipseRadians, circleRadians) {
        circleRadians.length = 0;
        const acc = ux * ux + uy * uy - uw * uw;
        const acs = 2.0 * (ux * vx + uy * vy - uw * vw);
        const ass = vx * vx + vy * vy - vw * vw;
        const ac = 2.0 * (ux * cx + uy * cy - uw * cw);
        const asi = 2.0 * (vx * cx + vy * cy - vw * cw);
        const a = cx * cx + cy * cy - cw * cw;
        const status = this.solveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);
        for (const radians of ellipseRadians) {
            const cc = Math.cos(radians);
            const ss = Math.sin(radians);
            const x = cx + ux * cc + vx * ss;
            const y = cy + uy * cc + vy * ss;
            circleRadians.push(Math.atan2(y, x));
        }
        return status;
    }
}
exports.TrigPolynomial = TrigPolynomial;
// tolerance for small angle decision.
TrigPolynomial._smallAngle = 1.0e-11;
/** Standard Basis coefficients for rational sine numerator. */
TrigPolynomial.S = Float64Array.from([0.0, 2.0, -2.0]);
/** Standard Basis coefficients for rational cosine numerator. */
TrigPolynomial.C = Float64Array.from([1.0, -2.0]);
/** Standard Basis coefficients for rational denominator. */
TrigPolynomial.W = Float64Array.from([1.0, -2.0, 2.0]);
/** Standard Basis coefficients for cosine*weight numerator */
TrigPolynomial.CW = Float64Array.from([1.0, -4.0, 6.0, -4.0]);
/** Standard Basis coefficients for sine*weight numerator */
TrigPolynomial.SW = Float64Array.from([0.0, 2.0, -6.0, 8.0, -4.0]);
/** Standard Basis coefficients for sine*cosine numerator */
TrigPolynomial.SC = Float64Array.from([0.0, 2.0, -6.0, 4.0]);
/** Standard Basis coefficients for sine^2 numerator */
TrigPolynomial.SS = Float64Array.from([0.0, 0.0, 4.0, -8.0, 4.0]);
/** Standard Basis coefficients for cosine^2 numerator */
TrigPolynomial.CC = Float64Array.from([1.0, -4.0, 4.0]);
/** Standard Basis coefficients for weight^2 */
TrigPolynomial.WW = Float64Array.from([1.0, -4.0, 8.0, -8.0, 4.0]);
/** Standard Basis coefficients for (Math.Cos^2 - sine^2) numerator */
TrigPolynomial.CCminusSS = Float64Array.from([1.0, -4.0, 0.0, 8.0, -4.0]);
TrigPolynomial._coefficientRelTol = 1.0e-12;
/**
 * static methods for commonly appearing sets of equations in 2 or 3 variables
 * @public
 */
class SmallSystem {
    /**
     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection.
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param a0 start point of line a
     * @param a1  end point of line a
     * @param b0  start point of line b
     * @param b1 end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment2dXYTransverseIntersectionUnbounded(a0, a1, b0, b1, result) {
        const ux = a1.x - a0.x;
        const uy = a1.y - a0.y;
        const vx = b1.x - b0.x;
        const vy = b1.y - b0.y;
        const cx = b0.x - a0.x;
        const cy = b0.y - a0.y;
        const uv = Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy);
        const cv = Geometry_1.Geometry.crossProductXYXY(cx, cy, vx, vy);
        const cu = Geometry_1.Geometry.crossProductXYXY(ux, uy, cx, cy);
        const s = Geometry_1.Geometry.conditionalDivideFraction(cv, uv);
        const t = Geometry_1.Geometry.conditionalDivideFraction(cu, uv);
        if (s !== undefined && t !== undefined) {
            result.set(s, -t);
            return true;
        }
        result.set(0, 0);
        return false;
    }
    /**
     * * (ax0,ay0) to (ax0+ux,ay0+uy) are line A.
     * * (bx0,by0) to (bx0+vx,by0+vy) are lineB.
     * * Return true if the lines have a simple intersection.
     * * Return the fractional (not xy) coordinates in result.x, result.y
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegmentXYUVTransverseIntersectionUnbounded(ax0, ay0, ux, uy, bx0, by0, vx, vy, result) {
        const cx = bx0 - ax0;
        const cy = by0 - ay0;
        const uv = Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy);
        const cv = Geometry_1.Geometry.crossProductXYXY(cx, cy, vx, vy);
        const cu = Geometry_1.Geometry.crossProductXYXY(ux, uy, cx, cy);
        const s = Geometry_1.Geometry.conditionalDivideFraction(cv, uv);
        const t = Geometry_1.Geometry.conditionalDivideFraction(cu, uv);
        if (s !== undefined && t !== undefined) {
            result.set(s, -t);
            return true;
        }
        result.set(0, 0);
        return false;
    }
    /**
     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param a0 start point of line a
     * @param a1  end point of line a
     * @param b0  start point of line b
     * @param b1 end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment3dXYTransverseIntersectionUnbounded(a0, a1, b0, b1, result) {
        const ux = a1.x - a0.x;
        const uy = a1.y - a0.y;
        const vx = b1.x - b0.x;
        const vy = b1.y - b0.y;
        const cx = b0.x - a0.x;
        const cy = b0.y - a0.y;
        const uv = Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy);
        const cv = Geometry_1.Geometry.crossProductXYXY(cx, cy, vx, vy);
        const cu = Geometry_1.Geometry.crossProductXYXY(ux, uy, cx, cy);
        const s = Geometry_1.Geometry.conditionalDivideFraction(cv, uv);
        const t = Geometry_1.Geometry.conditionalDivideFraction(cu, uv);
        if (s !== undefined && t !== undefined) {
            result.set(s, -t);
            return true;
        }
        result.set(0, 0);
        return false;
    }
    /**
     * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts of WEIGHTED 4D Points
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param hA0 homogeneous start point of line a
     * @param hA1 homogeneous end point of line a
     * @param hB0 homogeneous start point of line b
     * @param hB1 homogeneous end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment3dHXYTransverseIntersectionUnbounded(hA0, hA1, hB0, hB1, result) {
        // Considering only x,y,w parts....
        // Point Q along B is (in full homogeneous)  `(1-lambda) B0 + lambda 1`
        // PointQ is colinear with A0,A1 when the determinant det (A0,A1,Q) is zero.  (Each column takes xyw parts)
        const alpha0 = Geometry_1.Geometry.tripleProduct(hA0.x, hA1.x, hB0.x, hA0.y, hA1.y, hB0.y, hA0.w, hA1.w, hB0.w);
        const alpha1 = Geometry_1.Geometry.tripleProduct(hA0.x, hA1.x, hB1.x, hA0.y, hA1.y, hB1.y, hA0.w, hA1.w, hB1.w);
        const fractionB = Geometry_1.Geometry.conditionalDivideFraction(-alpha0, alpha1 - alpha0);
        if (fractionB !== undefined) {
            const beta0 = Geometry_1.Geometry.tripleProduct(hB0.x, hB1.x, hA0.x, hB0.y, hB1.y, hA0.y, hB0.w, hB1.w, hA0.w);
            const beta1 = Geometry_1.Geometry.tripleProduct(hB0.x, hB1.x, hA1.x, hB0.y, hB1.y, hA1.y, hB0.w, hB1.w, hA1.w);
            const fractionA = Geometry_1.Geometry.conditionalDivideFraction(-beta0, beta1 - beta0);
            if (fractionA !== undefined)
                return Point2dVector2d_1.Vector2d.create(fractionA, fractionB, result);
        }
        return undefined;
    }
    /**
     * Return the line fraction at which the (homogeneous) line is closest to a space point as viewed in xy only.
     * @param hA0 homogeneous start point of line a
     * @param hA1 homogeneous end point of line a
     * @param spacePoint homogeneous point in space
     */
    static lineSegment3dHXYClosestPointUnbounded(hA0, hA1, spacePoint) {
        // Considering only x,y,w parts....
        // weighted difference of (A1 w0 - A0 w1) is (cartesian) tangent vector along the line as viewed.
        // The perpendicular (pure vector) W = (-y,x) flip is the direction of projection
        // Point Q along A is (in full homogeneous)  `(1-lambda) A0 + lambda 1 A1`
        // PointQ is colinear with spacePoint and and W when the xyw homogeneous determinant | Q W spacePoint | is zero.
        const tx = hA1.x * hA0.w - hA0.x * hA1.w;
        const ty = hA1.y * hA0.w - hA0.y * hA1.w;
        const det0 = Geometry_1.Geometry.tripleProduct(hA0.x, -ty, spacePoint.x, hA0.y, tx, spacePoint.y, hA0.w, 0, spacePoint.w);
        const det1 = Geometry_1.Geometry.tripleProduct(hA1.x, -ty, spacePoint.x, hA1.y, tx, spacePoint.y, hA1.w, 0, spacePoint.w);
        return Geometry_1.Geometry.conditionalDivideFraction(-det0, det1 - det0);
    }
    /**
     * Return the line fraction at which the line is closest to a space point as viewed in xy only.
     * @param pointA0 start point
     * @param pointA1 end point
     * @param spacePoint homogeneous point in space
     */
    static lineSegment3dXYClosestPointUnbounded(pointA0, pointA1, spacePoint) {
        // Considering only x,y parts....
        const ux = pointA1.x - pointA0.x;
        const uy = pointA1.y - pointA0.y;
        const uu = ux * ux + uy * uy;
        const vx = spacePoint.x - pointA0.x;
        const vy = spacePoint.y - pointA0.y;
        const uv = ux * vx + uy * vy;
        return Geometry_1.Geometry.conditionalDivideFraction(uv, uu);
    }
    /**
     * Return the line fraction at which the line is closest to a space point
     * @param pointA0 start point
     * @param pointA1 end point
     * @param spacePoint homogeneous point in space
     */
    static lineSegment3dClosestPointUnbounded(pointA0, pointA1, spacePoint) {
        // Considering only x,y parts....
        const ux = pointA1.x - pointA0.x;
        const uy = pointA1.y - pointA0.y;
        const uz = pointA1.z - pointA0.z;
        const uu = ux * ux + uy * uy + uz * uz;
        const vx = spacePoint.x - pointA0.x;
        const vy = spacePoint.y - pointA0.y;
        const vz = spacePoint.z - pointA0.z;
        const uv = ux * vx + uy * vy + uz * vz;
        return Geometry_1.Geometry.conditionalDivideFraction(uv, uu);
    }
    /**
     * Return true if lines (a0,a1) to (b0, b1) have closest approach (go by each other) in 3d
     * Return the fractional (not xy) coordinates in result.x, result.y
     * @param a0 start point of line a
     * @param a1  end point of line a
     * @param b0  start point of line b
     * @param b1 end point of line b
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static lineSegment3dClosestApproachUnbounded(a0, a1, b0, b1, result) {
        return this.ray3dXYZUVWClosestApproachUnbounded(a0.x, a0.y, a0.z, a1.x - a0.x, a1.y - a0.y, a1.z - a0.z, b0.x, b0.y, b0.z, b1.x - b0.x, b1.y - b0.y, b1.z - b0.z, result);
    }
    /**
     * Return true if lines (a0,a1) to (b0, b1) have closest approach (go by each other) in 3d
     * Return the fractional (not xy) coordinates as x and y parts of a Point2d.
     * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.
     */
    static ray3dXYZUVWClosestApproachUnbounded(ax, ay, az, au, av, aw, bx, by, bz, bu, bv, bw, result) {
        const cx = bx - ax;
        const cy = by - ay;
        const cz = bz - az;
        const uu = Geometry_1.Geometry.hypotenuseSquaredXYZ(au, av, aw);
        const vv = Geometry_1.Geometry.hypotenuseSquaredXYZ(bu, bv, bw);
        const uv = Geometry_1.Geometry.dotProductXYZXYZ(au, av, aw, bu, bv, bw);
        const cu = Geometry_1.Geometry.dotProductXYZXYZ(cx, cy, cz, au, av, aw);
        const cv = Geometry_1.Geometry.dotProductXYZXYZ(cx, cy, cz, bu, bv, bw);
        return SmallSystem.linearSystem2d(uu, -uv, uv, -vv, cu, cv, result);
    }
    /**
     * Solve the pair of linear equations
     * * `ux * x + vx + y = cx`
     * * `uy * x + vy * y = cy`
     * @param ux xx coefficient
     * @param vx xy coefficient
     * @param uy yx coefficient
     * @param vy yy coefficient
     * @param cx x right hand side
     * @param cy y right hand side
     * @param result (x,y) solution.  (MUST be preallocated by caller)
     */
    static linearSystem2d(ux, vx, // first row of matrix
    uy, vy, // second row of matrix
    cx, cy, // right side
    result) {
        const uv = Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy);
        const cv = Geometry_1.Geometry.crossProductXYXY(cx, cy, vx, vy);
        const cu = Geometry_1.Geometry.crossProductXYXY(ux, uy, cx, cy);
        const s = Geometry_1.Geometry.conditionalDivideFraction(cv, uv);
        const t = Geometry_1.Geometry.conditionalDivideFraction(cu, uv);
        if (s !== undefined && t !== undefined) {
            result.set(s, t);
            return true;
        }
        result.set(0, 0);
        return false;
    }
    /**
     * Solve a linear system
     * * x equation: `ux *u * vx * v + wx * w = cx`
     * * y equation: `uy *u * vy * v + wy * w = cy`
     * * z equation: `uz *u * vz * v + wz * w = cz`
     * @param axx row 0, column 0 coefficient
     * @param axy row 0, column 1 coefficient
     * @param axz row 0, column 1 coefficient
     * @param ayx row 1, column 0 coefficient
     * @param ayy row 1, column 1 coefficient
     * @param ayz row 1, column 2 coefficient
     * @param azx row 2, column 0 coefficient
     * @param azy row 2, column 1 coefficient
     * @param azz row 2, column 2 coefficient
     * @param cx right hand side row 0 coefficient
     * @param cy right hand side row 1 coefficient
     * @param cz right hand side row 2 coefficient
     * @param result optional result.
     */
    static linearSystem3d(axx, axy, axz, // first row of matrix
    ayx, ayy, ayz, // second row of matrix
    azx, azy, azz, // second row of matrix
    cx, cy, cz, // right side
    result) {
        // determinants of various combinations of columns ...
        const detXYZ = Geometry_1.Geometry.tripleProduct(axx, ayx, azx, axy, ayy, azy, axz, ayz, azz);
        const detCYZ = Geometry_1.Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, axz, ayz, azz);
        const detXCZ = Geometry_1.Geometry.tripleProduct(axx, ayx, azx, cx, cy, cz, axz, ayz, azz);
        const detXYC = Geometry_1.Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, cx, cy, cz);
        const s = Geometry_1.Geometry.conditionalDivideFraction(detCYZ, detXYZ);
        const t = Geometry_1.Geometry.conditionalDivideFraction(detXCZ, detXYZ);
        const u = Geometry_1.Geometry.conditionalDivideFraction(detXYC, detXYZ);
        if (s !== undefined && t !== undefined && t !== undefined) {
            return Point3dVector3d_1.Vector3d.create(s, t, u, result);
        }
        return undefined;
    }
    /**
     * * in rowB, replace `rowB[j] += a * rowB[pivot] * rowA[j] / rowA[pivot]` for `j>pivot`
     * @param rowA row that does not change
     * @param pivotIndex index of pivot (divisor) in rowA.
     * @param rowB row where elimination occurs.
     */
    static eliminateFromPivot(rowA, pivotIndex, rowB, a) {
        const n = rowA.length;
        let q = Geometry_1.Geometry.conditionalDivideFraction(rowB[pivotIndex], rowA[pivotIndex]);
        if (q === undefined)
            return false;
        q *= a;
        for (let j = pivotIndex + 1; j < n; j++)
            rowB[j] += q * rowA[j];
        return true;
    }
    /**
     * Solve a pair of bilinear equations
     * * First equation: `a0 + b0 * u + c0 * v + d0 * u * v = 0`
     * * Second equation: `a0 + b0 * u + c0 * v + d0 * u * v = 0`
     */
    static solveBilinearPair(a0, b0, c0, d0, a1, b1, c1, d1) {
        // constant linear, and quadratic coefficients for c0 + c1 * u + c2 * u*u = 0
        const e0 = Geometry_1.Geometry.crossProductXYXY(a0, a1, c0, c1);
        const e1 = Geometry_1.Geometry.crossProductXYXY(b0, b1, c0, c1) + Geometry_1.Geometry.crossProductXYXY(a0, a1, d0, d1);
        const e2 = Geometry_1.Geometry.crossProductXYXY(b0, b1, d0, d1);
        const uRoots = Degree2PowerPolynomial.solveQuadratic(e2, e1, e0);
        if (uRoots === undefined)
            return undefined;
        const uv = [];
        for (const u of uRoots) {
            const v0 = Geometry_1.Geometry.conditionalDivideFraction(-(a0 + b0 * u), c0 + d0 * u);
            const v1 = Geometry_1.Geometry.conditionalDivideFraction(-(a1 + b1 * u), c1 + d1 * u);
            if (v0 !== undefined)
                uv.push(Point2dVector2d_1.Point2d.create(u, v0));
            else if (v1 !== undefined)
                uv.push(Point2dVector2d_1.Point2d.create(u, v1));
        }
        return uv;
    }
}
exports.SmallSystem = SmallSystem;
/**
 * * bilinear expression
 * * `f(u,v) = a + b * u * c * v + d * u * v`
 * @internal
 */
class BilinearPolynomial {
    /**
     *
     * @param a constant coefficient
     * @param b `u` coefficient
     * @param c `v` coefficient
     * @param d `u*v` coefficient
     */
    constructor(a, b, c, d) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
    }
    /**
     * Evaluate the bilinear expression at u,v
     */
    evaluate(u, v) {
        return this.a + this.b * u + v * (this.c + this.d * u);
    }
    /** Create a bilinear polynomial z=f(u,v) given z values at 00, 10, 01, 11.
     */
    static createUnitSquareValues(f00, f10, f01, f11) {
        return new BilinearPolynomial(f00, f10, f10, f11 - f10 - f01);
    }
    /**
     * Solve the simultaneous equations
     * * `p(u,v) = pValue`
     * * `q(u,v) = qValue`
     * @param p
     * @param pValue
     * @param q
     * @param qValue
     */
    static solvePair(p, pValue, q, qValue) {
        return SmallSystem.solveBilinearPair(p.a - pValue, p.b, p.c, p.d, q.a - qValue, q.b, q.c, q.d);
    }
}
exports.BilinearPolynomial = BilinearPolynomial;


/***/ }),

/***/ "./lib/numerics/Quadrature.js":
/*!************************************!*\
  !*** ./lib/numerics/Quadrature.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
/** Support class for quadrature -- approximate integrals by summing weighted function values.
 * These are filled with x and weight for quadrature between xA and xB
 *
 * Since quadrature is done in side tight loops, these methods are structured for minimum object
 * allocation.
 * For methods names setupGauss<N> (where N is a smallish integer), the CALLER creates arrays xMapped and wMapped
 * The method installs particular x and weight values.
 * @internal
 */
class Quadrature {
    /**
     * Given points and weights in a reference interval (usually 0 to 1):
     *
     * * map each xRef[i] to xA + h * xRef[i];
     * * scale each weight wRef[i] to h * wRef[i]
     * * all arrays are assumed to have xRef.length entries.
     * * the return value is xRef.length
     * @param xA beginning of target interval
     * @param h length of target interval
     * @param xRef x coordinates in reference interval
     * @param wRef weights for integration in the reference interval
     * @param xMapped x coordinates to evaluate integrands
     * @param wMapped weights for evaluated integrands
     */
    static mapWeights(xA, h, xRef, wRef, xMapped, wMapped) {
        const n = xRef.length;
        for (let i = 0; i < n; i++) {
            xMapped[i] = xA + h * xRef[i];
            wMapped[i] = h * wRef[i];
        }
        return n;
    }
    /** Install 1 (ONE) x and weight values for quadrature from xA to xB. */
    static setupGauss1(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX1Interval01, Quadrature.gaussW1Interval01, xMapped, wMapped);
    }
    /** Install 2 (TWO) x and weight values for quadrature from xA to xB. */
    static setupGauss2(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX2Interval01, Quadrature.gaussW2Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
            const x0 = 0.5 * (xA + xB);
                const h = 0.5 * (xB - xA);
                const dx = h / Math.sqrt(3);
                xMapped[0] = x0 - dx; xMapped[1] = x0 + dx;
                wMapped[0] = wMapped[1] = h;
                */
    }
    /** Install 3 (THREE) x and weight values for quadrature from xA to xB. */
    static setupGauss3(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX3Interval01, Quadrature.gaussW3Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
        const x0 = 0.5 * (xA + xB);
        const h = 0.5 * (xB - xA);
        const a = Math.sqrt(0.6);
        const b = h * 5.0 / 9.0;
        const dx = a * h;
        xMapped[0] = x0 - dx; xMapped[1] = x0; xMapped[2] = x0 + dx;
        wMapped[0] = wMapped[2] = b;
        wMapped[1] = h * 8.0 / 9.0;
        return 3;
        */
    }
    /** Install 5 (FIVE) x and weight values for quadrature from xA to xB. */
    static setupGauss5(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX5Interval01, Quadrature.gaussW5Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
        const x0 = 0.5 * (xA + xB);
        const h = 0.5 * (xB - xA);
        const q = 2.0 * Math.sqrt(10.0 / 7.0);
        const b = 13.0 * Math.sqrt(70.0);
        const a1 = h * Math.sqrt(5.0 - q) / 3.0;
        const a2 = h * Math.sqrt(5.0 + q) / 3.0;
        const w1 = h * (322.0 + b) / 900.0;
        const w2 = h * (322.0 - b) / 900;
        const w0 = h * 128.0 / 225.0;
        xMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0; xMapped[3] = x0 + a1; xMapped[4] = x0 + a2;
        wMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w0; wMapped[3] = w1; wMapped[4] = w2;
        return 5;
        */
    }
    /** Install 4 (FOUR) x and weight values for quadrature from xA to xB. */
    static setupGauss4(xA, xB, xMapped, wMapped) {
        return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX4Interval01, Quadrature.gaussW4Interval01, xMapped, wMapped);
        /*  // exact formulas for interval xA..xB:
    const x0 = 0.5 * (xA + xB);
    const h = 0.5 * (xB - xA);
    const q = 2.0 * Math.sqrt(6.0 / 5.0);
    const r = Math.sqrt(30.0);
    const a1 = h * Math.sqrt((3 - q) / 7.0);
    const w1 = h * (18.0 + r) / 36.0;
    const a2 = h * Math.sqrt((3 + q) / 7.0);
    const w2 = h * (18.0 - r) / 36.0;
    xMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0 + a1; xMapped[3] = x0 + a2;
    wMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w1; wMapped[3] = w2;
    return 4;
    */
    }
    /** Sum function values with given weights and x values. */
    static sum1(xx, ww, n, f) {
        let sum = 0;
        for (let i = 0; i < n; i++)
            sum += ww[i] * f(xx[i]);
        return sum;
    }
}
exports.Quadrature = Quadrature;
/** x value for 1 point gauss rule in 0..1 interval */
Quadrature.gaussX1Interval01 = new Float64Array([0.5]);
/** weight for 1 point gauss rule in 0..1 interval */
Quadrature.gaussW1Interval01 = new Float64Array([1.0]);
/** x value for 2 point gauss rule in 0..1 interval */
Quadrature.gaussX2Interval01 = new Float64Array([0.21132486540518708, 0.7886751345948129]);
/** weight for 2 point gauss rule in 0..1 interval */
Quadrature.gaussW2Interval01 = new Float64Array([0.5, 0.5]);
/** x value for 3 point gauss rule in 0..1 interval */
Quadrature.gaussX3Interval01 = new Float64Array([0.1127016653792583, 0.5, 0.8872983346207417]);
/** weight for 3 point gauss rule in 0..1 interval */
Quadrature.gaussW3Interval01 = new Float64Array([0.2777777777777778, 0.4444444444444444, 0.2777777777777778]);
/** x value for 4 point gauss rule in 0..1 interval */
Quadrature.gaussX4Interval01 = new Float64Array([0.06943184420297371, 0.33000947820757187, 0.6699905217924281, 0.9305681557970262]);
/** weight for 4 point gauss rule in 0..1 interval */
Quadrature.gaussW4Interval01 = new Float64Array([0.17392742256872692, 0.3260725774312731, 0.3260725774312731, 0.17392742256872692]);
/** x value for 5 point gauss rule in 0..1 interval */
Quadrature.gaussX5Interval01 = new Float64Array([0.04691007703066802, 0.23076534494715845, 0.5, 0.7692346550528415, 0.9530899229693319]);
/** weight for 5 point gauss rule in 0..1 interval */
Quadrature.gaussW5Interval01 = new Float64Array([0.11846344252809454, 0.23931433524968324, 0.28444444444444444, 0.23931433524968324, 0.11846344252809454]);
/**
 * This class carries public members as needed for users to have gauss points that are used
 * in the callers loops.
 * @internal
 */
class GaussMapper {
    /** setup gauss arrays.
     * * Number of gauss points must be 1 to 5 (inclusive)
     * @param numGauss requested number of gauss points.
     */
    constructor(numGaussPoints) {
        const maxGauss = 7; // (As of Nov 2 2018, 7 is a fluffy over-allocation-- the quadrature class only handles up to 5.)
        this.gaussX = new Float64Array(maxGauss);
        this.gaussW = new Float64Array(maxGauss);
        // This sets the number of gauss points.  This integrates exactly for polynomials of (degree 2*numGauss - 1).
        if (numGaussPoints > 5 || numGaussPoints < 1)
            numGaussPoints = 5;
        switch (numGaussPoints) {
            case 1:
                this.mapXAndWFunction = Quadrature.setupGauss1;
                break;
            case 2:
                this.mapXAndWFunction = Quadrature.setupGauss2;
                break;
            case 3:
                this.mapXAndWFunction = Quadrature.setupGauss3;
                break;
            case 4:
                this.mapXAndWFunction = Quadrature.setupGauss4;
                break;
            default:
                this.mapXAndWFunction = Quadrature.setupGauss5;
                break;
        }
    }
    /** Execute the mapXAndWFunction to set up arrays for integration from xA to xB */
    mapXAndW(xA, xB) {
        return this.mapXAndWFunction(xA, xB, this.gaussX, this.gaussW);
    }
}
exports.GaussMapper = GaussMapper;
// someday .... http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/overlapped-newton-cotes-quadratures/


/***/ }),

/***/ "./lib/numerics/Range1dArray.js":
/*!**************************************!*\
  !*** ./lib/numerics/Range1dArray.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * A Range1d array is a set of intervals, such as occur when a line is clipped to a (nonconvex) polygon
 * @internal
 */
class Range1dArray {
    /** Internal step: Caller supplies rangeA = interval from left operand of set difference {A - B}
     *  ib = lowest possible index of overlapping interval of {B}
     *  Output live parts of rangeA, advancing B over intervals that do not extend beyond {rangeA}
     *  iB is advanced to the first interval whose high is to the right of {rangeA.high}
     */
    static advanceIntervalDifference(rangeA, dataB, iB, retVal) {
        const nB = dataB.length;
        let low = rangeA.low;
        let high = rangeA.high;
        while (iB < nB) {
            const rangeB = dataB[iB];
            if (rangeB.high < low) {
                iB++;
            }
            else if (rangeB.high <= high) {
                if (rangeB.low > low)
                    retVal.push(Range_1.Range1d.createXX(low, rangeB.low));
                low = rangeB.high;
                iB++;
            }
            else {
                // B ends beyond rangeA...
                if (rangeB.low < high)
                    high = rangeB.low;
                break;
            }
        }
        if (low < high)
            retVal.push(Range_1.Range1d.createXX(low, high));
        return retVal;
    }
    /** Intersect intervals in two pre-sorted sets. Output may NOT be the same as either input. */
    static differenceSorted(dataA, dataB) {
        const nA = dataA.length;
        const iB = 0;
        const retVal = [];
        for (let iA = 0; iA < nA; iA++) {
            Range1dArray.advanceIntervalDifference(dataA[iA], dataB, iB, retVal);
        }
        return retVal;
    }
    /** Internal step: Caller ensures rangeA is the "lower" interval.
     *  Look rangeB to decide (a) what output interval to create and (b) which read index to advance.
     *  Returns true or false to indicate whether the value associated with rangeA or rangeB should be incremented after this function returns
     */
    static advanceIntervalIntersection(rangeA, rangeB, retVal) {
        if (rangeB.low > rangeA.high) {
            return true;
        }
        else if (rangeB.high >= rangeA.high) {
            retVal.push(Range_1.Range1d.createXX(rangeB.low, rangeA.high));
            return true;
        }
        else {
            retVal.push(Range_1.Range1d.createXX(rangeB.low, rangeB.high));
            return false;
        }
    }
    /** Boolean intersection among the (presorted) input ranges */
    static intersectSorted(dataA, dataB) {
        let iA = 0;
        let iB = 0;
        const nA = dataA.length;
        const nB = dataB.length;
        const retVal = [];
        while (iA < nA && iB < nB) {
            const rangeA = dataA[iA];
            const rangeB = dataB[iB];
            if (rangeA.low <= rangeB.low) {
                if (Range1dArray.advanceIntervalIntersection(rangeA, rangeB, retVal))
                    iA++;
                else
                    iB++;
            }
            else {
                if (Range1dArray.advanceIntervalIntersection(rangeB, rangeA, retVal))
                    iB++;
                else
                    iA++;
            }
        }
        return retVal;
    }
    /** Internal step: Read an interval from the array.
     *  If it overlaps the work interval, advance the work interval, and return true to notify caller to increment read index.
     */
    static advanceIntervalUnion(workRange, source, readIndex) {
        if (readIndex >= source.length)
            return false;
        const candidate = source[readIndex];
        if (candidate.low > workRange.high)
            return false;
        if (candidate.high > workRange.high)
            workRange.high = candidate.high;
        return true;
    }
    /** Boolean union among the (presorted) input ranges */
    static unionSorted(dataA, dataB) {
        const nA = dataA.length;
        const nB = dataB.length;
        let iA = 0;
        let iB = 0;
        const retVal = [];
        while (iA < nA && iB < nB) {
            const rangeA = dataA[iA];
            const rangeB = dataB[iB];
            let workRange;
            // Pull from the lower of rangeA and rangeB. This always advances exactly one of the indices -- progress towards getting out.
            if (rangeA.low <= rangeB.low) {
                workRange = rangeA.clone();
                iA++;
            }
            else {
                workRange = rangeB.clone();
                iB++;
            }
            let toLoop = true;
            do {
                const resultA = Range1dArray.advanceIntervalUnion(workRange, dataA, iA);
                const resultB = Range1dArray.advanceIntervalUnion(workRange, dataB, iB);
                if (resultA)
                    iA++;
                if (resultB)
                    iB++;
                if (!(resultA || resultB))
                    toLoop = false;
            } while (toLoop);
            retVal.push(workRange);
        }
        while (iA < nA)
            retVal.push(dataA[iA++]);
        while (iB < nB)
            retVal.push(dataB[iB++]);
        return retVal;
    }
    /** Boolean parity among the (presorted) input ranges */
    static paritySorted(dataA, dataB) {
        // Combine the two arrays, and then perform a simplification using simplifySortParity function
        const retVal = [];
        for (const range of dataA)
            retVal.push(range.clone());
        for (const range of dataB)
            retVal.push(range.clone());
        // Sort the array
        retVal.sort(compareRange1dLexicalLowHigh);
        Range1dArray.simplifySortParity(retVal, true);
        return retVal;
    }
    /** Uses the Range1d specific compare function `compareRange1dLexicalLowHigh` for sorting the array of ranges */
    static sort(data) {
        data.sort(compareRange1dLexicalLowHigh);
    }
    /** Cleans up the array, compressing any overlapping ranges. If removeZeroLengthRanges is set to true, will also remove any Ranges in the form (x, x) */
    static simplifySortUnion(data, removeZeroLengthRanges = false) {
        if (data.length < 2)
            return;
        data.sort(compareRange1dLexicalLowHigh);
        let currIdx = 0;
        let toInsert = false;
        for (let i = 0; i < data.length; i++) {
            if (i === data.length - 1) {
                if (toInsert) {
                    if (!removeZeroLengthRanges || data[i].low !== data[i].high)
                        data[currIdx++] = data[i];
                }
                break;
            }
            if (data[i + 1].low > data[i].high) {
                if (!removeZeroLengthRanges || data[i].low !== data[i].high)
                    data[currIdx++] = data[i];
                continue;
            }
            else {
                data[i + 1].low = data[i].low;
                data[i + 1].high = Math.max(data[i].high, data[i + 1].high);
                toInsert = true;
            }
        }
        data.length = currIdx;
    }
    /** Apply parity logic among ranges which are not pre-sorted. */
    static simplifySortParity(data, removeZeroLengthRanges = false) {
        const numData = [];
        for (const range of data) {
            if (range.low !== range.high) {
                numData.push(range.low);
                numData.push(range.high);
            }
        }
        const n = numData.length;
        numData.sort((a, b) => {
            if (a < b)
                return -1;
            if (a > b)
                return 1;
            return 0;
        });
        let currIdx = 0;
        let x0;
        let x1;
        for (let i = 0; i < n; i += 2) {
            x0 = numData[i];
            x1 = numData[i + 1];
            if (!removeZeroLengthRanges) {
                Range_1.Range1d.createXX(x0, x1, data[currIdx++]);
            }
            else {
                // coalesce intervals that share end and start:
                while (i + 2 < n && numData[i + 2] === x1) {
                    i += 2;
                    x1 = numData[i + 1];
                }
                if (x1 > x0)
                    Range_1.Range1d.createXX(x0, x1, data[currIdx++]);
            }
        }
        data.length = currIdx;
    }
    /** test if value is "in" by union rules.
     * * This considers all intervals-- i.e. does not expect or take advantage of sorting.
     */
    static testUnion(data, value) {
        return this.countContainingRanges(data, value) > 0;
    }
    /** test if value is "in" by parity rules.
     * * This considers all intervals-- i.e. does not expect or take advantage of sorting.
     */
    static testParity(data, value) {
        let inside = false;
        for (const range of data) {
            if (range.containsX(value))
                inside = !inside;
        }
        return inside;
    }
    /** linear search to count number of intervals which contain `value`.
     */
    static countContainingRanges(data, value) {
        let n = 0;
        for (const range of data) {
            if (range.containsX(value))
                n++;
        }
        return n;
    }
    /** return an array with all the low and high values of all the ranges.
     * @param data array of ranges.
     * @param sort optionally request immediate sort.
     * @param compress optionally request removal of duplicates.
     */
    static getBreaks(data, result, sort = false, compress = false, clear = true) {
        if (!result)
            result = new GrowableFloat64Array_1.GrowableFloat64Array(2 * data.length);
        if (clear)
            result.clear();
        for (const range of data) {
            result.push(range.low);
            result.push(range.high);
        }
        if (sort)
            result.sort();
        if (compress)
            result.compressAdjacentDuplicates();
        return result;
    }
    /**  evaluate a point at an array of given fraction values
     * @param data array of ranges.
     * @param initialRangeFraction fraction coordinate applied only to first range. (typically negative)
     * @param rangeFraction fraction within each range.
     * @param includeDegenerateRange if false, skip rangeFraction for 0-length ranges.
     * @param gapFraction fraction within interval from each range high to successor low
     * @param includeDegenerateGap if false, skip rangeFraction for 0-length gaps.
     * @param finalRangeFraction fraction coordinate applied only to last range (typically an extrapolation above)
     * @param result array to receive values
     */
    static appendFractionalPoints(data, initialRangeFraction, rangeFraction, includeDegenerateRange, gapFraction, includeDegenerateGap, finalRangeFraction, result) {
        const numRange = data.length;
        if (numRange > 0) {
            if (undefined !== initialRangeFraction)
                result.push(data[0].fractionToPoint(initialRangeFraction));
            for (let i = 0; i < numRange; i++) {
                if (rangeFraction !== undefined && (includeDegenerateRange || data[i].low !== data[i].high))
                    result.push(data[i].fractionToPoint(rangeFraction));
                if (i > 1 && gapFraction !== undefined && (includeDegenerateGap || data[i].low !== data[i].high))
                    result.push(Geometry_1.Geometry.interpolate(data[i - 1].high, gapFraction, data[i].low));
            }
            if (undefined !== finalRangeFraction)
                result.push(data[numRange - 1].fractionToPoint(finalRangeFraction));
        }
        return result;
    }
    /** Return a single range constructed with the low of range 0 and high of final range in the set.  */
    static firstLowToLastHigh(data) {
        if (data.length === 0)
            return Range_1.Range1d.createNull();
        return Range_1.Range1d.createXX(data[0].low, data[data.length - 1].high);
    }
    /** sum the lengths of all ranges */
    static sumLengths(data) {
        let sum = 0.0;
        for (const range of data) {
            sum += range.length();
        }
        return sum;
    }
    /**
     * Test if the low,high values are sorted with no overlap.
     * @param data array of ranges.
     * @param strict if true, consider exact high-to-low match as overlap.
     */
    static isSorted(data, strict = true) {
        const n = data.length;
        if (strict) {
            for (let i = 0; i + 1 < n; i++) {
                if (data[i].high >= data[i + 1].low)
                    return false;
            }
        }
        else {
            for (let i = 0; i + 1 < n; i++) {
                if (data[i].high > data[i + 1].low)
                    return false;
            }
        }
        return true;
    }
}
exports.Range1dArray = Range1dArray;
/** Checks low's first, then high's
 * @internal
 */
function compareRange1dLexicalLowHigh(a, b) {
    if (a.low < b.low)
        return -1;
    if (a.low > b.low)
        return 1;
    if (a.high < b.high)
        return -1;
    if (a.high > b.high)
        return 1;
    return 0;
}
exports.compareRange1dLexicalLowHigh = compareRange1dLexicalLowHigh;


/***/ }),

/***/ "./lib/numerics/TriDiagonalSystem.js":
/*!*******************************************!*\
  !*** ./lib/numerics/TriDiagonalSystem.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Numerics */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
// Enumerated type lies outside of TriDiagonalSystem, as TSLint prevented declaration within class
var DataState;
(function (DataState) {
    DataState[DataState["RawMatrix"] = 0] = "RawMatrix";
    DataState[DataState["FactorOK"] = 1] = "FactorOK";
    DataState[DataState["FactorFailed"] = 2] = "FactorFailed";
})(DataState || (DataState = {}));
/**
 * Linear system operations on a matrix with data only on the diagonal and its immediate left and right neighbors
 * @internal
 */
class TriDiagonalSystem {
    constructor(n) {
        this._aLeft = new Float64Array(n);
        this._aDiag = new Float64Array(n);
        this._aRight = new Float64Array(n);
        this._b = new Float64Array(n);
        this._x = new Float64Array(n);
        this.reset();
    }
    /** Reset to RawMatrix state with all coefficients zero */
    reset() {
        this._dataState = DataState.RawMatrix;
        const n = this._aDiag.length;
        for (let i = 0; i < n; i++) {
            this._aLeft[i] = this._aRight[i] = this._aDiag[i] = this._b[i] = this._x[i] = 0.0;
        }
    }
    /** Install data in a row of the matrix */
    setRow(row, left, diag, right) {
        this._aLeft[row] = left;
        this._aDiag[row] = diag;
        this._aRight[row] = right;
    }
    /** Add to row of matrix */
    addToRow(row, left, diag, right) {
        this._aLeft[row] += left;
        this._aDiag[row] += diag;
        this._aRight[row] += right;
    }
    /** Install data in the right side (B) vector */
    setB(row, bb) {
        this._b[row] = bb;
    }
    /** Add to an entry in the right side (B) vector */
    addToB(row, bb) {
        this._b[row] += bb;
    }
    /** Access data from the right side (B) vector */
    getB(row) {
        return this._b[row];
    }
    /** Install data in the solution (X) vector */
    setX(row, xx) {
        this._x[row] = xx;
    }
    /** Access data frin the solution (X) vector */
    getX(row) {
        return this._x[row];
    }
    /** Get method for matrix and vector order */
    order() {
        return this._aDiag.length;
    }
    /** Compute product of AX and save as B */
    multiplyAX() {
        if (this._dataState === DataState.FactorFailed) {
            return false;
        }
        else if (this._dataState === DataState.FactorOK) {
            const n = this._aDiag.length;
            const nm1 = n - 1;
            for (let i = 0; i < nm1; i++) {
                this._b[i] = this._aDiag[i] * this._x[i] + this._aRight[i] * this._x[i + 1];
            }
            this._b[nm1] = this._aDiag[nm1] * this._x[nm1];
            for (let i = nm1; i > 0; i--) {
                this._b[i] += this._aLeft[i] * this._b[i - 1];
            }
            return true;
        }
        else {
            const n = this._aDiag.length;
            const nm1 = n - 1;
            this._b[0] = this._aDiag[0] * this._x[0] + this._aRight[0] * this._x[1];
            let i;
            for (i = 1; i < nm1; i++) {
                this._b[i] = this._aLeft[i] * this._x[i - 1] + this._aDiag[i] * this._x[i] + this._aRight[i] * this._x[i + 1];
            }
            this._b[nm1] = this._aLeft[nm1] * this._x[n - 2] + this._aDiag[i] * this._x[nm1];
            return true;
        }
    }
    /** Compute product of AX and save as B */
    multiplyAXPoints(pointX, pointB) {
        pointB.length = 0;
        while (pointB.length < pointX.length)
            pointB.push(Point3dVector3d_1.Point3d.create());
        pointB.length = pointX.length;
        if (this._dataState === DataState.FactorFailed) {
            return false;
        }
        else if (this._dataState === DataState.FactorOK) {
            const n = this._aDiag.length;
            const nm1 = n - 1;
            for (let i = 0; i < nm1; i++) {
                Point3dVector3d_1.Point3d.createAdd2Scaled(pointX[i], this._aDiag[i], pointX[i + 1], this._aRight[i], pointB[i]);
            }
            Point3dVector3d_1.Point3d.createScale(pointX[nm1], this._aDiag[nm1], pointB[nm1]);
            for (let i = nm1; i > 0; i--) {
                pointB[i].plusScaled(pointB[i - 1], this._aLeft[i], pointB[i]);
            }
            return true;
        }
        else {
            const n = this._aDiag.length;
            const nm1 = n - 1;
            Point3dVector3d_1.Point3d.createAdd2Scaled(pointX[0], this._aDiag[0], pointX[1], this._aRight[0], pointB[0]);
            let i;
            for (i = 1; i < nm1; i++) {
                Point3dVector3d_1.Point3d.createAdd3Scaled(pointX[i - 1], this._aLeft[i], pointX[i], this._aDiag[i], pointX[i + 1], this._aRight[i], pointB[i]);
            }
            Point3dVector3d_1.Point3d.createAdd2Scaled(pointX[n - 2], this._aLeft[nm1], pointX[nm1], this._aDiag[nm1], pointB[nm1]);
            return true;
        }
    }
    /** Multiply the stored factors together to return to plain matrix form */
    defactor() {
        if (this._dataState === DataState.RawMatrix) {
            return true;
        }
        if (this._dataState === DataState.FactorFailed) {
            return false;
        }
        const n = this._aDiag.length;
        const nm1 = n - 1;
        for (let i = nm1; i > 0; i--) {
            this._aDiag[i] += this._aLeft[i] * this._aRight[i - 1];
            this._aLeft[i] *= this._aDiag[i - 1];
        }
        this._dataState = DataState.RawMatrix;
        return true;
    }
    /** Factor the tridiagonal matrix to LU parts. b, x, not altered */
    factor() {
        if (this._dataState === DataState.FactorOK) {
            return true;
        }
        if (this._dataState !== DataState.RawMatrix) {
            return false;
        }
        this._dataState = DataState.FactorFailed;
        const n1 = this._aDiag.length - 1; // Last pivot index
        // Eliminate in subdiagonal.
        for (let i = 0; i < n1; i++) {
            const r = Geometry_1.Geometry.conditionalDivideFraction(this._aLeft[i + 1], this._aDiag[i]);
            if (!r)
                return false;
            this._aLeft[i + 1] = r;
            this._aDiag[i + 1] -= r * this._aRight[i];
        }
        this._dataState = DataState.FactorOK;
        return true;
    }
    /** Solve AX=B. A is left in factored state. B unchanged. */
    factorAndBackSubstitute() {
        const n = this._aDiag.length;
        const n1 = n - 1;
        if (!this.factor())
            return false;
        // Apply Linv to B, same sequence as was done to A:
        for (let i = 0; i < n; i++) {
            this._x[i] = this._b[i];
        }
        for (let i = 1; i < n; i++) {
            this._x[i] -= this._aLeft[i] * this._x[i - 1];
        }
        // Print ("LU  LinvB B");
        // overwrite X with solution of U * X = Linv B, where RHS is already in X...
        // All diagonals are known to be nonzero. Really.  Really???
        this._x[n1] /= this._aDiag[n1];
        for (let i = n1 - 1; i >= 0; i--) {
            this._x[i] = (this._x[i] - this._aRight[i] * this._x[i + 1]) / this._aDiag[i];
        }
        return true;
    }
    /** Solve AX=B. A is left in factored state. B unchanged. vectorB and vectorX may be the same array */
    factorAndBackSubstitutePointArrays(vectorB, vectorX) {
        const n = this._aDiag.length;
        if (vectorB.length < n)
            return false;
        while (vectorX.length < n)
            vectorX.push(Point3dVector3d_1.Point3d.create(0, 0, 0));
        vectorX.length = n;
        const n1 = n - 1;
        if (!this.factor())
            return false;
        // Apply Linv to B, same sequence as was done to A:
        if (vectorB !== vectorX) {
            for (let i = 0; i < n; i++) {
                vectorX[i].setFrom(vectorB[i]);
            }
        }
        let a;
        let b;
        for (let i = 1; i < n; i++) {
            a = this._aLeft[i];
            vectorX[i].x -= a * vectorX[i - 1].x;
            vectorX[i].y -= a * vectorX[i - 1].y;
            vectorX[i].z -= a * vectorX[i - 1].z;
        }
        // Print ("LU  LinvB B");
        // overwrite X with solution of U * X = Linv B, where RHS is already in X...
        // All diagonals are known to be nonzero. Really.  Really???
        b = 1.0 / this._aDiag[n1];
        vectorX[n1].x *= b;
        vectorX[n1].y *= b;
        vectorX[n1].z *= b;
        for (let i = n1 - 1; i >= 0; i--) {
            a = this._aRight[i];
            b = 1.0 / this._aDiag[i];
            vectorX[i].x = (vectorX[i].x - a * vectorX[i + 1].x) * b;
            vectorX[i].y = (vectorX[i].y - a * vectorX[i + 1].y) * b;
            vectorX[i].z = (vectorX[i].z - a * vectorX[i + 1].z) * b;
        }
        return true;
    }
    /** Allocate a complete copy */
    copy() {
        const n = this._aDiag.length;
        const B = new TriDiagonalSystem(n);
        for (let i = 0; i < n; i++) {
            B._aLeft[i] = this._aLeft[i];
            B._aDiag[i] = this._aDiag[i];
            B._aRight[i] = this._aRight[i];
            B._x[i] = this._x[i];
            B._b[i] = this._b[i];
        }
        B._dataState = this._dataState;
        return B;
    }
    /** return an array form that may be useful for display ... */
    flatten() {
        const n = this._aDiag.length;
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push([i, [this._aLeft[i], this._aDiag[i], this._aRight[i]], this._x[i], this._b[i]]);
        }
        return data;
    }
    /** return an array form that may be useful for display ... */
    flattenWithPoints(xyzB) {
        const n = this._aDiag.length;
        const data = [];
        for (let i = 0; i < n; i++) {
            data.push([i, [this._aLeft[i], this._aDiag[i], this._aRight[i]], this._x[i], xyzB[i].toJSON()]);
        }
        return data;
    }
}
exports.TriDiagonalSystem = TriDiagonalSystem;


/***/ }),

/***/ "./lib/numerics/UnionFind.js":
/*!***********************************!*\
  !*** ./lib/numerics/UnionFind.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/**
 * Implement the classic UnionFind algorithm, viz https://en.wikipedia.org/wiki/Disjoint-set_data_structure
 * * Each of the entities being merged exists as an entry in an array.
 * * The index in the array is the (only!) identification of the entity.
 * * The array entry is the index of a parent in the merge process.
 * * New entries are created as singletons pointing to themselves.
 * * Merge (i,j) merges the collections containing entries (i) and (j) into a single collection.
 * * The merge process updates the indices "above" (i) and (j)
 * * The whole process is extraordinarily efficient regardless of the order that the (i,j) merges are announced.
 * @internal
 */
class UnionFindContext {
    /** Create a set initialized with numLeaf singleton subsets */
    constructor(numLeaf = 0) {
        this._parentArray = [];
        for (let i = 0; i < numLeaf; i++)
            this._parentArray.push(i);
    }
    /** Return the number of leaves. */
    get length() { return this._parentArray.length; }
    /** test if index is within the valid index range. */
    isValidIndex(index) {
        return 0 <= index && index < this._parentArray.length;
    }
    /** Return the index of a new singleton set */
    addLeaf() {
        const index = this._parentArray.length;
        this._parentArray.push(index);
        return index;
    }
    /**
     * * follow links to parent
     * * after finding the parent, repeat the search and reset parents along the way.
     * * If index is invalid, return index unchanged.
     * @param index start of search
     */
    findRoot(index) {
        if (!this.isValidIndex(index))
            return index;
        let currentIndex = index;
        let nextIndex = this._parentArray[index];
        while (nextIndex !== currentIndex) {
            currentIndex = nextIndex;
            nextIndex = this._parentArray[currentIndex];
        }
        const rootIndex = currentIndex;
        // sweep up again and shorten the paths.
        currentIndex = index;
        while (currentIndex !== rootIndex) {
            nextIndex = this._parentArray[currentIndex];
            this._parentArray[currentIndex] = rootIndex;
            currentIndex = nextIndex;
        }
        return rootIndex;
    }
    /** Merge the subsets containing index (i) and (j)
     * * Look up the root of each.
     * * Fix up the path to the root so it points to the root.
     * * Return the root index of the merged set.
     * * If either index is invalid return index i with no changes.
     */
    mergeSubsets(i, j) {
        if (!this.isValidIndex(i) || !this.isValidIndex(j))
            return i;
        const rootIndexI = this.findRoot(i);
        const rootIndexJ = this.findRoot(j);
        if (rootIndexI !== rootIndexJ)
            this._parentArray[rootIndexI] = rootIndexJ;
        // cleanup a little more ...
        return this.findRoot(i);
    }
    /** Return the immediate parent of index (i), with no fixups
     * * If index is invalid, return it.
     */
    askParent(index) {
        if (!this.isValidIndex(index))
            return index;
        return this._parentArray[index];
    }
    /** Return the number of entries which are their own parent. */
    countRoots() {
        let numRoot = 0;
        const numLeaf = this._parentArray.length;
        for (let i = 0; i < numLeaf; i++)
            if (this._parentArray[i] === i)
                numRoot++;
        return numRoot;
    }
    /** Return the number of entries whose parent is not a root. */
    countNonTrivialPaths() {
        let numLong = 0;
        const numLeaf = this._parentArray.length;
        for (let i = 0; i < numLeaf; i++) {
            const j = this._parentArray[i];
            if (j !== i && this._parentArray[j] !== j)
                numLong++;
        }
        return numLong;
    }
    /** Return an array of all root indices.
     * * This array is sorted.
     */
    collectRootIndices() {
        const roots = [];
        const numLeaf = this._parentArray.length;
        for (let i = 0; i < numLeaf; i++) {
            if (this._parentArray[i] === i)
                roots.push(i);
        }
        return roots;
    }
}
exports.UnionFindContext = UnionFindContext;


/***/ }),

/***/ "./lib/numerics/UsageSums.js":
/*!***********************************!*\
  !*** ./lib/numerics/UsageSums.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * Accumulator for computing average and standard deviations.
 * * Usual usage pattern:
 *   * create with `sums = new UsageSums ()`
 *   * announce data values with any combination of
 *      * `sums.accumulate (x: number)`
 *      * `sums.accumulateArray (data: numberArray)`
 *   * query properties at any time:
 *      * `sums.mean`
 *      * `sums.count`
 *      * `sums.meanSquare`
 *      * `sums.standardDeviation`
 *      * `sums.minMax`
 * * Optional `origin`
 *   * if `origin` is nonzero:
 *      * when a value `x` is announced to the `accumulate(x)` method, the value used for sums is `(x-origin)`
 *   * All queries (mean, minMax, meanSquare, standardDeviation) return values relative to the origin.
 *   * The origin can be reset in two different ways:
 *     * `setOrigin(a)` sets the saved origin value to `a`, but leaves sums unchanged.
 *       * This affects subsequence how sums are changed by `announce(x)`
 *     * `shiftOriginAndSums` sets the origin (like `sums.setOrigin (a))` and also corrects all sums and minMax so they appear that the new origin had been in effect during all prior `accumulate(x)` calls.
 * @internal
 */
class UsageSums {
    /** Constructor:
     * * All sums 0
     * * min and max set to extreme values.
     * * origin assigned.
     */
    constructor(origin = 0) {
        this._minMax = Range_1.Range1d.createNull();
        this._count = this._sumX = this._sumXX = 0;
        this._origin = origin;
    }
    /** Return the number of samples seen */
    get count() { return this._count; }
    /** return the mean of all samples.
     * * Return 0 if no samples
     */
    get mean() { return this._count > 0 ? this._sumX / this._count : 0.0; }
    /** Return the mean of  squared samples.
     * * Return 0 if no samples.
     */
    get meanSquare() { return this._count > 0 ? this._sumXX / this._count : 0.0; }
    get minMax() { return this._minMax.clone(); }
    /**
     * Return the "biased standard deviation" (https://en.wikipedia.org/wiki/Standard_deviation)
     * * This is zero if count is zero.
     */
    get standardDeviation() {
        if (this._count < 1)
            return 0.0;
        const xBar = this.mean;
        const sumXX = this._sumXX;
        const sumX = this._sumX;
        return Math.sqrt((sumXX - 2 * xBar * sumX + this._count * xBar * xBar) / this._count);
    }
    /** Reinitialize all sums.
     * * origin is unchanged
     */
    clearSums() {
        this._count = this._sumX = this._sumXX = 0;
        this._minMax.setNull();
    }
    /**
     * return the origin being used in the `accumulate(x)` method.
     */
    get origin() { return this._origin; }
    /**
     * Reset the origin.
     * * Former sums are unchanged !!
     * @param origin new origin
     */
    setOrigin(origin) {
        this._origin = origin;
    }
    /**
     * * reset the origin
     * * adjust all sums to what they would be if the new origin had been in effect.
     */
    shiftOriginAndSums(origin) {
        const delta = origin - this._origin;
        this._origin = origin;
        // adjust sumXX first to get old sumX value before it is modified.
        this._sumXX = this._sumXX - 2 * delta * this._sumX + this._count * delta * delta;
        this._sumX = this._sumX - this._count * delta;
        this._minMax.cloneTranslated(-delta, this._minMax);
    }
    /** Accumulate a single value */
    accumulate(x) {
        x = x - this._origin;
        this._count += 1;
        this._sumX += x;
        this._sumXX += x * x;
        this._minMax.extendX(x);
    }
    /** Accumulate a single value */
    accumulateArray(xArray) {
        for (const x of xArray)
            this.accumulate(x);
    }
    /** Clone all content (origin, count, sums, minMax) */
    clone(result) {
        if (!result)
            result = new UsageSums();
        this._minMax.clone(result._minMax);
        result._count = this._count;
        result._origin = this._origin;
        result._sumX = this._sumX;
        result._sumXX = this._sumXX;
        return result;
    }
    /** Compare all content. */
    isAlmostEqual(other) {
        return Geometry_1.Geometry.isAlmostEqualNumber(this._sumX, other._sumX)
            && Geometry_1.Geometry.isAlmostEqualNumber(this._sumXX, other._sumXX)
            && Geometry_1.Geometry.isAlmostEqualNumber(this._origin, other._origin)
            && this._count === other._count
            && this._minMax.isAlmostEqual(other._minMax);
    }
}
exports.UsageSums = UsageSums;


/***/ }),

/***/ "./lib/polyface/AuxData.js":
/*!*********************************!*\
  !*** ./lib/polyface/AuxData.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty*/
// import { Geometry } from "./Geometry";
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
/** The data types of [[AuxChannel]].  The scalar types are used to produce thematic  vertex colors.
 * @public
*/
var AuxChannelDataType;
(function (AuxChannelDataType) {
    /** General scalar type - no scaling is applied if associated [[Polyface]] is transformed. */
    AuxChannelDataType[AuxChannelDataType["Scalar"] = 0] = "Scalar";
    /** Distance (scalar) scaling is applied if associated [[Polyface]] is scaled. 3 Data values (x,y.z) per entry. */
    AuxChannelDataType[AuxChannelDataType["Distance"] = 1] = "Distance";
    /** Displacement added to  vertex position.  Transformed and scaled with associated [[Polyface]]. 3 Data values (x,y.z) per entry.,*/
    AuxChannelDataType[AuxChannelDataType["Vector"] = 2] = "Vector";
    /** Normal -- replaces vertex normal.  Rotated with associated [[Polyface]] transformation. 3 Data values (x,y.z) per entry. */
    AuxChannelDataType[AuxChannelDataType["Normal"] = 3] = "Normal";
})(AuxChannelDataType = exports.AuxChannelDataType || (exports.AuxChannelDataType = {}));
/**  Represents the [[AuxChannel]] data at a single input value.
 * @public
*/
class AuxChannelData {
    /** Construct a new [[AuxChannelData]] from input value and vertex values. */
    constructor(input, values) {
        this.input = input;
        this.values = values;
    }
    /** Copy blocks of size `blockSize` from (blocked index) `thisIndex` in this AuxChannelData to (blockIndex) `otherIndex` of `other` */
    copyValues(other, thisIndex, otherIndex, blockSize) {
        for (let i = 0; i < blockSize; i++)
            this.values[thisIndex * blockSize + i] = other.values[otherIndex * blockSize + i];
    }
    /** return a deep copy */
    clone() {
        return new AuxChannelData(this.input, this.values.slice());
    }
    /** toleranced comparison of the `input` and `value` fields.
     * * Default tolernace is 1.0e-8
     */
    isAlmostEqual(other, tol) {
        const tolerance = tol ? tol : 1.0E-8;
        return Math.abs(this.input - other.input) < tolerance && PointHelpers_1.NumberArray.isAlmostEqual(this.values, other.values, tolerance);
    }
}
exports.AuxChannelData = AuxChannelData;
/**  Represents a single [[PolyfaceAuxData]] channel. A channel  may represent a single scalar value such as stress or temperature or may represent displacements from vertex position or replacements for normals.
 * @public
*/
class AuxChannel {
    /** create a [[AuxChannel]] */
    constructor(data, dataType, name, inputName) {
        this.data = data;
        this.dataType = dataType;
        this.name = name;
        this.inputName = inputName;
    }
    /** Return a deep clone */
    clone() {
        const clonedData = [];
        for (const data of this.data)
            clonedData.push(data.clone());
        return new AuxChannel(clonedData, this.dataType, this.name, this.inputName);
    }
    /** toleranced comparison of contents. */
    isAlmostEqual(other, tol) {
        if (this.dataType !== other.dataType ||
            this.name !== other.name ||
            this.inputName !== other.inputName ||
            this.data.length !== other.data.length)
            return false;
        for (let i = 0; i < this.data.length; i++)
            if (!this.data[i].isAlmostEqual(other.data[i], tol))
                return false;
        return true;
    }
    /** return true if the data for this channel is of scalar type (single data entry per value) */
    get isScalar() { return this.dataType === AuxChannelDataType.Distance || this.dataType === AuxChannelDataType.Scalar; }
    /** return the number of data values per entry (1 for scalar, 3 for point or vector */
    get entriesPerValue() { return this.isScalar ? 1 : 3; }
    /** return value count */
    get valueCount() { return 0 === this.data.length ? 0 : this.data[0].values.length / this.entriesPerValue; }
    /** return the range of the scalar data. (undefined if not scalar) */
    get scalarRange() {
        if (!this.isScalar)
            return undefined;
        const range = Range_1.Range1d.createNull();
        for (const data of this.data) {
            range.extendArray(data.values);
        }
        return range;
    }
}
exports.AuxChannel = AuxChannel;
/**  The `PolyfaceAuxData` structure contains one or more analytical data channels for each vertex of a `Polyface`.
 * Typically a `Polyface` will contain only vertex data required for its basic display,the vertex position, normal
 * and possibly texture parameter.  The `PolyfaceAuxData` structure contains supplemental data that is generally computed
 *  in an analysis program or other external data source.  This can be scalar data used to either overide the vertex colors through *Thematic Colorization* or
 *  XYZ data used to deform the mesh by adjusting the vertex postions or normals.
 * @public
 */
class PolyfaceAuxData {
    constructor(channels, indices) {
        this.channels = channels;
        this.indices = indices;
    }
    /** return a deep clone */
    clone() {
        const clonedChannels = [];
        for (const channel of this.channels)
            clonedChannels.push(channel.clone());
        return new PolyfaceAuxData(clonedChannels, this.indices.slice());
    }
    /** deep test for equality.
     * * Exact equality for discrete number arrays.
     * * approximate test for coordinate data.
     */
    isAlmostEqual(other, tol) {
        if (!PointHelpers_1.NumberArray.isExactEqual(this.indices, other.indices) || this.channels.length !== other.channels.length)
            return false;
        for (let i = 0; i < this.channels.length; i++)
            if (!this.channels[i].isAlmostEqual(other.channels[i], tol))
                return false;
        return true;
    }
    /**
     * class level almostEqual test, allowing either or both to be undefined at point of call.
     * @param left
     * @param right
     * @param tol
     */
    static isAlmostEqual(left, right, tol) {
        if (left === right) // This catches double undefined !!!
            return true;
        if (left && right)
            return left.isAlmostEqual(right, tol);
        return false;
    }
    /** Create a PolyfaceAuxData for use by a facet iterator  */
    createForVisitor() {
        const visitorChannels = [];
        for (const parentChannel of this.channels) {
            const visitorChannelData = [];
            for (const parentChannelData of parentChannel.data) {
                visitorChannelData.push(new AuxChannelData(parentChannelData.input, []));
            }
            visitorChannels.push(new AuxChannel(visitorChannelData, parentChannel.dataType, parentChannel.name, parentChannel.inputName));
        }
        return new PolyfaceAuxData(visitorChannels, []);
    }
}
exports.PolyfaceAuxData = PolyfaceAuxData;


/***/ }),

/***/ "./lib/polyface/BoxTopology.js":
/*!*************************************!*\
  !*** ./lib/polyface/BoxTopology.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
//
//      2------------------3
//      | \     F4       / |
//      |   6----------7   |
//      |   |          |   |   (BOTTOM = F0)
//      |F5 |   F1     |F3 |
//      |   |          |   |
//      |   4----------5   |
//      | /     F2       \ |
//      0------------------1
//
/**
 * methods for gathering points and indices of a box (8 corners, 6 faces, 12 edges)
 * @internal
 */
class BoxTopology {
}
exports.BoxTopology = BoxTopology;
/**
 * static readonly array with the coordinates of the 8 unit cube corners in standard order, which is:
 * x varies fastest
 * * The point indices for the x edges are (0 to 1), (2 to 3), (4 to 5), (6 to 7)
 * * The point indices for the y edges are (0 to 2), (1 to 3), (4 to 6), (5 to 7)
 * * The point indices for the z edges are (0 to 4), (1 to 5), (2 to 6), (3 to 7)
 * * These indices are tabulated in the `axisEdgeVertex[axis][edge][vertex]` array
 */
BoxTopology.points = [
    Point3dVector3d_1.Point3d.create(0, 0, 0),
    Point3dVector3d_1.Point3d.create(1, 0, 0),
    Point3dVector3d_1.Point3d.create(0, 1, 0),
    Point3dVector3d_1.Point3d.create(1, 1, 0),
    Point3dVector3d_1.Point3d.create(0, 0, 1),
    Point3dVector3d_1.Point3d.create(1, 0, 1),
    Point3dVector3d_1.Point3d.create(0, 1, 1),
    Point3dVector3d_1.Point3d.create(1, 1, 1),
];
/** IN faceId pair, the first component for bottom and top caps is `primaryCapId` */
BoxTopology.primaryCapId = -1;
/** Indices of vertices around faces, in CCW from the outside. */
BoxTopology.cornerIndexCCW = [
    [1, 0, 2, 3],
    [4, 5, 7, 6],
    [0, 1, 5, 4],
    [1, 3, 7, 5],
    [3, 2, 6, 7],
    [2, 0, 4, 6]
];
/**  // [partnerFace[faceIndex][k] = index of k'th adjacent face  */
BoxTopology.partnerFace = [
    [5, 4, 3, 2],
    [2, 3, 4, 5],
    [0, 3, 1, 5],
    [0, 4, 1, 2],
    [0, 5, 1, 3],
    [0, 2, 1, 4],
];
/** face id as used in SolidPrimitive methods */
BoxTopology.faceId = [
    [BoxTopology.primaryCapId, 0],
    [BoxTopology.primaryCapId, 1],
    [0, 0],
    [0, 1],
    [0, 2],
    [0, 3]
];
/**
 * Table to look up axis indices of edges and normals in box faces.
 * faceDirections[faceIndex] =[[edge0AxisIndex, edge1AxisIndex, normalAxisIndex],[direction sign for along the axis]
 */
BoxTopology.faceDirections = [
    [[0, 1, 2], [-1, 1, -1]],
    [[0, 1, 2], [1, 1, 1]],
    [[0, 2, 1], [1, -1, 1]],
    [[1, 2, 0], [1, 1, 1]],
    [[0, 2, 1], [-1, 1, 1]],
    [[1, 2, 0], [-1, 1, -1]]
];
/** There are 4 edges in each axis direction.
 *  * axisEdgeVertex[axisIndex][edgeIndex 0..3][*] = vertex index at end of edge in axisIndex direction.
 */
BoxTopology.axisEdgeVertex = [
    [[0, 1], [2, 3], [4, 5], [6, 7]],
    [[0, 2], [1, 3], [4, 6], [5, 7]],
    [[0, 4], [1, 5], [2, 6], [3, 7]]
];


/***/ }),

/***/ "./lib/polyface/FacetFaceData.js":
/*!***************************************!*\
  !*** ./lib/polyface/FacetFaceData.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Polyface_1 = __webpack_require__(/*! ./Polyface */ "./lib/polyface/Polyface.js");
/** module Polyface */
/**
 * Data for a face in a polyface containing facets.
 * This is built up cooperatively by the PolyfaceBuilder and its
 * callers, and stored as a FaceData array in PolyfaceData.
 * @public
 */
class FacetFaceData {
    constructor(distanceRange, paramRange) {
        this._paramDistanceRange = distanceRange;
        this._paramRange = paramRange;
    }
    /** (property accessor) Return a reference to the distance-scaled parameter range. */
    get paramDistanceRange() { return this._paramDistanceRange; }
    /** (property accessor) Return a reference to the parameter range. */
    get paramRange() { return this._paramRange; }
    /** Create a FacetFaceData with null ranges. */
    static createNull() {
        return new FacetFaceData(Range_1.Range2d.createNull(), Range_1.Range2d.createNull());
    }
    /** Create a deep copy of this FacetFaceData object. */
    clone(result) {
        if (result) {
            this._paramDistanceRange.clone(result._paramDistanceRange);
            this._paramRange.clone(result._paramRange);
            return result;
        }
        return new FacetFaceData(this._paramDistanceRange.clone(), this._paramRange.clone());
    }
    /** Restore this FacetFaceData to its null constructor state. */
    setNull() {
        this._paramDistanceRange.setNull();
        this._paramRange.setNull();
    }
    /** Return distance-based parameter from stored parameter value. */
    convertParamXYToDistance(x, y, result) {
        result = result ? result : Point2dVector2d_1.Point2d.create();
        const paramDelta = this._paramRange.high.minus(this._paramRange.low);
        result.x = (0 === paramDelta.x) ? x : (this._paramDistanceRange.low.x + (x - this._paramRange.low.x)
            * (this._paramDistanceRange.high.x - this._paramDistanceRange.low.x) / paramDelta.x);
        result.y = (0.0 === paramDelta.y) ? y : (this.paramDistanceRange.low.y + (y - this._paramRange.low.y)
            * (this._paramDistanceRange.high.y - this._paramDistanceRange.low.y) / paramDelta.y);
        return result;
    }
    /** Return normalized (0-1) parameter from stored parameter value. */
    convertParamXYToNormalized(x, y, result) {
        result = result ? result : Point2dVector2d_1.Point2d.create();
        const paramDelta = this._paramRange.high.minus(this._paramRange.low);
        result.x = (0.0 === paramDelta.x) ? x : ((x - this._paramRange.low.x) / paramDelta.x);
        result.y = (0.0 === paramDelta.y) ? y : ((y - this._paramRange.low.y) / paramDelta.y);
        return result;
    }
    /** Return distance-based parameter from stored parameter value. */
    convertParamToDistance(param, result) {
        return this.convertParamXYToDistance(param.x, param.y, result);
    }
    /** Return normalized (0-1) parameter from stored parameter value. */
    convertParamToNormalized(param, result) {
        return this.convertParamXYToNormalized(param.x, param.y, result);
    }
    /** Scale distance parameters. */
    scaleDistances(distanceScale) {
        this._paramDistanceRange.low.x *= distanceScale;
        this._paramDistanceRange.low.y *= distanceScale;
        this._paramDistanceRange.high.x *= distanceScale;
        this._paramDistanceRange.high.y *= distanceScale;
    }
    /**
     * Sets the param and paramDistance range of this FacetFaceData based on the newly terminated facets that make it up.
     * Takes the polyface itself, the first and last indexes of the facets to be included in the face.
     * Returns true on success, false otherwise.
     */
    setParamDistanceRangeFromNewFaceData(polyface, facetStart, facetEnd) {
        const dSTotal = Point2dVector2d_1.Point2d.create();
        const dSSquaredTotal = Point2dVector2d_1.Point2d.create();
        this.setNull();
        let aveTotal = 0;
        const visitor = Polyface_1.IndexedPolyfaceVisitor.create(polyface, 0);
        if (!visitor.moveToReadIndex(facetStart) || facetEnd <= facetStart)
            return false;
        do {
            const numPointsInFacet = visitor.numEdgesThisFacet;
            const visitorPoints = visitor.point;
            const trianglePointIndexes = [];
            const visitorParams = visitor.param;
            const triangleParamIndexes = [];
            if (!visitorParams)
                return false;
            visitorParams.extendRange(this._paramRange);
            const dUV0 = Point2dVector2d_1.Vector2d.create();
            const dUV1 = Point2dVector2d_1.Vector2d.create();
            for (let k = 0; k < numPointsInFacet; k++) {
                trianglePointIndexes[2] = k;
                triangleParamIndexes[2] = k;
                if (k > 1) {
                    visitorParams.vectorIndexIndex(triangleParamIndexes[1], triangleParamIndexes[0], dUV0);
                    visitorParams.vectorIndexIndex(triangleParamIndexes[1], triangleParamIndexes[2], dUV1);
                    const delta0 = visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[0]).minus(visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[1]));
                    const delta1 = visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[1]).minus(visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[2]));
                    const uvCross = Math.abs(dUV0.x * dUV1.y - dUV1.x * dUV0.y);
                    if (uvCross) {
                        const dwDu = Point3dVector3d_1.Point3d.createFrom(delta0);
                        dwDu.scaleInPlace(dUV1.y);
                        dwDu.addScaledInPlace(delta1, -dUV0.y);
                        const dwDv = Point3dVector3d_1.Point3d.createFrom(delta1);
                        dwDv.scaleInPlace(dUV0.x);
                        dwDv.addScaledInPlace(delta0, -dUV1.x);
                        const dS = Point2dVector2d_1.Point2d.create(dwDu.magnitude() / uvCross, dwDv.magnitude() / uvCross);
                        dSTotal.x += dS.x;
                        dSTotal.y += dS.y;
                        dSSquaredTotal.x += dS.x * dS.x;
                        dSSquaredTotal.y += dS.y * dS.y;
                        aveTotal++;
                    }
                }
                triangleParamIndexes[0] = triangleParamIndexes[1];
                triangleParamIndexes[1] = triangleParamIndexes[2];
                trianglePointIndexes[0] = trianglePointIndexes[1];
                trianglePointIndexes[1] = trianglePointIndexes[2];
            }
        } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < facetEnd);
        if (aveTotal !== 0) {
            const dS = Point2dVector2d_1.Point2d.create(dSTotal.x / aveTotal, dSTotal.y / aveTotal);
            const standardDeviation = Point2dVector2d_1.Point2d.create(Math.sqrt(Math.abs((dSSquaredTotal.x / aveTotal) - dS.x * dS.x)), Math.sqrt(Math.abs((dSSquaredTotal.y / aveTotal) - dS.y * dS.y)));
            // TR# 268980 - Add standard deviation to match QV....
            this._paramDistanceRange.low.set(0, 0);
            this._paramDistanceRange.high.set((dS.x + standardDeviation.x) * (this._paramRange.high.x - this._paramRange.low.x), (dS.y + standardDeviation.y) * (this._paramRange.high.y - this._paramRange.low.y));
        }
        return true;
    }
}
exports.FacetFaceData = FacetFaceData;


/***/ }),

/***/ "./lib/polyface/GreedyTriangulationBetweenLineStrings.js":
/*!***************************************************************!*\
  !*** ./lib/polyface/GreedyTriangulationBetweenLineStrings.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const TriangleCandidate_1 = __webpack_require__(/*! ./TriangleCandidate */ "./lib/polyface/TriangleCandidate.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const IndexedCollectionInterval_1 = __webpack_require__(/*! ../geometry3d/IndexedCollectionInterval */ "./lib/geometry3d/IndexedCollectionInterval.js");
/** @module Polyface */
/**
 * * Context for constructing triangulations between linestrings with dis-similar point counts and distribution.
 * @internal
 */
class GreedyTriangulationBetweenLineStrings {
    constructor(turnRadians) {
        this._turnRadians = turnRadians;
        this._xyzA = Point3dVector3d_1.Point3d.create();
        this._xyzB = Point3dVector3d_1.Point3d.create();
        this._forwardA = Point3dVector3d_1.Vector3d.create();
        this._forwardB = Point3dVector3d_1.Vector3d.create();
        this._vector1 = Point3dVector3d_1.Vector3d.create();
        this._crossA = Point3dVector3d_1.Vector3d.create();
        this._crossB = Point3dVector3d_1.Vector3d.create();
    }
    isForwardVector(candidate, forward, perp) {
        if (candidate.dotProduct(forward) <= 0.0)
            return false;
        const theta = candidate.angleFromPerpendicular(perp);
        if (Math.abs(theta.radians) > this._turnRadians)
            return false;
        return true;
    }
    isPlanarBase(pointsA, baseA, pointsB, baseB, xyzA, crossA, forwardA, xyzB, crossB, forwardB) {
        if (baseA + 1 < pointsA.length && baseB + 1 < pointsB.length) {
            pointsA.getPoint3dAtUncheckedPointIndex(baseA, xyzA);
            pointsB.getPoint3dAtUncheckedPointIndex(baseB, xyzB);
            pointsA.vectorXYAndZIndex(xyzA, baseA + 1, forwardA);
            pointsB.vectorXYAndZIndex(xyzB, baseB + 1, forwardB);
            Point3dVector3d_1.Vector3d.createStartEnd(xyzA, xyzB, this._vector1);
            this._vector1.crossProduct(forwardA, crossA);
            this._vector1.crossProduct(forwardB, crossB);
            if (!xyzA.isAlmostEqual(xyzB) && crossA.angleTo(crossB).radians < this._turnRadians)
                return true;
        }
        return false;
    }
    /**
     * Starting at start in source, examine points to see how long they are close to being "in plane"
     * * child interval begins at parent.begin
     * * child interval end initializes at trialEnd and grows.
     * * child must be predefined by caller
     * * Return the accepted interval
     */
    advanceToPlanarLimit(parent, child, trialEnd, xyzA, perpA, forwardA, perpB, forwardB) {
        child.setFrom(parent, parent.begin, trialEnd); // initialize as empty interval.
        while (child.end < parent.end) {
            child.points.vectorXYAndZIndex(xyzA, child.end, this._vector1);
            if (!this.isForwardVector(this._vector1, forwardA, perpA))
                break;
            if (!this.isForwardVector(this._vector1, forwardB, perpB))
                break;
            if (child.end > 0) {
                child.points.vectorIndexIndex(child.end - 1, child.end, this._vector1);
                if (!this.isForwardVector(this._vector1, forwardA, perpA))
                    break;
            }
            child.end++;
        }
    }
    /** evaluate aspect ratios to select heuristically best triangles with given index intervals.
     * (ASSUME NO DUPLICATES, as in caller.)
     */
    addGreedy(intervalA, intervalB, handler, addOnly1 = false) {
        intervalA.restrictEnd();
        intervalB.restrictEnd();
        while (intervalA.length > 1 && intervalB.length > 1) {
            // triangles A1 and B1 are always valid.
            this._triangleA1 = TriangleCandidate_1.TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin, intervalA.points, intervalA.begin + 1, intervalB.points, intervalB.begin, 1, this._triangleA1);
            this._triangleA2 = TriangleCandidate_1.TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin + 1, intervalA.points, intervalA.begin + 2, intervalB.points, intervalB.begin, 2, this._triangleA2);
            this._triangleA3 = TriangleCandidate_1.TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin, intervalA.points, intervalA.begin + 1, intervalB.points, intervalB.begin + 1, 3, this._triangleA3);
            this._triangleB1 = TriangleCandidate_1.TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 1, intervalB.points, intervalB.begin, intervalA.points, intervalA.begin, -1, this._triangleB1);
            this._triangleB2 = TriangleCandidate_1.TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 2, intervalB.points, intervalB.begin + 1, intervalA.points, intervalA.begin, -2, this._triangleB2);
            this._triangleB3 = TriangleCandidate_1.TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 1, intervalB.points, intervalB.begin, intervalA.points, intervalA.begin + 1, -3, this._triangleB3);
            // Look at pairs of 2 triangles.
            // (each pair begins with 1 or -1)
            // For each pair find the smallest aspect ratio of its two triangles.  (Small is bad)
            // Choose the pair where that (smaller aspect ratio of two) is largest.
            // Advance in that direction.
            this._bestTriangle = TriangleCandidate_1.TriangleCandidate.copyWithLowerQuality(this._triangleA1, this._triangleB3, this._bestTriangle);
            this._workTriangle = TriangleCandidate_1.TriangleCandidate.copyWithLowerQuality(this._triangleB1, this._triangleA3, this._workTriangle);
            TriangleCandidate_1.TriangleCandidate.updateIfOtherHasHigherQuality(this._bestTriangle, this._workTriangle);
            // TestTriangle::UpdateIfOtherHasLargerAspectRatio (bestTriangle, TestTriangle::MergeAspectRatio (triangleB1, triangleB2));
            // TestTriangle::UpdateIfOtherHasLargerAspectRatio (bestTriangle, TestTriangle::MergeAspectRatio (triangleA1, triangleA2));
            if (this._bestTriangle.id > 0) {
                intervalA.advanceBegin();
                handler(this._bestTriangle);
                if (addOnly1)
                    return;
            }
            else {
                intervalB.advanceBegin();
                handler(this._bestTriangle);
                if (addOnly1)
                    return;
            }
        }
        // sweep in trailing points from either side.  At least one of intervalA.begin, intervalB.begin is at its limit, so only one of these will execute any bodies.
        if (intervalA.isSingleton) {
            while (intervalB.length >= 2) {
                this._workTriangle = TriangleCandidate_1.TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 1, intervalB.points, intervalB.begin, intervalA.points, intervalA.begin, 0, this._workTriangle);
                //  this._workTriangle.scaleFromPointInPlace(this._workTriangle.points[2], 0.95); // crude visualization aid for tracking logic.
                handler(this._workTriangle);
                intervalB.advanceBegin();
            }
        }
        // sweep in trailing points from either side.  At least one of baseA, baseB is at its limit, so only one of these will execute any bodies.
        if (intervalB.isSingleton) {
            while (intervalA.length >= 2) {
                this._workTriangle = TriangleCandidate_1.TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin, intervalA.points, intervalA.begin + 1, intervalB.points, intervalB.begin, 0, this._workTriangle);
                // this._workTriangle.scaleFromPointInPlace(this._workTriangle.points[2], 0.95); // crude visualization aid for tracking logic.
                handler(this._workTriangle);
                intervalA.advanceBegin();
            }
        }
    }
    /**
     * Working from start to finish, emit triangles with heuristic lookahead to get pleasing matching between the linestrings.
     * @param pointsA
     * @param pointsB
     * @param handler
     */
    emitTriangles(pointsA, pointsB, handler) {
        /** Clean up duplicates for the real logic . . . */
        this.emitTrianglesGo(resolveToNoDuplicates(pointsA), resolveToNoDuplicates(pointsB), handler);
    }
    /**
     * Run triangle logic on inputs with no duplicates.
     * @param pointsA
     * @param pointsB
     * @param handler
     */
    emitTrianglesGo(pointsA, pointsB, handler) {
        const intervalA = IndexedCollectionInterval_1.IndexedXYZCollectionInterval.createComplete(pointsA);
        const intervalB = IndexedCollectionInterval_1.IndexedXYZCollectionInterval.createComplete(pointsB);
        const childA = IndexedCollectionInterval_1.IndexedXYZCollectionInterval.createComplete(pointsA);
        const childB = IndexedCollectionInterval_1.IndexedXYZCollectionInterval.createComplete(pointsB);
        while (intervalA.length > 0 && intervalB.length > 0 && (intervalA.length > 1 || intervalB.length > 1)) {
            // const lA = intervalA.length;
            // const lB = intervalB.length;
            if (this.isPlanarBase(pointsA, intervalA.begin, pointsB, intervalB.begin, this._xyzA, this._crossA, this._forwardA, this._xyzB, this._crossB, this._forwardB)) {
                this.advanceToPlanarLimit(intervalA, childA, intervalA.begin + 1, this._xyzA, this._crossA, this._forwardA, this._crossB, this._forwardB);
                this.advanceToPlanarLimit(intervalB, childB, intervalB.begin + 1, this._xyzB, this._crossB, this._forwardB, this._crossA, this._forwardA);
                this.addGreedy(childA, childB, handler);
                intervalA.advanceToTail(childA);
                intervalB.advanceToTail(childB);
            }
            else if (this.isPlanarBase(pointsA, intervalA.begin + 1, pointsB, intervalB.begin, this._xyzA, this._crossA, this._forwardA, this._xyzB, this._crossB, this._forwardB)) {
                childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 2);
                childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 1);
                this.addGreedy(childA, childB, handler);
                intervalA.advanceToTail(childA);
                intervalB.advanceToTail(childB);
            }
            else if (this.isPlanarBase(pointsA, intervalA.begin, pointsB, intervalB.begin + 1, this._xyzA, this._crossA, this._forwardA, this._xyzB, this._crossB, this._forwardB)) {
                childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 1);
                childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 2);
                this.addGreedy(childA, childB, handler);
                intervalA.advanceToTail(childA);
                intervalB.advanceToTail(childB);
            }
            else if (intervalA.length > 1 && intervalB.length > 1) {
                childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 2);
                childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 2);
                this.addGreedy(childA, childB, handler, true);
                intervalA.advanceToHead(childA);
                intervalB.advanceToHead(childB);
            }
            else if (intervalA.length > 1) {
                childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 2);
                childB.setFrom(intervalB);
                this.addGreedy(childA, childB, handler);
                intervalA.advanceToTail(childA);
                intervalB.advanceToTail(childB);
            }
            else if (intervalB.length > 1) {
                childA.setFrom(intervalA);
                childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 2);
                this.addGreedy(childA, childB, handler);
                intervalA.advanceToTail(childA);
                intervalB.advanceToTail(childB);
            }
            /*      if (intervalA.length >= lA && intervalB.length >= lB) {
                    // This should not happen == neither one advanced.   Just move ahead in the longer one ..
                    if (intervalA.length > intervalB.length)
                      intervalA.advanceBegin();
                    else intervalB.advanceBegin();
                  } */
        }
        // catch everything else blindly
        this.addGreedy(intervalA, intervalB, handler);
    }
    static createContext(planarTurnAngle = this.defaultNearColinearAngle) {
        return new GreedyTriangulationBetweenLineStrings(planarTurnAngle.radians);
    }
}
exports.GreedyTriangulationBetweenLineStrings = GreedyTriangulationBetweenLineStrings;
/** Default angle for considering two vectors to be colinear */
GreedyTriangulationBetweenLineStrings.defaultNearColinearAngle = Angle_1.Angle.createDegrees(15);
/**
 * * If there are no contiguous duplicated points in `data` return `data` unchanged.
 * * If there are duplicates, compress to a new array.
 * @param data
 * @param tolerance
 */
function resolveToNoDuplicates(data, tolerance = Geometry_1.Geometry.smallMetricDistance) {
    let hasDuplicates = false;
    const n = data.length;
    for (let i = 0; i + 1 < n; i++) {
        if (data.distanceIndexIndex(i, i + 1) <= tolerance) {
            hasDuplicates = true;
            break;
        }
    }
    if (!hasDuplicates)
        return data;
    const result = new GrowableXYZArray_1.GrowableXYZArray(n);
    result.pushXYZ(data.getXAtUncheckedPointIndex(0), data.getYAtUncheckedPointIndex(0), data.getZAtUncheckedPointIndex(0));
    let i0 = 0;
    for (let i = 1; i < n; i++) {
        if (data.distanceIndexIndex(i0, i) > tolerance) {
            result.pushXYZ(data.getXAtUncheckedPointIndex(i), data.getYAtUncheckedPointIndex(i), data.getZAtUncheckedPointIndex(i));
            i0 = i;
        }
    }
    /** enforce exact closure if original was closed. */
    if (data.distanceIndexIndex(0, n - 1) <= tolerance) {
        result.pop();
        result.pushFromGrowableXYZArray(result, 0);
    }
    return result;
}


/***/ }),

/***/ "./lib/polyface/IndexedEdgeMatcher.js":
/*!********************************************!*\
  !*** ./lib/polyface/IndexedEdgeMatcher.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
// For boundary sorting, an edge exists as a (packed!) Float64Array.
// Fixed entries are:
// 0:
/**
 * * For boundary sorting, an edge is a (packed!) Float64Array.
 * * Fixed entry positions are:
 *   * [0] is start vertex index (in CCW order around its facet)
 *   * [1] is end vertex index (in CCW order around its facet)
 *   * [2] is facet index.
 */
class SortableEdge extends Float64Array {
    /** Return the vertex index that appears first in the order stored.  */
    get vertexIndexA() { return this[0]; }
    /** Return the vertex index that appears second in the order stored.  */
    get vertexIndexB() { return this[1]; }
    /** Return the facet index.  */
    get facetIndex() { return this[2]; }
    /** return true if vertexIndexA is less than vertexIndexB */
    get isLowHigh() { return this[0] < this[1]; }
    /** Return the vertex index with lower numeric value */
    get lowVertexIndex() { return this[0] < this[1] ? this[0] : this[1]; }
    /** Return the vertex index with higher numeric value */
    get highVertexIndex() { return this[0] > this[1] ? this[0] : this[1]; }
    /** Return true if the vertices edgeA and edgeB are the same vertex indices in opposite order */
    static areDirectedPartners(edgeA, edgeB) { return edgeA[0] === edgeB[1] && edgeA[1] === edgeB[0]; }
    /** Return true if the vertices edgeA and edgeB are the same vertex indices with no consideration of order */
    static areUndirectedPartners(edgeA, edgeB) {
        return (edgeA[0] === edgeB[0] && edgeA[1] === edgeB[1]) || ((edgeA[0] === edgeB[1] && edgeA[1] === edgeB[0]));
    }
    get isNullEdge() { return this[0] === this[1]; }
    /**
     * lexical comparison of two edges.
     * * If the edges have the same vertex pair (in same or opposite order) they will end up adjacent in a sort
     * * If the edges have 0 or 1 shared vertex indices, the one with lowest low comes first.
     * @param edgeA first edge
     * @param edgeB second edge
     */
    static lessThan(edgeA, edgeB) {
        // primary compare is based on indirect indices
        const lowA = edgeA.lowVertexIndex;
        const lowB = edgeB.lowVertexIndex;
        if (lowA < lowB)
            return -1;
        if (lowB < lowA)
            return 1;
        const highA = edgeA.highVertexIndex;
        const highB = edgeB.highVertexIndex;
        if (highA < highB)
            return -1;
        if (highB < highA)
            return 1;
        // undirected indices match ... use directed vertexIndexA
        return edgeA.vertexIndexA - edgeB.vertexIndexA;
    }
    constructor(vertexA, vertexB, facetIndex) {
        super(3);
        this[0] = vertexA;
        this[1] = vertexB;
        this[2] = facetIndex;
    }
    toJSON() { return [this[0], this[1], this[2]]; }
    static clusterToJSON(data) {
        if (data instanceof SortableEdge)
            return data.toJSON();
        const result = [];
        for (const edge of data)
            result.push(edge.toJSON());
    }
    static clusterArrayToJSON(data) {
        const result = [];
        for (const cluster of data)
            result.push(SortableEdge.clusterToJSON(cluster));
        return result;
    }
}
exports.SortableEdge = SortableEdge;
/**
 * An IndexedEdgeMatcher carries an array (`edges`) of edges start & end indices for sorting and subsequent analyses (such as testing for closed mesh)
 */
class IndexedEdgeMatcher {
    constructor() {
        this.edges = [];
    }
    /**
     * push a new edge.
     * @returns the edge (as emplaced at the back of the sortableEdge array)
     * @param vertexA start vertex
     * @param vertexB end vertex
     * @param facetIndex facet index
     */
    addEdge(vertexA, vertexB, facetIndex) {
        const edge = new SortableEdge(vertexA, vertexB, facetIndex);
        this.edges.push(edge);
        return edge;
    }
    /**
     * Push edges all around a facet, returning to vertexArray[0]
     * @param vertexArray array of vertex indices around facet
     * @param facetIndex
     */
    addPath(vertexArray, facetIndex, closeLoop = true) {
        if (vertexArray.length === 0)
            return;
        const m = vertexArray.length - 1;
        for (let i = 0; i < m; i++) {
            this.addEdge(vertexArray[i], vertexArray[i + 1], facetIndex);
        }
        if (closeLoop)
            this.addEdge(vertexArray[m], vertexArray[0], facetIndex);
    }
    /** Sort the edge index array. */
    sort() {
        this.edges.sort(SortableEdge.lessThan);
    }
    /** Create a single or compound SortableEdgeCluster in dest. */
    collectSortableEdgeCluster(index0, index1, dest) {
        if (dest !== undefined && index1 > index0) {
            if (index1 === index0 + 1) {
                dest.push(this.edges[index0]);
            }
            else {
                const cluster = [];
                for (let i = index0; i < index1; i++)
                    cluster.push(this.edges[i]);
                dest.push(cluster);
            }
        }
    }
    /**
     * sort the edges, and look for three categories of paired edges:
     * * caller must allocate all result arrays of interest.
     * * Any combination of the result arrays may be `undefined`, indicating that category is to be ignored.
     * * Any combination of the result arrays may be aliased as the same target, in which case those to categories are merged into the target.
     * * For instance, to ignore manifold pairs and collect all others (singleton and other) as a single array `allOther`, create `const allOther = []` as an empty array and call
     * `sortAndCollectClusters (undefined, allOther, allOther);`
     * @param manifoldPairs optional array to receive pairs of properly mated SortableEdgePairs, i.e. simple interior edges adjacent to two facets in opposing directions.
     * @param singletons optional array to receive edges that are simple boundary edges.
     * @param nullEdges clusters with null edges (same start and end vertex)
     * @param allOtherClusters optional array to receive arrays in which all the edges are partners in an undirected sense but not a simple directed pair.
     */
    sortAndCollectClusters(manifoldPairs, singletons, nullEdges, allOtherClusters) {
        this.sort();
        if (manifoldPairs)
            manifoldPairs.length = 0;
        if (singletons)
            singletons.length = 0;
        if (nullEdges)
            nullEdges.length = 0;
        if (allOtherClusters)
            allOtherClusters.length = 0;
        const n = this.edges.length;
        let clusterLength;
        for (let index0 = 0; index0 < n; index0 += clusterLength) {
            const baseEdge = this.edges[index0];
            clusterLength = 1;
            for (let index1 = index0 + 1; index1 < n && SortableEdge.areUndirectedPartners(baseEdge, this.edges[index1]); index1++) {
                clusterLength++;
            }
            if (this.edges[index0].isNullEdge) {
                this.collectSortableEdgeCluster(index0, index0 + clusterLength, nullEdges);
            }
            else if (clusterLength === 2 && SortableEdge.areDirectedPartners(baseEdge, this.edges[index0 + 1])) {
                this.collectSortableEdgeCluster(index0, index0 + clusterLength, manifoldPairs);
            }
            else if (clusterLength === 1) {
                this.collectSortableEdgeCluster(index0, index0 + 1, singletons);
            }
            else {
                this.collectSortableEdgeCluster(index0, index0 + clusterLength, allOtherClusters);
            }
        }
    }
}
exports.IndexedEdgeMatcher = IndexedEdgeMatcher;


/***/ }),

/***/ "./lib/polyface/Polyface.js":
/*!**********************************!*\
  !*** ./lib/polyface/Polyface.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty*/
// import { Geometry } from "./Geometry";
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const GeometryQuery_1 = __webpack_require__(/*! ../curve/GeometryQuery */ "./lib/curve/GeometryQuery.js");
const PolyfaceData_1 = __webpack_require__(/*! ./PolyfaceData */ "./lib/polyface/PolyfaceData.js");
const FacetFaceData_1 = __webpack_require__(/*! ./FacetFaceData */ "./lib/polyface/FacetFaceData.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const GrowableXYArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYArray */ "./lib/geometry3d/GrowableXYArray.js");
function allDefined(valueA, valueB, valueC) {
    return valueA !== undefined && valueB !== undefined && valueC !== undefined;
}
/**
 * A Polyface is n abstract mesh structure (of unspecified implementation) that provides a PolyfaceVisitor
 * to iterate over its facets.
 * @public
 */
class Polyface extends GeometryQuery_1.GeometryQuery {
    constructor(data) {
        super();
        /** String name for schema properties */
        this.geometryCategory = "polyface";
        this.data = data;
    }
    /** Return the flag indicating if the mesh display must assume both sides are visible. */
    get twoSided() { return this.data.twoSided; }
    /** set the flag indicating if the mesh display must assume both sides are visible. */
    set twoSided(value) { this.data.twoSided = value; }
    /**
       * Check validity of indices into a data array.
       * * It is valid to have  both indices and data undefined.
       * * It is NOT valid for just one to be defined.
       * * Index values at indices[indexPositionA <= i < indexPositionB] must be valid indices to the data array.
       * @param indices array of indices.
       * @param indexPositionA first index to test
       * @param indexPositionB one past final index to test
       * @param data data array.  Only its length is referenced.
       */
    static areIndicesValid(indices, indexPositionA, indexPositionB, data, dataLength) {
        if (indices === undefined && data === undefined)
            return true;
        if (!indices || !data)
            return false;
        if (indexPositionA < 0 || indexPositionA >= indices.length)
            return false;
        if (indexPositionB < indexPositionA || indexPositionB > indices.length)
            return false;
        for (let i = indexPositionA; i < indexPositionB; i++)
            if (indices[i] < 0 || indices[i] >= dataLength)
                return false;
        return true;
    }
}
exports.Polyface = Polyface;
/**
 * An `IndexedPolyface` is a set of facets which can have normal, param, and color arrays with independent point, normal, param, and color indices.
 * @public
 */
class IndexedPolyface extends Polyface {
    /**
     * Constructor for a new polyface.
     * @param data PolyfaceData arrays to capture.
     * @param facetStart optional array of facet start indices (e.g. known during clone)
     * @param facetToFacetData optional array of face identifiers (e.g. known during clone)
     */
    constructor(data, facetStart, facetToFaceData) {
        super(data);
        if (facetStart)
            this._facetStart = facetStart.slice();
        else {
            this._facetStart = [];
            this._facetStart.push(0);
        }
        if (facetToFaceData)
            this._facetToFaceData = facetToFaceData.slice();
        else
            this._facetToFaceData = [];
    }
    /** Test if other is an instance of `IndexedPolyface` */
    isSameGeometryClass(other) { return other instanceof IndexedPolyface; }
    /** Tests for equivalence between two IndexedPolyfaces. */
    isAlmostEqual(other) {
        if (other instanceof IndexedPolyface) {
            return this.data.isAlmostEqual(other.data) && PointHelpers_1.NumberArray.isExactEqual(this._facetStart, other._facetStart) &&
                PointHelpers_1.NumberArray.isExactEqual(this._facetToFaceData, other._facetToFaceData);
        }
        return false;
    }
    /**
     * Returns true if either the point array or the point index array is empty.
     */
    get isEmpty() { return this.data.pointCount === 0 || this.data.pointIndex.length === 0; }
    /**
     * * apply the transform to points
     * * apply the (inverse transpose of) the matrix part to normals
     * * If determinant is negative, also
     *   * negate normals
     *   * reverse index order around each facet.
     * @param transform
     */
    tryTransformInPlace(transform) {
        if (this.data.tryTransformInPlace(transform)) {
            const determinant = transform.matrix.determinant();
            if (determinant < 0) {
                this.reverseIndices();
                this.reverseNormals();
            }
        }
        return false;
    }
    /** Return a deep clone. */
    clone() {
        const result = new IndexedPolyface(this.data.clone(), this._facetStart.slice(), this._facetToFaceData.slice());
        return result;
    }
    /** Return a deep clone with transformed points and normals */
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    /** Reverse the order of indices around all facets. */
    reverseIndices() { this.data.reverseIndices(this._facetStart); }
    /** Reverse the direction of all normal vectors. */
    reverseNormals() { this.data.reverseNormals(); }
    /** return face data using a facet index. This is the REFERENCE to the FacetFaceData, not a copy. Returns undefined if none found. */
    tryGetFaceData(i) {
        const faceIndex = this._facetToFaceData[i];
        if (faceIndex >= this.data.face.length)
            return undefined;
        return this.data.face[faceIndex];
    }
    /**
     * * Add facets from source to this polyface.
     * * optionally reverse the facets.
     * * optionally apply a transform to points.
     * * will only copy param, normal, color, and face data if we are already tracking them AND/OR the source contains them
     */
    addIndexedPolyface(source, reversed, transform) {
        const copyParams = allDefined(this.data.param, source.data.param, source.data.paramIndex);
        const copyNormals = allDefined(this.data.normal, source.data.normal, source.data.normalIndex);
        // Add point data
        const sourceToDestPointIndex = new GrowableFloat64Array_1.GrowableFloat64Array();
        sourceToDestPointIndex.ensureCapacity(source.data.pointCount);
        const sourcePoints = source.data.point;
        const xyz = Point3dVector3d_1.Point3d.create();
        for (let i = 0, n = source.data.point.length; i < n; i++) {
            sourcePoints.getPoint3dAtUncheckedPointIndex(i, xyz);
            if (transform) {
                transform.multiplyPoint3d(xyz, xyz);
                sourceToDestPointIndex.push(this.addPoint(xyz));
            }
            else
                sourceToDestPointIndex.push(this.addPoint(xyz));
        }
        // Add point index and facet data
        const numSourceFacets = source._facetStart.length - 1;
        for (let i = 0; i < numSourceFacets; i++) {
            const i0 = source._facetStart[i];
            const i1 = source._facetStart[i + 1];
            if (reversed) {
                for (let j = i1; j-- > i0;) {
                    this.addPointIndex(sourceToDestPointIndex.atUncheckedIndex(source.data.pointIndex[j]), source.data.edgeVisible[j]);
                }
            }
            else {
                for (let j = i0; j < i1; j++) {
                    this.addPointIndex(sourceToDestPointIndex.atUncheckedIndex(source.data.pointIndex[j]), source.data.edgeVisible[j]);
                }
            }
            this.terminateFacet(false);
        }
        // Add param and param index data
        if (copyParams) {
            const myParams = this.data.param;
            const startOfNewParams = myParams.length;
            myParams.pushFromGrowableXYArray(source.data.param);
            for (let i = 0; i < source._facetStart.length; i++) { // Expect facet start and ends for points to match normals
                const i0 = source._facetStart[i];
                const i1 = source._facetStart[i + 1];
                if (reversed) {
                    for (let j = i1; j-- > i0;)
                        this.addParamIndex(startOfNewParams + source.data.paramIndex[j]);
                }
                else {
                    for (let j = i0; j < i1; j++)
                        this.addParamIndex(startOfNewParams + source.data.paramIndex[j]);
                }
            }
        }
        // Add normal and normal index data
        if (copyNormals && source.data.normal) {
            const startOfNewNormals = this.data.normal.length;
            const numNewNormals = source.data.normal.length;
            for (let i = 0; i < numNewNormals; i++) {
                const sourceNormal = source.data.normal.getVector3dAtCheckedVectorIndex(i);
                if (transform) {
                    transform.multiplyVector(sourceNormal, sourceNormal);
                    this.addNormal(sourceNormal);
                }
                else {
                    this.addNormal(sourceNormal);
                }
            }
            for (let i = 0; i < source._facetStart.length; i++) { // Expect facet start and ends for points to match normals
                const i0 = source._facetStart[i];
                const i1 = source._facetStart[i + 1];
                if (reversed) {
                    for (let j = i1; j-- > i0;)
                        this.addNormalIndex(startOfNewNormals + source.data.normalIndex[j]);
                }
                else {
                    for (let j = i0; j < i1; j++)
                        this.addNormalIndex(startOfNewNormals + source.data.normalIndex[j]);
                }
            }
        }
        // Add color and color index data
        if (this.data.color && source.data.color && source.data.colorIndex) {
            const startOfNewColors = this.data.color.length;
            for (const sourceColor of source.data.color) {
                this.addColor(sourceColor);
            }
            for (let i = 0; i < source._facetStart.length; i++) { // Expect facet start and ends for points to match colors
                const i0 = source._facetStart[i];
                const i1 = source._facetStart[i + 1];
                if (reversed) {
                    for (let j = i1; j-- > i0;)
                        this.addColorIndex(startOfNewColors + source.data.colorIndex[j - 1]);
                }
                else {
                    for (let j = i0; j < i1; j++)
                        this.addColorIndex(startOfNewColors + source.data.colorIndex[j]);
                }
            }
        }
        // Add face and facetToFace index data
        if (source.data.face.length !== 0) {
            const startOfNewFaceData = this.data.face.length;
            for (const face of source.data.face) {
                const sourceFaceData = face.clone();
                this.data.face.push(sourceFaceData);
            }
            for (const facetToFaceIdx of source._facetToFaceData) {
                this._facetToFaceData.push(startOfNewFaceData + facetToFaceIdx);
            }
        }
    }
    /** Return the total number of param indices in zero-terminated style, which includes
     * * all the indices in the packed zero-based table
     * * one additional index for the zero-terminator of each facet.
     * @note Note that all index arrays (point, normal, param, color) have the same counts, so there
     * is not a separate query for each of them.
     */
    get zeroTerminatedIndexCount() { return this.data.pointIndex.length + this._facetStart.length - 1; }
    /** Create an empty facet set, with coordinate and index data to be supplied later.
     * @param needNormals true if normals will be constructed
     * @param needParams true if uv parameters will be constructed
     * @param needColors true if colors will e constructed.
     */
    static create(needNormals = false, needParams = false, needColors = false, twoSided = false) {
        return new IndexedPolyface(new PolyfaceData_1.PolyfaceData(needNormals, needParams, needColors, twoSided));
    }
    /** add (a clone of ) a point. return its 0 based index.
     * @param point point coordinates
     * @param priorIndex optional index of prior point to check for repeated coordinates
     * @returns Returns the zero-based index of the added or reused point.
     */
    addPoint(point, priorIndex) {
        if (priorIndex !== undefined) {
            const distance = this.data.point.distanceIndexToPoint(priorIndex, point);
            if (distance !== undefined && Geometry_1.Geometry.isSmallMetricDistance(distance))
                return priorIndex;
        }
        this.data.point.pushXYZ(point.x, point.y, point.z);
        return this.data.point.length - 1;
    }
    /** add a point.
     * @returns Returns the zero-based index of the added point.
     */
    addPointXYZ(x, y, z) { this.data.point.push(Point3dVector3d_1.Point3d.create(x, y, z)); return this.data.point.length - 1; }
    /** Add a uv param.
     * @returns 0-based index of the added param.
     */
    addParam(param) {
        if (!this.data.param)
            this.data.param = new GrowableXYArray_1.GrowableXYArray();
        this.data.param.push(param);
        return this.data.param.length - 1;
    }
    /** Add a uv parameter to the parameter array.
     * @param priorIndexA first index to check for possible duplicate value.
     * @param priorIndexB second index to check for possible duplicate value.
     * @returns 0-based index of the added or reused param.
     */
    addParamUV(u, v, priorIndexA, priorIndexB) {
        if (!this.data.param)
            this.data.param = new GrowableXYArray_1.GrowableXYArray();
        if (priorIndexA !== undefined && this.data.isAlmostEqualParamIndexUV(priorIndexA, u, v))
            return priorIndexA;
        if (priorIndexB !== undefined && this.data.isAlmostEqualParamIndexUV(priorIndexB, u, v))
            return priorIndexB;
        this.data.param.push(Point2dVector2d_1.Point2d.create(u, v));
        return this.data.param.length - 1;
    }
    /** Add a normal vector
     * @param priorIndexA first index to check for possible duplicate value.
     * @param priorIndexB second index to check for possible duplicate value.
     * @returns 0-based index of the added or reused normal.
     */
    addNormal(normal, priorIndexA, priorIndexB) {
        if (this.data.normal !== undefined) {
            let distance;
            if (priorIndexA !== undefined) {
                distance = this.data.normal.distanceIndexToPoint(priorIndexA, normal);
                if (distance !== undefined && Geometry_1.Geometry.isSmallMetricDistance(distance))
                    return priorIndexA;
            }
            if (priorIndexB !== undefined) {
                distance = this.data.normal.distanceIndexToPoint(priorIndexB, normal);
                if (distance !== undefined && Geometry_1.Geometry.isSmallMetricDistance(distance))
                    return priorIndexB;
            }
            const tailIndex = this.data.normal.length - 1;
            distance = this.data.normal.distanceIndexToPoint(tailIndex, normal);
            if (distance !== undefined && Geometry_1.Geometry.isSmallMetricDistance(distance))
                return tailIndex;
        }
        return this.addNormalXYZ(normal.x, normal.y, normal.z);
    }
    /** Add a normal vector given by direct coordinates
     * @returns 0-based index of the added or reused param.
     */
    addNormalXYZ(x, y, z) {
        if (!this.data.normal)
            this.data.normal = new GrowableXYZArray_1.GrowableXYZArray();
        this.data.normal.pushXYZ(x, y, z);
        return this.data.normal.length - 1;
    }
    /** Add a color
     * @returns 0-based index of the added or reused color.
     */
    addColor(color) {
        if (!this.data.color)
            this.data.color = [];
        this.data.color.push(color);
        return this.data.color.length - 1;
    }
    /** Add a point index with edge visibility flag. */
    addPointIndex(index, visible = true) { this.data.pointIndex.push(index); this.data.edgeVisible.push(visible); }
    /** Add a normal index */
    addNormalIndex(index) {
        if (!this.data.normalIndex)
            this.data.normalIndex = [];
        this.data.normalIndex.push(index);
    }
    /** Add a param index */
    addParamIndex(index) {
        if (!this.data.paramIndex)
            this.data.paramIndex = [];
        this.data.paramIndex.push(index);
    }
    /** Add a color index */
    addColorIndex(index) {
        if (!this.data.colorIndex)
            this.data.colorIndex = [];
        this.data.colorIndex.push(index);
    }
    /** clean up the open facet.  return the returnValue (so caller can easily return cleanupOpenFacet("message")) */
    cleanupOpenFacet() {
        this.data.trimAllIndexArrays(this.data.pointIndex.length);
    }
    /** announce the end of construction of a facet.
     *
     * * The "open" facet is checked for:
     *
     * **  Same number of indices among all active index arrays --  point, normal, param, color
     * **  All indices are within bounds of the respective data arrays.
     * *  in error cases, all index arrays are trimmed back to the size when previous facet was terminated.
     * *  "undefined" return is normal.   Any other return is a description of an error.
     */
    terminateFacet(validateAllIndices = true) {
        const numFacets = this._facetStart.length - 1;
        const lengthA = this._facetStart[numFacets]; // number of indices in accepted facets
        const lengthB = this.data.pointIndex.length; // number of indices including the open facet
        if (validateAllIndices) {
            const messages = [];
            if (lengthB < lengthA + 2)
                messages.push("Less than 3 indices in open facet");
            if (this.data.normalIndex && this.data.normalIndex.length !== lengthB)
                messages.push("normalIndex count must match pointIndex count");
            if (this.data.paramIndex && this.data.paramIndex.length !== lengthB)
                messages.push("paramIndex count must equal pointIndex count");
            if (this.data.colorIndex && this.data.colorIndex.length !== lengthB)
                messages.push("colorIndex count must equal pointIndex count");
            if (this.data.edgeVisible.length !== lengthB)
                messages.push("visibleIndex count must equal pointIndex count");
            if (!Polyface.areIndicesValid(this.data.normalIndex, lengthA, lengthB, this.data.normal, this.data.normal ? this.data.normal.length : 0))
                messages.push("invalid normal indices in open facet");
            if (messages.length > 0) {
                this.cleanupOpenFacet();
                return messages;
            }
        }
        // appending to facetStart accepts the facet !!!
        this._facetStart.push(lengthB);
        return undefined;
    }
    /**
     * All terminated facets added since the declaration of the previous face
     * will be grouped into a new face with their own 2D range.
     */
    /** (read-only property) number of facets */
    get facetCount() { return this._facetStart.length - 1; }
    /** (read-only property) number of faces */
    get faceCount() { return this.data.faceCount; }
    /** (read-only property) number of points */
    get pointCount() { return this.data.pointCount; }
    /** (read-only property) number of colors */
    get colorCount() { return this.data.colorCount; }
    /** (read-only property) number of parameters */
    get paramCount() { return this.data.paramCount; }
    /** (read-only property) number of normals */
    get normalCount() { return this.data.normalCount; }
    /** Return the number of edges in a particular facet. */
    numEdgeInFacet(facetIndex) {
        if (this.isValidFacetIndex(facetIndex))
            return this._facetStart[facetIndex + 1] - this._facetStart[facetIndex];
        return 0;
    }
    /** test if `index` is a valid facet index. */
    isValidFacetIndex(index) { return index >= 0 && index + 1 < this._facetStart.length; }
    /** ASSUME valid facet index . .. return its start index in index arrays. */
    facetIndex0(index) { return this._facetStart[index]; }
    /** ASSUME valid facet index . .. return its end index in index arrays. */
    facetIndex1(index) { return this._facetStart[index + 1]; }
    /** create a visitor for this polyface */
    createVisitor(numWrap = 0) { return IndexedPolyfaceVisitor.create(this, numWrap); }
    /** Return the range of (optionally transformed) points in this mesh. */
    range(transform, result) { return this.data.range(result, transform); }
    /** Extend `range` with coordinates from this mesh */
    extendRange(range, transform) { this.data.range(range, transform); }
    /** Given the index of a facet, return the data pertaining to the face it is a part of. */
    getFaceDataByFacetIndex(facetIndex) {
        return this.data.face[this._facetToFaceData[facetIndex]];
    }
    /**
     * All terminated facets since the last face declaration will be mapped to a single new FacetFaceData object
     * using facetToFaceData[]. FacetFaceData holds the 2D range of the face. Returns true if successful, false otherwise.
     */
    setNewFaceData(endFacetIndex = 0) {
        const facetStart = this._facetToFaceData.length;
        if (facetStart >= this._facetStart.length)
            return false;
        if (0 === endFacetIndex) // The default for endFacetIndex is really the last facet
            endFacetIndex = this._facetStart.length; // Last facetStart index corresponds to the next facet if we were to create one
        const faceData = FacetFaceData_1.FacetFaceData.createNull();
        const visitor = IndexedPolyfaceVisitor.create(this, 0);
        if (!visitor.moveToReadIndex(facetStart)) { // Move visitor to first facet of new face
            return false;
        }
        // If parameter range is provided (by the polyface planeSet clipper) then use it
        const paramDefined = this.data.param !== undefined;
        const setParamRange = faceData.paramRange.isNull && paramDefined;
        do {
            if (setParamRange && visitor.param !== undefined)
                visitor.param.extendRange(faceData.paramRange);
        } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < endFacetIndex);
        if (paramDefined && !(this.data.param.length === 0) && faceData.paramDistanceRange.isNull)
            faceData.setParamDistanceRangeFromNewFaceData(this, facetStart, endFacetIndex);
        this.data.face.push(faceData);
        const faceDataIndex = this.data.face.length - 1;
        for (let i = this._facetToFaceData.length; i < endFacetIndex; i++)
            this._facetToFaceData.push(0 === this._facetStart[i] ? 0 : faceDataIndex);
        return true;
    }
    /** Second step of double dispatch:  call `handler.handleIndexedPolyface(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleIndexedPolyface(this);
    }
}
exports.IndexedPolyface = IndexedPolyface;
/**
 * An `IndexedPolyfaceVisitor` is an iterator-like object that "visits" facets of a mesh.
 * * The visitor extends a `PolyfaceData ` class, so it can at any time hold all the data of a single facet.
 * @public
 */
class IndexedPolyfaceVisitor extends PolyfaceData_1.PolyfaceData {
    // to be called from static factory method that validates the polyface ...
    constructor(facets, numWrap) {
        super(facets.data.normalCount > 0, facets.data.paramCount > 0, facets.data.colorCount > 0, facets.twoSided);
        this._polyface = facets;
        this._numWrap = numWrap;
        if (facets.data.auxData)
            this.auxData = facets.data.auxData.createForVisitor();
        this.reset();
        this._numEdges = 0;
        this._nextFacetIndex = 0;
        this._currentFacetIndex = -1;
    }
    /** Return the client polyface object. */
    clientPolyface() { return this._polyface; }
    /** Set the number of vertices duplicated (e.g. 1 for start and end) in arrays in the visitor. */
    setNumWrap(numWrap) { this._numWrap = numWrap; }
    /** Return the number of edges in the current facet.
     * * Not that if this visitor has `numWrap` greater than zero, the number of edges is smaller than the number of points.
     */
    get numEdgesThisFacet() { return this._numEdges; }
    /** Create a visitor for iterating the facets of `polyface`, with indicated number of points to be added to each facet to produce closed point arrays
     * Typical wrap counts are:
     * * 0 -- leave the point arrays with "missing final edge"
     * * 1 -- add point 0 as closure point
     * * 2 -- add points 0 and 1 as closure and wrap point.  This is useful when vertex visit requires two adjacent vectors, e.g. for cross products.
     */
    static create(polyface, numWrap) {
        return new IndexedPolyfaceVisitor(polyface, numWrap);
    }
    /** Advance the iterator to a particular facet in the client polyface */
    moveToReadIndex(facetIndex) {
        if (!this._polyface.isValidFacetIndex(facetIndex))
            return false;
        this._currentFacetIndex = facetIndex;
        this._nextFacetIndex = facetIndex + 1;
        this._numEdges = this._polyface.numEdgeInFacet(facetIndex);
        this.resizeAllDataArrays(this._numEdges + this._numWrap);
        this.gatherIndexedData(this._polyface.data, this._polyface.facetIndex0(this._currentFacetIndex), this._polyface.facetIndex1(this._currentFacetIndex), this._numWrap);
        return true;
    }
    /** Advance the iterator to a the 'next' facet in the client polyface */
    moveToNextFacet() {
        if (this._nextFacetIndex !== this._currentFacetIndex)
            return this.moveToReadIndex(this._nextFacetIndex);
        this._nextFacetIndex++;
        return true;
    }
    /** Reset the iterator to start at the first facet of the polyface. */
    reset() {
        this.moveToReadIndex(0);
        this._nextFacetIndex = 0; // so immediate moveToNextFacet stays here.
    }
    /**
     * Attempts to extract the distance parameter for the given vertex index on the current facet
     * Returns the distance parameter as a point. Returns undefined on failure.
     */
    tryGetDistanceParameter(index, result) {
        if (index >= this.numEdgesThisFacet)
            return undefined;
        if (this.param === undefined || this._polyface.data.face.length === 0)
            return undefined;
        const faceData = this._polyface.tryGetFaceData(this._currentFacetIndex);
        if (!faceData)
            return undefined;
        return faceData.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(index), this.param.getYAtUncheckedPointIndex(index), result);
    }
    /**
     * Attempts to extract the normalized parameter (0,1) for the given vertex index on the current facet.
     * Returns the normalized parameter as a point. Returns undefined on failure.
     */
    tryGetNormalizedParameter(index, result) {
        if (index >= this.numEdgesThisFacet)
            return undefined;
        if (this.param === undefined || this._polyface.data.face.length === 0)
            return undefined;
        const faceData = this._polyface.tryGetFaceData(this._currentFacetIndex);
        if (!faceData)
            return undefined;
        return faceData.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(index), this.param.getYAtUncheckedPointIndex(index), result);
    }
    /** Return the index (in the client polyface) of the current facet */
    currentReadIndex() { return this._currentFacetIndex; }
    /** Return the point index of vertex i within the currently loaded facet */
    clientPointIndex(i) { return this.pointIndex[i]; }
    /** Return the param index of vertex i within the currently loaded facet */
    clientParamIndex(i) { return this.paramIndex ? this.paramIndex[i] : -1; }
    /** Return the normal index of vertex i within the currently loaded facet */
    clientNormalIndex(i) { return this.normalIndex ? this.normalIndex[i] : -1; }
    /** Return the color index of vertex i within the currently loaded facet */
    clientColorIndex(i) { return this.colorIndex ? this.colorIndex[i] : -1; }
    /** Return the aux data index of vertex i within the currently loaded facet */
    clientAuxIndex(i) { return this.auxData ? this.auxData.indices[i] : -1; }
    /** clear the contents of all arrays.  Use this along with transferDataFrom methods to build up new facets */
    clearArrays() {
        if (this.point !== undefined)
            this.point.length = 0;
        if (this.param !== undefined)
            this.param.length = 0;
        if (this.normal !== undefined)
            this.normal.length = 0;
        if (this.color !== undefined)
            this.color.length = 0;
    }
    /** transfer data from a specified index of the other visitor as new data in this visitor. */
    pushDataFrom(other, index) {
        this.point.pushFromGrowableXYZArray(other.point, index);
        if (this.color && other.color && index < other.color.length)
            this.color.push(other.color[index]);
        if (this.param && other.param && index < other.param.length)
            this.param.pushFromGrowableXYArray(other.param, index);
        if (this.normal && other.normal && index < other.normal.length)
            this.normal.pushFromGrowableXYZArray(other.normal, index);
    }
    /** transfer interpolated data from the other visitor.
     * * all data values are interpolated at `fraction` between `other` values at index0 and index1.
     */
    pushInterpolatedDataFrom(other, index0, fraction, index1) {
        this.point.pushInterpolatedFromGrowableXYZArray(other.point, index0, fraction, index1);
        if (this.color && other.color && index0 < other.color.length && index1 < other.color.length)
            this.color.push(interpolateColor(other.color[index0], fraction, other.color[index1]));
        if (this.param && other.param && index0 < other.param.length && index1 < other.param.length)
            this.param.pushInterpolatedFromGrowableXYArray(other.param, index0, fraction, index1);
        if (this.normal && other.normal && index0 < other.normal.length && index1 < other.normal.length)
            this.normal.pushInterpolatedFromGrowableXYZArray(other.normal, index0, fraction, index1);
    }
}
exports.IndexedPolyfaceVisitor = IndexedPolyfaceVisitor;
/**
 * * shift to right by shiftBits.
 * * mask off the low 8 bits
 * * interpolate the number
 * * truncate to floor
 * * shift left
 * * Hence all numbers in and out of the floating point are 0..255.
 * @param color0
 * @param fraction
 * @param color1
 * @param shiftBits
 */
function interpolateByte(color0, fraction, color1, shiftBits) {
    color0 = (color0 >>> shiftBits) & 0xFF;
    color1 = (color1 >>> shiftBits) & 0xFF;
    const color = Math.floor(color0 + fraction * (color1 - color0)) & 0xFF;
    return color << shiftBits;
}
function interpolateColor(color0, fraction, color1) {
    // don't allow fractions outside the individual byte ranges.
    fraction = Geometry_1.Geometry.clamp(fraction, 0, 1);
    // interpolate each byte in place ....
    /*
    const byte0 = interpolateLowByte(color0 & 0xFF, fraction, color1 & 0xFF);
    const byte1 = interpolateLowByte((color0 & 0xFF00) >>> 8, fraction, (color1 & 0xFF00) >>> 8) << 8;
    const byte2 = interpolateLowByte((color0 & 0xFF0000) >>> 16, fraction, (color1 & 0xFF0000) >>> 16) << 16;
    const byte3 = interpolateLowByte((color0 & 0xFF000000) >>> 24, fraction, (color1 & 0xFF000000) >>> 24) << 24;
    */
    const byte0 = interpolateByte(color0, fraction, color1, 0);
    const byte1 = interpolateByte(color0, fraction, color1, 8);
    const byte2 = interpolateByte(color0, fraction, color1, 16);
    const byte3 = interpolateByte(color0, fraction, color1, 24);
    return (byte0 | byte1 | byte2 | byte3);
}


/***/ }),

/***/ "./lib/polyface/PolyfaceBuilder.js":
/*!*****************************************!*\
  !*** ./lib/polyface/PolyfaceBuilder.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
const Polyface_1 = __webpack_require__(/*! ./Polyface */ "./lib/polyface/Polyface.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const BoxTopology_1 = __webpack_require__(/*! ./BoxTopology */ "./lib/polyface/BoxTopology.js");
const StrokeOptions_1 = __webpack_require__(/*! ../curve/StrokeOptions */ "./lib/curve/StrokeOptions.js");
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const Graph_1 = __webpack_require__(/*! ../topology/Graph */ "./lib/topology/Graph.js");
const GeometryHandler_1 = __webpack_require__(/*! ../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const StrokeCountChain_1 = __webpack_require__(/*! ../curve/Query/StrokeCountChain */ "./lib/curve/Query/StrokeCountChain.js");
const ParityRegion_1 = __webpack_require__(/*! ../curve/ParityRegion */ "./lib/curve/ParityRegion.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const ConstructCurveBetweenCurves_1 = __webpack_require__(/*! ../curve/ConstructCurveBetweenCurves */ "./lib/curve/ConstructCurveBetweenCurves.js");
const CylindricalRange_1 = __webpack_require__(/*! ../curve/Query/CylindricalRange */ "./lib/curve/Query/CylindricalRange.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const BilinearPatch_1 = __webpack_require__(/*! ../geometry3d/BilinearPatch */ "./lib/geometry3d/BilinearPatch.js");
const FrameBuilder_1 = __webpack_require__(/*! ../geometry3d/FrameBuilder */ "./lib/geometry3d/FrameBuilder.js");
const Triangulation_1 = __webpack_require__(/*! ../topology/Triangulation */ "./lib/topology/Triangulation.js");
const PolygonOps_1 = __webpack_require__(/*! ../geometry3d/PolygonOps */ "./lib/geometry3d/PolygonOps.js");
const SweepContour_1 = __webpack_require__(/*! ../solid/SweepContour */ "./lib/solid/SweepContour.js");
const Point3dArrayCarrier_1 = __webpack_require__(/*! ../geometry3d/Point3dArrayCarrier */ "./lib/geometry3d/Point3dArrayCarrier.js");
const GreedyTriangulationBetweenLineStrings_1 = __webpack_require__(/*! ./GreedyTriangulationBetweenLineStrings */ "./lib/polyface/GreedyTriangulationBetweenLineStrings.js");
/* tslint:disable:variable-name prefer-for-of*/
/**
 * A FacetSector
 * * initially holds coordinate data for a place where xyz and sectionDerivative are known
 * * normal is computed as a deferred step using an edge to adjacent place on ruled surface
 * * indices are set up even later.
 */
class FacetSector {
    constructor(needNormal = false, needUV = false, needSectionDerivative = false) {
        this.xyz = Point3dVector3d_1.Point3d.create();
        this.normalIndex = -1;
        this.uvIndex = -1;
        this.xyzIndex = -1;
        if (needNormal) {
            this.normal = Point3dVector3d_1.Vector3d.create();
        }
        if (needUV) {
            this.uv = Point2dVector2d_1.Point2d.create();
            this.uvIndex = -1;
        }
        if (needSectionDerivative) {
            this.sectionDerivative = Point3dVector3d_1.Vector3d.create();
        }
    }
    /** copy contents (not pointers) from source
     * * ASSUME all fields defined in this are defined int the source (undefined check only needed on this)
     */
    copyContentsFrom(other) {
        this.xyz.setFromPoint3d(other.xyz);
        this.xyzIndex = other.xyzIndex;
        if (this.normal)
            this.normal.setFromVector3d(other.normal);
        this.normalIndex = other.normalIndex;
        if (this.uv)
            this.uv.setFrom(other.uv);
        this.uvIndex = other.uvIndex;
        if (this.sectionDerivative)
            this.sectionDerivative.setFrom(other.sectionDerivative);
    }
    /** access xyz, derivative from given arrays.
     * * ASSUME corresponding defined conditions
     * * xyz and derivative are set.
     * * index fields for updated data are cleared to -1.
     */
    loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i, packedXYZ, packedDerivatives, fractions, v) {
        packedXYZ.getPoint3dAtCheckedPointIndex(i, this.xyz);
        if (fractions && v !== undefined)
            this.uv = Point2dVector2d_1.Point2d.create(fractions.atUncheckedIndex(i), v);
        this.xyzIndex = -1;
        this.normalIndex = -1;
        this.uvIndex = -1;
        if (this.sectionDerivative !== undefined && packedDerivatives !== undefined)
            packedDerivatives.getVector3dAtCheckedVectorIndex(i, this.sectionDerivative);
    }
    static suppressSmallUnitVectorComponents(uvw) {
        const tol = 1.0e-15;
        if (Math.abs(uvw.x) < tol)
            uvw.x = 0.0;
        if (Math.abs(uvw.y) < tol)
            uvw.y = 0.0;
        if (Math.abs(uvw.z) < tol)
            uvw.z = 0.0;
    }
    /**
     * given two sectors with xyz and sectionDerivative (u derivative)
     * use the edge from A to B as v direction in-surface derivative.
     * compute cross products (and normalize)
     * @param sectorA "lower" sector
     * @param sectorB "upper" sector
     *
     */
    static computeNormalsAlongRuleLine(sectorA, sectorB) {
        // We expect that if sectionDerivative is defined so is normal.
        // (If not, the cross product calls will generate normals that are never used ..  not good, garbage collector will clean up.)
        if (sectorA.sectionDerivative && sectorB.sectionDerivative) {
            const vectorAB = FacetSector._edgeVector;
            Point3dVector3d_1.Vector3d.createStartEnd(sectorA.xyz, sectorB.xyz, vectorAB);
            sectorA.sectionDerivative.crossProduct(vectorAB, sectorA.normal);
            sectorB.sectionDerivative.crossProduct(vectorAB, sectorB.normal);
            sectorA.normal.normalizeInPlace();
            sectorB.normal.normalizeInPlace();
            FacetSector.suppressSmallUnitVectorComponents(sectorA.normal);
            FacetSector.suppressSmallUnitVectorComponents(sectorB.normal);
        }
    }
}
FacetSector._edgeVector = Point3dVector3d_1.Vector3d.create();
/**
 * UVSurfaceOps is a class containing static methods operating on UVSurface objects.
 * @public
 */
class UVSurfaceOps {
    constructor() { } // private constructor -- no instances.
    /**
     * * evaluate `numEdge+1` points at surface uv parameters interpolated between (u0,v0) and (u1,v1)
     * * accumulate the xyz in a linestring.
     * * If xyzToUV is given, also accumulate transformed values as surfaceUV
     * * use xyzToUserUV transform to convert xyz to uv stored in the linestring (this uv is typically different from surface uv -- e.g. torus cap plane coordinates)
     * @param surface
     * @param u0 u coordinate at start of parameter space line
     * @param v0 v coordinate at end of parameter space line
     * @param u1 u coordinate at start of parameter space line
     * @param v1 v coordinate at end of parameter space line
     * @param numEdge number of edges.   (`numEdge+1` points are evaluated)
     * @param saveUV if true, save each surface uv fractions with `linestring.addUVParamsAsUV (u,v)`
     * @param saveFraction if true, save each fractional coordinate (along the u,v line) with `linestring.addFraction (fraction)`
     *
     * @param xyzToUV
     */
    static createLinestringOnUVLine(surface, u0, v0, u1, v1, numEdge, saveUV = false, saveFraction = false) {
        const ls = LineString3d_1.LineString3d.create();
        const xyz = Point3dVector3d_1.Point3d.create();
        let fraction, u, v;
        const numEvaluate = numEdge + 1;
        for (let i = 0; i < numEvaluate; i++) {
            fraction = i / numEdge;
            u = Geometry_1.Geometry.interpolate(u0, fraction, u1);
            v = Geometry_1.Geometry.interpolate(v0, fraction, v1);
            surface.uvFractionToPoint(u, v, xyz);
            ls.addPoint(xyz);
            if (saveUV)
                ls.addUVParamAsUV(u, v);
            if (saveFraction)
                ls.addFraction(fraction);
        }
        return ls;
    }
}
exports.UVSurfaceOps = UVSurfaceOps;
/**
 *
 * * Simple construction for strongly typed GeometryQuery objects:
 *
 *  * Create a builder with `builder = PolyfaceBuilder.create()`
 *  * Add GeometryQuery objects:
 *
 *    * `builder.addGeometryQuery(g: GeometryQuery)`
 *    * `builder.addCone(cone: Cone)`
 *    * `builder.addTorusPipe(surface: TorusPipe)`
 *    * `builder.addLinearSweepLineStrings(surface: LinearSweep)`
 *    * `builder.addRotationalSweep(surface: RotationalSweep)`
 *    * `builder.addLinearSweep(surface: LinearSweep)`
 *    * `builder.addRuledSweep(surface: RuledSweep)`
 *    * `builder.addSphere(sphere: Sphere)`
 *    * `builder.addBox(box: Box)`
 *    * `builder.addIndexedPolyface(polyface)`
 *  *  Extract with `builder.claimPolyface (true)`
 *
 * * Simple construction for ephemeral constructive data:
 *
 *  * Create a builder with `builder = PolyfaceBuilder.create()`
 *  * Add from fragmentary data:
 *    * `builder.addBetweenLineStrings (linestringA, linestringB, addClosure)`
 *    * `builder.addBetweenTransformedLineStrings (curves, transformA, transformB, addClosure)`
 *    * `builder.addBetweenStroked (curveA, curveB)`
 *    * `builder.addLinearSweepLineStrings (contour, vector)`
 *    * `builder.addPolygon (points, numPointsToUse)`
 *    * `builder.addTransformedUnitBox (transform)`
 *    * `builder.addTriangleFan (conePoint, linestring, toggleOrientation)`
 *    * `builder.addTrianglesInUncheckedPolygon (linestring, toggle)`
 *    * `builder.addUVGridBody(surface,numU, numV, createFanInCaps)`
 *    * `builder.addGraph(Graph, acceptFaceFunction)`
 *  *  Extract with `builder.claimPolyface(true)`
 *
 * * Low-level detail construction -- direct use of indices
 *  * Create a builder with `builder = PolyfaceBuilder.create()`
 *  * Add GeometryQuery objects
 *    * `builder.findOrAddPoint(point)`
 *    * `builder.findOrAddPointInLineString (linestring, index)`
 *    * `builder.findOrAddTransformedPointInLineString(linestring, index, transform)`
 *    * `builder.findOrAddPointXYZ(x,y,z)`
 *    * `builder.addTriangle (point0, point1, point2)`
 *    * `builder.addQuad (point0, point1, point2, point3)`
 *    * `builder.addOneBasedPointIndex (index)`
 * @public
 */
class PolyfaceBuilder extends GeometryHandler_1.NullGeometryHandler {
    constructor(options) {
        super();
        this._options = options ? options : StrokeOptions_1.StrokeOptions.createForFacets();
        this._polyface = Polyface_1.IndexedPolyface.create(this._options.needNormals, this._options.needParams, this._options.needColors, this._options.needTwoSided);
        this._reversed = false;
    }
    /** return (pointer to) the `StrokeOptions` in use by the builder. */
    get options() { return this._options; }
    /** Ask if this builder is reversing vertex order as loops are received. */
    get reversedFlag() { return this._reversed; }
    /** extract the polyface. */
    claimPolyface(compress = true) {
        if (compress)
            this._polyface.data.compress();
        return this._polyface;
    }
    /** Toggle (reverse) the flag controlling orientation flips for newly added facets. */
    toggleReversedFacetFlag() { this._reversed = !this._reversed; }
    /**
     * Create a builder with given StrokeOptions
     * @param options StrokeOptions (captured)
     */
    static create(options) {
        return new PolyfaceBuilder(options);
    }
    /** add facets for a transformed unit box. */
    addTransformedUnitBox(transform) {
        const pointIndex0 = this._polyface.data.pointCount;
        // these will have sequential indices starting at pointIndex0 . . .
        for (const p of BoxTopology_1.BoxTopology.points)
            this._polyface.addPoint(transform.multiplyPoint3d(p));
        for (const facet of BoxTopology_1.BoxTopology.cornerIndexCCW) {
            for (const pointIndex of facet)
                this._polyface.addPointIndex(pointIndex0 + pointIndex);
            this._polyface.terminateFacet();
        }
    }
    /** Add triangles from points[0] to each far edge.
     * @param ls linestring with point coordinates
     * @param toggle if true, wrap the triangle creation in toggleReversedFacetFlag.
     */
    addTriangleFan(conePoint, ls, toggle) {
        const n = ls.numPoints();
        if (n > 2) {
            if (toggle)
                this.toggleReversedFacetFlag();
            const index0 = this.findOrAddPoint(conePoint);
            let index1 = this.findOrAddPointInLineString(ls, 0);
            let index2 = 0;
            for (let i = 1; i < n; i++) {
                index2 = this.findOrAddPointInLineString(ls, i);
                this.addIndexedTrianglePointIndexes(index0, index1, index2);
                index1 = index2;
            }
            if (toggle)
                this.toggleReversedFacetFlag();
        }
    }
    /** Add triangles from points[0] to each far edge
     * * Assume the polygon is convex.
     * * i.e. simple triangulation from point0
     * * i.e. simple cross products give a good normal.
     * @param ls linestring with point coordinates
     * @param reverse if true, wrap the triangle creation in toggleReversedFacetFlag.
     */
    addTrianglesInUncheckedConvexPolygon(ls, toggle) {
        const n = ls.numPoints();
        if (n > 2) {
            if (toggle)
                this.toggleReversedFacetFlag();
            let normal;
            let normalIndex;
            if (this._options.needNormals) {
                normal = ls.quickUnitNormal(PolyfaceBuilder._workVectorFindOrAdd);
                if (toggle)
                    normal.scaleInPlace(-1.0);
                normalIndex = this._polyface.addNormal(normal);
            }
            const needParams = this._options.needParams;
            const packedUV = needParams ? ls.packedUVParams : undefined;
            let paramIndex0 = -1;
            let paramIndex1 = -1;
            let paramIndex2 = -1;
            if (packedUV) {
                paramIndex0 = this.findOrAddParamInGrowableXYArray(packedUV, 0);
                paramIndex1 = this.findOrAddParamInGrowableXYArray(packedUV, 1);
            }
            const pointIndex0 = this.findOrAddPointInLineString(ls, 0);
            let pointIndex1 = this.findOrAddPointInLineString(ls, 1);
            let pointIndex2 = 0;
            let numEdge = n;
            if (ls.isPhysicallyClosed)
                numEdge--;
            for (let i = 2; i < numEdge; i++, pointIndex1 = pointIndex2, paramIndex1 = paramIndex2) {
                pointIndex2 = this.findOrAddPointInLineString(ls, i);
                this.addIndexedTrianglePointIndexes(pointIndex0, pointIndex1, pointIndex2, false);
                if (normalIndex !== undefined)
                    this.addIndexedTriangleNormalIndexes(normalIndex, normalIndex, normalIndex);
                if (packedUV) {
                    paramIndex2 = this.findOrAddParamInGrowableXYArray(packedUV, i);
                    this.addIndexedTriangleParamIndexes(paramIndex0, paramIndex1, paramIndex2);
                }
                this._polyface.terminateFacet();
            }
            if (toggle)
                this.toggleReversedFacetFlag();
        }
    }
    /**
     * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.
     */
    findOrAddPoint(xyz) {
        return this._polyface.addPoint(xyz);
    }
    /**
     * Announce point coordinates.  The implementation is free to either create a new param or (if known) return index of a prior param with the same coordinates.
     */
    findOrAddParamXY(x, y) {
        return this._polyface.addParamUV(x, y);
    }
    /**
     * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.
     * @returns Returns the point index in the Polyface.
     * @param index Index of the point in the linestring.
     */
    findOrAddPointInLineString(ls, index, transform, priorIndex) {
        const q = ls.pointAt(index, PolyfaceBuilder._workPointFindOrAddA);
        if (q) {
            if (transform)
                transform.multiplyPoint3d(q, q);
            return this._polyface.addPoint(q, priorIndex);
        }
        return undefined;
    }
    /**
     * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.
     * @returns Returns the point index in the Polyface.
     * @param index Index of the point in the linestring.
     */
    findOrAddPointInGrowableXYZArray(xyz, index, transform, priorIndex) {
        const q = xyz.getPoint3dAtCheckedPointIndex(index, PolyfaceBuilder._workPointFindOrAddA);
        if (q) {
            if (transform)
                transform.multiplyPoint3d(q, q);
            return this._polyface.addPoint(q, priorIndex);
        }
        return undefined;
    }
    /**
     * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.
     * @returns Returns the point index in the Polyface.
     * @param index Index of the point in the linestring.
     */
    findOrAddNormalInGrowableXYZArray(xyz, index, transform, priorIndex) {
        const q = xyz.getVector3dAtCheckedVectorIndex(index, PolyfaceBuilder._workVectorFindOrAdd);
        if (q) {
            if (transform)
                transform.multiplyVector(q, q);
            return this._polyface.addNormal(q, priorIndex);
        }
        return undefined;
    }
    /**
     * Announce param coordinates.  The implementation is free to either create a new param or (if known) return index of a prior point with the same coordinates.
     * @returns Returns the point index in the Polyface.
     * @param index Index of the param in the linestring.
     */
    findOrAddParamInGrowableXYArray(data, index) {
        if (!data)
            return undefined;
        const q = data.getPoint2dAtUncheckedPointIndex(index, PolyfaceBuilder._workUVFindOrAdd);
        if (q) {
            return this._polyface.addParam(q);
        }
        return undefined;
    }
    /**
     * Announce param coordinates, taking u from ls.fractions and v from parameter.  The implementation is free to either create a new param or (if known) return index of a prior point with the same coordinates.
     * @returns Returns the point index in the Polyface.
     * @param index Index of the point in the linestring.
     */
    findOrAddParamInLineString(ls, index, v, priorIndexA, priorIndexB) {
        const u = (ls.fractions && index < ls.fractions.length) ? ls.fractions.atUncheckedIndex(index) : index / ls.points.length;
        return this._polyface.addParamUV(u, v, priorIndexA, priorIndexB);
    }
    /**
     * Announce normal coordinates found at index in the surfaceNormal array stored on the linestring
     * @returns Returns the point index in the Polyface.
     * @param index Index of the point in the linestring.
     * @param priorIndex possible prior normal index to reuse
     */
    findOrAddNormalInLineString(ls, index, transform, priorIndexA, priorIndexB) {
        const linestringNormals = ls.packedSurfaceNormals;
        if (linestringNormals) {
            const q = linestringNormals.getVector3dAtCheckedVectorIndex(index, PolyfaceBuilder._workVectorFindOrAdd);
            if (q) {
                if (transform)
                    transform.multiplyVector(q, q);
                return this._polyface.addNormal(q, priorIndexA, priorIndexB);
            }
        }
        return undefined;
    }
    // cspell:word Normaln
    /**
     * This is a misspelling of findOrAddNormalInLineString
     * @deprecated
     */
    findOrAddNormalnLineString(ls, index, transform, priorIndexA, priorIndexB) {
        return this.findOrAddNormalInLineString(ls, index, transform, priorIndexA, priorIndexB);
    }
    /**
     * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.
     */
    findOrAddPointXYZ(x, y, z) {
        return this._polyface.addPointXYZ(x, y, z);
    }
    /** Returns a transform who can be applied to points on a triangular facet in order to obtain UV parameters. */
    getUVTransformForTriangleFacet(pointA, pointB, pointC) {
        const vectorAB = pointA.vectorTo(pointB);
        const vectorAC = pointA.vectorTo(pointC);
        const unitAxes = Matrix3d_1.Matrix3d.createRigidFromColumns(vectorAB, vectorAC, Geometry_1.AxisOrder.XYZ);
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(pointA, unitAxes);
        return localToWorld.inverse();
    }
    /** Returns the normal to a triangular facet. */
    getNormalForTriangularFacet(pointA, pointB, pointC) {
        const vectorAB = pointA.vectorTo(pointB);
        const vectorAC = pointA.vectorTo(pointC);
        let normal = vectorAB.crossProduct(vectorAC).normalize();
        normal = normal ? normal : Point3dVector3d_1.Vector3d.create();
        return normal;
    }
    // ###: Consider case where normals will be reversed and point through the other end of the facet
    /**
     * Add a quad to the polyface given its points in order around the edges.
     * Optionally provide params and the plane normal, otherwise they will be calculated without reference data.
     * Optionally mark this quad as the last piece of a face in this polyface.
     */
    addQuadFacet(points, params, normals) {
        if (points instanceof GrowableXYZArray_1.GrowableXYZArray)
            points = points.getPoint3dArray();
        // If params and/or normals are needed, calculate them first
        const needParams = this.options.needParams;
        const needNormals = this.options.needNormals;
        let param0, param1, param2, param3;
        let normal0, normal1, normal2, normal3;
        if (needParams) {
            if (params !== undefined && params.length > 3) {
                param0 = params[0];
                param1 = params[1];
                param2 = params[2];
                param3 = params[3];
            }
            else {
                const paramTransform = this.getUVTransformForTriangleFacet(points[0], points[1], points[2]);
                if (paramTransform === undefined) {
                    param0 = param1 = param2 = param3 = Point2dVector2d_1.Point2d.createZero();
                }
                else {
                    param0 = Point2dVector2d_1.Point2d.createFrom(paramTransform.multiplyPoint3d(points[0]));
                    param1 = Point2dVector2d_1.Point2d.createFrom(paramTransform.multiplyPoint3d(points[1]));
                    param2 = Point2dVector2d_1.Point2d.createFrom(paramTransform.multiplyPoint3d(points[2]));
                    param3 = Point2dVector2d_1.Point2d.createFrom(paramTransform.multiplyPoint3d(points[3]));
                }
            }
        }
        if (needNormals) {
            if (normals !== undefined && normals.length > 3) {
                normal0 = normals[0];
                normal1 = normals[1];
                normal2 = normals[2];
                normal3 = normals[3];
            }
            else {
                normal0 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);
                normal1 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);
                normal2 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);
                normal3 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);
            }
        }
        if (this._options.shouldTriangulate) {
            // Add as two triangles, with a diagonal along the shortest distance
            const vectorAC = points[0].vectorTo(points[2]);
            const vectorBD = points[1].vectorTo(points[3]);
            // Note: We pass along any values for normals or params that we calculated
            if (vectorAC.magnitude() >= vectorBD.magnitude()) {
                this.addTriangleFacet([points[0], points[1], points[2]], needParams ? [param0, param1, param2] : undefined, needNormals ? [normal0, normal1, normal2] : undefined);
                this.addTriangleFacet([points[0], points[2], points[3]], needParams ? [param0, param2, param3] : undefined, needNormals ? [normal0, normal2, normal3] : undefined);
            }
            else {
                this.addTriangleFacet([points[0], points[1], points[3]], needParams ? [param0, param1, param3] : undefined, needNormals ? [normal0, normal1, normal3] : undefined);
                this.addTriangleFacet([points[1], points[2], points[3]], needParams ? [param1, param2, param3] : undefined, needNormals ? [normal1, normal2, normal3] : undefined);
            }
            return;
        }
        let idx0, idx1, idx2, idx3;
        // Add params if needed
        if (needParams) {
            idx0 = this._polyface.addParam(param0);
            idx1 = this._polyface.addParam(param1);
            idx2 = this._polyface.addParam(param2);
            idx3 = this._polyface.addParam(param3);
            this.addIndexedQuadParamIndexes(idx0, idx1, idx3, idx2);
        }
        // Add normals if needed
        if (needNormals) {
            idx0 = this._polyface.addNormal(normal0);
            idx1 = this._polyface.addNormal(normal1);
            idx2 = this._polyface.addNormal(normal2);
            idx3 = this._polyface.addNormal(normal3);
            this.addIndexedQuadNormalIndexes(idx0, idx1, idx3, idx2);
        }
        // Add point and point indexes last (terminates the facet)
        idx0 = this.findOrAddPoint(points[0]);
        idx1 = this.findOrAddPoint(points[1]);
        idx2 = this.findOrAddPoint(points[2]);
        idx3 = this.findOrAddPoint(points[3]);
        this.addIndexedQuadPointIndexes(idx0, idx1, idx3, idx2);
    }
    /** Announce a single quad facet's point indexes.
     *
     * * The actual quad may be reversed or triangulated based on builder setup.
     * *  indexA0 and indexA1 are in the forward order at the "A" end of the quad
     * *  indexB0 and indexB1 are in the forward order at the "B" end of the quad.
     */
    addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1, terminate = true) {
        if (this._reversed) {
            this._polyface.addPointIndex(indexA0);
            this._polyface.addPointIndex(indexB0);
            this._polyface.addPointIndex(indexB1);
            this._polyface.addPointIndex(indexA1);
        }
        else {
            this._polyface.addPointIndex(indexA0);
            this._polyface.addPointIndex(indexA1);
            this._polyface.addPointIndex(indexB1);
            this._polyface.addPointIndex(indexB0);
        }
        if (terminate)
            this._polyface.terminateFacet();
    }
    /** For a single quad facet, add the indexes of the corresponding param points. */
    addIndexedQuadParamIndexes(indexA0, indexA1, indexB0, indexB1) {
        if (this._reversed) {
            this._polyface.addParamIndex(indexA0);
            this._polyface.addParamIndex(indexB0);
            this._polyface.addParamIndex(indexB1);
            this._polyface.addParamIndex(indexA1);
        }
        else {
            this._polyface.addParamIndex(indexA0);
            this._polyface.addParamIndex(indexA1);
            this._polyface.addParamIndex(indexB1);
            this._polyface.addParamIndex(indexB0);
        }
    }
    /** For a single quad facet, add the indexes of the corresponding normal vectors. */
    addIndexedQuadNormalIndexes(indexA0, indexA1, indexB0, indexB1) {
        if (this._reversed) {
            this._polyface.addNormalIndex(indexA0);
            this._polyface.addNormalIndex(indexB0);
            this._polyface.addNormalIndex(indexB1);
            this._polyface.addNormalIndex(indexA1);
        }
        else {
            this._polyface.addNormalIndex(indexA0);
            this._polyface.addNormalIndex(indexA1);
            this._polyface.addNormalIndex(indexB1);
            this._polyface.addNormalIndex(indexB0);
        }
    }
    // ### TODO: Consider case where normals will be reversed and point through the other end of the facet
    /**
     * Add a triangle to the polyface given its points in order around the edges.
     * * Optionally provide params and triangle normals, otherwise they will be calculated without reference data.
     */
    addTriangleFacet(points, params, normals) {
        if (points.length < 3)
            return;
        let idx0;
        let idx1;
        let idx2;
        let point0, point1, point2;
        if (points instanceof GrowableXYZArray_1.GrowableXYZArray) {
            point0 = points.getPoint3dAtCheckedPointIndex(0);
            point1 = points.getPoint3dAtCheckedPointIndex(1);
            point2 = points.getPoint3dAtCheckedPointIndex(2);
        }
        else {
            point0 = points[0];
            point1 = points[1];
            point2 = points[2];
        }
        // Add params if needed
        if (this._options.needParams) {
            if (params && params.length >= 3) { // Params were given
                idx0 = this._polyface.addParam(params[0]);
                idx1 = this._polyface.addParam(params[1]);
                idx2 = this._polyface.addParam(params[2]);
            }
            else { // Compute params
                const paramTransform = this.getUVTransformForTriangleFacet(point0, point1, point2);
                idx0 = this._polyface.addParam(Point2dVector2d_1.Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point0) : undefined));
                idx1 = this._polyface.addParam(Point2dVector2d_1.Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point1) : undefined));
                idx2 = this._polyface.addParam(Point2dVector2d_1.Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point1) : undefined));
            }
            this.addIndexedTriangleParamIndexes(idx0, idx1, idx2);
        }
        // Add normals if needed
        if (this._options.needNormals) {
            if (normals !== undefined && normals.length > 2) { // Normals were given
                idx0 = this._polyface.addNormal(normals[0]);
                idx1 = this._polyface.addNormal(normals[1]);
                idx2 = this._polyface.addNormal(normals[2]);
            }
            else { // Compute normals
                const normal = this.getNormalForTriangularFacet(point0, point1, point2);
                idx0 = this._polyface.addNormal(normal);
                idx1 = this._polyface.addNormal(normal);
                idx2 = this._polyface.addNormal(normal);
            }
            this.addIndexedTriangleNormalIndexes(idx0, idx1, idx2);
        }
        // Add point and point indexes last (terminates the facet)
        idx0 = this.findOrAddPoint(point0);
        idx1 = this.findOrAddPoint(point1);
        idx2 = this.findOrAddPoint(point2);
        this.addIndexedTrianglePointIndexes(idx0, idx1, idx2);
    }
    /** Announce a single triangle facet's point indexes.
     *
     * * The actual quad may be reversed or triangulated based on builder setup.
     * *  indexA0 and indexA1 are in the forward order at the "A" end of the quad
     * *  indexB0 and indexB1 are in the forward order at the "B" end of hte quad.
     */
    addIndexedTrianglePointIndexes(indexA, indexB, indexC, terminateFacet = true) {
        if (!this._reversed) {
            this._polyface.addPointIndex(indexA);
            this._polyface.addPointIndex(indexB);
            this._polyface.addPointIndex(indexC);
        }
        else {
            this._polyface.addPointIndex(indexA);
            this._polyface.addPointIndex(indexC);
            this._polyface.addPointIndex(indexB);
        }
        if (terminateFacet)
            this._polyface.terminateFacet();
    }
    /** For a single triangle facet, add the indexes of the corresponding params. */
    addIndexedTriangleParamIndexes(indexA, indexB, indexC) {
        if (!this._reversed) {
            this._polyface.addParamIndex(indexA);
            this._polyface.addParamIndex(indexB);
            this._polyface.addParamIndex(indexC);
        }
        else {
            this._polyface.addParamIndex(indexA);
            this._polyface.addParamIndex(indexC);
            this._polyface.addParamIndex(indexB);
        }
    }
    /** For a single triangle facet, add the indexes of the corresponding params. */
    addIndexedTriangleNormalIndexes(indexA, indexB, indexC) {
        if (!this._reversed) {
            this._polyface.addNormalIndex(indexA);
            this._polyface.addNormalIndex(indexB);
            this._polyface.addNormalIndex(indexC);
        }
        else {
            this._polyface.addNormalIndex(indexA);
            this._polyface.addNormalIndex(indexC);
            this._polyface.addNormalIndex(indexB);
        }
    }
    /** Find or add xyzIndex and normalIndex for coordinates in the sector. */
    setSectorIndices(sector) {
        sector.xyzIndex = this.findOrAddPoint(sector.xyz);
        if (sector.normal)
            sector.normalIndex = this._polyface.addNormal(sector.normal);
        if (sector.uv)
            sector.uvIndex = this._polyface.addParam(sector.uv);
    }
    addSectorQuadA01B01(sectorA0, sectorA1, sectorB0, sectorB1) {
        if (sectorA0.xyz.isAlmostEqual(sectorA1.xyz) && sectorB0.xyz.isAlmostEqual(sectorB1.xyz)) {
            // ignore null quad !!
        }
        else {
            if (this._options.needNormals)
                this.addIndexedQuadNormalIndexes(sectorA0.normalIndex, sectorA1.normalIndex, sectorB0.normalIndex, sectorB1.normalIndex);
            if (this._options.needParams)
                this.addIndexedQuadParamIndexes(sectorA0.uvIndex, sectorA1.uvIndex, sectorB0.uvIndex, sectorB1.uvIndex);
            this.addIndexedQuadPointIndexes(sectorA0.xyzIndex, sectorA1.xyzIndex, sectorB0.xyzIndex, sectorB1.xyzIndex);
            this._polyface.terminateFacet();
        }
    }
    /** Add facets between lineStrings with matched point counts.
     * * surface normals are computed from (a) curve tangents in the linestrings and (b)rule line between linestrings.
     * * Facets are announced to addIndexedQuad.
     * * addIndexedQuad is free to apply reversal or triangulation options.
     */
    addBetweenLineStringsWithRuleEdgeNormals(lineStringA, vA, lineStringB, vB, addClosure = false) {
        const pointA = lineStringA.packedPoints;
        const pointB = lineStringB.packedPoints;
        const derivativeA = lineStringA.packedDerivatives;
        const derivativeB = lineStringB.packedDerivatives;
        const fractionA = lineStringA.fractions;
        const fractionB = lineStringB.fractions;
        const needNormals = this._options.needNormals;
        const needParams = this._options.needParams;
        const sectorA0 = new FacetSector(needNormals, needParams, needNormals);
        const sectorA1 = new FacetSector(needNormals, needParams, needNormals);
        const sectorB0 = new FacetSector(needNormals, needParams, needNormals);
        const sectorB1 = new FacetSector(needNormals, needParams, needNormals);
        const sectorA00 = new FacetSector(needNormals, needParams, needNormals);
        const sectorB00 = new FacetSector(needNormals, needParams, needNormals);
        const numPoints = pointA.length;
        if (numPoints < 2 || numPoints !== pointB.length)
            return;
        sectorA0.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0, pointA, derivativeA, fractionA, vA);
        sectorB0.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0, pointB, derivativeB, fractionB, vB);
        if (needNormals)
            FacetSector.computeNormalsAlongRuleLine(sectorA0, sectorB0);
        this.setSectorIndices(sectorA0);
        this.setSectorIndices(sectorB0);
        sectorA00.copyContentsFrom(sectorA0);
        sectorB00.copyContentsFrom(sectorB0);
        for (let i = 1; i < numPoints; i++) {
            sectorA1.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i, pointA, derivativeA, fractionA, vA);
            sectorB1.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i, pointB, derivativeA, fractionB, vB);
            FacetSector.computeNormalsAlongRuleLine(sectorA1, sectorB1);
            this.setSectorIndices(sectorA1);
            this.setSectorIndices(sectorB1);
            // create the facet ...
            this.addSectorQuadA01B01(sectorA0, sectorA1, sectorB0, sectorB1);
            sectorA0.copyContentsFrom(sectorA1);
            sectorB0.copyContentsFrom(sectorB1);
        }
        if (addClosure)
            this.addSectorQuadA01B01(sectorA0, sectorA00, sectorB0, sectorB00);
    }
    /** Add facets between lineStrings with matched point counts.
     * * point indices pre-stored
     * * normal indices pre-stored
     * * uv indices pre-stored
     */
    addBetweenLineStringsWithStoredIndices(lineStringA, lineStringB) {
        const pointA = lineStringA.pointIndices;
        const pointB = lineStringB.pointIndices;
        let normalA = lineStringA.normalIndices;
        let normalB = lineStringB.normalIndices;
        if (!this._options.needNormals) {
            normalA = undefined;
            normalB = undefined;
        }
        let paramA = lineStringA.paramIndices;
        let paramB = lineStringB.paramIndices;
        if (!this._options.needParams) {
            paramA = undefined;
            paramB = undefined;
        }
        const numPoints = pointA.length;
        for (let i = 1; i < numPoints; i++) {
            if (pointA.atUncheckedIndex(i - 1) !== pointA.atUncheckedIndex(i) || pointB.atUncheckedIndex(i - 1) !== pointB.atUncheckedIndex(i)) {
                this.addIndexedQuadPointIndexes(pointA.atUncheckedIndex(i - 1), pointA.atUncheckedIndex(i), pointB.atUncheckedIndex(i - 1), pointB.atUncheckedIndex(i));
                if (normalA && normalB)
                    this.addIndexedQuadNormalIndexes(normalA.atUncheckedIndex(i - 1), normalA.atUncheckedIndex(i), normalB.atUncheckedIndex(i - 1), normalB.atUncheckedIndex(i));
                if (paramA && paramB)
                    this.addIndexedQuadParamIndexes(paramA.atUncheckedIndex(i - 1), paramA.atUncheckedIndex(i), paramB.atUncheckedIndex(i - 1), paramB.atUncheckedIndex(i));
                this._polyface.terminateFacet();
            }
        }
    }
    /** Add facets between lineStrings with matched point counts.
     *
     * * Facets are announced to addIndexedQuad.
     * * addIndexedQuad is free to apply reversal or triangulation options.
     */
    addBetweenTransformedLineStrings(curves, transformA, transformB, addClosure = false) {
        if (curves instanceof LineString3d_1.LineString3d) {
            const pointA = curves.points;
            const numPoints = pointA.length;
            let indexA0 = this.findOrAddPointInLineString(curves, 0, transformA);
            let indexB0 = this.findOrAddPointInLineString(curves, 0, transformB);
            const indexA00 = indexA0;
            const indexB00 = indexB0;
            let indexA1 = 0;
            let indexB1 = 0;
            for (let i = 1; i < numPoints; i++) {
                indexA1 = this.findOrAddPointInLineString(curves, i, transformA);
                indexB1 = this.findOrAddPointInLineString(curves, i, transformB);
                this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);
                indexA0 = indexA1;
                indexB0 = indexB1;
            }
            if (addClosure)
                this.addIndexedQuadPointIndexes(indexA0, indexA00, indexB0, indexB00);
        }
        else {
            const children = curves.children;
            // just send the children individually -- final s will fix things??
            if (children)
                for (const c of children) {
                    this.addBetweenTransformedLineStrings(c, transformA, transformB);
                }
        }
    }
    addBetweenStrokeSetPair(dataA, vA, dataB, vB) {
        if (dataA instanceof LineString3d_1.LineString3d && dataB instanceof LineString3d_1.LineString3d) {
            this.addBetweenLineStringsWithRuleEdgeNormals(dataA, vA, dataB, vB, false);
        }
        else if (dataA instanceof ParityRegion_1.ParityRegion && dataB instanceof ParityRegion_1.ParityRegion) {
            if (dataA.children.length === dataB.children.length) {
                for (let i = 0; i < dataA.children.length; i++) {
                    this.addBetweenStrokeSetPair(dataA.children[i], vA, dataB.children[i], vB);
                }
            }
        }
        else if (dataA instanceof CurveCollection_1.CurveChain && dataB instanceof CurveCollection_1.CurveChain) {
            const chainA = dataA.children;
            const chainB = dataB.children;
            if (chainA.length === chainB.length) {
                for (let i = 0; i < chainA.length; i++) {
                    const cpA = chainA[i];
                    const cpB = chainB[i];
                    if (cpA instanceof LineString3d_1.LineString3d && cpB instanceof LineString3d_1.LineString3d) {
                        this.addBetweenLineStringsWithRuleEdgeNormals(cpA, vA, cpB, vB);
                    }
                }
            }
        }
    }
    /**
     * Add facets from a Cone
     */
    addCone(cone) {
        // ensure identical stroke counts at each end . . .
        let strokeCount = 16;
        if (this._options)
            strokeCount = this._options.applyTolerancesToArc(cone.getMaxRadius());
        let axisStrokeCount = 1;
        const lineStringA = cone.strokeConstantVSection(0.0, strokeCount, this._options);
        const lineStringB = cone.strokeConstantVSection(1.0, strokeCount, this._options);
        if (this._options) {
            const vDistanceRange = GrowableXYZArray_1.GrowableXYZArray.distanceRangeBetweenCorrespondingPoints(lineStringA.packedPoints, lineStringB.packedPoints);
            axisStrokeCount = this._options.applyMaxEdgeLength(1, vDistanceRange.low);
        }
        const sizes = cone.maxIsoParametricDistance();
        this.addUVGridBody(cone, strokeCount, axisStrokeCount, Segment1d_1.Segment1d.create(0, sizes.x), Segment1d_1.Segment1d.create(0, sizes.y));
        this.endFace();
        if (cone.capped) {
            if (!Geometry_1.Geometry.isSmallMetricDistance(cone.getRadiusA())) {
                this.addTrianglesInUncheckedConvexPolygon(lineStringA, true); // lower triangles flip
                this.endFace();
            }
            if (!Geometry_1.Geometry.isSmallMetricDistance(cone.getRadiusB())) {
                this.addTrianglesInUncheckedConvexPolygon(lineStringB, false); // upper triangles to not flip.
                this.endFace();
            }
        }
    }
    /**
     * Add facets for a TorusPipe.
     */
    addTorusPipe(surface, phiStrokeCount, thetaStrokeCount) {
        const thetaFraction = surface.getThetaFraction();
        const numU = Geometry_1.Geometry.clamp(Geometry_1.Geometry.resolveNumber(phiStrokeCount, 8), 4, 64);
        const numV = Geometry_1.Geometry.clamp(Geometry_1.Geometry.resolveNumber(thetaStrokeCount, Math.ceil(16 * thetaFraction)), 2, 64);
        this.toggleReversedFacetFlag();
        const sizes = surface.maxIsoParametricDistance();
        this.addUVGridBody(surface, numU, numV, Segment1d_1.Segment1d.create(0, sizes.x), Segment1d_1.Segment1d.create(0, sizes.y));
        this.toggleReversedFacetFlag();
        if (surface.capped && thetaFraction < 1.0) {
            const centerFrame = surface.getConstructiveFrame();
            const minorRadius = surface.getMinorRadius();
            const majorRadius = surface.getMajorRadius();
            const a = 2 * minorRadius;
            const r0 = majorRadius - minorRadius;
            const r1 = majorRadius + minorRadius;
            const z0 = -minorRadius;
            const cap0ToLocal = Transform_1.Transform.createRowValues(a, 0, 0, r0, 0, 0, -1, 0, 0, a, 0, z0);
            const cap0ToWorld = centerFrame.multiplyTransformTransform(cap0ToLocal);
            const worldToCap0 = cap0ToWorld.inverse();
            if (worldToCap0) {
                const ls0 = UVSurfaceOps.createLinestringOnUVLine(surface, 0, 0, 1, 0, numU, false, true);
                ls0.computeUVFromXYZTransform(worldToCap0);
                this.addTrianglesInUncheckedConvexPolygon(ls0, false);
            }
            const thetaRadians = surface.getSweepAngle().radians;
            const cc = Math.cos(thetaRadians);
            const ss = Math.sin(thetaRadians);
            const cap1ToLocal = Transform_1.Transform.createRowValues(-cc * a, 0, -ss, r1 * cc, -ss * a, 0, cc, r1 * ss, 0, a, 0, z0);
            const cap1ToWorld = centerFrame.multiplyTransformTransform(cap1ToLocal);
            const worldToCap1 = cap1ToWorld.inverse();
            if (worldToCap1) {
                const ls1 = UVSurfaceOps.createLinestringOnUVLine(surface, 1, 1, 0, 1, numU, false, true);
                ls1.computeUVFromXYZTransform(worldToCap1);
                this.addTrianglesInUncheckedConvexPolygon(ls1, false);
            }
        }
    }
    /**
     * Add point data (no params, normals) for linestrings.
     * * This recurses through curve chains (loops and paths)
     * * linestrings are swept
     * * All other curve types are ignored.
     * @param vector sweep vector
     * @param contour contour which contains only linestrings
     */
    addLinearSweepLineStringsXYZOnly(contour, vector) {
        if (contour instanceof LineString3d_1.LineString3d) {
            const ls = contour;
            let pointA = Point3dVector3d_1.Point3d.create();
            let pointB = Point3dVector3d_1.Point3d.create();
            let indexA0 = 0;
            let indexA1 = 0;
            let indexB0 = 0;
            let indexB1 = 0;
            const n = ls.numPoints();
            for (let i = 0; i < n; i++) {
                pointA = ls.pointAt(i, pointA);
                pointB = pointA.plus(vector, pointB);
                indexA1 = this.findOrAddPoint(pointA);
                indexB1 = this.findOrAddPoint(pointB);
                if (i > 0) {
                    this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);
                }
                indexA0 = indexA1;
                indexB0 = indexB1;
            }
        }
        else if (contour instanceof CurveCollection_1.CurveChain) {
            for (const ls of contour.children) {
                this.addLinearSweepLineStringsXYZOnly(ls, vector);
            }
        }
    }
    /**
     * Construct facets for a rotational sweep.
     */
    addRotationalSweep(surface) {
        const contour = surface.getCurves();
        const section0 = StrokeCountChain_1.StrokeCountSection.createForParityRegionOrChain(contour, this._options);
        const baseStrokes = section0.getStrokes();
        const axis = surface.cloneAxisRay();
        const perpendicularVector = CylindricalRange_1.CylindricalRangeQuery.computeMaxVectorFromRay(axis, baseStrokes);
        const swingVector = axis.direction.crossProduct(perpendicularVector);
        if (this._options.needNormals)
            CylindricalRange_1.CylindricalRangeQuery.buildRotationalNormalsInLineStrings(baseStrokes, axis, swingVector);
        const maxDistance = perpendicularVector.magnitude();
        const maxPath = Math.abs(maxDistance * surface.getSweep().radians);
        let numStep = StrokeOptions_1.StrokeOptions.applyAngleTol(this._options, 1, surface.getSweep().radians, undefined);
        numStep = StrokeOptions_1.StrokeOptions.applyMaxEdgeLength(this._options, numStep, maxPath);
        for (let i = 1; i <= numStep; i++) {
            const transformA = surface.getFractionalRotationTransform((i - 1) / numStep);
            const transformB = surface.getFractionalRotationTransform(i / numStep);
            this.addBetweenRotatedStrokeSets(baseStrokes, transformA, i - 1, transformB, i);
        }
        if (surface.capped) {
            const capContour = surface.getSweepContourRef();
            capContour.purgeFacets();
            capContour.emitFacets(this, true, undefined);
            // final loop pass left transformA at end ..
            capContour.emitFacets(this, false, surface.getFractionalRotationTransform(1.0));
        }
    }
    /**
     * Construct facets for any planar region
     */
    addTriangulatedRegion(region) {
        const contour = SweepContour_1.SweepContour.createForLinearSweep(region);
        if (contour)
            contour.emitFacets(this, true, undefined);
    }
    /**
     * * Recursively visit all children of data.
     * * At each primitive, invoke the computeStrokeCountForOptions method, with options from the builder.
     * @param data
     */
    applyStrokeCountsToCurvePrimitives(data) {
        const options = this._options;
        if (data instanceof CurvePrimitive_1.CurvePrimitive) {
            data.computeStrokeCountForOptions(options);
        }
        else if (data instanceof CurveCollection_1.CurveCollection) {
            const children = data.children;
            if (children)
                for (const child of children) {
                    this.applyStrokeCountsToCurvePrimitives(child);
                }
        }
    }
    addBetweenStrokeSetsWithRuledNormals(stroke0, stroke1, numVEdge) {
        const strokeSets = [stroke0];
        const fractions = [0.0];
        for (let vIndex = 1; vIndex < numVEdge; vIndex++) {
            const vFraction = vIndex / numVEdge;
            const strokeA = ConstructCurveBetweenCurves_1.ConstructCurveBetweenCurves.interpolateBetween(stroke0, vIndex / numVEdge, stroke1);
            strokeSets.push(strokeA);
            fractions.push(vFraction);
        }
        strokeSets.push(stroke1);
        fractions.push(1.0);
        for (let vIndex = 0; vIndex < numVEdge; vIndex++) {
            this.addBetweenStrokeSetPair(strokeSets[vIndex], fractions[vIndex], strokeSets[vIndex + 1], fractions[vIndex + 1]);
        }
    }
    createIndicesInLineString(ls, vParam, transform) {
        const n = ls.numPoints();
        {
            const pointIndices = ls.ensureEmptyPointIndices();
            const index0 = this.findOrAddPointInLineString(ls, 0, transform);
            pointIndices.push(index0);
            if (n > 1) {
                let indexA = index0;
                let indexB;
                for (let i = 1; i + 1 < n; i++) {
                    indexB = this.findOrAddPointInLineString(ls, i, transform, indexA);
                    pointIndices.push(indexB);
                    indexA = indexB;
                }
                // assume last point can only repeat back to zero ...
                indexB = this.findOrAddPointInLineString(ls, n - 1, transform, index0);
                pointIndices.push(indexB);
            }
        }
        if (this._options.needNormals && ls.packedSurfaceNormals !== undefined) {
            const normalIndices = ls.ensureEmptyNormalIndices();
            const normalIndex0 = this.findOrAddNormalInLineString(ls, 0, transform);
            normalIndices.push(normalIndex0);
            let normalIndexA = normalIndex0;
            let normalIndexB;
            if (n > 1) {
                for (let i = 1; i + 1 < n; i++) {
                    normalIndexB = this.findOrAddNormalInLineString(ls, i, transform, normalIndexA);
                    normalIndices.push(normalIndexB);
                    normalIndexA = normalIndexB;
                }
                // assume last point can only repeat back to zero ...
                normalIndexB = this.findOrAddNormalInLineString(ls, n - 1, transform, normalIndex0, normalIndexA);
                normalIndices.push(normalIndexB);
            }
        }
        if (this._options.needParams && ls.packedUVParams !== undefined) {
            const uvIndices = ls.ensureEmptyUVIndices();
            const uvIndex0 = this.findOrAddParamInLineString(ls, 0, vParam);
            uvIndices.push(uvIndex0);
            let uvIndexA = uvIndex0;
            let uvIndexB;
            if (n > 1) {
                for (let i = 1; i + 1 < n; i++) {
                    uvIndexB = this.findOrAddParamInLineString(ls, i, vParam, uvIndexA);
                    uvIndices.push(uvIndexB);
                    uvIndexA = uvIndexB;
                }
                // assume last point can only repeat back to zero ...
                uvIndexB = this.findOrAddParamInLineString(ls, n - 1, vParam, uvIndexA, uvIndex0);
                uvIndices.push(uvIndexB);
            }
        }
    }
    addBetweenRotatedStrokeSets(stroke0, transformA, vA, transformB, vB) {
        if (stroke0 instanceof LineString3d_1.LineString3d) {
            const strokeA = stroke0.cloneTransformed(transformA);
            this.createIndicesInLineString(strokeA, vA);
            const strokeB = stroke0.cloneTransformed(transformB);
            this.createIndicesInLineString(strokeB, vB);
            this.addBetweenLineStringsWithStoredIndices(strokeA, strokeB);
        }
        else if (stroke0 instanceof ParityRegion_1.ParityRegion) {
            for (let i = 0; i < stroke0.children.length; i++) {
                this.addBetweenRotatedStrokeSets(stroke0.children[i], transformA, vA, transformB, vB);
            }
        }
        else if (stroke0 instanceof CurveCollection_1.CurveChain) {
            const chainA = stroke0.children;
            for (let i = 0; i < chainA.length; i++) {
                const cpA = chainA[i];
                if (cpA instanceof LineString3d_1.LineString3d) {
                    this.addBetweenRotatedStrokeSets(cpA, transformA, vA, transformB, vB);
                }
            }
        }
    }
    /**
     *
     * Add facets from
     * * The swept contour
     * * each cap.
     */
    addLinearSweep(surface) {
        const contour = surface.getCurvesRef();
        const section0 = StrokeCountChain_1.StrokeCountSection.createForParityRegionOrChain(contour, this._options);
        const stroke0 = section0.getStrokes();
        const sweepVector = surface.cloneSweepVector();
        const sweepTransform = Transform_1.Transform.createTranslation(sweepVector);
        const stroke1 = stroke0.cloneTransformed(sweepTransform);
        const numVEdge = this._options.applyMaxEdgeLength(1, sweepVector.magnitude());
        this.addBetweenStrokeSetsWithRuledNormals(stroke0, stroke1, numVEdge);
        if (surface.capped && contour.isAnyRegionType) {
            const contourA = surface.getSweepContourRef();
            contourA.purgeFacets();
            contourA.emitFacets(this, true, undefined);
            contourA.emitFacets(this, false, sweepTransform);
        }
    }
    /**
     * Add facets from a ruled sweep.
     */
    addRuledSweep(surface) {
        const contours = surface.sweepContoursRef();
        let stroke0;
        let stroke1;
        const sectionMaps = [];
        for (let i = 0; i < contours.length; i++) {
            sectionMaps.push(StrokeCountChain_1.StrokeCountSection.createForParityRegionOrChain(contours[i].curves, this._options));
        }
        if (StrokeCountChain_1.StrokeCountSection.enforceStrokeCountCompatibility(sectionMaps)) {
            StrokeCountChain_1.StrokeCountSection.enforceCompatibleDistanceSums(sectionMaps);
            for (let i = 0; i < contours.length; i++) {
                stroke1 = sectionMaps[i].getStrokes();
                if (!stroke1)
                    stroke1 = contours[i].curves.cloneStroked();
                if (i > 0 && stroke0 && stroke1) {
                    const distanceRange = Range_1.Range1d.createNull();
                    if (StrokeCountChain_1.StrokeCountSection.extendDistanceRangeBetweenStrokes(stroke0, stroke1, distanceRange)
                        && !distanceRange.isNull) {
                        const numVEdge = this._options.applyMaxEdgeLength(1, distanceRange.high);
                        this.addBetweenStrokeSetsWithRuledNormals(stroke0, stroke1, numVEdge);
                    }
                }
                stroke0 = stroke1;
            }
        }
        if (surface.capped && contours[0].curves.isAnyRegionType) {
            contours[0].purgeFacets();
            contours[0].emitFacets(this, true, undefined);
            contours[contours.length - 1].purgeFacets();
            contours[contours.length - 1].emitFacets(this, false, undefined);
        }
        return true;
    }
    /**
     * Add facets from a Sphere
     */
    addSphere(sphere, strokeCount) {
        const numStrokeTheta = strokeCount ? strokeCount : this._options.defaultCircleStrokes;
        const numStrokePhi = Geometry_1.Geometry.clampToStartEnd(Math.abs(numStrokeTheta * sphere.latitudeSweepFraction), 1, Math.ceil(numStrokeTheta * 0.5));
        const lineStringA = sphere.strokeConstantVSection(0.0, numStrokeTheta, this._options);
        if (sphere.capped && !Geometry_1.Geometry.isSmallMetricDistance(lineStringA.quickLength())) {
            this.addTrianglesInUncheckedConvexPolygon(lineStringA, true); // lower triangles flip
            this.endFace();
        }
        const sizes = sphere.maxIsoParametricDistance();
        this.addUVGridBody(sphere, numStrokeTheta, numStrokePhi, Segment1d_1.Segment1d.create(0, sizes.x), Segment1d_1.Segment1d.create(0, sizes.y));
        this.endFace();
        const lineStringB = sphere.strokeConstantVSection(1.0, numStrokeTheta, this._options);
        if (sphere.capped && !Geometry_1.Geometry.isSmallMetricDistance(lineStringB.quickLength())) {
            this.addTrianglesInUncheckedConvexPolygon(lineStringB, false); // upper triangles do not flip
            this.endFace();
        }
    }
    /**
     * Add facets from a Box
     */
    addBox(box) {
        const corners = box.getCorners();
        const xLength = Geometry_1.Geometry.maxXY(box.getBaseX(), box.getBaseX());
        const yLength = Geometry_1.Geometry.maxXY(box.getBaseY(), box.getTopY());
        let zLength = 0.0;
        for (let i = 0; i < 4; i++) {
            zLength = Geometry_1.Geometry.maxXY(zLength, corners[i].distance(corners[i + 4]));
        }
        const numX = this._options.applyMaxEdgeLength(1, xLength);
        const numY = this._options.applyMaxEdgeLength(1, yLength);
        const numZ = this._options.applyMaxEdgeLength(1, zLength);
        // Wrap the 4 out-of-plane faces as a single parameters space with "distance" advancing in x then y then negative x then negative y ...
        const uParamRange = Segment1d_1.Segment1d.create(0, xLength);
        const vParamRange = Segment1d_1.Segment1d.create(0, zLength);
        this.addUVGridBody(BilinearPatch_1.BilinearPatch.create(corners[0], corners[1], corners[4], corners[5]), numX, numZ, uParamRange, vParamRange);
        uParamRange.shift(xLength);
        this.addUVGridBody(BilinearPatch_1.BilinearPatch.create(corners[1], corners[3], corners[5], corners[7]), numY, numZ, uParamRange, vParamRange);
        uParamRange.shift(yLength);
        this.addUVGridBody(BilinearPatch_1.BilinearPatch.create(corners[3], corners[2], corners[7], corners[6]), numX, numZ, uParamRange, vParamRange);
        uParamRange.shift(xLength);
        this.addUVGridBody(BilinearPatch_1.BilinearPatch.create(corners[2], corners[0], corners[6], corners[4]), numY, numZ, uParamRange, vParamRange);
        // finally end that wraparound face !!
        this.endFace();
        if (box.capped) {
            uParamRange.set(0.0, xLength);
            vParamRange.set(0.0, yLength);
            this.addUVGridBody(BilinearPatch_1.BilinearPatch.create(corners[4], corners[5], corners[6], corners[7]), numX, numY, uParamRange, vParamRange);
            this.endFace();
            uParamRange.set(0.0, xLength);
            vParamRange.set(0.0, yLength);
            this.addUVGridBody(BilinearPatch_1.BilinearPatch.create(corners[2], corners[3], corners[0], corners[1]), numX, numY, uParamRange, vParamRange);
            this.endFace();
        }
    }
    /** Add a polygon to the evolving facets.
     *
     * * Add points to the polyface
     * * indices are added (in reverse order if indicated by the builder state)
     * @param points array of points.  This may contain extra points not to be used in the polygon
     * @param numPointsToUse number of points to use.
     */
    addPolygon(points, numPointsToUse) {
        // don't use trailing points that match start point.
        if (numPointsToUse === undefined)
            numPointsToUse = points.length;
        while (numPointsToUse > 1 && points[numPointsToUse - 1].isAlmostEqual(points[0]))
            numPointsToUse--;
        let index = 0;
        if (!this._reversed) {
            for (let i = 0; i < numPointsToUse; i++) {
                index = this.findOrAddPoint(points[i]);
                this._polyface.addPointIndex(index);
            }
        }
        else {
            for (let i = numPointsToUse; --i >= 0;) {
                index = this.findOrAddPoint(points[i]);
                this._polyface.addPointIndex(index);
            }
        }
        this._polyface.terminateFacet();
    }
    /** Add a polygon to the evolving facets.
     *
     * * Add points to the polyface
     * * indices are added (in reverse order if indicated by the builder state)
     * @param points array of points.  This may contain extra points not to be used in the polygon
     * @param numPointsToUse number of points to use.
     */
    addPolygonGrowableXYZArray(points) {
        // don't use trailing points that match start point.
        let numPointsToUse = points.length;
        while (numPointsToUse > 1 && Geometry_1.Geometry.isSmallMetricDistance(points.distanceIndexIndex(0, numPointsToUse - 1)))
            numPointsToUse--;
        let index = 0;
        if (!this._reversed) {
            for (let i = 0; i < numPointsToUse; i++) {
                index = this.findOrAddPointInGrowableXYZArray(points, i);
                this._polyface.addPointIndex(index);
            }
        }
        else {
            for (let i = numPointsToUse; --i >= 0;) {
                index = this.findOrAddPointInGrowableXYZArray(points, i);
                this._polyface.addPointIndex(index);
            }
        }
        this._polyface.terminateFacet();
    }
    /** Add a polygon to the evolving facets.
     *
     * * Add points to the polyface
     * * indices are added (in reverse order if indicated by the builder state)
     * @param normals array of points.  This may contain extra points not to be used in the polygon
     * @param numPointsToUse number of points to use.
     */
    addFacetFromGrowableArrays(points, normals, params, colors) {
        // don't use trailing points that match start point.
        let numPointsToUse = points.length;
        while (numPointsToUse > 1 && Geometry_1.Geometry.isSmallMetricDistance(points.distanceIndexIndex(0, numPointsToUse - 1)))
            numPointsToUse--;
        let index = 0;
        if (normals && normals.length < numPointsToUse)
            normals = undefined;
        if (params && params.length < numPointsToUse)
            params = undefined;
        if (colors && colors.length < numPointsToUse)
            colors = undefined;
        if (!this._reversed) {
            for (let i = 0; i < numPointsToUse; i++) {
                index = this.findOrAddPointInGrowableXYZArray(points, i);
                this._polyface.addPointIndex(index);
                if (normals) {
                    index = this.findOrAddNormalInGrowableXYZArray(normals, i);
                    this._polyface.addNormalIndex(index);
                }
                if (params) {
                    index = this.findOrAddParamInGrowableXYArray(params, i);
                    this._polyface.addParamIndex(index);
                }
                if (colors) {
                    index = this._polyface.addColor(colors[i]);
                    this._polyface.addColorIndex(index);
                }
            }
        }
        else {
            for (let i = numPointsToUse; --i >= 0;) {
                index = this.findOrAddPointInGrowableXYZArray(points, i);
                this._polyface.addPointIndex(index);
                if (normals) {
                    index = this.findOrAddNormalInGrowableXYZArray(normals, i);
                    this._polyface.addNormalIndex(index);
                }
                if (params) {
                    index = this.findOrAddParamInGrowableXYArray(params, i);
                    this._polyface.addParamIndex(index);
                }
                if (colors) {
                    index = this._polyface.addColor(colors[i]);
                    this._polyface.addColorIndex(index);
                }
            }
        }
        this._polyface.terminateFacet();
    }
    /** Add the current visitor facet to the evolving polyface.
     * * indices are added (in reverse order if indicated by the builder state)
     */
    addFacetFromVisitor(visitor) {
        this.addFacetFromGrowableArrays(visitor.point, visitor.normal, visitor.param, visitor.color);
    }
    /** Add a polyface, with optional reverse and transform. */
    addIndexedPolyface(source, reversed, transform) {
        this._polyface.addIndexedPolyface(source, reversed, transform);
    }
    /**
     * Produce a new FacetFaceData for all terminated facets since construction of the previous face.
     * Each facet number/index is mapped to the FacetFaceData through the faceToFaceData array.
     * Returns true if successful, and false otherwise.
     */
    endFace() {
        return this._polyface.setNewFaceData();
    }
    /** Double dispatch handler for Cone */
    handleCone(g) { return this.addCone(g); }
    /** Double dispatch handler for TorusPipe */
    handleTorusPipe(g) { return this.addTorusPipe(g); }
    /** Double dispatch handler for Sphere */
    handleSphere(g) { return this.addSphere(g); }
    /** Double dispatch handler for Box */
    handleBox(g) { return this.addBox(g); }
    /** Double dispatch handler for LinearSweep */
    handleLinearSweep(g) { return this.addLinearSweep(g); }
    /** Double dispatch handler for RotationalSweep */
    handleRotationalSweep(g) { return this.addRotationalSweep(g); }
    /** Double dispatch handler for RuledSweep */
    handleRuledSweep(g) { return this.addRuledSweep(g); }
    /** add facets for a GeometryQuery object.   This is double dispatch through `dispatchToGeometryHandler(this)` */
    addGeometryQuery(g) { g.dispatchToGeometryHandler(this); }
    /**
     *
     * * Visit all faces
     * * Test each face with f(node) for any node on the face.
     * * For each face that passes, pass its coordinates to the builder.
     * * Rely on the builder's compress step to find common vertex coordinates
     * @internal
     */
    addGraph(graph, needParams, acceptFaceFunction = Graph_1.HalfEdge.testNodeMaskNotExterior) {
        let index = 0;
        const needNormals = this._options.needNormals;
        let normalIndex = 0;
        if (needNormals)
            normalIndex = this._polyface.addNormalXYZ(0, 0, 1); // big assumption !!!!  someday check if that's where the facets actually are!!
        graph.announceFaceLoops((_graph, seed) => {
            if (acceptFaceFunction(seed) && seed.countEdgesAroundFace() > 2) {
                let node = seed;
                do {
                    index = this.findOrAddPointXYZ(node.x, node.y, node.z);
                    this._polyface.addPointIndex(index);
                    if (needParams) {
                        index = this.findOrAddParamXY(node.x, node.y);
                        this._polyface.addParamIndex(index);
                    }
                    if (needNormals) {
                        this._polyface.addNormalIndex(normalIndex);
                    }
                    node = node.faceSuccessor;
                } while (node !== seed);
                this._polyface.terminateFacet();
            }
            return true;
        });
    }
    /**
     *
     * * For each node in `faces`
     *  * add all of its vertices to the polyface
     *  * add point indices to form a new facet.
     *    * (Note: no normal or param indices are added)
     *  * terminate the facet
     * @internal
     */
    addGraphFaces(_graph, faces) {
        let index = 0;
        for (const seed of faces) {
            let node = seed;
            do {
                index = this.findOrAddPointXYZ(node.x, node.y, node.z);
                this._polyface.addPointIndex(index);
                node = node.faceSuccessor;
            } while (node !== seed);
            this._polyface.terminateFacet();
        }
    }
    /** Create a polyface containing the faces of a HalfEdgeGraph, with test function to filter faces.
     * @internal
     */
    static graphToPolyface(graph, options, acceptFaceFunction = Graph_1.HalfEdge.testNodeMaskNotExterior) {
        const builder = PolyfaceBuilder.create(options);
        builder.addGraph(graph, builder.options.needParams, acceptFaceFunction);
        builder.endFace();
        return builder.claimPolyface();
    }
    /** Create a polyface containing an array of faces of a HalfEdgeGraph, with test function to filter faces.
     * @internal
     */
    static graphFacesToPolyface(graph, faces) {
        const builder = PolyfaceBuilder.create();
        builder.addGraphFaces(graph, faces);
        builder.endFace();
        return builder.claimPolyface();
    }
    /** Create a polyface containing triangles in a (space) polygon.
     * * The polyface contains only coordinate data (no params or normals).
     */
    static polygonToTriangulatedPolyface(points, localToWorld) {
        if (!localToWorld)
            localToWorld = FrameBuilder_1.FrameBuilder.createFrameWithCCWPolygon(points);
        if (localToWorld) {
            const localPoints = localToWorld.multiplyInversePoint3dArray(points);
            const areaXY = PolygonOps_1.PolygonOps.areaXY(localPoints);
            if (areaXY < 0.0)
                localPoints.reverse();
            const graph = Triangulation_1.Triangulator.createTriangulatedGraphFromSingleLoop(localPoints);
            if (graph) {
                const polyface = this.graphToPolyface(graph);
                polyface.tryTransformInPlace(localToWorld);
                return polyface;
            }
        }
        return undefined;
    }
    /**
     * Given arrays of coordinates for multiple facets.
     * * pointArray[i] is an array of 3 or 4 points
     * * paramArray[i] is an array of matching number of params
     * * normalArray[i] is an array of matching number of normals.
     * @param pointArray array of arrays of point coordinates
     * @param paramArray array of arrays of uv parameters
     * @param normalArray array of arrays of normals
     * @param endFace if true, call this.endFace after adding all the facets.
     */
    addCoordinateFacets(pointArray, paramArray, normalArray, endFace = false) {
        for (let i = 0; i < pointArray.length; i++) {
            const params = paramArray ? paramArray[i] : undefined;
            const normals = normalArray ? normalArray[i] : undefined;
            if (pointArray[i].length === 3)
                this.addTriangleFacet(pointArray[i], params, normals);
            else if (pointArray[i].length === 4)
                this.addQuadFacet(pointArray[i], params, normals);
        }
        if (endFace)
            this.endFace();
    }
    /**
     * * Evaluate `(numU + 1) * (numV + 1)` grid points (in 0..1 in both u and v) on a surface.
     * * Add the facets for `numU * numV` quads.
     * * uv params are the 0..1 fractions.
     * * normals are cross products of u and v direction partial derivatives.
     * @param surface
     * @param numU
     * @param numV
     */
    addUVGridBody(surface, numU, numV, uMap, vMap) {
        let xyzIndex0 = new GrowableFloat64Array_1.GrowableFloat64Array(numU);
        let xyzIndex1 = new GrowableFloat64Array_1.GrowableFloat64Array(numU);
        let paramIndex0;
        let paramIndex1;
        let normalIndex0;
        let normalIndex1;
        const reverse = this._reversed;
        const needNormals = this.options.needNormals;
        if (needNormals) {
            normalIndex0 = new GrowableFloat64Array_1.GrowableFloat64Array(numU);
            normalIndex1 = new GrowableFloat64Array_1.GrowableFloat64Array(numU);
        }
        const needParams = this.options.needParams;
        if (needParams) {
            paramIndex0 = new GrowableFloat64Array_1.GrowableFloat64Array(numU);
            paramIndex1 = new GrowableFloat64Array_1.GrowableFloat64Array(numU);
        }
        let indexSwap;
        xyzIndex0.ensureCapacity(numU);
        xyzIndex1.ensureCapacity(numU);
        const uv = Point2dVector2d_1.Point2d.create();
        const normal = Point3dVector3d_1.Vector3d.create();
        const du = 1.0 / numU;
        const dv = 1.0 / numV;
        const plane = Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createXYPlane();
        for (let v = 0; v <= numV; v++) {
            // evaluate new points ....
            xyzIndex1.clear();
            if (needNormals)
                normalIndex1.clear();
            if (needParams)
                paramIndex1.clear();
            for (let u = 0; u <= numU; u++) {
                const uFrac = u * du;
                const vFrac = v * dv;
                surface.uvFractionToPointAndTangents(uFrac, vFrac, plane);
                xyzIndex1.push(this._polyface.addPoint(plane.origin));
                if (needNormals) {
                    plane.vectorU.crossProduct(plane.vectorV, normal);
                    normal.normalizeInPlace();
                    if (reverse)
                        normal.scaleInPlace(-1.0);
                    normalIndex1.push(this._polyface.addNormal(normal));
                }
                if (needParams)
                    paramIndex1.push(this._polyface.addParam(Point2dVector2d_1.Point2d.create(uMap ? uMap.fractionToPoint(uFrac) : uFrac, vMap ? vMap.fractionToPoint(vFrac) : vFrac, uv)));
            }
            if (v > 0) {
                for (let u = 0; u < numU; u++) {
                    this.addIndexedQuadPointIndexes(xyzIndex0.atUncheckedIndex(u), xyzIndex0.atUncheckedIndex(u + 1), xyzIndex1.atUncheckedIndex(u), xyzIndex1.atUncheckedIndex(u + 1), false);
                    if (needNormals)
                        this.addIndexedQuadNormalIndexes(normalIndex0.atUncheckedIndex(u), normalIndex0.atUncheckedIndex(u + 1), normalIndex1.atUncheckedIndex(u), normalIndex1.atUncheckedIndex(u + 1));
                    if (needParams)
                        this.addIndexedQuadParamIndexes(paramIndex0.atUncheckedIndex(u), paramIndex0.atUncheckedIndex(u + 1), paramIndex1.atUncheckedIndex(u), paramIndex1.atUncheckedIndex(u + 1));
                    this._polyface.terminateFacet();
                }
            }
            indexSwap = xyzIndex1;
            xyzIndex1 = xyzIndex0;
            xyzIndex0 = indexSwap;
            if (needParams) {
                indexSwap = paramIndex1;
                paramIndex1 = paramIndex0;
                paramIndex0 = indexSwap;
            }
            if (needNormals) {
                indexSwap = normalIndex1;
                normalIndex1 = normalIndex0;
                normalIndex0 = indexSwap;
            }
        }
        xyzIndex0.clear();
        xyzIndex1.clear();
    }
    /**
     * Triangulate the points as viewed in xy.
     * @param points
     */
    static pointsToTriangulatedPolyface(points) {
        const graph = Triangulation_1.Triangulator.createTriangulatedGraphFromPoints(points);
        if (graph)
            return PolyfaceBuilder.graphToPolyface(graph);
        return undefined;
    }
    /** Create (and add to the builder) triangles that bridge the gap between two linestrings.
     * * Each triangle will have 1 vertex on one of the linestrings and 2 on the other
     * * Choice of triangles is heuristic, hence does not have a unique solution.
     * * Logic to choice among the various possible triangle orders prefers
     *    * Make near-coplanar facets
     *    * make facets with good aspect ratio.
     *    * This is exercised with a limited number of lookahead points, i.e. greedy to make first-available decision.
     * @param pointsA points of first linestring.
     * @param pointsB points of second linestring.
     */
    addGreedyTriangulationBetweenLineStrings(pointsA, pointsB) {
        const context = GreedyTriangulationBetweenLineStrings_1.GreedyTriangulationBetweenLineStrings.createContext();
        context.emitTriangles(resolveToIndexedXYZCollectionOrCarrier(pointsA), resolveToIndexedXYZCollectionOrCarrier(pointsB), (triangle) => {
            this.addTriangleFacet(triangle.points);
        });
    }
}
exports.PolyfaceBuilder = PolyfaceBuilder;
PolyfaceBuilder._workPointFindOrAddA = Point3dVector3d_1.Point3d.create();
PolyfaceBuilder._workVectorFindOrAdd = Point3dVector3d_1.Vector3d.create();
PolyfaceBuilder._workUVFindOrAdd = Point2dVector2d_1.Point2d.create();
function resolveToIndexedXYZCollectionOrCarrier(points) {
    if (Array.isArray(points))
        return new Point3dArrayCarrier_1.Point3dArrayCarrier(points);
    if (points instanceof LineString3d_1.LineString3d)
        return points.packedPoints;
    return points;
}


/***/ }),

/***/ "./lib/polyface/PolyfaceClip.js":
/*!**************************************!*\
  !*** ./lib/polyface/PolyfaceClip.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const ClipPlane_1 = __webpack_require__(/*! ../clipping/ClipPlane */ "./lib/clipping/ClipPlane.js");
const ConvexClipPlaneSet_1 = __webpack_require__(/*! ../clipping/ConvexClipPlaneSet */ "./lib/clipping/ConvexClipPlaneSet.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const PolyfaceBuilder_1 = __webpack_require__(/*! ./PolyfaceBuilder */ "./lib/polyface/PolyfaceBuilder.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const ChainMerge_1 = __webpack_require__(/*! ../topology/ChainMerge */ "./lib/topology/ChainMerge.js");
const SweepContour_1 = __webpack_require__(/*! ../solid/SweepContour */ "./lib/solid/SweepContour.js");
const PolygonOps_1 = __webpack_require__(/*! ../geometry3d/PolygonOps */ "./lib/geometry3d/PolygonOps.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const PolyfaceQuery_1 = __webpack_require__(/*! ./PolyfaceQuery */ "./lib/polyface/PolyfaceQuery.js");
const RangeSearch_1 = __webpack_require__(/*! ./multiclip/RangeSearch */ "./lib/polyface/multiclip/RangeSearch.js");
/** PolyfaceClip is a static class gathering operations using Polyfaces and clippers.
 * @public
 */
class PolyfaceClip {
    /** Clip each facet of polyface to the ClipPlane.
     * * Return all surviving clip as a new mesh.
     * * WARNING: The new mesh is "points only".
     */
    static clipPolyfaceClipPlaneWithClosureFace(polyface, clipper, insideClip = true, buildClosureFace = true) {
        const visitor = polyface.createVisitor(0);
        const builder = PolyfaceBuilder_1.PolyfaceBuilder.create();
        const chainContext = ChainMerge_1.ChainMergeContext.create();
        const work = new GrowableXYZArray_1.GrowableXYZArray(10);
        const point0 = Point3dVector3d_1.Point3d.create();
        const point1 = Point3dVector3d_1.Point3d.create();
        for (visitor.reset(); visitor.moveToNextFacet();) {
            clipper.clipConvexPolygonInPlace(visitor.point, work, insideClip);
            if (visitor.point.length > 2)
                builder.addPolygonGrowableXYZArray(visitor.point);
            this.collectEdgesOnPlane(visitor.point, clipper, chainContext, point0, point1);
        }
        // SweepContour is your friend .. but maybe it doesn't do holes and multi-loops yet?
        if (buildClosureFace) {
            const outwardNormal = clipper.getPlane3d().getNormalRef().scale(-1.0);
            chainContext.clusterAndMergeVerticesXYZ();
            const loops = chainContext.collectMaximalGrowableXYZArrays();
            PolygonOps_1.PolygonOps.orientLoopsCCWForOutwardNormalInPlace(loops, outwardNormal);
            const contour = SweepContour_1.SweepContour.createForPolygon(loops, outwardNormal);
            if (contour !== undefined) {
                contour.emitFacets(builder, insideClip);
            }
        }
        return builder.claimPolyface(true);
    }
    /** Clip each facet of polyface to the ClipPlane.
     * * Return all surviving clip as a new mesh.
     * * WARNING: The new mesh is "points only".
     */
    static clipPolyfaceClipPlane(polyface, clipper, insideClip = true) {
        return this.clipPolyfaceClipPlaneWithClosureFace(polyface, clipper, insideClip, false);
    }
    /** Clip each facet of polyface to the ClipPlane.
     * * Return surviving clip as a new mesh.
     * * WARNING: The new mesh is "points only".
     */
    static clipPolyfaceConvexClipPlaneSet(polyface, clipper) {
        const visitor = polyface.createVisitor(0);
        const builder = PolyfaceBuilder_1.PolyfaceBuilder.create();
        const work = new GrowableXYZArray_1.GrowableXYZArray(10);
        for (visitor.reset(); visitor.moveToNextFacet();) {
            clipper.clipConvexPolygonInPlace(visitor.point, work);
            if (visitor.point.length > 2)
                builder.addPolygonGrowableXYZArray(visitor.point);
        }
        return builder.claimPolyface(true);
    }
    /** Clip each facet of polyface to the ClipPlane or ConvexClipPlaneSet
     * * This method parses  the variant input types and calls a more specific method.
     * * WARNING: The new mesh is "points only".
     */
    static clipPolyface(polyface, clipper) {
        if (clipper instanceof ClipPlane_1.ClipPlane)
            return this.clipPolyfaceClipPlane(polyface, clipper);
        if (clipper instanceof ConvexClipPlaneSet_1.ConvexClipPlaneSet)
            return this.clipPolyfaceConvexClipPlaneSet(polyface, clipper);
        // (The if tests exhaust the type space -- this line is unreachable.)
        return undefined;
    }
    /** Find consecutive points around a polygon (with implied closure edge) that are ON a plane
     * @param points array of points around polygon.  Closure edge is implied.
     * @param chainContext context receiving edges
     * @param point0 work point
     * @param point1 work point
    */
    static collectEdgesOnPlane(points, clipper, chainContext, point0, point1) {
        const n = points.length;
        if (n > 1) {
            points.getPoint3dAtUncheckedPointIndex(n - 1, point0);
            for (let i = 0; i < n; i++) {
                points.getPoint3dAtUncheckedPointIndex(i, point1);
                if (clipper.isPointOn(point0) && clipper.isPointOn(point1))
                    chainContext.addSegment(point0, point1);
                point0.setFromPoint3d(point1);
            }
        }
    }
    /** Intersect each facet with the clip plane. (Producing intersection edges.)
     * * Return all edges  chained as array of LineString3d.
     */
    static sectionPolyfaceClipPlane(polyface, clipper) {
        const chainContext = ChainMerge_1.ChainMergeContext.create();
        const visitor = polyface.createVisitor(0);
        const work = new GrowableXYZArray_1.GrowableXYZArray(10);
        const point0 = Point3dVector3d_1.Point3d.create();
        const point1 = Point3dVector3d_1.Point3d.create();
        for (visitor.reset(); visitor.moveToNextFacet();) {
            clipper.clipConvexPolygonInPlace(visitor.point, work, true);
            this.collectEdgesOnPlane(visitor.point, clipper, chainContext, point0, point1);
        }
        chainContext.clusterAndMergeVerticesXYZ();
        return chainContext.collectMaximalChains();
    }
    /**
     * * Split facets of mesh "A" into parts that are
     *     * under mesh "B"
     *     * over mesh "B"
     * * both meshes are represented by visitors rather than the meshes themselves
     *     * If the data in-hand is a mesh, call with `mesh.createVisitor`
     * * The respective clip parts are fed to caller-supplied builders.
     *    * Caller may set either or both builders to toggle facet order (e.g. toggle the lower facets to make them "point down" in cut-fill application)
     *    * This step is commonly one-half of "cut fill".
     *       * A "cut fill" wrapper will call this twice with the visitor and builder roles reversed.
     * * Both polyfaces are assumed convex with CCW orientation viewed from above.
     * @param visitorA iterator over polyface to be split.
     * @param visitorB iterator over polyface that acts as a splitter
     * @param orientUnderMeshDownward if true, the "meshAUnderB" output is oriented with its normals reversed so it can act as the bottom side of a cut-fill pair.
     */
    static clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(visitorA, visitorB, builderAUnderB, builderAOverB) {
        const rangeDataA = PolyfaceQuery_1.PolyfaceQuery.collectRangeLengthData(visitorA);
        const searchA = RangeSearch_1.RangeSearch.create2dSearcherForRangeLengthData(rangeDataA);
        if (!searchA)
            return;
        const range = Range_1.Range3d.create();
        for (visitorA.reset(); visitorA.moveToNextFacet();) {
            visitorA.point.setRange(range);
            searchA.addRange(range, visitorA.currentReadIndex());
        }
        const xyClip = new GrowableXYZArray_1.GrowableXYZArray(10);
        const workArray = new GrowableXYZArray_1.GrowableXYZArray(10);
        const xyFrustum = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createEmpty();
        const below = new GrowableXYZArray_1.GrowableXYZArray(10);
        const above = new GrowableXYZArray_1.GrowableXYZArray(10);
        const planeOfFacet = ClipPlane_1.ClipPlane.createNormalAndPointXYZXYZ(0, 0, 1, 0, 0, 0);
        const altitudeRange = Range_1.Range1d.createNull();
        for (visitorB.reset(); visitorB.moveToNextFacet();) {
            visitorB.point.setRange(range);
            ConvexClipPlaneSet_1.ConvexClipPlaneSet.setPlaneAndXYLoopCCW(visitorB.point, planeOfFacet, xyFrustum);
            searchA.searchRange2d(range, (_rangeA, readIndexA) => {
                visitorA.moveToReadIndex(readIndexA);
                xyFrustum.polygonClip(visitorA.point, xyClip, workArray);
                // builderAOverB.addPolygonGrowableXYZArray(xyClip);
                if (xyClip.length > 0) {
                    // planeOfFacet.convexPolygonSplitInsideOutsideGrowableArrays(xyClip, below, above, altitudeRange);
                    PolygonOps_1.IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(planeOfFacet, xyClip, below, above, altitudeRange);
                    if (below.length > 0 && builderAUnderB)
                        builderAUnderB.addPolygonGrowableXYZArray(below);
                    if (above.length > 0 && builderAOverB)
                        builderAOverB.addPolygonGrowableXYZArray(above);
                }
                return true;
            });
        }
    }
    /**
     * * Split facets into vertically overlapping sections
     * * both meshes are represented by visitors rather than the meshes themselves
     *     * If the data in-hand is a mesh, call with `mesh.createVisitor`
     * * The respective clip parts are returned as separate meshes.
     *    * Caller may set either or both builders to toggle facet order (e.g. toggle the lower facets to make them "point down" in cut-fill application)
     * * Both polyfaces are assumed convex with CCW orientation viewed from above.
     * * Each output contains some facets from meshA and some from meshB:
     *    * meshAUnderB -- areas where meshA is underneath mesh B.
     *        * If A is "design surface" and B is existing DTM, this is "cut" volume
     *    * meshAOverB  -- areas where meshB is over meshB.
     *        * If A is "design surface" and B is existing DTM, this is "fill" volume
     *
     * @param visitorA iterator over polyface to be split.
     * @param visitorB iterator over polyface that acts as a splitter
     * @param orientUnderMeshDownward if true, the "meshAUnderB" output is oriented with its normals reversed so it can act as the bottom side of a cut-fill pair.
     */
    static computeCutFill(meshA, meshB) {
        const visitorA = meshA.createVisitor();
        const visitorB = meshB.createVisitor();
        const builderAUnderB = PolyfaceBuilder_1.PolyfaceBuilder.create();
        const builderAOverB = PolyfaceBuilder_1.PolyfaceBuilder.create();
        builderAUnderB.toggleReversedFacetFlag();
        this.clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(visitorA, visitorB, builderAUnderB, builderAOverB);
        builderAUnderB.toggleReversedFacetFlag();
        builderAOverB.toggleReversedFacetFlag();
        this.clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(visitorB, visitorA, builderAOverB, builderAUnderB);
        return {
            meshAUnderB: builderAUnderB.claimPolyface(),
            meshAOverB: builderAOverB.claimPolyface(),
        };
    }
}
exports.PolyfaceClip = PolyfaceClip;


/***/ }),

/***/ "./lib/polyface/PolyfaceData.js":
/*!**************************************!*\
  !*** ./lib/polyface/PolyfaceData.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const ClusterableArray_1 = __webpack_require__(/*! ../numerics/ClusterableArray */ "./lib/numerics/ClusterableArray.js");
const AuxData_1 = __webpack_require__(/*! ./AuxData */ "./lib/polyface/AuxData.js");
const GrowableXYArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYArray */ "./lib/geometry3d/GrowableXYArray.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
/**
 * PolyfaceData carries data arrays for point, normal, param, color and their indices.
 *
 * * IndexedPolyface carries a PolyfaceData as a member. (NOT as a base class -- it already has GeometryQuery as base)
 * * IndexedPolyfaceVisitor uses PolyfaceData as a base class.
 * @public
 */
class PolyfaceData {
    /** Constructor for facets.  The various params control whether respective arrays are to be allocated. */
    constructor(needNormals = false, needParams = false, needColors = false, twoSided = false) {
        this.point = new GrowableXYZArray_1.GrowableXYZArray();
        this.pointIndex = [];
        this.edgeVisible = [];
        this.face = [];
        if (needNormals) {
            this.normal = new GrowableXYZArray_1.GrowableXYZArray();
            this.normalIndex = [];
        }
        if (needParams) {
            this.param = new GrowableXYArray_1.GrowableXYArray();
            this.paramIndex = [];
        }
        if (needColors) {
            this.color = [];
            this.colorIndex = [];
        }
        this._twoSided = twoSided;
    }
    /** boolean tag indicating if the facets are viewable from the back */
    get twoSided() { return this._twoSided; }
    /** boolean tag indicating if the facets are viewable from the back */
    set twoSided(value) { this._twoSided = value; }
    /** Return a depp clone. */
    clone() {
        const result = new PolyfaceData();
        result.point = this.point.clone();
        result.pointIndex = this.pointIndex.slice();
        result.edgeVisible = this.edgeVisible.slice();
        result.face = this.face.slice();
        result.twoSided = this.twoSided;
        if (this.normal)
            result.normal = this.normal.clone();
        if (this.param)
            result.param = this.param.clone();
        if (this.color)
            result.color = this.color.slice();
        if (this.normalIndex)
            result.normalIndex = this.normalIndex.slice();
        if (this.paramIndex)
            result.paramIndex = this.paramIndex.slice();
        if (this.colorIndex)
            result.colorIndex = this.colorIndex.slice();
        if (this.auxData)
            result.auxData = this.auxData.clone();
        return result;
    }
    /** Test for equal indices and nearly equal coordinates */
    isAlmostEqual(other) {
        if (!GrowableXYZArray_1.GrowableXYZArray.isAlmostEqual(this.point, other.point))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.pointIndex, other.pointIndex))
            return false;
        if (!GrowableXYZArray_1.GrowableXYZArray.isAlmostEqual(this.normal, other.normal))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.normalIndex, other.normalIndex))
            return false;
        if (!GrowableXYArray_1.GrowableXYArray.isAlmostEqual(this.param, other.param))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.paramIndex, other.paramIndex))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.color, other.color))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.colorIndex, other.colorIndex))
            return false;
        if (!PointHelpers_1.NumberArray.isExactEqual(this.edgeVisible, other.edgeVisible))
            return false;
        if (!AuxData_1.PolyfaceAuxData.isAlmostEqual(this.auxData, other.auxData))
            return false;
        return true;
    }
    /** Ask if normals are required in this mesh. */
    get requireNormals() { return undefined !== this.normal; }
    /** Get the point count */
    get pointCount() { return this.point.length; }
    /** Get the normal count */
    get normalCount() { return this.normal ? this.normal.length : 0; }
    /** Get the param count */
    get paramCount() { return this.param ? this.param.length : 0; }
    /** Get the color count */
    get colorCount() { return this.color ? this.color.length : 0; }
    /** Get the index count.  Note that there is one count, and all index arrays (point, normal, param, color) must match */
    get indexCount() { return this.pointIndex.length; } // ALWAYS INDEXED ... all index vectors must have same length.
    /** Get the number of faces.
     * * Note that a "face" is not a facet.
     * * A "face" is a subset of facets grouped for application purposes.
     */
    get faceCount() { return this.face.length; }
    /** return indexed point. This is a copy of the coordinates, not a reference. */
    getPoint(i) { return this.point.getPoint3dAtCheckedPointIndex(i); }
    /** return indexed normal. This is the COPY to the normal, not a reference. */
    getNormal(i) { return this.normal ? this.normal.getVector3dAtCheckedVectorIndex(i) : undefined; }
    /** return indexed param. This is the COPY of the coordinates, not a reference. */
    getParam(i) { return this.param ? this.param.getPoint2dAtCheckedPointIndex(i) : undefined; }
    /** return indexed color */
    getColor(i) { return this.color ? this.color[i] : 0; }
    /** return indexed visibility */
    getEdgeVisible(i) { return this.edgeVisible[i]; }
    /** Copy the contents (not pointer) of point[i] into dest. */
    copyPointTo(i, dest) { this.point.getPoint3dAtUncheckedPointIndex(i, dest); }
    /** Copy the contents (not pointer) of normal[i] into dest. */
    copyNormalTo(i, dest) { if (this.normal)
        this.normal.getVector3dAtCheckedVectorIndex(i, dest); }
    /** Copy the contents (not pointer) of param[i] into dest. */
    copyParamTo(i, dest) { if (this.param)
        this.param.getPoint2dAtCheckedPointIndex(i, dest); }
    /** test if normal at a specified index matches uv */
    isAlmostEqualParamIndexUV(index, u, v) {
        if (this.param !== undefined && index >= 0 && index < this.param.length)
            return Geometry_1.Geometry.isSameCoordinate(u, this.param.getXAtUncheckedPointIndex(index))
                && Geometry_1.Geometry.isSameCoordinate(v, this.param.getYAtUncheckedPointIndex(index));
        return false;
    }
    /**
     * * Copy data from other to this.
     * * This is the essence of transferring coordinates spread throughout a large polyface into a visitor's single facet.
     * * "other" is the large polyface
     * * "this" is the visitor
     * * does NOT copy face data - visitors reference the FacetFaceData array for the whole polyface!!
     * @param other polyface data being mined.
     * @param index0 start index in other's index arrays
     * @param index1 end index (one beyond last data accessed0 in other's index arrays
     * @param numWrap number of points to replicate as wraparound.
     */
    gatherIndexedData(other, index0, index1, numWrap) {
        const numEdge = index1 - index0;
        const numTotal = numEdge + numWrap;
        this.resizeAllDataArrays(numTotal);
        // copy wrapped points
        for (let i = 0; i < numEdge; i++)
            this.point.transferFromGrowableXYZArray(i, other.point, other.pointIndex[index0 + i]);
        for (let i = 0; i < numWrap; i++)
            this.point.transferFromGrowableXYZArray(numEdge + i, this.point, i);
        // copy wrapped pointIndex
        for (let i = 0; i < numEdge; i++)
            this.pointIndex[i] = other.pointIndex[index0 + i];
        for (let i = 0; i < numWrap; i++)
            this.pointIndex[numEdge + i] = this.pointIndex[i];
        // copy wrapped edge visibility
        for (let i = 0; i < numEdge; i++)
            this.edgeVisible[i] = other.edgeVisible[index0 + i];
        for (let i = 0; i < numWrap; i++)
            this.edgeVisible[numEdge + i] = this.edgeVisible[i];
        if (this.normal && this.normalIndex && other.normal && other.normalIndex) {
            for (let i = 0; i < numEdge; i++)
                this.normal.transferFromGrowableXYZArray(i, other.normal, other.normalIndex[index0 + i]);
            for (let i = 0; i < numWrap; i++)
                this.normal.transferFromGrowableXYZArray(numEdge + i, this.normal, i);
            for (let i = 0; i < numEdge; i++)
                this.normalIndex[i] = other.normalIndex[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.normalIndex[numEdge + i] = this.normalIndex[i];
        }
        if (this.param && this.paramIndex && other.param && other.paramIndex) {
            for (let i = 0; i < numEdge; i++)
                this.param.transferFromGrowableXYArray(i, other.param, other.paramIndex[index0 + i]);
            for (let i = 0; i < numWrap; i++)
                this.param.transferFromGrowableXYArray(numEdge + i, this.param, i);
            for (let i = 0; i < numEdge; i++)
                this.paramIndex[i] = other.paramIndex[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.paramIndex[numEdge + i] = this.paramIndex[i];
        }
        if (this.color && this.colorIndex && other.color && other.colorIndex) {
            for (let i = 0; i < numEdge; i++)
                this.color[i] = other.color[other.colorIndex[index0 + i]];
            for (let i = 0; i < numWrap; i++)
                this.color[numEdge + i] = this.color[i];
            for (let i = 0; i < numEdge; i++)
                this.colorIndex[i] = other.colorIndex[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.colorIndex[numEdge + i] = this.colorIndex[i];
        }
        if (this.auxData && other.auxData && this.auxData.channels.length === other.auxData.channels.length) {
            for (let iChannel = 0; iChannel < this.auxData.channels.length; iChannel++) {
                const thisChannel = this.auxData.channels[iChannel];
                const otherChannel = other.auxData.channels[iChannel];
                const blockSize = thisChannel.entriesPerValue;
                if (thisChannel.data.length === otherChannel.data.length) {
                    for (let iData = 0; iData < thisChannel.data.length; iData++) {
                        const thisData = thisChannel.data[iData];
                        const otherData = otherChannel.data[iData];
                        for (let i = 0; i < numEdge; i++)
                            thisData.copyValues(otherData, i, index0 + i, blockSize);
                        for (let i = 0; i < numWrap; i++)
                            thisData.copyValues(thisData, numEdge + i, i, blockSize);
                    }
                }
            }
            for (let i = 0; i < numEdge; i++)
                this.auxData.indices[i] = other.auxData.indices[index0 + i];
            for (let i = 0; i < numWrap; i++)
                this.auxData.indices[numEdge + i] = this.auxData.indices[i];
        }
    }
    static trimArray(data, length) { if (data && length < data.length)
        data.length = length; }
    /** Trim all index arrays to stated length.
     * * This is called by PolyfaceBuilder to clean up after an aborted construction sequence.
     */
    trimAllIndexArrays(length) {
        PolyfaceData.trimArray(this.pointIndex, length);
        PolyfaceData.trimArray(this.paramIndex, length);
        PolyfaceData.trimArray(this.normalIndex, length);
        PolyfaceData.trimArray(this.colorIndex, length);
        PolyfaceData.trimArray(this.edgeVisible, length);
        if (this.auxData) {
            PolyfaceData.trimArray(this.auxData.indices, length);
            for (const channel of this.auxData.channels) {
                for (const data of channel.data)
                    PolyfaceData.trimArray(data.values, channel.entriesPerValue * length);
            }
        }
    }
    /** Resize all data arrays to specified length */
    resizeAllDataArrays(length) {
        if (length > this.point.length) {
            while (this.point.length < length)
                this.point.push(Point3dVector3d_1.Point3d.create());
            while (this.pointIndex.length < length)
                this.pointIndex.push(-1);
            while (this.edgeVisible.length < length)
                this.edgeVisible.push(false);
            if (this.normal)
                while (this.normal.length < length)
                    this.normal.push(Point3dVector3d_1.Vector3d.create());
            if (this.param)
                while (this.param.length < length)
                    this.param.push(Point2dVector2d_1.Point2d.create());
            if (this.color)
                while (this.color.length < length)
                    this.color.push(0);
            if (this.auxData) {
                for (const channel of this.auxData.channels) {
                    for (const channelData of channel.data) {
                        while (channelData.values.length < length * channel.entriesPerValue)
                            channelData.values.push(0);
                    }
                }
            }
        }
        else if (length < this.point.length) {
            this.point.resize(length);
            this.edgeVisible.length = length;
            this.pointIndex.length = length;
            if (this.normal)
                this.normal.resize(length);
            if (this.param)
                this.param.resize(length);
            if (this.color)
                this.color.length = length;
            if (this.auxData) {
                for (const channel of this.auxData.channels) {
                    for (const channelData of channel.data) {
                        channelData.values.length = length * channel.entriesPerValue;
                    }
                }
            }
        }
    }
    /** Return the range of the point array (optionally transformed) */
    range(result, transform) {
        result = result ? result : Range_1.Range3d.createNull();
        result.extendArray(this.point, transform);
        return result;
    }
    /** reverse indices facet-by-facet, with the given facetStartIndex array delimiting faces.
     *
     * * facetStartIndex[0] == 0 always -- start of facet zero.
     * * facet k has indices from facetStartIndex[k] <= i < facetStartIndex[k+1]
     * * hence for "internal" k, facetStartIndex[k] is both the upper limit of facet k-1 and the start of facet k.
     * *
     */
    reverseIndices(facetStartIndex) {
        if (facetStartIndex && PolyfaceData.isValidFacetStartIndexArray(facetStartIndex)) {
            PolyfaceData.reverseIndices(facetStartIndex, this.pointIndex, true);
            PolyfaceData.reverseIndices(facetStartIndex, this.normalIndex, true);
            PolyfaceData.reverseIndices(facetStartIndex, this.paramIndex, true);
            PolyfaceData.reverseIndices(facetStartIndex, this.colorIndex, true);
            PolyfaceData.reverseIndices(facetStartIndex, this.edgeVisible, false);
        }
    }
    /** Scale all the normals by -1 */
    reverseNormals() {
        if (this.normal)
            this.normal.scaleInPlace(-1.0);
    }
    /** Apply `transform` to point and normal arrays.
     * * IMPORTANT This base class is just a data carrier.  It does not know if the index order and normal directions have special meaning.
     * * i.e. caller must separately reverse index order and normal direction if needed.
     */
    tryTransformInPlace(transform) {
        this.point.multiplyTransformInPlace(transform);
        if (this.normal && !transform.matrix.isIdentity)
            this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(transform.matrix);
        return true;
    }
    /**
     * * Search for duplication of coordinates within points, normals, and params.
     * * compress the coordinate arrays.
     * * revise all indexing for the relocated coordinates
     */
    compress() {
        const packedData = ClusterableArray_1.ClusterableArray.clusterGrowablePoint3dArray(this.point);
        this.point = packedData.growablePackedPoints;
        packedData.updateIndices(this.pointIndex);
        //    if (this.paramIndex)  // Tracking uv params
        //      packedData.updateIndices(this.paramIndex);
        //    if (this.normalIndex) // Tracking normals
        //      packedData.updateIndices(this.normalIndex);
    }
    /**
     * Test if facetStartIndex is (minimally!) valid:
     * * length must be nonzero (recall that for "no facets" the facetStartIndexArray still must contain a 0)
     * * Each entry must be strictly smaller than the one that follows.
     * @param facetStartIndex array of facetStart data.  facet `i` has indices at `facetsStartIndex[i]` to (one before) `facetStartIndex[i+1]`
     */
    static isValidFacetStartIndexArray(facetStartIndex) {
        // facetStartIndex for empty facets has a single entry "0" -- empty array is not allowed
        if (facetStartIndex.length === 0)
            return false;
        for (let i = 0; i + 1 < facetStartIndex.length; i++)
            if (facetStartIndex[i] >= facetStartIndex[i + 1])
                return false;
        return true;
    }
    /** Reverse data in facet indexing arrays.
     * * parameterized over type T so non-number data -- e.g. boolean visibility flags -- can be reversed.
     */
    static reverseIndices(facetStartIndex, indices, preserveStart) {
        if (!indices || indices.length === 0)
            return true; // empty case
        if (indices.length > 0) {
            if (facetStartIndex[facetStartIndex.length - 1] === indices.length) {
                for (let i = 0; i + 1 < facetStartIndex.length; i++) {
                    let index0 = facetStartIndex[i];
                    let index1 = facetStartIndex[i + 1];
                    if (preserveStart) {
                        // leave [index0] as is so reversed facet starts at same vertex
                        while (index1 > index0 + 2) {
                            index1--;
                            index0++;
                            const a = indices[index0];
                            indices[index0] = indices[index1];
                            indices[index1] = a;
                        }
                    }
                    else {
                        // reverse all
                        while (index1 > index0 + 1) {
                            index1--;
                            const a = indices[index0];
                            indices[index0] = indices[index1];
                            indices[index1] = a;
                            index0++;
                        }
                    }
                }
                return true;
            }
        }
        return false;
    }
}
exports.PolyfaceData = PolyfaceData;
// <ul
// <li>optional arrays (normal, uv, color) must be indicated at constructor time.
// <li>all arrays are (independently) indexed.
// <li>with regret, the point, param, normal, and color arrays are exposed publicly.
// <li>getX methods are "trusting" -- no bounds check
// <li>getX methods return references to X.
// <li> EXCEPT -- for optional arrays, the return 000.
// <li>copyX methods move data to caller-supplied result..
// </ul>
/** Relative tolerance used in tests for planar facets
 * @internal
 */
PolyfaceData.planarityLocalRelTol = 1.0e-13;


/***/ }),

/***/ "./lib/polyface/PolyfaceQuery.js":
/*!***************************************!*\
  !*** ./lib/polyface/PolyfaceQuery.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Polyface */
// import { Point2d } from "./Geometry2d";
/* tslint:disable:variable-name jsdoc-format no-empty*/
// import { Point3d, Vector3d, Point2d } from "./PointVector";
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Polyface_1 = __webpack_require__(/*! ./Polyface */ "./lib/polyface/Polyface.js");
const Matrix4d_1 = __webpack_require__(/*! ../geometry4d/Matrix4d */ "./lib/geometry4d/Matrix4d.js");
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const PolygonOps_1 = __webpack_require__(/*! ../geometry3d/PolygonOps */ "./lib/geometry3d/PolygonOps.js");
const MomentData_1 = __webpack_require__(/*! ../geometry4d/MomentData */ "./lib/geometry4d/MomentData.js");
const IndexedEdgeMatcher_1 = __webpack_require__(/*! ./IndexedEdgeMatcher */ "./lib/polyface/IndexedEdgeMatcher.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const PolyfaceBuilder_1 = __webpack_require__(/*! ./PolyfaceBuilder */ "./lib/polyface/PolyfaceBuilder.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const LineSegment3d_1 = __webpack_require__(/*! ../curve/LineSegment3d */ "./lib/curve/LineSegment3d.js");
const ChainMerge_1 = __webpack_require__(/*! ../topology/ChainMerge */ "./lib/topology/ChainMerge.js");
const UnionFind_1 = __webpack_require__(/*! ../numerics/UnionFind */ "./lib/numerics/UnionFind.js");
const StrokeOptions_1 = __webpack_require__(/*! ../curve/StrokeOptions */ "./lib/curve/StrokeOptions.js");
const RangeLengthData_1 = __webpack_require__(/*! ./RangeLengthData */ "./lib/polyface/RangeLengthData.js");
const XYPointBuckets_1 = __webpack_require__(/*! ./multiclip/XYPointBuckets */ "./lib/polyface/multiclip/XYPointBuckets.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
/** PolyfaceQuery is a static class whose methods implement queries on a polyface or polyface visitor provided as a parameter to each method.
 * @public
 */
class PolyfaceQuery {
    /** copy the points from a visitor into a Linestring3d in a Loop object */
    static visitorToLoop(visitor) {
        const ls = LineString3d_1.LineString3d.createPoints(visitor.point.getPoint3dArray());
        return Loop_1.Loop.create(ls);
    }
    /** Create a linestring loop for each facet of the polyface. */
    static indexedPolyfaceToLoops(polyface) {
        const result = CurveCollection_1.BagOfCurves.create();
        const visitor = polyface.createVisitor(1);
        while (visitor.moveToNextFacet()) {
            const loop = PolyfaceQuery.visitorToLoop(visitor);
            result.tryAddChild(loop);
        }
        return result;
    }
    /** Return the sum of all facets areas. */
    static sumFacetAreas(source) {
        let s = 0;
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.sumFacetAreas(source.createVisitor(1));
        const visitor = source;
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            s += PolygonOps_1.PolygonOps.sumTriangleAreas(visitor.point.getPoint3dArray());
        }
        return s;
    }
    /** sum volumes of tetrahedra from origin to all facets.
     * * if origin is omitted, the first point encountered (by the visitor) is used as origin.
     * * If the mesh is closed, this sum is the volume.
     * * If the mesh is not closed, this sum is the volume of a mesh with various additional facets
     * from the origin to facets.
    */
    static sumTetrahedralVolumes(source, origin) {
        let s = 0;
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.sumTetrahedralVolumes(source.createVisitor(0), origin);
        let myOrigin = origin;
        const visitor = source;
        const facetOrigin = Point3dVector3d_1.Point3d.create();
        const targetA = Point3dVector3d_1.Point3d.create();
        const targetB = Point3dVector3d_1.Point3d.create();
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            if (myOrigin === undefined)
                myOrigin = visitor.point.getPoint3dAtUncheckedPointIndex(0);
            visitor.point.getPoint3dAtUncheckedPointIndex(0, facetOrigin);
            for (let i = 1; i + 1 < visitor.point.length; i++) {
                visitor.point.getPoint3dAtUncheckedPointIndex(i, targetA);
                visitor.point.getPoint3dAtUncheckedPointIndex(i + 1, targetB);
                s += myOrigin.tripleProductToPoints(facetOrigin, targetA, targetB);
            }
        }
        return s / 6.0;
    }
    /** sum (signed) volumes between facets and a plane.
     * Return a structure with multiple sums:
     * * volume = the sum of (signed) volumes between facets and the plane.
     * * positiveAreaMomentData, negativeProjectedFacetAreaMoments = moment data with centroid, area, and second moments with respect to the centroid.
     *
    */
    static sumVolumeBetweenFacetsAndPlane(source, plane) {
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.sumVolumeBetweenFacetsAndPlane(source.createVisitor(0), plane);
        const visitor = source;
        const facetOrigin = Point3dVector3d_1.Point3d.create();
        const targetA = Point3dVector3d_1.Point3d.create();
        const targetB = Point3dVector3d_1.Point3d.create();
        const triangleNormal = Point3dVector3d_1.Vector3d.create();
        const planeNormal = plane.getNormalRef();
        let h0, hA, hB;
        let signedVolumeSum = 0.0;
        let signedTriangleArea;
        let singleFacetArea;
        const positiveAreaMomentSums = MomentData_1.MomentData.create(undefined, true);
        const negativeAreaMomentSums = MomentData_1.MomentData.create(undefined, true);
        const singleFacetProducts = Matrix4d_1.Matrix4d.createZero();
        const projectToPlane = plane.getProjectionToPlane();
        visitor.reset();
        // For each facet ..
        //   Form triangles from facet origin to each far edge.
        //   Sum signed area and volume contributions
        // each "projectedArea" contribution is twice the area of a triangle.
        // each volume contribution is  3 times the actual volume -- (1/3) of the altitude sums was the centroid altitude.
        while (visitor.moveToNextFacet()) {
            visitor.point.getPoint3dAtUncheckedPointIndex(0, facetOrigin);
            h0 = plane.altitude(facetOrigin);
            singleFacetArea = 0;
            // within a single facets, the singleFacetArea sum is accumulated with signs of individual triangles.
            // For a non-convex facet, this can be a mixture of positive and negative areas.
            // The absoluteProjectedAreaSum contribution is forced positive after the sum for the facet.
            for (let i = 1; i + 1 < visitor.point.length; i++) {
                visitor.point.getPoint3dAtUncheckedPointIndex(i, targetA);
                visitor.point.getPoint3dAtUncheckedPointIndex(i + 1, targetB);
                facetOrigin.crossProductToPoints(targetA, targetB, triangleNormal);
                hA = plane.altitude(targetA);
                hB = plane.altitude(targetB);
                signedTriangleArea = planeNormal.dotProduct(triangleNormal);
                singleFacetArea += signedTriangleArea;
                signedVolumeSum += signedTriangleArea * (h0 + hA + hB);
            }
            singleFacetProducts.setZero();
            visitor.point.multiplyTransformInPlace(projectToPlane);
            PolygonOps_1.PolygonOps.addSecondMomentAreaProducts(visitor.point, facetOrigin, singleFacetProducts);
            if (singleFacetArea > 0) {
                positiveAreaMomentSums.accumulateProductsFromOrigin(facetOrigin, singleFacetProducts, 1.0);
            }
            else {
                negativeAreaMomentSums.accumulateProductsFromOrigin(facetOrigin, singleFacetProducts, 1.0);
            }
        }
        positiveAreaMomentSums.shiftOriginAndSumsToCentroidOfSums();
        negativeAreaMomentSums.shiftOriginAndSumsToCentroidOfSums();
        const positiveAreaMoments = MomentData_1.MomentData.inertiaProductsToPrincipalAxes(positiveAreaMomentSums.origin, positiveAreaMomentSums.sums);
        const negativeAreaMoments = MomentData_1.MomentData.inertiaProductsToPrincipalAxes(negativeAreaMomentSums.origin, negativeAreaMomentSums.sums);
        return {
            volume: signedVolumeSum / 6.0,
            positiveProjectedFacetAreaMoments: positiveAreaMoments,
            negativeProjectedFacetAreaMoments: negativeAreaMoments,
        };
    }
    /** Return the inertia products [xx,xy,xz,xw, yw, etc] integrated over all all facets, as viewed from origin. */
    static sumFacetSecondAreaMomentProducts(source, origin) {
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.sumFacetSecondAreaMomentProducts(source.createVisitor(0), origin);
        const products = Matrix4d_1.Matrix4d.createZero();
        const visitor = source;
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            PolygonOps_1.PolygonOps.addSecondMomentAreaProducts(visitor.point, origin, products);
        }
        return products;
    }
    /** Return the inertia products [xx,xy,xz,xw, yw, etc] integrated over all tetrahedral volumes from origin */
    static sumFacetSecondVolumeMomentProducts(source, origin) {
        if (source instanceof Polyface_1.Polyface)
            return PolyfaceQuery.sumFacetSecondVolumeMomentProducts(source.createVisitor(0), origin);
        const products = Matrix4d_1.Matrix4d.createZero();
        const visitor = source;
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            PolygonOps_1.PolygonOps.addSecondMomentVolumeProducts(visitor.point, origin, products);
        }
        return products;
    }
    /** Compute area moments for the mesh. In the returned MomentData:
     * * origin is the centroid.
     * * localToWorldMap has the origin and principal directions
     * * radiiOfGyration radii for rotation around the x,y,z axes.
     */
    static computePrincipalAreaMoments(source) {
        const origin = source.data.getPoint(0);
        if (!origin)
            return undefined;
        const inertiaProducts = PolyfaceQuery.sumFacetSecondAreaMomentProducts(source, origin);
        return MomentData_1.MomentData.inertiaProductsToPrincipalAxes(origin, inertiaProducts);
    }
    /** Compute area moments for the mesh. In the returned MomentData:
     * * origin is the centroid.
     * * localToWorldMap has the origin and principal directions
     * * radiiOfGyration radii for rotation around the x,y,z axes.
     * * The result is only valid if the mesh is closed.
     * * There is no test for closure.  Use `PolyfaceQuery.isPolyfaceClosedByEdgePairing(polyface)` to test for closure.
     */
    static computePrincipalVolumeMoments(source) {
        const origin = source.data.getPoint(0);
        if (!origin)
            return undefined;
        const inertiaProducts = PolyfaceQuery.sumFacetSecondVolumeMomentProducts(source, origin);
        return MomentData_1.MomentData.inertiaProductsToPrincipalAxes(origin, inertiaProducts);
    }
    /**
     * Test if the facets in `source` occur in perfectly mated pairs, as is required for a closed manifold volume.
     * @param source
     */
    static isPolyfaceClosedByEdgePairing(source) {
        const edges = new IndexedEdgeMatcher_1.IndexedEdgeMatcher();
        const visitor = source.createVisitor(1);
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            const numEdges = visitor.pointCount - 1;
            for (let i = 0; i < numEdges; i++) {
                edges.addEdge(visitor.clientPointIndex(i), visitor.clientPointIndex(i + 1), visitor.currentReadIndex());
            }
        }
        const badClusters = [];
        edges.sortAndCollectClusters(undefined, badClusters, undefined, badClusters);
        return badClusters.length === 0;
    }
    /**
    * Test if the facets in `source` occur in perfectly mated pairs, as is required for a closed manifold volume.
    * If not, extract the boundary edges as lines.
    * @param source
    */
    static boundaryEdges(source, includeDanglers = true, includeMismatch = true, includeNull = true) {
        const edges = new IndexedEdgeMatcher_1.IndexedEdgeMatcher();
        const visitor = source.createVisitor(1);
        visitor.reset();
        while (visitor.moveToNextFacet()) {
            const numEdges = visitor.pointCount - 1;
            for (let i = 0; i < numEdges; i++) {
                edges.addEdge(visitor.clientPointIndex(i), visitor.clientPointIndex(i + 1), visitor.currentReadIndex());
            }
        }
        const bad1 = [];
        const bad2 = [];
        const bad0 = [];
        edges.sortAndCollectClusters(undefined, bad1, bad0, bad2);
        const badList = [];
        if (includeDanglers && bad1.length > 0)
            badList.push(bad1);
        if (includeMismatch && bad2.length > 0)
            badList.push(bad2);
        if (includeNull && bad0.length > 0)
            badList.push(bad0);
        if (badList.length === 0)
            return undefined;
        const result = new CurveCollection_1.BagOfCurves();
        for (const list of badList) {
            for (const e of list) {
                const e1 = e instanceof IndexedEdgeMatcher_1.SortableEdge ? e : e[0];
                const indexA = e1.vertexIndexA;
                const indexB = e1.vertexIndexB;
                const pointA = source.data.getPoint(indexA);
                const pointB = source.data.getPoint(indexB);
                if (pointA && pointB)
                    result.tryAddChild(LineSegment3d_1.LineSegment3d.create(pointA, pointB));
            }
        }
        return result;
    }
    /** Find segments (within the linestring) which project to facets.
     * * Announce each pair of linestring segment and on-facet segment through a callback.
     * * Facets are ASSUMED to be convex and planar.
     */
    static announceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface, announce) {
        const visitor = polyface.createVisitor(0);
        const numLinestringPoints = linestringPoints.length;
        const segmentPoint0 = Point3dVector3d_1.Point3d.create();
        const segmentPoint1 = Point3dVector3d_1.Point3d.create();
        const localSegmentPoint0 = Point3dVector3d_1.Point3d.create();
        const localSegmentPoint1 = Point3dVector3d_1.Point3d.create();
        const clipFractions = Segment1d_1.Segment1d.create(0, 1);
        const localFrame = Transform_1.Transform.createIdentity();
        let frame;
        for (visitor.reset(); visitor.moveToNextFacet();) {
            // For each triangle within the facet ...
            for (let k1 = 1; k1 + 1 < visitor.point.length; k1++) {
                frame = visitor.point.fillLocalXYTriangleFrame(0, k1, k1 + 1, localFrame);
                if (frame) {
                    // For each stroke of the linestring ...
                    for (let i1 = 1; i1 < numLinestringPoints; i1++) {
                        linestringPoints.getPoint3dAtCheckedPointIndex(i1 - 1, segmentPoint0);
                        linestringPoints.getPoint3dAtCheckedPointIndex(i1, segmentPoint1);
                        frame.multiplyInversePoint3d(segmentPoint0, localSegmentPoint0);
                        frame.multiplyInversePoint3d(segmentPoint1, localSegmentPoint1);
                        clipFractions.set(0, 1);
                        /** (x,y,1-x-y) are barycentric coordinates in the triangle !!! */
                        if (clipFractions.clipBy01FunctionValuesPositive(localSegmentPoint0.x, localSegmentPoint1.x)
                            && clipFractions.clipBy01FunctionValuesPositive(localSegmentPoint0.y, localSegmentPoint1.y)
                            && clipFractions.clipBy01FunctionValuesPositive(1 - localSegmentPoint0.x - localSegmentPoint0.y, 1 - localSegmentPoint1.x - localSegmentPoint1.y)) {
                            /* project the local segment point to the plane. */
                            const localClippedPointA = localSegmentPoint0.interpolate(clipFractions.x0, localSegmentPoint1);
                            const localClippedPointB = localSegmentPoint0.interpolate(clipFractions.x1, localSegmentPoint1);
                            const worldClippedPointA = localFrame.multiplyPoint3d(localClippedPointA);
                            const worldClippedPointB = localFrame.multiplyPoint3d(localClippedPointB);
                            const planePointA = localFrame.multiplyXYZ(localClippedPointA.x, localClippedPointA.y, 0.0);
                            const planePointB = localFrame.multiplyXYZ(localClippedPointB.x, localClippedPointB.y, 0.0);
                            const splitParameter = Geometry_1.Geometry.inverseInterpolate01(localSegmentPoint0.z, localSegmentPoint1.z);
                            // emit 1 or 2 panels, oriented so panel normal is always to the left of the line.
                            if (splitParameter !== undefined && splitParameter > clipFractions.x0 && splitParameter < clipFractions.x1) {
                                const piercePointX = segmentPoint0.interpolate(splitParameter, segmentPoint1);
                                const piercePointY = piercePointX.clone(); // so points are distinct for the two triangle announcements.
                                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointA, piercePointX, planePointA], 2, 1);
                                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointB, piercePointY, planePointB], 1, 2);
                            }
                            else if (localSegmentPoint0.z > 0) { // segment is entirely above
                                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointA, worldClippedPointB, planePointB, planePointA], 3, 2);
                            }
                            else // segment is entirely under
                                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointB, worldClippedPointA, planePointA, planePointB], 2, 3);
                        }
                    }
                }
            }
        }
    }
    /** Search the facets for facet subsets that are connected with at least vertex contact.
     * * Return array of arrays of facet indices.
     */
    static partitionFacetIndicesByVertexConnectedComponent(polyface) {
        if (polyface instanceof Polyface_1.Polyface) {
            return this.partitionFacetIndicesByVertexConnectedComponent(polyface.createVisitor(0));
        }
        // The polyface is really a visitor !!!
        const context = new UnionFind_1.UnionFindContext(polyface.clientPolyface().data.point.length);
        for (polyface.reset(); polyface.moveToNextFacet();) {
            const firstVertexIndexOnThisFacet = polyface.pointIndex[0];
            for (const vertexIndex of polyface.pointIndex)
                context.mergeSubsets(firstVertexIndexOnThisFacet, vertexIndex);
        }
        const roots = context.collectRootIndices();
        const facetsInComponent = [];
        const numRoots = roots.length;
        for (let i = 0; i < numRoots; i++) {
            facetsInComponent.push([]);
        }
        for (polyface.reset(); polyface.moveToNextFacet();) {
            const firstVertexIndexOnThisFacet = polyface.pointIndex[0];
            const rootVertexForThisFacet = context.findRoot(firstVertexIndexOnThisFacet);
            for (let rootIndex = 0; rootIndex < numRoots; rootIndex++) {
                if (roots[rootIndex] === rootVertexForThisFacet) {
                    facetsInComponent[rootIndex].push(polyface.currentReadIndex());
                    break;
                }
            }
        }
        return facetsInComponent;
    }
    /** Clone the facets in each partition to a separate polyface.
     *
     */
    static clonePartitions(polyface, partitions) {
        if (polyface instanceof Polyface_1.Polyface) {
            return this.clonePartitions(polyface.createVisitor(0), partitions);
        }
        polyface.setNumWrap(0);
        const polyfaces = [];
        const options = StrokeOptions_1.StrokeOptions.createForFacets();
        options.needNormals = polyface.normal !== undefined;
        options.needParams = polyface.param !== undefined;
        options.needColors = polyface.color !== undefined;
        options.needTwoSided = polyface.twoSided;
        for (const partition of partitions) {
            const builder = PolyfaceBuilder_1.PolyfaceBuilder.create(options);
            polyface.reset();
            for (const facetIndex of partition) {
                polyface.moveToReadIndex(facetIndex);
                builder.addFacetFromVisitor(polyface);
            }
            polyfaces.push(builder.claimPolyface(true));
        }
        return polyfaces;
    }
    /** Search the facets for facet subsets that are connected with at least edge contact.
     * * Return array of arrays of facet indices.
     */
    static partitionFacetIndicesByEdgeConnectedComponent(polyface) {
        if (polyface instanceof Polyface_1.Polyface) {
            return this.partitionFacetIndicesByEdgeConnectedComponent(polyface.createVisitor(0));
        }
        polyface.setNumWrap(1);
        const matcher = new IndexedEdgeMatcher_1.IndexedEdgeMatcher();
        polyface.reset();
        let numFacets = 0;
        while (polyface.moveToNextFacet()) {
            const numEdges = polyface.pointCount - 1;
            numFacets++;
            for (let i = 0; i < numEdges; i++) {
                matcher.addEdge(polyface.clientPointIndex(i), polyface.clientPointIndex(i + 1), polyface.currentReadIndex());
            }
        }
        const allEdges = [];
        matcher.sortAndCollectClusters(allEdges, allEdges, allEdges, allEdges);
        const context = new UnionFind_1.UnionFindContext(numFacets);
        for (const cluster of allEdges) {
            if (cluster instanceof IndexedEdgeMatcher_1.SortableEdge) {
                // this edge does not connect anywhere.  Ignore it!!
            }
            else {
                const edge0 = cluster[0];
                for (let i = 1; i < cluster.length; i++)
                    context.mergeSubsets(edge0.facetIndex, cluster[i].facetIndex);
            }
        }
        const roots = context.collectRootIndices();
        const facetsInComponent = [];
        const numRoots = roots.length;
        for (let i = 0; i < numRoots; i++) {
            facetsInComponent.push([]);
        }
        for (let facetIndex = 0; facetIndex < numFacets; facetIndex++) {
            const rootOfFacet = context.findRoot(facetIndex);
            for (let rootIndex = 0; rootIndex < numRoots; rootIndex++) {
                if (roots[rootIndex] === rootOfFacet) {
                    facetsInComponent[rootIndex].push(facetIndex);
                    break;
                }
            }
        }
        return facetsInComponent;
    }
    /** Find segments (within the linestring) which project to facets.
     * * Assemble each segment pair as a facet in a new polyface
     * * Facets are ASSUMED to be convex and planar.
     */
    static sweepLinestringToFacetsXYreturnSweptFacets(linestringPoints, polyface) {
        const builder = PolyfaceBuilder_1.PolyfaceBuilder.create();
        this.announceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface, (_linestring, _segmentIndex, _polyface, _facetIndex, points) => {
            if (points.length === 4)
                builder.addQuadFacet(points);
            else if (points.length === 3)
                builder.addTriangleFacet(points);
        });
        return builder.claimPolyface(true);
    }
    /** Find segments (within the linestring) which project to facets.
     * * Return collected line segments
     */
    static sweepLinestringToFacetsXYReturnLines(linestringPoints, polyface) {
        const drapeGeometry = [];
        this.announceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface, (_linestring, _segmentIndex, _polyface, _facetIndex, points, indexA, indexB) => {
            drapeGeometry.push(LineSegment3d_1.LineSegment3d.create(points[indexA], points[indexB]));
        });
        return drapeGeometry;
    }
    /** Find segments (within the linestring) which project to facets.
     * * Return chains.
     */
    static sweepLinestringToFacetsXYReturnChains(linestringPoints, polyface) {
        const chainContext = ChainMerge_1.ChainMergeContext.create();
        this.announceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface, (_linestring, _segmentIndex, _polyface, _facetIndex, points, indexA, indexB) => {
            chainContext.addSegment(points[indexA], points[indexB]);
        });
        chainContext.clusterAndMergeVerticesXYZ();
        return chainContext.collectMaximalChains();
    }
    /** Find segments (within the linestring) which project to facets.
     * * Return chains.
     */
    static collectRangeLengthData(polyface) {
        if (polyface instanceof Polyface_1.Polyface) {
            return this.collectRangeLengthData(polyface.createVisitor(0));
        }
        const rangeData = new RangeLengthData_1.RangeLengthData();
        // polyface is a visitor ...
        for (polyface.reset(); polyface.moveToNextFacet();)
            rangeData.accumulateGrowableXYZArrayRange(polyface.point);
        return rangeData;
    }
    /** Clone the facets, inserting vertices (within edges) where points not part of each facet's vertex indices impinge within edges.
     *
     */
    static cloneWithTVertexFixup(polyface) {
        const oldFacetVisitor = polyface.createVisitor(1); // This is to visit the existing facets.
        const newFacetVisitor = polyface.createVisitor(0); // This is to build the new facets.
        const rangeSearcher = XYPointBuckets_1.XYPointBuckets.create(polyface.data.point, 30);
        const builder = PolyfaceBuilder_1.PolyfaceBuilder.create();
        const edgeRange = Range_1.Range3d.createNull();
        const point0 = Point3dVector3d_1.Point3d.create();
        const point1 = Point3dVector3d_1.Point3d.create();
        const spacePoint = Point3dVector3d_1.Point3d.create();
        const segment = LineSegment3d_1.LineSegment3d.create(point0, point1);
        for (oldFacetVisitor.reset(); oldFacetVisitor.moveToNextFacet();) {
            newFacetVisitor.clearArrays();
            for (let i = 0; i + 1 < oldFacetVisitor.point.length; i++) {
                // each base vertex is part of the result ...
                oldFacetVisitor.point.getPoint3dAtUncheckedPointIndex(i, point0);
                oldFacetVisitor.point.getPoint3dAtUncheckedPointIndex(i + 1, point1);
                newFacetVisitor.pushDataFrom(oldFacetVisitor, i);
                edgeRange.setNull();
                LineSegment3d_1.LineSegment3d.create(point0, point1, segment);
                let detailArray;
                edgeRange.extend(point0);
                edgeRange.extend(point1);
                rangeSearcher.announcePointsInRange(edgeRange, (index, _x, _y, _z) => {
                    // x,y,z has x,y within the range of the search ... test for exact on (in full 3d!)
                    polyface.data.point.getPoint3dAtUncheckedPointIndex(index, spacePoint);
                    const detail = segment.closestPoint(spacePoint, false);
                    if (undefined !== detail) {
                        if (detail.fraction >= 0.0 && detail.fraction < 1.0 && !detail.point.isAlmostEqual(point0) && !detail.point.isAlmostEqual(point1)) {
                            if (detailArray === undefined)
                                detailArray = [];
                            detail.a = index;
                            detailArray.push(detail);
                        }
                    }
                    return true;
                });
                if (detailArray !== undefined) {
                    detailArray.sort((a, b) => (a.fraction - b.fraction));
                    for (const d of detailArray) {
                        newFacetVisitor.pushInterpolatedDataFrom(oldFacetVisitor, i, d.fraction, i + 1);
                    }
                }
            }
            builder.addFacetFromGrowableArrays(newFacetVisitor.point, newFacetVisitor.normal, newFacetVisitor.param, newFacetVisitor.color);
        }
        return builder.claimPolyface();
    }
    /** Clone the facets, inserting removing points that are simply within colinear edges.
     *
     */
    static cloneWithColinearEdgeFixup(polyface) {
        const oldFacetVisitor = polyface.createVisitor(2); // This is to visit the existing facets.
        const newFacetVisitor = polyface.createVisitor(0); // This is to build the new facets.
        const builder = PolyfaceBuilder_1.PolyfaceBuilder.create();
        const vector01 = Point3dVector3d_1.Vector3d.create();
        const vector12 = Point3dVector3d_1.Vector3d.create();
        const numPoint = polyface.data.point.length;
        const pointState = new Int32Array(numPoint);
        // FIRST PASS -- in each sector of each facet, determine if the sector has colinear incoming and outgoing vectors.
        //   Mark each point as
        //  0 unvisited
        // -1 incident to a non-colinear sector
        //  n incident to n colinear sectors
        for (oldFacetVisitor.reset(); oldFacetVisitor.moveToNextFacet();) {
            for (let i = 0; i + 2 < oldFacetVisitor.point.length; i++) {
                // each base vertex is part of the result ...
                oldFacetVisitor.point.vectorIndexIndex(i, i + 1, vector01);
                oldFacetVisitor.point.vectorIndexIndex(i + 1, i + 2, vector12);
                const pointIndex = oldFacetVisitor.clientPointIndex(i + 1);
                if (pointState[pointIndex] >= 0) {
                    const theta = vector01.angleTo(vector12);
                    if (theta.isAlmostZero) {
                        pointState[pointIndex]++;
                    }
                    else {
                        pointState[pointIndex] = -1;
                    }
                }
            }
        }
        // SECOND PASS -- make copies, omitting references to points at colinear sectors
        for (oldFacetVisitor.reset(); oldFacetVisitor.moveToNextFacet();) {
            newFacetVisitor.clearArrays();
            for (let i = 0; i + 2 < oldFacetVisitor.point.length; i++) {
                const pointIndex = oldFacetVisitor.clientPointIndex(i);
                if (pointState[pointIndex] < 0) {
                    newFacetVisitor.pushDataFrom(oldFacetVisitor, i);
                }
            }
            if (newFacetVisitor.point.length > 2)
                builder.addFacetFromGrowableArrays(newFacetVisitor.point, newFacetVisitor.normal, newFacetVisitor.param, newFacetVisitor.color);
        }
        return builder.claimPolyface();
    }
}
exports.PolyfaceQuery = PolyfaceQuery;


/***/ }),

/***/ "./lib/polyface/RangeLengthData.js":
/*!*****************************************!*\
  !*** ./lib/polyface/RangeLengthData.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const UsageSums_1 = __webpack_require__(/*! ../numerics/UsageSums */ "./lib/numerics/UsageSums.js");
/**
 * Accumulated data for x,y,z length statistics in ranges.
 * * Usage pattern:
 *   * create a enw RangeLengthData:
 *      * `myData = new RangeLengthData ();`
 *   * announce ranges to be accumulated:
 *     * (many times)  `myData.accumulateRowableXYZArrayRange (points);
 *   * access data in public members:
 *     * `myData.range` -- the composite range.
 *     * `myData.xLength`, `myData.yLength`, `myData.zLength` -- mean, minMax, count, and standardDeviation of range lengths in x,y,z directions.
 * @public
 */
class RangeLengthData {
    constructor() {
        this.range = Range_1.Range3d.createNull();
        this.xSums = new UsageSums_1.UsageSums();
        this.ySums = new UsageSums_1.UsageSums();
        this.zSums = new UsageSums_1.UsageSums();
        this._workRange = Range_1.Range3d.createNull();
    }
    /** Extend the range and length sums by the range of points in an array. */
    accumulateGrowableXYZArrayRange(points) {
        points.setRange(this._workRange);
        this.range.extendRange(this._workRange);
        this.xSums.accumulate(this._workRange.xLength());
        this.ySums.accumulate(this._workRange.yLength());
        this.zSums.accumulate(this._workRange.zLength());
    }
}
exports.RangeLengthData = RangeLengthData;


/***/ }),

/***/ "./lib/polyface/TriangleCandidate.js":
/*!*******************************************!*\
  !*** ./lib/polyface/TriangleCandidate.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const BarycentricTriangle_1 = __webpack_require__(/*! ../geometry3d/BarycentricTriangle */ "./lib/geometry3d/BarycentricTriangle.js");
/** @module Polyface */
/**
 * `TriangleCandidate` is a `BarycentricTriangle` with additional application-specific label data:
 * * `quality` = numeric indicator of quality (e.g. aspect ratio of this triangle or a combination with other triangles)
 * * `isValid` = boolean flag.
 * * `id` = application specific identifier
 * @internal
 */
class TriangleCandidate extends BarycentricTriangle_1.BarycentricTriangle {
    constructor(point0, point1, point2, id, quality, isValid) {
        super(point0, point1, point2);
        this._isValid = isValid;
        this._quality = quality;
        this.id = id;
    }
    /**
     * Copy all coordinate and label data from `other` to this.
     * @param other source triangle
     */
    setFrom(other) {
        super.setFrom(other);
        this._isValid = other._isValid;
        this._quality = other._quality;
        this.id = other.id;
        return this;
    }
    /** Create (always) a TriangleCandidate.
     * * Access points from multiple `IndexedXYZCollection`
     * * mark invalid if any indices are invalid.
     */
    static createFromIndexedXYZ(source0, index0, source1, index1, source2, index2, id, result) {
        if (!result)
            result = new TriangleCandidate(Point3dVector3d_1.Point3d.create(), Point3dVector3d_1.Point3d.create(), Point3dVector3d_1.Point3d.create(), id, 0.0, false);
        result.id = id;
        let numValid = 0;
        if (undefined !== source0.getPoint3dAtCheckedPointIndex(index0, result.points[0]))
            numValid++;
        if (undefined !== source1.getPoint3dAtCheckedPointIndex(index1, result.points[1]))
            numValid++;
        if (undefined !== source2.getPoint3dAtCheckedPointIndex(index2, result.points[2]))
            numValid++;
        if (numValid === 3)
            result.updateAspectRatio();
        else
            result.markInvalid();
        return result;
    }
    /** (property) return the validity flag. */
    get isValid() { return this._isValid; }
    /**
     * * Mark this triangle invalid.
     * * optionally set aspect ratio.
     * * points are not changed
     * @param aspectRatio
     */
    markInvalid(quality) {
        this._isValid = false;
        if (quality !== undefined)
            this._quality = quality;
    }
    /**
     * * Recompute the aspect ratio.
     * * Mark invalid if aspect ratio is 0 or negative.
     */
    updateAspectRatio() {
        this._quality = super.aspectRatio;
        this._isValid = this._quality > 0.0;
    }
    /**
     * Clone all coordinate and label data.
     * @param result optional preallocated `TriangleCandidate`
     */
    clone(result) {
        if (result)
            return result.setFrom(this);
        return new TriangleCandidate(this.points[0].clone(), this.points[1].clone(), this.points[2].clone(), this.id, this._quality, this._isValid);
    }
    /**
     * Return a `TriangleCandidate` with
     *  * coordinate data and labels from `candidateA`
     *  * LOWER quality of the two candidates.
     *  * quality reduced by 1 if triangles have opposing normals (negative dot product of the two normals)
     * @param candidateA candidate known to be valid
     * @param candidateB candidate that may by valid
     * @param result copy of candidate A, but if candidateB is valid the result aspect ratio is reduced (a) to the minimum of the two ratios and then (b) reduced by 1 if orientations clash.
     */
    static copyWithLowerQuality(candidateA, candidateB, result) {
        result = candidateA.clone(result);
        if (candidateB.isValid) {
            const dot = candidateA.dotProductOfCrossProductsFromOrigin(candidateB);
            result._quality = Geometry_1.Geometry.minXY(candidateA.aspectRatio, candidateB.aspectRatio);
            if (dot < 0.0)
                result._quality -= 1.0;
        }
        return result;
    }
    /**
     * choose better aspect ratio of triangle, other.
     * @param triangle known valid triangle, to be updated
     * @param other candidate replacement
     */
    static updateIfOtherHasHigherQuality(triangle, other) {
        if (other.isValid && other._quality > triangle._quality)
            triangle.setFrom(other);
    }
}
exports.TriangleCandidate = TriangleCandidate;


/***/ }),

/***/ "./lib/polyface/multiclip/GriddedRaggedRange2dSet.js":
/*!***********************************************************!*\
  !*** ./lib/polyface/multiclip/GriddedRaggedRange2dSet.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const LinearSearchRange2dArray_1 = __webpack_require__(/*! ./LinearSearchRange2dArray */ "./lib/polyface/multiclip/LinearSearchRange2dArray.js");
/**
 * A GriddedRaggedRange2dSet is
 * * A doubly dimensioned array of LinearSearchRange2dArray
 * * Each entry represents a block in a uniform grid within the master range of the GriddedRaggedRange2dSet.
 * * Member ranges are noted in the grid block containing the range's lower left corner.
 * * Member ranges larger than twice the grid size are rejected by the insert method.
 * * Hence a search involving a point in grid block (i,j) must examine ranges in grid blocks left and below, i.e. (i-1,j-1), (i-1,j), (i,j-1)
 * @internal
 */
class GriddedRaggedRange2dSet {
    constructor(range, numXEdge, numYEdge) {
        this._range = range;
        this._numXEdge = numXEdge;
        this._numYEdge = numYEdge;
        this._rangesInBlock = [];
        for (let j = 0; j < this._numYEdge; j++) {
            const thisRow = [];
            for (let i = 0; i < this._numXEdge; i++) {
                thisRow.push(undefined);
            }
            this._rangesInBlock.push(thisRow);
        }
    }
    /**
     * Create an (empty) set of ranges.
     * @param range
     * @param numXEdge
     * @param numYEdge
     */
    static create(range, numXEdge, numYEdge) {
        if (numXEdge < 1 || numYEdge < 1 || range.isNull || range.isSinglePoint)
            return undefined;
        return new GriddedRaggedRange2dSet(range.clone(), numXEdge, numYEdge);
    }
    xIndex(x) {
        const fraction = (x - this._range.low.x) / (this._range.high.x - this._range.low.x);
        return Math.floor(fraction * this._numXEdge);
    }
    yIndex(y) {
        const fraction = (y - this._range.low.y) / (this._range.high.y - this._range.low.y);
        return Math.floor(fraction * this._numXEdge);
    }
    getBlock(i, j) {
        if (i >= 0 && i < this._numXEdge && j >= 0 && j < this._numYEdge) {
            if (!this._rangesInBlock[j][i])
                this._rangesInBlock[j][i] = new LinearSearchRange2dArray_1.LinearSearchRange2dArray();
            return this._rangesInBlock[j][i];
        }
        return undefined;
    }
    /** If possible, insert a range into the set.
     * * Decline to insert (and return false) if
     *   * range is null
     *   * range is not completely contained in the overall range of this set.
     *   * range x or y extent is larger than 2 grid blocks.
     */
    conditionalInsert(range, tag) {
        if (range.isNull)
            return false;
        if (!this._range.containsRange(range))
            return false;
        const xIndex0 = this.xIndex(range.low.x);
        const xIndex1 = this.xIndex(range.high.x);
        const yIndex0 = this.yIndex(range.low.y);
        const yIndex1 = this.yIndex(range.high.y);
        if (!(xIndex0 === xIndex1 || xIndex0 + 1 === xIndex1))
            return false;
        if (!(yIndex0 === yIndex1 || yIndex0 + 1 === yIndex1))
            return false;
        const rangesInBlock = this.getBlock(xIndex0, yIndex0);
        if (rangesInBlock) {
            rangesInBlock.addRange(range, tag);
            return true;
        }
        return false;
    }
    /**
     * * Search a single block
     * * Pass each range and tag to handler
     * * and return false if bad cell or if handler returns false.
     * @param testRange search range.
     * @param handler function to receive range and tag hits.
     * @return false if search terminated by handler.  Return true if no handler returned false.
     */
    searchXYInIndexedBlock(i, j, x, y, handler) {
        const rangesInBlock = this.getBlock(i, j);
        if (!rangesInBlock)
            return true;
        return rangesInBlock.searchXY(x, y, handler);
    }
    /**
     * * Search a single block
     * * Pass each range and tag to handler
     * * and return false if bad cell or if handler returns false.
     * @param testRange search range.
     * @param handler function to receive range and tag hits.
     * @return false if search terminated by handler.  Return true if no handler returned false.
     */
    searchRange2dInIndexedBlock(i, j, testRange, handler) {
        const rangesInBlock = this.getBlock(i, j);
        if (!rangesInBlock)
            return true;
        return rangesInBlock.searchRange2d(testRange, handler);
    }
    /**
     * * Search for ranges containing testRange
     * * Pass each range and tag to handler
     * * terminate search if handler returns false.
     * @param testRange search range.
     * @param handler function to receive range and tag hits.
     * @return false if search terminated by handler.  Return true if no handler returned false.
     */
    searchXY(x, y, handler) {
        const i = this.xIndex(x);
        const j = this.yIndex(y);
        return this.searchXYInIndexedBlock(i, j, x, y, handler)
            && this.searchXYInIndexedBlock(i - 1, j, x, y, handler)
            && this.searchXYInIndexedBlock(i, j - 1, x, y, handler)
            && this.searchXYInIndexedBlock(i - 1, j - 1, x, y, handler);
    }
    /**
     * * Search for ranges overlapping testRange
     * * Pass each range and tag to handler
     * * terminate search if handler returns false.
     * @param testRange search range.
     * @param handler function to receive range and tag hits.
     * @return false if search terminated by handler.  Return true if no handler returned false.
     */
    searchRange2d(testRange, handler) {
        const xIndex0 = this.xIndex(testRange.low.x) - 1;
        const xIndex1 = this.xIndex(testRange.high.x);
        const yIndex0 = this.yIndex(testRange.low.y) - 1;
        const yIndex1 = this.yIndex(testRange.high.y);
        for (let i = xIndex0; i <= xIndex1; i++) {
            for (let j = yIndex0; j <= yIndex1; j++) {
                if (!this.searchRange2dInIndexedBlock(i, j, testRange, handler))
                    return false;
            }
        }
        return true;
    }
    visitChildren(initialDepth, handler) {
        for (const row of this._rangesInBlock) {
            for (const block of row) {
                if (block)
                    handler(initialDepth, block);
            }
        }
    }
}
exports.GriddedRaggedRange2dSet = GriddedRaggedRange2dSet;


/***/ }),

/***/ "./lib/polyface/multiclip/GriddedRaggedRange2dSetWithOverflow.js":
/*!***********************************************************************!*\
  !*** ./lib/polyface/multiclip/GriddedRaggedRange2dSetWithOverflow.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const LinearSearchRange2dArray_1 = __webpack_require__(/*! ./LinearSearchRange2dArray */ "./lib/polyface/multiclip/LinearSearchRange2dArray.js");
const GriddedRaggedRange2dSet_1 = __webpack_require__(/*! ./GriddedRaggedRange2dSet */ "./lib/polyface/multiclip/GriddedRaggedRange2dSet.js");
/**
 * Use GriddedRaggedRange2dSetWithOverflow for searching among many ranges for which
 * * Most ranges are of somewhat consistent size.
 * * A modest number of oversizes.
 * * Maintain the smallish ones in a GriddedRaggedRange2dSet.
 * * Maintain the overflows in a LinearSearchRange2dArray
 * @internal
 */
class GriddedRaggedRange2dSetWithOverflow {
    constructor(gridSet, overflowSet) {
        this._gridSet = gridSet;
        this._overflowSet = overflowSet;
    }
    /**
     * Create an (empty) set of ranges.
     * @param range
     * @param numXEdge
     * @param numYEdge
     */
    static create(range, numXEdge, numYEdge) {
        const grids = GriddedRaggedRange2dSet_1.GriddedRaggedRange2dSet.create(range.clone(), numXEdge, numYEdge);
        if (grids)
            return new GriddedRaggedRange2dSetWithOverflow(grids, new LinearSearchRange2dArray_1.LinearSearchRange2dArray());
        return undefined;
    }
    /**
     * * Search for ranges containing testRange
     * * Pass each range and tag to handler
     * * terminate search if handler returns false.
     * @param testRange search range.
     * @param handler function to receive range and tag hits.
     * @return false if search terminated by handler.  Return true if no handler returned false.
     */
    searchXY(x, y, handler) {
        return this._gridSet.searchXY(x, y, handler) && this._overflowSet.searchXY(x, y, handler);
    }
    /**
     * * Search for ranges overlapping testRange
     * * Pass each range and tag to handler
     * * terminate search if handler returns false.
     * @param testRange search range.
     * @param handler function to receive range and tag hits.
     * @return false if search terminated by handler.  Return true if no handler returned false.
     */
    searchRange2d(testRange, handler) {
        return this._gridSet.searchRange2d(testRange, handler) && this._overflowSet.searchRange2d(testRange, handler);
    }
    /** If possible, insert a range into the set.
     * * Decline to insert (and return false) if
     *   * range is null
     *   * range is not completely contained in the overall range of this set.
     *   * range x or y extent is larger than 2 grid blocks.
     */
    addRange(range, tag) {
        if (!range.isNull) {
            if (!this._gridSet.conditionalInsert(range, tag))
                this._overflowSet.addRange(range, tag);
        }
    }
    visitChildren(initialDepth, handler) {
        handler(initialDepth, this._overflowSet);
        this._gridSet.visitChildren(initialDepth + 1, handler);
    }
}
exports.GriddedRaggedRange2dSetWithOverflow = GriddedRaggedRange2dSetWithOverflow;


/***/ }),

/***/ "./lib/polyface/multiclip/LinearSearchRange2dArray.js":
/*!************************************************************!*\
  !*** ./lib/polyface/multiclip/LinearSearchRange2dArray.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Range_1 = __webpack_require__(/*! ../../geometry3d/Range */ "./lib/geometry3d/Range.js");
/**
 * * Array of Range2d
 * * user data tag attached to each range via cast as (any).userTag.
 * * Search operations are simple linear.
 * * This class can be used directly for "smallish" range sets, or as the leaf level of hierarchical structures for larger range sets.
 * *
 * @internal
 */
class LinearSearchRange2dArray {
    constructor() {
        this._rangeArray = [];
        this._isDirty = false;
        this._compositeRange = Range_1.Range2d.createNull();
    }
    // TODO: build search structure
    updateForSearch() {
        this._isDirty = false;
    }
    /** Return the overall range of all member ranges. */
    totalRange(result) {
        result = result ? result : Range_1.Range2d.createNull();
        return this._compositeRange.clone(result);
    }
    /** Add a range to the search set. */
    addRange(range, tag) {
        this._isDirty = true;
        const myRange = Range_1.Range2d.createNull();
        myRange.tag = tag;
        myRange.extendXY(range.low.x, range.low.y);
        myRange.extendXY(range.high.x, range.high.y);
        this._compositeRange.extendRange(myRange);
        this._rangeArray.push(myRange);
    }
    /**
     * * Search for ranges containing testRange
     * * Pass each range and tag to handler
     * * terminate search if handler returns false.
     * @param testRange search range.
     * @param handler function to receive range and tag hits.
     * @return false if search terminated by handler.  Return true if no handler returned false.
     */
    searchXY(x, y, handler) {
        if (this._isDirty)
            this.updateForSearch();
        // NEEDS WORK: Linear search here -- do better!
        for (const candidate of this._rangeArray) {
            if (candidate.containsXY(x, y))
                if (!handler(candidate, candidate.tag))
                    return false;
        }
        return true;
    }
    /**
     * * Search for ranges overlapping testRange
     * * Pass each range and tag to handler
     * * terminate search if handler returns false.
     * @param testRange search range.
     * @param handler function to receive range and tag hits.
     * @return false if search terminated by handler.  Return true if no handler returned false.
     */
    searchRange2d(testRange, handler) {
        if (this._isDirty)
            this.updateForSearch();
        for (const candidate of this._rangeArray) {
            if (candidate.intersectsRange(testRange))
                if (!handler(candidate, candidate.tag))
                    return false;
        }
        return true;
    }
}
exports.LinearSearchRange2dArray = LinearSearchRange2dArray;


/***/ }),

/***/ "./lib/polyface/multiclip/RangeSearch.js":
/*!***********************************************!*\
  !*** ./lib/polyface/multiclip/RangeSearch.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Range_1 = __webpack_require__(/*! ../../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Geometry_1 = __webpack_require__(/*! ../../Geometry */ "./lib/Geometry.js");
const GriddedRaggedRange2dSetWithOverflow_1 = __webpack_require__(/*! ./GriddedRaggedRange2dSetWithOverflow */ "./lib/polyface/multiclip/GriddedRaggedRange2dSetWithOverflow.js");
const LinearSearchRange2dArray_1 = __webpack_require__(/*! ./LinearSearchRange2dArray */ "./lib/polyface/multiclip/LinearSearchRange2dArray.js");
/** Class with static members to work with various range searchers. */
class RangeSearch {
    /** Based on range count and distribution, return an object which can answer 2d range queries */
    static create2dSearcherForRangeLengthData(rangeLengthData, rangesPerBlockEdge = RangeSearch.defaultRangesPerBlockEdge, standardDeviationAdjustment = RangeSearch.defaultStandardDeviationAdjustment) {
        // for smallish sets, just linear search  . . ..
        if (rangeLengthData.xSums.count < RangeSearch.smallCountLimit)
            return new LinearSearchRange2dArray_1.LinearSearchRange2dArray();
        const numXBlock = this.estimateGridBlockCount(rangeLengthData.range.xLength(), rangeLengthData.xSums, rangesPerBlockEdge, standardDeviationAdjustment);
        const numYBlock = this.estimateGridBlockCount(rangeLengthData.range.yLength(), rangeLengthData.ySums, rangesPerBlockEdge, standardDeviationAdjustment);
        if (numXBlock < 2 && numYBlock < 2)
            return new LinearSearchRange2dArray_1.LinearSearchRange2dArray();
        return GriddedRaggedRange2dSetWithOverflow_1.GriddedRaggedRange2dSetWithOverflow.create(Range_1.Range2d.createFrom(rangeLengthData.range), numXBlock, numYBlock);
    }
    /** Return the number of grid bocks (in one direction) for
     * * The total range length in this direction
     * * individual ranges whose count, mean and standard deviation are available in the sums.
     * @param totalRange the total range being searched (in this direction)
     * @param sums source for mean, count, and standard deviation of individual ranges
     * @param rangesPerBlockEdge target ratio of edge length in search blocks divided by representative length of individual range edges
     * @param standardDeviationAdjustment the number of standard deviations above the mean to be applied to convert mean to representative length.  Typically 0 to 1.
     * @returns number of blocks in grid.
     */
    static estimateGridBlockCount(totalLength, sums, rangesPerBlockEdge = RangeSearch.defaultRangesPerBlockEdge, standardDeviationAdjustment = RangeSearch.defaultStandardDeviationAdjustment) {
        if (sums.count < 1)
            return 1;
        const representativeRangeLength = rangesPerBlockEdge * (sums.mean + standardDeviationAdjustment * sums.standardDeviation);
        const gridEdgeLength = Geometry_1.Geometry.conditionalDivideFraction(totalLength, representativeRangeLength);
        if (gridEdgeLength === undefined)
            return 1;
        return Math.ceil(gridEdgeLength);
    }
}
exports.RangeSearch = RangeSearch;
RangeSearch.smallCountLimit = 40;
/** Target size for grid block size divided by representative per-entry range size. */
RangeSearch.defaultRangesPerBlockEdge = 4;
/** the "representative range size"is the mean range size plus this number of standard deviations */
RangeSearch.defaultStandardDeviationAdjustment = 1.0;


/***/ }),

/***/ "./lib/polyface/multiclip/XYPointBuckets.js":
/*!**************************************************!*\
  !*** ./lib/polyface/multiclip/XYPointBuckets.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Range_1 = __webpack_require__(/*! ../../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Geometry_1 = __webpack_require__(/*! ../../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
/**
 * Arrays of type T values distributed by xy position when entered.
 * @internal
 */
class XYIndexGrid {
    constructor(range, numX, numY) {
        this._range = range;
        this._numXEdge = Math.max(numX, 1);
        this._numYEdge = Math.max(numY, 1);
        this._data = [];
        for (let j = 0; j < numY; j++) {
            const thisRow = [];
            for (let i = 0; i < numX; i++) {
                thisRow.push(undefined);
            }
            this._data.push(thisRow);
        }
    }
    /** Return the number of x edges in the grid */
    get numXEdge() { return this._numXEdge; }
    /** Return the number of y edges in the grid */
    get numYEdge() { return this._numYEdge; }
    /** Return the `i` index of cells containing x coordinate */
    xIndex(x) {
        const fraction = (x - this._range.low.x) / (this._range.high.x - this._range.low.x);
        const q = Math.floor(fraction * this._numXEdge);
        if (q < 0)
            return 0;
        if (q > this._numXEdge - 1)
            return this._numXEdge - 1;
        return q;
    }
    /** Return the `j` index of cells containing x coordinate */
    yIndex(y) {
        const fraction = (y - this._range.low.y) / (this._range.high.y - this._range.low.y);
        const q = Math.floor(fraction * this._numYEdge);
        if (q < 0)
            return 0;
        if (q > this._numYEdge - 1)
            return this._numYEdge - 1;
        return q;
    }
    /**
     * Construct an array with cells mapped to a range, with counts determined by estimated total count and target number of entries per cell.
     * @param range
     * @param totalEntries
     * @param targetEntriesPerCell
     */
    static createWithEstimatedCounts(range, totalEntries, targetEntriesPerCell) {
        if (range.low.x >= range.high.x || range.low.y >= range.high.y)
            return undefined;
        const range2d = Range_1.Range2d.createXYXY(range.low.x, range.low.y, range.high.x, range.high.y);
        const dx = range2d.xLength();
        const dy = range2d.yLength();
        // numX / numY = dX / dY  (numX,numY will be integers  . . .)
        // numX = dX * numY / dY
        let numX;
        let numY;
        if (dy > dx) {
            numY = Math.ceil(Math.sqrt(dy * totalEntries / (targetEntriesPerCell * dx)));
            numX = Math.ceil(totalEntries / numY);
        }
        else {
            numX = Math.ceil(Math.sqrt(dx * totalEntries / (targetEntriesPerCell * dy)));
            numY = Math.ceil(totalEntries / (numX * targetEntriesPerCell));
        }
        return new XYIndexGrid(range2d, numX, numY);
    }
    /**
     * Add (save) a new data value to the grid cell containing x,y
     * @param x
     * @param y
     * @param value
     */
    addDataAtXY(x, y, value) {
        const i = this.xIndex(x);
        const j = this.yIndex(y);
        let dataJI = this._data[j][i];
        if (!dataJI) {
            dataJI = [];
            this._data[j][i] = dataJI;
        }
        dataJI.push(value);
        return;
    }
    /**
     * Get the (reference to the possibly null array of) data values for the cell indicated by xy.
     * @param x
     * @param y
     */
    getDataAtXY(x, y) {
        const i = this.xIndex(x);
        const j = this.yIndex(y);
        return this._data[j][i];
    }
    /**
     * Get the (reference to the possibly null array of) data values for the cell indicated by indices in the x and y direction
     * @param xIndex
     * @param yIndex
     */
    getDataAtIndex(xIndex, yIndex) {
        if (xIndex < 0)
            return undefined;
        if (xIndex >= this._numXEdge)
            return undefined;
        if (yIndex < 0)
            return undefined;
        if (yIndex >= this._numYEdge)
            return undefined;
        return this._data[yIndex][xIndex];
    }
    /** Return true if (xIndex, yIndex) is a valid cell index. */
    isValidIndex(xIndex, yIndex) {
        if (xIndex < 0)
            return false;
        if (xIndex >= this._numXEdge)
            return false;
        if (yIndex < 0)
            return false;
        if (yIndex >= this._numYEdge)
            return false;
        return true;
    }
}
exports.XYIndexGrid = XYIndexGrid;
/** Manage buckets of points for fast search.
 * @internal
 */
class XYPointBuckets {
    constructor(points, buckets) {
        this._points = points;
        this._buckets = buckets;
    }
    /** Return the underlying grid with indices recorded by block */
    get indexGrid() { return this._buckets; }
    /** Create an XYIndex grid with all indices of all `points` entered */
    static create(points, targetPointsPerCell) {
        const n = points.length;
        if (points.length < 1)
            return undefined;
        const range = points.getRange();
        range.expandInPlace(Geometry_1.Geometry.smallMetricDistance * 1000.0);
        const buckets = XYIndexGrid.createWithEstimatedCounts(range, points.length, targetPointsPerCell);
        if (buckets === undefined)
            return undefined;
        const result = new XYPointBuckets(points, buckets);
        const point = Point3dVector3d_1.Point3d.create();
        for (let i = 0; i < n; i++) {
            points.getPoint3dAtUncheckedPointIndex(i, point);
            buckets.addDataAtXY(point.x, point.y, i);
        }
        return result;
    }
    /** call the `announce` function with the index and coordinates of all points in given range.
     * * continue the search if `announce` returns true.
     * * terminate the search if `announce` returns false;
     */
    announcePointsInRange(range, announce) {
        const i0 = this._buckets.xIndex(range.low.x);
        const i1 = this._buckets.xIndex(range.high.x);
        const j0 = this._buckets.yIndex(range.low.y);
        const j1 = this._buckets.yIndex(range.high.y);
        const n = this._points.length;
        for (let i = i0; i <= i1; i++) {
            for (let j = j0; j <= j1; j++) {
                const candidates = this._buckets.getDataAtIndex(i, j);
                if (candidates !== undefined) {
                    for (const k of candidates) {
                        if (k < n) {
                            const x = this._points.getXAtUncheckedPointIndex(k);
                            const y = this._points.getYAtUncheckedPointIndex(k);
                            const z = this._points.getZAtUncheckedPointIndex(k);
                            if (range.containsXY(x, y))
                                if (!announce(k, x, y, z))
                                    return;
                        }
                    }
                }
            }
        }
    }
}
exports.XYPointBuckets = XYPointBuckets;


/***/ }),

/***/ "./lib/serialization/DeepCompare.js":
/*!******************************************!*\
  !*** ./lib/serialization/DeepCompare.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Serialization */
/* tslint:disable: object-literal-key-quotes */
/**
 * Utilities to compare json objects by search through properties.
 * @internal
 */
class DeepCompare {
    constructor(numberRelTol = 1.0e-12) {
        /** Statistical accumulations during searchers. */
        this.typeCounts = {
            "numbers": 0,
            "arrays": 0,
            "functions": 0,
            "objects": 0,
            "strings": 0,
            "booleans": 0,
            "undefined": 0,
        };
        /** Counts of property names encountered during various searches. */
        this.propertyCounts = {};
        /** Array of error descriptions. */
        this.errorTracker = [];
        this.numberRelTol = numberRelTol;
    }
    /** test if _a and _b are within tolerance.
     * * If not, push error message to errorTracker.
     */
    compareNumber(_a, _b) {
        if (Math.abs(_b - _a) < this.numberRelTol * (1 + Math.abs(_a) + Math.abs(_b))) {
            return this.announce(true);
        }
        else {
            this.errorTracker.unshift(_b);
            this.errorTracker.unshift(_a);
            this.errorTracker.unshift("In " + this.errorTracker[this.errorTracker.length - 1] + " property: Mismatched values");
            return this.announce(false);
        }
    }
    compareArray(a, b) {
        if (a.length !== b.length) {
            const aCounter = {};
            const bCounter = {};
            // Append object to tracker that counts the properties of each array element (which is an object) in b, ONLY AT THIS LEVEL
            for (const i of b) {
                if (typeof i === "object" && typeof i !== "function" && !Array.isArray(i)) {
                    for (const property in i) {
                        if (i.hasOwnProperty(property)) {
                            // Add property to counter if not already there
                            if (!bCounter.hasOwnProperty(property))
                                bCounter[property] = 0;
                            bCounter[property]++;
                        }
                    }
                }
            }
            this.errorTracker.unshift(bCounter);
            // Append object to tracker that counts the properties of each array element (which is an object) in a, ONLY AT THIS LEVEL
            for (const i of a) {
                if (typeof i === "object" && typeof i !== "function" && !Array.isArray(i)) {
                    for (const property in i) {
                        if (i.hasOwnProperty(property)) {
                            // Add property to counter if not already there
                            if (!aCounter.hasOwnProperty(property))
                                aCounter[property] = 0;
                            aCounter[property]++;
                        }
                    }
                }
            }
            this.errorTracker.unshift(aCounter);
            this.errorTracker.unshift("Mismatched array lengths a: [" + a.length + "] b: [" + b.length + "]");
            return this.announce(false);
        }
        // Keep track of result for each element of array
        let toReturn = true;
        for (let i = 0; i < a.length; i++) {
            toReturn = toReturn && this.compareInternal(a[i], b[i]);
            // If false, break the loop
            if (!toReturn) {
                this.errorTracker.unshift("[" + i.toString() + "]");
                break;
            }
        }
        return this.announce(toReturn);
    }
    compareObject(a, b) {
        // Check that both objects contain the same amount of properties
        if (a == null && b == null)
            return this.announce(true);
        if ((Object.keys(a)).length !== (Object.keys(b)).length) {
            this.errorTracker.unshift("Mismatched property lists [" + (Object.keys(a)) + "][" + (Object.keys(b)) + "]");
            return this.announce(false);
        }
        // Keep track of result for each property of object
        let toReturn = true;
        for (const property in a) {
            // Only check non-generic object properties
            if (a.hasOwnProperty(property)) {
                // If property does not exist in propertyCounter, add it
                if (!this.propertyCounts.hasOwnProperty(property)) {
                    this.propertyCounts[property] = 0;
                }
                this.propertyCounts[property]++;
                // Check that same property exists in b
                if (!(b.hasOwnProperty(property))) {
                    this.errorTracker.unshift("Property " + property + " of A not in B");
                    this.errorTracker.unshift(a);
                    this.errorTracker.unshift(b);
                    return this.announce(false);
                }
                toReturn = toReturn && this.compareInternal(a[property], b[property]);
                // If not true, push property and break the loop
                if (!toReturn) {
                    this.errorTracker.unshift(property);
                    break;
                }
            }
        }
        return this.announce(toReturn);
    }
    // this is a convenient place for a breakpoint on failures in areSameStructure.
    announce(value) {
        if (value)
            return true;
        return false;
    }
    /** Main entry for comparing deep json objects.
     * * errorTracker, typeCounts, and propertyCounts are cleared.
     */
    compare(a, b, tolerance) {
        if (tolerance !== undefined)
            this.numberRelTol = tolerance;
        this.errorTracker.length = 0;
        this.typeCounts.numbers = this.typeCounts.arrays = this.typeCounts.functions = this.typeCounts.objects = this.typeCounts.strings = this.typeCounts.booleans = this.typeCounts.undefined = 0;
        this.propertyCounts = {};
        return this.compareInternal(a, b);
    }
    // Recursive function for comparing any two nodes in a json object "tree"
    compareInternal(a, b) {
        if (typeof a !== typeof b) {
            return this.announce(false);
        }
        if ((typeof a === "number") && (typeof b === "number")) {
            this.typeCounts.numbers++;
            return this.compareNumber(a, b);
        }
        else if (Array.isArray(a) && Array.isArray(b)) {
            this.typeCounts.arrays++;
            return this.compareArray(a, b);
        }
        else if (typeof a === "function" && typeof b === "function") {
            // No current necessity to check functions
            this.typeCounts.functions++;
            return true;
        }
        else if (typeof a === "object" && typeof b === "object") {
            // Argument is object but not array or function
            this.typeCounts.objects++;
            return (a === b) ? true : this.compareObject(a, b);
        }
        else if (typeof a === "string" && typeof b === "string") {
            this.typeCounts.strings++;
            return a === b;
        }
        else if (typeof a === "boolean" && typeof b === "boolean") {
            this.typeCounts.booleans++;
            return a === b;
        }
        else if (typeof a === "undefined" && typeof b === "undefined") {
            // As long as both are undefined, return true
            this.typeCounts.undefined++;
            return true;
        }
        else {
            // Unsupported type
            return this.announce(false);
        }
    }
}
exports.DeepCompare = DeepCompare;


/***/ }),

/***/ "./lib/serialization/GeometrySamples.js":
/*!**********************************************!*\
  !*** ./lib/serialization/GeometrySamples.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Serialization */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const Plane3dByOriginAndUnitNormal_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndUnitNormal */ "./lib/geometry3d/Plane3dByOriginAndUnitNormal.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const Map4d_1 = __webpack_require__(/*! ../geometry4d/Map4d */ "./lib/geometry4d/Map4d.js");
const Matrix4d_1 = __webpack_require__(/*! ../geometry4d/Matrix4d */ "./lib/geometry4d/Matrix4d.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const UnionRegion_1 = __webpack_require__(/*! ../curve/UnionRegion */ "./lib/curve/UnionRegion.js");
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const ParityRegion_1 = __webpack_require__(/*! ../curve/ParityRegion */ "./lib/curve/ParityRegion.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Path_1 = __webpack_require__(/*! ../curve/Path */ "./lib/curve/Path.js");
const Polyface_1 = __webpack_require__(/*! ../polyface/Polyface */ "./lib/polyface/Polyface.js");
const BSplineCurve_1 = __webpack_require__(/*! ../bspline/BSplineCurve */ "./lib/bspline/BSplineCurve.js");
const BSplineSurface_1 = __webpack_require__(/*! ../bspline/BSplineSurface */ "./lib/bspline/BSplineSurface.js");
const Sphere_1 = __webpack_require__(/*! ../solid/Sphere */ "./lib/solid/Sphere.js");
const Cone_1 = __webpack_require__(/*! ../solid/Cone */ "./lib/solid/Cone.js");
const Box_1 = __webpack_require__(/*! ../solid/Box */ "./lib/solid/Box.js");
const TorusPipe_1 = __webpack_require__(/*! ../solid/TorusPipe */ "./lib/solid/TorusPipe.js");
const LinearSweep_1 = __webpack_require__(/*! ../solid/LinearSweep */ "./lib/solid/LinearSweep.js");
const RotationalSweep_1 = __webpack_require__(/*! ../solid/RotationalSweep */ "./lib/solid/RotationalSweep.js");
const RuledSweep_1 = __webpack_require__(/*! ../solid/RuledSweep */ "./lib/solid/RuledSweep.js");
const LineSegment3d_1 = __webpack_require__(/*! ../curve/LineSegment3d */ "./lib/curve/LineSegment3d.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const TransitionSpiral_1 = __webpack_require__(/*! ../curve/TransitionSpiral */ "./lib/curve/TransitionSpiral.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const PointString3d_1 = __webpack_require__(/*! ../curve/PointString3d */ "./lib/curve/PointString3d.js");
const ClipPlane_1 = __webpack_require__(/*! ../clipping/ClipPlane */ "./lib/clipping/ClipPlane.js");
const ConvexClipPlaneSet_1 = __webpack_require__(/*! ../clipping/ConvexClipPlaneSet */ "./lib/clipping/ConvexClipPlaneSet.js");
const GrowableFloat64Array_1 = __webpack_require__(/*! ../geometry3d/GrowableFloat64Array */ "./lib/geometry3d/GrowableFloat64Array.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
const UnionOfConvexClipPlaneSets_1 = __webpack_require__(/*! ../clipping/UnionOfConvexClipPlaneSets */ "./lib/clipping/UnionOfConvexClipPlaneSets.js");
const BSplineCurve3dH_1 = __webpack_require__(/*! ../bspline/BSplineCurve3dH */ "./lib/bspline/BSplineCurve3dH.js");
const BezierCurve3d_1 = __webpack_require__(/*! ../bspline/BezierCurve3d */ "./lib/bspline/BezierCurve3d.js");
const BezierCurve3dH_1 = __webpack_require__(/*! ../bspline/BezierCurve3dH */ "./lib/bspline/BezierCurve3dH.js");
const CurveChainWithDistanceIndex_1 = __webpack_require__(/*! ../curve/CurveChainWithDistanceIndex */ "./lib/curve/CurveChainWithDistanceIndex.js");
const KnotVector_1 = __webpack_require__(/*! ../bspline/KnotVector */ "./lib/bspline/KnotVector.js");
const CoordinateXYZ_1 = __webpack_require__(/*! ../curve/CoordinateXYZ */ "./lib/curve/CoordinateXYZ.js");
/* tslint:disable:no-console */
/**
 * `Sample` has static methods to create a variety of geometry samples useful in testing.
 * @alpha
 */
class Sample {
    /** Return an array of Point3d, with x,y,z all stepping through a range of values.
     * x varies fastest, then y then z
     */
    static createPoint3dLattice(low, step, high) {
        const points = [];
        for (let z = low; z <= high; z += step)
            for (let y = low; y <= high; y += step)
                for (let x = low; x <= high; x += step)
                    points.push(Point3dVector3d_1.Point3d.create(x, y, z));
        return points;
    }
    /** Return an array of Point2d, with x,y all stepping through a range of values.
     * x varies fastest, then y
     */
    static createPoint2dLattice(low, step, high) {
        const points = [];
        for (let y = low; y <= high; y += step)
            for (let x = low; x <= high; x += step)
                points.push(Point2dVector2d_1.Point2d.create(x, y));
        return points;
    }
    /** Array with assorted nonzero vector samples. */
    static createNonZeroVectors() {
        return [
            Point3dVector3d_1.Vector3d.create(1, 0, 0),
            Point3dVector3d_1.Vector3d.create(0, 1, 0),
            Point3dVector3d_1.Vector3d.create(0, 0, 1),
            Point3dVector3d_1.Vector3d.create(-1, 0, 0),
            Point3dVector3d_1.Vector3d.create(0, -1, 0),
            Point3dVector3d_1.Vector3d.create(0, 0, -1),
            Point3dVector3d_1.Vector3d.createPolar(1.0, Angle_1.Angle.createDegrees(20)),
            Point3dVector3d_1.Vector3d.createSpherical(1.0, Angle_1.Angle.createDegrees(20), Angle_1.Angle.createDegrees(10)),
            Point3dVector3d_1.Vector3d.createPolar(2.0, Angle_1.Angle.createDegrees(20)),
            Point3dVector3d_1.Vector3d.createSpherical(2.0, Angle_1.Angle.createDegrees(20), Angle_1.Angle.createDegrees(10)),
            Point3dVector3d_1.Vector3d.create(2, 3, 0)
        ];
    }
    /** Return an array with assorted Range3d samples */
    static createRange3ds() {
        return [
            Range_1.Range3d.createXYZXYZ(0, 0, 0, 1, 1, 1),
            Range_1.Range3d.createXYZ(1, 2, 3),
            Range_1.Range3d.createXYZXYZ(-2, -3, 1, 200, 301, 8)
        ];
    }
    /** Create 5 points of a (axis aligned) rectangle with corners (x0,y0) and (x1,y1) */
    static createRectangleXY(x0, y0, ax, ay, z = 0) {
        return [
            Point3dVector3d_1.Point3d.create(x0, y0, z),
            Point3dVector3d_1.Point3d.create(x0 + ax, y0, z),
            Point3dVector3d_1.Point3d.create(x0 + ax, y0 + ay, z),
            Point3dVector3d_1.Point3d.create(x0, y0 + ay, z),
            Point3dVector3d_1.Point3d.create(x0, y0, z),
        ];
    }
    /** Access the last point in the array. push another shifted by dx,dy,dz.
     * * No push if all are 0.
     * * If array is empty, push a leading 000
     */
    static pushMove(data, dx, dy, dz = 0.0) {
        if (data.length === 0)
            data.push(Point3dVector3d_1.Point3d.create(0, 0, 0));
        const back = data[data.length - 1];
        if (dx !== 0 || dy !== 0 || dz !== 0)
            data.push(Point3dVector3d_1.Point3d.create(back.x + dx, back.y + dy, back.z + dz));
    }
    /** push a clone of the data[0] */
    static pushClosure(data) {
        if (data.length > 0)
            data.push(data[data.length - 1].clone());
    }
    /** Return an array with numPoints on the unit circle (counting closure) */
    static createUnitCircle(numPoints) {
        const points = [];
        const dTheta = Geometry_1.Geometry.safeDivideFraction(Math.PI * 2, numPoints - 1, 0.0);
        for (let i = 0; i < numPoints; i++) {
            const theta = i * dTheta;
            points.push(Point3dVector3d_1.Point3d.create(Math.cos(theta), Math.sin(theta), 0.0));
        }
        return points;
    }
    /** Create points for an L shaped polygon
     * * lower left at x0,y0.
     * * ax,ay are larger side lengths (lower left to corners along x and y directions)
     * * bx,by are smaller side lengths (inner corner to points along x and y directions)
     */
    static createLShapedPolygon(x0, y0, ax, ay, bx, by, z = 0) {
        return [
            Point3dVector3d_1.Point3d.create(x0, y0, z),
            Point3dVector3d_1.Point3d.create(x0 + ax, y0, z),
            Point3dVector3d_1.Point3d.create(x0 + ax, y0 + by),
            Point3dVector3d_1.Point3d.create(x0 + bx, y0 + by),
            Point3dVector3d_1.Point3d.create(x0 + bx, y0 + ay, z),
            Point3dVector3d_1.Point3d.create(x0, y0 + ay, z),
            Point3dVector3d_1.Point3d.create(x0, y0, z),
        ];
    }
    /** Create assorted clip planes. */
    static createClipPlanes() {
        const plane0 = ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(1, 0, 0), 2.0);
        const plane1 = plane0.cloneNegated();
        const plane2 = plane1.clone();
        plane2.setFlags(true, true);
        return [
            plane0, plane1, plane2,
            ClipPlane_1.ClipPlane.createNormalAndDistance(Point3dVector3d_1.Vector3d.create(3, 4, 0), 2.0),
            ClipPlane_1.ClipPlane.createEdgeXY(Point3dVector3d_1.Point3d.create(1, 0, 0), Point3dVector3d_1.Point3d.create(24, 32, 0))
        ];
    }
    /**
     * * A first-quadrant unit square
     * * Two squares -- first and fourth quadrant unit squares
     * * Three squares -- first, second and fourth quadrant unit squares
     */
    static createClipPlaneSets() {
        const result = [];
        const quadrant1 = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createXYBox(0, 0, 1, 1);
        result.push(UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets.createConvexSets([quadrant1.clone()]));
        const quadrant2 = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createXYBox(-1, 0, 0, 1);
        const quadrant4 = ConvexClipPlaneSet_1.ConvexClipPlaneSet.createXYBox(0, -1, 1, 0);
        result.push(UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets.createConvexSets([
            quadrant1.clone(),
            quadrant4.clone()
        ]));
        result.push(UnionOfConvexClipPlaneSets_1.UnionOfConvexClipPlaneSets.createConvexSets([
            quadrant1.clone(),
            quadrant2.clone(),
            quadrant4.clone()
        ]));
        return result;
    }
    /** Create (unweighted) bspline curves.
     * order varies from 2 to 5
     */
    static createBsplineCurves(includeMultipleKnots = false) {
        const result = [];
        const yScale = 0.1;
        for (const order of [2, 3, 4, 5]) {
            const points = [];
            for (const x of [0, 1, 2, 3, 4, 5, 7]) {
                points.push(Point3dVector3d_1.Point3d.create(x, yScale * (1 + x * x), 0.0));
            }
            const curve = BSplineCurve_1.BSplineCurve3d.createUniformKnots(points, order);
            result.push(curve);
        }
        if (includeMultipleKnots) {
            const interiorKnotCandidates = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8];
            for (const order of [3, 4]) {
                const numPoints = 8;
                const points = [];
                for (let i = 0; i < numPoints; i++)
                    points.push(Point3dVector3d_1.Point3d.create(i, i * i, 0));
                const knots = [];
                for (let i = 0; i < order - 1; i++)
                    knots.push(0);
                const numInteriorNeeded = numPoints - order;
                for (let i = 0; i < numInteriorNeeded; i++)
                    knots.push(interiorKnotCandidates[i]);
                const lastKnot = knots[knots.length - 1] + 1;
                for (let i = 0; i < order - 1; i++)
                    knots.push(lastKnot);
                const curve = BSplineCurve_1.BSplineCurve3d.create(points, knots, order);
                if (curve)
                    result.push(curve);
            }
        }
        return result;
    }
    /** Create weighted bspline curves.
     * order varies from 2 to 5
     */
    static createBspline3dHCurves() {
        const result = [];
        const yScale = 0.1;
        for (const weightVariation of [0, 0.125]) {
            for (const order of [2, 3, 4, 5]) {
                const points = [];
                for (const x of [0, 1, 2, 3, 4, 5, 7]) {
                    points.push(Point4d_1.Point4d.create(x, yScale * (1 + x * x), 0.0, 1.0 + weightVariation * Math.sin(x * Math.PI * 0.25)));
                }
                const curve = BSplineCurve3dH_1.BSplineCurve3dH.createUniformKnots(points, order);
                result.push(curve);
            }
        }
        return result;
    }
    /** Create weighted bsplines for circular arcs.
     */
    static createBspline3dHArcs() {
        const result = [];
        const halfRadians = Angle_1.Angle.degreesToRadians(60.0);
        const c = Math.cos(halfRadians);
        const s = Math.sin(halfRadians);
        // const sec = 1.0 / c;
        // const t = s / c;
        const points = [
            Point4d_1.Point4d.create(1, 0, 0, 1),
            Point4d_1.Point4d.create(c, s, 0, c),
            Point4d_1.Point4d.create(-c, s, 0, 1),
            Point4d_1.Point4d.create(-1, 0, 0, c),
            Point4d_1.Point4d.create(-c, -s, 0, 1),
            Point4d_1.Point4d.create(c, -s, 0, c),
            Point4d_1.Point4d.create(1, 0, 0, 1)
        ];
        const knots = [0, 0, 1, 1, 2, 2, 3, 3];
        const curve = BSplineCurve3dH_1.BSplineCurve3dH.create(points, knots, 3);
        result.push(curve);
        return result;
    }
    /** Return array   [x,y,z,w] bspline control points for an arc in 90 degree bspline spans.
     * @param points array of [x,y,z,w]
     * @param center center of arc
     * @param axes matrix with 0 and 90 degree axes
     * @param radius0 radius multiplier for x direction.
     * @param radius90 radius multiplier for y direction.
     * @param applyWeightsToXYZ
     */
    static createBsplineArc90SectionToXYZWArrays(center, axes, radius0, radius90, applyWeightsToXYZ) {
        const a = Math.sqrt(0.5);
        const xyz = Point3dVector3d_1.Point3d.create();
        Matrix3d_1.Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0, 0.0, 0, xyz);
        const controlPoints = [];
        controlPoints.push([xyz.x, xyz.y, xyz.z, 1.0]);
        const cornerTrig = [1, 1, -1, -1, 1];
        const axisTrig = [1, 0, -1, 0, 1];
        for (let i = 0; i < 4; i++) {
            Matrix3d_1.Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0 * cornerTrig[i + 1], radius90 * cornerTrig[i], 0, xyz);
            controlPoints.push([xyz.x, xyz.y, xyz.z, a]);
            Matrix3d_1.Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0 * axisTrig[i + 1], radius90 * axisTrig[i], 0, xyz);
            controlPoints.push([xyz.x, xyz.y, xyz.z, 1.0]);
        }
        if (applyWeightsToXYZ) {
            for (const xyzw of controlPoints) {
                const b = xyzw[3];
                xyzw[0] *= b;
                xyzw[1] *= b;
                xyzw[2] *= b;
            }
        }
        return controlPoints;
    }
    /**
     * Create both unweighted and weighted bspline curves.
     * (This is the combined results from createBsplineCurves and createBspline3dHCurves)
     */
    static createMixedBsplineCurves() {
        const arrayA = Sample.createBsplineCurves();
        const arrayB = Sample.createBspline3dHCurves();
        const result = [];
        for (const a of arrayA)
            result.push(a);
        for (const b of arrayB)
            result.push(b);
        return result;
    }
    /** create a plane from origin and normal coordinates -- default to 001 normal if needed. */
    static createPlane(x, y, z, u, v, w) {
        const point = Point3dVector3d_1.Point3d.create(x, y, z);
        const vector = Point3dVector3d_1.Vector3d.create(u, v, w).normalize();
        if (vector) {
            const plane = Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.create(point, vector);
            if (plane)
                return plane;
        }
        return Sample.createPlane(x, y, z, u, v, 1);
    }
    /** Create ray from (x,y,z) and direction components.   (Normalize the direction) */
    static createRay(x, y, z, u, v, w) {
        return Ray3d_1.Ray3d.create(Point3dVector3d_1.Point3d.create(x, y, z), Point3dVector3d_1.Vector3d.create(u, v, w).normalize());
    }
    /** Assorted lines strings */
    static createLineStrings() {
        return [
            LineString3d_1.LineString3d.createPoints([
                Point3dVector3d_1.Point3d.create(0, 0, 0),
                Point3dVector3d_1.Point3d.create(1, 0, 0)
            ]),
            LineString3d_1.LineString3d.createPoints([
                Point3dVector3d_1.Point3d.create(0, 0, 0),
                Point3dVector3d_1.Point3d.create(1, 0, 0),
                Point3dVector3d_1.Point3d.create(1, 1, 0)
            ]),
            LineString3d_1.LineString3d.createPoints([
                Point3dVector3d_1.Point3d.create(0, 0, 0),
                Point3dVector3d_1.Point3d.create(1, 0, 0),
                Point3dVector3d_1.Point3d.create(1, 1, 0),
                Point3dVector3d_1.Point3d.create(2, 2, 0)
            ])
        ];
    }
    /** Assorted Matrix3d:
     * * identity
     * * rotation around x
     * * rotation around general vector
     * * uniform scale
     * * nonuniform scale (including negative scales!)
     */
    static createMatrix3dArray() {
        return [
            Matrix3d_1.Matrix3d.createIdentity(),
            Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(1, 0, 0), Angle_1.Angle.createDegrees(10)),
            Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(1, -2, 5), Angle_1.Angle.createDegrees(-6.0)),
            Matrix3d_1.Matrix3d.createUniformScale(2.0),
            Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(1, 2, 3), Angle_1.Angle.createDegrees(49.0)),
            Matrix3d_1.Matrix3d.createScale(1, 1, -1),
            Matrix3d_1.Matrix3d.createScale(2, 3, 4)
        ];
    }
    /** Assorted invertible transforms. */
    static createInvertibleTransforms() {
        return [
            Transform_1.Transform.createIdentity(),
            Transform_1.Transform.createTranslationXYZ(1, 2, 0),
            Transform_1.Transform.createTranslationXYZ(1, 2, 3),
            Transform_1.Transform.createFixedPointAndMatrix(Point3dVector3d_1.Point3d.create(4, 1, -2), Matrix3d_1.Matrix3d.createUniformScale(2.0)),
            Transform_1.Transform.createFixedPointAndMatrix(Point3dVector3d_1.Point3d.create(4, 1, -2), Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(1, 2, 3), Angle_1.Angle.createRadians(10)))
        ];
    }
    /** Return an array of Matrix3d with various skew and scale.  This includes at least:
     * * identity
     * * 3 distinct diagonals.
     * * The distinct diagonal base with smaller value added to
     *    other 6 spots in succession.
     * * the distinct diagonals with all others also smaller non-zeros.
     */
    static createScaleSkewMatrix3d() {
        return [
            Matrix3d_1.Matrix3d.createRowValues(1, 0, 0, 0, 1, 0, 0, 0, 1),
            Matrix3d_1.Matrix3d.createRowValues(5, 0, 0, 0, 6, 0, 0, 0, 7),
            Matrix3d_1.Matrix3d.createRowValues(5, 2, 0, 0, 6, 0, 0, 0, 7),
            Matrix3d_1.Matrix3d.createRowValues(5, 0, 2, 0, 6, 0, 0, 0, 7),
            Matrix3d_1.Matrix3d.createRowValues(5, 0, 0, 1, 6, 0, 0, 0, 7),
            Matrix3d_1.Matrix3d.createRowValues(5, 0, 0, 0, 6, 1, 0, 0, 7),
            Matrix3d_1.Matrix3d.createRowValues(5, 0, 0, 0, 6, 0, 1, 0, 7),
            Matrix3d_1.Matrix3d.createRowValues(5, 0, 0, 0, 6, 0, 0, 1, 7),
            Matrix3d_1.Matrix3d.createRowValues(5, 2, 3, 2, 6, 1, -1, 2, 7)
        ];
    }
    /** Return an array of singular Matrix3d.  This includes at least:
     * * all zeros
     * * one nonzero column
     * * two independent columns, third is zero
     * * two independent columns, third is sum of those
     * * two independent columns, third is copy of one
     */
    static createSingularMatrix3d() {
        const vectorU = Point3dVector3d_1.Vector3d.create(2, 3, 6);
        const vectorV = Point3dVector3d_1.Vector3d.create(-1, 5, 2);
        const vectorUPlusV = vectorU.plus(vectorV);
        const vector0 = Point3dVector3d_1.Vector3d.createZero();
        return [
            Matrix3d_1.Matrix3d.createZero(),
            // one nonzero column
            Matrix3d_1.Matrix3d.createColumns(vectorU, vector0, vector0),
            Matrix3d_1.Matrix3d.createColumns(vector0, vectorU, vector0),
            Matrix3d_1.Matrix3d.createColumns(vector0, vector0, vector0),
            // two independent nonzero columns with zero
            Matrix3d_1.Matrix3d.createColumns(vectorU, vectorV, vector0),
            Matrix3d_1.Matrix3d.createColumns(vector0, vectorU, vectorV),
            Matrix3d_1.Matrix3d.createColumns(vectorV, vector0, vector0),
            // third column dependent
            Matrix3d_1.Matrix3d.createColumns(vectorU, vectorV, vectorUPlusV),
            Matrix3d_1.Matrix3d.createColumns(vectorU, vectorUPlusV, vectorV),
            Matrix3d_1.Matrix3d.createColumns(vectorUPlusV, vectorV, vectorU),
            // two independent with duplicate
            Matrix3d_1.Matrix3d.createColumns(vectorU, vectorV, vectorU),
            Matrix3d_1.Matrix3d.createColumns(vectorU, vectorU, vectorV),
            Matrix3d_1.Matrix3d.createColumns(vectorV, vectorV, vectorU)
        ];
    }
    /**
     * * Return an array of rigid transforms.  This includes (at least)
     *   * Identity
     *   * translation with identity matrix
     *   * rotation around origin and arbitrary vector
     *   * rotation around space point and arbitrary vector
     * * use given refDistance is crude distance of translation and distance to fixed point.
     */
    static createRigidTransforms(distanceScale = 4.0) {
        const distanceScale3 = distanceScale / 3.0;
        const distanceScale4 = distanceScale / 4.0;
        return [
            Transform_1.Transform.createIdentity(),
            Transform_1.Transform.createTranslationXYZ(distanceScale3 * 1, distanceScale3 * 2, distanceScale3 * 3),
            Transform_1.Transform.createFixedPointAndMatrix(Point3dVector3d_1.Point3d.create(0, 0, 0), Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.unitY(), Angle_1.Angle.createDegrees(10))),
            Transform_1.Transform.createFixedPointAndMatrix(Point3dVector3d_1.Point3d.create(distanceScale4 * 4, distanceScale4 * 1, -distanceScale4 * 2), Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(1, 2, 3), Angle_1.Angle.createDegrees(10))),
            Transform_1.Transform.createFixedPointAndMatrix(Point3dVector3d_1.Point3d.create(distanceScale4 * 4, distanceScale4 * 1, -distanceScale4 * 2), Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(-2, 1, 4), Angle_1.Angle.createDegrees(35)))
        ];
    }
    /**
     * Return a single rigid transform with all terms nonzero.
     */
    static createMessyRigidTransform(fixedPoint) {
        return Transform_1.Transform.createFixedPointAndMatrix(fixedPoint ? fixedPoint : Point3dVector3d_1.Point3d.create(1, 2, 3), Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(0.3, -0.2, 1.2), Angle_1.Angle.createDegrees(15.7)));
    }
    /** Return various rigid matrices:
     * * identity
     * * small rotations around x, y, z
     * * small rotation around (1,2,3)
     */
    static createRigidAxes() {
        return [
            Matrix3d_1.Matrix3d.createIdentity(),
            Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.unitX(), Angle_1.Angle.createDegrees(10)),
            Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.unitY(), Angle_1.Angle.createDegrees(10)),
            Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.unitZ(), Angle_1.Angle.createDegrees(10)),
            Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(1, 2, 3), Angle_1.Angle.createDegrees(10)),
        ];
    }
    /**
     * Return various Matrix4d
     * * Simple promotion of each Sample.createInvertibleTransforms ()
     * * optional nasty [1,2,3,4...15] row order
     * @param includeIrregular if true, include [1,2,..15] row major
     */ // promote each transform[] to a Matrix4d.
    static createMatrix4ds(includeIrregular = false) {
        const result = [];
        let transform;
        for (transform of Sample.createInvertibleTransforms())
            result.push(Matrix4d_1.Matrix4d.createTransform(transform));
        if (includeIrregular) {
            result.push(Matrix4d_1.Matrix4d.createRowValues(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16));
        }
        return result;
    }
    /**
     * Create full Map4d for each `Sample.createInvertibleTransforms ()`
     */
    static createMap4ds() {
        const result = [];
        let transform;
        for (transform of Sample.createInvertibleTransforms()) {
            const inverse = transform.inverse();
            if (inverse) {
                const map = Map4d_1.Map4d.createTransform(transform, inverse);
                if (map)
                    result.push(map);
            }
        }
        return result;
    }
    /** Assorted simple `Path` objects. */
    static createSimplePaths(withGaps = false) {
        const point0 = Point3dVector3d_1.Point3d.create(0, 0, 0);
        const point1 = Point3dVector3d_1.Point3d.create(10, 0, 0);
        const p1 = [point1, Point3dVector3d_1.Point3d.create(0, 10, 0), Point3dVector3d_1.Point3d.create(6, 10, 0), Point3dVector3d_1.Point3d.create(6, 10, 0), Point3dVector3d_1.Point3d.create(0, 10, 0)];
        const segment1 = LineSegment3d_1.LineSegment3d.create(point0, point1);
        const vectorU = Point3dVector3d_1.Vector3d.unitX(3);
        const vectorV = Point3dVector3d_1.Vector3d.unitY(3);
        const arc2 = Arc3d_1.Arc3d.create(point1.minus(vectorU), vectorU, vectorV, AngleSweep_1.AngleSweep.createStartEndDegrees(0, 90));
        const simplePaths = [
            Path_1.Path.create(segment1),
            Path_1.Path.create(segment1, arc2),
            Path_1.Path.create(LineSegment3d_1.LineSegment3d.create(point0, point1), LineString3d_1.LineString3d.create(p1)),
            Sample.createCappedArcPath(4, 0, 180),
        ];
        if (withGaps)
            simplePaths.push(Path_1.Path.create(LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(10, 0, 0)), LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(10, 10, 0), Point3dVector3d_1.Point3d.create(5, 0, 0))));
        return simplePaths;
    }
    /** Assorted `Path` with lines and arcs.
     * Specifically useful for offset tests.
     */
    static createLineArcPaths() {
        const paths = [];
        const x1 = 10.0;
        const y2 = 5.0;
        const y3 = 10.0;
        for (const y0 of [0, -1, 1]) {
            for (const x2 of [15, 11, 20, 9, 7]) {
                const point0 = Point3dVector3d_1.Point3d.create(0, y0, 0);
                const point1 = Point3dVector3d_1.Point3d.create(x1, 0, 0);
                const point2 = Point3dVector3d_1.Point3d.create(x2, y2, 0);
                const point3 = Point3dVector3d_1.Point3d.create(x1, y3, 0);
                const point4 = Point3dVector3d_1.Point3d.create(0, y3 + y0, 0);
                const path0 = Path_1.Path.create();
                path0.tryAddChild(LineString3d_1.LineString3d.create(point0, point1, point2, point3, point4));
                paths.push(path0);
                const path1 = Path_1.Path.create();
                path1.tryAddChild(LineSegment3d_1.LineSegment3d.create(point0, point1));
                path1.tryAddChild(Arc3d_1.Arc3d.createCircularStartMiddleEnd(point1, Point3dVector3d_1.Point3d.create(x2, y2, 0), point3));
                path1.tryAddChild(LineSegment3d_1.LineSegment3d.create(point3, point4));
                paths.push(path1);
            }
        }
        return paths;
    }
    /** Assorted `PointString3d` objects. */
    static createSimplePointStrings() {
        const p1 = [[Point3dVector3d_1.Point3d.create(0, 10, 0)], [Point3dVector3d_1.Point3d.create(6, 10, 0)], [Point3dVector3d_1.Point3d.create(6, 10, 0), [Point3dVector3d_1.Point3d.create(6, 10, 0)]]];
        const simplePaths = [
            PointString3d_1.PointString3d.create(Point3dVector3d_1.Point3d.create(1, 2, 0)),
            PointString3d_1.PointString3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(10, 0, 0)),
            PointString3d_1.PointString3d.create(Point3dVector3d_1.Point3d.create(10, 0, 0), Point3dVector3d_1.Point3d.create(10, 5, 0)),
            PointString3d_1.PointString3d.create(p1)
        ];
        return simplePaths;
    }
    /** Assorted `Loop` objects */
    static createSimpleLoops() {
        const point0 = Point3dVector3d_1.Point3d.create(0, 0, 0);
        const point1 = Point3dVector3d_1.Point3d.create(10, 0, 0);
        const point2 = Point3dVector3d_1.Point3d.create(10, 5, 0);
        const point3 = Point3dVector3d_1.Point3d.create(0, 5, 0);
        const result = [
            // rectangle with single linestring
            Loop_1.Loop.create(LineString3d_1.LineString3d.create(point0, point1, point2, point3, point0)),
            // unit circle
            Loop_1.Loop.create(Arc3d_1.Arc3d.createUnitCircle()),
            // rectangle, but with individual line segments
            Loop_1.Loop.create(LineSegment3d_1.LineSegment3d.create(point0, point1), LineSegment3d_1.LineSegment3d.create(point1, point2), LineSegment3d_1.LineSegment3d.create(point2, point3), LineSegment3d_1.LineSegment3d.create(point3, point0)),
            // Semicircle
            Sample.createCappedArcLoop(4, -90, 90),
        ];
        return result;
    }
    /**
     * Create a square wave along x direction
     * @param dx0 distance along x axis at y=0
     * @param dy vertical rise
     * @param dx1 distance along x axis at y=dy
     * @param numPhase number of phases of the jump.
     * @param dyReturn y value for return to origin.  If 0, the wave ends at y=0 after then final "down" with one extra horizontal dx0
     *     If nonzero, rise to that y value, return to x=0, and return down to origin.
     *
     */
    static createSquareWave(origin, dx0, dy, dx1, numPhase, dyReturn) {
        const result = [origin.clone()];
        for (let i = 0; i < numPhase; i++) {
            this.pushMove(result, dx0, 0);
            this.pushMove(result, 0, dy);
            this.pushMove(result, dx1, 0);
            this.pushMove(result, 0, -dy);
        }
        this.pushMove(result, dx0, 0);
        if (dyReturn !== 0.0) {
            this.pushMove(result, 0, dyReturn);
            result.push(Point3dVector3d_1.Point3d.create(origin.x, origin.y + dyReturn));
            result.push(result[0].clone());
        }
        return result;
    }
    /**
     * Create multiple interpolated points between two points
     * @param point0 start point (at fraction0)
     * @param point1 end point (at fraction1)
     * @param numPoints total number of points.  This is force to at least 2.
     * @param result optional existing array to receive points.
     * @param index0 optional index of first point.  Default is 0.
     * @param index1 optional index of final point.  Default is numPoints
     */
    static createInterpolatedPoints(point0, point1, numPoints, result, index0, index1) {
        if (numPoints < 2)
            numPoints = 2;
        if (result === undefined)
            result = [];
        if (index0 === undefined)
            index0 = 0;
        if (index1 === undefined)
            index1 = numPoints;
        for (let i = index0; i <= index1; i++) {
            result.push(point0.interpolate(i / numPoints, point1));
        }
        return result;
    }
    /**
     * Append numPhase teeth.  Each tooth starts with dxLow dwell at initial y, then sloped rise, then dwell at top, then sloped fall
     * * If no points are present, start with 000.  (this happens in pushMove) Otherwise start from final point.
     * * return points array reference.
     * @param points point array to receive points
     * @param dxLow starting step along x direction
     * @param riseX width of rising and falling parts
     * @param riseY height of rise
     * @param dxHigh width at top
     * @param numPhase number of phases.
     */
    static appendSawTooth(points, dxLow, riseX, riseY, dxHigh, numPhase) {
        for (let i = 0; i < numPhase; i++) {
            this.pushMove(points, dxLow, 0, 0);
            this.pushMove(points, riseX, riseY, 0);
            this.pushMove(points, dxHigh, 0, 0);
            this.pushMove(points, riseX, -riseY, 0);
        }
        return points;
    }
    /** append sawtooth with x distances successively scaled by xFactor */
    static appendVariableSawTooth(points, dxLow, riseX, riseY, dxHigh, numPhase, xFactor) {
        let factor = 1.0;
        for (let i = 0; i < numPhase; i++) {
            this.appendSawTooth(points, factor * dxLow, factor * riseX, riseY, factor * dxHigh, 1);
            factor *= xFactor;
        }
        return points;
    }
    /**
     * Create a pair of sawtooth patterns, one (nominally) outbound and up, the other inbound and down.
     * * return phase count adjusted to end at start x
     * * enter return dx values as lengths -- sign will be negated in construction.
     * @param origin start of entire path.
     * @param dxLow low outbound dwell
     * @param riseX x part of outbound rise and fall
     * @param riseY y part of outbound rise and fall
     * @param dxHigh high outbound dwell
     * @param numPhaseOutbound number of phases outbound.  Final phase followed by dxLow dwell.
     * @param dyFinal rise after final dwell.
     * @param dxLowReturn dwell at return high
     * @param riseXReturn rise x part of return
     * @param riseYReturn rise y part of return
     * @param dxHighReturn  dwell at return high
     */
    static createBidirectionalSawtooth(origin, dxLow, riseX, riseY, dxHigh, numPhaseOutbound, dyFinal, dxLowReturn, riseXReturn, riseYReturn, dxHighReturn) {
        const data = [origin.clone()];
        const x0 = data[0].x;
        this.appendSawTooth(data, dxLow, riseX, riseY, dxHigh, numPhaseOutbound);
        this.pushMove(data, dxLow, 0, 0);
        this.pushMove(data, 0, dyFinal);
        const x1 = data[data.length - 1].x;
        const returnPhase = Math.abs(dxLowReturn + 2 * riseXReturn + dxHighReturn);
        const totalDX = Math.abs(x1 - x0);
        const numReturnPhase = Math.floor(Math.abs(totalDX / returnPhase));
        this.appendSawTooth(data, -dxLowReturn, -riseXReturn, riseYReturn, -dxHighReturn, numReturnPhase);
        const x2 = data[data.length - 1].x;
        this.pushMove(data, x0 - x2, 0, 0);
        data.push(data[0].clone());
        return data;
    }
    /** append to a linestring, taking steps along given vector directions
     * If the linestring is empty, a 000 point is added.
     * @param linestring LineString3d to receive points.
     * @param numPhase number of phases of the sawtooth
     * @param vectors any number of vector steps.
     */
    static appendPhases(linestring, numPhase, ...vectors) {
        const tailPoint = linestring.endPoint(); // and this defaults to 000 . ..
        if (linestring.numPoints() === 0)
            linestring.addPoint(tailPoint);
        for (let i = 0; i < numPhase; i++) {
            for (const v of vectors) {
                tailPoint.addInPlace(v);
                linestring.addPoint(tailPoint);
            }
        }
    }
    /** Assorted regions with arc boundaries
     * * full circle
     * * with varying sweep:
     *    * partial arc with single chord closure
     *    * partial arc with 2-edge closure via center
     */
    static createArcRegions() {
        const result = [];
        const center = Point3dVector3d_1.Point3d.create(0, 0, 0);
        for (const sweep of [
            AngleSweep_1.AngleSweep.createStartEndDegrees(0, 360),
            AngleSweep_1.AngleSweep.createStartEndDegrees(-20, 20),
            AngleSweep_1.AngleSweep.createStartEndDegrees(0, 90),
            AngleSweep_1.AngleSweep.createStartEndDegrees(0, 180),
        ]) {
            const arc0 = Arc3d_1.Arc3d.createXY(Point3dVector3d_1.Point3d.create(0, 0), 2.0, sweep);
            if (arc0.sweep.isFullCircle) {
                result.push(Loop_1.Loop.create(arc0));
            }
            else {
                const chord = LineSegment3d_1.LineSegment3d.create(arc0.endPoint(), arc0.startPoint());
                result.push(Loop_1.Loop.create(arc0, chord));
                result.push(Loop_1.Loop.create(arc0, LineString3d_1.LineString3d.create(arc0.endPoint(), center, arc0.startPoint())));
            }
        }
        return result;
    }
    /** Assorted loops in xy plane:
     * * unit square
     * * rectangle
     * * L shape
     */
    static createSimpleXYPointLoops() {
        const result = [];
        result.push(Sample.createRectangleXY(0, 0, 1, 1));
        result.push(Sample.createRectangleXY(0, 0, 4, 3));
        result.push(Sample.createLShapedPolygon(0, 0, 5, 4, 1, 2));
        return result;
    }
    /** Assorted `ParityRegion` objects */
    static createSimpleParityRegions(includeBCurves = false) {
        const pointC = Point3dVector3d_1.Point3d.create(-5, 0, 0);
        const point0 = Point3dVector3d_1.Point3d.create(0, 0, 0);
        const point1 = Point3dVector3d_1.Point3d.create(4, 2, 0);
        const point2 = Point3dVector3d_1.Point3d.create(6, 4, 0);
        const point3 = Point3dVector3d_1.Point3d.create(5, 5, 0);
        const point4 = Point3dVector3d_1.Point3d.create(8, 3, 0);
        const reverseSweep = AngleSweep_1.AngleSweep.createStartEndDegrees(0, -360);
        const ax = 10.0;
        const ay = 8.0;
        const bx = -3.0;
        const by = 2.0;
        const r2 = 0.5;
        const r2A = 2.5;
        const pointA = point0.plusXYZ(ax, 0, 0);
        const pointB = pointA.plusXYZ(0, ay, 0);
        const pointC1 = point0.plusXYZ(0, ay);
        const result = [
            ParityRegion_1.ParityRegion.create(Loop_1.Loop.create(LineString3d_1.LineString3d.create(point0, pointA, pointB), Arc3d_1.Arc3d.createCircularStartMiddleEnd(pointB, pointC1, point0)), Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(point1, bx, by))),
            ParityRegion_1.ParityRegion.create(Loop_1.Loop.create(Arc3d_1.Arc3d.createXY(pointC, 2.0)), Loop_1.Loop.create(Arc3d_1.Arc3d.createXY(pointC, 1.0, reverseSweep))),
            ParityRegion_1.ParityRegion.create(Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(point0, ax, ay)), Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(point1, bx, by))),
            ParityRegion_1.ParityRegion.create(Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(point0, ax, ay)), Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(point1, bx, by)), Loop_1.Loop.create(Arc3d_1.Arc3d.createXY(point2, r2, reverseSweep))),
            ParityRegion_1.ParityRegion.create(Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(point0, ax, ay)), Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(point1, bx, by)), Loop_1.Loop.create(Arc3d_1.Arc3d.createXY(point2, r2, reverseSweep)), Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(point3, bx, by))),
            ParityRegion_1.ParityRegion.create(Loop_1.Loop.create(LineString3d_1.LineString3d.create(point0, pointA, pointB), Arc3d_1.Arc3d.createCircularStartMiddleEnd(pointB, pointC1, point0)), Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(point1, bx, by)), Loop_1.Loop.create(Arc3d_1.Arc3d.create(point4, Point3dVector3d_1.Vector3d.create(-r2, 0), Point3dVector3d_1.Vector3d.create(0, r2A))), Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(point3, bx, by))),
        ];
        if (includeBCurves) {
            const ey = 1.0;
            result.push(ParityRegion_1.ParityRegion.create(Loop_1.Loop.create(LineSegment3d_1.LineSegment3d.create(point0, pointA), BSplineCurve_1.BSplineCurve3d.createUniformKnots([pointA, Point3dVector3d_1.Point3d.create(ax + 1, ey),
                Point3dVector3d_1.Point3d.create(ax + 1, 2 * ey),
                Point3dVector3d_1.Point3d.create(ax + 2, 3 * ey),
                Point3dVector3d_1.Point3d.create(ax + 1, 4 * ey), pointB], 3), Arc3d_1.Arc3d.createCircularStartMiddleEnd(pointB, pointC1, point0))));
        }
        return result;
    }
    /** Union region. */
    static createSimpleUnions() {
        const parityRegions = Sample.createSimpleParityRegions();
        const parityRange = parityRegions[0].range();
        const ax = 3.0;
        const ay = 1.0;
        const bx = 4.0;
        const by = 2.0;
        const result = [
            UnionRegion_1.UnionRegion.create(Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(Point3dVector3d_1.Point3d.create(0, 0, 0), ax, ay)), Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(Point3dVector3d_1.Point3d.create(0, 2 * ay, 0), bx, by))),
            UnionRegion_1.UnionRegion.create(Loop_1.Loop.create(LineString3d_1.LineString3d.create(Sample.createRectangleXY(parityRange.low.x, parityRange.high.y + 0.5, parityRange.xLength(), parityRange.yLength()))), parityRegions[0])
        ];
        return result;
    }
    /** Assorted unstructured curve sets. */
    static createBagOfCurves() {
        const parityRegions = Sample.createSimpleParityRegions();
        const loops = Sample.createSimpleLoops();
        const result = [
            CurveCollection_1.BagOfCurves.create(loops[0], parityRegions[0], LineSegment3d_1.LineSegment3d.createXYXY(0, 1, 4, 2, 1)),
            // a bag with just an arc
            CurveCollection_1.BagOfCurves.create(Arc3d_1.Arc3d.createUnitCircle()),
            // a bag with just a line segment
            CurveCollection_1.BagOfCurves.create(LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(1, 1, 0))),
            // a bag with just a linestring
            CurveCollection_1.BagOfCurves.create(LineString3d_1.LineString3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(1, 1, 0), Point3dVector3d_1.Point3d.create(2, 1, 0))),
        ];
        return result;
    }
    /** Assorted smooth curve primitives:
     * * line segments
     * * arcs
     */
    static createSmoothCurvePrimitives(size = 1.0) {
        const alpha = 0.1;
        const beta = 0.3;
        return [
            LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(size, 0, 0)),
            LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(size, size, 0)),
            Arc3d_1.Arc3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Vector3d.create(size, 0, 0), Point3dVector3d_1.Vector3d.create(0, size, 0), AngleSweep_1.AngleSweep.createStartEndDegrees(0, 90)),
            Arc3d_1.Arc3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Vector3d.create(size, 0, 0), Point3dVector3d_1.Vector3d.create(0, size, 0), AngleSweep_1.AngleSweep.createStartEndDegrees(-40, 270)),
            Arc3d_1.Arc3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Vector3d.create(size, alpha * size, 0), Point3dVector3d_1.Vector3d.create(-alpha * beta * size, beta * size, 0), AngleSweep_1.AngleSweep.createStartEndDegrees(-40, 270)),
        ];
    }
    /** assorted small polyface grids, possibly expanded by gridMultiplier */
    static createSimpleIndexedPolyfaces(gridMultiplier) {
        return [
            Sample.createTriangularUnitGridPolyface(Point3dVector3d_1.Point3d.create(), Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitY(), gridMultiplier * 3, 2 * gridMultiplier, false, false, false),
            Sample.createTriangularUnitGridPolyface(Point3dVector3d_1.Point3d.create(), Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitY(), 3 * gridMultiplier, 2 * gridMultiplier, true, false, false),
            Sample.createTriangularUnitGridPolyface(Point3dVector3d_1.Point3d.create(), Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitY(), 3 * gridMultiplier, 2 * gridMultiplier, false, true, false),
            Sample.createTriangularUnitGridPolyface(Point3dVector3d_1.Point3d.create(), Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitY(), 3 * gridMultiplier, 2 * gridMultiplier, false, false, true),
            Sample.createTriangularUnitGridPolyface(Point3dVector3d_1.Point3d.create(), Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitY(), 3 * gridMultiplier, 2 * gridMultiplier, true, true, true),
        ];
    }
    /**
     * Build a mesh that is a (possibly skewed) grid in a plane.
     * @param origin "lower left" coordinate
     * @param vectorX step in "X" direction
     * @param vectorY step in "Y" direction
     * @param numXVertices number of vertices in X direction
     * @param numYVertices number of vertices in y direction
     * @param createParams true to create parameters, with paramter value `(i,j)` for point at (0 based) vertex in x,y directions
     * @param createNormals true to create a (single) normal indexed from all facets
     * @param createColors true to create a single color on each quad.  (shared between its triangles)
     * @note edgeVisible is false only on the diagonals
     */
    static createTriangularUnitGridPolyface(origin, vectorX, vectorY, numXVertices, numYVertices, createParams = false, createNormals = false, createColors = false) {
        const mesh = Polyface_1.IndexedPolyface.create(createNormals, createParams, createColors);
        const normal = vectorX.crossProduct(vectorY);
        if (createNormals) {
            normal.normalizeInPlace();
            mesh.addNormalXYZ(normal.x, normal.y, normal.z); // use XYZ to help coverage count!!
        }
        // Push to coordinate arrays
        for (let j = 0; j < numYVertices; j++) {
            for (let i = 0; i < numXVertices; i++) {
                mesh.addPoint(origin.plus2Scaled(vectorX, i, vectorY, j));
                if (createParams)
                    mesh.addParamUV(i, j);
            }
        }
        let color = 10; // arbitrarily start at color 10 so colorIndex is different from color.
        // Push elements to index array (vertices are calculated using i and j positioning for each point)
        let thisColorIndex = 0;
        for (let j = 0; j + 1 < numYVertices; j++) {
            for (let i = 0; i + 1 < numXVertices; i++) {
                const vertex00 = numXVertices * j + i;
                const vertex10 = vertex00 + 1;
                const vertex01 = vertex00 + numXVertices;
                const vertex11 = vertex01 + 1;
                // Push lower triangle
                mesh.addPointIndex(vertex00, true);
                mesh.addPointIndex(vertex10, true);
                mesh.addPointIndex(vertex11, false);
                // make color === faceIndex
                if (createColors) {
                    thisColorIndex = mesh.addColor(color++);
                    mesh.addColorIndex(thisColorIndex);
                    mesh.addColorIndex(thisColorIndex);
                    mesh.addColorIndex(thisColorIndex);
                }
                // param indexing matches points .  .
                if (createParams) {
                    mesh.addParamIndex(vertex00);
                    mesh.addParamIndex(vertex10);
                    mesh.addParamIndex(vertex11);
                }
                if (createNormals) {
                    mesh.addNormalIndex(0);
                    mesh.addNormalIndex(0);
                    mesh.addNormalIndex(0);
                }
                mesh.terminateFacet(false);
                // upper triangle
                mesh.addPointIndex(vertex11, true);
                mesh.addPointIndex(vertex01, true);
                mesh.addPointIndex(vertex00, false);
                // make color === faceIndex
                if (createColors) {
                    mesh.addColorIndex(thisColorIndex);
                    mesh.addColorIndex(thisColorIndex);
                    mesh.addColorIndex(thisColorIndex);
                }
                // param indexing matches points.
                if (createParams) {
                    mesh.addParamIndex(vertex11);
                    mesh.addParamIndex(vertex01);
                    mesh.addParamIndex(vertex00);
                }
                if (createNormals) {
                    mesh.addNormalIndex(0);
                    mesh.addNormalIndex(0);
                    mesh.addNormalIndex(0);
                }
                mesh.terminateFacet(false);
            }
        }
        return mesh;
    }
    /** Create an xy grid of points in single array with x varying fastest. */
    static createXYGrid(numU, numV, dX = 1.0, dY = 1.0) {
        const points = [];
        for (let j = 0; j < numV; j++) {
            for (let i = 0; i < numU; i++) {
                points.push(Point3dVector3d_1.Point3d.create(i * dX, j * dY, 0));
            }
        }
        return points;
    }
    /** Create simple bspline surface on xy plane grid. */
    static createXYGridBsplineSurface(numU, numV, orderU, orderV) {
        return BSplineSurface_1.BSplineSurface3d.create(Sample.createXYGrid(numU, numV, 1.0, 1.0), numU, orderU, undefined, numV, orderV, undefined);
    }
    /**
     * Create a bspline surface whose poles area on circular paths.
     * * (BUT not weighted bspline, therefore although u and v isolines "go around" they are not true circles.)
     * @param radiusU major radius
     * @param radiusV minor radius
     * @param numU number of facets around major hoop
     * @param numV number of facets around minor hoop
     * @param orderU major hoop order
     * @param orderV minor hoop order
     */
    static createPseudoTorusBsplineSurface(radiusU, radiusV, numU, numV, orderU, orderV) {
        const points = [];
        const numUPole = numU + orderU - 1;
        const numVPole = numV + orderV - 1;
        const uKnots = KnotVector_1.KnotVector.createUniformWrapped(numU, orderU - 1, 0, 1);
        const vKnots = KnotVector_1.KnotVector.createUniformWrapped(numV, orderV - 1, 0, 1);
        const dURadians = 2.0 * Math.PI / numU;
        const dVRadians = 2.0 * Math.PI / numV;
        for (let iV = 0; iV < numVPole; iV++) {
            const vRadians = iV * dVRadians;
            const cV = Math.cos(vRadians);
            const sV = Math.sin(vRadians);
            for (let iU = 0; iU < numUPole; iU++) {
                const uRadians = iU * dURadians;
                const cU = Math.cos(uRadians);
                const sU = Math.sin(uRadians);
                const rho = radiusU + cV * radiusV;
                points.push(Point3dVector3d_1.Point3d.create(rho * cU, rho * sU, sV * radiusV));
            }
        }
        const result = BSplineSurface_1.BSplineSurface3d.create(points, numUPole, orderU, uKnots.knots, numVPole, orderV, vKnots.knots);
        if (result) {
            result.setWrappable(0, KnotVector_1.BSplineWrapMode.OpenByAddingControlPoints);
            result.setWrappable(1, KnotVector_1.BSplineWrapMode.OpenByAddingControlPoints);
        }
        return result;
    }
    /**
     * Create a Bspline surface for a cone.
     * @param centerA center at section A
     * @param centerB center at section B
     * @param radiusA radius at point A
     * @param radiusB radius at point B
     */
    static createConeBsplineSurface(centerA, centerB, radiusA, radiusB, numSection) {
        if (numSection < 2)
            numSection = 2;
        const controlPoints = [];
        const numVPole = numSection;
        const q1 = 0.25;
        const q2 = 0.5;
        const q3 = 0.75;
        const uKnots = [0, 0, q1, q1, q2, q2, q3, q3, 1, 1];
        const vKnots = [];
        const dv = 1.0 / (numSection - 1);
        for (let i = 0; i < numSection; i++) {
            vKnots.push(i * dv);
        }
        const center = Point3dVector3d_1.Point3d.create();
        const vectorAB = Point3dVector3d_1.Vector3d.createStartEnd(centerA, centerB);
        const axes = Matrix3d_1.Matrix3d.createRigidHeadsUp(vectorAB, Geometry_1.AxisOrder.ZXY);
        let r0, r90, v;
        for (let iV = 0; iV < numVPole; iV++) {
            v = iV * dv;
            centerA.interpolate(v, centerB, center);
            r0 = r90 = Geometry_1.Geometry.interpolate(radiusA, v, radiusB);
            controlPoints.push(Sample.createBsplineArc90SectionToXYZWArrays(center, axes, r0, r90, false));
        }
        const result = BSplineSurface_1.BSplineSurface3dH.createGrid(controlPoints, BSplineSurface_1.WeightStyle.WeightsSeparateFromCoordinates, 3, uKnots, 2, vKnots);
        // if (result) {
        // result.setWrappable(0, BSplineWrapMode.OpenByAddingControlPoints);
        // result.setWrappable(1, BSplineWrapMode.OpenByAddingControlPoints);
        // }
        return result;
    }
    /** Create bspline surface on xy grid with weights. */
    static createWeightedXYGridBsplineSurface(numU, numV, orderU, orderV, weight00 = 1.0, weight10 = 1.0, weight01 = 1.0, weight11 = 1.0) {
        const xyzPoles = Sample.createXYGrid(numU, numV, 1.0, 1.0);
        const weights = [];
        for (let i = 0; i < numU; i++)
            for (let j = 0; j < numV; j++) {
                const wu0 = Geometry_1.Geometry.interpolate(weight00, i / (numU - 1), weight10);
                const wu1 = Geometry_1.Geometry.interpolate(weight01, i / (numU - 1), weight11);
                weights.push(Geometry_1.Geometry.interpolate(wu0, j / (numV - 1), wu1));
            }
        return BSplineSurface_1.BSplineSurface3dH.create(xyzPoles, weights, numU, orderU, undefined, numV, orderV, undefined);
    }
    /** assorted linear sweeps */
    static createSimpleLinearSweeps() {
        const result = [];
        const base = Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(Point3dVector3d_1.Point3d.create(), 2, 3));
        const vectorZ = Point3dVector3d_1.Vector3d.create(0, 0, 1.234);
        const vectorQ = Point3dVector3d_1.Vector3d.create(0.1, 0.21, 1.234);
        result.push(LinearSweep_1.LinearSweep.create(base, vectorZ, false));
        result.push(LinearSweep_1.LinearSweep.create(base, vectorZ, true));
        result.push(LinearSweep_1.LinearSweep.create(base, vectorQ, false));
        result.push(LinearSweep_1.LinearSweep.create(base, vectorQ, true));
        result.push(LinearSweep_1.LinearSweep.create(Sample.createCappedArcLoop(5, -45, 90), vectorQ, true));
        for (const curve of Sample.createSmoothCurvePrimitives()) {
            const path = Path_1.Path.create(curve);
            result.push(LinearSweep_1.LinearSweep.create(path, vectorZ, false));
        }
        // coordinates for a clearly unclosed linestring ....
        const xyPoints = [
            Point2dVector2d_1.Point2d.create(0, 0),
            Point2dVector2d_1.Point2d.create(1, 0),
            Point2dVector2d_1.Point2d.create(1, 1)
        ];
        result.push(LinearSweep_1.LinearSweep.createZSweep(xyPoints, 1, 3, false));
        // this forces artificial closure point . . .
        result.push(LinearSweep_1.LinearSweep.createZSweep(xyPoints, 1, 3, true));
        // add a not-quite-exact closure point ...
        const e = 1.0e-11;
        xyPoints.push(Point2dVector2d_1.Point2d.create(e, e));
        result.push(LinearSweep_1.LinearSweep.createZSweep(xyPoints, 1, 3, false));
        result.push(LinearSweep_1.LinearSweep.createZSweep(xyPoints, 1, 3, true));
        // make it a better closure
        xyPoints.pop();
        xyPoints.push(xyPoints[0]);
        result.push(LinearSweep_1.LinearSweep.createZSweep(xyPoints, 1, 3, false));
        result.push(LinearSweep_1.LinearSweep.createZSweep(xyPoints, 1, 3, true));
        // negative sweep ...
        result.push(LinearSweep_1.LinearSweep.createZSweep(xyPoints, 1, -3, true));
        return result;
    }
    /**
     * Create an array of primitives with an arc centered at origin and a line segment closing back to the arc start.
     * This can be bundled into Path or Loop by caller.
     */
    static createCappedArcPrimitives(radius, startDegrees, endDegrees) {
        const arc = Arc3d_1.Arc3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Vector3d.unitX(radius), Point3dVector3d_1.Vector3d.unitY(radius), AngleSweep_1.AngleSweep.createStartEndDegrees(startDegrees, endDegrees));
        return [arc, LineSegment3d_1.LineSegment3d.create(arc.fractionToPoint(1.0), arc.fractionToPoint(0.0))];
    }
    /** Return a Path structure for a segment of arc, with closure segment */
    static createCappedArcPath(radius, startDegrees, endDegrees) {
        return Path_1.Path.createArray(Sample.createCappedArcPrimitives(radius, startDegrees, endDegrees));
    }
    /** Return a Loop structure for a segment of arc, with closure segment */
    static createCappedArcLoop(radius, startDegrees, endDegrees) {
        return Loop_1.Loop.createArray(Sample.createCappedArcPrimitives(radius, startDegrees, endDegrees));
    }
    /** Create assorted rotational sweeps. */
    static createSimpleRotationalSweeps() {
        const result = [];
        // rectangle in xy plane
        const base = Loop_1.Loop.create(LineString3d_1.LineString3d.createRectangleXY(Point3dVector3d_1.Point3d.create(1, 0, 0), 2, 3));
        // rotate around the y axis
        for (const axis of [
            Ray3d_1.Ray3d.createXYZUVW(0, 0, 0, 0, 1, 0),
            Ray3d_1.Ray3d.createXYZUVW(5, 0, 0, 0, 1, 0),
            Ray3d_1.Ray3d.createXYZUVW(-1, 0, 0, -1, 1, 0)
        ]) {
            result.push(RotationalSweep_1.RotationalSweep.create(base, axis, Angle_1.Angle.createDegrees(45.0), false));
            result.push(RotationalSweep_1.RotationalSweep.create(base, axis, Angle_1.Angle.createDegrees(150.0), true));
        }
        return result;
    }
    /** Create assorted spheres */
    static createSpheres(includeEllipsoidal = false) {
        const result = [];
        result.push(Sphere_1.Sphere.createCenterRadius(Point3dVector3d_1.Point3d.create(0, 0, 0), 1.0));
        result.push(Sphere_1.Sphere.createCenterRadius(Point3dVector3d_1.Point3d.create(1, 2, 3), 3.0));
        const s1 = Sphere_1.Sphere.createCenterRadius(Point3dVector3d_1.Point3d.create(1, 2, 3), 2.0, AngleSweep_1.AngleSweep.createStartEndDegrees(-45, 80));
        s1.capped = true;
        result.push(s1);
        // still a sphere, but with axes KIJ . .
        const s2 = Sphere_1.Sphere.createFromAxesAndScales(Point3dVector3d_1.Point3d.create(1, 2, 3), Matrix3d_1.Matrix3d.createRowValues(0, 1, 0, 0, 0, 1, 1, 0, 0), 4, 4, 4, AngleSweep_1.AngleSweep.createStartEndDegrees(-45, 45), true);
        result.push(s2);
        if (includeEllipsoidal)
            result.push(Sphere_1.Sphere.createDgnSphere(Point3dVector3d_1.Point3d.create(1, 2, 3), Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitZ(), 3, 2, AngleSweep_1.AngleSweep.createFullLatitude(), false));
        return result;
    }
    /** Create true (non-spherical) ellipsoids. */
    static createEllipsoids() {
        return [
            Sphere_1.Sphere.createEllipsoid(Transform_1.Transform.createOriginAndMatrix(Point3dVector3d_1.Point3d.create(0, 0, 0), Matrix3d_1.Matrix3d.createRowValues(4, 1, 1, 1, 4, 1, 0.5, 0.2, 5)), AngleSweep_1.AngleSweep.createFullLatitude(), true)
        ];
    }
    /** Create assorted cones. */
    static createCones() {
        const result = [];
        const origin = Point3dVector3d_1.Point3d.create(0, 0, 0);
        const topZ = Point3dVector3d_1.Point3d.create(0, 0, 5);
        const centerA = Point3dVector3d_1.Point3d.create(1, 2, 1);
        const centerB = Point3dVector3d_1.Point3d.create(2, 3, 8);
        result.push(Cone_1.Cone.createAxisPoints(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(0, 0, 1), 0.5, 0.5, false));
        result.push(Cone_1.Cone.createAxisPoints(centerA, centerB, 0.5, 0.5, false));
        result.push(Cone_1.Cone.createAxisPoints(origin, topZ, 1.0, 0.2, true));
        result.push(Cone_1.Cone.createAxisPoints(centerA, centerB, 0.2, 0.5, false));
        result.push(Cone_1.Cone.createAxisPoints(origin, centerB, 1.0, 0.0, false));
        result.push(Cone_1.Cone.createAxisPoints(topZ, origin, 0.0, 1.0, true));
        return result;
    }
    /** Create assorted Torus Pipes */
    static createTorusPipes() {
        const result = [];
        const center = Point3dVector3d_1.Point3d.create(1, 2, 3);
        const frame = Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(1, 2, 3), Angle_1.Angle.createRadians(10));
        const vectorX = frame.columnX();
        const vectorY = frame.columnY();
        const vectorZ = frame.columnZ();
        result.push(TorusPipe_1.TorusPipe.createInFrame(Transform_1.Transform.createIdentity(), 5.0, 0.8, Angle_1.Angle.create360(), false));
        result.push(TorusPipe_1.TorusPipe.createInFrame(Transform_1.Transform.createIdentity(), 5.0, 1.0, Angle_1.Angle.createDegrees(90), true));
        result.push(TorusPipe_1.TorusPipe.createDgnTorusPipe(center, vectorX, vectorY, 10, 1, Angle_1.Angle.createDegrees(180), true));
        result.push(TorusPipe_1.TorusPipe.createDgnTorusPipe(center, vectorY, vectorZ, 10, 1, Angle_1.Angle.createDegrees(45), true));
        return result;
    }
    /** Create assorted boxes. */
    static createBoxes(capped = true) {
        const result = [];
        const cornerA = Point3dVector3d_1.Point3d.create(1, 2, 3);
        const aX = 3.0;
        const aY = 2.0;
        const bX = 1.5;
        const bY = 1.0;
        const h = 5.0;
        const frame = Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(0, 0, 1), Angle_1.Angle.createDegrees(10));
        const vectorX = frame.columnX();
        const vectorY = frame.columnY();
        const cornerB = Matrix3d_1.Matrix3d.xyzPlusMatrixTimesCoordinates(cornerA, frame, 0, 0, h);
        result.push(Box_1.Box.createDgnBox(cornerA, Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitY(), cornerB, aX, aY, aX, aY, capped));
        result.push(Box_1.Box.createDgnBox(cornerA, Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitY(), cornerB, aX, aY, bX, bY, capped));
        result.push(Box_1.Box.createDgnBox(cornerA, vectorX, vectorY, cornerB, aX, aY, bX, bY, capped));
        const frameY = Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.create(0, 1, 0), Angle_1.Angle.createDegrees(10));
        result.push(Box_1.Box.createDgnBox(cornerA, frameY.columnX(), frameY.columnY(), cornerA.plusScaled(frameY.columnZ(), h), aX, aY, bX, bY, capped));
        return result;
    }
    /** create an array of points for a rectangle with corners (x0,y0,z) and (x1,y1,z)
     */
    static createRectangle(x0, y0, x1, y1, z = 0.0, closed = false) {
        const points = [
            Point3dVector3d_1.Point3d.create(x0, y0, z),
            Point3dVector3d_1.Point3d.create(x1, y0, z),
            Point3dVector3d_1.Point3d.create(x1, y1, z),
            Point3dVector3d_1.Point3d.create(x0, y1, z),
        ];
        if (closed)
            points.push(Point3dVector3d_1.Point3d.create(x0, y0, z));
        return points;
    }
    /** create an array of points for a rectangle with corners of a Range2d.
     */
    static createRectangleInRange2d(range, z = 0.0, closed = false) {
        const x0 = range.low.x;
        const x1 = range.high.x;
        const y0 = range.low.y;
        const y1 = range.high.y;
        return this.createRectangle(x0, y0, x1, y1, z, closed);
    }
    /** Create assorted ruled sweeps */
    static createRuledSweeps(includeParityRegion = false, includeBagOfCurves = false) {
        const allSweeps = [];
        const contour0 = Loop_1.Loop.create(LineString3d_1.LineString3d.create(this.createRectangleXY(0, 0, 3, 2, 0)));
        const contour1 = Loop_1.Loop.create(LineString3d_1.LineString3d.create(this.createRectangleXY(0, 0, 3, 2.5, 2)));
        const contour2 = Loop_1.Loop.create(LineString3d_1.LineString3d.create(this.createRectangleXY(0, 0, 4, 3.5, 4)));
        const contour3 = Loop_1.Loop.create(LineString3d_1.LineString3d.create(this.createRectangleXY(0, 0, 2, 1, 7)));
        const allContours = [contour0, contour1, contour2];
        allSweeps.push(RuledSweep_1.RuledSweep.create([contour0, contour1], true));
        allSweeps.push(RuledSweep_1.RuledSweep.create([contour0, contour1, contour2], true));
        allSweeps.push(RuledSweep_1.RuledSweep.create([contour0, contour1, contour2, contour3], true));
        allSweeps.push(RuledSweep_1.RuledSweep.create(allContours, false));
        const curves = Sample.createSmoothCurvePrimitives();
        for (const c of curves) {
            const frame = c.fractionToFrenetFrame(0.0);
            if (frame) {
                const perpVector = frame.matrix.columnZ();
                perpVector.scaleInPlace(10.0);
                const c1 = c.cloneTransformed(Transform_1.Transform.createTranslation(perpVector));
                allSweeps.push(RuledSweep_1.RuledSweep.create([Path_1.Path.create(c), Path_1.Path.create(c1)], false));
            }
        }
        if (includeParityRegion) {
            const outer = Loop_1.Loop.create(LineString3d_1.LineString3d.create(this.createRectangleXY(0, 0, 5, 6, 0)));
            const inner = Loop_1.Loop.create(LineString3d_1.LineString3d.create(this.createRectangleXY(1, 1, 2, 3, 0)));
            const contourA = ParityRegion_1.ParityRegion.create(outer, inner);
            const contourB = contourA.clone();
            contourB.tryTranslateInPlace(0, 0, 2);
            allSweeps.push(RuledSweep_1.RuledSweep.create([contourA, contourB], false));
        }
        if (includeBagOfCurves) {
            const contourA = CurveCollection_1.BagOfCurves.create(LineSegment3d_1.LineSegment3d.createXYZXYZ(1, 1, 0, 3, 1, 0));
            const contourB = CurveCollection_1.BagOfCurves.create(LineSegment3d_1.LineSegment3d.createXYZXYZ(1, 1, 1, 3, 1, 1));
            allSweeps.push(RuledSweep_1.RuledSweep.create([contourA, contourB], false));
        }
        return allSweeps;
    }
    /**
     * Uniformly spaced numbers
     * @param a0 first entry
     * @param delta step between entries
     * @param n number of entries
     */
    static createGrowableArrayCountedSteps(a0, delta, n) {
        const data = new GrowableFloat64Array_1.GrowableFloat64Array(n);
        for (let i = 0; i < n; i++)
            data.push(a0 + i * delta);
        return data;
    }
    /**
     * Create points on a unit circle
     * @param radius first entry
     * @param numEdge number of edges of chorded circle.  Angle step is 2PI/numEdge (whether or not closed)
     * @param closed true to include final point (i.e. return numEdge+1 points)
     */
    static createGrowableArrayCirclePoints(radius, numEdge, closed = false, centerX = 0, centerY = 0, data) {
        if (!data)
            data = new GrowableXYZArray_1.GrowableXYZArray();
        data.ensureCapacity(numEdge + (closed ? 1 : 0));
        const delta = 2.0 * Math.PI / numEdge;
        for (let i = 0; i < numEdge; i++) {
            const radians = i * delta;
            data.push(Point3dVector3d_1.Point3d.create(centerX + radius * Math.cos(radians), centerY + radius * Math.sin(radians)));
        }
        return data;
    }
    static pushIfDistinct(points, xyz, tol = 1.0e-12) {
        if (points.length === 0 || points[points.length - 1].distanceXY(xyz) > tol)
            points.push(xyz);
    }
    static appendToFractalEval(points, pointA, pointB, pattern, numRecursion, perpendicularFactor) {
        const point0 = pointA.clone();
        Sample.pushIfDistinct(points, pointA);
        for (const uv of pattern) {
            const point1 = pointA.interpolatePerpendicularXY(uv.x, pointB, perpendicularFactor * uv.y);
            if (numRecursion > 0)
                Sample.appendToFractalEval(points, point0, point1, pattern, numRecursion - 1, perpendicularFactor);
            Sample.pushIfDistinct(points, point1);
            point0.setFrom(point1);
        }
        Sample.pushIfDistinct(points, pointB);
    }
    /**
     * For each edge of points, construct a transform (with scale, rotate, and translate) that spreads the patter out along the edge.
     * Repeat recursively for each edge
     * @returns Returns an array of recursively generated fractal points
     * @param poles level-0 (coarse) polygon whose edges are to be replaced by recursive fractals
     * @param pattern pattern to map to each edge of poles (and to edges of the recursion)
     * @param numRecursion  number of recursions
     * @param perpendicularFactor factor to apply to perpendicular sizing.
     */
    static createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor) {
        const points = [];
        Sample.pushIfDistinct(points, poles[0]);
        for (let i = 0; i + 1 < poles.length; i++) {
            if (numRecursion > 0)
                Sample.appendToFractalEval(points, poles[i], poles[i + 1], pattern, numRecursion - 1, perpendicularFactor);
            Sample.pushIfDistinct(points, poles[i + 1]);
        }
        return points;
    }
    /** Primary shape is a "triangle" with lower edge pushed in so it becomes a mild nonconvex quad.
     *  Fractal effects are gentle.
     */
    static nonConvexQuadSimpleFractal(numRecursion, perpendicularFactor) {
        const pattern = [
            Point2dVector2d_1.Point2d.create(),
            Point2dVector2d_1.Point2d.create(0.5, 0.1),
            Point2dVector2d_1.Point2d.create(1.0, 0.0),
        ];
        const poles = [
            Point3dVector3d_1.Point3d.create(0, 0, 0),
            Point3dVector3d_1.Point3d.create(0.6, 0.1, 0),
            Point3dVector3d_1.Point3d.create(1, 0.1, 0),
            Point3dVector3d_1.Point3d.create(0.6, 1, 0),
            Point3dVector3d_1.Point3d.create(),
        ];
        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);
    }
    /** create a diamond with convex fractal */
    static createFractalDiamondConvexPattern(numRecursion, perpendicularFactor) {
        const pattern = [
            Point2dVector2d_1.Point2d.create(),
            Point2dVector2d_1.Point2d.create(0.3, 0.05),
            Point2dVector2d_1.Point2d.create(0.5, 0.10),
            Point2dVector2d_1.Point2d.create(0.7, 0.04),
            Point2dVector2d_1.Point2d.create(1.0, 0.0),
        ];
        const poles = [
            Point3dVector3d_1.Point3d.create(0, -1, 0),
            Point3dVector3d_1.Point3d.create(1, 0, 0),
            Point3dVector3d_1.Point3d.create(0, 1, 0),
            Point3dVector3d_1.Point3d.create(-1, 0, 0),
            Point3dVector3d_1.Point3d.create(0, -1, 0),
        ];
        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);
    }
    /** Create l on a square, with pattern shift to both directions. */
    static createFractalSquareReversingPattern(numRecursion, perpendicularFactor) {
        const pattern = [
            Point2dVector2d_1.Point2d.create(),
            Point2dVector2d_1.Point2d.create(0.25, 0),
            Point2dVector2d_1.Point2d.create(0.5, 0.2),
            Point2dVector2d_1.Point2d.create(0.75, -0.1),
            Point2dVector2d_1.Point2d.create(1.0, 0.0),
        ];
        const poles = [
            Point3dVector3d_1.Point3d.create(),
            Point3dVector3d_1.Point3d.create(1, 0, 0),
            Point3dVector3d_1.Point3d.create(1, 1, 0),
            Point3dVector3d_1.Point3d.create(0, 1, 0),
            Point3dVector3d_1.Point3d.create(0, 0, 0),
        ];
        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);
    }
    /** Create a fractal on a non-convex base and reversing pattern */
    static createFractalHatReversingPattern(numRecursion, perpendicularFactor) {
        const pattern = [
            Point2dVector2d_1.Point2d.create(),
            Point2dVector2d_1.Point2d.create(0.25, 0),
            Point2dVector2d_1.Point2d.create(0.25, 0.1),
            Point2dVector2d_1.Point2d.create(0.50, 0.1),
            Point2dVector2d_1.Point2d.create(0.50, -0.1),
            Point2dVector2d_1.Point2d.create(0.75, -0.1),
            Point2dVector2d_1.Point2d.create(0.75, 0),
            Point2dVector2d_1.Point2d.create(1.0, 0.0),
        ];
        const poles = [
            Point3dVector3d_1.Point3d.create(),
            Point3dVector3d_1.Point3d.create(1, 0, 0),
            Point3dVector3d_1.Point3d.create(1, 1, 0),
            Point3dVector3d_1.Point3d.create(0, 1, 0),
            Point3dVector3d_1.Point3d.create(0, 0, 0),
        ];
        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);
    }
    /** Create a fractal on a primary L shape with a reversing pattern */
    static createFractalLReversingPattern(numRecursion, perpendicularFactor) {
        const pattern = [
            Point2dVector2d_1.Point2d.create(),
            Point2dVector2d_1.Point2d.create(0.25, 0),
            Point2dVector2d_1.Point2d.create(0.5, 0.2),
            Point2dVector2d_1.Point2d.create(0.75, -0.1),
            Point2dVector2d_1.Point2d.create(1.0, 0.0),
        ];
        const poles = [
            Point3dVector3d_1.Point3d.create(),
            Point3dVector3d_1.Point3d.create(1, 0, 0),
            Point3dVector3d_1.Point3d.create(1, 1, 0),
            Point3dVector3d_1.Point3d.create(2, 2, 0),
            Point3dVector3d_1.Point3d.create(2, 3, 0),
            Point3dVector3d_1.Point3d.create(0, 3, 0),
            Point3dVector3d_1.Point3d.create(),
        ];
        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);
    }
    /** Fractal with fewer concavity changes.... */
    static createFractalLMildConcavePatter(numRecursion, perpendicularFactor) {
        const pattern = [
            Point2dVector2d_1.Point2d.create(),
            Point2dVector2d_1.Point2d.create(0.25, 0.05),
            Point2dVector2d_1.Point2d.create(0.5, 0.15),
            Point2dVector2d_1.Point2d.create(0.75, 0.05),
            Point2dVector2d_1.Point2d.create(1.0, 0.0),
        ];
        const poles = [
            Point3dVector3d_1.Point3d.create(),
            Point3dVector3d_1.Point3d.create(1, 0, 0),
            Point3dVector3d_1.Point3d.create(1, 1, 0),
            Point3dVector3d_1.Point3d.create(2, 2, 0),
            Point3dVector3d_1.Point3d.create(1.5, 3, 0),
            Point3dVector3d_1.Point3d.create(0, 3, 0),
            Point3dVector3d_1.Point3d.create(),
        ];
        return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);
    }
    /** append interpolated points from the array tail to the target. */
    static appendSplits(points, target, numSplit, includeTarget) {
        const pointA = points[points.length - 1];
        for (let i = 0; i < numSplit; i++)
            points.push(pointA.interpolate(i / numSplit, target));
        if (includeTarget)
            points.push(target);
    }
    /**
     * Triangle with 3 given vertices, and indicated extra points on each each.
     * @param numSplitAB number of extra points on edge AB
     * @param numSplitBC number of extra points on edge BC
     * @param numSplitCA number of extra points on edge CA
     * @param wrap true to replicate vertexA at end
     * @param xyzA vertexA
     * @param xyzB vertexB
     * @param xyzC vertexC
     */
    static createTriangleWithSplitEdges(numSplitAB, numSplitBC, numSplitCA, wrap = true, xyzA = Point3dVector3d_1.Point3d.create(0, 0, 0), xyzB = Point3dVector3d_1.Point3d.create(1, 0, 0), xyzC = Point3dVector3d_1.Point3d.create(0, 1, 0)) {
        const result = [xyzA.clone()];
        Sample.appendSplits(result, xyzB, numSplitAB, true);
        Sample.appendSplits(result, xyzC, numSplitBC, true);
        Sample.appendSplits(result, xyzA, numSplitCA, wrap);
        return result;
    }
    /** Create a box (xyz) from half-lengths and center. */
    static createCenteredBoxEdges(ax = 1, ay = 1, az = 0, cx = 0, cy = 0, cz = 0, geometry) {
        if (!geometry)
            geometry = [];
        const x0 = cx - ax;
        const y0 = cy - ay;
        const z0 = cz - az;
        const x1 = cx + ax;
        const y1 = cy + ay;
        const z1 = cz + az;
        for (const z of [z0, z1]) {
            geometry.push(LineString3d_1.LineString3d.create(Point3dVector3d_1.Point3d.create(x0, y0, z), Point3dVector3d_1.Point3d.create(x1, y0, z), Point3dVector3d_1.Point3d.create(x1, y1, z), Point3dVector3d_1.Point3d.create(x0, y1, z), Point3dVector3d_1.Point3d.create(x0, y0, z)));
        }
        geometry.push(LineSegment3d_1.LineSegment3d.createXYZXYZ(x0, y0, z0, x0, y0, z1));
        geometry.push(LineSegment3d_1.LineSegment3d.createXYZXYZ(x1, y0, z0, x1, y0, z1));
        geometry.push(LineSegment3d_1.LineSegment3d.createXYZXYZ(x1, y1, z0, x1, y1, z1));
        geometry.push(LineSegment3d_1.LineSegment3d.createXYZXYZ(x0, y1, z0, x0, y1, z1));
        return geometry;
    }
    /** Assorted transition spirals
     * * (All combinations of bearing radius bearing radius length subsets.)
     */
    static createSimpleTransitionSpirals() {
        // 5 spirals exercise the intricate "4 out of 5" input rules for spirals . ..
        const r1 = 1000.0;
        const r0 = 0.0;
        const averageCurvature = TransitionSpiral_1.TransitionSpiral3d.averageCurvatureR0R1(r0, r1);
        const arcLength = 100.0;
        const dThetaRadians = arcLength * averageCurvature;
        return [
            TransitionSpiral_1.TransitionSpiral3d.create("clothoid", r0, r1, Angle_1.Angle.createDegrees(0), Angle_1.Angle.createRadians(dThetaRadians), undefined, undefined, Transform_1.Transform.createIdentity()),
            TransitionSpiral_1.TransitionSpiral3d.create("clothoid", r0, r1, Angle_1.Angle.createDegrees(0), undefined, arcLength, undefined, Transform_1.Transform.createIdentity()),
            TransitionSpiral_1.TransitionSpiral3d.create("clothoid", r0, r1, undefined, Angle_1.Angle.createRadians(dThetaRadians), arcLength, undefined, Transform_1.Transform.createIdentity()),
            TransitionSpiral_1.TransitionSpiral3d.create("clothoid", r0, undefined, Angle_1.Angle.createDegrees(0), Angle_1.Angle.createRadians(dThetaRadians), arcLength, undefined, Transform_1.Transform.createIdentity()),
            TransitionSpiral_1.TransitionSpiral3d.create("clothoid", undefined, r1, Angle_1.Angle.createDegrees(0), Angle_1.Angle.createRadians(dThetaRadians), arcLength, undefined, Transform_1.Transform.createIdentity()),
            TransitionSpiral_1.TransitionSpiral3d.create("clothoid", r0, r1, Angle_1.Angle.createDegrees(0), Angle_1.Angle.createRadians(dThetaRadians), undefined, Segment1d_1.Segment1d.create(0, 0.5), Transform_1.Transform.createOriginAndMatrix(Point3dVector3d_1.Point3d.create(1, 2, 0), Matrix3d_1.Matrix3d.createRotationAroundVector(Point3dVector3d_1.Vector3d.unitZ(), Angle_1.Angle.createDegrees(15)))),
        ];
    }
    /** Create a Bezier curve with significant twist effects
     * * r and theta are circle in xy plane at steps in thetaStepper
     * * z varies with sin(phi) at steps in phiStepper.
     */
    static createTwistingBezier(order, x0, y0, r, thetaStepper, phiStepper, weightInterval) {
        if (weightInterval !== undefined) {
            const points = [];
            for (let i = 0; i < order; i++) {
                const theta = thetaStepper.fractionToRadians(i);
                const phi = phiStepper.fractionToRadians(i);
                const weight = weightInterval.fractionToPoint(i / (order - 1));
                points.push(Point4d_1.Point4d.create(weight * (x0 + r * Math.cos(theta)), weight * (y0 + r * Math.sin(theta)), weight * Math.sin(phi), weight));
            }
            return BezierCurve3dH_1.BezierCurve3dH.create(points);
        }
        else {
            const points = [];
            for (let i = 0; i < order; i++) {
                const theta = thetaStepper.fractionToRadians(i);
                const phi = phiStepper.fractionToRadians(i);
                points.push(Point3dVector3d_1.Point3d.create(x0 + r * Math.cos(theta), y0 + r * Math.sin(theta), Math.sin(phi)));
            }
            return BezierCurve3d_1.BezierCurve3d.create(points);
        }
        return undefined;
    }
    /**
     * Create various curve chains with distance indexing.
     * * LineSegment
     * * CircularArc
     * * LineString
     * * order 3 bspline
     * * order 4 bspline
     * * alternating lines and arcs
     */
    static createCurveChainWithDistanceIndex() {
        const pointsA = [Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(1, 3, 0), Point3dVector3d_1.Point3d.create(2, 4, 0), Point3dVector3d_1.Point3d.create(3, 3, 0), Point3dVector3d_1.Point3d.create(4, 0, 0)];
        const result = [];
        // one singleton per basic curve type ...
        result.push(CurveChainWithDistanceIndex_1.CurveChainWithDistanceIndex.createCapture(Path_1.Path.create(LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(5, 0, 0)))));
        result.push(CurveChainWithDistanceIndex_1.CurveChainWithDistanceIndex.createCapture(Path_1.Path.create(Arc3d_1.Arc3d.createCircularStartMiddleEnd(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(3, 3, 0), Point3dVector3d_1.Point3d.create(6, 0, 0)))));
        result.push(CurveChainWithDistanceIndex_1.CurveChainWithDistanceIndex.createCapture(Path_1.Path.create(LineString3d_1.LineString3d.create(pointsA))));
        result.push(CurveChainWithDistanceIndex_1.CurveChainWithDistanceIndex.createCapture(Path_1.Path.create(BSplineCurve_1.BSplineCurve3d.createUniformKnots(pointsA, 3))));
        result.push(CurveChainWithDistanceIndex_1.CurveChainWithDistanceIndex.createCapture(Path_1.Path.create(BSplineCurve_1.BSplineCurve3d.createUniformKnots(pointsA, 4))));
        result.push(CurveChainWithDistanceIndex_1.CurveChainWithDistanceIndex.createCapture(Path_1.Path.create(LineSegment3d_1.LineSegment3d.create(pointsA[0], pointsA[1]), Arc3d_1.Arc3d.createCircularStartMiddleEnd(pointsA[1], pointsA[2], pointsA[3]), LineSegment3d_1.LineSegment3d.create(pointsA[3], pointsA[4]))));
        return result;
    }
    /**
     * Create a square wave path.
     * @param numTooth number of teeth.
     * @param dxA x size of "A" part
     * @param dxB x size of "B" part
     * @param yA y for A part
     * @param yB y for B part
     * @param structure 1 for line segments, 2 for one linestring per tooth, 0 for single linestring
     */
    static createSquareWavePath(numTooth, dxA, dxB, yA, yB, structure) {
        const dxAB = dxA + dxB;
        const path = Path_1.Path.create();
        // build the whole linestring ...
        const allPoints = new GrowableXYZArray_1.GrowableXYZArray(4 * numTooth);
        let x2 = 0.0;
        for (let i = 0; i < numTooth; i++) {
            const x0 = i * dxAB;
            const x1 = x0 + dxA;
            x2 = (i + 1) * dxAB;
            allPoints.pushXYZ(x0, yA, 0);
            allPoints.pushXYZ(x1, yA, 0.0);
            allPoints.pushXYZ(x1, yB, 0.0);
            allPoints.pushXYZ(x2, yB, 0.0);
        }
        allPoints.pushXYZ(x2, yA, 0.0);
        const numPoints = allPoints.length;
        if (structure === 1) {
            const pointA = Point3dVector3d_1.Point3d.create();
            const pointB = Point3dVector3d_1.Point3d.create();
            allPoints.getPoint3dAtUncheckedPointIndex(0, pointA);
            for (let i1 = 0; i1 + 1 < numPoints; i1++) {
                allPoints.getPoint3dAtUncheckedPointIndex(i1, pointB);
                path.tryAddChild(LineSegment3d_1.LineSegment3d.create(pointA, pointB));
                pointA.setFromPoint3d(pointB);
            }
        }
        else if (structure === 2) {
            for (let i0 = 0; i0 + 4 < numPoints; i0 += 4) {
                const ls = LineString3d_1.LineString3d.create();
                ls.addSteppedPoints(allPoints, i0, 1, 5);
                path.tryAddChild(ls);
            }
        }
        else {
            const ls = LineString3d_1.LineString3d.create();
            ls.addSteppedPoints(allPoints, 0, 1, numPoints);
            path.tryAddChild(ls);
        }
        return path;
    }
    /**
     * Create various elliptic arcs
     * * circle with vector0, vector90 aligned with x,y
     * * circle with axes rotated
     * *
     * @param radiusRatio = vector90.magnitude / vector0.magnitude
     */
    static createArcs(radiusRatio = 1.0, sweep = AngleSweep_1.AngleSweep.create360()) {
        const arcs = [];
        const center0 = Point3dVector3d_1.Point3d.create(0, 0, 0);
        const a = 1.0;
        const b = radiusRatio;
        const direction0 = Point3dVector3d_1.Vector3d.createPolar(a, Angle_1.Angle.createDegrees(35.0));
        const direction90 = direction0.rotate90CCWXY();
        direction90.scaleInPlace(radiusRatio);
        arcs.push(Arc3d_1.Arc3d.create(center0, Point3dVector3d_1.Vector3d.create(a, 0, 0), Point3dVector3d_1.Vector3d.create(0, b, 0), sweep));
        arcs.push(Arc3d_1.Arc3d.create(center0, direction0, direction90, sweep));
        return arcs;
    }
    /**
     * Create many arcs, optionally including skews
     * * @param skewFactor array of skew factors.  for each skew factor, all base arcs are replicated with vector90 shifted by the factor times vector0
     */
    static createManyArcs(skewFactors = []) {
        const result = [];
        const sweep1 = AngleSweep_1.AngleSweep.createStartEndDegrees(-10, 75);
        const sweep2 = AngleSweep_1.AngleSweep.createStartEndDegrees(160.0, 380.0);
        for (const arcs of [
            Sample.createArcs(1.0), Sample.createArcs(0.5),
            Sample.createArcs(1.0, sweep1), Sample.createArcs(0.3, sweep2)
        ]) {
            for (const arc of arcs)
                result.push(arc);
        }
        const numBase = result.length;
        for (const skewFactor of skewFactors) {
            for (let i = 0; i < numBase; i++) {
                const originalArc = result[i];
                result.push(Arc3d_1.Arc3d.create(originalArc.center, originalArc.vector0, originalArc.vector90.plusScaled(originalArc.vector0, skewFactor), originalArc.sweep));
            }
        }
        return result;
    }
    /**
     * Create edges of a range box.
     * * Line strings on low and high z
     * * single lines on each low z to high z edge.
     * * @param range (possibly null) range
     */
    static createRangeEdges(range) {
        if (range.isNull)
            return undefined;
        const corners = range.corners();
        return CurveCollection_1.BagOfCurves.create(LineString3d_1.LineString3d.create(corners[0], corners[1], corners[3], corners[2], corners[0]), LineString3d_1.LineString3d.create(corners[4], corners[5], corners[7], corners[6], corners[4]), LineSegment3d_1.LineSegment3d.create(corners[0], corners[4]), LineSegment3d_1.LineSegment3d.create(corners[1], corners[5]), LineSegment3d_1.LineSegment3d.create(corners[2], corners[6]), LineSegment3d_1.LineSegment3d.create(corners[3], corners[7]));
    }
    /** Create swept "solids" that can be capped.
     * * At least one of each solid type.
     * * each is within 10 of the origin all directions.
     */
    static createClosedSolidSampler(capped) {
        const result = [];
        result.push(Box_1.Box.createRange(Range_1.Range3d.createXYZXYZ(0, 0, 0, 3, 2, 5), capped));
        result.push(Cone_1.Cone.createAxisPoints(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(0, 0, 5), 1.0, 1.0, capped));
        result.push(Sphere_1.Sphere.createCenterRadius(Point3dVector3d_1.Point3d.create(0, 0, 0), 1.0));
        result.push(TorusPipe_1.TorusPipe.createInFrame(Transform_1.Transform.createIdentity(), 3.0, 1.0, Angle_1.Angle.create360(), capped));
        const arcA = Arc3d_1.Arc3d.createXY(Point3dVector3d_1.Point3d.create(6, 1, 0), 1.0, AngleSweep_1.AngleSweep.createStartEndDegrees(-90, 0));
        const point0 = arcA.fractionAndDistanceToPointOnTangent(0.0, -4);
        const pointQ1 = arcA.fractionAndDistanceToPointOnTangent(1.0, 2);
        const pointQ2 = arcA.fractionAndDistanceToPointOnTangent(1.0, 0.5);
        const pointR1 = Point3dVector3d_1.Point3d.create(point0.x, pointQ1.y);
        const pointR2 = Point3dVector3d_1.Point3d.create(point0.x, pointQ1.y);
        const linestringQ1 = LineString3d_1.LineString3d.create(arcA.fractionToPoint(1.0), pointQ1, pointR1, point0);
        const linestringQ2 = LineString3d_1.LineString3d.create(arcA.fractionToPoint(1.0), pointQ2, pointR2, point0);
        const contourZ = Path_1.Path.create(linestringQ1.clone());
        const contourA = Loop_1.Loop.create(LineSegment3d_1.LineSegment3d.create(point0, arcA.fractionToPoint(0)), arcA.clone(), linestringQ1.clone());
        const contourB = Loop_1.Loop.create(LineSegment3d_1.LineSegment3d.create(point0, arcA.fractionToPoint(0)), arcA.clone(), linestringQ2.clone());
        contourB.tryTransformInPlace(Transform_1.Transform.createTranslationXYZ(1, 1, 3));
        // const contourC = contourB.cloneTransformed(Transform.createTranslationXYZ(2, 1, 4))!;
        result.push(LinearSweep_1.LinearSweep.create(contourA, Point3dVector3d_1.Vector3d.create(0, 0, 5), capped));
        const axis = Ray3d_1.Ray3d.createXYZUVW(0, 8, 0, 1, 0, 0);
        result.push(RotationalSweep_1.RotationalSweep.create(contourA.clone(), axis.clone(), Angle_1.Angle.createDegrees(90), capped));
        if (!capped)
            result.push(RotationalSweep_1.RotationalSweep.create(contourZ.clone(), axis.clone(), Angle_1.Angle.createDegrees(90), false));
        result.push(RuledSweep_1.RuledSweep.create([contourA.clone(), contourB.clone()], capped));
        const transformC = Transform_1.Transform.createScaleAboutPoint(Point3dVector3d_1.Point3d.create(0, 0, 8), 0.5);
        const contourC = contourB.cloneTransformed(transformC);
        result.push(RuledSweep_1.RuledSweep.create([contourA.clone(), contourB.clone(), contourC.clone()], capped));
        return result;
    }
    /** Create a rotational sweep with segment, arc, and linestring in its contour.
     */
    static createRotationalSweepLineSegment3dArc3dLineString3d(capped) {
        const result = [];
        const arcA = Arc3d_1.Arc3d.createXY(Point3dVector3d_1.Point3d.create(6, 1, 0), 1.0, AngleSweep_1.AngleSweep.createStartEndDegrees(-90, 0));
        const point0 = arcA.fractionAndDistanceToPointOnTangent(0.0, -4);
        const pointQ1 = arcA.fractionAndDistanceToPointOnTangent(1.0, 2);
        const pointR1 = Point3dVector3d_1.Point3d.create(point0.x, pointQ1.y);
        const linestringQ1 = LineString3d_1.LineString3d.create(arcA.fractionToPoint(1.0), pointQ1, pointR1, point0);
        const contourZ = Path_1.Path.create(linestringQ1.clone());
        const axis = Ray3d_1.Ray3d.createXYZUVW(0, 8, 0, 1, 0, 0);
        result.push(RotationalSweep_1.RotationalSweep.create(contourZ.clone(), axis.clone(), Angle_1.Angle.createDegrees(90), capped));
        return result;
    }
    /**
     * Create points:
     * *  `numRadialEdges` radially from origin to polar point (r,sweep.start)
     * * `numArcEdges` along arc from (r,sweep.start) to (r,sweep.end)
     * * `numRadialEdges` returning to origin.
     * * optionally include closure point at origin.
     * @param x0 center x
     * @param y0 center y
     * @param radius radius of circle.
     * @param sweep start and end angles of sweep.
     * @param numRadialEdges number of edges from center to arc
     * @param numArcEdges number of edges along arc
     * @param addClosure true to repeat center as closure point
     */
    static createCutPie(x0, y0, radius, sweep, numRadialEdges, numArcEdges, addClosure = false) {
        const points = [];
        const center = Point3dVector3d_1.Point3d.create(x0, y0);
        points.push(center);
        const pointA = Point3dVector3d_1.Point3d.create(x0 + radius * Math.cos(sweep.startRadians), y0 + radius * Math.sin(sweep.startRadians));
        const pointB = Point3dVector3d_1.Point3d.create(x0 + radius * Math.cos(sweep.endRadians), y0 + radius * Math.sin(sweep.endRadians));
        for (let i = 1; i < numRadialEdges; i++)
            points.push(center.interpolate(i / numRadialEdges, pointA));
        points.push(pointA);
        for (let i = 1; i < numArcEdges; i++) {
            const radians = sweep.fractionToRadians(i / numArcEdges);
            points.push(Point3dVector3d_1.Point3d.create(x0 + radius * Math.cos(radians), y0 + radius * Math.sin(radians)));
        }
        points.push(pointB);
        for (let i = 1; i < numRadialEdges; i++)
            points.push(pointB.interpolate(i / numRadialEdges, center));
        if (addClosure)
            points.push(center.clone());
        return points;
    }
    /**
     * * let ay = 4
     * * base polygon has vertices (0,0), (ax,0), (2*ax,0), (2* ax,ay), (ax,ay), (0,ay), (0,0).
     * * shift the x coordinates of vertices 1,4 by indicated amounts (0-based numbering)
     * * shift the y coordinates for points 1,2,3,4 by indicated amounts (in 0-based numbering)
     * * This is useful for testing non-y-monotonic face situations.
     * * Return as points.
     * @param dy1
     * @param dy2
     * @param dy3
     * @param dy4
     */
    static creatVerticalStaggerPolygon(dy1, dy2, dy3, dy4, ax, ay, dx1, dx4) {
        return [Point3dVector3d_1.Point3d.create(0, 0),
            Point3dVector3d_1.Point3d.create(ax + dx1, dy1),
            Point3dVector3d_1.Point3d.create(2 * ax, dy2),
            Point3dVector3d_1.Point3d.create(2 * ax, ay + dy3),
            Point3dVector3d_1.Point3d.create(ax + dx4, ay + dy4),
            Point3dVector3d_1.Point3d.create(0.0, ay),
            Point3dVector3d_1.Point3d.create(0, 0)];
    }
    /**
     * make line segments for each pair of adjacent points.
     * @param points array of points
     * @param forceClosure if true, inspect coordinates to determine if a closure edge is needed.
     */
    static convertPointsToSegments(points, forceClosure = false) {
        const segments = [];
        const n = points.length;
        for (let i = 0; i + 1 < n; i++) {
            segments.push(LineSegment3d_1.LineSegment3d.create(points[i], points[i + 1]));
        }
        if (forceClosure && n > 1 && !points[0].isAlmostEqual(points[n - 1]))
            segments.push(LineSegment3d_1.LineSegment3d.create(points[n - 1], points[0]));
        return segments;
    }
    /**
     * Create a regular polygon
     * @param angle0 angle from x axis to first point.
     * @param numPoint number of points
     * @param close true to add closure edge.
     */
    static createRegularPolygon(cx, cy, cz, angle0, r, numPoint, close) {
        const points = [];
        const angleStepRadians = 2.0 * Math.PI / numPoint;
        let radians;
        for (let i = 0; i < numPoint; i++) {
            radians = angle0.radians + i * angleStepRadians;
            points.push(Point3dVector3d_1.Point3d.create(cx + r * Math.cos(radians), cy + r * Math.sin(radians), cz));
        }
        if (close)
            points.push(points[0].clone());
        return points;
    }
    /**
     * Create a star by alternating radii (with equal angular steps)
     * @param r0 first point radius
     * @param r1 second point radius (if undefined, this is skipped and the result is points on a circle.)
     * @param numPoint number of points
     * @param close true to add closure edge.
     */
    static createStar(cx, cy, cz, r0, r1, numPoint, close, theta0) {
        const points = [];
        const angleStepRadians = Math.PI / numPoint;
        const radians0 = theta0 === undefined ? 0.0 : theta0.radians;
        let radians;
        for (let i = 0; i < numPoint; i++) {
            radians = radians0 + 2 * i * angleStepRadians;
            points.push(Point3dVector3d_1.Point3d.create(cx + r0 * Math.cos(radians), cy + r0 * Math.sin(radians), cz));
            if (r1 !== undefined) {
                radians = radians0 + (2 * i + 1) * angleStepRadians;
                points.push(Point3dVector3d_1.Point3d.create(cx + r1 * Math.cos(radians), cy + r1 * Math.sin(radians), cz));
            }
        }
        if (close)
            points.push(points[0].clone());
        return points;
    }
    /**
     * Create an outer star A
     * Place multiple inner stars B with centers on circle C
     * @param rA0 radius to star tips on starA
     * @param rA1 radius to star tips on starA
     * @param numAPoint number of points on starA
     * @param rB0 radius to star B tips
     * @param rB1 radius to star B  tips
     * @param numBPoint
     * @param rC radius for inner star centers
     * @param numC number of inner stars
     */
    static createStarsInStars(rA0, rA1, numAPoint, rB0, rB1, numBPoint, rC, numC, close) {
        const loops = [];
        loops.push(this.createStar(0, 0, 0, rA0, rA1, numAPoint, close));
        if (numC > 0) {
            const radiansStep = Math.PI * 2.0 / numC;
            for (let i = 0; i < numC; i++) {
                const radians = i * radiansStep;
                loops.push(this.createStar(rC * Math.cos(radians), rC * Math.sin(radians), 0.0, rB0, rB1, numBPoint, close));
            }
        }
        return loops;
    }
    static appendGeometry(source, dest) {
        for (const g of source)
            dest.push(g);
    }
    /** Create a simple example of each GeometryQuery type .... */
    static createAllGeometryQueryTypes() {
        const result = [];
        const pointA = Point3dVector3d_1.Point3d.create(0, 0, 0);
        const pointB = Point3dVector3d_1.Point3d.create(1, 0, 0);
        const pointC = Point3dVector3d_1.Point3d.create(1, 1, 0);
        const pointD = Point3dVector3d_1.Point3d.create(0, 1, 0);
        const pointABC = [pointA, pointB, pointC];
        const pointABCD = [pointA, pointB, pointC, pointD];
        const pointABCDA = [pointA, pointB, pointC, pointD, pointA];
        result.push(LineSegment3d_1.LineSegment3d.create(pointA, pointB));
        result.push(CoordinateXYZ_1.CoordinateXYZ.create(pointA));
        result.push(Arc3d_1.Arc3d.createCircularStartMiddleEnd(pointA, pointB, pointC));
        result.push(PointString3d_1.PointString3d.create(pointA, pointB));
        result.push(TransitionSpiral_1.TransitionSpiral3d.createRadiusRadiusBearingBearing(Segment1d_1.Segment1d.create(0, 100), AngleSweep_1.AngleSweep.createStartEndDegrees(0, 5), Segment1d_1.Segment1d.create(0, 0.5), Transform_1.Transform.createIdentity()));
        result.push(LineString3d_1.LineString3d.create(pointABCD));
        result.push(BezierCurve3d_1.BezierCurve3d.create(pointABC));
        result.push(BezierCurve3dH_1.BezierCurve3dH.create(pointABC));
        result.push(BSplineCurve_1.BSplineCurve3d.createUniformKnots(pointABC, 3));
        result.push(BSplineCurve3dH_1.BSplineCurve3dH.createUniformKnots(pointABC, 3));
        result.push(Loop_1.Loop.create(LineString3d_1.LineString3d.create(pointABCDA)));
        result.push(Path_1.Path.create(LineString3d_1.LineString3d.create(pointABCD)));
        result.push(this.createConeBsplineSurface(pointA, pointC, 1, 2, 4));
        result.push(this.createXYGridBsplineSurface(8, 4, 4, 3));
        this.appendGeometry(this.createClosedSolidSampler(true), result);
        result.push(this.createTriangularUnitGridPolyface(pointA, Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitY(), 4, 5));
        this.appendGeometry(this.createSimpleParityRegions(), result);
        this.appendGeometry(this.createSimpleUnions(), result);
        this.appendGeometry(this.createBagOfCurves(), result);
        return result;
    }
}
exports.Sample = Sample;
/** Array with assorted Point2d samples */
Sample.point2d = [
    Point2dVector2d_1.Point2d.create(0, 0),
    Point2dVector2d_1.Point2d.create(1, 0),
    Point2dVector2d_1.Point2d.create(0, 1),
    Point2dVector2d_1.Point2d.create(2, 3)
];
/** Array with assorted Point3d samples */
Sample.point3d = [
    Point3dVector3d_1.Point3d.create(0, 0, 0),
    Point3dVector3d_1.Point3d.create(1, 0, 0),
    Point3dVector3d_1.Point3d.create(0, 1, 0),
    Point3dVector3d_1.Point3d.create(0, 1, 0),
    Point3dVector3d_1.Point3d.create(0, 0, 1),
    Point3dVector3d_1.Point3d.create(2, 3, 0),
    Point3dVector3d_1.Point3d.create(0, 2, 5),
    Point3dVector3d_1.Point3d.create(-3, 0, 5),
    Point3dVector3d_1.Point3d.create(4, 3, -2)
];
/** Array with assorted Point4d samples */
Sample.point4d = [
    Point4d_1.Point4d.create(0, 0, 0, 1),
    Point4d_1.Point4d.create(1, 0, 0, 1),
    Point4d_1.Point4d.create(0, 1, 0, 1),
    Point4d_1.Point4d.create(0, 1, 0, 1),
    Point4d_1.Point4d.create(0, 0, 1, 1),
    Point4d_1.Point4d.create(2, 3, 0, 1),
    Point4d_1.Point4d.create(0, 2, 5, 1),
    Point4d_1.Point4d.create(-3, 0, 5, 1),
    Point4d_1.Point4d.create(-3, 0, 5, 0.3),
    Point4d_1.Point4d.create(-3, 0, 5, -0.2),
    Point4d_1.Point4d.create(4, 3, -2, 1)
];
/** Array with assorted nonzero Vector2d samples */
Sample.vector2d = [
    Point2dVector2d_1.Vector2d.create(1, 0),
    Point2dVector2d_1.Vector2d.create(0, 1),
    Point2dVector2d_1.Vector2d.create(0, 0),
    Point2dVector2d_1.Vector2d.create(-1, 0),
    Point2dVector2d_1.Vector2d.create(0, -1),
    Point2dVector2d_1.Vector2d.create(0, 0),
    Point2dVector2d_1.Vector2d.createPolar(1.0, Angle_1.Angle.createDegrees(20)),
    Point2dVector2d_1.Vector2d.createPolar(2.0, Angle_1.Angle.createDegrees(20)),
    Point2dVector2d_1.Vector2d.create(2, 3)
];
/** Assorted Plane3dBYOriginAndUnitNormal */
Sample.plane3dByOriginAndUnitNormal = [
    Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.createXYPlane(),
    Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.createYZPlane(),
    Plane3dByOriginAndUnitNormal_1.Plane3dByOriginAndUnitNormal.createZXPlane(),
    Sample.createPlane(0, 0, 0, 3, 0, 1),
    Sample.createPlane(1, 2, 3, 2, 4, -1)
];
/** Assorted Ray3d, not all unit direction vectors. */
Sample.ray3d = [
    Sample.createRay(0, 0, 0, 1, 0, 0),
    Sample.createRay(0, 0, 0, 0, 1, 0),
    Sample.createRay(0, 0, 0, 0, 0, 1),
    Sample.createRay(0, 0, 0, 1, 2, 0),
    Sample.createRay(1, 2, 3, 4, 2, -1)
];
/** Assorted angles.  All principal directions, some others included. */
Sample.angle = [
    Angle_1.Angle.createDegrees(0),
    Angle_1.Angle.createDegrees(90),
    Angle_1.Angle.createDegrees(180),
    Angle_1.Angle.createDegrees(-90),
    Angle_1.Angle.createDegrees(30),
    Angle_1.Angle.createDegrees(-105)
];
/** Assorted angle sweeps */
Sample.angleSweep = [
    AngleSweep_1.AngleSweep.createStartEndDegrees(0, 90),
    AngleSweep_1.AngleSweep.createStartEndDegrees(0, 180),
    AngleSweep_1.AngleSweep.createStartEndDegrees(-90, 0),
    AngleSweep_1.AngleSweep.createStartEndDegrees(0, -90),
    AngleSweep_1.AngleSweep.createStartEndDegrees(0, 30),
    AngleSweep_1.AngleSweep.createStartEndDegrees(45, 110)
];
/** assorted line segments */
Sample.lineSegment3d = [
    LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(1, 0, 0)),
    LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(0, 1, 0)),
    LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(0, 0, 0), Point3dVector3d_1.Point3d.create(0, 0, 1)),
    LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(1, 2, 3), Point3dVector3d_1.Point3d.create(-2, -3, 0.5))
];
/** Assorted Range1d:   single point, null, simple forward, simple reverse */
Sample.range1d = [
    Range_1.Range1d.createX(1),
    Range_1.Range1d.createNull(),
    Range_1.Range1d.createXX(1, 2),
    Range_1.Range1d.createXX(2, 1)
];
/** Assorted range2d: single point, null, 2 point with various creation orders. */
Sample.range2d = [
    Range_1.Range2d.createXY(1, 2),
    Range_1.Range2d.createNull(),
    Range_1.Range2d.createXYXY(1, 2, 0, 3),
    Range_1.Range2d.createXYXY(1, 2, 3, 4)
];
/** Assorted range2d: single point, null, 2 point with various creation orders. */
Sample.range3d = [
    Range_1.Range3d.createXYZ(1, 2, 3),
    Range_1.Range3d.createNull(),
    Range_1.Range3d.createXYZXYZ(1, 2, 0, 3, 4, 7),
    Range_1.Range3d.createXYZXYZ(1, 2, 3, -2, -4, -1)
];


/***/ }),

/***/ "./lib/serialization/IModelJsonSchema.js":
/*!***********************************************!*\
  !*** ./lib/serialization/IModelJsonSchema.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Serialization */
// import { Geometry, Angle, AxisOrder, BSIJSONValues } from "../Geometry";
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Segment1d_1 = __webpack_require__(/*! ../geometry3d/Segment1d */ "./lib/geometry3d/Segment1d.js");
const YawPitchRollAngles_1 = __webpack_require__(/*! ../geometry3d/YawPitchRollAngles */ "./lib/geometry3d/YawPitchRollAngles.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const GeometryQuery_1 = __webpack_require__(/*! ../curve/GeometryQuery */ "./lib/curve/GeometryQuery.js");
const CoordinateXYZ_1 = __webpack_require__(/*! ../curve/CoordinateXYZ */ "./lib/curve/CoordinateXYZ.js");
const TransitionSpiral_1 = __webpack_require__(/*! ../curve/TransitionSpiral */ "./lib/curve/TransitionSpiral.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const UnionRegion_1 = __webpack_require__(/*! ../curve/UnionRegion */ "./lib/curve/UnionRegion.js");
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const ParityRegion_1 = __webpack_require__(/*! ../curve/ParityRegion */ "./lib/curve/ParityRegion.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Path_1 = __webpack_require__(/*! ../curve/Path */ "./lib/curve/Path.js");
const Polyface_1 = __webpack_require__(/*! ../polyface/Polyface */ "./lib/polyface/Polyface.js");
const AuxData_1 = __webpack_require__(/*! ../polyface/AuxData */ "./lib/polyface/AuxData.js");
const BSplineCurve_1 = __webpack_require__(/*! ../bspline/BSplineCurve */ "./lib/bspline/BSplineCurve.js");
const BSplineSurface_1 = __webpack_require__(/*! ../bspline/BSplineSurface */ "./lib/bspline/BSplineSurface.js");
const Sphere_1 = __webpack_require__(/*! ../solid/Sphere */ "./lib/solid/Sphere.js");
const Cone_1 = __webpack_require__(/*! ../solid/Cone */ "./lib/solid/Cone.js");
const Box_1 = __webpack_require__(/*! ../solid/Box */ "./lib/solid/Box.js");
const TorusPipe_1 = __webpack_require__(/*! ../solid/TorusPipe */ "./lib/solid/TorusPipe.js");
const LinearSweep_1 = __webpack_require__(/*! ../solid/LinearSweep */ "./lib/solid/LinearSweep.js");
const RotationalSweep_1 = __webpack_require__(/*! ../solid/RotationalSweep */ "./lib/solid/RotationalSweep.js");
const RuledSweep_1 = __webpack_require__(/*! ../solid/RuledSweep */ "./lib/solid/RuledSweep.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const GeometryHandler_1 = __webpack_require__(/*! ../geometry3d/GeometryHandler */ "./lib/geometry3d/GeometryHandler.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const PointString3d_1 = __webpack_require__(/*! ../curve/PointString3d */ "./lib/curve/PointString3d.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const LineSegment3d_1 = __webpack_require__(/*! ../curve/LineSegment3d */ "./lib/curve/LineSegment3d.js");
const BSplineCurve3dH_1 = __webpack_require__(/*! ../bspline/BSplineCurve3dH */ "./lib/bspline/BSplineCurve3dH.js");
const Point4d_1 = __webpack_require__(/*! ../geometry4d/Point4d */ "./lib/geometry4d/Point4d.js");
const KnotVector_1 = __webpack_require__(/*! ../bspline/KnotVector */ "./lib/bspline/KnotVector.js");
/* tslint:disable: object-literal-key-quotes no-console*/
/**
 * `ImodelJson` namespace has classes for serializing and deserialization json objects
 * @public
 */
var IModelJson;
(function (IModelJson) {
    /** parser services for "iModelJson" schema
     * * 1: create a reader with `new ImodelJsonReader`
     * * 2: parse json fragment to strongly typed geometry: `const g = reader.parse (fragment)`
     * @public
     */
    class Reader {
        constructor() {
        }
        static parseVector3dProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Geometry_1.Geometry.isNumberArray(value, 3))
                    return Point3dVector3d_1.Vector3d.create(value[0], value[1], value[2]);
                if (Point3dVector3d_1.XYZ.isXAndY(value))
                    return Point3dVector3d_1.Vector3d.fromJSON(value);
            }
            return defaultValue;
        }
        static parsePoint3dProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Geometry_1.Geometry.isNumberArray(value, 3))
                    return Point3dVector3d_1.Point3d.create(value[0], value[1], value[2]);
                if (Point3dVector3d_1.XYZ.isXAndY(value))
                    return Point3dVector3d_1.Point3d.fromJSON(value);
            }
            return defaultValue;
        }
        static parseSegment1dProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Geometry_1.Geometry.isNumberArray(value, 2))
                    return Segment1d_1.Segment1d.create(value[0], value[1]);
            }
            return defaultValue;
        }
        static parseNumberProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Number.isFinite(value))
                    return value;
            }
            return defaultValue;
        }
        /* ==============
            private static parseNumberArrayProperty(json: any, propertyName: string, minValues: number, maxValues: number, defaultValue?: number[] | undefined): number[] | undefined {
              if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Array.isArray(value)
                  && value.length >= minValues && value.length <= maxValues) {
                  const result = [];
                  for (const a of value) {
                    result.push(a);
                  }
                  return result;
                }
              }
              return defaultValue;
            }
        */
        static parseAngleProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                return Angle_1.Angle.fromJSON(value);
            }
            return defaultValue;
        }
        /**
         * @param defaultFunction function to call if needed to produce a default value
         */
        static parseAngleSweepProps(json, propertyName, defaultFunction) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                return AngleSweep_1.AngleSweep.fromJSON(value);
            }
            if (defaultFunction === undefined)
                return undefined;
            return defaultFunction();
        }
        static parseBooleanProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (value === true)
                    return true;
                if (value === false)
                    return false;
            }
            return defaultValue;
        }
        static loadContourArray(json, propertyName) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (Array.isArray(value)) {
                    const result = [];
                    for (const contourData of value) {
                        const contour = Reader.parse(contourData);
                        if (contour instanceof CurveCollection_1.CurveCollection) {
                            result.push(contour);
                        }
                    }
                    if (result.length > 0)
                        return result;
                }
            }
            return undefined;
        }
        static parseYawPitchRollAnglesToMatrix3d(json) {
            const ypr = YawPitchRollAngles_1.YawPitchRollAngles.fromJSON(json);
            return ypr.toMatrix3d();
        }
        static parseStringProperty(json, propertyName, defaultValue) {
            if (json.hasOwnProperty(propertyName)) {
                const value = json[propertyName];
                if (value.type === "string")
                    return value;
            }
            return defaultValue;
        }
        static parseAxesFromVectors(json, axisOrder, createDefaultIdentity) {
            if (Array.isArray(json) && json.length === 2) {
                const xVector = Point3dVector3d_1.Vector3d.fromJSON(json[0]);
                const yVector = Point3dVector3d_1.Vector3d.fromJSON(json[1]);
                const matrix = Matrix3d_1.Matrix3d.createRigidFromColumns(xVector, yVector, axisOrder);
                if (matrix)
                    return matrix;
            }
            if (createDefaultIdentity)
                return Matrix3d_1.Matrix3d.createIdentity();
            return undefined;
        }
        /**
         * Look for orientation data and convert to Matrix3d.
         * * Search order is:
         * * * yawPitchRollAngles
         * * * xyVectors
         * * * zxVectors
         * @param json [in] json source data
         * @param createDefaultIdentity [in] If true and no orientation is present, return an identity matrix.  If false and no orientation is present, return undefined.
         */
        static parseOrientation(json, createDefaultIdentity) {
            if (json.yawPitchRollAngles) {
                return Reader.parseYawPitchRollAnglesToMatrix3d(json.yawPitchRollAngles);
            }
            else if (json.xyVectors) {
                return Reader.parseAxesFromVectors(json.xyVectors, Geometry_1.AxisOrder.XYZ, createDefaultIdentity);
            }
            else if (json.zxVectors) {
                return Reader.parseAxesFromVectors(json.zxVectors, Geometry_1.AxisOrder.ZXY, createDefaultIdentity);
            }
            if (createDefaultIdentity)
                return Matrix3d_1.Matrix3d.createIdentity();
            return undefined;
        }
        static parseArcByVectorProps(data) {
            if (data
                && data.center !== undefined
                && data.vectorX !== undefined
                && data.vectorY !== undefined
                && data.sweepStartEnd !== undefined) {
                return Arc3d_1.Arc3d.create(Point3dVector3d_1.Point3d.fromJSON(data.center), Point3dVector3d_1.Vector3d.fromJSON(data.vectorX), Point3dVector3d_1.Vector3d.fromJSON(data.vectorY), AngleSweep_1.AngleSweep.fromJSON(data.sweepStartEnd));
            }
            return undefined;
        }
        // remark: Returns LineString3d as last default when give points are colinear.
        static parseArcBy3Points(data) {
            if (Array.isArray(data) && data.length > 2) {
                const pointA = Point3dVector3d_1.Point3d.fromJSON(data[0]);
                const pointB = Point3dVector3d_1.Point3d.fromJSON(data[1]);
                const pointC = Point3dVector3d_1.Point3d.fromJSON(data[2]);
                return Arc3d_1.Arc3d.createCircularStartMiddleEnd(pointA, pointB, pointC);
            }
            return undefined;
        }
        static parseArcObject(data) {
            let arc = Reader.parseArcByVectorProps(data);
            if (arc)
                return arc;
            arc = Reader.parseArcBy3Points(data);
            return arc; // possibly undefined.
        }
        /** Parse point content (right side) `[1,2,3]` to a CoordinateXYZ object. */
        static parseCoordinate(data) {
            const point = Point3dVector3d_1.Point3d.fromJSON(data);
            if (point)
                return CoordinateXYZ_1.CoordinateXYZ.create(point);
            return undefined;
        }
        /** Parse TransitionSpiral content (right side) to TransitionSpiral3d
         * @alpha
         */
        static parseTransitionSpiral(data) {
            const axes = Reader.parseOrientation(data, true);
            const origin = Reader.parsePoint3dProperty(data, "origin");
            // the create method will juggle any 4 out of these 5 inputs to define the other ..
            const startBearing = Reader.parseAngleProperty(data, "startBearing");
            const endBearing = Reader.parseAngleProperty(data, "endBearing");
            const startRadius = Reader.parseNumberProperty(data, "startRadius");
            const endRadius = Reader.parseNumberProperty(data, "endRadius");
            const length = Reader.parseNumberProperty(data, "curveLength", undefined);
            const interval = Reader.parseSegment1dProperty(data, "fractionInterval", undefined);
            const spiralType = Reader.parseStringProperty(data, "spiralType", "clothoid");
            if (origin)
                return TransitionSpiral_1.TransitionSpiral3d.create(spiralType, startRadius, endRadius, startBearing, endBearing, length, interval, Transform_1.Transform.createOriginAndMatrix(origin, axes));
            return undefined;
        }
        /**
         * Special closed case if the input was forced to bezier . . . (e.g. arc)
         *       (b-1) 0 0 0  a . . . b 111 (a+1)
         *       with {order} clamp-like values .. no pole duplication needed, but throw out 2 knots at each end . ..
         * @param numPoles number of poles
         * @param knots knot vector
         * @param order curve order
         * @param newKnots array to receive new knots.
         * @returns true if this is a closed-but-clamped case and corrected knots are filled in.
         */
        static getCorrectedKnotsForClosedClamped(numPoles, knots, order, newKnots) {
            const numKnots = knots.length;
            if (numPoles + 2 * order - 1 === numKnots
                && knots[0] < knots[1]
                && knots[numKnots - 2] < knots[numKnots - 1]) {
                const a0 = knots[1];
                const a1 = knots[numKnots - 2];
                for (let i = 2; i <= order; i++) {
                    if (knots[i] !== a0)
                        return false;
                    if (knots[numKnots - 1 - i] !== a1)
                        return false;
                }
                // copy only the "minimal" set - without the typical extra knots from microstation and psd.
                for (let i = 2; i + 2 < numKnots; i++)
                    newKnots.push(knots[i]);
                return true;
            }
            return false;
        }
        /** Parse `bcurve` content (right side)to  BSplineCurve3d or BSplineCurve3dH object. */
        static parseBcurve(data) {
            if (data === undefined)
                return undefined;
            if (Array.isArray(data.points) && Array.isArray(data.knots) && Number.isFinite(data.order) && data.closed !== undefined) {
                if (data.points[0].length === 4) {
                    const hPoles = [];
                    for (const p of data.points)
                        hPoles.push(Point4d_1.Point4d.fromJSON(p));
                    const knots = [];
                    let wrapMode = KnotVector_1.BSplineWrapMode.None;
                    if (data.closed && this.getCorrectedKnotsForClosedClamped(data.points.length, data.knots, data.order, knots)) {
                        // leave the poles alone -- knots are fixed.
                        wrapMode = KnotVector_1.BSplineWrapMode.OpenByRemovingKnots;
                    }
                    else if (data.closed) {
                        for (const knot of data.knots)
                            knots.push(knot);
                        for (let i = 0; i + 1 < data.order; i++) {
                            hPoles.push(hPoles[i].clone());
                        }
                        wrapMode = KnotVector_1.BSplineWrapMode.OpenByAddingControlPoints;
                    }
                    else {
                        // simple case .. just copy
                        for (const knot of data.knots)
                            knots.push(knot);
                    }
                    const newCurve = BSplineCurve3dH_1.BSplineCurve3dH.create(hPoles, knots, data.order);
                    if (newCurve) {
                        if (data.closed === true)
                            newCurve.setWrappable(wrapMode);
                        return newCurve;
                    }
                }
                else if (data.points[0].length === 3 || data.points[0].length === 2) {
                    const poles = [];
                    for (const p of data.points)
                        poles.push(Point3dVector3d_1.Point3d.fromJSON(p));
                    const knots = [];
                    let wrapMode = KnotVector_1.BSplineWrapMode.None;
                    if (data.closed && this.getCorrectedKnotsForClosedClamped(data.points.length, data.knots, data.order, knots)) {
                        wrapMode = KnotVector_1.BSplineWrapMode.OpenByRemovingKnots;
                        // leave the poles alone -- knots are fixed.
                    }
                    else if (data.closed) {
                        for (const knot of data.knots)
                            knots.push(knot);
                        for (let i = 0; i + 1 < data.order; i++) {
                            poles.push(poles[i].clone());
                        }
                        wrapMode = KnotVector_1.BSplineWrapMode.OpenByAddingControlPoints;
                    }
                    else {
                        // simple case .. just copy
                        for (const knot of data.knots)
                            knots.push(knot);
                    }
                    const newCurve = BSplineCurve_1.BSplineCurve3d.create(poles, knots, data.order);
                    if (newCurve) {
                        if (data.closed === true)
                            newCurve.setWrappable(wrapMode);
                        return newCurve;
                    }
                }
            }
            return undefined;
        }
        /** Parse array of json objects to array of instances. */
        static parseArray(data) {
            if (Array.isArray(data)) {
                const myArray = [];
                let c;
                for (c of data) {
                    const g = Reader.parse(c);
                    if (g !== undefined)
                        myArray.push(g);
                }
                return myArray;
            }
            return undefined;
        }
        // For each nonzero index, Announce Math.abs (value) -1
        static addZeroBasedIndicesFromSignedOneBased(data, f) {
            if (data && Geometry_1.Geometry.isNumberArray(data)) {
                for (const value of data) {
                    if (value !== 0)
                        f(Math.abs(value) - 1);
                }
            }
        }
        /** parse polyface aux data content to PolyfaceAuxData instance */
        static parsePolyfaceAuxData(data) {
            if (!Array.isArray(data.channels) || !Array.isArray(data.indices))
                return undefined;
            const outChannels = [];
            for (const inChannel of data.channels) {
                if (Array.isArray(inChannel.data) && inChannel.hasOwnProperty("dataType")) {
                    const outChannelData = [];
                    for (const inChannelData of inChannel.data) {
                        if (inChannelData.hasOwnProperty("input") && Array.isArray(inChannelData.values))
                            outChannelData.push(new AuxData_1.AuxChannelData(inChannelData.input, inChannelData.values));
                    }
                    outChannels.push(new AuxData_1.AuxChannel(outChannelData, inChannel.dataType, inChannel.name, inChannel.inputName));
                }
            }
            const auxData = new AuxData_1.PolyfaceAuxData(outChannels, []);
            Reader.addZeroBasedIndicesFromSignedOneBased(data.indices, (x) => { auxData.indices.push(x); });
            return auxData;
        }
        /** parse indexed mesh content to an IndexedPolyface instance */
        static parseIndexedMesh(data) {
            // {Coord:[[x,y,z],. . . ],   -- simple xyz for each point
            // CoordIndex[1,2,3,0]    -- zero-terminated, one based !!!
            if (data.hasOwnProperty("point") && Array.isArray(data.point)
                && data.hasOwnProperty("pointIndex") && Array.isArray(data.pointIndex)) {
                const polyface = Polyface_1.IndexedPolyface.create();
                if (data.hasOwnProperty("normal") && Array.isArray(data.normal)) {
                    for (const uvw of data.normal) {
                        if (Geometry_1.Geometry.isNumberArray(uvw, 3))
                            polyface.addNormal(Point3dVector3d_1.Vector3d.create(uvw[0], uvw[1], uvw[2]));
                    }
                }
                if (data.hasOwnProperty("param") && Array.isArray(data.param)) {
                    for (const uv of data.param) {
                        if (Geometry_1.Geometry.isNumberArray(uv, 2))
                            polyface.addParam(Point2dVector2d_1.Point2d.create(uv[0], uv[1]));
                    }
                }
                if (data.hasOwnProperty("color") && Array.isArray(data.color)) {
                    for (const c of data.color) {
                        polyface.addColor(c);
                    }
                }
                for (const p of data.point)
                    polyface.addPoint(Point3dVector3d_1.Point3d.fromJSON(p));
                for (const p of data.pointIndex) {
                    if (p === 0)
                        polyface.terminateFacet(false); // we are responsible for index checking !!!
                    else {
                        const p0 = Math.abs(p) - 1;
                        polyface.addPointIndex(p0, p > 0);
                    }
                }
                if (data.hasOwnProperty("normalIndex")) {
                    Reader.addZeroBasedIndicesFromSignedOneBased(data.normalIndex, (x) => { polyface.addNormalIndex(x); });
                }
                if (data.hasOwnProperty("paramIndex")) {
                    Reader.addZeroBasedIndicesFromSignedOneBased(data.paramIndex, (x) => { polyface.addParamIndex(x); });
                }
                if (data.hasOwnProperty("colorIndex")) {
                    Reader.addZeroBasedIndicesFromSignedOneBased(data.colorIndex, (x) => { polyface.addColorIndex(x); });
                }
                if (data.hasOwnProperty("auxData"))
                    polyface.data.auxData = Reader.parsePolyfaceAuxData(data.auxData);
                return polyface;
            }
            return undefined;
        }
        /** parse contents of a curve collection to a CurveCollection instance */
        static parseCurveCollectionMembers(result, data) {
            if (data && Array.isArray(data)) {
                for (const c of data) {
                    const g = Reader.parse(c);
                    if (g instanceof GeometryQuery_1.GeometryQuery && ("curveCollection" === g.geometryCategory || "curvePrimitive" === g.geometryCategory))
                        result.tryAddChild(g);
                }
                return result;
            }
            return undefined;
        }
        /** Parse content of `bsurf` to BSplineSurface3d or BSplineSurface3dH */
        static parseBsurf(data) {
            if (data.hasOwnProperty("uKnots") && Array.isArray(data.uKnots)
                && data.hasOwnProperty("vKnots") && Array.isArray(data.vKnots)
                && data.hasOwnProperty("orderU") && Number.isFinite(data.orderU)
                && data.hasOwnProperty("orderV") && Number.isFinite(data.orderV)
                && data.hasOwnProperty("points") && Array.isArray(data.points)) {
                const orderU = data.orderU;
                const orderV = data.orderV;
                if (Array.isArray(data.points[0]) && Array.isArray(data.points[0][0])) {
                    const d = data.points[0][0].length;
                    /** xyz surface (no weights) */
                    if (d === 3) {
                        return BSplineSurface_1.BSplineSurface3d.createGrid(data.points, orderU, data.uKnots, orderV, data.vKnots);
                    }
                    /** xyzw surface (weights already applied) */
                    if (d === 4) {
                        return BSplineSurface_1.BSplineSurface3dH.createGrid(data.points, BSplineSurface_1.WeightStyle.WeightsAlreadyAppliedToCoordinates, orderU, data.uKnots, orderV, data.vKnots);
                    }
                }
            }
            return undefined;
        }
        /** Parse `cone` contents to `Cone` instance  */
        static parseConeProps(json) {
            const axes = Reader.parseOrientation(json, false);
            const start = Reader.parsePoint3dProperty(json, "start");
            const end = Reader.parsePoint3dProperty(json, "end");
            const startRadius = Reader.parseNumberProperty(json, "startRadius");
            const endRadius = Reader.parseNumberProperty(json, "endRadius", startRadius);
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (start
                && end
                && startRadius !== undefined
                && endRadius !== undefined) {
                if (axes === undefined) {
                    const axisVector = Point3dVector3d_1.Vector3d.createStartEnd(start, end);
                    const frame = Matrix3d_1.Matrix3d.createRigidHeadsUp(axisVector, Geometry_1.AxisOrder.ZXY);
                    const vectorX = frame.columnX();
                    const vectorY = frame.columnY();
                    return Cone_1.Cone.createBaseAndTarget(start, end, vectorX, vectorY, startRadius, endRadius, capped);
                }
                else {
                    return Cone_1.Cone.createBaseAndTarget(start, end, axes.columnX(), axes.columnY(), startRadius, endRadius, capped);
                }
            }
            return undefined;
        }
        /** Parse `cylinder` content to `Cone` instance */
        static parseCylinderProps(json) {
            const start = Reader.parsePoint3dProperty(json, "start");
            const end = Reader.parsePoint3dProperty(json, "end");
            const radius = Reader.parseNumberProperty(json, "radius");
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (start
                && end
                && radius !== undefined) {
                return Cone_1.Cone.createAxisPoints(start, end, radius, radius, capped);
            }
            return undefined;
        }
        /** Parse line segment (array of 2 points) properties to `LineSegment3d` instance */
        static parseLineSegmentProps(value) {
            if (Array.isArray(value) && value.length > 1)
                return LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.fromJSON(value[0]), Point3dVector3d_1.Point3d.fromJSON(value[1]));
            else
                return undefined;
        }
        /** Parse linear sweep content to `LinearSweep` instance. */
        static parseLinearSweep(json) {
            const contour = Reader.parse(json.contour);
            const capped = Reader.parseBooleanProperty(json, "capped");
            const extrusionVector = Reader.parseVector3dProperty(json, "vector");
            if (contour instanceof GeometryQuery_1.GeometryQuery
                && "curveCollection" === contour.geometryCategory
                && capped !== undefined
                && extrusionVector) {
                return LinearSweep_1.LinearSweep.create(contour, extrusionVector, capped);
            }
            return undefined;
        }
        /** Parse rotational sweep contents to `RotationalSweep` instance */
        static parseRotationalSweep(json) {
            if (json === undefined)
                return undefined;
            const contour = Reader.parse(json.contour);
            const capped = Reader.parseBooleanProperty(json, "capped");
            const axisVector = Reader.parseVector3dProperty(json, "axis");
            const center = Reader.parsePoint3dProperty(json, "center");
            const sweepDegrees = Reader.parseNumberProperty(json, "sweepAngle");
            if (contour instanceof GeometryQuery_1.GeometryQuery
                && "curveCollection" === contour.geometryCategory
                && sweepDegrees !== undefined
                && capped !== undefined
                && axisVector
                && center) {
                return RotationalSweep_1.RotationalSweep.create(contour, Ray3d_1.Ray3d.createCapture(center, axisVector), Angle_1.Angle.createDegrees(sweepDegrees), capped);
            }
            return undefined;
        }
        /** Parse box contents to `Box` instance */
        static parseBox(json) {
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            const baseOrigin = Reader.parsePoint3dProperty(json, "baseOrigin");
            const baseX = Reader.parseNumberProperty(json, "baseX");
            const baseY = Reader.parseNumberProperty(json, "baseY", baseX);
            let topOrigin = Reader.parsePoint3dProperty(json, "topOrigin");
            const topX = Reader.parseNumberProperty(json, "topX", baseX);
            const topY = Reader.parseNumberProperty(json, "topY", baseY);
            const height = Reader.parseNumberProperty(json, "height", baseX);
            const axes = Reader.parseOrientation(json, true);
            if (baseOrigin && !topOrigin)
                topOrigin = Matrix3d_1.Matrix3d.xyzMinusMatrixTimesXYZ(baseOrigin, axes, Point3dVector3d_1.Vector3d.create(0, 0, height));
            if (capped !== undefined
                && baseX !== undefined
                && baseY !== undefined
                && topY !== undefined
                && topX !== undefined
                && axes
                && baseOrigin
                && topOrigin) {
                return Box_1.Box.createDgnBoxWithAxes(baseOrigin, axes, topOrigin, baseX, baseY, topX, topY, capped);
            }
            return undefined;
        }
        /** Parse `SphereProps` to `Sphere` instance. */
        static parseSphere(json) {
            const center = Reader.parsePoint3dProperty(json, "center");
            // optional unqualified radius . . .
            const radius = Reader.parseNumberProperty(json, "radius");
            // optional specific X
            const radiusX = Reader.parseNumberProperty(json, "radiusX", radius);
            // missing Y and Z both pick up radiusX  (which may have already been defaulted from unqualified radius)
            const radiusY = Reader.parseNumberProperty(json, "radiusX", radiusX);
            const radiusZ = Reader.parseNumberProperty(json, "radiusX", radiusX);
            const latitudeStartEnd = Reader.parseAngleSweepProps(json, "latitudeStartEnd"); // this may be undefined!!
            const axes = Reader.parseOrientation(json, true);
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (center !== undefined
                && radiusX !== undefined
                && radiusY !== undefined
                && radiusZ !== undefined
                && capped !== undefined) {
                return Sphere_1.Sphere.createFromAxesAndScales(center, axes, radiusX, radiusY, radiusZ, latitudeStartEnd, capped);
            }
            return undefined;
        }
        /** Parse RuledSweepProps to RuledSweep instance. */
        static parseRuledSweep(json) {
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            const contours = this.loadContourArray(json, "contour");
            if (contours !== undefined
                && capped !== undefined) {
                return RuledSweep_1.RuledSweep.create(contours, capped);
            }
            return undefined;
        }
        /** Parse TorusPipe props to TorusPipe instance. */
        static parseTorusPipe(json) {
            const axes = Reader.parseOrientation(json, true);
            const center = Reader.parsePoint3dProperty(json, "center");
            const radiusA = Reader.parseNumberProperty(json, "majorRadius");
            const radiusB = Reader.parseNumberProperty(json, "minorRadius");
            const sweepAngle = Reader.parseAngleProperty(json, "sweepAngle", undefined);
            const capped = Reader.parseBooleanProperty(json, "capped", false);
            if (center
                && radiusA !== undefined
                && radiusB !== undefined) {
                return TorusPipe_1.TorusPipe.createDgnTorusPipe(center, axes.columnX(), axes.columnY(), radiusA, radiusB, sweepAngle ? sweepAngle : Angle_1.Angle.createDegrees(360), capped);
            }
            return undefined;
        }
        /** Parse an array object to array of Point3d instances. */
        static parsePointArray(json) {
            const points = [];
            if (json && Array.isArray(json)) {
                for (const member of json) {
                    if (Point3dVector3d_1.XYZ.isXAndY(member)) {
                        points.push(Point3dVector3d_1.Point3d.fromJSON(member));
                    }
                    else if (Geometry_1.Geometry.isNumberArray(member, 2)) {
                        points.push(Point3dVector3d_1.Point3d.fromJSON(member));
                    }
                }
            }
            return points;
        }
        /** Deserialize `json` to `GeometryQuery` instances. */
        static parse(json) {
            if (json !== undefined && json) {
                if (json.lineSegment !== undefined) {
                    return Reader.parseLineSegmentProps(json.lineSegment);
                }
                else if (json.lineString !== undefined) {
                    return LineString3d_1.LineString3d.create(Reader.parsePointArray(json.lineString));
                }
                else if (json.arc !== undefined) {
                    return Reader.parseArcObject(json.arc);
                }
                else if (json.hasOwnProperty("point")) {
                    return Reader.parseCoordinate(json.point);
                }
                else if (json.hasOwnProperty("bcurve")) {
                    return Reader.parseBcurve(json.bcurve);
                }
                else if (json.hasOwnProperty("path")) {
                    return Reader.parseCurveCollectionMembers(new Path_1.Path(), json.path);
                }
                else if (json.hasOwnProperty("loop")) {
                    return Reader.parseCurveCollectionMembers(new Loop_1.Loop(), json.loop);
                }
                else if (json.hasOwnProperty("parityRegion")) {
                    return Reader.parseCurveCollectionMembers(new ParityRegion_1.ParityRegion(), json.parityRegion);
                }
                else if (json.hasOwnProperty("unionRegion")) {
                    return Reader.parseCurveCollectionMembers(new UnionRegion_1.UnionRegion(), json.unionRegion);
                }
                else if (json.hasOwnProperty("bagOfCurves")) {
                    return Reader.parseCurveCollectionMembers(new CurveCollection_1.BagOfCurves(), json.bagOfCurves);
                }
                else if (json.hasOwnProperty("indexedMesh")) {
                    return Reader.parseIndexedMesh(json.indexedMesh);
                }
                else if (json.hasOwnProperty("bsurf")) {
                    return Reader.parseBsurf(json.bsurf);
                }
                else if (json.hasOwnProperty("cone")) {
                    return Reader.parseConeProps(json.cone);
                }
                else if (json.hasOwnProperty("cylinder")) {
                    return Reader.parseCylinderProps(json.cylinder);
                }
                else if (json.hasOwnProperty("sphere")) {
                    return Reader.parseSphere(json.sphere);
                }
                else if (json.hasOwnProperty("linearSweep")) {
                    return Reader.parseLinearSweep(json.linearSweep);
                }
                else if (json.hasOwnProperty("box")) {
                    return Reader.parseBox(json.box);
                }
                else if (json.hasOwnProperty("rotationalSweep")) {
                    return Reader.parseRotationalSweep(json.rotationalSweep);
                }
                else if (json.hasOwnProperty("ruledSweep")) {
                    return Reader.parseRuledSweep(json.ruledSweep);
                }
                else if (json.hasOwnProperty("torusPipe")) {
                    return Reader.parseTorusPipe(json.torusPipe);
                }
                else if (json.hasOwnProperty("pointString")) {
                    return PointString3d_1.PointString3d.create(Reader.parsePointArray(json.pointString));
                }
                else if (json.hasOwnProperty("transitionSpiral")) {
                    return Reader.parseTransitionSpiral(json.transitionSpiral);
                }
                else if (Array.isArray(json))
                    return Reader.parseArray(json);
            }
            return undefined;
        }
    }
    IModelJson.Reader = Reader;
    // ISSUE: include 3d in names?
    // ISSUE: would like shorter term than lineSegment
    // ISSUE: is arc clear?
    // ISSUE: label center, vectorX, vector90 on arc?
    // ISSUE: sweep data on arc -- serialize as AngleSweep?
    /**
     * Class to deserialize json objects into GeometryQuery objects
     * @public
     */
    class Writer extends GeometryHandler_1.GeometryHandler {
        /** Convert strongly typed instance to tagged json */
        handleLineSegment3d(data) {
            return { "lineSegment": [data.point0Ref.toJSON(), data.point1Ref.toJSON()] };
        }
        /** Convert strongly typed instance to tagged json */
        handleCoordinateXYZ(data) {
            return { "point": data.point.toJSON() };
        }
        /** Convert strongly typed instance to tagged json */
        handleArc3d(data) {
            return {
                "arc": {
                    "center": data.center.toJSON(),
                    "vectorX": data.vector0.toJSON(),
                    "vectorY": data.vector90.toJSON(),
                    "sweepStartEnd": [data.sweep.startDegrees, data.sweep.endDegrees],
                },
            };
        }
        /**
         * Insert orientation description to a data object.
         * @param matrix matrix with orientation
         * @param omitIfIdentity omit the axis data if the matrix is an identity.
         * @param data AxesProps object to be annotated.
         */
        static insertOrientationFromMatrix(data, matrix, omitIfIdentity) {
            if (omitIfIdentity) {
                if (matrix === undefined)
                    return;
                if (matrix.isIdentity)
                    return;
            }
            if (matrix)
                data.xyVectors = [matrix.columnX().toJSON(), matrix.columnY().toJSON()];
            else
                data.xyVectors = [[1, 0, 0], [0, 1, 0]];
        }
        static isIdentityXY(xVector, yVector) {
            return xVector.isAlmostEqualXYZ(1, 0, 0) && yVector.isAlmostEqualXYZ(0, 1, 0);
        }
        /**
         * Insert orientation description to a data object.
         * @param matrix matrix with orientation
         * @param omitIfIdentity omit the axis data if the matrix is an identity.
         * @param data AxesProps object to be annotated.
         */
        static insertOrientationFromXYVectors(data, vectorX, vectorY, omitIfIdentity) {
            if (omitIfIdentity && Writer.isIdentityXY(vectorX, vectorY))
                return;
            data.xyVectors = [vectorX.toJSON(), vectorY.toJSON()];
        }
        /**
         * Insert orientation description to a data object, with orientation defined by u and v direction
         * vectors.
         * @param vectorX u direction
         * @param vectorV v direction
         * @param omitIfIdentity omit the axis data if the vectorU and vectorV are global x and y vectors.
         * @param data AxesProps object to be annotated.
         */
        static insertXYOrientation(data, vectorU, vectorV, omitIfIdentity) {
            if (omitIfIdentity) {
                if (vectorU.isAlmostEqualXYZ(1, 0, 0) && vectorV.isAlmostEqualXYZ(0, 1, 0))
                    return;
            }
            data.xyVectors = [vectorU.toJSON(), vectorV.toJSON()];
        }
        /**
         * parse properties of a TransitionSpiral.
         * @alpha
         */
        handleTransitionSpiral(data) {
            // TODO: HANDLE NONRIGID TRANSFORM !!
            // the spiral may have indication of how it was defined.  If so, use defined/undefined state of the original data
            // as indication of what current data to use.  (Current data may have changed due to transforms.)
            const originalProperties = data.originalProperties;
            const value = {
                origin: data.localToWorld.origin.toJSON(),
                type: data.getSpiralType(),
            };
            Writer.insertOrientationFromMatrix(value, data.localToWorld.matrix, true);
            if (!data.activeFractionInterval.isExact01)
                value.fractionInterval = [data.activeFractionInterval.x0, data.activeFractionInterval.x1];
            // Object.defineProperty(value, "fractionInterval", { value: [data.activeFractionInterval.x0, data.activeFractionInterval.x1] });
            // if possible, do selective output of defining data (omit exactly one out of the 5, matching original definition)
            if (originalProperties !== undefined && originalProperties.numDefinedProperties() === 4) {
                if (originalProperties.radius0 !== undefined)
                    value.startRadius = data.radius01.x0;
                if (originalProperties.radius1 !== undefined)
                    value.endRadius = data.radius01.x1;
                if (originalProperties.bearing0 !== undefined)
                    value.startBearing = data.bearing01.startAngle.toJSON();
                if (originalProperties.bearing1 !== undefined)
                    value.endBearing = data.bearing01.endAngle.toJSON();
                if (originalProperties.curveLength !== undefined)
                    value.curveLength = data.curveLength();
            }
            else {
                // uh oh ... no original data, but the spiral itself knows all 5 values.  We don't know which to consider primary.
                // DECISION -- put everything out, let readers make sense if they can. (It should be consistent ?)
                value.startRadius = data.radius01.x0;
                value.endRadius = data.radius01.x1;
                value.startBearing = data.bearing01.startAngle.toJSON();
                value.endBearing = data.bearing01.endAngle.toJSON();
                value.curveLength = data.curveLength();
            }
            return { "transitionSpiral": value };
        }
        /** Convert strongly typed instance to tagged json */
        handleCone(data) {
            const radiusA = data.getRadiusA();
            const radiusB = data.getRadiusB();
            const centerA = data.getCenterA();
            const centerB = data.getCenterB();
            const vectorX = data.getVectorX();
            const vectorY = data.getVectorY();
            const axisVector = Point3dVector3d_1.Vector3d.createStartEnd(centerA, centerB);
            if (Geometry_1.Geometry.isSameCoordinate(radiusA, radiusB)
                && vectorX.isPerpendicularTo(axisVector)
                && vectorY.isPerpendicularTo(axisVector)
                && Geometry_1.Geometry.isSameCoordinate(vectorX.magnitude(), 1.0)
                && Geometry_1.Geometry.isSameCoordinate(vectorY.magnitude(), 1.0)) {
                return {
                    "cylinder": {
                        "capped": data.capped,
                        "start": data.getCenterA().toJSON(),
                        "end": data.getCenterB().toJSON(),
                        "radius": radiusA,
                    },
                };
            }
            else {
                const coneProps = {
                    "capped": data.capped,
                    "start": data.getCenterA().toJSON(),
                    "end": data.getCenterB().toJSON(),
                    "startRadius": data.getRadiusA(),
                    "endRadius": data.getRadiusB(),
                };
                Writer.insertOrientationFromXYVectors(coneProps, vectorX, vectorY, false);
                return { "cone": coneProps };
            }
        }
        /** Convert strongly typed instance to tagged json */
        handleSphere(data) {
            const xData = data.cloneVectorX().normalizeWithLength();
            const yData = data.cloneVectorY().normalizeWithLength();
            const zData = data.cloneVectorZ().normalizeWithLength();
            const latitudeSweep = data.cloneLatitudeSweep();
            const rX = xData.mag;
            const rY = yData.mag;
            const rZ = zData.mag;
            if (xData.v && zData.v) {
                const value = {
                    "center": data.cloneCenter().toJSON(),
                };
                if (!(data.getConstructiveFrame()).matrix.isIdentity)
                    value.zxVectors = [zData.v.toJSON(), xData.v.toJSON()];
                const fullSweep = latitudeSweep.isFullLatitudeSweep;
                if (data.capped && !fullSweep)
                    value.capped = data.capped;
                if (Geometry_1.Geometry.isSameCoordinate(rX, rY) && Geometry_1.Geometry.isSameCoordinate(rX, rZ))
                    value.radius = rX;
                else {
                    value.radiusX = rX;
                    value.radiusY = rY;
                    value.radiusZ = rZ;
                }
                if (!fullSweep)
                    value.latitudeStartEnd = latitudeSweep.toJSON();
                return { "sphere": value };
            }
            return undefined;
        }
        /** Convert strongly typed instance to tagged json */
        handleTorusPipe(data) {
            const vectorX = data.cloneVectorX();
            const vectorY = data.cloneVectorY();
            const radiusA = data.getMajorRadius();
            const radiusB = data.getMinorRadius();
            const sweep = data.getSweepAngle();
            if (data.getIsReversed()) {
                vectorY.scaleInPlace(-1.0);
                sweep.setRadians(-sweep.radians);
            }
            const value = {
                "center": data.cloneCenter().toJSON(),
                "majorRadius": radiusA,
                "minorRadius": radiusB,
                "xyVectors": [vectorX.toJSON(), vectorY.toJSON()],
            };
            if (!sweep.isFullCircle) {
                value.sweepAngle = sweep.degrees;
                value.capped = data.capped;
            }
            return { "torusPipe": value };
        }
        /** Convert strongly typed instance to tagged json */
        handleLineString3d(data) {
            const pointsA = data.points;
            const pointsB = [];
            if (pointsA)
                for (const p of pointsA)
                    pointsB.push(p.toJSON());
            return { "lineString": pointsB };
        }
        /** Convert strongly typed instance to tagged json */
        handlePointString3d(data) {
            const pointsA = data.points;
            const pointsB = [];
            if (pointsA)
                for (const p of pointsA)
                    pointsB.push(p.toJSON());
            return { "pointString": pointsB };
        }
        /** Convert strongly typed instance to tagged json */
        handlePath(data) {
            return { "path": this.collectChildren(data) };
        }
        /** Convert strongly typed instance to tagged json */
        handleLoop(data) {
            return { "loop": this.collectChildren(data) };
        }
        /** Convert strongly typed instance to tagged json */
        handleParityRegion(data) {
            return { "parityRegion": this.collectChildren(data) };
        }
        /** Convert strongly typed instance to tagged json */
        handleUnionRegion(data) {
            return { "unionRegion": this.collectChildren(data) };
        }
        /** Convert strongly typed instance to tagged json */
        handleBagOfCurves(data) {
            return { "bagOfCurves": this.collectChildren(data) };
        }
        collectChildren(data) {
            const children = [];
            if (data.children && Array.isArray(data.children)) {
                for (const child of data.children) {
                    const cdata = child.dispatchToGeometryHandler(this);
                    if (cdata)
                        children.push(cdata);
                }
            }
            return children;
        }
        /** Convert strongly typed instance to tagged json */
        handleLinearSweep(data) {
            const extrusionVector = data.cloneSweepVector();
            const curves = data.getCurvesRef();
            const capped = data.capped;
            if (extrusionVector
                && curves
                && capped !== undefined) {
                return {
                    "linearSweep": {
                        "contour": curves.dispatchToGeometryHandler(this),
                        "capped": capped,
                        "vector": extrusionVector.toJSON(),
                    },
                };
            }
            return undefined;
        }
        /** Convert strongly typed instance to tagged json */
        handleRuledSweep(data) {
            const contours = data.cloneContours();
            const capped = data.capped;
            if (contours
                && contours.length > 1
                && capped !== undefined) {
                const jsonContours = [];
                for (const c of contours) {
                    jsonContours.push(this.emit(c));
                }
                return {
                    "ruledSweep": {
                        "contour": jsonContours,
                        "capped": capped,
                    },
                };
            }
            return undefined;
        }
        /** Convert strongly typed instance to tagged json */
        handleRotationalSweep(data) {
            const axisRay = data.cloneAxisRay();
            const curves = data.getCurves();
            const capped = data.capped;
            const sweepAngle = data.getSweep();
            return {
                "rotationalSweep": {
                    "axis": axisRay.direction.toJSON(),
                    "contour": curves.dispatchToGeometryHandler(this),
                    "capped": capped,
                    "center": axisRay.origin.toJSON(),
                    "sweepAngle": sweepAngle.degrees,
                },
            };
        }
        /** Convert strongly typed instance to tagged json */
        handleBox(box) {
            const out = {
                "box": {
                    "baseOrigin": box.getBaseOrigin().toJSON(),
                    "baseX": box.getBaseX(),
                    "baseY": box.getBaseY(),
                    "capped": box.capped,
                    "topOrigin": box.getTopOrigin().toJSON(),
                },
            };
            Writer.insertXYOrientation(out.box, box.getVectorX(), box.getVectorY(), true);
            if (!Geometry_1.Geometry.isSameCoordinate(box.getTopX(), box.getBaseX()))
                out.box.topX = box.getTopX();
            if (!Geometry_1.Geometry.isSameCoordinate(box.getTopY(), box.getBaseY()))
                out.box.topY = box.getTopY();
            return out;
        }
        handlePolyfaceAuxData(auxData, pf) {
            const contents = {};
            contents.indices = [];
            const visitor = pf.createVisitor(0);
            if (!visitor.auxData)
                return;
            while (visitor.moveToNextFacet()) {
                for (let i = 0; i < visitor.indexCount; i++) {
                    contents.indices.push(visitor.auxData.indices[i] + 1);
                }
                contents.indices.push(0); // facet terminator.
            }
            contents.channels = [];
            for (const inChannel of auxData.channels) {
                const outChannel = {};
                outChannel.dataType = inChannel.dataType;
                outChannel.name = inChannel.name;
                outChannel.inputName = inChannel.inputName;
                outChannel.data = [];
                for (const inData of inChannel.data) {
                    const outData = {};
                    outData.input = inData.input;
                    outData.values = inData.values.slice(0);
                    outChannel.data.push(outData);
                }
                contents.channels.push(outChannel);
            }
            return contents;
        }
        /** Convert strongly typed instance to tagged json */
        handleIndexedPolyface(pf) {
            const points = [];
            const pointIndex = [];
            const normals = [];
            const params = [];
            const colors = [];
            {
                const p = Point3dVector3d_1.Point3d.create();
                for (let i = 0; pf.data.point.getPoint3dAtCheckedPointIndex(i, p); i++)
                    points.push(p.toJSON());
            }
            if (pf.data.normal) {
                const numNormal = pf.data.normal.length;
                const normal = Point3dVector3d_1.Vector3d.create();
                for (let i = 0; i < numNormal; i++) {
                    pf.data.normal.getVector3dAtCheckedVectorIndex(i, normal);
                    normals.push(normal.toJSON());
                }
            }
            if (pf.data.param) {
                const uv = Point2dVector2d_1.Point2d.create();
                for (let i = 0; pf.data.param.getPoint2dAtCheckedPointIndex(i, uv); i++)
                    params.push(uv.toJSON());
            }
            if (pf.data.color) {
                for (const value of pf.data.color)
                    colors.push(value);
            }
            const visitor = pf.createVisitor(0);
            let indexCounter = 0;
            const normalIndex = [];
            const paramIndex = [];
            const colorIndex = [];
            let n;
            while (visitor.moveToNextFacet()) {
                n = visitor.indexCount;
                // All meshes have point and point index ...
                for (let i = 0; i < n; i++) {
                    // Change sign of value to be pushed based on whether or not the edge was originally visible or not
                    const toPush = pf.data.edgeVisible[indexCounter + i] ? visitor.pointIndex[i] + 1 : -(visitor.clientPointIndex(i) + 1);
                    pointIndex.push(toPush);
                }
                pointIndex.push(0); // facet terminator.
                indexCounter += visitor.indexCount;
                if (visitor.normalIndex) {
                    for (let i = 0; i < n; i++)
                        normalIndex.push(1 + visitor.clientNormalIndex(i));
                    normalIndex.push(0);
                }
                if (visitor.paramIndex) {
                    for (let i = 0; i < n; i++)
                        paramIndex.push(1 + visitor.clientParamIndex(i));
                    paramIndex.push(0);
                }
                if (visitor.colorIndex) {
                    for (let i = 0; i < n; i++)
                        colorIndex.push(1 + visitor.clientColorIndex(i));
                    colorIndex.push(0);
                }
            }
            // assemble the contents in alphabetical order.
            const contents = {};
            if (pf.twoSided)
                contents.twoSided = true;
            if (pf.data.auxData)
                contents.auxData = this.handlePolyfaceAuxData(pf.data.auxData, pf);
            if (pf.data.color)
                contents.color = colors;
            if (pf.data.colorIndex)
                contents.colorIndex = colorIndex;
            if (pf.data.normal)
                contents.normal = normals;
            if (pf.data.normalIndex)
                contents.normalIndex = normalIndex;
            if (pf.data.param)
                contents.param = params;
            if (pf.data.paramIndex)
                contents.paramIndex = paramIndex;
            contents.point = points;
            contents.pointIndex = pointIndex;
            return { "indexedMesh": contents };
        }
        /** Convert strongly typed instance to tagged json */
        handleBSplineCurve3d(curve) {
            // ASSUME -- if the curve originated "closed" the knot and pole replication are unchanged,
            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.
            const wrapMode = curve.isClosable;
            if (wrapMode === KnotVector_1.BSplineWrapMode.OpenByAddingControlPoints) {
                const knots = curve.copyKnots(true);
                const poles = curve.copyPoints();
                const degree = curve.degree;
                for (let i = 0; i < degree; i++)
                    poles.pop();
                // knots have replicated first and last.  Change the values to be periodic.
                const leftIndex = degree;
                const rightIndex = knots.length - degree - 1;
                const knotPeriod = knots[rightIndex] - knots[leftIndex];
                knots[0] = knots[rightIndex - degree] - knotPeriod;
                knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;
                return {
                    "bcurve": {
                        "points": poles,
                        "knots": knots,
                        "closed": true,
                        "order": curve.order,
                    },
                };
            }
            else if (curve.isClosable === KnotVector_1.BSplineWrapMode.OpenByRemovingKnots) {
                // special case to re-close the case that originated as :    a a0 a0 .. a0 knot0 knot1 knot2 ... b1 b1 .. b1 b
                // with (order) copies of a0 and b1 (usually 0 and 1)
                // and a,b are related to the interior knots
                // (This is the "bezier saturated arc")
                const rawKnots = curve.copyKnots(false); // unchanged knots . . .
                const poles = curve.copyPoints();
                const degree = curve.degree;
                const leftIndex = degree - 1;
                const rightIndex = rawKnots.length - degree;
                const leftKnot = rawKnots[leftIndex];
                const rightKnot = rawKnots[rightIndex];
                const knotPeriod = rightKnot - leftKnot;
                const knots = [];
                knots.push(rawKnots[rightIndex - 1] - knotPeriod);
                knots.push(leftKnot);
                for (const k of rawKnots)
                    knots.push(k);
                knots.push(rightKnot);
                knots.push(rawKnots[leftIndex + 1] + knotPeriod);
                return {
                    "bcurve": {
                        "points": poles,
                        "knots": knots,
                        "closed": true,
                        "order": curve.order,
                    },
                };
            }
            else {
                return {
                    "bcurve": {
                        "points": curve.copyPoints(),
                        "knots": curve.copyKnots(true),
                        "closed": false,
                        "order": curve.order,
                    },
                };
            }
        }
        /** Convert strongly typed instance to tagged json */
        handleBezierCurve3d(curve) {
            const knots = [];
            const order = curve.order;
            for (let i = 0; i < order; i++)
                knots.push(0.0);
            for (let i = 0; i < order; i++)
                knots.push(1.0);
            return {
                "bcurve": {
                    "points": curve.copyPolesAsJsonArray(),
                    "knots": knots,
                    "closed": false,
                    "order": curve.order,
                },
            };
        }
        /** Convert strongly typed instance to tagged json */
        handleBSplineCurve3dH(curve) {
            // ASSUME -- if the curve originated "closed" the knot and pole replication are unchanged,
            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.
            if (curve.isClosable) {
                const knots = curve.copyKnots(true);
                const poles = curve.copyPoints();
                const degree = curve.degree;
                for (let i = 0; i < degree; i++)
                    poles.pop();
                // knots have replicated first and last.  Change the values to be periodic.
                const leftIndex = degree;
                const rightIndex = knots.length - degree - 1;
                const knotPeriod = knots[rightIndex] - knots[leftIndex];
                knots[0] = knots[rightIndex - degree] - knotPeriod;
                knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;
                return {
                    "bcurve": {
                        "points": poles,
                        "knots": knots,
                        "closed": true,
                        "order": curve.order,
                    },
                };
            }
            else {
                return {
                    "bcurve": {
                        "points": curve.copyPoints(),
                        "knots": curve.copyKnots(true),
                        "closed": false,
                        "order": curve.order,
                    },
                };
            }
        }
        /** Convert strongly typed instance to tagged json */
        handleBSplineSurface3d(surface) {
            // ASSUME -- if the curve originated "closed" the knot and pole replication are unchanged,
            // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.
            const periodicU = surface.isClosable(0);
            const periodicV = surface.isClosable(1);
            if (periodicU || periodicV) {
                let numUPoles = surface.numPolesUV(0);
                let numVPoles = surface.numPolesUV(1);
                if (periodicU)
                    numUPoles -= surface.degreeUV(0);
                if (periodicV)
                    numVPoles -= surface.degreeUV(1);
                const xyz = Point3dVector3d_1.Point3d.create();
                const grid = [];
                for (let j = 0; j < numVPoles; j++) {
                    const stringer = [];
                    for (let i = 0; i < numUPoles; i++) {
                        surface.getPoint3dPole(i, j, xyz);
                        stringer.push([xyz.x, xyz.y, xyz.z]);
                    }
                    grid.push(stringer);
                }
                return {
                    "bsurf": {
                        "points": grid,
                        "uKnots": surface.copyKnots(0, true),
                        "vKnots": surface.copyKnots(1, true),
                        "orderU": surface.orderUV(0),
                        "orderV": surface.orderUV(1),
                        "closedU": periodicU,
                        "closedV": periodicV,
                    },
                };
            }
            else {
                return {
                    "bsurf": {
                        "points": surface.getPointArray(false),
                        "uKnots": surface.copyKnots(0, true),
                        "vKnots": surface.copyKnots(1, true),
                        "orderU": surface.orderUV(0),
                        "orderV": surface.orderUV(1),
                    },
                };
            }
        }
        /** Convert strongly typed instance to tagged json */
        handleBezierCurve3dH(curve) {
            const knots = [];
            const order = curve.order;
            for (let i = 0; i < order; i++)
                knots.push(0.0);
            for (let i = 0; i < order; i++)
                knots.push(1.0);
            return {
                "bcurve": {
                    "points": curve.copyPolesAsJsonArray(),
                    "knots": knots,
                    "closed": false,
                    "order": curve.order,
                },
            };
        }
        /** Convert strongly typed instance to tagged json */
        handleBSplineSurface3dH(surface) {
            const data = surface.getPointGridJSON();
            return {
                "bsurf": {
                    "points": data.points,
                    "uKnots": surface.copyKnots(0, true),
                    "vKnots": surface.copyKnots(1, true),
                    "orderU": surface.orderUV(0),
                    "orderV": surface.orderUV(1),
                },
            };
        }
        /** Convert an array of strongly typed instances to an array of tagged json */
        emitArray(data) {
            const members = [];
            for (const c of data) {
                const toPush = this.emit(c);
                members.push(toPush);
            }
            return members;
        }
        /** Convert GeometryQuery data (array or single instance) to instance to tagged json */
        emit(data) {
            if (Array.isArray(data))
                return this.emitArray(data);
            if (data instanceof GeometryQuery_1.GeometryQuery) {
                return data.dispatchToGeometryHandler(this);
            }
            return undefined;
        }
        /** One-step static method to create a writer and emit a json object */
        static toIModelJson(data) {
            const writer = new Writer();
            return writer.emit(data);
        }
    }
    IModelJson.Writer = Writer;
})(IModelJson = exports.IModelJson || (exports.IModelJson = {}));


/***/ }),

/***/ "./lib/solid/Box.js":
/*!**************************!*\
  !*** ./lib/solid/Box.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Solid */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
/**
 * A box-like solid defined by
 * * A local coordinate frame
 *   * (0,0,0) is left lower rear corner of box (considering "left" to reference x, "lower" to reference y, "rear and front" to reference z=0 and z=1)
 *   * (0,0,1) is left lower front corner.
 *   * (baseX,baseY,z) is right upper corner at z
 *   * note that the frame x and y columns are usually unit vectors in local space, but z is full rear to front vector
 * * The separate values for base and top x and y allow the box to be a "view frustum" with parallel back and front planes but independent x and y bellows effects.
 * @public
 */
class Box extends SolidPrimitive_1.SolidPrimitive {
    constructor(map, baseX, baseY, topX, topY, capped) {
        super(capped);
        /** String name for schema properties */
        this.solidPrimitiveType = "box";
        this._localToWorld = map;
        this._baseX = baseX;
        this._baseY = baseY;
        this._topX = topX;
        this._topY = topY;
    }
    /** Return a clone */
    clone() {
        return new Box(this._localToWorld.clone(), this._baseX, this._baseY, this._topX, this._topY, this.capped);
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin lower left of box
     * * x direction on base rectangle x edge
     * * y direction in base rectangle
     * * z direction perpendicular
     */
    getConstructiveFrame() {
        return this._localToWorld.cloneRigid();
    }
    /** Apply the transform to the box's `localToWorld` frame.
     * * Note that this may make the frame nonrigid.
     */
    tryTransformInPlace(transform) {
        if (transform.matrix.isSingular())
            return false;
        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);
        return true;
    }
    /** Clone the box and immediately apply `transform` to the local frame of the clone. */
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);
        return result;
    }
    /**
     * Create a new box from vector and size daa.
     * @param baseOrigin Origin of base rectangle
     * @param vectorX  Direction for base rectangle
     * @param vectorY Direction for base rectangle
     * @param topOrigin origin of top rectangle
     * @param baseX size factor for base rectangle (multiplies vectorX)
     * @param baseY size factor for base rectangle (multiplies vectorY)
     * @param topX size factor for top rectangle (multiplies vectorX)
     * @param topY size factor for top rectangle (multiplies vectorY)
     * @param capped true to define top and bottom closure caps
     */
    static createDgnBox(baseOrigin, vectorX, vectorY, topOrigin, baseX, baseY, topX, topY, capped) {
        const vectorZ = baseOrigin.vectorTo(topOrigin);
        const localToWorld = Transform_1.Transform.createOriginAndMatrixColumns(baseOrigin, vectorX, vectorY, vectorZ);
        return new Box(localToWorld, baseX, baseY, topX, topY, capped);
    }
    /**
     * Create a new box with xy directions taken from columns of the `axes` matrix.
     * @param baseOrigin Origin of base rectangle
     * @param axes  Direction for base rectangle
     * @param topOrigin origin of top rectangle
     * @param baseX size factor for base rectangle (multiplies vectorX)
     * @param baseY size factor for base rectangle (multiplies vectorY)
     * @param topX size factor for top rectangle (multiplies vectorX)
     * @param topY size factor for top rectangle (multiplies vectorY)
     * @param capped true to define top and bottom closure caps
     */
    static createDgnBoxWithAxes(baseOrigin, axes, topOrigin, baseX, baseY, topX, topY, capped) {
        return Box.createDgnBox(baseOrigin, axes.columnX(), axes.columnY(), topOrigin, baseX, baseY, topX, topY, capped);
    }
    /**
     * Create an axis-aligned `Box` primitive for a range.
     * @param range range corners Origin of base rectangle
     * @param capped true to define top and bottom closure caps
     */
    static createRange(range, capped) {
        if (!range.isNull) {
            const lowPoint = range.low;
            const xSize = range.xLength();
            const ySize = range.yLength();
            const zPoint = range.low.clone();
            zPoint.z = zPoint.z + range.zLength();
            return Box.createDgnBox(lowPoint, Point3dVector3d_1.Vector3d.unitX(), Point3dVector3d_1.Vector3d.unitY(), zPoint, xSize, ySize, xSize, ySize, capped);
        }
        return undefined;
    }
    /** (property accessor) return the x length at z = 0 */
    getBaseX() { return this._baseX; }
    /** (property accessor) return the y length at z = 0 */
    getBaseY() { return this._baseY; }
    /** (property accessor) return the x length at z = 1 */
    getTopX() { return this._topX; }
    /** (property accessor) return the x length at z = 1 */
    getTopY() { return this._topY; }
    /** (property accessor) return the local coordinates point (0,0,0) to world */
    getBaseOrigin() { return this._localToWorld.multiplyXYZ(0, 0, 0); }
    /** (property accessor) return the local coordinates point (0,0,1) to world */
    getTopOrigin() { return this._localToWorld.multiplyXYZ(0, 0, 1); }
    /** (property accessor) return the local coordinate frame x vector */
    getVectorX() { return this._localToWorld.matrix.columnX(); }
    /** (property accessor) return the local coordinate frame y vector */
    getVectorY() { return this._localToWorld.matrix.columnY(); }
    /** (property accessor) return the local coordinate frame z vector */
    getVectorZ() { return this._localToWorld.matrix.columnZ(); }
    /** Test of `other` is also of class `Box` */
    isSameGeometryClass(other) { return other instanceof Box; }
    /** test for near equality */
    isAlmostEqual(other) {
        if (other instanceof Box) {
            if (this.capped !== other.capped)
                return false;
            if (!this._localToWorld.isAlmostEqual(other._localToWorld))
                return false;
            return Geometry_1.Geometry.isSameCoordinate(this._baseX, other._baseX)
                && Geometry_1.Geometry.isSameCoordinate(this._baseY, other._baseY)
                && Geometry_1.Geometry.isSameCoordinate(this._topX, other._topX)
                && Geometry_1.Geometry.isSameCoordinate(this._topY, other._topY);
        }
        return false;
    }
    /** Second step of double dispatch:  call `handler.handleBox(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleBox(this);
    }
    /** Return strokes of the cross-section rectangle at local z coordinate */
    strokeConstantVSection(zFraction) {
        const ax = Geometry_1.Geometry.interpolate(this._baseX, zFraction, this._topX);
        const ay = Geometry_1.Geometry.interpolate(this._baseY, zFraction, this._topY);
        const result = LineString3d_1.LineString3d.create();
        const transform = this._localToWorld;
        const workPoint = Point3dVector3d_1.Point3d.create();
        transform.multiplyXYZ(0, 0, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(ax, 0, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(ax, ay, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(0, ay, zFraction, workPoint);
        result.addPoint(workPoint);
        transform.multiplyXYZ(0, 0, zFraction, workPoint);
        result.addPoint(workPoint);
        return result;
    }
    /**
     * Returns the 8 corners in x fastest, then y, finally z lexical order.
     */
    getCorners() {
        const transform = this._localToWorld;
        const ax = this._baseX;
        const ay = this._baseY;
        const bx = this._topX;
        const by = this._topY;
        return [transform.multiplyXYZ(0, 0, 0),
            transform.multiplyXYZ(ax, 0, 0),
            transform.multiplyXYZ(0, ay, 0),
            transform.multiplyXYZ(ax, ay, 0),
            transform.multiplyXYZ(0, 0, 1),
            transform.multiplyXYZ(bx, 0, 1),
            transform.multiplyXYZ(0, by, 1),
            transform.multiplyXYZ(bx, by, 1)];
    }
    /**
     * Consider the box sides (not top and bottom) as a (u,v) surface with
     * * v = 0 as the z=0 local plane
     * * v = 1 as the z=1 local plane
     * Return the (rectangular) section at fractional v
     */
    constantVSection(zFraction) {
        const ls = this.strokeConstantVSection(zFraction);
        return Loop_1.Loop.create(ls);
    }
    /** Extend  `rangeToExtend` by each of the 8 corners */
    extendRange(rangeToExtend, transform) {
        const boxTransform = this._localToWorld;
        const ax = this._baseX;
        const ay = this._baseY;
        const bx = this._topX;
        const by = this._topY;
        if (transform) {
            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 0);
            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, ax, 0, 0);
            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, ay, 0);
            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, ax, ay, 0);
            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 1);
            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, bx, 0, 1);
            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, by, 1);
            rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, bx, by, 1);
        }
        else {
            rangeToExtend.extendTransformedXYZ(boxTransform, 0, 0, 0);
            rangeToExtend.extendTransformedXYZ(boxTransform, ax, 0, 0);
            rangeToExtend.extendTransformedXYZ(boxTransform, 0, ay, 0);
            rangeToExtend.extendTransformedXYZ(boxTransform, ax, ay, 0);
            rangeToExtend.extendTransformedXYZ(boxTransform, 0, 0, 1);
            rangeToExtend.extendTransformedXYZ(boxTransform, bx, 0, 1);
            rangeToExtend.extendTransformedXYZ(boxTransform, 0, by, 1);
            rangeToExtend.extendTransformedXYZ(boxTransform, bx, by, 1);
        }
    }
    /**
     * @return true if this is a closed volume.
     */
    get isClosedVolume() {
        return this.capped;
    }
}
exports.Box = Box;


/***/ }),

/***/ "./lib/solid/Cone.js":
/*!***************************!*\
  !*** ./lib/solid/Cone.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Solid */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
/**
 * A cone with axis along the z axis of a (possibly skewed) local coordinate system.
 *
 * * In local coordinates, the sections at z=0 and z=1 are circles of radius r0 and r1.
 * * Either one individually  may be zero, but they may not both be zero.
 * * The stored matrix has unit vectors in the xy columns, and full-length z column.
 * @public
 */
class Cone extends SolidPrimitive_1.SolidPrimitive {
    constructor(map, radiusA, radiusB, capped) {
        super(capped);
        /** String name for schema properties */
        this.solidPrimitiveType = "cone";
        this._localToWorld = map;
        this._radiusA = radiusA;
        this._radiusB = radiusB;
        this._maxRadius = Math.max(this._radiusA, this._radiusB); // um... should resolve elliptical sections
    }
    /** Return a clone of this Cone. */
    clone() {
        return new Cone(this._localToWorld.clone(), this._radiusA, this._radiusB, this.capped);
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin at center of the base circle.
     * * base circle in the xy plane
     * * z axis by right hand rule.
     */
    getConstructiveFrame() {
        return this._localToWorld.cloneRigid();
    }
    /** Apply the transform to this cone's locla to world coordinates.
     * * Note that the radii are not changed.  Scaling is absorbed into the frame.
     * * This fails if the transformation is singular.
     */
    tryTransformInPlace(transform) {
        if (transform.matrix.isSingular())
            return false;
        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);
        return true;
    }
    /**
     * Create a clone and immediately transform the clone.
     */
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);
        return result;
    }
    /** create a cylinder or cone from two endpoints and their radii.   The circular cross sections are perpendicular to the axis line
     * from start to end point.
     * * both radii must be of the same sign.
     * * negative radius is accepted to create interior surface.    Downstream effects of that combined with capping may be a problem.
     */
    static createAxisPoints(centerA, centerB, radiusA, radiusB, capped) {
        const zDirection = centerA.vectorTo(centerB);
        const a = zDirection.magnitude();
        if (Geometry_1.Geometry.isSmallMetricDistance(a))
            return undefined;
        // force near-zero radii to true zero
        radiusA = Geometry_1.Geometry.correctSmallMetricDistance(radiusA);
        radiusB = Geometry_1.Geometry.correctSmallMetricDistance(radiusB);
        // cone tip may not be "within" the z range.
        if (radiusA * radiusB < 0.0)
            return undefined;
        // at least one must be nonzero.
        if (radiusA + radiusB === 0.0)
            return undefined;
        const matrix = Matrix3d_1.Matrix3d.createRigidHeadsUp(zDirection);
        matrix.scaleColumns(1.0, 1.0, a, matrix);
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(centerA, matrix);
        return new Cone(localToWorld, radiusA, radiusB, capped);
    }
    /** create a cylinder or cone from axis start and end with cross section defined by vectors that do not need to be perpendicular to each other or
     * to the axis.
     */
    static createBaseAndTarget(centerA, centerB, vectorX, vectorY, radiusA, radiusB, capped) {
        radiusA = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(radiusA));
        radiusB = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(radiusB));
        const vectorZ = centerA.vectorTo(centerB);
        const localToWorld = Transform_1.Transform.createOriginAndMatrixColumns(centerA, vectorX, vectorY, vectorZ);
        return new Cone(localToWorld, radiusA, radiusB, capped);
    }
    /** (Property accessor) Return the center point at the base plane */
    getCenterA() { return this._localToWorld.multiplyXYZ(0, 0, 0); }
    /** (Property accessor) */
    getCenterB() { return this._localToWorld.multiplyXYZ(0, 0, 1); }
    /** (Property accessor) Return the x vector in the local frame */
    getVectorX() { return this._localToWorld.matrix.columnX(); }
    /** (Property accessor) Return the y vector in the local frame */
    getVectorY() { return this._localToWorld.matrix.columnY(); }
    /** (Property accessor) return the radius at the base plane */
    getRadiusA() { return this._radiusA; }
    /** (Property accessor) return the radius at the top plane */
    getRadiusB() { return this._radiusB; }
    /** (Property accessor) return the larger of the base and top plane radii */
    getMaxRadius() { return this._maxRadius; }
    /** (Property accessor) return the radius at fraction `v` along the axis */
    vFractionToRadius(v) { return Geometry_1.Geometry.interpolate(this._radiusA, v, this._radiusB); }
    /** (Property accessor) test if `other` is an instance of `Cone` */
    isSameGeometryClass(other) { return other instanceof Cone; }
    /** (Property accessor) Test for nearly equal coordinate data. */
    isAlmostEqual(other) {
        if (other instanceof Cone) {
            if (this.capped !== other.capped)
                return false;
            if (!this._localToWorld.isAlmostEqual(other._localToWorld))
                return false;
            return Geometry_1.Geometry.isSameCoordinate(this._radiusA, other._radiusA)
                && Geometry_1.Geometry.isSameCoordinate(this._radiusB, other._radiusB);
        }
        return false;
    }
    /** Second step of double dispatch:   call `handler.handleCone(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleCone(this);
    }
    /**
     *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.
     * * fixedStrokeCount takes priority over stroke options.
     * * The linestring is created by LineString3d.createForStrokes (fixedStrokeCount, options), which sets up property according to the options:
     *   * optional fractions member
     *   * optional uvParams.  uvParams are installed as full-scale distance parameters.
     *   * optional derivatives.
     * @param v fractional position along the cone axis
     * @param fixedStrokeCount optional stroke count.
     * @param options optional stroke options.
     */
    strokeConstantVSection(v, fixedStrokeCount, options) {
        let strokeCount = 16;
        if (fixedStrokeCount !== undefined)
            strokeCount = fixedStrokeCount;
        else if (options !== undefined)
            strokeCount = options.defaultCircleStrokes; // NEEDS WORK -- get circle stroke count with this.maxRadius !!!
        else {
            // accept the local default
        }
        strokeCount = Geometry_1.Geometry.clampToStartEnd(strokeCount, 4, 64);
        const r = this.vFractionToRadius(v);
        const result = LineString3d_1.LineString3d.createForStrokes(fixedStrokeCount, options);
        const twoPi = Math.PI * 2.0;
        const deltaRadians = twoPi / strokeCount;
        let radians = 0;
        const fractions = result.fractions; // possibly undefined !!!
        const derivatives = result.packedDerivatives; // possibly undefined !!!
        const uvParams = result.packedUVParams; // possibly undefined !!
        const surfaceNormals = result.packedSurfaceNormals;
        const xyz = Point3dVector3d_1.Point3d.create();
        const dXdu = Point3dVector3d_1.Vector3d.create();
        const dXdv = Point3dVector3d_1.Vector3d.create();
        const normal = Point3dVector3d_1.Vector3d.create();
        const transform = this._localToWorld;
        let rc, rs, cc, ss;
        for (let i = 0; i <= strokeCount; i++) {
            if (i * 2 <= strokeCount)
                radians = i * deltaRadians;
            else
                radians = (i - strokeCount) * deltaRadians;
            cc = Math.cos(radians);
            ss = Math.sin(radians);
            rc = r * cc;
            rs = r * ss;
            transform.multiplyXYZ(rc, rs, v, xyz);
            result.addPoint(xyz);
            if (fractions)
                fractions.push(i / strokeCount);
            if (derivatives) {
                transform.matrix.multiplyXYZ(-rs * twoPi, rc * twoPi, 0.0, dXdu);
                derivatives.push(dXdu);
            }
            if (surfaceNormals) {
                // the along-hoop vector does not need to be scaled by radius -- just need the direction for a cross product.
                transform.matrix.multiplyXYZ(-ss, cc, 0.0, dXdu);
                transform.matrix.multiplyXYZ(0, 0, 1, dXdv);
                dXdu.unitCrossProduct(dXdv, normal);
                surfaceNormals.push(normal);
            }
            if (uvParams) {
                uvParams.pushXY(i / strokeCount, v);
            }
        }
        return result;
    }
    /**
     * Return the Arc3d section at vFraction
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const r = this.vFractionToRadius(vFraction);
        const transform = this._localToWorld;
        const center = transform.multiplyXYZ(0, 0, vFraction);
        const vector0 = transform.matrix.multiplyXYZ(r, 0, 0);
        const vector90 = transform.matrix.multiplyXYZ(0, r, 0);
        return Loop_1.Loop.create(Arc3d_1.Arc3d.create(center, vector0, vector90));
    }
    /** Extend `rangeToExtend` so it includes this `Cone` instance. */
    extendRange(rangeToExtend, transform) {
        const arc0 = this.constantVSection(0.0);
        const arc1 = this.constantVSection(1.0);
        arc0.extendRange(rangeToExtend, transform);
        arc1.extendRange(rangeToExtend, transform);
    }
    /** Evaluate a point on the Cone surfaces, with
     * * v = 0 is the base plane.
     * * v = 1 is the top plane
     * * u = 0 to u = 1 wraps the angular range.
     */
    uvFractionToPoint(uFraction, vFraction, result) {
        const theta = uFraction * Math.PI * 2.0;
        const r = Geometry_1.Geometry.interpolate(this._radiusA, vFraction, this._radiusB);
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        return this._localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction, result);
    }
    /** Evaluate a point tangent plane on the Cone surfaces, with
     * * v = 0 is the base plane.
     * * v = 1 is the top plane
     * * u = 0 to u = 1 wraps the angular range.
     */
    uvFractionToPointAndTangents(uFraction, vFraction, result) {
        const theta = uFraction * Math.PI * 2.0;
        const r = Geometry_1.Geometry.interpolate(this._radiusA, vFraction, this._radiusB);
        const drdv = this._radiusB - this._radiusA;
        const cosTheta = Math.cos(theta);
        const sinTheta = Math.sin(theta);
        const fTheta = 2.0 * Math.PI;
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction), this._localToWorld.multiplyVectorXYZ(-r * sinTheta * fTheta, r * cosTheta * fTheta, 0), this._localToWorld.multiplyVectorXYZ(drdv * cosTheta, drdv * sinTheta, 1.0), result);
    }
    /**
     * @return true if this is a closed volume.
     */
    get isClosedVolume() {
        return this.capped;
    }
    /**
     * Directional distance query
     * * u direction is around longitude circle at maximum distance from axis.
     * * v direction is on a line of longitude between the latitude limits.
     */
    maxIsoParametricDistance() {
        const vectorX = this._localToWorld.matrix.columnX();
        const vectorY = this._localToWorld.matrix.columnY();
        const columnZ = this._localToWorld.matrix.columnZ();
        const xyNormal = vectorX.unitCrossProduct(vectorY);
        const hZ = xyNormal.dotProduct(columnZ);
        const zSkewVector = columnZ.plusScaled(xyNormal, hZ);
        const zSkewDistance = zSkewVector.magnitudeXY();
        return Point2dVector2d_1.Vector2d.create(Math.PI * 2 * Math.max(this._radiusA, this._radiusB), Geometry_1.Geometry.hypotenuseXY(Math.abs(this._radiusB - this._radiusA) + zSkewDistance, hZ));
    }
}
exports.Cone = Cone;


/***/ }),

/***/ "./lib/solid/LinearSweep.js":
/*!**********************************!*\
  !*** ./lib/solid/LinearSweep.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Path_1 = __webpack_require__(/*! ../curve/Path */ "./lib/curve/Path.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const PolygonOps_1 = __webpack_require__(/*! ../geometry3d/PolygonOps */ "./lib/geometry3d/PolygonOps.js");
const SweepContour_1 = __webpack_require__(/*! ./SweepContour */ "./lib/solid/SweepContour.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
/**
 * A LinearSweep is a `SolidPrimitive` defined by
 * * A set of curves (any Loop, Path, or parityRegion)
 * * A sweep vector
 * If the object is "capped", the curves must be planar.
 * @public
 */
class LinearSweep extends SolidPrimitive_1.SolidPrimitive {
    constructor(contour, direction, capped) {
        super(capped);
        /** String name for schema properties */
        this.solidPrimitiveType = "linearSweep";
        this._contour = contour;
        this._direction = direction;
    }
    /**
     * Create a sweep of a starting contour.
     * @param contour contour to be swept
     * @param direction sweep vector.  The contour is swept the full length of the vector.
     * @param capped true to include end caps
     */
    static create(contour, direction, capped) {
        const sweepable = SweepContour_1.SweepContour.createForLinearSweep(contour, direction);
        if (!sweepable)
            return undefined;
        return new LinearSweep(sweepable, direction, capped);
    }
    /** Create a z-direction sweep of the polyline or polygon given as xy linestring values.
     * * If not capped, the xyPoints array is always used unchanged.
     * * If capped but the xyPoints array does not close, exact closure will be enforced by one of these:
     * * * If the final point is almost equal to the first, it is replaced by the exact first point.
     * * * if the final point is not close to the first an extra point is added.
     * * If capped, the point order will be reversed if necessary to produce positive volume.
     * @param xyPoints array of xy coordinates
     * @param z z value to be used for all coordinates
     * @param zSweep the sweep distance in the z direction.
     * @param capped true if caps are to be added.
     */
    static createZSweep(xyPoints, z, zSweep, capped) {
        const xyz = LineString3d_1.LineString3d.createXY(xyPoints, z, capped);
        if (capped) {
            xyz.addClosurePoint();
            const area = PolygonOps_1.PolygonOps.areaXY(xyz.points);
            if (area * zSweep < 0.0)
                xyz.points.reverse();
        }
        const contour = capped ? Loop_1.Loop.create(xyz) : Path_1.Path.create(xyz);
        return LinearSweep.create(contour, Point3dVector3d_1.Vector3d.create(0, 0, zSweep), capped);
    }
    /** get a reference to the swept curves */
    getCurvesRef() { return this._contour.curves; }
    /** Get a reference to the `SweepContour` carrying the plane of the curves */
    getSweepContourRef() { return this._contour; }
    /** return a clone of the sweep vector */
    cloneSweepVector() { return this._direction.clone(); }
    /** Test if `other` is also an instance of `LinearSweep` */
    isSameGeometryClass(other) { return other instanceof LinearSweep; }
    /** Return a deep clone */
    clone() {
        return new LinearSweep(this._contour.clone(), this._direction.clone(), this.capped);
    }
    /** apply a transform to the curves and sweep vector */
    tryTransformInPlace(transform) {
        if (transform.matrix.isSingular())
            return false;
        if (this._contour.tryTransformInPlace(transform)) {
            transform.multiplyVector(this._direction, this._direction);
            return true;
        }
        return false;
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin on base contour
     * * x, y directions from base contour.
     * * z direction perpendicular
     */
    getConstructiveFrame() {
        return this._contour.localToWorld.cloneRigid();
    }
    /** Return a transformed clone */
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    /** Test for near-equality of coordinates in `other` */
    isAlmostEqual(other) {
        if (other instanceof LinearSweep) {
            return this._contour.isAlmostEqual(other._contour)
                && this._direction.isAlmostEqual(other._direction)
                && this.capped === other.capped;
        }
        return false;
    }
    /** Invoke strongly typed `handler.handleLinearSweep(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleLinearSweep(this);
    }
    /**
     * Return the curves at a fraction along the sweep direction.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const section = this._contour.curves.clone();
        if (section && vFraction !== 0.0)
            section.tryTransformInPlace(Transform_1.Transform.createTranslation(this._direction.scale(vFraction)));
        return section;
    }
    /** Extend `rangeToExtend` to include this geometry. */
    extendRange(rangeToExtend, transform) {
        const contourRange = this._contour.curves.range(transform);
        rangeToExtend.extendRange(contourRange);
        if (transform) {
            const transformedDirection = transform.multiplyVector(this._direction);
            contourRange.low.addInPlace(transformedDirection);
            contourRange.high.addInPlace(transformedDirection);
        }
        else {
            contourRange.low.addInPlace(this._direction);
            contourRange.high.addInPlace(this._direction);
        }
        rangeToExtend.extendRange(contourRange);
    }
    /**
     * @return true if this is a closed volume.
     */
    get isClosedVolume() {
        return this.capped && this._contour.curves.isAnyRegionType;
    }
}
exports.LinearSweep = LinearSweep;


/***/ }),

/***/ "./lib/solid/RotationalSweep.js":
/*!**************************************!*\
  !*** ./lib/solid/RotationalSweep.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const SweepContour_1 = __webpack_require__(/*! ./SweepContour */ "./lib/solid/SweepContour.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const StrokeOptions_1 = __webpack_require__(/*! ../curve/StrokeOptions */ "./lib/curve/StrokeOptions.js");
/**
 * A LinearSweep is
 * * A planar contour (any Loop, Path, or parityRegion)
 * * An axis vector.
 *   * The planar contour is expected to be in the plane of the axis vector
 *   * The contour may have points and/or lines that are on the axis, but otherwise is entirely on one side of the axis.
 * * A sweep angle.
 * @public
 */
class RotationalSweep extends SolidPrimitive_1.SolidPrimitive {
    constructor(contour, normalizedAxis, sweepAngle, capped) {
        super(capped);
        /** String name for schema properties */
        this.solidPrimitiveType = "rotationalSweep";
        this._contour = contour;
        this._normalizedAxis = normalizedAxis;
        this.capped = capped;
        this._sweepAngle = sweepAngle;
    }
    /** Create a rotational sweep. */
    static create(contour, axis, sweepAngle, capped) {
        if (!axis.direction.normalizeInPlace())
            return undefined;
        const sweepable = SweepContour_1.SweepContour.createForRotation(contour, axis);
        if (!sweepable)
            return undefined;
        return new RotationalSweep(sweepable, axis, sweepAngle.clone(), capped);
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin at origin of rotation ray
     * * z direction along the rotation ray.
     * * y direction perpendicular to the base contour plane
     */
    getConstructiveFrame() {
        const contourPerpendicular = this._contour.localToWorld.matrix.columnZ();
        const axes = Matrix3d_1.Matrix3d.createRigidFromColumns(contourPerpendicular, this._normalizedAxis.direction, Geometry_1.AxisOrder.YZX);
        if (axes) {
            return Transform_1.Transform.createOriginAndMatrix(this._normalizedAxis.origin, axes);
        }
        return undefined;
    }
    /** return clone of (not reference to) the axis vector. */
    cloneAxisRay() { return this._normalizedAxis.clone(); }
    /** Return (REFERENCE TO) the swept curves. */
    getCurves() { return this._contour.curves; }
    /** Return (REFERENCE TO) the swept curves with containing plane markup. */
    getSweepContourRef() { return this._contour; }
    /** Return the sweep angle. */
    getSweep() { return this._sweepAngle.clone(); }
    /** Test if `other` is a `RotationalSweep` */
    isSameGeometryClass(other) { return other instanceof RotationalSweep; }
    /** Test for same axis, capping, and swept geometry. */
    isAlmostEqual(other) {
        if (other instanceof RotationalSweep) {
            return this._contour.isAlmostEqual(other._contour)
                && this._normalizedAxis.isAlmostEqual(other._normalizedAxis)
                && this.capped === other.capped;
        }
        return false;
    }
    /** return a deep clone */
    clone() {
        return new RotationalSweep(this._contour.clone(), this._normalizedAxis.clone(), this._sweepAngle.clone(), this.capped);
    }
    /** Transform the contour and axis */
    tryTransformInPlace(transform) {
        if (!transform.matrix.isSingular()
            && this._contour.tryTransformInPlace(transform)) {
            this._normalizedAxis.transformInPlace(transform);
            return this._normalizedAxis.direction.normalizeInPlace();
        }
        return false;
    }
    /** return a cloned transform. */
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    /** Dispatch to strongly typed handler  `handler.handleRotationalSweep(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleRotationalSweep(this);
    }
    /** Return a transform that rotates around the rotational axis by a fraction of the total sweep. */
    getFractionalRotationTransform(vFraction, result) {
        const radians = this._sweepAngle.radians * vFraction;
        const rotation = Transform_1.Transform.createFixedPointAndMatrix(this._normalizedAxis.origin, Matrix3d_1.Matrix3d.createRotationAroundVector(this._normalizedAxis.direction, Angle_1.Angle.createRadians(radians), result ? result.matrix : undefined));
        return rotation;
    }
    /**
     * Return the curves of a constant-v section of the solid.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const section = this._contour.curves.clone();
        if (section) {
            section.tryTransformInPlace(this.getFractionalRotationTransform(vFraction));
        }
        return section;
    }
    /** Extend range using sampled points on the surface. */
    extendRange(range, transform) {
        const degreeStep = 360 / 32;
        const options = StrokeOptions_1.StrokeOptions.createForCurves();
        options.angleTol = Angle_1.Angle.createDegrees(degreeStep);
        const strokes = this._contour.curves.cloneStroked(options);
        const numStep = Geometry_1.Geometry.stepCount(degreeStep, this._sweepAngle.degrees, 4, 32);
        const stepTransform = Transform_1.Transform.createIdentity();
        if (transform) {
            const compositeTransform = Transform_1.Transform.createIdentity();
            for (let i = 0; i <= numStep; i++) {
                transform.multiplyTransformTransform(this.getFractionalRotationTransform(i / numStep, stepTransform), compositeTransform);
                strokes.extendRange(range, compositeTransform);
            }
        }
        else {
            for (let i = 0; i <= numStep; i++)
                strokes.extendRange(range, this.getFractionalRotationTransform(i / numStep, stepTransform));
        }
    }
    /**
     * @return true if this is a closed volume.
     */
    get isClosedVolume() {
        return this.capped || this._sweepAngle.isFullCircle;
    }
}
exports.RotationalSweep = RotationalSweep;


/***/ }),

/***/ "./lib/solid/RuledSweep.js":
/*!*********************************!*\
  !*** ./lib/solid/RuledSweep.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const CurveCollection_1 = __webpack_require__(/*! ../curve/CurveCollection */ "./lib/curve/CurveCollection.js");
const CurvePrimitive_1 = __webpack_require__(/*! ../curve/CurvePrimitive */ "./lib/curve/CurvePrimitive.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const SweepContour_1 = __webpack_require__(/*! ./SweepContour */ "./lib/solid/SweepContour.js");
const ConstructCurveBetweenCurves_1 = __webpack_require__(/*! ../curve/ConstructCurveBetweenCurves */ "./lib/curve/ConstructCurveBetweenCurves.js");
/**
 * A ruled sweep (surface) is a collection of 2 or more contours.
 * * All contours must have identical number and type of geometry. (paths, loops, parity regions, lines, arcs, other curves)
 * @public
 */
class RuledSweep extends SolidPrimitive_1.SolidPrimitive {
    constructor(contours, capped) {
        super(capped);
        /** String name for schema properties */
        this.solidPrimitiveType = "ruledSweep";
        this._contours = contours;
    }
    /**
     * Create a ruled sweep from an array of contours.
     *  * the contours are CAPTURED (not cloned)
     */
    static create(contours, capped) {
        const sweepContours = [];
        for (const contour of contours) {
            const sweepable = SweepContour_1.SweepContour.createForLinearSweep(contour);
            if (sweepable === undefined)
                return undefined;
            sweepContours.push(sweepable);
        }
        return new RuledSweep(sweepContours, capped);
    }
    /** Return a reference to the array of SweepContour. */
    sweepContoursRef() { return this._contours; }
    /** Return clones of all the sweep contours
     * * See also cloneContours, which returns the spatial contours without their local coordinate system definitions)
     */
    cloneSweepContours() {
        const result = [];
        for (const sweepable of this._contours) {
            result.push(sweepable.clone());
        }
        return result;
    }
    /** Return clones of all the contours
     * * See also cloneContours, which returns the contours in their local coordinate systems
     */
    cloneContours() {
        const result = [];
        for (const sweepable of this._contours) {
            result.push(sweepable.curves.clone());
        }
        return result;
    }
    /** Return a deep clone */
    clone() {
        return new RuledSweep(this.cloneSweepContours(), this.capped);
    }
    /** Transform all contours in place. */
    tryTransformInPlace(transform) {
        if (transform.matrix.isSingular())
            return false;
        for (const contour of this._contours) {
            contour.tryTransformInPlace(transform);
        }
        return true;
    }
    /** Return a cloned transform. */
    cloneTransformed(transform) {
        const result = this.clone();
        result.tryTransformInPlace(transform);
        return result;
    }
    /** Return a coordinate frame (right handed unit vectors)
     * * origin on base contour
     * * x, y directions from base contour.
     * * z direction perpendicular
     */
    getConstructiveFrame() {
        if (this._contours.length === 0)
            return undefined;
        return this._contours[0].localToWorld.cloneRigid();
    }
    /** Test if `other` is an instance of a `RuledSweep` */
    isSameGeometryClass(other) { return other instanceof RuledSweep; }
    /** test same contour geometry and capping. */
    isAlmostEqual(other) {
        if (other instanceof RuledSweep) {
            if (this.capped !== other.capped)
                return false;
            if (this._contours.length !== other._contours.length)
                return false;
            for (let i = 0; i < this._contours.length; i++) {
                if (!this._contours[i].isAlmostEqual(other._contours[i]))
                    return false;
            }
            return true;
        }
        return false;
    }
    /** dispatch to strongly typed `handler.handleRuledSweep(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleRuledSweep(this);
    }
    /**
     * Return the section curves at a fraction of the sweep
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const numSection = this._contours.length;
        if (numSection < 2)
            return undefined;
        const q = vFraction * numSection;
        let section0 = 0;
        if (vFraction >= 1.0)
            section0 = numSection - 1;
        else
            section0 = Math.floor(q);
        if (section0 + 1 >= numSection)
            section0 = numSection - 2;
        const section1 = section0 + 1;
        const localFraction = Geometry_1.Geometry.clampToStartEnd(q - section0, 0, 1);
        return RuledSweep.mutatePartners(this._contours[section0].curves, this._contours[section1].curves, (primitive0, primitive1) => {
            const newPrimitive = ConstructCurveBetweenCurves_1.ConstructCurveBetweenCurves.interpolateBetween(primitive0, localFraction, primitive1);
            if (newPrimitive instanceof CurvePrimitive_1.CurvePrimitive)
                return newPrimitive;
            return undefined;
        });
    }
    /** Pass each contour to `extendRange` */
    extendRange(rangeToExtend, transform) {
        for (const contour of this._contours)
            contour.curves.extendRange(rangeToExtend, transform);
    }
    /** Construct a CurveCollection with the same structure as collectionA and collectionB, with primitives constructed by the caller-supplied primitiveMutator function.
     * @returns Returns undefined if there is any type mismatch between the two collections.
     */
    static mutatePartners(collectionA, collectionB, primitiveMutator) {
        if (!collectionA.isSameGeometryClass(collectionB))
            return undefined;
        if (collectionA instanceof CurveCollection_1.CurveChain && collectionB instanceof CurveCollection_1.CurveChain) {
            const chainA = collectionA;
            const chainB = collectionB;
            const chainC = chainA.cloneEmptyPeer();
            const childrenA = chainA.children;
            const childrenB = chainB.children;
            if (childrenA.length !== childrenB.length)
                return undefined;
            for (let i = 0; i < childrenA.length; i++) {
                const newChild = primitiveMutator(childrenA[i], childrenB[i]);
                if (!newChild)
                    return undefined;
                chainC.children.push(newChild);
            }
            return chainC;
        }
        else if (collectionA instanceof CurveCollection_1.CurveCollection && collectionB instanceof CurveCollection_1.CurveCollection) {
            const collectionC = collectionA.cloneEmptyPeer();
            const childrenA = collectionA.children;
            const childrenB = collectionB.children;
            const childrenC = collectionC.children;
            if (childrenA === undefined || childrenB === undefined || childrenC === undefined || childrenA.length !== childrenB.length)
                return undefined;
            for (let i = 0; i < childrenA.length; i++) {
                const childA = childrenA[i];
                const childB = childrenB[i];
                if (childA instanceof CurvePrimitive_1.CurvePrimitive && childB instanceof CurvePrimitive_1.CurvePrimitive) {
                    const newPrimitive = primitiveMutator(childA, childB);
                    if (!newPrimitive)
                        return undefined;
                    childrenC.push(newPrimitive);
                }
                else if (childA instanceof CurveCollection_1.CurveCollection && childB instanceof CurveCollection_1.CurveCollection) {
                    const newChild = this.mutatePartners(childA, childB, primitiveMutator);
                    if (!newChild)
                        return undefined;
                    if (newChild instanceof CurveCollection_1.CurveCollection)
                        childrenC.push(newChild);
                }
            }
            return collectionC;
        }
        return undefined;
    }
    /**
     * Return true if this is a closed volume, as observed by
     * * cap flag
     * identical first and last contours.
     */
    get isClosedVolume() {
        const n = this._contours.length;
        return n > 1 && (this.capped || this._contours[0].isAlmostEqual(this._contours[n - 1]));
    }
}
exports.RuledSweep = RuledSweep;


/***/ }),

/***/ "./lib/solid/SolidPrimitive.js":
/*!*************************************!*\
  !*** ./lib/solid/SolidPrimitive.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const GeometryQuery_1 = __webpack_require__(/*! ../curve/GeometryQuery */ "./lib/curve/GeometryQuery.js");
/**
 * Base class for SolidPrimitive variants.
 *
 * * The base class holds capped flag for all derived classes.
 * @public
 */
class SolidPrimitive extends GeometryQuery_1.GeometryQuery {
    constructor(capped) {
        super();
        /** String name for schema properties */
        this.geometryCategory = "solid";
        this._capped = capped;
    }
    /** Ask if this is a capped solid */
    get capped() { return this._capped; }
    /** Set the capped flag */
    set capped(capped) { this._capped = capped; }
}
exports.SolidPrimitive = SolidPrimitive;


/***/ }),

/***/ "./lib/solid/Sphere.js":
/*!*****************************!*\
  !*** ./lib/solid/Sphere.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Solid */
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Matrix3d_1 = __webpack_require__(/*! ../geometry3d/Matrix3d */ "./lib/geometry3d/Matrix3d.js");
const StrokeOptions_1 = __webpack_require__(/*! ../curve/StrokeOptions */ "./lib/curve/StrokeOptions.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
/**
 * A Sphere is
 *
 * * A unit sphere (but read on ....)
 * * mapped by an arbitrary (possibly skewed, non-uniform scaled) transform
 * * hence possibly the final geometry is ellipsoidal
 * @public
 */
class Sphere extends SolidPrimitive_1.SolidPrimitive {
    constructor(localToWorld, latitudeSweep, capped) {
        super(capped);
        /** String name for schema properties */
        this.solidPrimitiveType = "sphere";
        this._localToWorld = localToWorld;
        this._latitudeSweep = latitudeSweep ? latitudeSweep : AngleSweep_1.AngleSweep.createFullLatitude();
    }
    /** Return the latitude (in radians) all fractional v. */
    vFractionToRadians(v) {
        return this._latitudeSweep.fractionToRadians(v);
    }
    /** Return the longitude (in radians) all fractional u. */
    uFractionToRadians(u) {
        return u * Math.PI * 2.0;
    }
    /** return a deep clone */
    clone() {
        return new Sphere(this._localToWorld.clone(), this._latitudeSweep.clone(), this.capped);
    }
    /** Transform the sphere in place.
     * * Fails if the transform is singular.
     */
    tryTransformInPlace(transform) {
        if (transform.matrix.isSingular())
            return false;
        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);
        return true;
    }
    /** Return a transformed clone. */
    cloneTransformed(transform) {
        const sphere1 = this.clone();
        transform.multiplyTransformTransform(sphere1._localToWorld, sphere1._localToWorld);
        if (transform.matrix.determinant() < 0.0) {
            if (sphere1._latitudeSweep !== undefined) {
                sphere1._latitudeSweep.reverseInPlace();
            }
        }
        return sphere1;
    }
    /** Return a coordinate frame (right handed, unit axes)
     * * origin at sphere center
     * * equator in xy plane
     * * z axis perpendicular
     */
    getConstructiveFrame() {
        return this._localToWorld.cloneRigid();
    }
    /** Return the latitude sweep as fraction of south pole to north pole. */
    get latitudeSweepFraction() { return this._latitudeSweep.sweepRadians / Math.PI; }
    /** Create from center and radius, with optional restricted latitudes. */
    static createCenterRadius(center, radius, latitudeSweep) {
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(center, Matrix3d_1.Matrix3d.createUniformScale(radius));
        return new Sphere(localToWorld, latitudeSweep ? latitudeSweep : AngleSweep_1.AngleSweep.createFullLatitude(), false);
    }
    /** Create an ellipsoid which is a unit sphere mapped to position by an (arbitrary, possibly skewed and scaled) transform. */
    static createEllipsoid(localToWorld, latitudeSweep, capped) {
        return new Sphere(localToWorld, latitudeSweep, capped);
    }
    /** Create a sphere from the typical parameters of the Dgn file */
    static createDgnSphere(center, vectorX, vectorZ, radiusXY, radiusZ, latitudeSweep, capped) {
        const vectorY = vectorX.rotate90Around(vectorZ);
        if (vectorY && !vectorX.isParallelTo(vectorZ)) {
            const matrix = Matrix3d_1.Matrix3d.createColumns(vectorX, vectorY, vectorZ);
            matrix.scaleColumns(radiusXY, radiusXY, radiusZ, matrix);
            const frame = Transform_1.Transform.createOriginAndMatrix(center, matrix);
            return new Sphere(frame, latitudeSweep.clone(), capped);
        }
        return undefined;
    }
    /** Create a sphere from the typical parameters of the Dgn file */
    static createFromAxesAndScales(center, axes, radiusX, radiusY, radiusZ, latitudeSweep, capped) {
        const localToWorld = Transform_1.Transform.createOriginAndMatrix(center, axes);
        localToWorld.matrix.scaleColumnsInPlace(radiusX, radiusY, radiusZ);
        return new Sphere(localToWorld, latitudeSweep ? latitudeSweep.clone() : AngleSweep_1.AngleSweep.createFullLatitude(), capped);
    }
    /** return (copy of) sphere center */
    cloneCenter() { return this._localToWorld.getOrigin(); }
    /** return the (full length, i.e. scaled by radius) X vector from the sphere transform */
    cloneVectorX() { return this._localToWorld.matrix.columnX(); }
    /** return the (full length, i.e. scaled by radius) Y vector from the sphere transform */
    cloneVectorY() { return this._localToWorld.matrix.columnY(); }
    /** return the (full length, i.e. scaled by radius) Z vector from the sphere transform */
    cloneVectorZ() { return this._localToWorld.matrix.columnZ(); }
    /** return (a copy of) the sphere's angle sweep. */
    cloneLatitudeSweep() { return this._latitudeSweep.clone(); }
    /** Test if the geometry is a true sphere taking the transform (which might have nonuniform scaling) is applied. */
    trueSphereRadius() {
        const factors = this._localToWorld.matrix.factorRigidWithSignedScale();
        if (!factors)
            return undefined;
        if (factors && factors.scale > 0)
            return factors.scale;
        return undefined;
    }
    /**
     * Return a (clone of) the sphere's local to world transformation.
     */
    cloneLocalToWorld() { return this._localToWorld.clone(); }
    /** Test if `other` is a `Sphere` */
    isSameGeometryClass(other) { return other instanceof Sphere; }
    /** Test for same geometry in `other` */
    isAlmostEqual(other) {
        if (other instanceof Sphere) {
            if (this.capped !== other.capped)
                return false;
            if (!this._localToWorld.isAlmostEqual(other._localToWorld))
                return false;
            return true;
        }
        return false;
    }
    /**
     *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.
     * * if strokeOptions is supplied, it is applied to the equator radii.
     * @param v fractional position along the cone axis
     * @param strokes stroke count or options.
     */
    strokeConstantVSection(v, fixedStrokeCount, options) {
        let strokeCount = 16;
        if (fixedStrokeCount !== undefined && Number.isFinite(fixedStrokeCount)) {
            strokeCount = fixedStrokeCount;
        }
        else if (options instanceof StrokeOptions_1.StrokeOptions) {
            strokeCount = options.applyTolerancesToArc(Geometry_1.Geometry.maxXY(this._localToWorld.matrix.columnXMagnitude(), this._localToWorld.matrix.columnYMagnitude()));
        }
        strokeCount = Geometry_1.Geometry.clampToStartEnd(strokeCount, 4, 64);
        const transform = this._localToWorld;
        const phi = this.vFractionToRadians(v);
        const c1 = Math.cos(phi);
        const s1 = Math.sin(phi);
        let c0, s0;
        const result = LineString3d_1.LineString3d.createForStrokes(fixedStrokeCount, options);
        const deltaRadians = Math.PI * 2.0 / strokeCount;
        const fractions = result.fractions; // possibly undefined !!!
        const derivatives = result.packedDerivatives; // possibly undefined !!!
        const uvParams = result.packedUVParams; // possibly undefined !!
        const surfaceNormals = result.packedSurfaceNormals;
        const dXdu = Point3dVector3d_1.Vector3d.create();
        const dXdv = Point3dVector3d_1.Vector3d.create();
        const normal = Point3dVector3d_1.Vector3d.create();
        let radians = 0;
        for (let i = 0; i <= strokeCount; i++) {
            if (i * 2 <= strokeCount)
                radians = i * deltaRadians;
            else
                radians = (i - strokeCount) * deltaRadians;
            c0 = Math.cos(radians);
            s0 = Math.sin(radians);
            const xyz = transform.multiplyXYZ(c1 * c0, c1 * s0, s1);
            result.addPoint(xyz);
            if (fractions)
                fractions.push(i / strokeCount);
            if (derivatives) {
                transform.matrix.multiplyXYZ(-c1 * s0, c1 * c0, 0.0, dXdu);
                derivatives.push(dXdu);
            }
            if (uvParams) {
                uvParams.pushXY(i / strokeCount, v);
            }
            if (surfaceNormals) {
                transform.matrix.multiplyXYZ(-s0, c0, 0, dXdu);
                transform.matrix.multiplyXYZ(-s1 * c0, -s1 * s0, c1, dXdv);
                dXdu.unitCrossProduct(dXdv, normal);
                surfaceNormals.push(normal);
            }
        }
        return result;
    }
    /** Second step of double dispatch:  call `handler.handleSphere(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleSphere(this);
    }
    /**
     * Return the Arc3d section at vFraction.  For the sphere, this is a latitude circle.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(vFraction) {
        const phi = this._latitudeSweep.fractionToRadians(vFraction);
        const s1 = Math.sin(phi);
        const c1 = Math.cos(phi);
        const transform = this._localToWorld;
        const center = transform.multiplyXYZ(0, 0, s1);
        const vector0 = transform.matrix.multiplyXYZ(c1, 0, 0);
        const vector90 = transform.matrix.multiplyXYZ(0, c1, 0);
        return Loop_1.Loop.create(Arc3d_1.Arc3d.create(center, vector0, vector90));
    }
    /** Extend a range to contain this sphere. */
    extendRange(range, transform) {
        let placement = this._localToWorld;
        if (transform) {
            placement = transform.multiplyTransformTransform(placement);
        }
        range.extendTransformedXYZ(placement, -1, -1, -1);
        range.extendTransformedXYZ(placement, 1, -1, -1);
        range.extendTransformedXYZ(placement, -1, 1, -1);
        range.extendTransformedXYZ(placement, 1, 1, -1);
        range.extendTransformedXYZ(placement, -1, -1, 1);
        range.extendTransformedXYZ(placement, 1, -1, 1);
        range.extendTransformedXYZ(placement, -1, 1, 1);
        range.extendTransformedXYZ(placement, 1, 1, 1);
    }
    /** Evaluate as a uv surface
     * @param uFraction fractional position in minor (phi)
     * @param vFraction fractional position on major (theta) arc
     */
    uvFractionToPoint(uFraction, vFraction, result) {
        // sphere with radius 1 . . .
        const thetaRadians = this.uFractionToRadians(uFraction);
        const phiRadians = this.vFractionToRadians(vFraction);
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const sinPhi = Math.sin(phiRadians);
        const cosPhi = Math.cos(phiRadians);
        return this._localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi, result);
    }
    /** Evaluate as a uv surface, returning point and two vectors.
     * @param u fractional position in minor (phi)
     * @param v fractional position on major (theta) arc
     */
    uvFractionToPointAndTangents(uFraction, vFraction, result) {
        const thetaRadians = this.uFractionToRadians(uFraction);
        const phiRadians = this.vFractionToRadians(vFraction);
        const fTheta = Math.PI * 2.0;
        const fPhi = this._latitudeSweep.sweepRadians;
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const sinPhi = Math.sin(phiRadians);
        const cosPhi = Math.cos(phiRadians);
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi), this._localToWorld.matrix.multiplyXYZ(-fTheta * sinTheta, fTheta * cosTheta, 0), // !!! note cosTheta term is omitted -- scale is wrong, but remains non-zero at poles.
        this._localToWorld.matrix.multiplyXYZ(-fPhi * cosTheta * sinPhi, -fPhi * sinTheta * sinPhi, fPhi * cosPhi), result);
    }
    /**
     * * A sphere is can be closed two ways:
     *   * full sphere (no caps needed for closure)
     *   * incomplete but with caps
     * @return true if this is a closed volume.
     */
    get isClosedVolume() {
        return this.capped || this._latitudeSweep.isFullLatitudeSweep;
    }
    /**
     * Directional distance query
     * * u direction is around longitude circle at maximum distance from axis.
     * * v direction is on a line of longitude between the latitude limits.
     */
    maxIsoParametricDistance() {
        // approximate radius at equator .. if elliptic, this is not exact . . .
        const rX = this._localToWorld.matrix.columnXMagnitude();
        const rY = this._localToWorld.matrix.columnYMagnitude();
        const rZ = this._localToWorld.matrix.columnZMagnitude();
        const rMaxU = Math.max(rX, rY);
        let dMaxU = Math.PI * 2.0 * rMaxU;
        if (!this._latitudeSweep.isRadiansInSweep(0.0))
            dMaxU *= Math.max(Math.cos(Math.abs(this._latitudeSweep.startRadians)), Math.cos(Math.abs(this._latitudeSweep.endRadians)));
        const dMaxV = Math.max(rMaxU, rZ) * Math.abs(this._latitudeSweep.sweepRadians);
        return Point2dVector2d_1.Vector2d.create(dMaxU, dMaxV);
    }
}
exports.Sphere = Sphere;


/***/ }),

/***/ "./lib/solid/SweepContour.js":
/*!***********************************!*\
  !*** ./lib/solid/SweepContour.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const FrameBuilder_1 = __webpack_require__(/*! ../geometry3d/FrameBuilder */ "./lib/geometry3d/FrameBuilder.js");
const PolyfaceBuilder_1 = __webpack_require__(/*! ../polyface/PolyfaceBuilder */ "./lib/polyface/PolyfaceBuilder.js");
const Triangulation_1 = __webpack_require__(/*! ../topology/Triangulation */ "./lib/topology/Triangulation.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const ParityRegion_1 = __webpack_require__(/*! ../curve/ParityRegion */ "./lib/curve/ParityRegion.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const PolygonOps_1 = __webpack_require__(/*! ../geometry3d/PolygonOps */ "./lib/geometry3d/PolygonOps.js");
/**
 * Sweepable contour with Transform for local to world interaction.
 * * The surface/solid classes `LinearSweep`, `RotationalSweep`, `RuledSweep` use this for their swept contours.
 * @public
 */
class SweepContour {
    constructor(contour, map, axis) {
        this.curves = contour;
        this.localToWorld = map;
        this.axis = axis;
    }
    /** Create for linear sweep.
     * * The optional default normal may be useful for guiding coordinate frame setup.
     * * the contour is CAPTURED.
     */
    static createForLinearSweep(contour, defaultNormal) {
        const localToWorld = FrameBuilder_1.FrameBuilder.createRightHandedFrame(defaultNormal, contour);
        if (localToWorld) {
            return new SweepContour(contour, localToWorld, undefined);
        }
        return undefined;
    }
    /** Create for linear sweep.
     * * The optional default normal may be useful for guiding coordinate frame setup.
     * * the points are captured into linestrings and Loops as needed.
     */
    static createForPolygon(points, defaultNormal) {
        const localToWorld = FrameBuilder_1.FrameBuilder.createRightHandedFrame(defaultNormal, points);
        if (localToWorld) {
            if (defaultNormal !== undefined) {
                if (localToWorld.matrix.dotColumnZ(defaultNormal))
                    localToWorld.matrix.scaleColumnsInPlace(1.0, -1.0, -1.0);
            }
            const linestrings = LineString3d_1.LineString3d.createArrayOfLineString3dFromVariantData(points);
            const loops = [];
            for (const ls of linestrings) {
                ls.addClosurePoint();
                loops.push(Loop_1.Loop.create(ls));
            }
            if (loops.length === 1) {
                return new SweepContour(loops[0], localToWorld, undefined);
            }
            else if (loops.length > 1) {
                return new SweepContour(ParityRegion_1.ParityRegion.createLoops(loops), localToWorld, undefined);
            }
        }
        return undefined;
    }
    /** Create for rotational sweep.
     * * The axis ray is retained.
     * * the contour is CAPTURED.
     */
    static createForRotation(contour, axis) {
        // createRightHandedFrame -- the axis is a last-gasp resolver for in-plane vectors.
        const localToWorld = FrameBuilder_1.FrameBuilder.createRightHandedFrame(undefined, contour, axis);
        if (localToWorld) {
            return new SweepContour(contour, localToWorld, axis.clone());
        }
        return undefined;
    }
    /** Return (Reference to) the curves */
    getCurves() { return this.curves; }
    /** Apply `transform` to the curves, axis.
     * * The local to world frame is reconstructed for the transformed curves.
     */
    tryTransformInPlace(transform) {
        if (this.curves.tryTransformInPlace(transform)) {
            if (this.axis)
                this.axis.transformInPlace(transform);
            const localToWorld = this.axis !== undefined
                ? FrameBuilder_1.FrameBuilder.createRightHandedFrame(undefined, this.curves, this.axis)
                : FrameBuilder_1.FrameBuilder.createRightHandedFrame(undefined, this.curves);
            if (localToWorld) {
                this.localToWorld.setFrom(localToWorld);
                return true;
            }
        }
        return false;
    }
    /** Return a deep clone. */
    clone() {
        return new SweepContour(this.curves.clone(), this.localToWorld.clone(), this.axis);
    }
    /** Return a transformed clone. */
    cloneTransformed(transform) {
        const newContour = this.clone();
        if (newContour.tryTransformInPlace(transform))
            return newContour;
        return undefined;
    }
    /** Test for near equality of cures and local frame. */
    isAlmostEqual(other) {
        if (other instanceof SweepContour) {
            return this.curves.isAlmostEqual(other.curves) && this.localToWorld.isAlmostEqual(other.localToWorld);
        }
        return false;
    }
    /**
     * build the (cached) internal facets.
     * @param _builder (NOT USED -- an internal builder is constructed for the triangulation)
     * @param options options for stroking the curves.
     */
    buildFacets(_builder, options) {
        if (!this._facets) {
            if (this.curves instanceof Loop_1.Loop) {
                this._xyStrokes = this.curves.cloneStroked(options);
                if (this._xyStrokes instanceof Loop_1.Loop && this._xyStrokes.children.length === 1) {
                    const children = this._xyStrokes.children;
                    const linestring = children[0];
                    const points = linestring.points;
                    this.localToWorld.multiplyInversePoint3dArrayInPlace(points);
                    if (PolygonOps_1.PolygonOps.sumTriangleAreasXY(points) < 0)
                        points.reverse();
                    const graph = Triangulation_1.Triangulator.createTriangulatedGraphFromSingleLoop(points);
                    if (graph) {
                        Triangulation_1.Triangulator.flipTriangles(graph);
                        const unflippedPoly = PolyfaceBuilder_1.PolyfaceBuilder.graphToPolyface(graph, options);
                        this._facets = unflippedPoly;
                        this._facets.tryTransformInPlace(this.localToWorld);
                    }
                }
            }
            else if (this.curves instanceof ParityRegion_1.ParityRegion) {
                this._xyStrokes = this.curves.cloneStroked(options);
                if (this._xyStrokes instanceof (ParityRegion_1.ParityRegion)) {
                    const worldToLocal = this.localToWorld.inverse();
                    this._xyStrokes.tryTransformInPlace(worldToLocal);
                    const strokes = [];
                    for (const childLoop of this._xyStrokes.children) {
                        const loopCurves = childLoop.children;
                        if (loopCurves.length === 1) {
                            const c = loopCurves[0];
                            if (c instanceof LineString3d_1.LineString3d)
                                strokes.push(c.packedPoints);
                        }
                    }
                    const graph = Triangulation_1.Triangulator.createTriangulatedGraphFromLoops(strokes);
                    if (graph) {
                        Triangulation_1.Triangulator.flipTriangles(graph);
                        const unflippedPoly = PolyfaceBuilder_1.PolyfaceBuilder.graphToPolyface(graph, options);
                        this._facets = unflippedPoly;
                        this._facets.tryTransformInPlace(this.localToWorld);
                    }
                }
            }
        }
    }
    /** delete existing facets.
     * * This protects against PolyfaceBuilder reusing facets constructed with different options settings.
     */
    purgeFacets() {
        this._facets = undefined;
    }
    /** Emit facets to a builder.
     * This method may cache and reuse facets over multiple calls.
     */
    emitFacets(builder, reverse, transform) {
        this.buildFacets(builder, builder.options);
        if (this._facets)
            builder.addIndexedPolyface(this._facets, reverse, transform);
    }
}
exports.SweepContour = SweepContour;


/***/ }),

/***/ "./lib/solid/TorusPipe.js":
/*!********************************!*\
  !*** ./lib/solid/TorusPipe.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Transform_1 = __webpack_require__(/*! ../geometry3d/Transform */ "./lib/geometry3d/Transform.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const AngleSweep_1 = __webpack_require__(/*! ../geometry3d/AngleSweep */ "./lib/geometry3d/AngleSweep.js");
const SolidPrimitive_1 = __webpack_require__(/*! ./SolidPrimitive */ "./lib/solid/SolidPrimitive.js");
const Loop_1 = __webpack_require__(/*! ../curve/Loop */ "./lib/curve/Loop.js");
const Path_1 = __webpack_require__(/*! ../curve/Path */ "./lib/curve/Path.js");
const Arc3d_1 = __webpack_require__(/*! ../curve/Arc3d */ "./lib/curve/Arc3d.js");
const Plane3dByOriginAndVectors_1 = __webpack_require__(/*! ../geometry3d/Plane3dByOriginAndVectors */ "./lib/geometry3d/Plane3dByOriginAndVectors.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
/**
 * A torus pipe is a partial torus (donut).  In a local coordinate system
 * * The z axis passes through the hole.
 * * The "major hoop" arc has
 *   * vectorTheta0 = (radiusA,0,0)
 *   * vectorTheta90 = (0, radiusA,0)
 *   * The major arc point at angle theta is `C(theta) = vectorTheta0 * cos(theta) + vectorTheta90 * sin(theta)
 * * The minor hoop at theta various with phi "around the minor hoop"
 *    * (x,y,z) = C(theta) + (radiusB *cos(theta), radiusB * sin(theta)) * cos(phi) + (0,radiusB,0) * sin(phi)
 * * The stored form of the torus pipe is oriented for positive volume:
 *   * Both radii are positive, with r0 >= r1 > 0
 *   * The sweep is positive
 *   * The coordinate system has positive determinant.
 * * For uv parameterization,
 *   * u is around the minor hoop, with (0..1) mapping to phi of (0 degrees ..360 degrees)
 *   * v is along the major hoop with (0..1) mapping to theta of (0 .. sweep)
 *   * a constant v section is a full circle
 *   * a constant u section is an arc with sweep angle matching the torusPipe sweep angle.
 * @public
 */
class TorusPipe extends SolidPrimitive_1.SolidPrimitive {
    constructor(map, radiusA, radiusB, sweep, capped) {
        super(capped);
        /** String name for schema properties */
        this.solidPrimitiveType = "torusPipe";
        this._localToWorld = map;
        this._radiusA = radiusA;
        this._radiusB = radiusB;
        this._sweep = sweep;
        this._isReversed = false;
    }
    /** return a copy of the TorusPipe */
    clone() {
        const result = new TorusPipe(this._localToWorld.clone(), this._radiusA, this._radiusB, this._sweep.clone(), this.capped);
        result._isReversed = this._isReversed;
        return result;
    }
    /** Apply `transform` to the local coordinate system. */
    tryTransformInPlace(transform) {
        if (transform.matrix.isSingular())
            return false;
        transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);
        return true;
    }
    /** Clone this TorusPipe and transform the clone */
    cloneTransformed(transform) {
        const result = this.clone();
        transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);
        return result;
    }
    /** Create a new `TorusPipe`
     * @param frame local to world transformation
     * @param majorRadius major hoop radius
     * @param minorRadius minor hoop radius
     * @param sweep sweep angle for major circle, with positive sweep from x axis towards y axis.
     * @param capped true for circular caps
     */
    static createInFrame(frame, majorRadius, minorRadius, sweep, capped) {
        // force near-zero radii to true zero
        majorRadius = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(majorRadius));
        minorRadius = Math.abs(Geometry_1.Geometry.correctSmallMetricDistance(minorRadius));
        if (majorRadius < minorRadius)
            return undefined;
        if (majorRadius === 0.0)
            return undefined;
        if (minorRadius === 0.0)
            return undefined;
        if (sweep.isAlmostZero)
            return undefined;
        const xScale = 1.0;
        let yScale = 1.0;
        let zScale = 1.0;
        if (frame.matrix.determinant() < 0.0)
            zScale *= -1.0;
        let isReversed = false;
        const sweep1 = sweep.clone();
        if (sweep.radians < 0.0) {
            sweep1.setRadians(-sweep.radians);
            zScale *= -1.0;
            yScale *= -1.0;
            isReversed = true;
        }
        const frame1 = frame.clone();
        frame1.matrix.scaleColumns(xScale, yScale, zScale, frame1.matrix);
        const result = new TorusPipe(frame1, majorRadius, minorRadius, sweep1, capped);
        result._isReversed = isReversed;
        return result;
    }
    /** Create a TorusPipe from the typical parameters of the Dgn file */
    static createDgnTorusPipe(center, vectorX, vectorY, majorRadius, minorRadius, sweep, capped) {
        const vectorZ = vectorX.crossProduct(vectorY);
        vectorZ.scaleToLength(vectorX.magnitude(), vectorZ);
        const frame = Transform_1.Transform.createOriginAndMatrixColumns(center, vectorX, vectorY, vectorZ);
        return TorusPipe.createInFrame(frame, majorRadius, minorRadius, sweep, capped);
    }
    /** Return a coordinate frame (right handed, unit axes)
     * * origin at center of major circle
     * * major circle in xy plane
     * * z axis perpendicular
     */
    getConstructiveFrame() {
        return this._localToWorld.cloneRigid();
    }
    /** Return the center of the torus pipe (inside the donut hole) */
    cloneCenter() { return this._localToWorld.getOrigin(); }
    /** return the vector along the x axis (in the major hoops plane) */
    cloneVectorX() { return this._localToWorld.matrix.columnX(); }
    /** return the vector along the y axis (in the major hoop plane) */
    cloneVectorY() { return this._localToWorld.matrix.columnY(); }
    /** get the minor hoop radius (`radiusA`) */
    getMinorRadius() { return this._radiusB; }
    /** get the major hoop radius (`radiusB`) */
    getMajorRadius() { return this._radiusA; }
    /** get the sweep angle along the major circle. */
    getSweepAngle() { return this._sweep.clone(); }
    /** Ask if this TorusPipe is labeled as reversed */
    getIsReversed() { return this._isReversed; }
    /** Return the sweep angle as a fraction of full 360 degrees (2PI radians) */
    getThetaFraction() { return this._sweep.radians / (Math.PI * 2.0); }
    /** ask if `other` is an instance of `TorusPipe` */
    isSameGeometryClass(other) { return other instanceof TorusPipe; }
    /** test if `this` and `other` have nearly equal geometry */
    isAlmostEqual(other) {
        if (other instanceof TorusPipe) {
            if (this.capped !== other.capped)
                return false;
            if (!this._localToWorld.isAlmostEqual(other._localToWorld))
                return false;
            return Geometry_1.Geometry.isSameCoordinate(this._radiusA, other._radiusA)
                && Geometry_1.Geometry.isSameCoordinate(this._radiusB, other._radiusB)
                && this._sweep.isAlmostEqualNoPeriodShift(other._sweep);
        }
        return false;
    }
    /** Return the angle (in radians) for given fractional position around the major hoop.
     */
    vFractionToRadians(v) { return this._sweep.radians * v; }
    /** Second step of double dispatch:  call `handler.handleTorusPipe(this)` */
    dispatchToGeometryHandler(handler) {
        return handler.handleTorusPipe(this);
    }
    /**
     * Return the Arc3d section at vFraction.  For the TorusPipe, this is a minor circle.
     * @param vFraction fractional position along the sweep direction
     */
    constantVSection(v) {
        const thetaRadians = this.vFractionToRadians(v);
        const c0 = Math.cos(thetaRadians);
        const s0 = Math.sin(thetaRadians);
        const majorRadius = this.getMajorRadius();
        const minorRadius = this.getMinorRadius();
        const center = this._localToWorld.multiplyXYZ(majorRadius * c0, majorRadius * s0, 0);
        const vector0 = this._localToWorld.multiplyVectorXYZ(minorRadius * c0, minorRadius * s0, 0);
        const vector90 = this._localToWorld.multiplyVectorXYZ(0, 0, minorRadius);
        return Loop_1.Loop.create(Arc3d_1.Arc3d.create(center, vector0, vector90));
    }
    /** Return an arc at constant u, and arc sweep  matching this TorusPipe sweep. */
    constantUSection(uFraction) {
        const theta1Radians = this._sweep.radians;
        const phiRadians = uFraction * Math.PI;
        const majorRadius = this.getMajorRadius();
        const minorRadius = this.getMinorRadius();
        const transform = this._localToWorld;
        const axes = transform.matrix;
        const center = this._localToWorld.multiplyXYZ(0, 0, minorRadius * Math.sin(phiRadians));
        const rxy = majorRadius + minorRadius * Math.cos(phiRadians);
        const vector0 = axes.multiplyXYZ(rxy, 0, 0);
        const vector90 = axes.multiplyXYZ(0, rxy, 0);
        return Path_1.Path.create(Arc3d_1.Arc3d.create(center, vector0, vector90, AngleSweep_1.AngleSweep.createStartEndRadians(0.0, theta1Radians)));
    }
    /** extend `rangeToExtend` to include this `TorusPipe` */
    extendRange(rangeToExtend, transform) {
        const theta1Radians = this._sweep.radians;
        const majorRadius = this.getMajorRadius();
        const minorRadius = this.getMinorRadius();
        const transform0 = this._localToWorld;
        const numThetaSample = Math.ceil(theta1Radians / (Math.PI / 16.0));
        const numHalfPhiSample = 16;
        let phi0 = 0;
        let dphi = 0;
        let numPhiSample = 0;
        let theta = 0;
        let cosTheta = 0;
        let sinTheta = 0;
        let rxy = 0;
        let phi = 0;
        let j = 0;
        const dTheta = theta1Radians / numThetaSample;
        for (let i = 0; i <= numThetaSample; i++) {
            theta = i * dTheta;
            cosTheta = Math.cos(theta);
            sinTheta = Math.sin(theta);
            // At the ends, do the entire phi circle.
            // Otherwise only do the outer half
            if (i === 0 || i === numThetaSample) {
                phi0 = -Math.PI;
                dphi = 2.0 * Math.PI / numHalfPhiSample;
                numPhiSample = numHalfPhiSample;
            }
            else {
                phi0 = -0.5 * Math.PI;
                dphi = Math.PI / numHalfPhiSample;
                numPhiSample = 2 * numHalfPhiSample - 1;
            }
            if (transform) {
                for (j = 0; j <= numPhiSample; j++) {
                    phi = phi0 + j * dphi;
                    rxy = majorRadius + minorRadius * Math.cos(phi);
                    rangeToExtend.extendTransformTransformedXYZ(transform, transform0, cosTheta * rxy, sinTheta * rxy, Math.sin(phi) * minorRadius);
                }
            }
            else {
                for (j = 0; j <= numPhiSample; j++) {
                    phi = phi0 + j * dphi;
                    rxy = majorRadius + minorRadius * Math.sin(phi);
                    rangeToExtend.extendTransformedXYZ(transform0, cosTheta * rxy, sinTheta * rxy, Math.sin(phi) * minorRadius);
                }
            }
        }
    }
    /** Evaluate as a uv surface
     * @param u fractional position in minor (phi)
     * @param v fractional position on major (theta) arc
     */
    uvFractionToPoint(u, v, result) {
        const thetaRadians = v * this._sweep.radians;
        const phiRadians = u * Math.PI * 2.0;
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const minorRadius = this.getMinorRadius();
        const rxy = this.getMajorRadius() + Math.cos(phiRadians) * minorRadius;
        return this._localToWorld.multiplyXYZ(rxy * cosTheta, rxy * sinTheta, minorRadius * Math.sin(phiRadians), result);
    }
    /** Evaluate as a uv surface, returning point and two vectors.
     * @param u fractional position in minor (phi)
     * @param v fractional position on major (theta) arc
     */
    uvFractionToPointAndTangents(u, v, result) {
        const thetaRadians = v * this._sweep.radians;
        const phiRadians = u * Math.PI * 2.0;
        const fTheta = this._sweep.radians;
        const fPhi = Math.PI * 2.0;
        const cosTheta = Math.cos(thetaRadians);
        const sinTheta = Math.sin(thetaRadians);
        const sinPhi = Math.sin(phiRadians);
        const cosPhi = Math.cos(phiRadians);
        const minorRadius = this.getMinorRadius();
        const rxy = this.getMajorRadius() + Math.cos(phiRadians) * minorRadius;
        const rSinPhi = minorRadius * sinPhi;
        const rCosPhi = minorRadius * cosPhi; // appears only as derivative of rSinPhi.
        return Plane3dByOriginAndVectors_1.Plane3dByOriginAndVectors.createOriginAndVectors(this._localToWorld.multiplyXYZ(cosTheta * rxy, sinTheta * rxy, rSinPhi), this._localToWorld.multiplyVectorXYZ(-cosTheta * rSinPhi * fPhi, -sinTheta * rSinPhi * fPhi, rCosPhi * fPhi), this._localToWorld.multiplyVectorXYZ(-rxy * sinTheta * fTheta, rxy * cosTheta * fTheta, 0), result);
    }
    /**
     * Directional distance query
     * * u direction is around the (full) minor hoop
     * * v direction is around the outer radius, sum of (absolute values of) major and minor radii.
     */
    maxIsoParametricDistance() {
        const a = Math.abs(this.getMajorRadius());
        const b = Math.abs(this.getMinorRadius());
        return Point2dVector2d_1.Vector2d.create(b * Math.PI * 2.0, (a + b) * this._sweep.radians);
    }
    /**
     * @return true if this is a closed volume.
     */
    get isClosedVolume() {
        return this.capped || this._sweep.isFullCircle;
    }
}
exports.TorusPipe = TorusPipe;


/***/ }),

/***/ "./lib/topology/ChainMerge.js":
/*!************************************!*\
  !*** ./lib/topology/ChainMerge.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Graph_1 = __webpack_require__(/*! ./Graph */ "./lib/topology/Graph.js");
const Merging_1 = __webpack_require__(/*! ./Merging */ "./lib/topology/Merging.js");
const LineString3d_1 = __webpack_require__(/*! ../curve/LineString3d */ "./lib/curve/LineString3d.js");
const GrowableXYZArray_1 = __webpack_require__(/*! ../geometry3d/GrowableXYZArray */ "./lib/geometry3d/GrowableXYZArray.js");
/** Internal form of ChainMergeContextOptions -- same field names, but required to have contents. */
class ChainMergeContextValidatedOptions {
    /**
     * PRIVATE constructor -- assumes all inputs are validated in public create method !!!!
     * @param tolerance
     * @param unitVectorForPrimarySort
     */
    constructor(tolerance, unitVectorForPrimarySort) {
        /**
         * Tolerance for declaring points equal.
         */
        this.tolerance = Geometry_1.Geometry.smallMetricDistance;
        this.tolerance = tolerance;
        this.primarySortDirection = unitVectorForPrimarySort;
    }
    /** return a unit vector aligned with optional direction.
     * * Default return is into the first quadrant at a quirky angle so any perpendicular plane is unlikely to hit many points
     */
    static createPrimarySortVector(vector) {
        if (vector === undefined) {
            vector = this._defaultPrimarySortDirection.clone();
        }
        return vector.normalizeWithDefault(ChainMergeContextValidatedOptions._defaultPrimarySortDirection.x, ChainMergeContextValidatedOptions._defaultPrimarySortDirection.y, ChainMergeContextValidatedOptions._defaultPrimarySortDirection.z);
    }
    /** return the default option set. */
    static createFromUnValidated(options) {
        const result = new ChainMergeContextValidatedOptions(Geometry_1.Geometry.smallMetricDistance, ChainMergeContextValidatedOptions.createPrimarySortVector());
        if (options !== undefined) {
            if (options.tolerance !== undefined)
                result.tolerance = options.tolerance;
            if (options.primarySortDirection !== undefined)
                result.primarySortDirection = ChainMergeContextValidatedOptions.createPrimarySortVector();
        }
        return result;
    }
    /** Clone this context. */
    clone() {
        return new ChainMergeContextValidatedOptions(this.tolerance, this.primarySortDirection);
    }
}
/** UNNORMALIZED base vector for sorting.
 * * Actual vector hoisted into an instance is normalized.
 */
ChainMergeContextValidatedOptions._defaultPrimarySortDirection = Point3dVector3d_1.Vector3d.create(0.294234298, 0.72391399, 0.45234328798);
/**
 * * Context for assembling line segments into chains.
 * * Use the context in phases:
 *   * Create the context:   `context = ChainMergeContext.create ()`
 *   * Add line with any combination of:
 *      * `context.addSegment(pointA, pointB)`
 *      * `context.addLineSegment3dArray (segments)`
 *   * Scan all coordinate data for common coordinates.  Twist nodes together to form chains:
 *      * `context.clusterAndMergeVerticesXYZ ()`
 *   * Collect the chains:
 *      * myLinestringArray = context.collectMaximalChains();
 *
 * @internal
 */
class ChainMergeContext {
    constructor(options) {
        this._graph = new Graph_1.HalfEdgeGraph();
        this._options = options;
    }
    /**
     * * Construct an empty chain merge graph.
     * * The options parameter may contain any combination of the options values.
     *   * tolerance = absolute tolerance for declaring points equal.
     *     * Default is `Geometry.smallMetricDistance`
     *   * primarySortDirection = direction for first sort.
     *     * To minimize clash among points on primary sort, this should NOT be perpendicular to any principal plane.
     *     * The default points into the first octant with inobvious components.
     */
    static create(options) {
        const validatedOptions = ChainMergeContextValidatedOptions.createFromUnValidated(options);
        return new ChainMergeContext(validatedOptions);
    }
    /** Add a segment to the evolving graph. */
    addSegment(pointA, pointB) {
        this._graph.createEdgeXYZXYZ(pointA.x, pointA.y, pointA.z, 0, pointB.x, pointB.y, pointB.z, 0);
    }
    /** Add all segments from an array to the graph. */
    addLineSegment3dArray(data) {
        for (const segment of data) {
            this.addSegment(segment.point0Ref, segment.point1Ref);
        }
    }
    /**
     * Return a numeric value to be used for sorting, with little chance widely separated nodes will have identical key.
     * * Any single x,y,z component is a poor choice because horizontal and vertical alignment is common.
     * * Hence take dot product of x,y,z with non-trivial fraction values.
     * @param node node with x,y,z coordinates
     */
    primarySortKey(node) {
        return this._options.primarySortDirection.dotProductXYZ(node.x, node.y, node.z);
    }
    /** Return difference of sortData members as sort comparison */
    static nodeCompareSortData(nodeA, nodeB) {
        return nodeA.sortData - nodeB.sortData;
    }
    /** test if nodeA is a dangling edge end (i.e. edges around vertex equal 1, but detect it without walking all the way around. */
    static isIsolatedEnd(nodeA) {
        return nodeA.vertexSuccessor === nodeA;
    }
    /** test if nodeA is at a vertex with exactly 2 edges (i.e. edges around vertex equal w, but detect it without walking all the way around. */
    static isChainInteriorVertex(nodeA) {
        const nodeB = nodeA.vertexSuccessor;
        return nodeB !== nodeA && nodeB.vertexSuccessor === nodeA;
    }
    /**
     * * isolate all edge ends.
     * * perform cluster analysis to determine nearly coincident points.
     * * pinch all edges together at each vertex.
     */
    clusterAndMergeVerticesXYZ() {
        Merging_1.HalfEdgeGraphOps.isolateAllEdges(this._graph);
        for (const p of this._graph.allHalfEdges) {
            p.sortData = this.primarySortKey(p);
        }
        const sortArray = this._graph.allHalfEdges.slice();
        sortArray.sort(ChainMergeContext.nodeCompareSortData);
        const xyzTolerance = this._options.tolerance;
        // A node is unvisited if it is its own vertex successor !!!
        // otherwise the node has already been twisted into a base vertex.
        const n = sortArray.length;
        for (let i0 = 0; i0 < n; i0++) {
            const node0 = sortArray[i0];
            const qMin = node0.sortData;
            const qMax = qMin + xyzTolerance;
            if (ChainMergeContext.isIsolatedEnd(node0)) {
                for (let i1 = i0 + 1; i1 < n; i1++) {
                    const node1 = sortArray[i1];
                    if (ChainMergeContext.isIsolatedEnd(node1)) {
                        if (node1.sortData > qMax)
                            break;
                        if (node0.distanceXYZ(node1) <= xyzTolerance) {
                            Graph_1.HalfEdge.pinch(node0, node1);
                            node1.setXYZFrom(node0); // force true equal coordinates.
                        }
                    }
                }
            }
        }
    }
    /**
     * If node0 is not visited, creating a linestring with that starting edge and all successive edges along a chain.
     * @param chains growing array of chains.
     * @param node0 start node for search.
     */
    collectMaximalLineString3dFromStartNode(chains, node0, visitMask) {
        if (!node0.isMaskSet(visitMask)) {
            const ls = LineString3d_1.LineString3d.create();
            ls.addPointXYZ(node0.x, node0.y, node0.z);
            for (;;) {
                node0.setMask(visitMask);
                node0.edgeMate.setMask(visitMask);
                node0 = node0.faceSuccessor;
                ls.addPointXYZ(node0.x, node0.y, node0.z);
                if (node0.isMaskSet(visitMask) || !ChainMergeContext.isChainInteriorVertex(node0))
                    break;
            }
            chains.push(ls);
        }
    }
    /**
     * If node0 is not visited, creating a linestring with that starting edge and all successive edges along a chain.
     * @param chains growing array of chains.
     * @param node0 start node for search.
     */
    collectMaximalGrowableXYXArrayFromStartNode(result, node0, visitMask) {
        if (!node0.isMaskSet(visitMask)) {
            const points = new GrowableXYZArray_1.GrowableXYZArray();
            points.pushXYZ(node0.x, node0.y, node0.z);
            for (;;) {
                node0.setMask(visitMask);
                node0.edgeMate.setMask(visitMask);
                node0 = node0.faceSuccessor;
                points.pushXYZ(node0.x, node0.y, node0.z);
                if (node0.isMaskSet(visitMask) || !ChainMergeContext.isChainInteriorVertex(node0))
                    break;
            }
            if (points.length > 0)
                result.push(points);
        }
    }
    /**
     * * find edges with start, end in same vertex loop.
     * * pinch them away from the loop
     * * set mask on both sides.
     * * Return the number of excisions.
     */
    exciseAndMarkSlingEdges(mask) {
        let n = 0;
        for (const p of this._graph.allHalfEdges) {
            if (p.distanceXYZ(p.edgeMate) < this._options.tolerance
                && !p.isMaskSet(mask)) {
                const q = p.edgeMate;
                Graph_1.HalfEdge.pinch(p, p.vertexPredecessor);
                Graph_1.HalfEdge.pinch(q, q.vertexPredecessor);
                p.setMask(mask);
                q.setMask(mask);
                n++;
            }
        }
        return n;
    }
    /** Collect chains which have maximum edge count, broken at an vertex with other than 2 edges.
     * * This is assumed to be preceded by a call to a vertex-cluster step such as `clusterAndMergeVerticesYXZ`
     */
    collectMaximalChains() {
        const result = [];
        const visitMask = Graph_1.HalfEdgeMask.VISITED;
        // Pass 0: excise and mark zero-length edges.
        this.exciseAndMarkSlingEdges(visitMask);
        this._graph.clearMask(visitMask);
        // Pass 1: only start at non-interior edges -- vertices with one edge or more than 2 edges.
        // (Note that collectMaximalChain checks the visit mask.)
        for (const node0 of this._graph.allHalfEdges) {
            if (!ChainMergeContext.isChainInteriorVertex(node0)) {
                this.collectMaximalLineString3dFromStartNode(result, node0, visitMask);
            }
        }
        // Pass 2: start anywhere in an unvisited loop.
        for (const node0 of this._graph.allHalfEdges) {
            this.collectMaximalLineString3dFromStartNode(result, node0, visitMask);
        }
        return result;
    }
    collectMaximalGrowableXYZArrays() {
        const result = [];
        const visitMask = Graph_1.HalfEdgeMask.VISITED;
        // Pass 0: excise and mark zero-length edges.
        this.exciseAndMarkSlingEdges(visitMask);
        this._graph.clearMask(visitMask);
        // Pass 1: only start at non-interior edges -- vertices with one edge or more than 2 edges.
        // (Note that collectMaximalChain checks the visit mask.)
        for (const node0 of this._graph.allHalfEdges) {
            if (!ChainMergeContext.isChainInteriorVertex(node0)) {
                this.collectMaximalGrowableXYXArrayFromStartNode(result, node0, visitMask);
            }
        }
        // Pass 2: start anywhere in an unvisited loop.
        for (const node0 of this._graph.allHalfEdges) {
            this.collectMaximalGrowableXYXArrayFromStartNode(result, node0, visitMask);
        }
        return result;
    }
}
exports.ChainMergeContext = ChainMergeContext;


/***/ }),

/***/ "./lib/topology/Graph.js":
/*!*******************************!*\
  !*** ./lib/topology/Graph.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const LineSegment3d_1 = __webpack_require__(/*! ../curve/LineSegment3d */ "./lib/curve/LineSegment3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const MaskManager_1 = __webpack_require__(/*! ./MaskManager */ "./lib/topology/MaskManager.js");
/**
 *
 * * A HalfEdge is "one side of an edge" in a structure of faces, edges and vertices.  From a node there are navigational links to:
 * ** "faceSuccessor" -- the next half edge in a loop around a face.
 * ** "facePredecessor" -- the previous half edge in a loop around a face.
 * ** "edgeMate"  -- the node's partner on the other side of the edge.
 * * The next, prev, and mate are the essential connectivity.  Additional node content is for application-specific
 *     uses.  The most useful ones are:
 * ** x,y -- coordinates in the xy plane
 * ** z -- z coordinate.  This is normally ignored during planar setup, but used for output.
 * ** buffer -- a integer value manipulated as individual bits.
 * * In properly connected planar graph, interior face loops are counterclockwise.  But that property (along with
 *      expected masking) is a result of extensive validation of inputs, and is not true in intermediate phases
 *      of graph manipulation.
 * @internal
 */
class HalfEdge {
    constructor(x = 0, y = 0, z = 0, i = 0) {
        this._id = HalfEdge._totalNodesCreated++;
        this.i = i;
        this.maskBits = 0x00000000;
        this.x = x;
        this.y = y;
        this.z = z;
        // Explicit init to undefined is important for performance here
        this.sortAngle = undefined;
        this.sortData = undefined;
        this.edgeTag = undefined;
        // Always created in pairs, init here to make TS compiler and JS runtime happy
        this._facePredecessor = this;
        this._faceSuccessor = this;
        this._edgeMate = this;
    }
    /** id assigned sequentially during construction --- useful for debugging. */
    get id() { return this._id; }
    /** previous half edge "around the face"
     */
    get facePredecessor() { return this._facePredecessor; }
    /** next half edge "around the face" */
    get faceSuccessor() { return this._faceSuccessor; }
    /** Half edge on the other side of this edge.
     */
    get edgeMate() { return this._edgeMate; }
    /** Take numStep face steps and return y coordinate
     * * positive steps are through faceSuccessor
     * * negative steps are through facePredecessor
     */
    faceStepY(numStep) {
        let node = this;
        if (numStep > 0)
            for (let i = 0; i < numStep; i++)
                node = node.faceSuccessor;
        else if (numStep < 0)
            for (let i = 0; i > numStep; i--)
                node = node.facePredecessor;
        return node.y;
    }
    /**
     * * Create 2 half edges.
     * * The two edges are joined as edgeMate pair.
     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.
     * @returns Returns the reference to the first half edge created
     */
    static createHalfEdgePair(heArray) {
        const a = new HalfEdge();
        const b = new HalfEdge();
        if (heArray) {
            heArray.push(a);
            heArray.push(b);
        }
        HalfEdge.setFaceLinks(a, b);
        HalfEdge.setFaceLinks(b, a);
        HalfEdge.setEdgeMates(a, b);
        return a;
    }
    /**
     * * Create 2 half edges.
     * * The two edges are joined as edgeMate pair.
     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.
     * * Properties x,y,z,i are inserted in each
     * @returns Returns the reference to the first half edge created
     */
    static createHalfEdgePairWithCoordinates(xA = 0, yA = 0, zA = 0, iA = 0, xB = 0, yB = 0, zB = 0, iB = 0, heArray) {
        const a = HalfEdge.createHalfEdgePair(heArray);
        const b = a._edgeMate;
        a.x = xA;
        a.y = yA;
        a.z = zA;
        a.i = iA;
        b.x = xB;
        b.y = yB;
        b.z = zB;
        b.i = iB;
        return a;
    }
    /**
     * * set heA <==> heB pointer relation through heA._faceSuccessor and heB._facePredecessor
     * * This changes heA._faceSuccessor and heB._facePredecessor, but not heA._facePredecessor and heB._faceSuccessor.
     * * this must always be done with another call to reestablish the entire double-linked list.
     */
    static setFaceLinks(heA, heB) {
        heA._faceSuccessor = heB;
        heB._facePredecessor = heA;
    }
    /**
     * * set heA <==> heB pointer relation edgeMate
     */
    static setEdgeMates(heA, heB) {
        heA._edgeMate = heB;
        heB._edgeMate = heA;
    }
    /**
     * * Create a new vertex within the edge from base.
     * * Insert it "within" the base edge.
     * * This requires two new half edges.
     * * if the base is undefined, create a single-edge loop.
     * * This (unlike pinch) breaks the edgeMate pairing of the base edge.
     * * This preserves xyz and i properties at all existing vertices.
     * * on each side, if edgeTag is present it is copied to the new edge.
     * @returns Returns the reference to the half edge created.
     */
    static splitEdge(baseA, xA = 0, yA = 0, zA = 0, iA = 0, heArray) {
        const newA = new HalfEdge(xA, yA, zA, iA);
        const newB = new HalfEdge(xA, yA, zA, iA);
        if (heArray) {
            heArray.push(newA);
            heArray.push(newB);
        }
        if (baseA === undefined) {
            newA._faceSuccessor = newA._facePredecessor = newA;
            newB._faceSuccessor = newB._facePredecessor = newB;
            HalfEdge.setEdgeMates(newA, newB);
        }
        else {
            const nextA = baseA._faceSuccessor;
            const mateA = baseA._edgeMate;
            const vPredA = mateA._faceSuccessor;
            HalfEdge.setFaceLinks(newA, nextA);
            HalfEdge.setFaceLinks(baseA, newA);
            HalfEdge.setFaceLinks(mateA, newB);
            HalfEdge.setFaceLinks(newB, vPredA);
            HalfEdge.setEdgeMates(newA, mateA);
            HalfEdge.setEdgeMates(newB, baseA);
            newA.edgeTag = baseA.edgeTag;
            newB.edgeTag = mateA.edgeTag;
        }
        return newA;
    }
    /**
     * Return the next outbound half edge around this vertex in the CCW direction
     */
    get vertexSuccessor() { return this.facePredecessor.edgeMate; }
    /**
     * Return the next outbound half edge around this vertex in the CW direction
     */
    get vertexPredecessor() { return this.edgeMate.faceSuccessor; }
    /**
     * Set mask bits on this HalfEdge
     * @param mask mask to apply
     */
    setMask(mask) { this.maskBits |= mask; }
    /**
     * Get mask bits from this HalfEdge
     * @param mask mask to query
     */
    getMask(mask) { return (this.maskBits & mask); }
    /**
     * Clear mask bits from this HalfEdge
     * @param mask mask to clear
     */
    clearMask(mask) { this.maskBits &= ~mask; }
    /**
     * Set a mask at all nodes around a vertex.
     * @param mask mask to apply to the half edges around this HalfEdge's vertex loop
     */
    setMaskAroundVertex(mask) {
        let node = this;
        do {
            node.setMask(mask);
            node = node.vertexSuccessor;
        } while (node !== this);
    }
    /**
     * Set x,y,z at all nodes around a vertex.
     * @param mask mask to apply to the half edges around this HalfEdge's vertex loop
     */
    setXYZAroundVertex(x, y, z) {
        let node = this;
        do {
            node.x = x;
            node.y = y;
            node.z = z;
            node = node.vertexSuccessor;
        } while (node !== this);
    }
    /**
     * Apply a mask to all edges around a face.
     * @param mask mask to apply to the half edges around this HalfEdge's face loop
     */
    setMaskAroundFace(mask) {
        let node = this;
        do {
            node.setMask(mask);
            node = node.faceSuccessor;
        } while (node !== this);
    }
    /**
     * Apply a mask to both sides of an edge.
     * @param mask mask to apply to this edge and its `edgeMate`
     */
    setMaskAroundEdge(mask) {
        this.setMask(mask);
        this.edgeMate.setMask(mask);
    }
    /**
     * Apply a mask to both sides of an edge.
     * @param mask mask to apply to this edge and its `edgeMate`
     */
    clearMaskAroundEdge(mask) {
        this.clearMask(mask);
        this.edgeMate.clearMask(mask);
    }
    /** Returns the number of edges around this face. */
    countEdgesAroundFace() {
        let count = 0;
        let node = this;
        do {
            count++;
            node = node.faceSuccessor;
        } while (node !== this);
        return count;
    }
    /**
     * Apply a edgeTag and mask to all edges around a face.
     * optionally apply it to all edge mates.
     * @param edgeTag tag to apply
     * @param bothSides If true, also apply the tag to the mates around the face.
     */
    setMaskAndEdgeTagAroundFace(mask, tag, applyToMate = false) {
        let node = this;
        do {
            node.setMask(mask);
            node.edgeTag = tag;
            if (applyToMate) {
                const mate = node.edgeMate;
                mate.edgeTag = tag;
                mate.setMask(mask);
            }
            node = node.faceSuccessor;
        } while (node !== this);
    }
    /** Returns the number of edges around vertex. */
    countEdgesAroundVertex() {
        let count = 0;
        let node = this;
        do {
            count++;
            node = node.vertexSuccessor;
        } while (node !== this);
        return count;
    }
    /** Returns the number of nodes found with the given mask value around this vertex loop. */
    countMaskAroundFace(mask, value = true) {
        let count = 0;
        let node = this;
        if (value) {
            do {
                if (node.isMaskSet(mask))
                    count++;
                node = node.faceSuccessor;
            } while (node !== this);
        }
        else {
            do {
                if (!node.isMaskSet(mask))
                    count++;
                node = node.faceSuccessor;
            } while (node !== this);
        }
        return count;
    }
    /** Returns the number of nodes found with the given mask value around this vertex loop.   */
    countMaskAroundVertex(mask, value = true) {
        let count = 0;
        let node = this;
        if (value) {
            do {
                if (node.isMaskSet(mask))
                    count++;
                node = node.vertexSuccessor;
            } while (node !== this);
        }
        else {
            do {
                if (!node.isMaskSet(mask))
                    count++;
                node = node.vertexSuccessor;
            } while (node !== this);
        }
        return count;
    }
    /** Set a mask, and return prior value.
     * @param mask mask to apply
     */
    testAndSetMask(mask) {
        const oldMask = this.maskBits & mask;
        this.maskBits |= mask;
        return oldMask;
    }
    /**
     * Set (copy) the this.x, this.y, this.z from node.x, node.y, node.z
     * @param node node containing xyz
     */
    setXYZFrom(node) {
        this.x = node.x;
        this.y = node.y;
        this.z = node.z;
    }
    /**
     * Test if mask bits are set in the node's bitMask.
     * @return Return true (as a simple boolean, not a mask) if any bits of the mask parameter match bits of the node's bitMask
     */
    isMaskSet(mask) { return (this.maskBits & mask) !== 0; }
    /** (static!) method to test if a mask is set on a node.
     * This is used as filter in searches.
     * @returns true iff `node.isMaskSet (mask)`
     */
    static filterIsMaskOn(node, mask) {
        return node.isMaskSet(mask);
    }
    /** (static!) method to test if a mask is set on a node.
     * This is used as filter in searches.
     * @returns true iff `!node.isMaskSet (mask)`
     */
    static filterIsMaskOff(node, mask) {
        return !node.isMaskSet(mask);
    }
    /**
     * Create an edge with initial id,x,y at each end.
     * @param id0 id for first node
     * @param x0  x coordinate for first node
     * @param y0  y coordinate for first node
     * @param id1 id for second node
     * @param x1 x coordinate for second node
     * @param y1 y coordinate for second node
     */
    static createEdgeXYXY(id0, x0, y0, id1, x1, y1) {
        const node0 = new HalfEdge(x0, y0);
        const node1 = new HalfEdge(x1, y1);
        node0._faceSuccessor = node0._facePredecessor = node0._edgeMate = node1;
        node1._faceSuccessor = node1._facePredecessor = node1._edgeMate = node0;
        node0._id = id0;
        node1._id = id1;
        return node0;
    }
    /** "pinch" ...
     *
     * * is the universal manipulator for manipulating a node's next and prev pointers
     * * swaps face predecessors of nodeA and nodeB.
     * *  is its own inverse.
     * *  if nodeA, nodeB are in different face loops, the loops join to one loop.
     * *  if nodeA, nodeB are in the same face loop, the loop splits into two loops.
     */
    static pinch(nodeA, nodeB) {
        if (nodeA !== nodeB) {
            const predA = nodeA._facePredecessor;
            const predB = nodeB._facePredecessor;
            nodeB._facePredecessor = predA;
            nodeA._facePredecessor = predB;
            predB._faceSuccessor = nodeA;
            predA._faceSuccessor = nodeB;
        }
    }
    /** Turn all pointers to undefined so garbage collector can reuse the object.
     *  This is to be called only by a Graph object that is being decommissioned.
     */
    decommission() {
        this._facePredecessor = undefined;
        this._faceSuccessor = undefined;
        this._edgeMate = undefined;
    }
    /** Return the node. This identity function is useful as the NodeFunction in collector methods. */
    static nodeToSelf(node) { return node; }
    /** Return the id of a node.  Useful for collector methods. */
    static nodeToId(node) { return node.id; }
    /** Return the id of a node.Useful for collector methods. */
    static nodeToIdString(node) { return node.id.toString(); }
    /** Return the [id, [x,y]] of a node.  Useful for collector methods. */
    static nodeToIdMaskXY(node) {
        return { id: node.id, mask: HalfEdge.nodeToMaskString(node), xy: [node.x, node.y] };
    }
    /** Return the [id, [x,y]] of a node.  Useful for collector methods. */
    static nodeToIdXYString(node) {
        const s = node.id.toString() + " " +
            HalfEdge.nodeToMaskString(node) + " [" + node.x + "," + node.y + "]";
        return s;
    }
    /** Create a string representation of the mask
     * * Null mask is empty string.
     * * Appended characters B,P,X for Boundary, Primary, Exterior mask bits.
     */
    static nodeToMaskString(node) {
        let s = "";
        if (node.isMaskSet(HalfEdgeMask.BOUNDARY_EDGE))
            s += "B";
        if (node.isMaskSet(HalfEdgeMask.PRIMARY_EDGE))
            s += "P";
        if (node.isMaskSet(HalfEdgeMask.EXTERIOR))
            s += "X";
        if (node.isMaskSet(HalfEdgeMask.NULL_FACE))
            s += "N";
        return s;
    }
    /** Return [x,y] with coordinates of node */
    static nodeToXY(node) { return [node.x, node.y]; }
    /** Return Vector2d to face successor, with only xy coordinates */
    vectorToFaceSuccessorXY(result) {
        return Point2dVector2d_1.Vector2d.create(this.faceSuccessor.x - this.x, this.faceSuccessor.y - this.y, result);
    }
    /** Return Vector3d to face successor */
    vectorToFaceSuccessor(result) {
        return Point3dVector3d_1.Vector3d.create(this.faceSuccessor.x - this.x, this.faceSuccessor.y - this.y, this.faceSuccessor.z - this.z, result);
    }
    /** Returns Return cross product (2d) of vectors from base to target1 and this to target2 */
    static crossProductXYToTargets(base, targetA, targetB) {
        return Geometry_1.Geometry.crossProductXYXY(targetA.x - base.x, targetA.y - base.y, targetB.x - base.x, targetB.y - base.y);
    }
    /** Return cross product (2d) of vectors from nodeA to nodeB and nodeB to nodeC
     */
    static crossProductXYAlongChain(nodeA, nodeB, nodeC) {
        return Geometry_1.Geometry.crossProductXYXY(nodeB.x - nodeA.x, nodeB.y - nodeA.y, nodeC.x - nodeB.x, nodeC.y - nodeB.y);
    }
    /** Return true if `this` is lexically below `other`, comparing y first then x. */
    belowYX(other) {
        // Check y's
        // if (!Geometry.isSameCoordinate(a.y, b.y))
        if (this.y < other.y)
            return true;
        if (this.y > other.y)
            return false;
        // same y.
        // Check x's
        if (this.x < other.x)
            return true;
        return false;
    }
    /** Returns Returns true if the node does NOT have Mask.EXTERIOR_MASK set. */
    static testNodeMaskNotExterior(node) { return !node.isMaskSet(HalfEdgeMask.EXTERIOR); }
    /** Returns Returns true if the face has positive area in xy parts. */
    static testFacePositiveAreaXY(node) {
        return node.countEdgesAroundFace() > 2 && node.signedFaceArea() > 0.0;
    }
    /** Return true if x and y coordinates of this and other are exactly equal */
    isEqualXY(other) {
        return this.x === other.x && this.y === other.y;
    }
    /** Return true if x and y coordinates of this and other are exactly equal */
    distanceXY(other) {
        return Geometry_1.Geometry.distanceXYXY(this.x, this.y, other.x, other.y);
    }
    /** Return true if x and y coordinates of this and other are exactly equal */
    distanceXYZ(other) {
        return Geometry_1.Geometry.distanceXYZXYZ(this.x, this.y, this.z, other.x, other.y, other.z);
    }
    /**
     *
     * * Evaluate f(node) at each node around a face loop.
     * * Collect the function values.
     * @returns Return the array of function values.
     */
    collectAroundFace(f) {
        const nodes = [];
        let node = this;
        do {
            nodes.push(f ? f(node) : node);
            node = node.faceSuccessor;
        } while (node !== this);
        return nodes;
    }
    /**
     *
     * * Evaluate f(node) at each outbound node around this node's vertex loop.
     * * Collect the function values.
     * @returns Return the array of function values.
     */
    collectAroundVertex(f) {
        const nodes = [];
        let node = this;
        do {
            nodes.push(f ? f(node) : node);
            node = node.vertexSuccessor;
        } while (node !== this);
        return nodes;
    }
    /**
     *
     * * Evaluate f(node) at each node around a face loop.
     * * Sum the function values
     * @returns Return the sum
     */
    sumAroundFace(f) {
        let node = this;
        let sum = 0;
        do {
            sum += f(node);
            node = node.faceSuccessor;
        } while (node !== this);
        return sum;
    }
    /**
     *
     * * Evaluate f(node) at each outbound node around this node's vertex loop.
     * * Sum the function values
     * @returns Return the sum
     */
    sumAroundVertex(f) {
        let node = this;
        let sum = 0;
        do {
            sum += f(node);
            node = node.vertexSuccessor;
        } while (node !== this);
        return sum;
    }
    /** For all the nodes in the face loop of the given node, clear out the mask given */
    clearMaskAroundFace(mask) {
        let node = this;
        do {
            node.clearMask(mask);
            node = node.faceSuccessor;
        } while (node !== this);
    }
    /** For all the nodes in the vertex loop of the given node, clear out the mask given */
    clearMaskAroundVertex(mask) {
        let node = this;
        do {
            node.clearMask(mask);
            node = node.vertexSuccessor;
        } while (node !== this);
    }
    /** Returns the signed sum of xy areas of triangles from first node to edges.
     *
     * * A positive area is counterclockwise.
     * * A negative area is clockwise.
     */
    signedFaceArea() {
        let sum = 0;
        // sum area of trapezoids.
        // * the formula in the loop gives twice the area (because it does nto average the y values).
        // * this is fixed up at the end by a single multiply by 0.5
        // * individual trapezoid heights are measured from y at the start node to keep area values numerical smaller.
        const y0 = this.y;
        let dy0 = 0.0;
        let dy1 = 0.0;
        let x0 = this.x;
        let x1 = x0;
        let node1 = this; // just to initialize -- reassigned in each loop pass.
        let node0 = this;
        do {
            node1 = node0.faceSuccessor;
            x1 = node1.x;
            dy1 = node1.y - y0;
            sum += (x0 - x1) * (dy0 + dy1);
            x0 = x1;
            dy0 = dy1;
            node0 = node1;
            node0 = node1;
        } while (node0 !== this);
        return 0.5 * sum;
    }
    /**
     * interpolate xy coordinates between this node and its face successor.
     * @param fraction fractional position along this edge.
     * @param result xy coordinates
     */
    fractionToPoint2d(fraction, result) {
        const node1 = this.faceSuccessor;
        return Point2dVector2d_1.Point2d.create(this.x + (node1.x - this.x) * fraction, this.y + (node1.y - this.y) * fraction, result);
    }
    /**
     * interpolate xy coordinates between this node and its face successor.
     * @param fraction fractional position along this edge.
     * @param result xy coordinates
     */
    fractionToPoint3d(fraction, result) {
        const node1 = this.faceSuccessor;
        return Point3dVector3d_1.Point3d.create(this.x + (node1.x - this.x) * fraction, this.y + (node1.y - this.y) * fraction, this.z + (node1.z - this.z) * fraction, result);
    }
    /**
     * * interpolate xy coordinates at fractionAlong between this node and its face successor.
     * * shift to left by fractionPerpendicular
     * @param fraction fractional position along this edge.
     * @param result xy coordinates
     */
    fractionAlongAndPerpendicularToPoint2d(fractionAlong, fractionPerpendicular, result) {
        const node1 = this.faceSuccessor;
        const dx = node1.x - this.x;
        const dy = node1.y - this.y;
        return Point2dVector2d_1.Point2d.create(this.x + dx * fractionAlong - dy * fractionPerpendicular, this.y + dy * fractionAlong + dx * fractionPerpendicular, result);
    }
    /**
     * Return the interpolated x coordinate between this node and its face successor.
     * @param fraction fractional position along this edge.
     */
    fractionToX(fraction) {
        const node1 = this.faceSuccessor;
        return this.x + (node1.x - this.x) * fraction;
    }
    /**
     * Return the interpolated y coordinate between this node and its face successor.
     * @param fraction fractional position along this edge.
     */
    fractionToY(fraction) {
        const node1 = this.faceSuccessor;
        return this.y + (node1.y - this.y) * fraction;
    }
    /**
     * Return the interpolated z coordinate between this node and its face successor.
     * @param fraction fractional position along this edge.
     */
    fractionToZ(fraction) {
        const node1 = this.faceSuccessor;
        return this.z + (node1.z - this.z) * fraction;
    }
    /**
     * * Compute fractional coordinates of the intersection of edges from given base nodes
     * * If parallel or colinear, return undefined.
     * * If (possibly extended) lines intersect, return the fractions of intersection as x,y in the result.
     * @param nodeA0 Base node of edge A
     * @param nodeB0 Base node of edge B
     * @param result optional preallocated result
     */
    static transverseIntersectionFractions(nodeA0, nodeB0, result) {
        const nodeA1 = nodeA0.faceSuccessor;
        const nodeB1 = nodeB0.faceSuccessor;
        if (!result)
            result = Point2dVector2d_1.Vector2d.create();
        if (Polynomials_1.SmallSystem.linearSystem2d(nodeA1.x - nodeA0.x, nodeB0.x - nodeB1.x, nodeA1.y - nodeA0.y, nodeB0.y - nodeB1.y, nodeB0.x - nodeA0.x, nodeB0.y - nodeA0.y, result))
            return result;
        return undefined;
    }
    /**
     * * Compute fractional coordinates of the intersection of a horizontal line with an edge.
     * * If the edge is horizontal with (approximate) identical y, return the node.
     * * If the edge is horizontal with different y, return undefined.
     * * If the edge is not horizontal, return the fractional position (possibly outside 0..1) of the intersection.
     * @param nodeA Base node of edge
     * @param result optional preallocated result
     */
    static horizontalScanFraction(node0, y) {
        const node1 = node0.faceSuccessor;
        const dy = node1.y - node0.y;
        if (Geometry_1.Geometry.isSameCoordinate(y, node0.y) && Geometry_1.Geometry.isSameCoordinate(y, node1.y))
            return node0;
        if (Geometry_1.Geometry.isSameCoordinate(dy, 0.0))
            return undefined;
        return Geometry_1.Geometry.conditionalDivideFraction(y - node0.y, dy);
    }
    /**
     * * Compute fractional coordinates of the intersection of a horizontal line with an edge.
     * * If the edge is horizontal return undefined (no test for horizontal at y!!!)
     * * If the edge is not horizontal and y is between its end y's, return the fraction
     * @param nodeA Base node of edge
     * @param result optional preallocated result
     */
    static horizontalScanFraction01(node0, y) {
        const node1 = node0.faceSuccessor;
        const dy = node1.y - node0.y;
        if (Geometry_1.Geometry.isSameCoordinate(y, node0.y) && Geometry_1.Geometry.isSameCoordinate(y, node1.y))
            return undefined;
        if (Geometry_1.Geometry.isSameCoordinate(dy, 0.0))
            return undefined;
        const fraction = Geometry_1.Geometry.conditionalDivideFraction(y - node0.y, dy);
        if (fraction !== undefined && fraction >= 0.0 && fraction <= 1.0)
            return fraction;
        return undefined;
    }
}
exports.HalfEdge = HalfEdge;
HalfEdge._totalNodesCreated = 0;
/**
 * A HalfEdgeGraph has:
 * * An array of (pointers to ) HalfEdge objects.
 * * A pool of masks for grab/drop use by algorithms.
 * @internal
 */
class HalfEdgeGraph {
    constructor() {
        this._numNodesCreated = 0;
        this.allHalfEdges = [];
        this._maskManager = MaskManager_1.MaskManager.create(HalfEdgeMask.ALL_GRAB_DROP_MASKS);
    }
    /** Ask for a mask (from the graph's free pool.) for caller's use.
     * * Optionally clear the mask throughout the graph.
     */
    grabMask(clearInAllHalfEdges = true) {
        const mask = this._maskManager.grabMask();
        if (clearInAllHalfEdges) {
            this.clearMask(mask);
        }
        return mask;
    }
    /**
     * Return `mask` to the free pool.
     */
    dropMask(mask) { this._maskManager.dropMask(mask); }
    /**
     * * Create 2 half edges forming 2 vertices, 1 edge, and 1 face
     * * The two edges are joined as edgeMate pair.
     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.
     * * The two edges are added to the graph's HalfEdge set
     * @returns Return pointer to the first half edge created.
     */
    createEdgeXYZXYZ(xA = 0, yA = 0, zA = 0, iA = 0, xB = 0, yB = 0, zB = 0, iB = 0) {
        const a = HalfEdge.createHalfEdgePairWithCoordinates(xA, yA, zA, iA, xB, yB, zB, iB, this.allHalfEdges);
        return a;
    }
    /**
     * * create an edge from coordinates x,y,z to (the tail of) an existing half edge.
     * @returns Return pointer to the half edge with tail at x,y,z
     */
    createEdgeXYZHalfEdge(xA = 0, yA = 0, zA = 0, iA = 0, node, iB = 0) {
        const a = HalfEdge.createHalfEdgePairWithCoordinates(xA, yA, zA, iA, node.x, node.y, node.z, iB, this.allHalfEdges);
        const b = a.faceSuccessor;
        HalfEdge.pinch(node, b);
        return a;
    }
    /**
     * * create an edge from coordinates x,y,z to (the tail of) an existing half edge.
     * @returns Return pointer to the half edge with tail at x,y,z
     */
    createEdgeHalfEdgeHalfEdge(nodeA, idA, nodeB, idB = 0) {
        const a = HalfEdge.createHalfEdgePairWithCoordinates(nodeA.x, nodeA.y, nodeA.z, idA, nodeB.x, nodeB.y, nodeB.z, idB, this.allHalfEdges);
        const b = a.faceSuccessor;
        HalfEdge.pinch(nodeA, a);
        HalfEdge.pinch(nodeB, b);
        return a;
    }
    /**
     * * Create 2 half edges forming 2 vertices, 1 edge, and 1 face
     * * The two edges are joined as edgeMate pair.
     * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.
     * * The two edges are added to the graph's HalfEdge set
     * @returns Return pointer to the first half edge created.
     */
    createEdgeXYAndZ(xyz0, id0, xyz1, id1) {
        const a = HalfEdge.createHalfEdgePairWithCoordinates(xyz0.x, xyz0.y, xyz0.z, id0, xyz1.x, xyz1.y, xyz1.z, id1, this.allHalfEdges);
        return a;
    }
    /**
     * * Insert a vertex in the edge beginning at base.
     * * this creates two half edges.
     * * The base of the new edge is 'after' the (possibly undefined) start node in its face loop.
     * * The existing mate retains its base xyz and i properties but is no longer the mate of base.
     * * The base and existing mate each become mates with a new half edge.
     * @returns Returns the reference to the half edge created.
     */
    splitEdge(base, xA = 0, yA = 0, zA = 0, iA = 0) {
        const he = HalfEdge.splitEdge(base, xA, yA, zA, iA, this.allHalfEdges);
        return he;
    }
    /**
     * * Insert a vertex in the edge beginning at base, with coordinates specified as a fraction along the existing edge.
     * * this creates two half edges.
     * * The base of the new edge is 'after' the (possibly undefined) start node in its face loop.
     * * The existing mate retains its base xyz and i properties but is no longer the mate of base.
     * * The base and existing mate each become mates with a new half edge.
     * @returns Returns the reference to the half edge created.
     */
    splitEdgeAtFraction(base, fraction) {
        const he = HalfEdge.splitEdge(base, base.fractionToX(fraction), base.fractionToY(fraction), base.fractionToZ(fraction), 0, this.allHalfEdges);
        return he;
    }
    /** This is a destructor-like action that eliminates all interconnection among the graph's nodes.
     * After this is called the graph is unusable.
     */
    decommission() {
        for (const node of this.allHalfEdges) {
            node.decommission();
        }
        this.allHalfEdges.length = 0;
        this.allHalfEdges = undefined;
    }
    /** create two nodes of a new edge.
     * @returns Return one of the two nodes, which the caller may consider as the start of the edge.
     */
    addEdgeXY(x0, y0, x1, y1) {
        const baseNode = HalfEdge.createEdgeXYXY(this._numNodesCreated, x0, y0, this._numNodesCreated + 1, x1, y1);
        this._numNodesCreated += 2;
        this.allHalfEdges.push(baseNode);
        this.allHalfEdges.push(baseNode.faceSuccessor);
        return baseNode;
    }
    /** Clear selected bits in all nodes of the graph. */
    clearMask(mask) {
        for (const node of this.allHalfEdges)
            node.maskBits &= ~mask;
    }
    /** Set selected bits in all nodes of the graph. */
    setMask(mask) {
        for (const node of this.allHalfEdges)
            node.maskBits |= mask;
    }
    /** toggle selected bits in all nodes of the graph. */
    reverseMask(mask) {
        for (const node of this.allHalfEdges) {
            node.maskBits ^= mask;
        }
    }
    /**
     * Return the number of nodes that have a specified mask bit set.
     * @param mask mask to count
     */
    countMask(mask) {
        let n = 0;
        for (const node of this.allHalfEdges)
            if (node.isMaskSet(mask))
                n++;
        return n;
    }
    /** Return an array LineSegment3d.
     * * The array has one segment per edge
     * * The coordinates are taken from a node and its face successor.
     * * On each edge, the line segment start at the HalfEdge with lower id than its edgeMate.
     */
    collectSegments() {
        const segments = [];
        for (const node of this.allHalfEdges) {
            if (node.id < node.edgeMate.id)
                segments.push(LineSegment3d_1.LineSegment3d.create(Point3dVector3d_1.Point3d.create(node.x, node.y), Point3dVector3d_1.Point3d.create(node.faceSuccessor.x, node.faceSuccessor.y)));
        }
        return segments;
    }
    /** Returns the number of vertex loops in a graph structure */
    countVertexLoops() {
        this.clearMask(HalfEdgeMask.VISITED);
        let count = 0;
        this.announceVertexLoops((_graph, _seed) => { count++; return true; });
        return count;
    }
    /** Returns the number of face loops */
    countFaceLoops() {
        this.clearMask(HalfEdgeMask.VISITED);
        let count = 0;
        this.announceFaceLoops((_graph, _seed) => { count++; return true; });
        return count;
    }
    /**
     * Returns the number of face loops satisfying a filter function with mask argument.
     *
     */
    countFaceLoopsWithMaskFilter(filter, mask) {
        this.clearMask(HalfEdgeMask.VISITED);
        let count = 0;
        this.announceFaceLoops((_graph, seed) => {
            if (filter(seed, mask))
                count++;
            return true;
        });
        return count;
    }
    /** Returns an array of nodes, where each node represents a starting point of a face loop.
     */
    collectFaceLoops() {
        const returnArray = [];
        this.announceFaceLoops((_graph, node) => { returnArray.push(node); return true; });
        return returnArray;
    }
    /** Returns an array of nodes, where each node represents a starting point of a vertex loop.
     */
    collectVertexLoops() {
        this.clearMask(HalfEdgeMask.VISITED);
        const returnArray = [];
        for (const node of this.allHalfEdges) {
            if (node.getMask(HalfEdgeMask.VISITED))
                continue;
            returnArray.push(node);
            node.setMaskAroundVertex(HalfEdgeMask.VISITED);
        }
        return returnArray;
    }
    /**
     * * Visit each facet of the graph once.
     * * Call the announceFace function
     * * continue search if announceFace(graph, node) returns true
     * * terminate search if announce face (graph, node) returns false
     * @param  announceFace function to apply at one node of each face.
     */
    announceFaceLoops(announceFace) {
        this.clearMask(HalfEdgeMask.VISITED);
        for (const node of this.allHalfEdges) {
            if (node.getMask(HalfEdgeMask.VISITED))
                continue;
            node.setMaskAroundFace(HalfEdgeMask.VISITED);
            if (!announceFace(this, node))
                break;
        }
    }
    /**
     * * Visit each vertex loop of the graph once.
     * * Call the announceVertex function
     * * continue search if announceFace(graph, node) returns true
     * * terminate search if announce face (graph, node) returns false
     * @param  announceVertex function to apply at one node of each face.
     */
    announceVertexLoops(announceVertex) {
        this.clearMask(HalfEdgeMask.VISITED);
        for (const node of this.allHalfEdges) {
            if (node.getMask(HalfEdgeMask.VISITED))
                continue;
            node.setMaskAroundVertex(HalfEdgeMask.VISITED);
            if (!announceVertex(this, node))
                break;
        }
    }
    /** Return the number of nodes in the graph */
    countNodes() { return this.allHalfEdges.length; }
    /** Apply transform to the xyz coordinates in the graph. */
    transformInPlace(transform) {
        for (const node of this.allHalfEdges) {
            transform.multiplyXYAndZInPlace(node);
        }
    }
}
exports.HalfEdgeGraph = HalfEdgeGraph;
// cspell:word CONSTU
// cspell:word CONSTV
// cspell:word USEAM
// cspell:word VSEAM
/**
 * * Each node of the graph has a mask member.
 * * The mask member is a number which is used as set of single bit boolean values.
 * * Particular meanings of the various bits are HIGHLY application dependent.
 *   * The EXTERIOR mask bit is widely used to mark nodes that are "outside" the active areas
 *   * The PRIMARY_EDGE bit is widely used to indicate linework created directly from input data, hence protected from triangle edge flipping.
 *   * The BOUNDARY bit is widely used to indicate that crossing this edge is a transition from outside to inside.
 *   * VISITED is used locally in many searches.
 *      * Never use VISITED unless the search logic is highly self contained.
 * @internal
 */
var HalfEdgeMask;
(function (HalfEdgeMask) {
    /**  Mask commonly set consistently around exterior faces.
     * * A boundary edge with interior to one side, exterior to the other will have EXTERIOR only on the outside.
     * * An an edge inserted "within a purely exterior face" can have EXTERIOR on both MediaStreamAudioDestinationNode[Symbol]
     * * An interior edges (such as added during triangulation) will have no EXTERIOR bits.
     */
    HalfEdgeMask[HalfEdgeMask["EXTERIOR"] = 1] = "EXTERIOR";
    /** Mask commonly set (on both sides) of original geometry edges that are transition from outside from to inside.
     * * At the moment of creating an edge from primary user boundary loop coordinates, the fact that an edge is BOUNDARY is often clear even though
     *  there is uncertainty about which side should be EXTERIOR.
     */
    HalfEdgeMask[HalfEdgeMask["BOUNDARY_EDGE"] = 2] = "BOUNDARY_EDGE";
    // REMARK: Various mask names are COMMENTED here for reference to native legacy code.
    // CONSTU_MASK = 0x00000004,
    // CONSTV_MASK = 0x00000008,
    // USEAM_MASK = 0x00000010,
    // VSEAM_MASK = 0x00000020,
    // BOUNDARY_VERTEX_MASK = 0x00000040,
    // PRIMARY_VERTEX_MASK = 0x00000080,
    // DIRECTED_EDGE_MASK = 0x00000100,
    /** Mask commonly set (on both sides) of original geometry edges, but NOT indicating that the edge is certainly a boundary between outside and inside.
     * * For instance, if geometry is provided as stray sticks (not loops), it can be marked PRIMARY_EDGE but neither BOUNDARY_EDGE nor EXTERIOR_EDGE
     */
    HalfEdgeMask[HalfEdgeMask["PRIMARY_EDGE"] = 4] = "PRIMARY_EDGE";
    /** Mask used for low level searches to identify previously-visited nodes */
    HalfEdgeMask[HalfEdgeMask["VISITED"] = 16] = "VISITED";
    /** Mask applied to triangles by earcut triangulator */
    HalfEdgeMask[HalfEdgeMask["TRIANGULATED_FACE"] = 256] = "TRIANGULATED_FACE";
    /** mask applied in a face with 2 edges. */
    HalfEdgeMask[HalfEdgeMask["NULL_FACE"] = 512] = "NULL_FACE";
    /** no mask bits */
    HalfEdgeMask[HalfEdgeMask["NULL_MASK"] = 0] = "NULL_MASK";
    /** The "upper 12 " bits of 32 bit integer. */
    HalfEdgeMask[HalfEdgeMask["ALL_GRAB_DROP_MASKS"] = 4293918720] = "ALL_GRAB_DROP_MASKS";
    /** all mask bits */
    HalfEdgeMask[HalfEdgeMask["ALL_MASK"] = 4294967295] = "ALL_MASK";
    // informal convention on preassigned mask bit numbers:
    // byte0 (EXTERIOR, BOUNDARY_EDGE, PRIMARY_EDGE) -- edge properties
    // byte1 (VISITED, VISIT_A, WORK_MASK0, WORK_MASK1) -- temp masks for algorithms.
    // byte2 (TRIANGULATED_FACE, NULL_FACE) -- face properties.
})(HalfEdgeMask = exports.HalfEdgeMask || (exports.HalfEdgeMask = {}));


/***/ }),

/***/ "./lib/topology/HalfEdgeGraphSearch.js":
/*!*********************************************!*\
  !*** ./lib/topology/HalfEdgeGraphSearch.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const Graph_1 = __webpack_require__(/*! ./Graph */ "./lib/topology/Graph.js");
const XYParitySearchContext_1 = __webpack_require__(/*! ./XYParitySearchContext */ "./lib/topology/XYParitySearchContext.js");
const SignedDataSummary_1 = __webpack_require__(/*! ./SignedDataSummary */ "./lib/topology/SignedDataSummary.js");
/**
 */
class HalfEdgeMaskTester {
    /**
     *
     * @param mask mask to test in `testEdge` function
     * @param targetValue value to match for true return
     */
    constructor(mask, targetValue = true) {
        this._targetMask = mask;
        this._targetValue = targetValue;
    }
    /** Return true if the value of the targetMask matches the targetValue */
    testEdge(edge) {
        return edge.isMaskSet(this._targetMask) === this._targetValue;
    }
}
exports.HalfEdgeMaskTester = HalfEdgeMaskTester;
// Search services for HalfEdgeGraph
class HalfEdgeGraphSearch {
    /**
     * * for each node of face, set the mask push to allNodesStack
     * * push the faceSeed on onePerFaceStack[]
     */
    static pushAndMaskAllNodesInFace(faceSeed, mask, allNodeStack, onePerFaceStack) {
        onePerFaceStack.push(faceSeed);
        faceSeed.collectAroundFace((node) => {
            node.setMask(mask);
            allNodeStack.push(node);
        });
    }
    /**
     * Search an array of faceSeed nodes for the face with the most negative area.
     * @param oneCandidateNodePerFace array containing one node from each face to be considered.
     */
    static findMinimumAreaFace(oneCandidateNodePerFace) {
        const summary = HalfEdgeGraphSearch.collectFaceAreaSummary(oneCandidateNodePerFace);
        return summary.largestNegativeItem;
    }
    /**
     *
     * Return a summary structure data about face areas.
     */
    static collectFaceAreaSummary(source, collectAllNodes = false) {
        const result = new SignedDataSummary_1.SignedDataSummary(collectAllNodes);
        let allFaces;
        if (source instanceof Graph_1.HalfEdgeGraph)
            allFaces = source.collectFaceLoops();
        else
            allFaces = source;
        for (const node of allFaces) {
            const area = node.signedFaceArea();
            result.announceItem(node, area);
        }
        return result;
    }
    /**
     * Search to all accessible faces from given seed.
     * * The returned array contains one representative node in each face of the connected component.
     * * If (nonnull) parity mask is given, on return:
     *    * It is entirely set or entirely clear around each face
     *    * It is entirely set on all faces that are an even number of face-to-face steps away from the seed.
     *    * It is entirely clear on all faces that are an odd number of face-to-face steps away from the seed.
     * @param seedEdge first edge to search.
     * @param visitMask mask applied to all faces as visited.
     * @param parityMask mask to apply (a) to first face, (b) to faces with alternating parity during the search.
     */
    static parityFloodFromSeed(seedEdge, visitMask, parityEdgeTester, parityMask) {
        const faces = [];
        if (seedEdge.isMaskSet(visitMask))
            return faces; // empty
        const allMasks = parityMask | visitMask;
        const stack = [];
        // arbitrarily call the seed face exterior ... others will alternate as visited.
        HalfEdgeGraphSearch.pushAndMaskAllNodesInFace(seedEdge, allMasks, stack, faces); // Start with exterior as mask
        while (stack.length > 0) {
            const p = stack.pop();
            const mate = p.edgeMate;
            if (!mate)
                continue;
            if (!mate.isMaskSet(visitMask)) {
                let newState = p.isMaskSet(parityMask);
                if (!parityEdgeTester || parityEdgeTester.testEdge(p))
                    newState = !newState;
                HalfEdgeGraphSearch.pushAndMaskAllNodesInFace(mate, newState ? allMasks : visitMask, stack, faces);
            }
        }
        return faces;
    }
    /**
     * * Search the given faces for the one with the minimum area.
     * * If the mask in that face is OFF, toggle it on (all half edges of) all the faces.
     * * In a properly merged planar subdivision there should be only one true negative area face per component.
     * @param graph parent graph
     * @param parityMask mask which was previously set with alternating parity, but with an arbitrary start face.
     * @param faces array of faces to search.
     */
    static correctParityInSingleComponent(_graph, mask, faces) {
        const exteriorHalfEdge = HalfEdgeGraphSearch.findMinimumAreaFace(faces);
        if (exteriorHalfEdge.isMaskSet(mask)) {
            // all should be well .. nothing to do.
        }
        else {
            // TOGGLE around the face (assuming all are consistent with the seed)
            for (const faceSeed of faces) {
                if (faceSeed.isMaskSet(mask)) {
                    faceSeed.clearMaskAroundFace(mask);
                }
                else {
                    faceSeed.setMaskAroundFace(mask);
                }
            }
        }
    }
    /** Apply correctParityInSingleComponent to each array in components. (Quick exit if mask in NULL_MASK) */
    static correctParityInComponentArrays(graph, mask, components) {
        if (mask === Graph_1.HalfEdgeMask.NULL_MASK)
            return;
        for (const facesInComponent of components)
            HalfEdgeGraphSearch.correctParityInSingleComponent(graph, mask, facesInComponent);
    }
    /**
     * Collect arrays gathering faces by connected component.
     * @param graph graph to inspect
     * @param parityEdgeTester (optional) function to test of an edge is a parity change.
     * @param parityMask (optional, along with boundaryTestFunction) mask to apply indicating parity.  If this is Mask.NULL_MASK, there is no record of parity.
     */
    static collectConnectedComponentsWithExteriorParityMasks(graph, parityEdgeTester, parityMask = Graph_1.HalfEdgeMask.NULL_MASK) {
        const components = [];
        const visitMask = Graph_1.HalfEdgeMask.VISITED;
        const allMasks = parityMask | visitMask;
        graph.clearMask(allMasks);
        for (const faceSeed of graph.allHalfEdges) {
            if (!faceSeed.isMaskSet(Graph_1.HalfEdgeMask.VISITED)) {
                const newFaces = HalfEdgeGraphSearch.parityFloodFromSeed(faceSeed, visitMask, parityEdgeTester, parityMask);
                components.push(newFaces);
            }
        }
        HalfEdgeGraphSearch.correctParityInComponentArrays(graph, parityMask, components);
        return components;
    }
    /**
     * Test if (x,y) is inside (1), on an edge (0) or outside (-1) a face.
     * @param seedNode any node on the face loop
     * @param x x coordinate of test point.
     * @param y y coordinate of test point.
     */
    static pointInOrOnFaceXY(seedNode, x, y) {
        const context = new XYParitySearchContext_1.XYParitySearchContext(x, y);
        // walk around looking for an accepted node to start the search (seedNode is usually ok!)
        let nodeA = seedNode;
        let nodeB = seedNode.faceSuccessor;
        for (;; nodeA = nodeB) {
            if (context.tryStartEdge(nodeA.x, nodeA.y, nodeB.x, nodeB.y))
                break;
            if (nodeB === seedNode) {
                // umm.. the face is all on the x axis?
                return context.classifyCounts();
            }
            nodeB = nodeA.faceSuccessor;
        }
        // nodeB is the real start node for search ... emit ends of each edge around the face,
        //   stopping after emitting nodeB as an edge end.
        let node = nodeB.faceSuccessor;
        for (;;) {
            if (!context.advance(node.x, node.y)) {
                return context.classifyCounts();
            }
            if (node === nodeB)
                break;
            node = node.faceSuccessor;
        }
        return context.classifyCounts();
    }
}
exports.HalfEdgeGraphSearch = HalfEdgeGraphSearch;


/***/ }),

/***/ "./lib/topology/HalfEdgeMarkSet.js":
/*!*****************************************!*\
  !*** ./lib/topology/HalfEdgeMarkSet.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Graph_1 = __webpack_require__(/*! ./Graph */ "./lib/topology/Graph.js");
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Topology */
/**
 * A class to manage a set of edges as both (a) an array of possible members and (b) mask bits.
 * * A half edge is "in the MarkSet" if its mask is set.
 * * The MarkSet array is a superset of the half edges in the set.
 * * Entry of a HalfEdge into the set is indicated by both
 *    * adding the HalfEdge to the array
 *    * setting the mask on the half edge, edge, face, or vertex
 * * Half edges can "go out of the MarkSet" if the mask is cleared.
 *   * This clearing can happen independently of the array management.
 *   * Hence the array can contain half edges that are no longer in the MarkSet
 *   * the "remove" methods monitor this.
 * * Derived classes expand this concept for edge, vertex, or face MarkSets.
 *   * a single representative of an edge, vertex, or face is entered to the array
 *   * all edges around the edge, vertex, or face are marked with the mask
 *   * Hence the array contains one or more representatives of the edge, face, or vertex
 * * This allows quick query for both:
 *   * Testing the mask gives constant time test of whether a HalfEdge is in the set
 *   * access through the array gives direct access to the HalfEdge pointers
 * @internal
 */
class AbstractHalfEdgeGraphMarkSet {
    constructor(graph, mask) {
        this._graph = graph;
        this._candidates = [];
        this._mask = mask;
        this._graph.clearMask(mask);
    }
    /** remove all nodes from the set.
     * * This pops from the array, clearing masks as the pop.
     * * Note that it does NOT walk the entire graph to clear masks.
     */
    clear() {
        for (; undefined !== this.chooseAndRemoveAny();) {
        }
    }
    /**
     * count the number of active members.
     * * This is the number of HalfEdges which are (a) in the array and (b) masked.
     */
    getLength() {
        let n = 0;
        for (const candidate of this._candidates) {
            if (candidate.isMaskSet(this._mask))
                n++;
        }
        return n;
    }
    /**
     * Return the number of candidates.
     * * This may be more than `getLength ()`
     * * This will typically only be called by the iterator.
     */
    getNumCandidates() {
        return this._candidates.length;
    }
    /** Read property accessor: return the graph */
    get graph() { return this._graph; }
    /** return borrowed assets (the mask!) to the graph. */
    teardown() {
        this._graph.dropMask(this._mask);
        this._candidates.length = 0;
        // this._graph = undefined;
    }
    /** (Read property) return the mask used to mark members of the set. */
    get mask() { return this._mask; }
    /** pop and return the last node out of the array, without testing if it is still marked. */
    popAndReturn() {
        const n = this._candidates.length;
        if (n === 0)
            return undefined;
        const node = this._candidates[n - 1];
        this._candidates.pop();
        return node;
    }
    /**
     * * read at an index in the candidates array.
     * * if that candidate has the mask, return it.
     * * otherwise return undefined.
     * * REMARK: This is only to be called by the iterator.
     */
    getAtIndex(index) {
        if (index >= 0 && index < this._candidates.length) {
            const candidate = this._candidates[index];
            if (candidate.isMaskSet(this._mask))
                return candidate;
        }
        return undefined;
    }
    /** Add a node to the set.  This means
     * * Set the mask
     * * push the node on the array
     * * (BUT!) If the node already has the mask, do nothing.
     * * This base class method affects only the single given HalfEdge.
     * * Derived classes for edge, face, and vertex will override this method and also set the mask around the larger structures.
     * @returns true if the HalfEdge is a new member of the set, false if it was already in the set.
     */
    addToSet(candidate) {
        if (candidate.isMaskSet(this._mask))
            return false;
        this._candidates.push(candidate);
        this.setMaskInScope(candidate);
        return true;
    }
    /** Test if `candidate` is already in the set.
     * * This examines only the mask.
     */
    isCandidateInSet(candidate) {
        return candidate.isMaskSet(this._mask);
    }
    /**
     * * If the candidate is not marked as a member of the MarkSet, do nothing.
     * * If the candidate is marked:
     *   * clear the mask
     *   * but do NOT search the array.
     *   * As the array is searched, the candidate will appear and be ignored because the mask is not set.
     * @param candidate
     * @return true if the candidate was a member (an hence removed), false if the candidate was not masked.
     */
    removeFromSet(candidate) {
        if (!candidate.isMaskSet(this._mask))
            return false;
        this.clearMaskInScope(candidate);
        return true;
    }
    /**
     *  * Search the array to find any current set member
     *  * If found, clear its mask and return it.
     *  * If unmasked HalfEdges are found in the array, they are removed from the array.
     */
    chooseAndRemoveAny() {
        for (;;) {
            const candidate = this.popAndReturn();
            if (!candidate)
                return undefined;
            if (this.removeFromSet(candidate))
                return candidate;
        }
    }
    /** Create an iterator over member HalfEdges */
    [Symbol.iterator]() { return new IterableHalfEdgeMarkSetIterator(this); }
    /**
     * * visit all half edges around face.
     * * Add each to mark set.
     */
    addAroundFace(seed) {
        let p = seed;
        do {
            this.addToSet(p);
            p = p.faceSuccessor;
        } while (p !== seed);
    }
    /**
     * * visit all half edges around vertex.
     * * Add each to mark set.
     */
    addAroundVertex(seed) {
        let p = seed;
        do {
            this.addToSet(p);
            p = p.vertexSuccessor;
        } while (p !== seed);
    }
}
exports.AbstractHalfEdgeGraphMarkSet = AbstractHalfEdgeGraphMarkSet;
/**
 * AbstractHalfEdgeGraphMarkSet specialized to manage the masks on individual half edges
 * @internal
 */
class MarkedHalfEdgeSt extends AbstractHalfEdgeGraphMarkSet {
    constructor(graph, mask) {
        super(graph, mask);
    }
    /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.
     * * Returns undefined if unable to get a mask for the graph.
     * * Undefined return can only happen if the caller is failing to return grabbed masks.
     */
    static create(graph) {
        const mask = graph.grabMask();
        if (mask === Graph_1.HalfEdgeMask.NULL_MASK)
            return undefined;
        return new MarkedHalfEdgeSt(graph, mask);
    }
    /**
     * * Set mask on candidate's edge.
     * * This overrides the base class implementation.
     */
    setMaskInScope(candidate) {
        candidate.setMask(this._mask);
    }
    /**
     * * Clear mask on candidate's edge.
     * * This overrides the base class implementation.
     */
    clearMaskInScope(candidate) {
        candidate.clearMask(this._mask);
    }
    /**
     * Return the number of half edges that would be set/cleared when dealing with this candidate.
     * * This is always 1 for EdgeMarkSet
     * * return 0 for undefined candidate
     * @param candidate
     */
    countHalfEdgesAroundCandidate(candidate) {
        if (!candidate)
            return 0;
        return 1;
    }
}
exports.MarkedHalfEdgeSt = MarkedHalfEdgeSt;
/**
 * AbstractHalfEdgeGraphMarkSet specialized to manage the mask on both sides of edges.
 * @internal
 */
class MarkedEdgeSet extends AbstractHalfEdgeGraphMarkSet {
    constructor(graph, mask) {
        super(graph, mask);
    }
    /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.
     * * Returns undefined if unable to get a mask for the graph.
     * * Undefined return can only happen if the caller is failing to return grabbed masks.
     */
    static create(graph) {
        const mask = graph.grabMask();
        if (mask === Graph_1.HalfEdgeMask.NULL_MASK)
            return undefined;
        return new MarkedEdgeSet(graph, mask);
    }
    /**
     * * Set mask on candidate's edge.
     * * This overrides the base class implementation.
     */
    setMaskInScope(candidate) {
        candidate.setMaskAroundEdge(this._mask);
    }
    /**
     * * Clear mask on candidate's edge.
     * * This overrides the base class implementation.
     */
    clearMaskInScope(candidate) {
        candidate.clearMaskAroundEdge(this._mask);
    }
    /**
     * Return the number of half edges that would be set/cleared when dealing with this candidate.
     * * This is always 2 for EdgeMarkSet
     * @param candidate
     */
    countHalfEdgesAroundCandidate(candidate) {
        if (!candidate)
            return 0;
        return 2;
    }
}
exports.MarkedEdgeSet = MarkedEdgeSet;
/**
 * AbstractHalfEdgeGraphMarkSet specialized to manage the mask around faces
 * @internal
 */
class MarkedFaceSet extends AbstractHalfEdgeGraphMarkSet {
    constructor(graph, mask) {
        super(graph, mask);
    }
    /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.
     * * Returns undefined if unable to get a mask for the graph.
     * * Undefined return can only happen if the caller is failing to return grabbed masks.
     */
    static create(graph) {
        const mask = graph.grabMask();
        if (mask === Graph_1.HalfEdgeMask.NULL_MASK)
            return undefined;
        return new MarkedFaceSet(graph, mask);
    }
    /**
     * * Set mask on (all nodes around) candidate's face
     * * This overrides the base class implementation.
     */
    setMaskInScope(candidate) {
        candidate.setMaskAroundFace(this._mask);
    }
    /**
     * * Clear mask on (all nodes around) candidate's face.
     * * This overrides the base class implementation.
     */
    clearMaskInScope(candidate) {
        candidate.clearMaskAroundFace(this._mask);
    }
    /**
     * Return the number of half edges that would be set/cleared when dealing with this candidate.
     * * This is the "aroundFace" count.
     * @param candidate
     */
    countHalfEdgesAroundCandidate(candidate) {
        if (!candidate)
            return 0;
        return candidate.countEdgesAroundFace();
    }
}
exports.MarkedFaceSet = MarkedFaceSet;
/**
 * AbstractHalfEdgeGraphMarkSet specialized to manage the mask around faces
 * @internal
 */
class MarkedVertexSet extends AbstractHalfEdgeGraphMarkSet {
    constructor(graph, mask) {
        super(graph, mask);
    }
    /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.
     * * Returns undefined if unable to get a mask for the graph.
     * * Undefined return can only happen if the caller is failing to return grabbed masks.
     */
    static create(graph) {
        const mask = graph.grabMask();
        if (mask === Graph_1.HalfEdgeMask.NULL_MASK)
            return undefined;
        return new MarkedVertexSet(graph, mask);
    }
    /**
     * * Set mask on (all nodes around) candidate's face
     * * This overrides the base class implementation.
     */
    setMaskInScope(candidate) {
        candidate.setMaskAroundVertex(this._mask);
    }
    /**
     * * Clear mask on (all nodes around) candidate's face.
     * * This overrides the base class implementation.
     */
    clearMaskInScope(candidate) {
        candidate.clearMaskAroundVertex(this._mask);
    }
    /**
     * Return the number of half edges that would be set/cleared when dealing with this candidate.
     * * This is the "aroundVertex" count.
     * @param candidate
     */
    countHalfEdgesAroundCandidate(candidate) {
        if (!candidate)
            return 0;
        return candidate.countEdgesAroundVertex();
    }
}
exports.MarkedVertexSet = MarkedVertexSet;
/**
 * Class to act as an iterator over points in a markSet.
 * * Internal data is:
 *   * pointer to the parent markSet
 *   * index of index of the next point to read.
 * * the parent markSet class
 */
class IterableHalfEdgeMarkSetIterator {
    constructor(markSet) {
        this._markSet = markSet;
        this._nextReadIndex = 0;
    }
    next() {
        const n = this._markSet.getNumCandidates();
        // Walk over candidates that have been quietly de-masked
        while (this._nextReadIndex < n) {
            const p = this._markSet.getAtIndex(this._nextReadIndex++);
            if (p !== undefined)
                return { done: false, value: p };
        }
        return { done: true, value: undefined };
    }
    [Symbol.iterator]() { return this; }
}


/***/ }),

/***/ "./lib/topology/HalfEdgeNodeXYZUV.js":
/*!*******************************************!*\
  !*** ./lib/topology/HalfEdgeNodeXYZUV.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
/** @module Topology */
/**
 * Reference to a HalfEdge node with extra XYZ and UV data.
 * @internal
 */
class NodeXYZUV {
    constructor(node, x, y, z, u, v) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._u = u;
        this._v = v;
        this._node = node;
    }
    /** Set all content directly from args.
     * @returns `this` reference
     */
    set(node, x, y, z, u, v) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._u = u;
        this._v = v;
        this._node = node;
        return this;
    }
    setFrom(other) {
        this._x = other.x;
        this._y = other.y;
        this._z = other.z;
        this._u = other.u;
        this._v = other.v;
        this._node = other.node;
    }
    /** Create a `NodeXYZUV` with
     * * x,y,z at ray origin
     * * u,v as dotXY and crossXY for the ray direction with x,y distances from the ray origin.
     */
    static createNodeAndRayOrigin(node, ray, result) {
        const x = node.x;
        const y = node.y;
        const z = node.z;
        const dx = x - ray.origin.x;
        const dy = y - ray.origin.y;
        const u = Geometry_1.Geometry.dotProductXYXY(dx, dy, ray.direction.x, ray.direction.y);
        const v = Geometry_1.Geometry.crossProductXYXY(ray.direction.x, ray.direction.y, dx, dy);
        if (result)
            return result.set(node, x, y, z, u, v);
        return new NodeXYZUV(node, x, y, z, u, v);
    }
    /** Access the node. */
    get node() { return this._node; }
    /** Access the x coordinate */
    get x() { return this._x; }
    /** Access the y coordinate */
    get y() { return this._y; }
    /** Access the z coordinate */
    get z() { return this._z; }
    /** Access the u coordinate */
    get u() { return this._u; }
    /** Access the v coordinate */
    get v() { return this._v; }
    /** Access the x,y,z coordinates as Point3d with optional caller-supplied result. */
    getXYZAsPoint3d(result) {
        return Point3dVector3d_1.Point3d.create(this._x, this._y, this._z, result);
    }
    /** Access the uv coordinates as Point2d with optional caller-supplied result. */
    getUVAsPoint2d(result) { return Point2dVector2d_1.Point2d.create(this._u, this._v, result); }
    /** Toleranced comparison function for u coordinate */
    classifyU(target, tol) {
        const delta = this.u - target;
        if (Math.abs(delta) <= tol)
            return 0;
        return delta >= 0 ? 1 : -1;
    }
    /** Toleranced comparison function for v coordinate */
    classifyV(target, tol) {
        const delta = target - this._v;
        if (Math.abs(delta) <= tol)
            return 0;
        return delta >= 0 ? 1 : -1;
    }
}
exports.NodeXYZUV = NodeXYZUV;


/***/ }),

/***/ "./lib/topology/HalfEdgePointInGraphSearch.js":
/*!****************************************************!*\
  !*** ./lib/topology/HalfEdgePointInGraphSearch.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const HalfEdgePositionDetail_1 = __webpack_require__(/*! ./HalfEdgePositionDetail */ "./lib/topology/HalfEdgePositionDetail.js");
const HalfEdgeNodeXYZUV_1 = __webpack_require__(/*! ./HalfEdgeNodeXYZUV */ "./lib/topology/HalfEdgeNodeXYZUV.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
var RayClassification;
(function (RayClassification) {
    RayClassification[RayClassification["RC_NoHits"] = 0] = "RC_NoHits";
    RayClassification[RayClassification["RC_TargetOnVertex"] = 1] = "RC_TargetOnVertex";
    RayClassification[RayClassification["RC_TargetOnEdge"] = 2] = "RC_TargetOnEdge";
    RayClassification[RayClassification["RC_Bracket"] = 3] = "RC_Bracket";
    RayClassification[RayClassification["RC_TargetBefore"] = 4] = "RC_TargetBefore";
    RayClassification[RayClassification["RC_TargetAfter"] = 5] = "RC_TargetAfter";
})(RayClassification = exports.RayClassification || (exports.RayClassification = {}));
class PointSearchContext {
    constructor(tol) {
        this._tol = tol;
    }
    static create(tol = Geometry_1.Geometry.smallMetricDistance) {
        return new PointSearchContext(tol);
    }
    panic() {
        return HalfEdgePositionDetail_1.HalfEdgePositionDetail.create();
    }
    // From given edge start point
    // The edgeHit is reused as the result.
    reAimFromEdge(edgeHit, ray, targetDistance) {
        const nodeA = edgeHit.node;
        const dataA = HalfEdgeNodeXYZUV_1.NodeXYZUV.createNodeAndRayOrigin(nodeA, ray);
        const dataB = HalfEdgeNodeXYZUV_1.NodeXYZUV.createNodeAndRayOrigin(nodeA.edgeMate, ray);
        const sideA = -dataA.classifyV(0.0, this._tol);
        const sideB = -dataB.classifyV(0.0, this._tol);
        let result;
        if (sideA * sideB < 0) {
            // Simple crossing -- just aim into a face
            if (sideA > 0) {
                result = edgeHit.resetAsFace(dataA.node);
            }
            else {
                result = edgeHit.resetAsFace(dataB.node);
            }
        }
        else if (sideA === 0 || sideB === 0) {
            // The usual case is both 0 i.e. ray is clearly along the edge.
            const alongA = dataA.classifyU(targetDistance, this._tol);
            const alongB = dataB.classifyU(targetDistance, this._tol);
            if (alongA === 0 && sideA === 0) {
                result = edgeHit.resetAsVertex(dataA.node);
                result.setITag(1);
            }
            else if (alongB === 0 && sideB === 0) {
                result = edgeHit.resetAsVertex(dataB.node);
                result.setITag(1);
            }
            else if (alongA * alongB < 0) {
                // target is within edge
                // (.. This is written for the case where both sideA and sideB are zero.
                //    If only one is zero, this computes a close edge point but the strong "on" conclusion might be wrong)
                const edgeFraction = (targetDistance - dataA.u) / (dataB.u - dataA.u);
                result = edgeHit.resetAtEdgeAndFraction(dataA.node, edgeFraction);
                result.setITag(1);
            }
            else if (alongA < 0 && alongB < 0) {
                // target is beyond the edge -- move towards it.
                if (dataA.u > dataB.u)
                    result = edgeHit.resetAsVertex(dataA.node);
                else
                    result = edgeHit.resetAsVertex(dataB.node);
            }
            else {
                // This shouldn't happen -- maybe as if the initial edge point was not within the edge???
                if (Math.abs(dataA.u) < this._tol
                    && Math.abs(dataA.v) < this._tol) {
                    result = edgeHit.resetAsVertex(dataA.node); // , dataA);
                }
                else if (Math.abs(dataB.u) < this._tol
                    && Math.abs(dataB.v) < this._tol) {
                    result = edgeHit.resetAsVertex(dataB.node);
                }
                else {
                    edgeHit.resetAsUnknown();
                    result = this.panic();
                }
            }
        }
        else {
            // Both vertices are to same side of the line.   This can't happen for edge point between nodes.
            edgeHit.resetAsUnknown();
            result = this.panic();
        }
        return result;
    }
    // From given edge start point, pick vertex or edge side for proceeding along ray.
    // RAY IS ASSUMED TO START AT THE VERTEX PRECISELY !!!!
    reAimFromVertex(searchBase, ray, targetDistance) {
        const vertexNode = searchBase.node;
        let result;
        let outboundEdge = vertexNode;
        do {
            // DPoint3d xyzBase;
            // vu_getDPoint3d(& xyzBase, outboundEdge);
            const data0 = HalfEdgeNodeXYZUV_1.NodeXYZUV.createNodeAndRayOrigin(outboundEdge.faceSuccessor, ray);
            const data1 = HalfEdgeNodeXYZUV_1.NodeXYZUV.createNodeAndRayOrigin(outboundEdge.facePredecessor, ray);
            const u0 = data0.u;
            // double u1 = data1.GetU ();
            const v0 = data0.v;
            const v1 = data1.v;
            if (Math.abs(v0) < this._tol) {
                if (Math.abs(u0 - targetDistance) < this._tol) {
                    // Direct hit at far end
                    result = searchBase.resetAsVertex(data0.node);
                    result.setITag(1);
                    return result;
                }
                else if (u0 > targetDistance) {
                    // Direct hig within edge
                    const edgeFraction = targetDistance / u0;
                    result = searchBase.resetAtEdgeAndFraction(outboundEdge, edgeFraction);
                    return result;
                }
                else if (Math.abs(u0) <= this._tol) {
                    // Unexpected direct hit on the base of the search, but call it a hit....
                    result = searchBase.resetAsVertex(outboundEdge);
                    result.setITag(1);
                    return result;
                }
                else if (u0 > this._tol) {
                    // Advance to vertex  ...
                    // double edgeFraction = targetDistance / u0;
                    result = searchBase.resetAsVertex(data0.node);
                    return result;
                }
                else {
                    // Search direction is exactly opposite this edge.
                    // See if the other side of the sector is turned even beyond that ...
                    if (v1 > this._tol) {
                        result = searchBase.resetAsFace(outboundEdge, outboundEdge);
                        return result;
                    }
                }
            }
            else if (v0 < -this._tol) {
                if (v1 > this._tol) {
                    // The usual simple entry into an angle < 180
                    result = searchBase.resetAsFace(outboundEdge, outboundEdge);
                    return result;
                }
            }
            // NEEDS WORK: angle >= 180 cases !!!!
            outboundEdge = outboundEdge.vertexSuccessor;
        } while (outboundEdge !== vertexNode);
        return this.panic();
    }
    // Visit all edges around face.
    // reset lastBefore and firstAfter describing progress towards target distance on ray.
    reAimAroundFace(faceNode, ray, targetDistance, // !< distance to target point
    lastBefore, // CALLER CREATED -- reset as first hit on negative side of ray.
    firstAfter) {
        lastBefore.resetAsUndefinedWithTag(-Number.MAX_VALUE);
        firstAfter.resetAsUndefinedWithTag(Number.MAX_VALUE);
        const data0 = HalfEdgeNodeXYZUV_1.NodeXYZUV.createNodeAndRayOrigin(faceNode, ray);
        let data1;
        let node0 = faceNode;
        do {
            const node1 = node0.faceSuccessor;
            data1 = HalfEdgeNodeXYZUV_1.NodeXYZUV.createNodeAndRayOrigin(node1, ray, data1);
            const u0 = data0.u;
            const u1 = data1.u;
            const v0 = data0.v;
            const v1 = data1.v;
            if (Math.abs(v1) < this._tol) {
                // Vertex hit ...
                const vertexHit = HalfEdgePositionDetail_1.HalfEdgePositionDetail.createVertex(node1);
                vertexHit.setDTag(u1);
                if (Math.abs(u1 - targetDistance) < this._tol) {
                    firstAfter.setFrom(vertexHit);
                    lastBefore.setFrom(vertexHit);
                    return RayClassification.RC_TargetOnVertex;
                }
                if (u1 > targetDistance && u1 < firstAfter.getDTag())
                    firstAfter.setFrom(vertexHit);
                if (u1 < targetDistance && u1 > lastBefore.getDTag())
                    lastBefore.setFrom(vertexHit);
            }
            else if (v0 * v1 < 0.0) {
                // Edge Crossing ...
                const edgeFraction = -v0 / (v1 - v0);
                const uEdge = Geometry_1.Geometry.interpolate(u0, edgeFraction, u1);
                const edgeHit = HalfEdgePositionDetail_1.HalfEdgePositionDetail.createEdgeAtFraction(data0.node, edgeFraction);
                edgeHit.setDTag(uEdge);
                if (Math.abs(uEdge - targetDistance) <= this._tol) {
                    firstAfter.setFrom(edgeHit);
                    lastBefore.setFrom(edgeHit);
                    return RayClassification.RC_TargetOnEdge;
                }
                if (uEdge > targetDistance && uEdge < firstAfter.getDTag()) {
                    firstAfter.setFrom(edgeHit);
                    firstAfter.setITag(v0 > 0.0 ? -1 : 1);
                }
                if (uEdge < targetDistance && uEdge > lastBefore.getDTag()) {
                    lastBefore.setFrom(edgeHit);
                    lastBefore.setDTag(uEdge);
                }
            }
            data0.setFrom(data1);
            node0 = node0.faceSuccessor;
        } while (node0 !== faceNode);
        const afterTag = firstAfter.getITag();
        firstAfter.setITag(0);
        lastBefore.setITag(0);
        if (lastBefore.isUnclassified) {
            if (firstAfter.isUnclassified)
                return RayClassification.RC_NoHits;
            return RayClassification.RC_TargetBefore;
        }
        if (firstAfter.isUnclassified
            || (firstAfter.isEdge && afterTag && afterTag < 0)) {
            return RayClassification.RC_TargetAfter;
        }
        else {
            return RayClassification.RC_Bracket;
        }
    }
    // Return false if target is reached !!!!
    /**
     * Set (replace contents) ray with
     * * `origin` at start
     * * `direction` is unit vector from start towards target
     * * `a` is distance from start to target.
     * @param start existing position
     * @param target target xy coordinates
     * @param ray ray to update
     */
    setSearchRay(start, target, ray) {
        ray.origin.setFromPoint3d(start);
        Point3dVector3d_1.Vector3d.createStartEnd(ray.origin, target, ray.direction);
        ray.direction.z = 0.0;
        const distanceToTarget = ray.direction.magnitudeXY();
        ray.a = ray.direction.magnitude();
        ray.direction.scaleInPlace(1 / ray.a);
        return distanceToTarget >= this._tol;
    }
}
exports.PointSearchContext = PointSearchContext;


/***/ }),

/***/ "./lib/topology/HalfEdgePositionDetail.js":
/*!************************************************!*\
  !*** ./lib/topology/HalfEdgePositionDetail.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
/** @module Topology */
/**
 * Enumeration of categorization of "where" a HalfEdgePositionDetail is sitting in the graph.
 */
var HalfEdgeTopo;
(function (HalfEdgeTopo) {
    /** No known position */
    HalfEdgeTopo[HalfEdgeTopo["None"] = 0] = "None";
    /**  */
    HalfEdgeTopo[HalfEdgeTopo["Vertex"] = 1] = "Vertex";
    HalfEdgeTopo[HalfEdgeTopo["Edge"] = 2] = "Edge";
    HalfEdgeTopo[HalfEdgeTopo["Face"] = 3] = "Face";
})(HalfEdgeTopo = exports.HalfEdgeTopo || (exports.HalfEdgeTopo = {}));
/**
 * Description of a generalized position within a graph, categorized as:
 * * "at a certain node around a vertex"
 * * "at a fractional position along an edge
 * * "within a face"
 */
class HalfEdgePositionDetail {
    /** Constructor.
     * * The point is CAPTURED.  (static `create` methods normally clone their inputs.)
     */
    constructor(node, x, y, z, topo, edgeFraction, iTag, _dTag) {
        this._node = node;
        this.x = x;
        this.y = y;
        this.z = z;
        this._topo = topo;
        this._edgeFraction = edgeFraction;
        this._iTag = iTag;
        this._dTag = _dTag;
    }
    /** Copy (clones of) all data from other */
    setFrom(other) {
        this._node = other._node;
        this.x = other.x;
        this.y = other.y;
        this.z = other.z;
        this._topo = other._topo;
        this._edgeFraction = other._edgeFraction;
        this._iTag = other._iTag;
        this._dTag = other._dTag;
    }
    /** reset to null topo state. */
    resetAsUnknown() {
        this._node = undefined;
        this._topo = HalfEdgeTopo.None;
    }
    /**  Create with null data. */
    static create() {
        const detail = new HalfEdgePositionDetail(undefined, 0, 0, 0, HalfEdgeTopo.None);
        return detail;
    }
    getITag() { return this._iTag; }
    setITag(value) { this._iTag = value; }
    getDTag() { return this._dTag; }
    setDTag(value) { this._dTag = value; }
    getTopo() { return this._topo; }
    /** Create with node, fraction along edge, marked as "HalfEdgeTopo.Edge".  Compute interpolated xyz on the edge */
    static createEdgeAtFraction(node, edgeFraction) {
        const node1 = node.faceSuccessor;
        const x = Geometry_1.Geometry.interpolate(node.x, edgeFraction, node1.x);
        const y = Geometry_1.Geometry.interpolate(node.y, edgeFraction, node1.y);
        const z = Geometry_1.Geometry.interpolate(node.z, edgeFraction, node1.z);
        return new HalfEdgePositionDetail(node, x, y, z, HalfEdgeTopo.Edge, edgeFraction);
    }
    /** reassign contents so this instance becomes a face hit.
     * @param node new node value. If missing, current node is left unchanged.
     * @param xyz new coordinates. if missing, current coordinates are left unchanged.
     */
    resetAsFace(node, xyz) {
        this._topo = HalfEdgeTopo.Face;
        if (node)
            this._node = node;
        if (xyz) {
            this.x = xyz.x;
            this.y = xyz.y;
            this.z = xyz.z;
        }
        return this;
    }
    /** reassign contents so this instance has dTag but no node or HalfEdgeTopo
     */
    resetAsUndefinedWithTag(dTag) {
        this._topo = HalfEdgeTopo.None;
        this._dTag = 0;
        this._iTag = 0;
        this._dTag = dTag;
        this._node = undefined;
        return this;
    }
    /** reassign contents so this instance becomes an edge hit
     * @param node new node value.
     * @param edgeFraction new edge fraction.   xyz is recomputed from this edge and its face successor.
     */
    resetAtEdgeAndFraction(node, edgeFraction) {
        this._topo = HalfEdgeTopo.Edge;
        this._node = node;
        const nodeB = node.faceSuccessor;
        this._edgeFraction = edgeFraction;
        this.x = Geometry_1.Geometry.interpolate(node.x, edgeFraction, nodeB.x);
        this.y = Geometry_1.Geometry.interpolate(node.y, edgeFraction, nodeB.y);
        this.z = Geometry_1.Geometry.interpolate(node.z, edgeFraction, nodeB.z);
        return this;
    }
    /** Create at a node.
     * * Take xyz from the node.
     */
    static createVertex(node) {
        return new HalfEdgePositionDetail(node, node.x, node.y, node.z, HalfEdgeTopo.Vertex);
    }
    /** Create with node and (optional) xyz, marked as "HalfEdgeTopo.Vertex"
     * * if the xyz is omitted, take from the node.
     */
    resetAsVertex(node) {
        this._topo = HalfEdgeTopo.Vertex;
        this._node = node;
        this.setXYZFromNode(node);
        return this;
    }
    /** Copy x,y,z from the node to this instance local values. */
    setXYZFromNode(node) {
        this.x = node.x;
        this.y = node.y;
        this.z = node.z;
    }
    /**
     * Return the (possibly undefined) edge fraction.
     */
    get edgeFraction() {
        return this._edgeFraction;
    }
    /** Return true if this detail is marked as being within a face. */
    get isFace() { return this._topo === HalfEdgeTopo.Face; }
    /** Return true if this detail is marked as being within an edge. */
    get isEdge() { return this._topo === HalfEdgeTopo.Edge; }
    /** Return true if this detail is marked as being at a vertex. */
    get isVertex() { return this._topo === HalfEdgeTopo.Vertex; }
    /** Return true if this detail has no vertex, edge, or face qualifier. */
    get isUnclassified() { return this._topo === HalfEdgeTopo.None; }
    /** Return the node reference from this detail */
    get node() { return this._node; }
    /** Return the (clone of, or optional filled in result) coordinates from this detail. */
    clonePoint(result) { return Point3dVector3d_1.Point3d.create(this.x, this.y, this.z, result); }
    /*
      // If candidateKey is less than resultKey, replace resultPos and resultKey
      // by the candidate data.
      public updateMinimizer(
        HalfEdgePositionDetail & resultPos, number & resultKey,
    : HalfEdgePositionDetail & candidatePos, candidateKey: number
      ): boolean {
        if (candidateKey < resultKey) {
          resultKey = candidateKey;
          resultPos = candidatePos;
          return true;
        }
        return false;
      }
    */
    isAtXY(x, y) {
        return this._topo !== HalfEdgeTopo.None && Geometry_1.Geometry.isSameCoordinate(this.x, x) && Geometry_1.Geometry.isSameCoordinate(this.y, y);
    }
}
exports.HalfEdgePositionDetail = HalfEdgePositionDetail;


/***/ }),

/***/ "./lib/topology/HalfEdgePriorityQueue.js":
/*!***********************************************!*\
  !*** ./lib/topology/HalfEdgePriorityQueue.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const Merging_1 = __webpack_require__(/*! ./Merging */ "./lib/topology/Merging.js");
/**
 * * Combination of a priority queue of HalfEdges with
 * * Additional "active" array to carry edges that have been removed from the queue but are still to be
 *    inspected (possibly many times)
 * * The priority queue default sort is Y-then-X lexical sort.
 * * Caller has direct access to the queue and array.
 * * Methods are added here only to do things that involve both the queue and the array.
 * @internal
 */
class HalfEdgePriorityQueueWithPartnerArray {
    constructor(compare = Merging_1.HalfEdgeGraphOps.compareNodesYXUp) {
        this.priorityQueue = new bentleyjs_core_1.PriorityQueue(compare);
        this.activeEdges = [];
    }
    /** Read a member from the queue and transfer to the active array. */
    popQueueToArray() {
        if (this.priorityQueue.isEmpty)
            return undefined;
        const x = this.priorityQueue.pop();
        this.activeEdges.push(x);
        return x;
    }
    /** Pop the last entry and put it back as replacement for current entry at index i.
     * * Effectively remove active member at index i
     * * The array order is changed.
     * * constant time.
     */
    popArrayToArrayIndex(i) {
        const n = this.activeEdges.length;
        if (i < n) {
            const x = this.activeEdges.pop();
            this.activeEdges[i] = x;
        }
    }
    /**
     * * Scan the active array.
     * * remove edges whose top y is below y
     * * (pack all remaining ones back towards the beginning)
     */
    removeArrayMembersWithY1Below(y) {
        let numKeep = 0;
        const n = this.activeEdges.length;
        for (let i = 0; i < n; i++) {
            const q = this.activeEdges[i];
            const yB = q.faceSuccessor.y;
            if (yB >= y) {
                // copy [i] forward to [target]
                if (numKeep < i)
                    this.activeEdges[numKeep] = q;
                numKeep++;
            }
            else {
                // let it go by !!!
            }
        }
        this.activeEdges.length = numKeep;
    }
}
exports.HalfEdgePriorityQueueWithPartnerArray = HalfEdgePriorityQueueWithPartnerArray;


/***/ }),

/***/ "./lib/topology/InsertAndRetriangulateContext.js":
/*!*******************************************************!*\
  !*** ./lib/topology/InsertAndRetriangulateContext.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Graph_1 = __webpack_require__(/*! ./Graph */ "./lib/topology/Graph.js");
const HalfEdgePositionDetail_1 = __webpack_require__(/*! ./HalfEdgePositionDetail */ "./lib/topology/HalfEdgePositionDetail.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const HalfEdgePointInGraphSearch_1 = __webpack_require__(/*! ./HalfEdgePointInGraphSearch */ "./lib/topology/HalfEdgePointInGraphSearch.js");
const Ray3d_1 = __webpack_require__(/*! ../geometry3d/Ray3d */ "./lib/geometry3d/Ray3d.js");
const HalfEdgeMarkSet_1 = __webpack_require__(/*! ./HalfEdgeMarkSet */ "./lib/topology/HalfEdgeMarkSet.js");
const Triangulation_1 = __webpack_require__(/*! ./Triangulation */ "./lib/topology/Triangulation.js");
/** @module Topology */
/**
 * Context for repeated insertion of new points in a graph.
 * * Initial graph should have clean outer boundary. (e.g. as typically marked with HalfEdgeMask.EXTERIOR)
 * * After each insertion, the current "position" within the graph is remembered so that each subsequent insertion
 *     can reuse that position as start for walking to the new point.
 */
class InsertAndRetriangulateContext {
    // Temporaries used in reAimFromFace
    // private _lastBefore: HalfEdgePositionDetail;
    // private _firstAfter: HalfEdgePositionDetail;
    constructor(graph) {
        this._graph = graph;
        this._edgeSet = HalfEdgeMarkSet_1.MarkedEdgeSet.create(graph);
        this._searcher = HalfEdgePositionDetail_1.HalfEdgePositionDetail.create();
        // this._lastBefore = HalfEdgePositionDetail.create();
        // this._firstAfter = HalfEdgePositionDetail.create();
    }
    /** Create a new context referencing the graph. */
    static create(graph) {
        return new InsertAndRetriangulateContext(graph);
    }
    /** Query the (pointer to) the graph in the context. */
    get graph() { return this._graph; }
    // Walk face from edgeNode;  insert new edges back to start node from all except
    //   immediate successor and predecessor.
    // insert all new nodes, and nodes of the existing face, in edgeSet.
    retriangulateFromBaseVertex(centralNode) {
        const numNode = centralNode.countEdgesAroundFace();
        this._edgeSet.addAroundFace(centralNode);
        if (numNode < 4 || centralNode.signedFaceArea() <= 0.0)
            return;
        const numEdge = numNode - 3;
        let farNode = centralNode.faceSuccessor;
        let nearNode = centralNode;
        for (let i = 0; i < numEdge; i++) {
            farNode = farNode.faceSuccessor;
            nearNode = this._graph.createEdgeHalfEdgeHalfEdge(nearNode, 0, farNode, 0);
            farNode = nearNode.faceSuccessor;
            this._edgeSet.addToSet(nearNode);
        }
    }
    /** Reset the "current" position to unknown state. */
    reset() {
        this._searcher = HalfEdgePositionDetail_1.HalfEdgePositionDetail.create();
    }
    /** Return a (reference to!) the current position in the graph */
    get currentPosition() { return this._searcher; }
    /**
     * Linear search through the graph
     * * Returns a HalfEdgePositionDetail for the nearest edge or vertex.
     * @param xyz
     */
    searchForNearestEdgeOrVertex(xyz) {
        const position = HalfEdgePositionDetail_1.HalfEdgePositionDetail.create();
        position.setDTag(Number.MAX_VALUE);
        const xyzC = Point3dVector3d_1.Point3d.create();
        let fractionC;
        let distanceC;
        for (const nodeA of this._graph.allHalfEdges) {
            const nodeB = nodeA.faceSuccessor;
            fractionC = Polynomials_1.SmallSystem.lineSegment3dXYClosestPointUnbounded(nodeA, nodeB, xyz);
            if (fractionC !== undefined) {
                if (fractionC > 1.0) {
                    distanceC = xyz.distanceXY(nodeB);
                    if (distanceC < position.getDTag()) {
                        position.resetAsVertex(nodeB);
                        position.setDTag(distanceC);
                    }
                }
                else if (fractionC < 0.0) {
                    distanceC = xyz.distanceXY(nodeA);
                    if (distanceC < position.getDTag()) {
                        position.resetAsVertex(nodeA);
                        position.setDTag(distanceC);
                    }
                }
                else {
                    nodeA.fractionToPoint3d(fractionC, xyzC);
                    distanceC = xyz.distanceXY(xyzC);
                    if (distanceC < position.getDTag()) {
                        position.resetAtEdgeAndFraction(nodeA, fractionC);
                    }
                }
            }
        }
        return position;
    }
    searchForNearestVertex(xyz) {
        const position = HalfEdgePositionDetail_1.HalfEdgePositionDetail.create();
        position.setDTag(Number.MAX_VALUE);
        let distanceA;
        for (const nodeA of this._graph.allHalfEdges) {
            distanceA = xyz.distanceXY(nodeA);
            if (distanceA < position.getDTag()) {
                position.resetAsVertex(nodeA);
                position.setDTag(distanceA);
            }
        }
        return position;
    }
    resetSearch(xyz, maxDim) {
        if (maxDim > 0)
            this._searcher = this.searchForNearestEdgeOrVertex(xyz);
        else
            this._searcher = this.searchForNearestVertex(xyz);
    }
    insertAndRetriangulate(xyz, newZWins) {
        this.moveToPoint(this._searcher, xyz);
        const seedNode = this._searcher.node;
        let stat = false;
        if (seedNode === undefined) {
        }
        else if (this._searcher.isFace) {
            if (!seedNode.isMaskSet(Graph_1.HalfEdgeMask.EXTERIOR)) {
                const newInteriorNode = this._graph.createEdgeXYZHalfEdge(xyz.x, xyz.y, xyz.z, 0, seedNode, 0);
                this.retriangulateFromBaseVertex(newInteriorNode);
                Triangulation_1.Triangulator.flipTrianglesInEdgeSet(this._graph, this._edgeSet);
                this._searcher.resetAsVertex(newInteriorNode);
            }
            stat = true;
        }
        else if (this._searcher.isEdge) {
            const newA = this._graph.splitEdgeAtFraction(seedNode, this._searcher.edgeFraction);
            const newB = newA.vertexPredecessor;
            this.retriangulateFromBaseVertex(newA);
            this.retriangulateFromBaseVertex(newB);
            Triangulation_1.Triangulator.flipTrianglesInEdgeSet(this._graph, this._edgeSet);
            this._searcher.resetAsVertex(newA);
            stat = true;
        }
        else if (this._searcher.isVertex) {
            // There's already a vertex there.  Maybe the z is different.
            if (newZWins)
                seedNode.setXYZAroundVertex(xyz.x, xyz.y, xyz.z);
            stat = true;
        }
        else {
            stat = false;
        }
        return stat;
    }
    // Advance movingPosition to a face, edge, or vertex position detail that contains xyz.
    // Prior content in movingPosition is used as seed.
    // Return true if successful.
    moveToPoint(movingPosition, xyz, announcer) {
        const psc = HalfEdgePointInGraphSearch_1.PointSearchContext.create();
        movingPosition.setITag(0);
        if (movingPosition.isUnclassified) {
            moveToAnyUnmaskedEdge(this.graph, movingPosition, 0.5, 0);
            if (movingPosition.isUnclassified)
                return false;
        }
        // double tol = vu_getMergeTol (pGraph);
        const ray = Ray3d_1.Ray3d.createXAxis();
        for (; movingPosition.getITag() === 0;) {
            if (announcer !== undefined) {
                const continueSearch = announcer(movingPosition);
                if (!continueSearch)
                    break;
            }
            if (!psc.setSearchRay(movingPosition, xyz, ray)) {
                return false;
            }
            else if (movingPosition.isFace) {
                const lastBefore = HalfEdgePositionDetail_1.HalfEdgePositionDetail.create();
                const firstAfter = HalfEdgePositionDetail_1.HalfEdgePositionDetail.create();
                const rc = psc.reAimAroundFace(movingPosition.node, ray, ray.a, lastBefore, firstAfter);
                // reAimAroundFace returns lots of cases in `lastBefore` !!
                switch (rc) {
                    case HalfEdgePointInGraphSearch_1.RayClassification.RC_NoHits: {
                        movingPosition.resetAsUnknown();
                        break;
                    }
                    case HalfEdgePointInGraphSearch_1.RayClassification.RC_TargetOnVertex: {
                        movingPosition.setFrom(lastBefore);
                        movingPosition.setITag(1);
                        break;
                    }
                    case HalfEdgePointInGraphSearch_1.RayClassification.RC_TargetOnEdge: {
                        movingPosition.setFrom(lastBefore);
                        movingPosition.setITag(1);
                        break;
                    }
                    case HalfEdgePointInGraphSearch_1.RayClassification.RC_Bracket: {
                        movingPosition.resetAsFace(lastBefore.node, xyz);
                        movingPosition.setITag(1);
                        break;
                    }
                    case HalfEdgePointInGraphSearch_1.RayClassification.RC_TargetBefore: {
                        movingPosition.resetAsFace(movingPosition.node, xyz);
                        movingPosition.setITag(1);
                        break;
                    }
                    case HalfEdgePointInGraphSearch_1.RayClassification.RC_TargetAfter: {
                        movingPosition.setFrom(lastBefore);
                        break;
                    }
                }
            }
            else if (movingPosition.isEdge) {
                psc.reAimFromEdge(movingPosition, ray, ray.a);
                if (movingPosition.isUnclassified)
                    break;
            }
            else if (movingPosition.isVertex) {
                psc.reAimFromVertex(movingPosition, ray, ray.a);
                if (movingPosition.isUnclassified)
                    break;
            }
        }
        return movingPosition.isAtXY(xyz.x, xyz.y);
    }
}
exports.InsertAndRetriangulateContext = InsertAndRetriangulateContext;
// Create a VuPositionDetail for specified fraction along any unmasked edge.
function moveToAnyUnmaskedEdge(graph, position, edgeFraction, skipMask) {
    for (const candidate of graph.allHalfEdges) {
        if (!candidate.isMaskSet(skipMask)) {
            position.resetAtEdgeAndFraction(candidate, edgeFraction);
            return true;
        }
    }
    return false;
}


/***/ }),

/***/ "./lib/topology/MaskManager.js":
/*!*************************************!*\
  !*** ./lib/topology/MaskManager.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
/**
 * Methods to "grab and drop" mask bits.
 * * Caller code (e.g. HalfEdgeGraph) initializes with a block of bits to be managed.
 * * Callers borrow and return masks with "grabMask" and "dropMask"
 * * Callers must exercise grab/drop balance discipline.
 * @internal
 */
class MaskManager {
    /**
     * @param freeMasks caller-defined block of bits that are to be managed.
     */
    constructor(freeMasks, firstFreeMask) {
        this._originalFreeMasks = freeMasks;
        this._freeMasks = freeMasks;
        this._firstFreeMask = firstFreeMask;
    }
    /** Create a MaskManager.
     * Typical use:   MaskManager.create (0xFFFF0000)
     * * This makes bits 16 through 31 available to be borrowed, with lower bits available for fixed usage.
     */
    static create(freeMasks) {
        // look for first bit up to bit 31
        let firstFree = 0;
        let testBit = 0x01;
        for (let i = 0; i < 32; i++) {
            if ((testBit & freeMasks) !== 0) {
                firstFree = testBit;
                break;
            }
            testBit = (testBit << 1);
        }
        if (firstFree === 0)
            return undefined;
        return new MaskManager(freeMasks, firstFree);
    }
    /**
     * Find a mask bit that is not "in use".
     */
    grabMask() {
        let mask = this._firstFreeMask;
        if (this._freeMasks === 0)
            return 0;
        while (!(mask & this._freeMasks))
            mask = mask << 1;
        this._freeMasks &= ~mask;
        return mask;
    }
    /**
     * Find a mask bit that is not "in use".
     */
    dropMask(mask) {
        mask &= this._originalFreeMasks; // prevent "drop" of mask not in the pool.
        this._freeMasks |= mask;
    }
}
exports.MaskManager = MaskManager;


/***/ }),

/***/ "./lib/topology/Merging.js":
/*!*********************************!*\
  !*** ./lib/topology/Merging.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const Graph_1 = __webpack_require__(/*! ./Graph */ "./lib/topology/Graph.js");
const ClusterableArray_1 = __webpack_require__(/*! ../numerics/ClusterableArray */ "./lib/numerics/ClusterableArray.js");
const Range_1 = __webpack_require__(/*! ../geometry3d/Range */ "./lib/geometry3d/Range.js");
const HalfEdgePriorityQueue_1 = __webpack_require__(/*! ./HalfEdgePriorityQueue */ "./lib/topology/HalfEdgePriorityQueue.js");
const Polynomials_1 = __webpack_require__(/*! ../numerics/Polynomials */ "./lib/numerics/Polynomials.js");
const Point2dVector2d_1 = __webpack_require__(/*! ../geometry3d/Point2dVector2d */ "./lib/geometry3d/Point2dVector2d.js");
const Angle_1 = __webpack_require__(/*! ../geometry3d/Angle */ "./lib/geometry3d/Angle.js");
const Triangulation_1 = __webpack_require__(/*! ./Triangulation */ "./lib/topology/Triangulation.js");
const RegularizeFace_1 = __webpack_require__(/*! ./RegularizeFace */ "./lib/topology/RegularizeFace.js");
class GraphSplitData {
    constructor() {
        this.numUpEdge = 0;
        this.numIntersectionTest = 0;
        this.numSplit = 0;
        this.numPopOut = 0;
        this.numA0B0 = 0;
        this.numA0B1 = 0;
    }
}
exports.GraphSplitData = GraphSplitData;
/**
 * * Assorted methods used in algorithms on HalfEdgeGraph.
 * @internal
 */
class HalfEdgeGraphOps {
    /** Compare function for sorting with primary y compare, secondary  x compare. */
    static compareNodesYXUp(a, b) {
        // Check y's
        // if (!Geometry.isSameCoordinate(a.y, b.y))
        if (a.y < b.y)
            return -1;
        else if (a.y > b.y)
            return 1;
        // Check x's
        // if (!Geometry.isSameCoordinate(a.x, b.x))
        if (a.x < b.x)
            return -1;
        else if (a.x > b.x)
            return 1;
        return 0;
    }
    /** Return true if nodeB (a) is lower than both its neighbors and (b) inflects as a downward peak (rather than an upward trough) */
    static isDownPeak(nodeB) {
        const nodeA = nodeB.facePredecessor;
        const nodeC = nodeB.faceSuccessor;
        return this.compareNodesYXUp(nodeB, nodeA) < 0
            && this.compareNodesYXUp(nodeB, nodeC) < 0
            && this.crossProductToTargets(nodeB, nodeA, nodeC) > 0;
    }
    /** return the cross product of vectors from base to targetA and base to targetB
     * @param base base vertex of both vectors.
     * @param targetA target vertex of first vector
     * @param targetB target vertex of second vector
     */
    static crossProductToTargets(base, targetA, targetB) {
        return Geometry_1.Geometry.crossProductXYXY(targetA.x - base.x, targetA.y - base.y, targetB.x - base.x, targetB.y - base.y);
    }
    // ---------------------------------------------------------------------------------------------------------------------
    // ----------------------------------------------------------------------------------------------------------------------
    static graphRange(graph) {
        const range = Range_1.Range3d.create();
        for (const node of graph.allHalfEdges) {
            range.extendXYZ(node.x, node.y, node.z);
        }
        return range;
    }
    /** Returns an array of a all nodes (both ends) of edges created from segments. */
    static segmentArrayToGraphEdges(segments, returnGraph, mask) {
        const result = [];
        let idxCounter = 0;
        // Push the endpoints of each segment onto arr[] in the form {(x, y, theta), Node}
        for (const segment of segments) {
            const node0 = returnGraph.createEdgeXYZXYZ(segment.point0Ref.x, segment.point0Ref.y, segment.point0Ref.z, idxCounter, segment.point1Ref.x, segment.point1Ref.y, segment.point1Ref.z, idxCounter + 1);
            const node1 = node0.edgeMate;
            idxCounter += 2;
            node0.setMaskAroundFace(mask); // Original given coordinates must be part of boundary
            result.push(node0);
            result.push(node1);
        }
        return result;
    }
    /**
     * * For each face with positive area . . . add edges as needed so that each face has one definitely lower node and one definite upper node.
     * * Hence tracing edges from the low node, there is a sequence of upward edges, reaching the upper,  then a sequence of downward edges reaching the low node.
     * * This is an essential step for subsequent triangulation.
     *
     * @param graph
     */
    static formMonotoneFaces(graph) {
        const allFaces = graph.collectFaceLoops();
        graph.clearMask(Graph_1.HalfEdgeMask.VISITED);
        // For every face, break the face down into monotone sections
        for (const node of allFaces) {
            if (node.isMaskSet(Graph_1.HalfEdgeMask.VISITED))
                continue;
            const area = node.signedFaceArea();
            if (area <= 0.0) {
                node.setMaskAroundFace(Graph_1.HalfEdgeMask.VISITED);
                continue;
            }
        }
    }
    /**
     * * Visit all nodes in `graph`.
     * * invoke `pinch(node, vertexPredecessor)`
     * * this leaves the graph as isolated edges.
     * @param graph graph to modify
     */
    static isolateAllEdges(graph) {
        for (const nodeA of graph.allHalfEdges) {
            const nodeB = nodeA.vertexPredecessor;
            Graph_1.HalfEdge.pinch(nodeA, nodeB);
        }
    }
}
exports.HalfEdgeGraphOps = HalfEdgeGraphOps;
/**
 * @internal
 */
class HalfEdgeGraphMerge {
    /** Simplest merge algorithm:
     * * collect array of (x,y,theta) at all nodes
     * * lexical sort of the array.
     * * twist all vertices together.
     * * This effectively creates valid face loops for a planar subdivision if there are no edge crossings.
     * * If there are edge crossings, the graph can be a (highly complicated) Klein bottle topology.
     * * Mask.NULL_FACE is cleared throughout and applied within null faces.
     */
    static clusterAndMergeXYTheta(graph) {
        const allNodes = graph.allHalfEdges;
        const numNodes = allNodes.length;
        graph.clearMask(Graph_1.HalfEdgeMask.NULL_FACE);
        const clusters = new ClusterableArray_1.ClusterableArray(2, 2, numNodes); // data order: x,y,theta, nodeIndex.  But theta is not set in first round.
        for (let i = 0; i < numNodes; i++) {
            const nodeA = allNodes[i];
            const xA = nodeA.x;
            const yA = nodeA.y;
            Graph_1.HalfEdge.pinch(nodeA, nodeA.vertexSuccessor); // pull it out of its current vertex loop.
            clusters.addDirect(xA, yA, 0.0, i);
        }
        const order = clusters.clusterIndicesLexical();
        let k0 = 0;
        const numK = order.length;
        for (let k1 = 0; k1 < numK; k1++) {
            if (order[k1] === ClusterableArray_1.ClusterableArray.clusterTerminator) {
                // nodes identified in order[k0]..order[k1] are properly sorted around a vertex.
                if (k1 > k0) {
                    const iA = clusters.getExtraData(order[k0], 1);
                    const nodeA0 = allNodes[iA];
                    for (let k = k0 + 1; k < k1; k++) {
                        const iB = clusters.getExtraData(order[k], 1);
                        const nodeB = allNodes[iB];
                        nodeB.x = nodeA0.x;
                        nodeB.y = nodeA0.y;
                    }
                }
                k0 = k1 + 1;
            }
        }
        // NOW
        //  1) There are identical coordinates at all nodes around each vertex loop.
        //  2) Hence ready do sort (at each vertex) by theta.
        // insert theta as extra data in the sort table . . .
        for (const clusterTableIndex of order) {
            if (clusterTableIndex !== ClusterableArray_1.ClusterableArray.clusterTerminator) {
                const nodeA = allNodes[clusterTableIndex];
                const nodeB = nodeA.faceSuccessor;
                let radians = Math.atan2(nodeB.y - nodeA.y, nodeB.x - nodeA.x);
                if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(radians, -Math.PI))
                    radians = Math.PI;
                clusters.setExtraData(clusterTableIndex, 0, radians);
            }
        }
        clusters.sortSubsetsBySingleKey(order, 2);
        const unmatchedNullFaceNodes = [];
        k0 = 0;
        let thetaA, thetaB;
        // now pinch each neighboring pair together
        for (let k1 = 0; k1 < numK; k1++) {
            if (order[k1] === ClusterableArray_1.ClusterableArray.clusterTerminator) {
                // nodes identified in order[k0]..order[k1] are properly sorted around a vertex.
                if (k1 > k0) {
                    const iA = clusters.getExtraData(order[k0], 1);
                    thetaA = clusters.getExtraData(order[k0], 0);
                    const nodeA0 = allNodes[iA];
                    let nodeA = nodeA0;
                    for (let k = k0 + 1; k < k1; k++) {
                        const iB = clusters.getExtraData(order[k], 1);
                        thetaB = clusters.getExtraData(order[k], 0);
                        const nodeB = allNodes[iB];
                        if (nodeA.isMaskSet(Graph_1.HalfEdgeMask.NULL_FACE)) {
                            // nope, this edge was flagged and pinched from the other end.
                            const j = unmatchedNullFaceNodes.findIndex((node) => nodeA === node);
                            if (j >= 0) {
                                unmatchedNullFaceNodes[j] = unmatchedNullFaceNodes[unmatchedNullFaceNodes.length - 1];
                                unmatchedNullFaceNodes.pop();
                            }
                            nodeA = nodeB;
                            thetaA = thetaB;
                        }
                        else if (nodeB.isMaskSet(Graph_1.HalfEdgeMask.NULL_FACE)) {
                            const j = unmatchedNullFaceNodes.findIndex((node) => nodeA === node);
                            if (j >= 0) {
                                unmatchedNullFaceNodes[j] = unmatchedNullFaceNodes[unmatchedNullFaceNodes.length - 1];
                                unmatchedNullFaceNodes.pop();
                            }
                            // NO leave nodeA and thetaA   ignore nodeB -- later step will get the outside of its banana.
                        }
                        else {
                            Graph_1.HalfEdge.pinch(nodeA, nodeB);
                            if (Angle_1.Angle.isAlmostEqualRadiansAllowPeriodShift(thetaA, thetaB)) {
                                const nodeA1 = nodeA.faceSuccessor;
                                const nodeB1 = nodeB.edgeMate;
                                // WE TRUST -- nodeA1 and node B1 must have identical xy.
                                // pinch them together and mark the face loop as null ..
                                Graph_1.HalfEdge.pinch(nodeA1, nodeB1);
                                nodeA.setMask(Graph_1.HalfEdgeMask.NULL_FACE);
                                nodeB1.setMask(Graph_1.HalfEdgeMask.NULL_FACE);
                                unmatchedNullFaceNodes.push(nodeB1);
                            }
                            nodeA = nodeB;
                            thetaA = thetaB;
                        }
                    }
                }
                k0 = k1 + 1;
            }
        }
    }
    static buildVerticalSweepPriorityQueue(graph) {
        const sweepHeap = new HalfEdgePriorityQueue_1.HalfEdgePriorityQueueWithPartnerArray();
        for (const p of graph.allHalfEdges) {
            if (HalfEdgeGraphOps.compareNodesYXUp(p, p.faceSuccessor) < 0) {
                sweepHeap.priorityQueue.push(p);
            }
        }
        return sweepHeap;
    }
    static computeIntersectionFractionsOnEdges(nodeA0, nodeB0, fractions, pointA, pointB) {
        const nodeA1 = nodeA0.faceSuccessor;
        const ax0 = nodeA0.x;
        const ay0 = nodeA0.y;
        const ux = nodeA1.x - ax0;
        const uy = nodeA1.y - ay0;
        const nodeB1 = nodeB0.faceSuccessor;
        const bx0 = nodeB0.x;
        const by0 = nodeB0.y;
        const vx = nodeB1.x - bx0;
        const vy = nodeB1.y - by0;
        if (Polynomials_1.SmallSystem.lineSegmentXYUVTransverseIntersectionUnbounded(ax0, ay0, ux, uy, bx0, by0, vx, vy, fractions)) {
            pointA.x = ax0 + fractions.x * ux;
            pointA.y = ay0 + fractions.x * uy;
            pointB.x = bx0 + fractions.y * vx;
            pointB.y = by0 + fractions.y * vy;
            return Geometry_1.Geometry.isIn01(fractions.x) && Geometry_1.Geometry.isIn01(fractions.y);
        }
        return false;
    }
    /**
     * Split edges at intersections.
     * * This is a large operation.
     * @param graph
     */
    static splitIntersectingEdges(graph) {
        const data = new GraphSplitData();
        const sweepHeap = this.buildVerticalSweepPriorityQueue(graph);
        let nodeA0, nodeB1;
        const smallFraction = 1.0e-8;
        const largeFraction = 1.0 - smallFraction;
        let i;
        const fractions = Point2dVector2d_1.Vector2d.create();
        const pointA = Point2dVector2d_1.Point2d.create();
        const pointB = Point2dVector2d_1.Point2d.create();
        let nodeB0;
        while (undefined !== (nodeA0 = sweepHeap.priorityQueue.pop())) {
            data.numUpEdge++;
            const n0 = sweepHeap.activeEdges.length;
            sweepHeap.removeArrayMembersWithY1Below(nodeA0.y);
            data.numPopOut += n0 - sweepHeap.activeEdges.length;
            for (i = 0; i < sweepHeap.activeEdges.length; i++) {
                nodeB0 = sweepHeap.activeEdges[i];
                nodeB1 = nodeB0.faceSuccessor;
                // const nodeB1 = nodeB0.faceSuccessor;
                if (Geometry_1.Geometry.isSameCoordinateXY(nodeA0.x, nodeA0.y, nodeB0.x, nodeB0.y)) {
                    data.numA0B0++;
                }
                else if (Geometry_1.Geometry.isSameCoordinateXY(nodeB1.x, nodeB1.y, nodeA0.x, nodeA0.y)) {
                    data.numA0B1++;
                }
                else {
                    data.numIntersectionTest++;
                    if (this.computeIntersectionFractionsOnEdges(nodeA0, nodeB0, fractions, pointA, pointB)) {
                        if (fractions.x > smallFraction && fractions.x < largeFraction) {
                            const nodeC0 = graph.splitEdgeAtFraction(nodeA0, fractions.x);
                            sweepHeap.priorityQueue.push(nodeC0); // The upper portion will be reviewed as a nodeA0 later !!!
                            data.numSplit++;
                        }
                        if (fractions.y > smallFraction && fractions.y < largeFraction) {
                            const nodeD0 = graph.splitEdgeAtFraction(nodeB0, fractions.y);
                            sweepHeap.priorityQueue.push(nodeD0); // The upper portion will be reviewed as a nodeA0 later !!!
                            data.numSplit++;
                        }
                        // existing nodeA0 and its shortened edge remain for further intersections
                    }
                }
            }
            sweepHeap.activeEdges.push(nodeA0);
        }
        return data;
    }
    /**
     * Returns a graph structure formed from the given LineSegment array
     *
     * *  Find all intersections among segments, and split them if necessary
     * *  Record endpoints of every segment in the form X, Y, Theta; This information is stored as a new node and sorted to match up
     *      vertices.
     * *  For vertices that match up, pinch the nodes to create vertex loops, which in closed objects, will also eventually form face
     *      loops
     */
    static formGraphFromSegments(lineSegments) {
        // Structure of an index of the array: { xyTheta: Point3d, node: Node }
        const graph = new Graph_1.HalfEdgeGraph();
        HalfEdgeGraphOps.segmentArrayToGraphEdges(lineSegments, graph, Graph_1.HalfEdgeMask.BOUNDARY_EDGE);
        this.splitIntersectingEdges(graph);
        this.clusterAndMergeXYTheta(graph);
        return graph;
    }
    /**
     * * Input is random linestrings, not necessarily loops
     * * Graph gets full splitEdges, regularize, and triangulate.
     * @returns triangulated graph, or undefined if bad data.
     */
    static formGraphFromChains(chains, regularize = true, mask = Graph_1.HalfEdgeMask.PRIMARY_EDGE) {
        if (chains.length < 1)
            return undefined;
        const graph = new Graph_1.HalfEdgeGraph();
        const chainSeeds = Triangulation_1.Triangulator.directCreateChainsFromCoordinates(graph, chains);
        for (const seed of chainSeeds)
            seed.setMaskAroundFace(mask);
        this.splitIntersectingEdges(graph);
        this.clusterAndMergeXYTheta(graph);
        if (regularize) {
            const context = new RegularizeFace_1.RegularizationContext(graph);
            context.regularizeGraph(true, true);
        }
        return graph;
    }
}
exports.HalfEdgeGraphMerge = HalfEdgeGraphMerge;


/***/ }),

/***/ "./lib/topology/RegularizeFace.js":
/*!****************************************!*\
  !*** ./lib/topology/RegularizeFace.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const Graph_1 = __webpack_require__(/*! ./Graph */ "./lib/topology/Graph.js");
const Merging_1 = __webpack_require__(/*! ./Merging */ "./lib/topology/Merging.js");
//   /* tslint:disable:no-console */
/**
 * * Context for regularizing single faces.
 * @internal
 */
class RegularizationContext {
    constructor(graph) {
        this.graph = graph;
        this.upEdges = [];
        this.downEdges = [];
        this.bottomPeaks = [];
        this.topPeaks = [];
        this.localMin = [];
        this.localMax = [];
    }
    /**
     * Collect (and classify) all the edges around a single face.
     * * The various arrays are collected: upEdges, downEdges, topPeaks, bottomPeaks, upChains, downChains
     * @param faceSeed face to examine
     */
    collectVerticalEventsAroundFace(faceSeed) {
        let nodeA = faceSeed;
        let nodeB;
        let nodeC;
        let abUp;
        let bcUp;
        this.upEdges.length = 0;
        this.downEdges.length = 0;
        this.topPeaks.length = 0;
        this.bottomPeaks.length = 0;
        this.localMin.length = 0;
        this.localMax.length = 0;
        do {
            nodeB = nodeA.faceSuccessor;
            nodeC = nodeB.faceSuccessor;
            abUp = Merging_1.HalfEdgeGraphOps.compareNodesYXUp(nodeA, nodeB) < 0;
            bcUp = Merging_1.HalfEdgeGraphOps.compareNodesYXUp(nodeB, nodeC) < 0;
            if (abUp) {
                this.upEdges.push(nodeA);
                if (!bcUp) {
                    if (Merging_1.HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) < 0)
                        this.localMax.push(nodeB);
                    else
                        this.topPeaks.push(nodeB);
                }
            }
            else { // ab is DOWN
                this.downEdges.push(nodeA);
                if (bcUp) {
                    if (Merging_1.HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) > 0)
                        this.bottomPeaks.push(nodeB);
                    else
                        this.localMin.push(nodeB);
                }
            }
            nodeA = nodeB;
        } while (nodeA !== faceSeed);
    }
    /**
     * Collect (and classify) all the edges in an array.
     * * The various arrays are collected: upEdges, downEdges, topPeaks, bottomPeaks, upChains, downChains
     * @param candidateEdges array of edges.
     */
    collectVerticalEventFromEdgesInAndArray(candidateEdges) {
        let nodeA;
        let nodeB;
        let nodeC;
        let abUp;
        let bcUp;
        this.upEdges.length = 0;
        this.downEdges.length = 0;
        this.topPeaks.length = 0;
        this.bottomPeaks.length = 0;
        this.localMin.length = 0;
        this.localMax.length = 0;
        for (nodeA of candidateEdges) {
            nodeB = nodeA.faceSuccessor;
            nodeC = nodeB.faceSuccessor;
            abUp = Merging_1.HalfEdgeGraphOps.compareNodesYXUp(nodeA, nodeB) < 0;
            bcUp = Merging_1.HalfEdgeGraphOps.compareNodesYXUp(nodeB, nodeC) < 0;
            if (abUp) {
                this.upEdges.push(nodeA);
                if (!bcUp) {
                    if (Merging_1.HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) < 0)
                        this.localMax.push(nodeB);
                    else
                        this.topPeaks.push(nodeB);
                }
            }
            else { // ab is DOWN
                this.downEdges.push(nodeA);
                if (bcUp) {
                    if (Merging_1.HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) > 0)
                        this.bottomPeaks.push(nodeB);
                    else
                        this.localMin.push(nodeB);
                }
            }
        }
    }
    swapArrays() {
        let save = this.downEdges;
        this.downEdges = this.upEdges;
        this.upEdges = save;
        save = this.localMax;
        this.localMax = this.localMin;
        this.localMin = save;
        save = this.topPeaks;
        this.topPeaks = this.bottomPeaks;
        this.bottomPeaks = save;
    }
    /**
     * Find the edge (among candidates) which is first struck by a "rightward" scan from node
     * * comparisonFunction determines scan sense
     *   * HalfEdge.compareNodeYXTheta is an upward scan.
     *   * HalfEdge.compareNodeYXThetaDownward is a downward scan.
     * @param node
     * @param candidates Array of nodes to search
     * @param nodeComparisonFunction function for lexical comparison.
     */
    findTopVisibleEdge(node, candidates, directionSign) {
        const y0 = node.y;
        const x0 = node.x;
        let dx;
        let distanceRight = Number.MAX_SAFE_INTEGER;
        let result;
        for (const rightBase of candidates) {
            const rightTop = rightBase.faceSuccessor;
            if (rightBase === node || rightTop === node)
                continue;
            // for horizontal edge cases -- require edges ends to have strict sign change (no zeros!!)
            const cRight = Merging_1.HalfEdgeGraphOps.compareNodesYXUp(node, rightBase);
            const cTop = Merging_1.HalfEdgeGraphOps.compareNodesYXUp(node, rightTop);
            // console.log(node.id, rightBase.id, rightTop.id, cRight, cTop);
            if (cRight * cTop >= 0)
                continue;
            const fraction = Graph_1.HalfEdge.horizontalScanFraction01(rightBase, y0);
            if (fraction !== undefined) {
                dx = directionSign * (rightBase.fractionToX(fraction) - x0);
                if (dx > 0 && dx < distanceRight) {
                    result = rightBase;
                    distanceRight = dx;
                }
            }
        }
        return result;
    }
    /**
     *
     * @param downPeak a "bottom" node where the interior CCW loop has a local min
     * @param downEdgeStart (optional) node at the start (heading downwards!) of an edge that brackets downPeak on the left.
     * @param upEdgeStart  (optional) node at the start (heading up!) of the edge that brackets downPeak on the right.
     */
    highestUpPeakConnection(downPeak, downEdgeStart, upEdgeStart) {
        let highestPeak;
        for (const upPeak of this.topPeaks) {
            const y0 = upPeak.y;
            const x0 = upPeak.x;
            // is upPeak higher than prior upPeak?
            if (highestPeak !== undefined && Merging_1.HalfEdgeGraphOps.compareNodesYXUp(upPeak, highestPeak) < 0)
                continue;
            // is upPeak BELOW downPeak, ABOVE both limit edges lower node, and between limit edge interiors.
            if (Merging_1.HalfEdgeGraphOps.compareNodesYXUp(upPeak, downPeak) < 0) {
                if (downEdgeStart) {
                    const fraction = Graph_1.HalfEdge.horizontalScanFraction01(downEdgeStart, y0);
                    if (fraction === undefined)
                        continue;
                    if (x0 <= downEdgeStart.fractionToX(fraction))
                        continue;
                }
                if (upEdgeStart) {
                    const fraction = Graph_1.HalfEdge.horizontalScanFraction01(upEdgeStart, y0);
                    if (fraction === undefined)
                        continue;
                    if (upEdgeStart.fractionToX(fraction) <= x0)
                        continue;
                }
                highestPeak = upPeak;
            }
        }
        return highestPeak;
    }
    updateMaxNode(maxNode, candidate, compare) {
        if (!maxNode)
            return candidate;
        if (!candidate)
            return maxNode;
        // both are defined .. look for positive compare ...
        if (compare(maxNode, candidate) < 0)
            return candidate;
        return maxNode;
    }
    negateXY() {
        for (const node of this.graph.allHalfEdges) {
            node.x *= -1;
            node.y *= -1;
        }
    }
    downwardConnectionFromBottomPeak(node) {
        let connectTo;
        const upFunction = Merging_1.HalfEdgeGraphOps.compareNodesYXUp;
        const upEdgeBase = this.findTopVisibleEdge(node, this.upEdges, 1.0);
        const downEdgeBase = this.findTopVisibleEdge(node, this.downEdges, -1.0);
        connectTo = this.updateMaxNode(connectTo, upEdgeBase, upFunction);
        if (downEdgeBase)
            connectTo = this.updateMaxNode(connectTo, downEdgeBase.faceSuccessor, upFunction);
        const upPeakConnection = this.highestUpPeakConnection(node, downEdgeBase, upEdgeBase);
        if (upPeakConnection !== undefined)
            connectTo = this.updateMaxNode(connectTo, upPeakConnection, upFunction);
        return connectTo;
    }
    joinNodes(nodeA, nodeB) {
        const nodeC = this.graph.createEdgeXYZXYZ(nodeA.x, nodeA.y, nodeA.z, 0, nodeB.x, nodeB.y, nodeB.z, 0);
        Graph_1.HalfEdge.pinch(nodeA, nodeC);
        Graph_1.HalfEdge.pinch(nodeB, nodeC.edgeMate);
        return nodeC;
    }
    /**
     * Regularize a single face.
     * * Insert edge from any downward interior vertex to something lower
     * * Insert an edge from each upward interior vertex to something higher.
     * * The face is split into smaller faces
     * * Each final face has at most one "min" and one "max", and is easy to triangulate with a bottom to top sweep.
     * * Normal usage is to sweep in both directions, i.e. use the default (true,true) for the upSweep and downSweep parameters.
     * @param faceSeed any representative half edge on the face
     * @param upSweep true to do the upward sweep.
     * @param downSweep true to do the downward sweep.
     */
    runRegularization(upSweep = true, downSweep = true) {
        if (upSweep) {
            this.bottomPeaks.sort(Merging_1.HalfEdgeGraphOps.compareNodesYXUp);
            for (const bottomPeak of this.bottomPeaks) {
                // console.log("SEARCH", bottomPeak.id, [bottomPeak.x, bottomPeak.y]);
                if (!Merging_1.HalfEdgeGraphOps.isDownPeak(bottomPeak))
                    continue;
                const target = this.downwardConnectionFromBottomPeak(bottomPeak);
                if (target !== undefined) {
                    // console.log("join", bottomPeak.id, [bottomPeak.x, bottomPeak.y], target.id, [target.x, target.y]);
                    this.joinNodes(bottomPeak, target);
                }
            }
        }
        if (downSweep) {
            // flip the whole graph (ouch)
            this.negateXY();
            // swap the various p and down seeds ....
            this.swapArrays();
            this.bottomPeaks.sort(Merging_1.HalfEdgeGraphOps.compareNodesYXUp);
            for (const bottomPeak of this.bottomPeaks) {
                if (!Merging_1.HalfEdgeGraphOps.isDownPeak(bottomPeak))
                    continue;
                const target = this.downwardConnectionFromBottomPeak(bottomPeak);
                if (target !== undefined) {
                    this.joinNodes(bottomPeak, target);
                }
            }
            this.negateXY();
            this.swapArrays();
        }
    }
    /**
     * Regularize a single face.
     * * Insert edge from any downward interior vertex to something lower
     * * Insert an edge from each upward interior vertex to something higher.
     * * The face is split into smaller faces
     * * Each final face has at most one "min" and one "max", and is easy to triangulate with a bottom to top sweep.
     * * Normal usage is to sweep in both directions, i.e. use the default (true,true) for the upSweep and downSweep parameters.
     * @param faceSeed any representative half edge on the face
     * @param upSweep true to do the upward sweep.
     * @param downSweep true to do the downward sweep.
     */
    regularizeFace(faceSeed, upSweep = true, downSweep = true) {
        this.collectVerticalEventsAroundFace(faceSeed);
        this.runRegularization(upSweep, downSweep);
    }
    regularizeGraph(upSweep = true, downSweep = true) {
        this.collectVerticalEventFromEdgesInAndArray(this.graph.allHalfEdges);
        this.runRegularization(upSweep, downSweep);
    }
    /** test if a single face is monotone;  if so, return its (single) min */
    static isMonotoneFace(seed) {
        let numMin = 0;
        let numMax = 0;
        let nodeMin;
        let nodeA = seed;
        do {
            const nodeB = nodeA.faceSuccessor;
            const nodeC = nodeB.faceSuccessor;
            const ab = Merging_1.HalfEdgeGraphOps.compareNodesYXUp(nodeA, nodeB);
            const bc = Merging_1.HalfEdgeGraphOps.compareNodesYXUp(nodeB, nodeC);
            if (ab * bc <= 0) {
                if (ab > 0) {
                    numMin++;
                    nodeMin = nodeB;
                }
                if (bc > 0) {
                    numMax++;
                }
            }
        } while ((nodeA = nodeA.faceSuccessor) !== seed);
        return numMin === 1 && numMax === 1 ? nodeMin : undefined;
    }
    /** Return faces filtered by area and test function.
     * * find one arbitrary representative of each face
     * * offer the candidate to the mutate function.
     * * collect results
     * @param mappedSeeds when filter returns a HalfEdge, collect it here
     * @param unmappedSeeds when filter does not return a half edge, collect the candidate.
     */
    static collectMappedFaceRepresentatives(graph, positiveAreaOnly, mutate, mappedEdges, unMappedSeeds) {
        if (mappedEdges)
            mappedEdges.length = 0;
        if (unMappedSeeds)
            unMappedSeeds.length = 0;
        const mask = Graph_1.HalfEdgeMask.VISITED;
        graph.clearMask(mask);
        for (const seed of graph.allHalfEdges) {
            if (!seed.getMask(mask)) {
                seed.setMaskAroundFace(mask);
                if (!positiveAreaOnly || seed.signedFaceArea() > 0) {
                    const edge = mutate(seed);
                    if (edge) {
                        if (mappedEdges)
                            mappedEdges.push(edge);
                    }
                    else {
                        if (unMappedSeeds)
                            unMappedSeeds.push(seed);
                    }
                }
            }
        }
    }
}
exports.RegularizationContext = RegularizationContext;


/***/ }),

/***/ "./lib/topology/SignedDataSummary.js":
/*!*******************************************!*\
  !*** ./lib/topology/SignedDataSummary.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
/**
 * Class to accumulate statistics about a stream of signed numbers with tag items.
 * * All sums, counts, extrema, and item values are initialized to zero in the constructor.
 * * Each call to `announceItem (item, value)` updates the various sums, counts, and extrema.
 */
class SignedDataSummary {
    /** setup with zero sums and optional arrays */
    constructor(createArrays) {
        this.positiveSum = this.negativeSum = 0.0;
        this.numPositive = this.numNegative = this.numZero = 0.0;
        this.largestPositiveValue = this.largestNegativeValue = 0.0;
        if (createArrays) {
            this.negativeItemArray = [];
            this.positiveItemArray = [];
            this.zeroItemArray = [];
        }
    }
    /** update with an item and its data value. */
    announceItem(item, data) {
        if (data < 0) {
            this.numNegative++;
            this.negativeSum += data;
            if (this.negativeItemArray)
                this.negativeItemArray.push(item);
            if (data < this.largestNegativeValue) {
                this.largestNegativeValue = data;
                this.largestNegativeItem = item;
            }
        }
        else if (data > 0) {
            this.numPositive++;
            this.positiveSum += data;
            if (this.positiveItemArray)
                this.positiveItemArray.push(item);
            if (data > this.largestPositiveValue) {
                this.largestPositiveValue = data;
                this.largestPositiveItem = item;
            }
        }
        else {
            this.numZero++;
            if (this.zeroItemArray)
                this.zeroItemArray.push(item);
        }
    }
}
exports.SignedDataSummary = SignedDataSummary;


/***/ }),

/***/ "./lib/topology/Triangulation.js":
/*!***************************************!*\
  !*** ./lib/topology/Triangulation.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
const Graph_1 = __webpack_require__(/*! ./Graph */ "./lib/topology/Graph.js");
const Point3dVector3d_1 = __webpack_require__(/*! ../geometry3d/Point3dVector3d */ "./lib/geometry3d/Point3dVector3d.js");
const Geometry_1 = __webpack_require__(/*! ../Geometry */ "./lib/Geometry.js");
const IndexedXYZCollection_1 = __webpack_require__(/*! ../geometry3d/IndexedXYZCollection */ "./lib/geometry3d/IndexedXYZCollection.js");
const PointStreaming_1 = __webpack_require__(/*! ../geometry3d/PointStreaming */ "./lib/geometry3d/PointStreaming.js");
const PointHelpers_1 = __webpack_require__(/*! ../geometry3d/PointHelpers */ "./lib/geometry3d/PointHelpers.js");
const InsertAndRetriangulateContext_1 = __webpack_require__(/*! ./InsertAndRetriangulateContext */ "./lib/topology/InsertAndRetriangulateContext.js");
const HalfEdgeMarkSet_1 = __webpack_require__(/*! ./HalfEdgeMarkSet */ "./lib/topology/HalfEdgeMarkSet.js");
/**
 * (static) methods for triangulating polygons
 * * @internal
 */
class Triangulator {
    /** Given the six nodes that make up two bordering triangles, "pinch" and relocate the nodes to flip them
     * * The shared edge mates are a and d.
     * * (abc) are a triangle in CCW order
     * * (dfe) are a triangle in CCW order. (!! node dfe instead of def.)
     */
    static flipEdgeBetweenTriangles(a, b, c, d, e, f) {
        // Reassign all of the pointers
        Graph_1.HalfEdge.pinch(a, e);
        Graph_1.HalfEdge.pinch(c, d);
        Graph_1.HalfEdge.pinch(f, c);
        Graph_1.HalfEdge.pinch(e, b);
        // Move alpha and beta into the xy coordinates of their predecessors
        e.x = b.x;
        e.y = b.y;
        e.z = b.z;
        e.i = b.i;
        c.i = f.i;
        c.x = f.x;
        c.y = f.y;
        c.z = f.z;
    }
    /**
     * * nodeA is a given node
     * * nodeA1 is its nodeA.faceSuccessor
     * * nodeA2 is nodeA1.faceSuccessor, i.e. 3rd node of triangle A
     * * nodeB  is nodeA.edgeMate, i.e. a node in the "other" triangle at nodeA's edge
     * * nodeB1 is nodeB.faceSuccessor
     * * nodeB2 is nodeB1.faceSuccessor, i.e the 3rd node of triangle B
     * Construct (as simple doubles, to avoid object creation) xy vectors from:
     * * (ux,uy): nodeA to nodeA1, i.e. the shared edge
     * * (vx,vy): nodeA to nodeA2,
     * * (wx,wy): nodeA to nodeB2
     * * this determinant is positive if nodeA is "in the circle" of nodeB2, nodeA1, nodeA2
     * * Return true if clearly positive
     * * Return false if clearly negative or almost zero.
     * @param nodeA node on the diagonal edge of candidate for edge flip.
     * @param if true, divide the determinant by the sum of absolute values of the cubic terms of the determinant.
     * @return the determinant as modified per comment (but undefined if the faces are not triangles as expected.)
     */
    static computeInCircleDeterminantIsStrongPositive(nodeA) {
        const nodeA1 = nodeA.faceSuccessor;
        const nodeA2 = nodeA1.faceSuccessor;
        if (nodeA2.faceSuccessor !== nodeA)
            return false;
        const nodeB = nodeA.edgeMate;
        const nodeB1 = nodeB.faceSuccessor;
        const nodeB2 = nodeB1.faceSuccessor;
        if (nodeB2.faceSuccessor !== nodeB)
            return false;
        const ux = nodeA1.x - nodeA.x;
        const uy = nodeA1.y - nodeA.y;
        const vx = nodeA2.x - nodeA.x;
        const vy = nodeA2.y - nodeA.y;
        if (Geometry_1.Geometry.crossProductXYXY(ux, uy, vx, vy) < 0)
            return false;
        // we assume identical coordinates in pairs (nodeA, nodeB1)  and (nodeA1, nodeB)
        const wx = nodeB2.x - nodeA.x;
        const wy = nodeB2.y - nodeA.y;
        const tx = wx * wx + wy * wy;
        const ty = vx * vx + vy * vy;
        const tz = ux * ux + uy * uy;
        const q = Geometry_1.Geometry.tripleProduct(wx, wy, tx, vx, vy, ty, ux, uy, tz);
        if (q < 0)
            return false;
        const denom = Math.abs(wx * vy * tz) + Math.abs(wx * ty * ux) + Math.abs(tx * vx * uy)
            + Math.abs(wx * ty * uy) + Math.abs(wy * vx * tz) + Math.abs(tx * vy * ux);
        return q > 1.0e-12 * denom;
    }
    /**
     *  *  Visit each node of the graph array
     *  *  If a flip would be possible, test the results of flipping using incircle condition
     *  *  If revealed to be an improvement, conduct the flip, mark involved nodes as unvisited, and repeat until all nodes are visited
     */
    static flipTriangles(graph) {
        const edgeSet = HalfEdgeMarkSet_1.MarkedEdgeSet.create(graph);
        for (const node of graph.allHalfEdges)
            edgeSet.addToSet(node);
        const numFlip = this.flipTrianglesInEdgeSet(graph, edgeSet);
        edgeSet.teardown();
        return numFlip;
    }
    /**
     *  *  Visit each node of the graph array
     *  *  If a flip would be possible, test the results of flipping using incircle condition
     *  *  If revealed to be an improvement, conduct the flip, mark involved nodes as unvisited, and repeat until all nodes are visited
     */
    static flipTrianglesInEdgeSet(graph, edgeSet) {
        const barrierMasks = Graph_1.HalfEdgeMask.EXTERIOR | Graph_1.HalfEdgeMask.PRIMARY_EDGE | Graph_1.HalfEdgeMask.BOUNDARY_EDGE;
        const nodeArray = graph.allHalfEdges;
        const maxTest = 10.0 * nodeArray.length;
        let numFlip = 0;
        let numOK = 0;
        let node;
        while (undefined !== (node = edgeSet.chooseAndRemoveAny())) {
            if (node.isMaskSet(barrierMasks)) // Flip not allowed
                continue;
            if (Triangulator.computeInCircleDeterminantIsStrongPositive(node)) {
                // Flip the triangles
                Triangulator.flipEdgeBetweenTriangles(node.edgeMate.faceSuccessor, node.edgeMate.facePredecessor, node.edgeMate, node.faceSuccessor, node, node.facePredecessor);
                // keep looking at the 2 faces
                edgeSet.addAroundFace(node);
                edgeSet.addAroundFace(node.edgeMate);
                numFlip++;
            }
            else {
                numOK++;
            }
            if (numFlip + numOK > maxTest)
                break;
        }
        return numFlip;
    }
    /** Create a graph with a triangulation points.
     * * The outer limit of the graph is the convex hull of the points.
     * * The outside loop is marked `HalfEdgeMask.EXTERIOR`
     */
    static createTriangulatedGraphFromPoints(points) {
        if (points.length < 3)
            return undefined;
        const hull = [];
        const interior = [];
        PointHelpers_1.Point3dArray.computeConvexHullXY(points, hull, interior, true);
        const graph = new Graph_1.HalfEdgeGraph();
        const context = InsertAndRetriangulateContext_1.InsertAndRetriangulateContext.create(graph);
        Triangulator.createFaceLoopFromCoordinates(graph, hull, true, true);
        // HalfEdgeGraphMerge.clusterAndMergeXYTheta(graph);
        let numInsert = 0;
        for (const p of interior) {
            context.insertAndRetriangulate(p, true);
            numInsert++;
            if (numInsert > 16) {
                /*
                context.reset();
                Triangulator.flipTriangles(context.graph);
                // console.log (" intermediate flips " + numFlip);
                */
                numInsert = 0;
            }
        }
        /*
            // final touchup for aspect ratio flip
            for (let i = 0; i < 15; i++) {
              const numFlip = Triangulator.flipTriangles(graph);
              if (numFlip === 0)
                break;
            }
            */
        return graph;
    }
    /**
     * * Only one outer loop permitted.
     * * Largest area loop is assumed outer.
     * @param loops an array of loops as GrowableXYZArray or XAndY[]
     * @returns triangulated graph, or undefined if bad data.
     */
    static createTriangulatedGraphFromLoops(loops) {
        if (loops.length < 1)
            return undefined;
        const mask = Graph_1.HalfEdgeMask.BOUNDARY_EDGE | Graph_1.HalfEdgeMask.PRIMARY_EDGE;
        const graph = new Graph_1.HalfEdgeGraph();
        const holeSeeds = [];
        let maxArea = -10000.0;
        let maxAreaIndex = -1;
        // collect all the loops with pointers to the positive (inside)
        // remember which one has largest area.
        for (let i = 0; i < loops.length; i++) {
            let seed = Triangulator.directCreateFaceLoopFromCoordinates(graph, loops[i]);
            if (seed) {
                seed = seed.faceSuccessor; // directCreate returns tail
                const mate = seed.vertexSuccessor;
                seed.setMaskAroundFace(mask);
                mate.setMaskAroundFace(mask);
                const signedFaceArea = seed.signedFaceArea();
                const area = Math.abs(signedFaceArea);
                holeSeeds.push(signedFaceArea >= 0 ? seed : mate);
                if (i === 0 || area > maxArea) {
                    maxArea = area;
                    maxAreaIndex = i;
                }
            }
        }
        if (holeSeeds.length === 0)
            return undefined;
        // extract the max area seed ...
        const maxAreaFace = holeSeeds[maxAreaIndex];
        holeSeeds[maxAreaIndex] = holeSeeds[holeSeeds.length - 1];
        holeSeeds.pop();
        maxAreaFace.vertexSuccessor.setMaskAroundFace(Graph_1.HalfEdgeMask.EXTERIOR);
        // The hole seeds all have inside nodes.  Set mask there and jump to outside.
        for (let i = 0; i < holeSeeds.length; i++) {
            const seed = holeSeeds[i];
            seed.setMaskAroundFace(Graph_1.HalfEdgeMask.EXTERIOR);
            holeSeeds[i] = this.getLeftmost(seed.vertexSuccessor);
        }
        const startingNode = Triangulator.spliceLeftMostNodesOfHoles(graph, maxAreaFace, holeSeeds);
        Triangulator.triangulateSingleFace(graph, startingNode);
        return graph;
    }
    /**
     * Triangulate all positive area faces of a graph.
     */
    static triangulateAllPositiveAreaFaces(graph) {
        const seeds = graph.collectFaceLoops();
        for (const face of seeds) {
            if (face.countEdgesAroundFace() > 3) {
                const area = face.signedFaceArea();
                if (area > 0.0)
                    Triangulator.triangulateSingleFace(graph, face);
            }
        }
    }
    /**
     * Triangulate the polygon made up of by a series of points.
     * * The loop may be either CCW or CW -- CCW order will be used for triangles.
     * * To triangulate a polygon with holes, use createTriangulatedGraphFromLoops
     */
    static createTriangulatedGraphFromSingleLoop(data) {
        const graph = new Graph_1.HalfEdgeGraph();
        const startingNode = Triangulator.createFaceLoopFromCoordinates(graph, data, true, true);
        if (!startingNode || graph.countNodes() < 6)
            return graph;
        Triangulator.triangulateSingleFace(graph, startingNode);
        Triangulator.flipTriangles(graph);
        return graph;
    }
    /**
     * cautiously split the edge starting at baseNode.
     * * If baseNode is null, create a trivial loop with the single vertex at xy
     * * if xy is distinct from the coordinates at both baseNode and its successor, insert xy as a new node within that edge.
     * * also include z coordinate if present.
     */
    static interiorEdgeSplit(graph, baseNode, xy) {
        let x = 0, y = 0, z = 0;
        if (Array.isArray(xy)) {
            x = xy[0];
            y = xy[1];
            z = xy.length > 2 ? xy[3] : 0.0;
        }
        else {
            const q = xy;
            if (q.hasOwnProperty("x"))
                x = q.x;
            if (q.hasOwnProperty("y"))
                y = q.y;
            if (q.hasOwnProperty("y"))
                z = q.z;
        }
        if (!baseNode)
            return graph.splitEdge(baseNode, x, y, z);
        if (Triangulator.equalXAndYXY(baseNode, x, y))
            return baseNode;
        if (Triangulator.equalXAndYXY(baseNode.faceSuccessor, x, y))
            return baseNode;
        return graph.splitEdge(baseNode, x, y, z);
    }
    /** Create a loop from coordinates.
     * * Return a pointer to any node on the loop.
     * * no masking or other markup is applied.
     */
    static directCreateFaceLoopFromCoordinates(graph, data) {
        // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors
        let baseNode;
        if (data instanceof IndexedXYZCollection_1.IndexedXYZCollection) {
            const xyz = Point3dVector3d_1.Point3d.create();
            for (let i = 0; i < data.length; i++) {
                data.getPoint3dAtCheckedPointIndex(i, xyz);
                baseNode = Triangulator.interiorEdgeSplit(graph, baseNode, xyz);
            }
        }
        else {
            for (const xy of data) {
                baseNode = Triangulator.interiorEdgeSplit(graph, baseNode, xy);
            }
        }
        return baseNode;
    }
    /** Create chains from coordinates.
     * * Return array of pointers to base node of the chains.
     * * no masking or other markup is applied.
     * @param graph New edges are built in this graph
     * @param data coordinate data
     * @param id id to attach to (both side of all) edges
     */
    static directCreateChainsFromCoordinates(graph, data, id = 0) {
        // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors
        const assembler = new AssembleXYZXYZChains(graph, id);
        PointStreaming_1.VariantPointDataStream.streamXYZ(data, assembler);
        return assembler.claimSeeds();
    }
    /**
     * @param graph the containing graph
     * @param base The last node of a newly created loop.  (i.e. its `faceSuccessor` has the start xy)
     * @param returnPositiveAreaLoop if true, return the start node on the side with positive area.  otherwise return the left side as given.
     * @param maskForBothSides mask to apply on both sides.
     * @param maskForOtherSide mask to apply to the "other" side of the loop.
     * @return the loop's start node or its vertex successor, chosen to be the positive or negative loop per request.
     */
    static maskAndOrientNewFaceLoop(_graph, base, returnPositiveAreaLoop, maskForBothSides, maskForOtherSide) {
        // base is the final coordinates
        if (base) {
            base = base.faceSuccessor; // because typical construction process leaves the "live" edge at the end of the loop.
            const area = base.signedFaceArea();
            const mate = base.edgeMate;
            if (maskForBothSides !== Graph_1.HalfEdgeMask.NULL_MASK) {
                base.setMaskAroundFace(maskForBothSides);
                mate.setMaskAroundFace(maskForBothSides);
            }
            let preferredNode = base;
            if (returnPositiveAreaLoop && (area < 0))
                preferredNode = mate;
            const otherNode = preferredNode.vertexSuccessor;
            if (maskForOtherSide !== Graph_1.HalfEdgeMask.NULL_MASK)
                otherNode.setMaskAroundFace(maskForOtherSide);
            return preferredNode;
        }
        return undefined;
    }
    /**
     * create a circular doubly linked list of internal and external nodes from polygon points in the specified winding order
     * * This applies the masks used by typical applications:
     *   * HalfEdgeMask.BOUNDARY on both sides
     *   * HalfEdgeMask.PRIMARY_EDGE on both sides.
     * * Use `createFaceLoopFromCoordinatesAndMasks` for detail control of masks.
     */
    static createFaceLoopFromCoordinates(graph, data, returnPositiveAreaLoop, markExterior) {
        const base = Triangulator.directCreateFaceLoopFromCoordinates(graph, data);
        return Triangulator.maskAndOrientNewFaceLoop(graph, base, returnPositiveAreaLoop, Graph_1.HalfEdgeMask.BOUNDARY_EDGE | Graph_1.HalfEdgeMask.PRIMARY_EDGE, markExterior ? Graph_1.HalfEdgeMask.EXTERIOR : Graph_1.HalfEdgeMask.NULL_MASK);
    }
    /**
     * create a circular doubly linked list of internal and external nodes from polygon points.
     * * Optionally jump to the "other" side so the returned loop has positive area
     * @param graph graph to receive the new edges
     * @param data array with x,y coordinates
     * @param returnPositiveAreaLoop if false, return an edge proceeding around the loop in the order given.  If true, compute the loop area and flip return the side with positive area.
     * @param maskForBothSides mask to apply on both sides.
     * @param maskForOtherSide mask to apply on the "other" side from the returned loop.
     */
    static createFaceLoopFromCoordinatesAndMasks(graph, data, returnPositiveAreaLoop, maskForBothSides, maskForOtherSide) {
        const base = Triangulator.directCreateFaceLoopFromCoordinates(graph, data);
        return Triangulator.maskAndOrientNewFaceLoop(graph, base, returnPositiveAreaLoop, maskForBothSides, maskForOtherSide);
    }
    /** Cut off an ear, forming a new face loop of nodes
     * @param ear the vertex being cut off.
     * *  Form two new nodes, alpha and beta, which have the coordinates one step away from the ear vertex.
     * *  Reassigns the pointers such that beta is left behind with the new face created
     * *  Reassigns the pointers such that alpha becomes the resulting missing node from the remaining polygon
     * * Reassigns prevZ and nextZ pointers
     */
    static joinNeighborsOfEar(graph, ear) {
        const alpha = graph.createEdgeXYZXYZ(ear.facePredecessor.x, ear.facePredecessor.y, ear.facePredecessor.z, ear.facePredecessor.i, ear.faceSuccessor.x, ear.faceSuccessor.y, ear.faceSuccessor.z, ear.faceSuccessor.i);
        const beta = alpha.edgeMate;
        // Add two nodes alpha and beta and reassign pointers (also mark triangle nodes as part of triangle)
        Graph_1.HalfEdge.pinch(ear.faceSuccessor, beta);
        Graph_1.HalfEdge.pinch(ear.facePredecessor, alpha);
        ear.setMaskAroundFace(Graph_1.HalfEdgeMask.TRIANGULATED_FACE);
    }
    static isInteriorTriangle(a) {
        if (!a.isMaskSet(Graph_1.HalfEdgeMask.TRIANGULATED_FACE))
            return false;
        const b = a.faceSuccessor;
        if (!b.isMaskSet(Graph_1.HalfEdgeMask.TRIANGULATED_FACE))
            return false;
        const c = b.faceSuccessor;
        if (!c.isMaskSet(Graph_1.HalfEdgeMask.TRIANGULATED_FACE))
            return false;
        return c.faceSuccessor === a;
    }
    /**
     * Perform 0, 1, or more edge flips to improve aspect ratio just behind an that was just cut.
     * @param ear the triangle corner which just served as the ear node.
     * @returns the node at the back corner after flipping."appropriately positioned" node for the usual advance to ear.faceSuccessor.edgeMate.faceSuccessor.
     */
    static doPostCutFlips(ear) {
        //    B is the ear -- inside a (probably newly created) triangle ABC
        //    CA is the recently added cut edge.
        //    AB is the candidate to be flipped.
        //    triangle B1 A1 D is on the other side of AB
        //    The condition for flipping is:
        //           ! both triangles must be TRIANGULATED_NODE_MASK
        //           ! incircle condition flags D as in the circle of ABC
        //     after flip, node A moves to the vertex of D, and is the effective "ear",  with the cap edge C A1
        //      after flip, consider the A1 D (whose nodes are A1 and flipped A!!!)
        //
        //
        //                                   . C0|
        //                              .        |
        //                           .           |
        //                       .              ^|
        //                   .  A0 ---->       B0|
        //               *=======================*
        //                 \ A1     <----   B1/
        //                   \             /
        //                     \         /
        //                       \  D1 /
        //                          *
        let b0 = ear;
        let a0 = b0.facePredecessor;
        let b1 = a0.edgeMate;
        while (Triangulator.isInteriorTriangle(a0) && Triangulator.isInteriorTriangle(b1)) {
            const detA = Triangulator.computeInCircleDeterminantIsStrongPositive(a0);
            if (!detA)
                break;
            // Flip the triangles
            const a1 = b1.faceSuccessor;
            Triangulator.flipEdgeBetweenTriangles(a1, a1.faceSuccessor, a1.facePredecessor, b0, b0.facePredecessor, b0.faceSuccessor);
            b0 = a0;
            a0 = b0.facePredecessor;
            b1 = a0.edgeMate;
        }
        return b0;
    }
    /**
     * main ear slicing loop which triangulates a polygon (given as a linked list)
     * While there still exists ear nodes that have not yet been triangulated...
     *
     * *  Check if the ear is hashed, and can easily be split off. If so, "join" that ear.
     * *  If not hashed, move on to a separate ear.
     * *  If no ears are currently hashed, attempt to cure self intersections or split the polygon into two before continuing
     */
    static triangulateSingleFace(graph, ear) {
        if (!ear)
            return;
        let next;
        let next2;
        let maxCandidate = ear.countEdgesAroundFace();
        let numCandidate = 0;
        ear.clearMaskAroundFace(Graph_1.HalfEdgeMask.TRIANGULATED_FACE);
        // iterate through ears, slicing them one by one
        while (!ear.isMaskSet(Graph_1.HalfEdgeMask.TRIANGULATED_FACE)) {
            next = ear.faceSuccessor;
            next2 = next.faceSuccessor;
            if (next === ear || next2 === ear || next2.faceSuccessor === ear)
                break;
            if (++numCandidate > maxCandidate)
                break;
            if (Triangulator.isEar(ear)) {
                maxCandidate--;
                numCandidate = 0;
                // skipping the next vertices leads to less sliver triangles
                // If we already have a separated triangle, do not join
                if (ear.faceSuccessor.faceSuccessor !== ear.facePredecessor) {
                    Triangulator.joinNeighborsOfEar(graph, ear);
                    ear = Triangulator.doPostCutFlips(ear);
                    ear = ear.faceSuccessor.edgeMate.faceSuccessor;
                    // another step?   Nate's 2017 code went one more.
                }
                else {
                    ear.setMaskAroundFace(Graph_1.HalfEdgeMask.TRIANGULATED_FACE);
                    ear = next.faceSuccessor;
                }
                continue;
            }
            ear = next;
        }
    }
    /** Check whether a polygon node forms a valid ear with adjacent nodes */
    static isEar(ear) {
        const a = ear.facePredecessor;
        const b = ear;
        const c = ear.faceSuccessor;
        if (Triangulator.signedTriangleArea(a, b, c) >= 0)
            return false; // reflex, can't be an ear
        // now make sure we don't have other points inside the potential ear
        let p = ear.faceSuccessor.faceSuccessor;
        while (p !== ear.facePredecessor) {
            if (Triangulator.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
                Triangulator.signedTriangleArea(p.facePredecessor, p, p.faceSuccessor) >= 0)
                return false;
            p = p.faceSuccessor;
        }
        return true;
    }
    /** link holeLoopNodes[1], holeLoopNodes[2] etc into the outer loop, producing a single-ring polygon without holes
     *
     */
    static spliceLeftMostNodesOfHoles(graph, outerNode, leftMostHoleLoopNode) {
        leftMostHoleLoopNode.sort(Triangulator.compareX);
        // process holes from left to right
        for (const holeStart of leftMostHoleLoopNode) {
            Triangulator.eliminateHole(graph, holeStart, outerNode);
        }
        return outerNode;
    }
    /** For use in sorting -- return (signed) difference (a.x - b.x) */
    static compareX(a, b) {
        return a.x - b.x;
    }
    /** find a bridge between vertices that connects hole with an outer ring and and link it */
    static eliminateHole(graph, hole, outerNode) {
        const outerNodeA = Triangulator.findHoleBridge(hole, outerNode);
        if (outerNodeA) {
            Triangulator.splitFace(graph, outerNodeA, hole);
        }
    }
    // cspell:word Eberly
    /**
     *  David Eberly algorithm for finding a bridge between hole and outer polygon:
     *  https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf
     */
    static findHoleBridge(hole, outerNode) {
        let p = outerNode;
        if (!p)
            return undefined;
        const hx = hole.x;
        const hy = hole.y;
        let qx = -Infinity;
        let m;
        // find a segment intersected by a ray from the hole's leftmost point to the left;
        // segment's endpoint with lesser x will be potential connection point
        do {
            if (hy <= p.y && hy >= p.faceSuccessor.y && p.faceSuccessor.y !== p.y) {
                const x = p.x + (hy - p.y) * (p.faceSuccessor.x - p.x) / (p.faceSuccessor.y - p.y);
                if (x <= hx && x > qx) {
                    qx = x;
                    if (x === hx) {
                        if (hy === p.y)
                            return p;
                        if (hy === p.faceSuccessor.y)
                            return p.faceSuccessor;
                    }
                    m = p.x < p.faceSuccessor.x ? p : p.faceSuccessor;
                }
            }
            p = p.faceSuccessor;
        } while (p !== outerNode);
        if (!m)
            return undefined;
        if (hx === qx)
            return m.facePredecessor; // hole touches outer segment; pick lower endpoint
        // look for points inside the triangle of hole point, segment intersection and endpoint;
        // if there are no points found, we have a valid connection;
        // otherwise choose the point of the minimum angle with the ray as connection point
        const stop = m;
        const mx = m.x;
        const my = m.y;
        let tanMin = Infinity;
        let tan;
        p = m.faceSuccessor;
        while (p !== stop) {
            if (hx >= p.x && p.x >= mx && hx !== p.x &&
                Triangulator.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
                tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
                if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Triangulator.locallyInside(p, hole)) {
                    m = p;
                    tanMin = tan;
                }
            }
            p = p.faceSuccessor;
        }
        return m;
    }
    // find the leftmost node of a polygon ring
    static getLeftmost(start) {
        let p = start;
        let leftmost = start;
        do {
            if (p.x < leftmost.x)
                leftmost = p;
            p = p.faceSuccessor;
        } while (p !== start);
        return leftmost;
    }
    /** check if a point lies within a convex triangle */
    static pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
        return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
            (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
            (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
    }
    /** signed area of a triangle */
    static signedTriangleArea(p, q, r) {
        return 0.5 * ((q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y));
    }
    /** check if two points are equal */
    static equalXAndYXY(p1, x, y) {
        return Geometry_1.Geometry.isSameCoordinate(p1.x, x) && Geometry_1.Geometry.isSameCoordinate(p1.y, y);
    }
    /** check if a polygon diagonal is locally inside the polygon */
    static locallyInside(a, b) {
        return Triangulator.signedTriangleArea(a.facePredecessor, a, a.faceSuccessor) < 0 ?
            Triangulator.signedTriangleArea(a, b, a.faceSuccessor) >= 0 && Triangulator.signedTriangleArea(a, a.facePredecessor, b) >= 0 :
            Triangulator.signedTriangleArea(a, b, a.facePredecessor) < 0 || Triangulator.signedTriangleArea(a, a.faceSuccessor, b) < 0;
    }
    /**
     * link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
     * if one belongs to the outer ring and another to a hole, it merges it into a single ring
     * * Returns the base of the new edge at the "a" end.
     * * "a" and "b" still represent the same physical pieces of edges
     * @returns Returns the (base of) the new half edge, at the "a" end.
     */
    static splitFace(graph, a, b) {
        const a2 = graph.createEdgeXYZXYZ(a.x, a.y, a.z, a.i, b.x, b.y, b.z, b.i);
        const b2 = a2.faceSuccessor;
        Graph_1.HalfEdge.pinch(a, a2);
        Graph_1.HalfEdge.pinch(b, b2);
        return a2;
    }
    /**
     * Triangulate a single face with (linear time) logic applicable only if the lowNode is the lowest node.
     * @returns false if any monotonicity condition is violated.
     */
    static triangulateSingleMonotoneFace(graph, start) {
        let left = start.facePredecessor;
        let right = start.faceSuccessor;
        // P0, P1, P2 are successive edges along evolving chain
        let P0 = start; // will be reinitialized -- use start to quiet linter
        let P1 = start; // will be reinitialized -- use start to quiet linter
        let P2 = start; // will be reinitialized -- use start to quiet linter
        let upperSideOfNewEdge;
        while (left !== right
            && right !== start
            && right.faceSuccessor !== left) {
            /** These should not happen if face is monotone . .. */
            if (Graph_1.HalfEdge.crossProductXYAlongChain(left, start, right) <= 0)
                return false;
            if (!start.belowYX(left))
                return false;
            if (!start.belowYX(right))
                return false;
            if (left.belowYX(right)) {
                /*      Triangulate to all left side edges that
                   are below right */
                /*      Phase 1: move upward, adding back edges
                   when prior nodes are visible. */
                P0 = left;
                P1 = start;
                P2 = right;
                /*      Invariant: the path from P0 back to P1 is concave.
                   Each loop pass moves P0 up the left side, filling in
                   edges as needed.  The right side edge
                   (following start) is never altered.
                 */
                while (P0 !== P2 && P0.belowYX(right)) {
                    while (P2 !== right
                        && P2 !== P0
                        && P2 !== P1
                        && Graph_1.HalfEdge.crossProductXYAlongChain(P0, P1, P2) > 0) {
                        upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);
                        P0 = upperSideOfNewEdge;
                        P1 = P0.faceSuccessor;
                        P2 = P1.faceSuccessor;
                    }
                    P2 = P1;
                    P1 = P0;
                    P0 = P0.facePredecessor;
                }
                /*      Phase 2: Fan out edges from right to the
                   left side. P0.P1.P2 describes a pair of
                   adjacent edges at the bottom. */
                left = P1;
                P2 = right;
                P1 = P2.facePredecessor;
                P0 = P1.facePredecessor;
                while (P2.faceSuccessor !== P0 && P0 !== left) {
                    upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);
                    P1 = upperSideOfNewEdge;
                    P0 = P1.facePredecessor;
                }
                /*      Finish off with the last stroke from the
                   left node to the right, except when already
                   topped out */
                if (P2.faceSuccessor !== P0) {
                    upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);
                    P0 = upperSideOfNewEdge;
                }
                start = P0;
                right = start.faceSuccessor;
                left = start.facePredecessor;
            }
            else {
                /*      Triangulate to all right side edges that
                   are below left */
                /*      Phase 1: move upward, adding back edges
                   when prior nodes are visible. */
                P0 = left;
                P1 = start;
                P2 = right;
                /*      Invariant: the path up to P1 is concave.
                   Each loop pass advances P1, filling in
                   edges as needed. Note that the
                   start edge may get hidden, so the
                   bottom node must be referenced as
                   left.faceSuccessor rather than as start.
                 */
                while (P0 !== P2 && P2.belowYX(left)) {
                    while (P0 !== left
                        && P2 !== P0
                        && P2 !== P1
                        && Graph_1.HalfEdge.crossProductXYAlongChain(P0, P1, P2) > 0) {
                        upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);
                        P0 = upperSideOfNewEdge.facePredecessor;
                        P1 = upperSideOfNewEdge;
                    }
                    P0 = P1;
                    P1 = P2;
                    P2 = P2.faceSuccessor;
                }
                /*      Phase 2: Fan out edges from left to the
                   right side. P0.P1.P2 describes a pair of
                   adjacent edges at the bottom. */
                right = P1;
                P0 = left;
                P1 = P0.faceSuccessor;
                P2 = P1.faceSuccessor;
                while (P2.faceSuccessor !== P0 && P2 !== right) {
                    upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);
                    P0 = upperSideOfNewEdge;
                    P1 = P2;
                    P2 = P2.faceSuccessor;
                }
                /*      Finish off with the last stroke from the
                   left node to the right, except when already
                   topped out */
                if (P2.faceSuccessor !== P0) {
                    Triangulator.splitFace(graph, P0, P2);
                }
                start = right;
                right = start.faceSuccessor;
                left = start.facePredecessor;
            }
        }
        return true;
    }
}
exports.Triangulator = Triangulator;
/**
 * Internal class for assembling chains
 * @internal
 */
class AssembleXYZXYZChains extends PointStreaming_1.PointStreamXYZXYZHandlerBase {
    constructor(graph, id) {
        super();
        this._graph = graph;
        this._id = id;
    }
    startChain(chainData, isLeaf) {
        super.startChain(chainData, isLeaf);
        this._baseNode = undefined;
        this._nodeB = undefined;
    }
    handleXYZXYZ(x0, y0, z0, x1, y1, z1) {
        this._nodeC = this._graph.createEdgeXYZXYZ(x0, y0, z0, this._id, x1, y1, z1, this._id);
        if (this._baseNode === undefined) {
            this._baseNode = this._nodeC;
            this._nodeB = this._baseNode.faceSuccessor;
        }
        else {
            Graph_1.HalfEdge.pinch(this._nodeB, this._nodeC);
            this._nodeB = this._nodeC.faceSuccessor;
        }
    }
    endChain(chainData, isLeaf) {
        super.endChain(chainData, isLeaf);
        if (this._baseNode !== undefined) {
            if (this._seeds === undefined)
                this._seeds = [];
            this._seeds.push(this._baseNode);
        }
        this._baseNode = undefined;
        this._nodeB = undefined;
        this._nodeC = undefined;
    }
    claimSeeds() {
        if (this._seeds === undefined)
            return [];
        return this._seeds;
    }
}


/***/ }),

/***/ "./lib/topology/XYParitySearchContext.js":
/*!***********************************************!*\
  !*** ./lib/topology/XYParitySearchContext.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
/** @module Topology */
/**
 * * XYParitySearchContext is an internal class for callers that can feed points (without extracting to array structures)
 * * Most will be via static methods which handle a specific data source.
 *   * PolygonOps.classifyPointInPolygon (x,y,points: XAndY[])
 *   * HalfEdgeGraphSearch.pointInOrOnFaceXY (halfEdgeOnFace, x, y)
 * Use pattern:
 * * Caller must be able walk around polygon producing x,y coordinates (possibly transformed from actual polygon)
 * * Caller announce edges to tryStartEdge until finding one acceptable to the search.
 * * Caller then passes additional points up to and including both x0,y0 and x1, y1 of the accepted start edge.
 * Call sequence is:
 *    `context = new XYParitySearchContext`
 *    `repeat {  acquire edge (x0,y0) (x1,y1)} until context.tryStartEdge (x0,y0,x1,y1);`
 *    `for each (x,y) beginning AFTER x1,y1 and ending with (x1,y1) context.advance (x,y)`
 *  `return context.classifyCounts ();`
 */
class XYParitySearchContext {
    /**
     * Create a new searcher for specified test point.
     * @param xTest x coordinate of test point
     * @param yTest y coordinate of test point
     */
    constructor(xTest, yTest) {
        this.xTest = xTest;
        this.yTest = yTest;
        this.u0 = this.v0 = this.u1 = this.v1 = 0; // Not valid for search -- caller must satisfy tryStartEdge !!!
        this.numLeftCrossing = this.numRightCrossing = 0;
        this.numHit = 0;
    }
    /**
     * test if x,y is a safe first coordinate to start the search.
     * * safe start must have non-zero y so that final point test (return to x0,y0) does not need look back for exact crossing logic.
     * @param x
     * @param y
     */
    tryStartEdge(x0, y0, x1, y1) {
        if (y0 !== this.yTest) {
            this.u0 = x0 - this.xTest;
            this.v0 = y0 - this.yTest;
            this.u1 = x1 - this.xTest;
            this.v1 = y1 - this.yTest;
            return true;
        }
        return false;
    }
    /** Return true if parity accumulation proceeded normally.
     * Return false if interrupted for exact hit.
     */
    advance(x, y) {
        const u = x - this.xTest;
        const v = y - this.yTest;
        const p = v * this.v1;
        if (p > 0) {
            // The common case -- skittering along above or below the x axis . . .
            this.u0 = this.u1;
            this.v0 = this.v1;
            this.u1 = u;
            this.v1 = v;
            return true;
        }
        if (p < 0) {
            // crossing within (u1,v1) to (u,v)
            // both v values are nonzero and of opposite sign, so this division is safe . . .
            const fraction = -this.v1 / (v - this.v1);
            const uCross = this.u1 + fraction * (u - this.u1);
            if (uCross === 0.0) {
                this.numHit++;
                return false;
            }
            if (uCross > 0)
                this.numRightCrossing++;
            else
                this.numLeftCrossing++;
            this.u0 = this.u1;
            this.v0 = this.v1;
            this.u1 = u;
            this.v1 = v;
            return true;
        }
        // hard stuff -- one or more exact hits . . .
        if (v === 0.0) {
            if (this.v1 === 0.0) {
                // uh oh -- moving along x axis.  Does it pass through xTest:
                if (u * this.u1 <= 0.0) {
                    this.numHit++;
                    return false;
                }
                // quietly moving along the scan line, both xy and x1y1 to same side of test point ...
                // u0 and u1 remain unchanged !!!
                this.u1 = u;
                this.v1 = v;
                return true;
            }
            // just moved onto the scan line ...
            this.u0 = this.u1;
            this.v0 = this.v1;
            this.u1 = u;
            this.v1 = v;
            return true;
        }
        // fall out with v1 = 0
        // both v0 and v are nonzero.
        // any along-0 v values that have passed through are on the same side of xTest, so u1 determines crossing
        const q = this.v0 * v;
        if (this.u1 > 0) {
            if (q < 0)
                this.numRightCrossing++;
        }
        else {
            if (q < 0)
                this.numLeftCrossing++;
        }
        this.u0 = this.u1;
        this.v0 = this.v1;
        this.u1 = u;
        this.v1 = v;
        return true;
    }
    /**
     * Return classification as ON, IN, or OUT according to hit and crossing counts.
     * * Any nonzero hit count is ON
     * * Otherwise IN if left crossing count is odd.
     * @return 0 if ON, 1 if IN, -1 if OUT
     */
    classifyCounts() {
        if (this.numHit > 0)
            return 0;
        const parity = this.numLeftCrossing & 0x01;
        return (parity === 1) ? 1 : -1;
    }
}
exports.XYParitySearchContext = XYParitySearchContext;


/***/ }),

/***/ "@bentley/bentleyjs-core":
/*!*********************************!*\
  !*** external "bentleyjs_core" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__;

/***/ })

},[["./lib/geometry-core.js","runtime"]]]);
});
//# sourceMappingURL=geometry-core.js.map