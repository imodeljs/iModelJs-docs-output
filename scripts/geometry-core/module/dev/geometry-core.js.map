{"version":3,"file":"geometry-core.js","sources":["file:///webpack/universalModuleDefinition","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\Constant.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\Geometry.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\bspline\\BSpline1dNd.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\bspline\\BSplineCurve.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\bspline\\BSplineCurve3dH.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\bspline\\BSplineSurface.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\bspline\\Bezier1dNd.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\bspline\\BezierCurve3d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\bspline\\BezierCurve3dH.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\bspline\\BezierCurveBase.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\bspline\\KnotVector.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\bspline\\SurfaceLocationDetail.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\clipping\\ClipPlane.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\clipping\\ClipPrimitive.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\clipping\\ClipUtils.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\clipping\\ClipVector.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\clipping\\ConvexClipPlaneSet.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\clipping\\UnionOfConvexClipPlaneSets.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\Arc3d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\ChainCollectorContext.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\ConstructCurveBetweenCurves.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CoordinateXYZ.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurveChainWithDistanceIndex.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurveCollection.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurveCurve.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurveCurveIntersectXY.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurveCurveIntersectXYZ.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurveExtendMode.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurveFactory.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurveLocationDetail.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurvePrimitive.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurveProcessor.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\CurveWireMomentsXYZ.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\GeometryQuery.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\LineSegment3d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\LineString3d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\Loop.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\ParityRegion.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\Path.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\PointString3d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\PolygonOffsetContext.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\Query\\ConsolidateAdjacentPrimitivesContext.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\Query\\CurveSplitContext.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\Query\\CylindricalRange.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\Query\\InOutTests.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\Query\\StrokeCountChain.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\Query\\StrokeCountMap.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\RegionMomentsXY.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\RegionOps.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\StrokeOptions.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\TransitionSpiral.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\curve\\UnionRegion.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry-core.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Angle.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\AngleSweep.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\BarycentricTriangle.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\BilinearPatch.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\FrameBuilder.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\FrustumAnimation.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\GeometryHandler.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\GrowableBlockedArray.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\GrowableFloat64Array.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\GrowableXYArray.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\GrowableXYZArray.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\IndexedCollectionInterval.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\IndexedXYCollection.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\IndexedXYZCollection.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Matrix3d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\OrderedRotationAngles.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Plane3dByOriginAndUnitNormal.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Plane3dByOriginAndVectors.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Point2dArrayCarrier.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Point2dVector2d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Point3dArrayCarrier.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Point3dVector3d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\PointHelpers.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\PointStreaming.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\PolygonOps.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\PolylineCompressionByEdgeOffset.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\PolylineOps.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Range.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Ray3d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Segment1d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\Transform.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry3d\\YawPitchRollAngles.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry4d\\Map4d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry4d\\Matrix4d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry4d\\MomentData.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry4d\\PlaneByOriginAndVectors4d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\geometry4d\\Point4d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\BezierPolynomials.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\ClusterableArray.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\Complex.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\ConvexPolygon2d.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\Newton.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\PascalCoefficients.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\Polynomials.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\Quadrature.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\Range1dArray.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\TriDiagonalSystem.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\UnionFind.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\numerics\\UsageSums.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\AuxData.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\BoxTopology.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\FacetFaceData.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\GreedyTriangulationBetweenLineStrings.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\IndexedEdgeMatcher.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\Polyface.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\PolyfaceBuilder.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\PolyfaceClip.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\PolyfaceData.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\PolyfaceQuery.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\RangeLengthData.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\TriangleCandidate.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\multiclip\\GriddedRaggedRange2dSet.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\multiclip\\GriddedRaggedRange2dSetWithOverflow.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\multiclip\\LinearSearchRange2dArray.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\multiclip\\RangeSearch.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\polyface\\multiclip\\XYPointBuckets.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\serialization\\DeepCompare.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\serialization\\GeometrySamples.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\serialization\\IModelJsonSchema.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\solid\\Box.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\solid\\Cone.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\solid\\LinearSweep.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\solid\\RotationalSweep.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\solid\\RuledSweep.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\solid\\SolidPrimitive.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\solid\\Sphere.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\solid\\SweepContour.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\solid\\TorusPipe.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\ChainMerge.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\Graph.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\HalfEdgeGraphSearch.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\HalfEdgeMarkSet.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\HalfEdgeNodeXYZUV.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\HalfEdgePointInGraphSearch.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\HalfEdgePositionDetail.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\HalfEdgePriorityQueue.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\InsertAndRetriangulateContext.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\MaskManager.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\Merging.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\RegularizeFace.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\SignedDataSummary.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\Triangulation.ts","file:///D:\\vsts_a\\3\\s\\core\\geometry\\src\\topology\\XYParitySearchContext.ts","file:///external \"bentleyjs_core\""],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"bentleyjs_core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"geometry_core\", [\"bentleyjs_core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"geometry_core\"] = factory(require(\"bentleyjs_core\"));\n\telse\n\t\troot[\"geometry_core\"] = factory(root[\"bentleyjs_core\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__) {\nreturn ","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module CartesianGeometry */\n\n/** Commonly used constant values.\n * @alpha\n */\nexport class Constant {\n  /** symbolic name for 1 millimeter:  0.001 meter */\n  public static readonly oneMillimeter: number = 0.001;\n  /** symbolic name for 1 centimeter:  0.01 meter */\n  public static readonly oneCentimeter: number = 0.01;\n  /** symbolic name for 1 meter:  1.0 meter */\n  public static readonly oneMeter: number = 1.0;\n  /** symbolic name for 1 kilometer: 1000 meter */\n  public static readonly oneKilometer: number = 1000.0;\n  /** Diameter of the earth in kilometers. */\n  public static readonly diameterOfEarth: number = 12742.0 * Constant.oneKilometer;\n  /** circumference of the earth in meters. */\n  public static readonly circumferenceOfEarth: number = 40075.0 * Constant.oneKilometer;\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty*/\r\nimport { Point2d, Vector2d, XY } from \"./geometry3d/Point2dVector2d\";\r\nimport { XAndY } from \"./geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d, XYZ } from \"./geometry3d/Point3dVector3d\";\r\nimport { Point4d } from \"./geometry4d/Point4d\";\r\nimport { AngleSweep } from \"./geometry3d/AngleSweep\";\r\n\r\n/** Enumeration of the 6 possible orderings of XYZ axis order\r\n * @public\r\n */\r\nexport enum AxisOrder {\r\n  /** Right handed system, X then Y then Z */\r\n  XYZ = 0,\r\n  /** Right handed system, Y then Z then X */\r\n  YZX = 1,\r\n  /** Right handed system, Z then X then Y */\r\n  ZXY = 2,\r\n  /** Left handed system, X then Z then Y */\r\n  XZY = 4,\r\n  /** Left handed system, Y then X then Z */\r\n  YXZ = 5,\r\n  /** Left handed system, Z then Y then X */\r\n  ZYX = 6,\r\n}\r\n/** Enumeration of numeric indices of 3 axes AxisIndex.X, AxisIndex.Y, AxisIndex.Z\r\n * @public\r\n */\r\nexport enum AxisIndex {\r\n  /** x axis is index 0 */\r\n  X = 0,\r\n  /** y axis is index 1 */\r\n  Y = 1,\r\n  /** 2 axis is index 2 */\r\n  Z = 2,\r\n}\r\n\r\n/** Standard views.   Used in `Matrix3d.createStandardViewAxes (index: StandardViewIndex, worldToView :boolean)`\r\n * @public\r\n */\r\nexport enum StandardViewIndex {\r\n  /** X to right, Y up */\r\n  Top = 1,\r\n  /** X to right, negative Y up */\r\n  Bottom = 2,\r\n  /** negative Y to right, Z up */\r\n  Left = 3,\r\n  /**  Y to right, Z up */\r\n  Right = 4,\r\n  /** X to right, Z up */\r\n  Front = 5,\r\n  /** negative X to right, Z up */\r\n  Back = 6,\r\n  /** View towards origin from (-1,-1,1) */\r\n  Iso = 7,\r\n  /** View towards origin from (1,-1,1) */\r\n  RightIso = 8,\r\n}\r\n\r\n/** Enumeration among choice for how a coordinate transformation should incorporate scaling.\r\n * @public\r\n */\r\nexport enum AxisScaleSelect {\r\n  /** All axes of unit length. */\r\n  Unit = 0,\r\n  /** On each axis, the vector length matches the longest side of the range of the data. */\r\n  LongestRangeDirection = 1,\r\n  /** On each axis, the vector length matches he length of the corresponding edge of the range. */\r\n  NonUniformRangeContainment = 2,\r\n}\r\n/** object with a radians value and its associated cosine and sine values.\r\n * @public\r\n */\r\nexport interface TrigValues {\r\n  /** the cosine value */\r\n  c: number;\r\n  /** the sine value */\r\n  s: number;\r\n  /** the radians value */\r\n  radians: number;\r\n}\r\n/**\r\n * Interface so various plane representations can be used by algorithms that just want altitude evaluations.\r\n *\r\n * Specific implementors are\r\n * * Plane3dByOriginAndUnitNormal\r\n * * Point4d (used for homogeneous plane coefficients)\r\n * @public\r\n */\r\nexport interface PlaneAltitudeEvaluator {\r\n  /**\r\n * Return the altitude of the point from the plane.\r\n * @param point point for evaluation\r\n */\r\n  altitude(point: Point3d): number;\r\n  /**\r\n     * Return the altitude of the point from the plane, with the point supplied as simple x,y,z\r\n     * @param x x coordinate\r\n     * @param y y coordinate\r\n     * @param z z coordinate\r\n     */\r\n  altitudeXYZ(x: number, y: number, z: number): number;\r\n  /**\r\n   * Return the derivative of altitude wrt motion along a vector.\r\n   * @param point point for evaluation\r\n   */\r\n  velocity(vector: Vector3d): number;\r\n\r\n  /**\r\n   * Return the derivative of altitude wrt motion along a vector given by components\r\n   * @param point point for evaluation\r\n   */\r\n  velocityXYZ(x: number, y: number, z: number): number;\r\n  /**\r\n   * Return the weighted altitude\r\n   * @param point xyzw data.\r\n   */\r\n  weightedAltitude(point: Point4d): number;\r\n}\r\n/**\r\n * Interface for `toJSON` and `setFromJSON` methods\r\n * @public\r\n */\r\nexport interface BeJSONFunctions {\r\n  /**\r\n   * Set content from a JSON object.\r\n   * If the json object is undefined or unrecognized, always set a default value.\r\n   */\r\n  setFromJSON(json: any): void;\r\n  /** Return a json object with this object's contents. */\r\n  toJSON(): any;\r\n}\r\n\r\n/** The Properties for a JSON representation of an Angle.\r\n * If value is a number, it is in *degrees*.\r\n * If value is an object, it can have either degrees or radians.\r\n * @public\r\n */\r\nexport type AngleProps = { degrees: number } | { radians: number } | { _radians: number } | { _degrees: number } | number;\r\n\r\n/** The Properties for a JSON representation of an AngleSweep.\r\n * * The json data is always start and end angles as a pair in an array.\r\n * If AngleProps data is an array of two numbers, it is an angle in degrees.\r\n * If the AngleProps is an object with key degrees, the degrees value must be an array with the two degrees angles as numbers\r\n * If the AngleProps is an object with key radians, the radians value must be an array with the two radians angles as numbers\r\n * @public\r\n */\r\nexport type AngleSweepProps =\r\n  AngleSweep |\r\n  { degrees: [number, number] } |\r\n  { radians: [number, number] } |\r\n  [number, number];\r\n\r\n/**\r\n * Class containing static methods for typical numeric operations.\r\n * * Experimentally, methods like Geometry.hypotenuse are observed to be faster than the system intrinsics.\r\n * * This is probably due to\r\n *    * Fixed length arg lists\r\n *    * strongly typed parameters\r\n * @public\r\n */\r\nexport class Geometry {\r\n  /** Tolerance for small distances in metric coordinates */\r\n  public static readonly smallMetricDistance = 1.0e-6;\r\n  /** Square of `smallMetricTolerance` */\r\n  public static readonly smallMetricDistanceSquared = 1.0e-12;\r\n  /** tolerance for small angle measured in radians. */\r\n  public static readonly smallAngleRadians = 1.0e-12;\r\n  /** square of `smallAngleRadians` */\r\n  public static readonly smallAngleRadiansSquared = 1.0e-24;\r\n  /** numeric value that may considered huge for numbers expected to be 0..1 fractions.\r\n   * * But note that the \"allowed\" result value is vastly larger than 1.\r\n   */\r\n  public static readonly largeFractionResult = 1.0e10;\r\n  /** numeric value that may considered huge for numbers expected to be coordinates.\r\n   * * This allows larger results than `largeFractionResult`.\r\n   */\r\n  public static readonly largeCoordinateResult = 1.0e13;\r\n  /** numeric value that may considered infinite for metric coordinates.\r\n   * * This coordinate should be used only as a placeholder indicating \"at infinity\" -- computing actual points at this coordinate invites numerical problems.\r\n   */\r\n  public static readonly hugeCoordinate = 1.0e12;\r\n  /** Test if absolute value of x is huge.\r\n   * * See `Geometry.hugeCoordinate`\r\n   */\r\n  public static isHugeCoordinate(x: number): boolean {\r\n    return x > this.hugeCoordinate || x < - this.hugeCoordinate;\r\n  }\r\n\r\n  /** Test if a number is odd.\r\n   */\r\n  public static isOdd(x: number): boolean {\r\n    return (x & (0x01)) === 1;\r\n  }\r\n  /** Radians value for full circle 2PI radians minus `smallAngleRadians` */\r\n  public static readonly fullCircleRadiansMinusSmallAngle = 2.0 * Math.PI - 1.0e-12;    // smallAngleRadians less than 360degrees\r\n  /** Correct `distance` to zero if smaller than metric tolerance.   Otherwise return it unchanged. */\r\n  public static correctSmallMetricDistance(distance: number, replacement: number = 0.0): number {\r\n    if (Math.abs(distance) < Geometry.smallMetricDistance) {\r\n      return replacement;\r\n    }\r\n    return distance;\r\n  }\r\n  /**\r\n * If `a` is large enough for safe division, return `1/a`, using Geometry.smallMetricDistance as the tolerance for declaring it as divide by zero.  Otherwise return `undefined`.\r\n * @param a denominator of division\r\n */\r\n  public static inverseMetricDistance(a: number): number | undefined { return (Math.abs(a) <= Geometry.smallMetricDistance) ? undefined : 1.0 / a; }\r\n  /**\r\n   * If `a` is large enough, return `1/a`, using the square of Geometry.smallMetricDistance as the tolerance for declaring it as divide by zero.  Otherwise return `undefined`.\r\n   * @param a denominator of division\r\n   */\r\n  public static inverseMetricDistanceSquared(a: number): number | undefined {\r\n    return (Math.abs(a) <= Geometry.smallMetricDistanceSquared) ? undefined : 1.0 / a;\r\n  }\r\n  /** Boolean test for metric coordinate near-equality */\r\n  public static isSameCoordinate(x: number, y: number, tol?: number): boolean {\r\n    if (tol)\r\n      return Math.abs(x - y) < Math.abs(tol);\r\n    return Math.abs(x - y) < Geometry.smallMetricDistance;\r\n  }\r\n  /** Boolean test for metric coordinate near-equality, with toleranceFactor applied to the usual smallMetricDistance */\r\n  public static isSameCoordinateWithToleranceFactor(x: number, y: number, toleranceFactor: number): boolean {\r\n    return Geometry.isSameCoordinate(x, y, toleranceFactor * Geometry.smallMetricDistance);\r\n  }\r\n\r\n  /** Boolean test for metric coordinate near-equality of x, y pair */\r\n  public static isSameCoordinateXY(x0: number, y0: number, x1: number, y1: number, tol: number = Geometry.smallMetricDistance): boolean {\r\n    let d = x1 - x0;\r\n    if (d < 0)\r\n      d = -d;\r\n    if (d > tol)\r\n      return false;\r\n    d = y1 - y0;\r\n    if (d < 0)\r\n      d = -d;\r\n    return d < tol;\r\n  }\r\n  /** Boolean test for squared metric coordinate near-equality */\r\n  public static isSameCoordinateSquared(x: number, y: number): boolean {\r\n    return Math.abs(Math.sqrt(x) - Math.sqrt(y)) < Geometry.smallMetricDistance;\r\n  }\r\n  /** boolean test for small `dataA.distance (dataB)`  within `smallMetricDistance` */\r\n  public static isSamePoint3d(dataA: Point3d, dataB: Point3d): boolean { return dataA.distance(dataB) < Geometry.smallMetricDistance; }\r\n  /** boolean test for distance between `XYZ` objects within `smallMetricDistance`\r\n   *  * Note that Point3d and Vector3d are both derived from XYZ, so this method tolerates mixed types.\r\n   */\r\n  public static isSameXYZ(dataA: XYZ, dataB: XYZ): boolean { return dataA.distance(dataB) < Geometry.smallMetricDistance; }\r\n  /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */\r\n  public static isSamePoint3dXY(dataA: Point3d, dataB: Point3d): boolean { return dataA.distanceXY(dataB) < Geometry.smallMetricDistance; }\r\n  /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */\r\n  public static isSameVector3d(dataA: Vector3d, dataB: Vector3d): boolean { return dataA.distance(dataB) < Geometry.smallMetricDistance; }\r\n  /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */\r\n  public static isSamePoint2d(dataA: Point2d, dataB: Point2d): boolean { return dataA.distance(dataB) < Geometry.smallMetricDistance; }\r\n  /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */\r\n  public static isSameVector2d(dataA: Vector2d, dataB: Vector2d): boolean { return dataA.distance(dataB) < Geometry.smallMetricDistance; }\r\n\r\n  /**\r\n   * Lexical comparison of (a.x,a.y) (b.x,b.y) with x as first test, y second.\r\n   * * This is appropriate for a horizontal sweep in the plane.\r\n   */\r\n  public static lexicalXYLessThan(a: XY | XYZ, b: XY | XYZ): -1 | 0 | 1 {\r\n    if (a.x < b.x)\r\n      return -1;\r\n    else if (a.x > b.x)\r\n      return 1;\r\n    if (a.y < b.y)\r\n      return -1;\r\n    else if (a.y > b.y)\r\n      return 1;\r\n    return 0;\r\n  }\r\n  /**\r\n   * Lexical comparison of (a.x,a.y) (b.x,b.y) with y as first test, x second.\r\n   * * This is appropriate for a vertical sweep in the plane.\r\n   */\r\n  public static lexicalYXLessThan(a: XY | XYZ, b: XY | XYZ): -1 | 0 | 1 {\r\n    if (a.y < b.y)\r\n      return -1;\r\n    else if (a.y > b.y)\r\n      return 1;\r\n    if (a.x < b.x)\r\n      return -1;\r\n    else if (a.x > b.x)\r\n      return 1;\r\n    return 0;\r\n  }\r\n  /**\r\n   * Lexical test, based on x first, y second, z third.\r\n   */\r\n  public static lexicalXYZLessThan(a: XYZ, b: XYZ): -1 | 0 | 1 {\r\n    if (a.x < b.x)\r\n      return -1;\r\n    else if (a.x > b.x)\r\n      return 1;\r\n    if (a.y < b.y)\r\n      return -1;\r\n    else if (a.y > b.y)\r\n      return 1;\r\n    if (a.z < b.z)\r\n      return -1;\r\n    else if (a.z > b.z)\r\n      return 1;\r\n    return 0;\r\n  }\r\n  /** Test if `value` is small compared to `smallAngleRadians`.\r\n   * * This is appropriate if `value` is know to be a typical 0..1 fraction.\r\n   */\r\n  public static isSmallRelative(value: number): boolean { return Math.abs(value) < Geometry.smallAngleRadians; }\r\n  /** Test if `value` is small compared to `smallAngleRadians` */\r\n  public static isSmallAngleRadians(value: number): boolean { return Math.abs(value) < Geometry.smallAngleRadians; }\r\n  /** Toleranced equality test, using tolerance `smallAngleRadians * ( 1 + abs(a) + (abs(b)))`\r\n   * * Effectively an absolute tolerance of `smallAngleRadians`, with tolerance increasing for larger values of a and b.\r\n  */\r\n  public static isAlmostEqualNumber(a: number, b: number): boolean {\r\n    const sumAbs = 1.0 + Math.abs(a) + Math.abs(b);\r\n    return Math.abs(a - b) <= Geometry.smallAngleRadians * sumAbs;\r\n  }\r\n  /** Toleranced equality test, using caller-supplied tolerance. */\r\n  public static isDistanceWithinTol(distance: number, tol: number): boolean {\r\n    return Math.abs(distance) <= Math.abs(tol);\r\n  }\r\n  /** Toleranced equality test, using `smallMetricDistance` tolerance. */\r\n  public static isSmallMetricDistance(distance: number): boolean {\r\n    return Math.abs(distance) <= Geometry.smallMetricDistance;\r\n  }\r\n  /** Toleranced equality, using `smallMetricDistanceSquared` tolerance. */\r\n  public static isSmallMetricDistanceSquared(distanceSquared: number): boolean {\r\n    return Math.abs(distanceSquared) <= Geometry.smallMetricDistanceSquared;\r\n  }\r\n  /** Return `axis modulo 3` with proper handling of negative indices (-1 is z), -2 is y, -3 is x etc) */\r\n  public static cyclic3dAxis(axis: number): number {\r\n    /* Direct test for the most common cases, avoid modulo */\r\n    if (axis >= 0) {\r\n      if (axis < 3)\r\n        return axis;\r\n      if (axis < 6)\r\n        return axis - 3;\r\n      return axis % 3;\r\n    }\r\n    const j = axis + 3;\r\n    if (j >= 0)\r\n      return j;\r\n    return 2 - ((-axis - 1) % 3);\r\n  }\r\n  /** Return the AxisOrder for which axisIndex is the first named axis.\r\n   * * `axisIndex===0`returns AxisOrder.XYZ\r\n   * * `axisIndex===1`returns AxisOrder.YZX\r\n   * * `axisIndex===2`returns AxisOrder.ZXY\r\n   */\r\n  public static axisIndexToRightHandedAxisOrder(axisIndex: AxisIndex): AxisOrder {\r\n    if (axisIndex === 0) return AxisOrder.XYZ;\r\n    if (axisIndex === 1) return AxisOrder.YZX;\r\n    if (axisIndex === 2) return AxisOrder.ZXY;\r\n    return Geometry.axisIndexToRightHandedAxisOrder(Geometry.cyclic3dAxis(axisIndex));\r\n  }\r\n  /** Return the largest absolute distance from a to either of b0 or b1 */\r\n  public static maxAbsDiff(a: number, b0: number, b1: number): number { return Math.max(Math.abs(a - b0), Math.abs(a - b1)); }\r\n  /** Return the largest absolute absolute value among x,y,z */\r\n  public static maxAbsXYZ(x: number, y: number, z: number): number {\r\n    return Geometry.maxXYZ(Math.abs(x), Math.abs(y), Math.abs(z));\r\n  }\r\n  /** Return the largest absolute absolute value among x,y */\r\n  public static maxAbsXY(x: number, y: number): number {\r\n    return Geometry.maxXY(Math.abs(x), Math.abs(y));\r\n  }\r\n\r\n  /** Return the largest signed value among a, b, c */\r\n  public static maxXYZ(a: number, b: number, c: number): number {\r\n    let q = a;\r\n    if (b > q) q = b;\r\n    if (c > q) q = c;\r\n    return q;\r\n  }\r\n  /** Examine the value (particularly sign) of x.\r\n   * * If x is negative, return outNegative.\r\n   * * If x is true zero, return outZero\r\n   * * If x is positive, return outPositive\r\n   */\r\n  public static split3WaySign(x: number, outNegative: number, outZero: number, outPositive: number): number {\r\n    if (x < 0)\r\n      return outNegative;\r\n    if (x > 0.0)\r\n      return outPositive;\r\n    return outZero;\r\n  }\r\n\r\n  /** Return the largest signed value among a, b */\r\n  public static maxXY(a: number, b: number): number {\r\n    let q = a;\r\n    if (b > q) q = b;\r\n    return q;\r\n  }\r\n\r\n  /** Return the smallest signed value among a, b */\r\n  public static minXY(a: number, b: number): number {\r\n    let q = a;\r\n    if (b < q) q = b;\r\n    return q;\r\n  }\r\n  /** Return the hypotenuse `sqrt(x*x + y*y)`. This is much faster than `Math.hypot(x,y)`. */\r\n  public static hypotenuseXY(x: number, y: number): number { return Math.sqrt(x * x + y * y); }\r\n  /** Return the squared `hypotenuse (x*x + y*y)`. */\r\n  public static hypotenuseSquaredXY(x: number, y: number): number { return x * x + y * y; }\r\n  /** Return the square of x */\r\n  public static square(x: number): number { return x * x; }\r\n\r\n  /** Return the hypotenuse `sqrt(x*x + y*y + z*z)`. This is much faster than `Math.hypot(x,y,z)`. */\r\n  public static hypotenuseXYZ(x: number, y: number, z: number): number { return Math.sqrt(x * x + y * y + z * z); }\r\n  /** Return the squared hypotenuse `(x*x + y*y + z*z)`. This is much faster than `Math.hypot(x,y,z)`. */\r\n  public static hypotenuseSquaredXYZ(x: number, y: number, z: number): number { return x * x + y * y + z * z; }\r\n  /** Return the (full 4d) hypotenuse `sqrt(x*x + y*y + z*z + w*w)`. This is much faster than `Math.hypot(x,y,z,w)`. */\r\n  public static hypotenuseXYZW(x: number, y: number, z: number, w: number): number { return Math.sqrt(x * x + y * y + z * z + w * w); }\r\n  /** Return the squared hypotenuse `(x*x + y*y + z*z+w*w)`. This is much faster than `Math.hypot(x,y,z)`. */\r\n  public static hypotenuseSquaredXYZW(x: number, y: number, z: number, w: number): number { return x * x + y * y + z * z + w * w; }\r\n  /**\r\n   * Return the distance between xy points given as numbers.\r\n   * @param x0 x coordinate of point 0\r\n   * @param y0 y coordinate of point 0\r\n   * @param x1 x coordinate of point 1\r\n   * @param y1 y coordinate of point 1\r\n   */\r\n  public static distanceXYXY(x0: number, y0: number, x1: number, y1: number): number {\r\n    return Geometry.hypotenuseXY(x1 - x0, y1 - y0);\r\n  }\r\n  /**\r\n   * Return the distance between xyz points given as numbers.\r\n   * @param x0 x coordinate of point 0\r\n   * @param y0 y coordinate of point 0\r\n   * @param z0 z coordinate of point 0\r\n   * @param x1 x coordinate of point 1\r\n   * @param y1 y coordinate of point 1\r\n   * @param z1 z coordinate of point 1\r\n   */\r\n  public static distanceXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): number {\r\n    return Geometry.hypotenuseXYZ(x1 - x0, y1 - y0, z1 - z0);\r\n  }\r\n  /** Returns Returns the triple product of 3 vectors provided as x,y,z number sequences.\r\n   *\r\n   * * The triple product is the determinant of the 3x3 matrix with the 9 numbers placed in either row or column order.\r\n   * * The triple product is positive if the 3 vectors form a right handed coordinate system.\r\n   * * The triple product is negative if the 3 vectors form a left handed coordinate system.\r\n   * * Treating the 9 numbers as 3 vectors U, V, W, any of these formulas gives the same result:\r\n   *\r\n   * ** U dot (V cross W)\r\n   * ** V dot (W cross U)\r\n   * ** W dot (U cross V)\r\n   * **  (-U dot (W cross V))  -- (note the negative -- reversing cross product order changes the sign)\r\n   * ** (-V dot (U cross W)) -- (note the negative -- reversing cross product order changes the sign)\r\n   * ** (-W dot (V cross U)) -- (note the negative -- reversing cross product order changes the sign)\r\n   * * the triple product is 6 times the (signed) volume of the tetrahedron with the three vectors as edges from a common vertex.\r\n   */\r\n  public static tripleProduct(\r\n    ux: number, uy: number, uz: number,\r\n    vx: number, vy: number, vz: number,\r\n    wx: number, wy: number, wz: number): number {\r\n    return ux * (vy * wz - vz * wy)\r\n      + uy * (vz * wx - vx * wz)\r\n      + uz * (vx * wy - vy * wx);\r\n  }\r\n  /** Returns the determinant of the 4x4 matrix unrolled as the 16 parameters.\r\n   */\r\n  public static determinant4x4(\r\n    xx: number, xy: number, xz: number, xw: number,\r\n    yx: number, yy: number, yz: number, yw: number,\r\n    zx: number, zy: number, zz: number, zw: number,\r\n    wx: number, wy: number, wz: number, ww: number): number {\r\n    return xx * this.tripleProduct(yy, yz, yw, zy, zz, zw, wy, wz, ww)\r\n      - yx * this.tripleProduct(xy, xz, xw, zy, zz, zw, wy, wz, ww)\r\n      + zx * this.tripleProduct(xy, xz, xw, yy, yz, yw, wy, wz, ww)\r\n      - wx * this.tripleProduct(xy, xz, xw, yy, yz, yw, zy, zz, zw);\r\n  }\r\n\r\n  /**\r\n * Returns curvature magnitude from a first and second derivative vector.\r\n * @param ux  first derivative x component\r\n * @param uy first derivative y component\r\n * @param uz first derivative z component\r\n * @param vx second derivative x component\r\n * @param vy second derivative y component\r\n * @param vz second derivative z component\r\n */\r\n  public static curvatureMagnitude(\r\n    ux: number, uy: number, uz: number,\r\n    vx: number, vy: number, vz: number): number {\r\n    let q = uy * vz - uz * vy;\r\n    let sum = q * q;\r\n    q = uz * vx - ux * vz;\r\n    sum += q * q;\r\n    q = ux * vy - uy * vx;\r\n    sum += q * q;\r\n    const a = Math.sqrt(ux * ux + uy * uy + uz * uz);\r\n    const b = Math.sqrt(sum);\r\n    // (sum and a are both nonnegative)\r\n    const aaa = a * a * a;\r\n    // radius of curvature = aaa / b;\r\n    // curvature = b/aaa\r\n    const tol = Geometry.smallAngleRadians;\r\n    if (aaa > tol * b)\r\n      return b / aaa;\r\n    return 0; // hm.. maybe should be infinite?\r\n  }\r\n\r\n  /** Returns the determinant of 3x3 matrix with x and y rows taken from 3 points, third row from corresponding numbers.\r\n   *\r\n   */\r\n  public static tripleProductXYW(\r\n    columnA: XAndY, weightA: number,\r\n    columnB: XAndY, weightB: number,\r\n    columnC: XAndY, weightC: number): number {\r\n    return Geometry.tripleProduct(\r\n      columnA.x, columnB.x, columnC.x,\r\n      columnA.y, columnB.y, columnC.y,\r\n      weightA, weightB, weightC);\r\n  }\r\n\r\n  /** Returns the determinant of 3x3 matrix with x and y rows taken from 3 points, third row from corresponding numbers.\r\n   *\r\n   */\r\n  public static tripleProductPoint4dXYW(\r\n    columnA: Point4d,\r\n    columnB: Point4d,\r\n    columnC: Point4d): number {\r\n    return Geometry.tripleProduct(\r\n      columnA.x, columnB.x, columnC.x,\r\n      columnA.y, columnB.y, columnC.y,\r\n      columnA.w, columnB.w, columnC.w);\r\n  }\r\n  /** 2D cross product of vectors layed out as scalars. */\r\n  public static crossProductXYXY(ux: number, uy: number, vx: number, vy: number): number {\r\n    return ux * vy - uy * vx;\r\n  }\r\n\r\n  /** 3D cross product of vectors layed out as scalars. */\r\n  public static crossProductXYZXYZ(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(\r\n      uy * vz - uz * vy,\r\n      uz * vx - ux * vz,\r\n      ux * vy - uy * vx, result);\r\n  }\r\n\r\n  /** magnitude of 3D cross product of vectors, with the vectors presented as */\r\n  public static crossProductMagnitude(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): number {\r\n    return Geometry.hypotenuseXYZ(\r\n      uy * vz - uz * vy,\r\n      uz * vx - ux * vz,\r\n      ux * vy - uy * vx);\r\n  }\r\n  /** 3D dot product of vectors layed out as scalars. */\r\n  public static dotProductXYZXYZ(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): number {\r\n    return ux * vx + uy * vy + uz * vz;\r\n  }\r\n  /** 2D dot product of vectors layed out as scalars. */\r\n  public static dotProductXYXY(ux: number, uy: number, vx: number, vy: number): number {\r\n    return ux * vx + uy * vy;\r\n  }\r\n  /**\r\n   * Clamp to (min(a,b), max(a,b))\r\n   * @param x\r\n   * @param a\r\n   * @param b\r\n   */\r\n  public static clampToStartEnd(x: number, a: number, b: number): number {\r\n    if (a > b)\r\n      return Geometry.clampToStartEnd(x, b, a);\r\n    if (x < a)\r\n      return a;\r\n    if (b < x)\r\n      return b;\r\n    return x;\r\n  }\r\n  /**\r\n   * Clamp value to (min,max) with no test for order of (min,max)\r\n   * @param value value to clamp\r\n   * @param min smallest allowed output\r\n   * @param max largest allowed result.\r\n   */\r\n  public static clamp(value: number, min: number, max: number): number { return Math.max(min, Math.min(max, value)); }\r\n  /** If given a number, return it.   If given undefined, return `defaultValue`. */\r\n  public static resolveNumber(value: number | undefined, defaultValue: number = 0): number {\r\n    return value !== undefined ? value : defaultValue;\r\n  }\r\n  /** simple interpolation between values, but choosing (based on fraction) a or b as starting point for maximum accuracy. */\r\n  public static interpolate(a: number, f: number, b: number): number {\r\n    return f <= 0.5 ? a + f * (b - a) : b - (1.0 - f) * (b - a);\r\n  }\r\n\r\n  /** given an axisOrder (e.g. XYZ, YZX, ZXY, XZYLeftHanded etc) and an (integer) offset, resolve to an axis index. */\r\n  public static axisOrderToAxis(order: AxisOrder, index: number): number {\r\n    const axis = order <= AxisOrder.ZXY ? order + index : (order - AxisOrder.XZY) - index;\r\n    return Geometry.cyclic3dAxis(axis);\r\n  }\r\n  /** Return (a modulo period), e.g. for use as a cyclic index.  Both a and period may be negative. */\r\n  public static modulo(a: number, period: number): number {\r\n    if (period <= 0) {\r\n      if (period === 0)\r\n        return a;\r\n      return -Geometry.modulo(-a, -period);\r\n    }\r\n\r\n    if (a >= 0) {\r\n      if (a < period)\r\n        return a;\r\n      if (a < 2 * period)\r\n        return a - period;\r\n    } else {\r\n      a += period;  // hopefully move into primary period without division and floor\r\n      if (a > 0)\r\n        return a;\r\n    }\r\n    const m = Math.floor(a / period);\r\n    return a - m * period;\r\n  }\r\n  /** return 0 if the value is undefined, 1 if defined. */\r\n  public static defined01(value: any): number { return value === undefined ? 0 : 1; }\r\n  /** normally, return numerator/denominator.\r\n   * but if the ratio would exceed Geometry.largeFractionResult, return undefined.\r\n   */\r\n  public static conditionalDivideFraction(numerator: number, denominator: number): number | undefined {\r\n    if (Math.abs(denominator) * Geometry.largeFractionResult > Math.abs(numerator))\r\n      return numerator / denominator;\r\n    return undefined;\r\n  }\r\n\r\n  /** normally, return numerator/denominator.\r\n   * but if the ratio would exceed Geometry.largestResult, return undefined.\r\n   */\r\n  public static conditionalDivideCoordinate(numerator: number, denominator: number, largestResult: number = Geometry.largeCoordinateResult): number | undefined {\r\n    if (Math.abs(denominator * largestResult) > Math.abs(numerator))\r\n      return numerator / denominator;\r\n    return undefined;\r\n  }\r\n\r\n  /** return the 0, 1, or 2 pairs of (c,s) values that solve\r\n   * {constCoff + cosCoff * c + sinCoff * s = }\r\n   * with the constraint {c*c+s*s = 1}\r\n   */\r\n  public static solveTrigForm(constCoff: number, cosCoff: number, sinCoff: number): Vector2d[] | undefined {\r\n    {\r\n      const delta2 = cosCoff * cosCoff + sinCoff * sinCoff;\r\n      const constCoff2 = constCoff * constCoff;\r\n      // let nSolution = 0;\r\n      let result;\r\n      if (delta2 > 0.0) {\r\n        const lambda = - constCoff / delta2;\r\n        const a2 = constCoff2 / delta2;\r\n        const D2 = 1.0 - a2;\r\n        if (D2 >= 0.0) {\r\n          const mu = Math.sqrt(D2 / delta2);\r\n          /* c0,s0 = closest approach of line to origin */\r\n          const c0 = lambda * cosCoff;\r\n          const s0 = lambda * sinCoff;\r\n          // nSolution = 2;\r\n          result = [Vector2d.create(c0 - mu * sinCoff, s0 + mu * cosCoff), Vector2d.create(c0 + mu * sinCoff, s0 - mu * cosCoff)];\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /** normally,  return the number result of conditionalDivideFraction.\r\n   * but if conditionalDivideFraction fails return specified default number.\r\n   */\r\n  public static safeDivideFraction(numerator: number, denominator: number, defaultResult: number): number {\r\n    const a = Geometry.conditionalDivideFraction(numerator, denominator);\r\n    if (a !== undefined)\r\n      return a;\r\n    return defaultResult;\r\n  }\r\n  /** For a line f(x) whose function values at x0 and x1 are f0 and f1, return the x value at which f(x)=fTarget;\r\n   */\r\n  public static inverseInterpolate(x0: number, f0: number, x1: number, f1: number,\r\n    targetF: number = 0,\r\n    defaultResult?: number): number | undefined {\r\n    const g = Geometry.conditionalDivideFraction(targetF - f0, f1 - f0);\r\n    if (g)\r\n      return Geometry.interpolate(x0, g, x1);\r\n    return defaultResult;\r\n  }\r\n  /** For a line f(x) whose function values at x=0 and x=1 are f0 and f1, return the x value at which f(x)=fTarget;\r\n   */\r\n  public static inverseInterpolate01(f0: number, f1: number, targetF: number = 0): number | undefined {\r\n    return Geometry.conditionalDivideFraction(targetF - f0, f1 - f0);\r\n  }\r\n  /** Return true if json is an array with at least minEntries, and all entries are numbers (including those beyond minEntries) */\r\n  public static isNumberArray(json: any, minEntries: number = 0): boolean {\r\n    if (Array.isArray(json) && json.length >= minEntries) {\r\n      let entry;\r\n      for (entry of json) {\r\n        //        if (!(entry as number) && entry !== 0.0)\r\n        if (!Number.isFinite(entry))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** Return true if json is an array of at least numNumberArrays, with at least minEntries in each number array.\r\n   */\r\n  public static isArrayOfNumberArray(json: any, numNumberArray: number, minEntries: number = 0): boolean {\r\n    if (Array.isArray(json) && json.length >= numNumberArray) {\r\n      let entry;\r\n      for (entry of json)\r\n        if (!Geometry.isNumberArray(entry, minEntries)) return false;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** return the number of steps to take so that numSteps * stepSize >= total.\r\n   * minCount is returned for both (a) setSize 0 or less and (b) stepSize > total.\r\n   * A small tolerance is applied for almost\r\n  */\r\n  public static stepCount(stepSize: number, total: number, minCount = 1, maxCount = 101): number {\r\n    if (stepSize <= 0)\r\n      return minCount;\r\n    if (stepSize >= total)\r\n      return minCount;\r\n    const stepCount = Math.floor((total + 0.999999 * stepSize) / stepSize);\r\n    if (stepCount < minCount)\r\n      return minCount;\r\n    if (stepCount > maxCount)\r\n      return maxCount;\r\n    return stepCount;\r\n  }\r\n  /** Test if x is in simple 0..1 interval.  But optionally skip the test.  (this odd behavior is very convenient for code that sometimes does not do the filtering.)\r\n   * @param x value to test.\r\n   * @param apply01 if false, accept all x.\r\n   */\r\n  public static isIn01(x: number, apply01: boolean = true): boolean { return apply01 ? x >= 0.0 && x <= 1.0 : true; }\r\n  /** Test if x is in simple 0..1 interval.  But optionally skip the test.  (this odd behavior is very convenient for code that sometimes does not do the filtering.)\r\n   * @param x value to test.\r\n   * @param apply01 if false, accept all x.\r\n   */\r\n  public static isIn01WithTolerance(x: number, tolerance: number): boolean { return x + tolerance >= 0.0 && x - tolerance <= 1.0; }\r\n  /**\r\n   * restrict x so it is in the interval `[a,b]`, allowing a,b to be in either order.\r\n   * @param x\r\n   * @param a (usually the lower) interval limit\r\n   * @param b (usually the upper) interval limit\r\n   */\r\n  public static restrictToInterval(x: number, a: number, b: number): number {\r\n    if (a <= b) {\r\n      if (x < a) return a;\r\n      if (x > b) return b;\r\n      return x;\r\n    }\r\n    // reversed interval ....\r\n    if (x < b) return b;\r\n    if (x > a) return a;\r\n    return x;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"../Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { KnotVector, BSplineWrapMode } from \"./KnotVector\";\r\nimport { Geometry } from \"../Geometry\";\r\n\r\n/** Bspline knots and poles for 1d-to-Nd.\r\n * * The \"pole\" (aka control point) of this class is a block of `poleLength` numbers.\r\n * * Derived classes (not this class) assign meaning such as x,y,z,w.\r\n * * for instance, an instance of this class with `poleLength===3` does not know if its poles are x,y,z or weighed 2D x,y,w\r\n * @public\r\n */\r\nexport class BSpline1dNd {\r\n  /** knots of the bspline */\r\n  public knots: KnotVector;\r\n  /** poles, packed in blocks of `poleLength` doubles. */\r\n  public packedData: Float64Array;\r\n  /** (property accessor) Return the number of numeric values per pole. */\r\n  public poleLength: number;\r\n  /** (property accessor) Return the degree of the polynomials. */\r\n  public get degree(): number { return this.knots.degree; }\r\n  /** (property accessor) Return the number of order (one more than degree) of the polynomials */\r\n  public get order(): number { return this.knots.degree + 1; }\r\n  /** (property accessor) Return the number of bezier spans (including null spans at multiple knots)*/\r\n  public get numSpan(): number { return this.numPoles - this.knots.degree; }\r\n  /** (property accessor)  Return the number of poles*/\r\n  public get numPoles(): number { return this.packedData.length / this.poleLength; }\r\n  /** copy 3 values of pole `i` into a point.\r\n   * * The calling clas sis responsible for knowing if this is an appropriate access to the blocked data.\r\n   */\r\n  public getPoint3dPole(i: number, result?: Point3d): Point3d | undefined { return Point3d.createFromPacked(this.packedData, i, result); }\r\n  /** preallocated array (length === `order`) used as temporary in evaluations */\r\n  public basisBuffer: Float64Array; // one set of basis function values.   ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** preallocated array (length === `poleLength`) used as temporary in evaluations */\r\n  public poleBuffer: Float64Array; // one set of target values.  ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** preallocated array (length === `order`) used as temporary in evaluations */\r\n  public basisBuffer1: Float64Array; // one set of basis function values.   ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** preallocated array (length === `order`) used as temporary in evaluations */\r\n  public basisBuffer2: Float64Array; // one set of basis function values.   ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** preallocated array (length === `poleLength`) used as temporary in evaluations */\r\n  public poleBuffer1: Float64Array; // one set of target values.  ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** preallocated array (length === `poleLength`) used as temporary in evaluations */\r\n  public poleBuffer2: Float64Array; // one set of target values.  ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n\r\n  /**\r\n   * initialize arrays for given spline dimensions.\r\n   * @param numPoles number of poles\r\n   * @param poleLength number of coordinates per pole (e.g.. 3 for 3D unweighted, 4 for 3d weighted, 2 for 2d unweighted, 3 for 2d weighted)\r\n   * @param order number of poles in support for a section of the bspline\r\n   * @param knots KnotVector.  This is captured, not cloned.\r\n   */\r\n  protected constructor(numPoles: number, poleLength: number, order: number, knots: KnotVector) {\r\n    this.knots = knots;\r\n    this.packedData = new Float64Array(numPoles * poleLength);\r\n    this.poleLength = poleLength;\r\n    this.basisBuffer = new Float64Array(order);\r\n    this.poleBuffer = new Float64Array(poleLength);\r\n    this.basisBuffer1 = new Float64Array(order);\r\n    this.basisBuffer2 = new Float64Array(order);\r\n    this.poleBuffer1 = new Float64Array(poleLength);\r\n    this.poleBuffer2 = new Float64Array(poleLength);\r\n  }\r\n\r\n  /**\r\n   * create a 1Bspline1dNd`\r\n   * @param numPoles number of poles\r\n   * @param poleLength number of coordinates per pole (e.g.. 3 for 3D unweighted, 4 for 3d weighted, 2 for 2d unweighted, 3 for 2d weighted)\r\n   * @param order number of poles in support for a section of the bspline\r\n   * @param knots KnotVector.  This is captured, not cloned.\r\n   */\r\n  public static create(numPoles: number, poleLength: number, order: number, knots: KnotVector): BSpline1dNd | undefined {\r\n    return new BSpline1dNd(numPoles, poleLength, order, knots);\r\n  }\r\n  /** Map a span index and local fraction to knot value. */\r\n  public spanFractionToKnot(span: number, localFraction: number): number {\r\n    return this.knots.spanFractionToKnot(span, localFraction);\r\n  }\r\n\r\n  /** Evaluate the `order` basis functions (and optionally one or two derivatives) at a given fractional position within indexed span. */\r\n  public evaluateBasisFunctionsInSpan(spanIndex: number, spanFraction: number, f: Float64Array, df?: Float64Array, ddf?: Float64Array) {\r\n    if (spanIndex < 0) spanIndex = 0;\r\n    if (spanIndex >= this.numSpan) spanIndex = this.numSpan - 1;\r\n    const knotIndex0 = spanIndex + this.degree - 1;\r\n    const globalKnot = this.knots.baseKnotFractionToKnot(knotIndex0, spanFraction);\r\n    return df ?\r\n      this.knots.evaluateBasisFunctions1(knotIndex0, globalKnot, f, df, ddf) :\r\n      this.knots.evaluateBasisFunctions(knotIndex0, globalKnot, f);\r\n  }\r\n  /**\r\n   * * Evaluate the basis functions at spanIndex and fraction.\r\n   *   * Evaluations are stored in the preallocated `this.basisBuffer`\r\n   * * Immediately do the summations of the basis values times the respective control points\r\n   *   * Summations are stored in the preallocated `this.poleBuffer`\r\n   * */\r\n  public evaluateBuffersInSpan(spanIndex: number, spanFraction: number) {\r\n    this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer);\r\n    this.sumPoleBufferForSpan(spanIndex);\r\n  }\r\n  /**\r\n   * * Evaluate the basis functions and one derivative at spanIndex and fraction.\r\n   *   * Evaluations are stored in the preallocated `this.basisBuffer`\r\n   * * Immediately do the summations of the basis values times the respective control points\r\n   *   * Summations are stored in the preallocated `this.poleBuffer` and `this.poleBuffer`\r\n   * */\r\n  public evaluateBuffersInSpan1(spanIndex: number, spanFraction: number) {\r\n    this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer, this.basisBuffer1);\r\n    this.sumPoleBufferForSpan(spanIndex);\r\n    this.sumPoleBuffer1ForSpan(spanIndex);\r\n  }\r\n  /** sum poles at span `spanIndex` by the weights in the `poleBuffer` */\r\n  public sumPoleBufferForSpan(spanIndex: number) {\r\n    this.poleBuffer.fill(0);\r\n    let k = spanIndex * this.poleLength;\r\n    for (const f of this.basisBuffer) {\r\n      for (let j = 0; j < this.poleLength; j++) { this.poleBuffer[j] += f * this.packedData[k++]; }\r\n    }\r\n  }\r\n  /** sum poles at span `spanIndex` by the weights in the `poleBuffer1`, i.e. form first derivatives */\r\n  public sumPoleBuffer1ForSpan(spanIndex: number) {\r\n    this.poleBuffer1.fill(0);\r\n    let k = spanIndex * this.poleLength;\r\n    for (const f of this.basisBuffer1) {\r\n      for (let j = 0; j < this.poleLength; j++) {\r\n        this.poleBuffer1[j] += f * this.packedData[k++];\r\n      }\r\n    }\r\n  }\r\n  /** sum poles at span `spanIndex` by the weights in the `poleBuffer2`, i.e. form second derivatives */\r\n  public sumPoleBuffer2ForSpan(spanIndex: number) {\r\n    this.poleBuffer2.fill(0);\r\n    let k = spanIndex * this.poleLength;\r\n    for (const f of this.basisBuffer2) {\r\n      for (let j = 0; j < this.poleLength; j++) {\r\n        this.poleBuffer2[j] += f * this.packedData[k++];\r\n      }\r\n    }\r\n  }\r\n  /** Evaluate the function values and 1 or 2 derivatives into `this.poleBuffer`, `this.poleBuffer1` and `this.poleBuffer2` */\r\n  public evaluateBuffersAtKnot(u: number, numDerivative: number = 0) {\r\n    const knotIndex0 = this.knots.knotToLeftKnotIndex(u);\r\n    if (numDerivative < 1) {\r\n      this.knots.evaluateBasisFunctions(knotIndex0, u, this.basisBuffer);\r\n      this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);\r\n    } else if (numDerivative === 1) {\r\n      this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1);\r\n      this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);\r\n      this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);\r\n    } else {\r\n      this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1, this.basisBuffer2);\r\n      this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);\r\n      this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);\r\n      this.sumPoleBuffer2ForSpan(knotIndex0 - this.degree + 1);\r\n    }\r\n  }\r\n  /**\r\n   * Reverse the (blocked) poles (in `this.packedData` in place.\r\n   */\r\n  public reverseInPlace(): void {\r\n    // reverse poles in blocks ...\r\n    const b = this.poleLength;\r\n    const data = this.packedData;\r\n    for (let i0 = 0, j0 = b * (this.numPoles - 1);\r\n      i0 < j0;\r\n      i0 += b, j0 -= b) {\r\n      let t = 0;\r\n      for (let i = 0; i < b; i++) {\r\n        t = data[i0 + i];\r\n        data[i0 + i] = data[j0 + i];\r\n        data[j0 + i] = t;\r\n      }\r\n    }\r\n    this.knots.reflectKnots();\r\n  }\r\n  /**\r\n   * Test if the leading and trailing polygon coordinates are replicated in the manner of a \"closed\" bspline polygon which has been expanded\r\n   * to act as a normal bspline.\r\n   * @returns true if `degree` leading and trailing polygon blocks match\r\n   */\r\n  public testCloseablePolygon(mode?: BSplineWrapMode): boolean {\r\n    if (mode === undefined)\r\n      mode = this.knots.wrappable;\r\n    const degree = this.degree;\r\n    const blockSize = this.poleLength;\r\n    const indexDelta = (this.numPoles - this.degree) * blockSize;\r\n    const data = this.packedData;\r\n    if (mode === BSplineWrapMode.OpenByAddingControlPoints) {\r\n      // expect {degree} matched points.\r\n      const numValuesToTest = degree * blockSize;\r\n      for (let i0 = 0; i0 < numValuesToTest; i0++) {\r\n        if (!Geometry.isSameCoordinate(data[i0], data[i0 + indexDelta]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    if (mode === BSplineWrapMode.OpenByRemovingKnots) {\r\n      // no pole conditions are applied.\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"../Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d, Range1d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\n\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\r\nimport { CurveLocationDetail, CurveIntervalRole } from \"../curve/CurveLocationDetail\";\r\n\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Geometry, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { KnotVector, BSplineWrapMode } from \"./KnotVector\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\r\nimport { BezierCurveBase } from \"./BezierCurveBase\";\r\nimport { BezierCurve3dH } from \"./BezierCurve3dH\";\r\nimport { BezierCurve3d } from \"./BezierCurve3d\";\r\nimport { BSpline1dNd } from \"./BSpline1dNd\";\r\nimport { UnivariateBezier } from \"../numerics/BezierPolynomials\";\r\nimport { Bezier1dNd } from \"./Bezier1dNd\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n\r\n/**\r\n * Base class for BSplineCurve3d and BSplineCurve3dH.\r\n * * A bspline curve consists of a set of knots and a set of poles.\r\n * * The bspline curve is a function of the independent \"knot axis\" variable\r\n * * The curve \"follows\" the poles loosely.\r\n * * The is a set of polynomial spans.\r\n * * The polynomial spans all have same `degree`.\r\n * * Within each span, the polynomial of that `degree` is controlled by `order = degree + 1` contiguous points called poles.\r\n * * The is a strict relationship between knot and poles counts:  `numPoles + order = numKnots + 2'\r\n * * The number of spans is `numSpan = numPoles - degree`\r\n * * For a given `spanIndex`:\r\n *   * The `order` poles begin at index `spanIndex`.\r\n *   * The `2*order` knots begin as span index\r\n *   * The knot interval for this span is from `knot[degree+span-1] to knot[degree+span]`\r\n * * The active part of the knot axis is `knot[degree-1] < knot < knot[degree-1 + numSpan]` i.e. `knot[degree-1] < knot < knot[numPoles]\r\n *\r\n * Nearly all bsplines are \"clamped \".\r\n * * Clamping make the curve pass through its first and last poles, with tangents directed along the first and last edges of the control polygon.\r\n * * The knots for a clamped bspline have `degree` copies of the lowest knot value and `degree` copies of the highest knot value.\r\n * * For instance, the knot vector `[0,0,0,1,2,3,3,3]\r\n *   * can be evaluated from `0<=knot<=3`\r\n *   * has 3 spans: 0 to 1, 1 to 2, 2 to 3\r\n *   * has 6 poles\r\n *   * passes through its first and last poles.\r\n * * `create` methods may allow classic convention that has an extra knot at the beginning and end of the knot vector.\r\n *   * The extra knots (first and last) were never referenced by the bspline recurrence relations.\r\n *   * When the `create` methods recognize the classic setup (`numPoles + order = numKnots`), the extra knot is not saved with the BSplineCurve3dBase knots.\r\n *\r\n * * The weighted variant has the problem that CurvePrimitive 3d typing does not allow undefined result where Point4d has zero weight.\r\n * * The convention for these is to return 000 in such places.\r\n *\r\n * * Note the class relationships:\r\n *   * BSpline1dNd knows the bspline recurrence relations for control points (poles) with no physical meaning.\r\n *   * BsplineCurve3dBase owns a protected BSpline1dNd\r\n *   * BsplineCurve3dBase is derived from CurvePrimitive, which creates obligation to act as a 3D curve, such as\r\n *     * evaluate fraction to point and derivatives wrt fraction\r\n *     * compute intersection with plane\r\n *   * BSplineCurve3d and BSplineCurve3dH have variant logic driven by whether or not there are \"weights\" on the poles.\r\n *     * For `BSplineCurve3d`, the xyz value of pole calculations are \"final\" values for 3d evaluation\r\n *     * For `BSplineCurve3dH`, various `BSpline1dNd` results with xyzw have to be normalized back to xyz.\r\n *\r\n * * These classes do not support \"periodic\" variants.\r\n *   * Periodic curves need to have certain leading knots and poles replicated at the end\r\n * @public\r\n */\r\nexport abstract class BSplineCurve3dBase extends CurvePrimitive {\r\n  /** String name for schema properties */\r\n  public readonly curvePrimitiveType = \"bsplineCurve\";\r\n\r\n  /** The underlying blocked-pole spline, with simple x,y,z poles */\r\n  protected _bcurve: BSpline1dNd;\r\n  protected constructor(poleDimension: number, numPoles: number, order: number, knots: KnotVector) {\r\n    super();\r\n    this._bcurve = BSpline1dNd.create(numPoles, poleDimension, order, knots) as BSpline1dNd;\r\n  }\r\n  /** Return the degree (one less than the order) of the curve */\r\n  public get degree(): number { return this._bcurve.degree; }\r\n  /** Return the order (one more than degree) of the curve */\r\n  public get order(): number { return this._bcurve.order; }\r\n  /** Return the number of bezier spans in the curve.  Note that this number includes the number of null spans at repeated knows */\r\n  public get numSpan(): number { return this._bcurve.numSpan; }\r\n  /** Return the number of poles */\r\n  public get numPoles(): number { return this._bcurve.numPoles; }\r\n  /**\r\n * return a simple array form of the knots.  optionally replicate the first and last\r\n * in classic over-clamped manner\r\n */\r\n  public copyKnots(includeExtraEndKnot: boolean): number[] { return this._bcurve.knots.copyKnots(includeExtraEndKnot); }\r\n\r\n  /**\r\n * Set the flag indicating the bspline might be suitable for having wrapped \"closed\" interpretation.\r\n */\r\n  public setWrappable(value: BSplineWrapMode) {\r\n    this._bcurve.knots.wrappable = value;\r\n  }\r\n\r\n  /** Evaluate at a position given by fractional position within a span. */\r\n  public abstract evaluatePointInSpan(spanIndex: number, spanFraction: number, result?: Point3d): Point3d;\r\n  /** Evaluate at a position given by fractional position within a span. */\r\n  public abstract evaluatePointAndDerivativeInSpan(spanIndex: number, spanFraction: number, result?: Ray3d): Ray3d;\r\n  /** Evaluate xyz at a position given by knot. */\r\n  public abstract knotToPoint(knot: number, result?: Point3d): Point3d;\r\n  /** Evaluate xyz and derivative at position given by a knot value.  */\r\n  public abstract knotToPointAndDerivative(knot: number, result?: Ray3d): Ray3d;\r\n  /** Evaluate xyz and 2 derivatives at position given by a knot value.  */\r\n  public abstract knotToPointAnd2Derivatives(knot: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;\r\n  /** Evaluate the curve point at `fraction` */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    return this.knotToPoint(this._bcurve.knots.fractionToKnot(fraction), result);\r\n  }\r\n  /** Construct a ray with\r\n   * * origin at the fractional position along the arc\r\n   * * direction is the first derivative, i.e. tangent along the curve\r\n   */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    const knot = this._bcurve.knots.fractionToKnot(fraction);\r\n    result = this.knotToPointAndDerivative(knot, result);\r\n    result.direction.scaleInPlace(this._bcurve.knots.knotLength01);\r\n    return result;\r\n  }\r\n\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the arc\r\n   * * x axis is the first derivative, i.e. tangent along the curve\r\n   * * y axis is the second derivative\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const knot = this._bcurve.knots.fractionToKnot(fraction);\r\n    result = this.knotToPointAnd2Derivatives(knot, result);\r\n    const a = this._bcurve.knots.knotLength01;\r\n    result.vectorU.scaleInPlace(a);\r\n    result.vectorV.scaleInPlace(a * a);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the start point of the curve.\r\n   */\r\n  public startPoint(): Point3d { return this.evaluatePointInSpan(0, 0.0); }\r\n  /**\r\n   * Return the end point of the curve\r\n   */\r\n  public endPoint(): Point3d { return this.evaluatePointInSpan(this.numSpan - 1, 1.0); }\r\n  /** Reverse the curve in place.\r\n   * * Poles are reversed\r\n   * * knot values are mirrored around the middle of the\r\n   */\r\n  public reverseInPlace(): void { this._bcurve.reverseInPlace(); }\r\n  /**\r\n   * Return an array with this curve's bezier fragments.\r\n   */\r\n  public collectBezierSpans(prefer3dH: boolean): BezierCurveBase[] {\r\n    const result: BezierCurveBase[] = [];\r\n    const numSpans = this.numSpan;\r\n    for (let i = 0; i < numSpans; i++) {\r\n      if (this._bcurve.knots.isIndexOfRealSpan(i)) {\r\n        const span = this.getSaturatedBezierSpan3dOr3dH(i, prefer3dH);\r\n        if (span)\r\n          result.push(span);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n    * Return a BezierCurveBase for this curve.  The concrete return type may be BezierCurve3d or BezierCurve3dH according to the instance type and the prefer3dH parameter.\r\n    * @param spanIndex\r\n    * @param prefer3dH true to force promotion to homogeneous.\r\n    * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\r\n    */\r\n  public abstract getSaturatedBezierSpan3dOr3dH(spanIndex: number, prefer3dH: boolean, result?: BezierCurveBase): BezierCurveBase | undefined;\r\n  /** Return a specified pole as a Point4d.\r\n   * * BSplineCurve3d appends weight 1 to its xyz\r\n   * * BSplineCurve3dH with pole whose \"normalized\" point is (x,y,z) but has weight w returns its weighted (wx,wy,wz,w)\r\n   */\r\n  public abstract getPolePoint4d(poleIndex: number, result?: Point4d): Point4d | undefined;\r\n  /** Return a specified pole as a Point3d\r\n   * * BSplineCurve3d returns its simple xyz\r\n   * * BSplineCurve3dH attempts to normalize its (wx,wy,wz,w) back to (x,y,z), and returns undefined if weight is zero.\r\n   * @param poleIndex\r\n   * @param result optional result\r\n   */\r\n  public abstract getPolePoint3d(poleIndex: number, result?: Point3d): Point3d | undefined;\r\n\r\n  /** Given a pole index, return the starting index for the contiguous array. */\r\n  public poleIndexToDataIndex(poleIndex: number): number | undefined {\r\n    if (poleIndex >= 0 && poleIndex < this.numPoles)\r\n      return poleIndex * this._bcurve.poleLength;\r\n    return undefined;\r\n  }\r\n\r\n  /** Search for the curve point that is closest to the spacePoint.\r\n   *\r\n   * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.\r\n   * * Since CurvePrimitive should always have start and end available as candidate points, this method should always succeed\r\n   * @param spacePoint point in space\r\n   * @param extend true to extend the curve (if possible)\r\n   * @returns Returns a CurveLocationDetail structure that holds the details of the close point.\r\n   */\r\n  public closestPoint(spacePoint: Point3d, _extend: boolean): CurveLocationDetail | undefined {\r\n    const point = this.fractionToPoint(0);\r\n    const result = CurveLocationDetail.createCurveFractionPointDistance(this, 0.0, point, point.distance(spacePoint));\r\n    this.fractionToPoint(1.0, point);\r\n    result.updateIfCloserCurveFractionPointDistance(this, 1.0, point, spacePoint.distance(point));\r\n\r\n    let span: BezierCurve3dH | undefined;\r\n    const numSpans = this.numSpan;\r\n    for (let i = 0; i < numSpans; i++) {\r\n      if (this._bcurve.knots.isIndexOfRealSpan(i)) {\r\n        span = this.getSaturatedBezierSpan3dOr3dH(i, true, span) as BezierCurve3dH;\r\n        if (span) {\r\n          if (span.updateClosestPointByTruePerpendicular(spacePoint, result)) {\r\n            // the detail records the span bezier -- promote it to the parent curve . ..\r\n            result.curve = this;\r\n            result.fraction = span.fractionToParentFraction(result.fraction);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Implement `CurvePrimitive.appendPlaneIntersections`\r\n   * @param plane A plane (e.g. specific type Plane3dByOriginAndUnitNormal or Point4d)\r\n   * @param result growing array of plane intersections\r\n   * @return number of intersections appended to the array.\r\n  */\r\n  public appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number {\r\n    const numPole = this.numPoles;\r\n    const order = this.order;\r\n    const allCoffs = new Float64Array(numPole);\r\n    const numSpan = this.numSpan;\r\n    const point4d = Point4d.create();\r\n    // compute all pole altitudes from the plane\r\n    const minMax = Range1d.createNull();\r\n    // Put the altitudes of all the bspline poles in one array.\r\n    for (let i = 0; i < numPole; i++) {\r\n      allCoffs[i] = plane.weightedAltitude(this.getPolePoint4d(i, point4d)!);\r\n      minMax.extendX(allCoffs[i]);\r\n    }\r\n    // A univariate bspline through the altitude poles gives altitude as function of the bspline knot.\r\n    // The (bspline) altitude function for each span is `order` consecutive altitudes.\r\n    // If those altitudes bracket zero, the span may potentially have a crossing.\r\n    // When that occurs,\r\n    let univariateBezier: UnivariateBezier | undefined;\r\n    let numFound = 0;\r\n    let previousFraction = -1000.0;\r\n    if (minMax.containsX(0.0)) {\r\n      for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n        if (this._bcurve.knots.isIndexOfRealSpan(spanIndex)) {  // ignore trivial knot intervals.\r\n          // outer range test ...\r\n          minMax.setNull();\r\n          minMax.extendArraySubset(allCoffs, spanIndex, order);\r\n          if (minMax.containsX(0.0)) {\r\n            // pack the bspline support into a univariate bezier ...\r\n            univariateBezier = UnivariateBezier.createArraySubset(allCoffs, spanIndex, order, univariateBezier)!;\r\n            // saturate and solve the bezier\r\n            Bezier1dNd.saturate1dInPlace(univariateBezier.coffs, this._bcurve.knots, spanIndex);\r\n            const roots = univariateBezier.roots(0.0, true);\r\n            if (roots) {\r\n              for (const spanFraction of roots) {\r\n                // promote each local bezier fraction to global fraction.\r\n                // save the curve evaluation at that fraction.\r\n                numFound++;\r\n                const fraction = this._bcurve.knots.spanFractionToFraction(spanIndex, spanFraction);\r\n                if (!Geometry.isAlmostEqualNumber(fraction, previousFraction)) {\r\n                  const detail = CurveLocationDetail.createCurveEvaluatedFraction(this, fraction);\r\n                  detail.intervalRole = CurveIntervalRole.isolated;\r\n                  result.push(detail);\r\n                  previousFraction = fraction;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return numFound;\r\n  }\r\n\r\n}\r\n/**\r\n * A BSplineCurve3d is a bspline curve whose poles are Point3d.\r\n * See BSplineCurve3dBase for description of knots, order, degree.\r\n * @public\r\n */\r\nexport class BSplineCurve3d extends BSplineCurve3dBase {\r\n\r\n  private _workBezier?: BezierCurve3dH;\r\n  private initializeWorkBezier(): BezierCurve3dH {\r\n    if (this._workBezier === undefined)\r\n      this._workBezier = BezierCurve3dH.createOrder(this.order);\r\n    return this._workBezier;\r\n  }\r\n  /** test of `other` is an instance of BSplineCurve3d */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BSplineCurve3d; }\r\n  /** Apply `transform` to the poles. */\r\n  public tryTransformInPlace(transform: Transform): boolean { Point3dArray.multiplyInPlace(transform, this._bcurve.packedData); return true; }\r\n  /** Get a pole as simple Point3d. */\r\n  public getPolePoint3d(poleIndex: number, result?: Point3d): Point3d | undefined {\r\n    const k = this.poleIndexToDataIndex(poleIndex);\r\n    if (k !== undefined) {\r\n      const data = this._bcurve.packedData;\r\n      return Point3d.create(data[k], data[k + 1], data[k + 2], result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Get a pole as Point4d with weight 1 */\r\n  public getPolePoint4d(poleIndex: number, result?: Point4d): Point4d | undefined {\r\n    const k = this.poleIndexToDataIndex(poleIndex);\r\n    if (k !== undefined) {\r\n      const data = this._bcurve.packedData;\r\n      return Point4d.create(data[k], data[k + 1], data[k + 2], 1.0, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Convert  `spanIndex` and `localFraction` to a knot. */\r\n  public spanFractionToKnot(span: number, localFraction: number): number {\r\n    return this._bcurve.spanFractionToKnot(span, localFraction);\r\n  }\r\n  private constructor(numPoles: number, order: number, knots: KnotVector) {\r\n    super(3, numPoles, order, knots);\r\n  }\r\n  /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */\r\n  public copyPoints(): any[] { return Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData, 3); }\r\n  /** Return a simple array of the control points coordinates */\r\n  public copyPointsFloat64Array(): Float64Array { return this._bcurve.packedData.slice(); }\r\n  /**\r\n   * return a simple array form of the knots.  optionally replicate the first and last\r\n   * in classic over-clamped manner\r\n   */\r\n  public copyKnots(includeExtraEndKnot: boolean): number[] { return this._bcurve.knots.copyKnots(includeExtraEndKnot); }\r\n\r\n  /** Create a bspline with uniform knots. */\r\n  public static createUniformKnots(poles: Point3d[] | Float64Array | GrowableXYZArray, order: number): BSplineCurve3d | undefined {\r\n    const numPoles = poles instanceof Float64Array ? poles.length / 3 : poles.length;\r\n    if (order < 1 || numPoles < order)\r\n      return undefined;\r\n    const knots = KnotVector.createUniformClamped(numPoles, order - 1, 0.0, 1.0);\r\n    const curve = new BSplineCurve3d(numPoles, order, knots);\r\n    if (poles instanceof Float64Array) {\r\n      for (let i = 0; i < 3 * numPoles; i++)\r\n        curve._bcurve.packedData[i] = poles[i];\r\n    } else if (poles instanceof GrowableXYZArray) {\r\n      curve._bcurve.packedData = poles.float64Data().slice(0, 3 * numPoles);\r\n    } else {\r\n      let i = 0;\r\n      for (const p of poles) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; }\r\n    }\r\n    return curve;\r\n  }\r\n  /** Create a bspline with given knots.\r\n   *\r\n   * *  Two count conditions are recognized:\r\n   *\r\n   * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.\r\n   *\r\n   */\r\n  public static create(poleArray: Float64Array | Point3d[], knotArray: Float64Array | number[], order: number): BSplineCurve3d | undefined {\r\n    let numPoles = poleArray.length;\r\n    if (poleArray instanceof Float64Array) {\r\n      numPoles /= 3;  // blocked as xyz\r\n    }\r\n    const numKnots = knotArray.length;\r\n    // shift knots-of-interest limits for overclamped case ...\r\n    const skipFirstAndLast = (numPoles + order === numKnots);\r\n    if (order < 1 || numPoles < order)\r\n      return undefined;\r\n    const knots = KnotVector.create(knotArray, order - 1, skipFirstAndLast);\r\n    const curve = new BSplineCurve3d(numPoles, order, knots);\r\n    if (poleArray instanceof Float64Array) {\r\n      let i = 0;\r\n      for (const coordinate of poleArray) { curve._bcurve.packedData[i++] = coordinate; }\r\n    } else {\r\n      let i = 0;\r\n      for (const p of poleArray) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; }\r\n    }\r\n    return curve;\r\n  }\r\n  /** Return a deep clone */\r\n  public clone(): BSplineCurve3d {\r\n    const knotVector1 = this._bcurve.knots.clone();\r\n    const curve1 = new BSplineCurve3d(this.numPoles, this.order, knotVector1);\r\n    curve1._bcurve.packedData = this._bcurve.packedData.slice();\r\n    return curve1;\r\n  }\r\n  /** Return a transformed deep clone. */\r\n  public cloneTransformed(transform: Transform): BSplineCurve3d {\r\n    const curve1 = this.clone();\r\n    curve1.tryTransformInPlace(transform);\r\n    return curve1;\r\n  }\r\n  /** Evaluate at a position given by fractional position within a span. */\r\n  public evaluatePointInSpan(spanIndex: number, spanFraction: number): Point3d {\r\n    this._bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);\r\n    return Point3d.createFrom(this._bcurve.poleBuffer);\r\n  }\r\n  /** Evaluate point and derivative vector at a position given by fractional position within a span.\r\n   * * The derivative is with respect to the span fraction (NOT scaled to either global fraction or knot)\r\n   */\r\n  public evaluatePointAndDerivativeInSpan(spanIndex: number, spanFraction: number): Ray3d {\r\n    this._bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);\r\n    return Ray3d.createCapture(\r\n      Point3d.createFrom(this._bcurve.poleBuffer),\r\n      Vector3d.createFrom(this._bcurve.poleBuffer1));\r\n  }\r\n\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPoint(u: number, result?: Point3d): Point3d {\r\n    this._bcurve.evaluateBuffersAtKnot(u);\r\n    return Point3d.createFrom(this._bcurve.poleBuffer, result);\r\n  }\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPointAndDerivative(u: number, result?: Ray3d): Ray3d {\r\n    this._bcurve.evaluateBuffersAtKnot(u, 1);\r\n    if (!result) return Ray3d.createCapture(\r\n      Point3d.createFrom(this._bcurve.poleBuffer),\r\n      Vector3d.createFrom(this._bcurve.poleBuffer1));\r\n    result.origin.setFrom(this._bcurve.poleBuffer);\r\n    result.direction.setFrom(this._bcurve.poleBuffer1);\r\n    return result;\r\n  }\r\n\r\n  /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */\r\n  public knotToPointAnd2Derivatives(u: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    this._bcurve.evaluateBuffersAtKnot(u, 2);\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(\r\n      this._bcurve.poleBuffer[0], this._bcurve.poleBuffer[1], this._bcurve.poleBuffer[2],\r\n      this._bcurve.poleBuffer1[0], this._bcurve.poleBuffer1[1], this._bcurve.poleBuffer1[2],\r\n      this._bcurve.poleBuffer2[0], this._bcurve.poleBuffer2[1], this._bcurve.poleBuffer2[2], result);\r\n  }\r\n  /** Evaluate the curve point at a fractional of the entire knot range. */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    return this.knotToPoint(this._bcurve.knots.fractionToKnot(fraction), result);\r\n  }\r\n\r\n  /** Evaluate the curve point at a fractional of the entire knot range. */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    const knot = this._bcurve.knots.fractionToKnot(fraction);\r\n    result = this.knotToPointAndDerivative(knot, result);\r\n    result.direction.scaleInPlace(this._bcurve.knots.knotLength01);\r\n    return result;\r\n  }\r\n\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the arc\r\n   * * x axis is the first derivative, i.e. tangent along the arc\r\n   * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\r\n   * If the arc is circular, the second derivative is directly towards the center\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const knot = this._bcurve.knots.fractionToKnot(fraction);\r\n    result = this.knotToPointAnd2Derivatives(knot, result);\r\n    const a = this._bcurve.knots.knotLength01;\r\n    result.vectorU.scaleInPlace(a);\r\n    result.vectorV.scaleInPlace(a * a);\r\n    return result;\r\n  }\r\n  /** test if almost the same curve as `other` */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BSplineCurve3d) {\r\n      return this._bcurve.knots.isAlmostEqual(other._bcurve.knots)\r\n        && Point3dArray.isAlmostEqual(this._bcurve.packedData, other._bcurve.packedData);\r\n    }\r\n    return false;\r\n  }\r\n  /** test if this curve is entirely within plane. */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Point3dArray.isCloseToPlane(this._bcurve.packedData, plane);\r\n  }\r\n  /** Return the control polygon length as approximation (always overestimate) of the curve length. */\r\n  public quickLength(): number { return Point3dArray.sumEdgeLengths(this._bcurve.packedData); }\r\n  /** Emit beziers or strokes (selected by the stroke options) to the handler. */\r\n  public emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void {\r\n    const needBeziers = handler.announceBezierCurve !== undefined;\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    let numStrokes;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dOr3dH(spanIndex, false, workBezier);\r\n      if (bezier) {\r\n        numStrokes = bezier.computeStrokeCountForOptions(options);\r\n        if (needBeziers) {\r\n          handler.announceBezierCurve!(bezier, numStrokes, this,\r\n            spanIndex,\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0),\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\r\n\r\n        } else {\r\n          handler.announceIntervalForUniformStepStrokes(this, numStrokes,\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0),\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assess length and turn to determine a stroke count.\r\n   * @param options stroke options structure.\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    let numStroke = 0;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier)\r\n        numStroke += bezier.computeStrokeCountForOptions(options);\r\n    }\r\n    return numStroke;\r\n  }\r\n  /**\r\n   * Compute individual segment stroke counts.  Attach in a StrokeCountMap.\r\n   * @param options StrokeOptions that determine count\r\n   * @param parentStrokeMap evolving parent map.\r\n   * @alpha\r\n   */\r\n  public computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap) {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    const myData = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);\r\n\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier) {\r\n        const segmentLength = workBezier.curveLength();\r\n        const numStrokeOnSegment = workBezier.computeStrokeCountForOptions(options);\r\n        myData.addToCountAndLength(numStrokeOnSegment, segmentLength);\r\n      }\r\n    }\r\n    CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);\r\n  }\r\n  /** Append strokes to a linestring. */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier)\r\n        bezier.emitStrokes(dest, options);\r\n    }\r\n  }\r\n  /**\r\n   * Test knots, control points, and wrappable flag to see if all agree for a possible wrapping.\r\n   * @returns the manner of closing.   Se BSplineWrapMode for particulars of each mode.\r\n   *\r\n   */\r\n  public get isClosable(): BSplineWrapMode {\r\n    const mode = this._bcurve.knots.wrappable;\r\n    if (mode === BSplineWrapMode.None)\r\n      return BSplineWrapMode.None;\r\n    if (!this._bcurve.knots.testClosable(mode))\r\n      return BSplineWrapMode.None;\r\n    if (!this._bcurve.testCloseablePolygon(mode))\r\n      return BSplineWrapMode.None;\r\n    return mode;\r\n  }\r\n  /**\r\n   * Return a BezierCurveBase for this curve.  The concrete return type may be BezierCurve3d or BezierCurve3dH according to this type.\r\n   * @param spanIndex\r\n   * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\r\n   */\r\n  public getSaturatedBezierSpan3dOr3dH(spanIndex: number, prefer3dH: boolean, result?: BezierCurveBase): BezierCurveBase | undefined {\r\n    if (prefer3dH)\r\n      return this.getSaturatedBezierSpan3dH(spanIndex, result);\r\n    return this.getSaturatedBezierSpan3d(spanIndex, result);\r\n  }\r\n\r\n  /**\r\n   * Return a CurvePrimitive (which is a BezierCurve3d) for a specified span of this curve.\r\n   * @param spanIndex\r\n   * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\r\n   */\r\n  public getSaturatedBezierSpan3d(spanIndex: number, result?: BezierCurveBase): BezierCurveBase | undefined {\r\n    if (spanIndex < 0 || spanIndex >= this.numSpan)\r\n      return undefined;\r\n\r\n    const order = this.order;\r\n    if (result === undefined || !(result instanceof BezierCurve3d) || result.order !== order)\r\n      result = BezierCurve3d.createOrder(order);\r\n    const bezier = result as BezierCurve3d;\r\n    bezier.loadSpanPoles(this._bcurve.packedData, spanIndex);\r\n    if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))\r\n      return result;\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a CurvePrimitive (which is a BezierCurve3dH) for a specified span of this curve.\r\n   * @param spanIndex\r\n   * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\r\n   */\r\n  public getSaturatedBezierSpan3dH(spanIndex: number, result?: BezierCurveBase): BezierCurve3dH | undefined {\r\n    if (spanIndex < 0 || spanIndex >= this.numSpan)\r\n      return undefined;\r\n\r\n    const order = this.order;\r\n    if (result === undefined || !(result instanceof BezierCurve3dH) || result.order !== order)\r\n      result = BezierCurve3dH.createOrder(order);\r\n    const bezier = result as BezierCurve3dH;\r\n    bezier.loadSpan3dPolesWithWeight(this._bcurve.packedData, spanIndex, 1.0);\r\n    if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))\r\n      return bezier;\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Set the flag indicating the bspline might be suitable for having wrapped \"closed\" interpretation.\r\n   */\r\n  public setWrappable(value: BSplineWrapMode) {\r\n    this._bcurve.knots.wrappable = value;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBSplineCurve3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBSplineCurve3d(this);\r\n  }\r\n  /**\r\n   * Extend a range so in includes the range of this curve\r\n   * * REMARK: this is based on the poles, not the exact curve.  This is generally larger than the true curve range.\r\n   * @param rangeToExtend\r\n   * @param transform transform to apply to points as they are entered into the range.\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    const buffer = this._bcurve.packedData;\r\n    const n = buffer.length - 2;\r\n    if (transform) {\r\n      for (let i0 = 0; i0 < n; i0 += 3)\r\n        rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\r\n    } else {\r\n      for (let i0 = 0; i0 < n; i0 += 3)\r\n        rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\r\n    }\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"../Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\n\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { KnotVector } from \"./KnotVector\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { Point3dArray, Point4dArray } from \"../geometry3d/PointHelpers\";\r\nimport { BezierCurveBase } from \"./BezierCurveBase\";\r\nimport { BezierCurve3dH } from \"./BezierCurve3dH\";\r\nimport { BSplineCurve3dBase } from \"./BSplineCurve\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\r\n\r\n/**\r\n * Weighted (Homogeneous) BSplineCurve in 3d\r\n * @public\r\n */\r\nexport class BSplineCurve3dH extends BSplineCurve3dBase {\r\n  private _workBezier?: BezierCurve3dH;\r\n  private initializeWorkBezier(): BezierCurve3dH {\r\n    if (this._workBezier === undefined)\r\n      this._workBezier = BezierCurve3dH.createOrder(this.order);\r\n    return this._workBezier;\r\n  }\r\n  /** Test if `other` is an instance of `BSplineCurve3dH` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BSplineCurve3dH; }\r\n  /** Apply `transform` to the curve */\r\n  public tryTransformInPlace(transform: Transform): boolean { Point4dArray.multiplyInPlace(transform, this._bcurve.packedData); return true; }\r\n  /** Get a pole, normalized to Point3d. */\r\n  public getPolePoint3d(poleIndex: number, result?: Point3d): Point3d | undefined {\r\n    const k = this.poleIndexToDataIndex(poleIndex);\r\n    if (k !== undefined) {\r\n      const data = this._bcurve.packedData;\r\n      const divW = Geometry.conditionalDivideFraction(1.0, data[k + 3]);\r\n      if (divW !== undefined)\r\n        return Point3d.create(data[k] * divW, data[k + 1] * divW, data[k + 2] * divW, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Get a pole as Point4d */\r\n  public getPolePoint4d(poleIndex: number, result?: Point4d): Point4d | undefined {\r\n    const k = this.poleIndexToDataIndex(poleIndex);\r\n    if (k !== undefined) {\r\n      const data = this._bcurve.packedData;\r\n      return Point4d.create(data[k], data[k + 1], data[k + 2], data[k + 3], result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** map a spanIndex and fraction to a knot value. */\r\n  public spanFractionToKnot(span: number, localFraction: number): number {\r\n    return this._bcurve.spanFractionToKnot(span, localFraction);\r\n  }\r\n  private constructor(numPoles: number, order: number, knots: KnotVector) {\r\n    super(4, numPoles, order, knots);\r\n  }\r\n  /** Return a simple array of arrays with the control points as `[[x,y,z,w],[x,y,z,w],..]` */\r\n  public copyPoints(): any[] { return Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData, 4); }\r\n  /** Return a simple array of the control points coordinates */\r\n  public copyPointsFloat64Array(): Float64Array { return this._bcurve.packedData.slice(); }\r\n\r\n  /** Create a bspline with uniform knots.\r\n   * * Control points may be supplied as:\r\n   *   * array of Point4d, with weight already multiplied into the `[wx,wy,wz,w]`\r\n   *   * array of Point3d, with implied weight 1.\r\n   *   * Float64Array, blocked as xyzw, i.e. 4 doubles per control point.\r\n   * @param controlPoints pole data in array form as noted above.\r\n   * @param order  curve order (1 more than degree)\r\n   */\r\n  public static createUniformKnots(controlPoints: Point3d[] | Point4d[] | Float64Array, order: number): BSplineCurve3dH | undefined {\r\n    const numPoles = (controlPoints instanceof Float64Array) ? controlPoints.length / 4 : controlPoints.length;\r\n    if (order < 1 || numPoles < order)\r\n      return undefined;\r\n    const knots = KnotVector.createUniformClamped(controlPoints.length, order - 1, 0.0, 1.0);\r\n    const curve = new BSplineCurve3dH(numPoles, order, knots);\r\n    let i = 0;\r\n    if (controlPoints[0] instanceof Point3d) {\r\n      for (const p of (controlPoints as Point3d[])) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; curve._bcurve.packedData[i++] = 1.0; }\r\n    } else if (controlPoints[0] instanceof Point4d) {\r\n      for (const p of (controlPoints as Point4d[])) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; curve._bcurve.packedData[i++] = p.w; }\r\n    } else if (controlPoints instanceof Float64Array) {\r\n      const qPoles = controlPoints as Float64Array;\r\n      const numQ = qPoles.length;\r\n      for (let k = 0; k < numQ; k++) {\r\n        curve._bcurve.packedData[k] = qPoles[k];\r\n      }\r\n    } else {\r\n      return undefined;\r\n    }\r\n    return curve;\r\n  }\r\n  /** Create a bspline with given knots.\r\n   *\r\n   * *  Two count conditions are recognized:\r\n   *\r\n   * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.\r\n   *\r\n   */\r\n  public static create(controlPoints: Float64Array | Point4d[] | Point3d[], knotArray: Float64Array | number[], order: number): BSplineCurve3dH | undefined {\r\n    let numPoles = controlPoints.length;\r\n    if (controlPoints instanceof Float64Array) {\r\n      numPoles /= 4;  // blocked as xyz\r\n    }\r\n    const numKnots = knotArray.length;\r\n    // shift knots-of-interest limits for overclamped case ...\r\n    const skipFirstAndLast = (numPoles + order === numKnots);\r\n    if (order < 1 || numPoles < order)\r\n      return undefined;\r\n    const knots = KnotVector.create(knotArray, order - 1, skipFirstAndLast);\r\n    const curve = new BSplineCurve3dH(numPoles, order, knots);\r\n    if (controlPoints instanceof Float64Array) {\r\n      let i = 0;\r\n      for (const coordinate of controlPoints) { curve._bcurve.packedData[i++] = coordinate; }\r\n    } else if (controlPoints[0] instanceof Point4d) {\r\n      let i = 0;\r\n      for (const p of (controlPoints as Point4d[])) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; curve._bcurve.packedData[i++] = p.w; }\r\n    } else if (controlPoints[0] instanceof Point3d) {\r\n      let i = 0;\r\n      for (const p of controlPoints) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; curve._bcurve.packedData[i++] = 1.0; }\r\n    }\r\n    return curve;\r\n  }\r\n  /** Return a deep clone of this curve. */\r\n  public clone(): BSplineCurve3dH {\r\n    const knotVector1 = this._bcurve.knots.clone();\r\n    const curve1 = new BSplineCurve3dH(this.numPoles, this.order, knotVector1);\r\n    curve1._bcurve.packedData = this._bcurve.packedData.slice();\r\n    return curve1;\r\n  }\r\n  /** Clone the curve and apply a transform to the clone. */\r\n  public cloneTransformed(transform: Transform): BSplineCurve3dH {\r\n    const curve1 = this.clone();\r\n    curve1.tryTransformInPlace(transform);\r\n    return curve1;\r\n  }\r\n  /** Evaluate at a position given by fractional position within a span. */\r\n  public evaluatePointInSpan(spanIndex: number, spanFraction: number, result?: Point3d): Point3d {\r\n    this._bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);\r\n    const xyzw = this._bcurve.poleBuffer;\r\n    return Point4d.createRealPoint3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], result);\r\n  }\r\n\r\n  /** Evaluate at a position given by fractional position within a span. */\r\n  public evaluatePointAndDerivativeInSpan(spanIndex: number, spanFraction: number, result?: Ray3d): Ray3d {\r\n    this._bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);\r\n    const xyzw = this._bcurve.poleBuffer;\r\n    const dXYZW = this._bcurve.poleBuffer1;\r\n    return Point4d.createRealDerivativeRay3dDefault000(\r\n      xyzw[0], xyzw[1], xyzw[2], xyzw[3],\r\n      dXYZW[0], dXYZW[1], dXYZW[2], dXYZW[3], result);\r\n  }\r\n\r\n  /** Evaluate at a position given by a knot value. */\r\n  public knotToPoint(u: number, result?: Point3d): Point3d {\r\n    this._bcurve.evaluateBuffersAtKnot(u);\r\n    const xyzw = this._bcurve.poleBuffer;\r\n    return Point4d.createRealPoint3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], result);\r\n  }\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPointAndDerivative(u: number, result?: Ray3d): Ray3d {\r\n    this._bcurve.evaluateBuffersAtKnot(u, 1);\r\n    const xyzw = this._bcurve.poleBuffer;\r\n    const dXYZW = this._bcurve.poleBuffer1;\r\n    return Point4d.createRealDerivativeRay3dDefault000(\r\n      xyzw[0], xyzw[1], xyzw[2], xyzw[3],\r\n      dXYZW[0], dXYZW[1], dXYZW[2], dXYZW[3], result);\r\n  }\r\n\r\n  /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */\r\n  public knotToPointAnd2Derivatives(u: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    this._bcurve.evaluateBuffersAtKnot(u, 2);\r\n    const xyzw = this._bcurve.poleBuffer;\r\n    const dXYZW = this._bcurve.poleBuffer1;\r\n    const ddXYZW = this._bcurve.poleBuffer2;\r\n    return Point4d.createRealDerivativePlane3dByOriginAndVectorsDefault000(\r\n      xyzw[0], xyzw[1], xyzw[2], xyzw[3],\r\n      dXYZW[0], dXYZW[1], dXYZW[2], dXYZW[3],\r\n      ddXYZW[0], ddXYZW[1], ddXYZW[2], ddXYZW[3],\r\n      result);\r\n  }\r\n  /** test if the curve is almost equal to `other` */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BSplineCurve3dH) {\r\n      return this._bcurve.knots.isAlmostEqual(other._bcurve.knots)\r\n        && Point4dArray.isAlmostEqual(this._bcurve.packedData, other._bcurve.packedData);\r\n    }\r\n    return false;\r\n  }\r\n  /** Test if the curve is entirely within a plane. */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Point4dArray.isCloseToPlane(this._bcurve.packedData, plane);\r\n  }\r\n  /** Return the control polygon length as quick approximation to the curve length. */\r\n  public quickLength(): number { return Point3dArray.sumEdgeLengths(this._bcurve.packedData); }\r\n  /** call a handler with interval data for stroking. */\r\n  public emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void {\r\n    const needBeziers = (handler as any).announceBezierCurve;\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    let numStrokes;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dOr3dH(spanIndex, false, workBezier);\r\n      if (bezier) {\r\n        numStrokes = bezier.computeStrokeCountForOptions(options);\r\n        if (needBeziers) {\r\n          (handler as any).announceBezierCurve(bezier, numStrokes, this,\r\n            spanIndex,\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0),\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\r\n\r\n        } else {\r\n          handler.announceIntervalForUniformStepStrokes(this, numStrokes,\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0),\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**  Append stroked approximation of this curve to the linestring. */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier)\r\n        bezier.emitStrokes(dest, options);\r\n    }\r\n  }\r\n  /**\r\n   * Assess length and turn to determine a stroke count.\r\n   * @param options stroke options structure.\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    let numStroke = 0;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier)\r\n        numStroke += bezier.computeStrokeCountForOptions(options);\r\n    }\r\n    return numStroke;\r\n  }\r\n  /**\r\n   * Compute individual segment stroke counts.  Attach in a StrokeCountMap.\r\n   * @param options StrokeOptions that determine count\r\n   * @param parentStrokeMap evolving parent map.\r\n   */\r\n  public computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap) {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    const myData = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);\r\n\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier) {\r\n        const segmentLength = workBezier.curveLength();\r\n        const numStrokeOnSegment = workBezier.computeStrokeCountForOptions(options);\r\n        myData.addToCountAndLength(numStrokeOnSegment, segmentLength);\r\n      }\r\n    }\r\n    CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);\r\n  }\r\n  /**\r\n   * return true if the spline is (a) unclamped with (degree-1) matching knot intervals,\r\n   * (b) (degree-1) wrapped points,\r\n   * (c) marked wrappable from construction time.\r\n   */\r\n  public get isClosable(): boolean {\r\n    if (!this._bcurve.knots.wrappable)\r\n      return false;\r\n    const degree = this.degree;\r\n    const leftKnotIndex = this._bcurve.knots.leftKnotIndex;\r\n    const rightKnotIndex = this._bcurve.knots.rightKnotIndex;\r\n    const period = this._bcurve.knots.rightKnot - this._bcurve.knots.leftKnot;\r\n    const indexDelta = rightKnotIndex - leftKnotIndex;\r\n    for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {\r\n      const k1 = k0 + indexDelta;\r\n      if (!Geometry.isSameCoordinate(this._bcurve.knots.knots[k0] + period, this._bcurve.knots.knots[k1]))\r\n        return false;\r\n    }\r\n    const poleIndexDelta = this.numPoles - this.degree;\r\n    for (let p0 = 0; p0 < degree; p0++) {\r\n      const p1 = p0 + poleIndexDelta;\r\n      if (!Geometry.isSamePoint3d(this.getPolePoint3d(p0) as Point3d, this.getPolePoint3d(p1) as Point3d))\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Return a CurvePrimitive (which is a BezierCurve3dH) for a specified span of this curve.\r\n   * @param spanIndex\r\n   * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\r\n   */\r\n  public getSaturatedBezierSpan3dH(spanIndex: number, result?: BezierCurveBase): BezierCurveBase | undefined {\r\n    if (spanIndex < 0 || spanIndex >= this.numSpan)\r\n      return undefined;\r\n\r\n    const order = this.order;\r\n    if (result === undefined || !(result instanceof BezierCurve3dH) || result.order !== order)\r\n      result = BezierCurve3dH.createOrder(order);\r\n    const bezier = result as BezierCurve3dH;\r\n    bezier.loadSpan4dPoles(this._bcurve.packedData, spanIndex);\r\n    if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))\r\n      return result;\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Return a BezierCurveBase for this curve.  Because BSplineCurve3dH is homogeneous, the returned BezierCurveBase is always homogeneous.\r\n   * @param spanIndex\r\n   * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3dH with matching order.\r\n   */\r\n  public getSaturatedBezierSpan3dOr3dH(spanIndex: number, _prefer3dH: boolean, result?: BezierCurveBase): BezierCurveBase | undefined {\r\n    return this.getSaturatedBezierSpan3dH(spanIndex, result);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBSplineCurve3dH(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBSplineCurve3dH(this);\r\n  }\r\n  /**\r\n   * Extend a range so in includes the range of this curve\r\n   * * REMARK: this is based on the poles, not the exact curve.  This is generally larger than the true curve range.\r\n   * @param rangeToExtend\r\n   * @param transform transform to apply to points as they are entered into the range.\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    const buffer = this._bcurve.packedData;\r\n    const n = buffer.length - 3;\r\n    if (transform) {\r\n      for (let i0 = 0; i0 < n; i0 += 4)\r\n        rangeToExtend.extendTransformedXYZW(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2], buffer[i0 + 3]);\r\n    } else {\r\n      for (let i0 = 0; i0 < n; i0 += 4)\r\n        rangeToExtend.extendXYZW(buffer[i0], buffer[i0 + 1], buffer[i0 + 2], buffer[i0 + 3]);\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\nimport { AxisOrder, Geometry } from \"../Geometry\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Point3dArray, Point4dArray } from \"../geometry3d/PointHelpers\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { KnotVector, BSplineWrapMode } from \"./KnotVector\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\n/**\r\n * UVSelect is an integer indicating uDirection (0) or vDirection (1) in a bspline surface parameterization.\r\n * @public\r\n */\r\nexport enum UVSelect {\r\n  /** index of u direction */\r\n  uDirection = 0,\r\n  /** index of v direction */\r\n  VDirection = 1,\r\n\r\n}\r\n/**\r\n * Enumeration of how weights are carried\r\n * * UnWeighted (0) -- there are no weights\r\n * * WeightsAlreadyAppliedToCoordinates (1) -- for real point (x,y,z) the homogeneous point has weight applied throughout as (wx,wy,wz,w)\r\n * * WeightsSeparateFromCoordinates (2) -- for real point (x,y,z) the homogeneous point is (x,y,z,w)\r\n *   * Note that \"internal\" computations never use WeightsSeparateFromCoordinates.\r\n *   * WeightsSeparateFromCoordinates is only useful as input or output state in serializers.\r\n * @public\r\n */\r\nexport enum WeightStyle {\r\n  /** There are no weights. */\r\n  UnWeighted = 0,\r\n  /**\r\n   * * Data is weighted\r\n   * * point with normalized coordinate `[x,y,z]` and weight `w` has weights already multiplied in as `[x*w,y*w,z*w,w]`\r\n   * */\r\n  WeightsAlreadyAppliedToCoordinates = 1,\r\n  /**\r\n   * * Data is weighted\r\n   * * point with normalized coordinate `[x,y,z]` and weight `w` has is `[x,y,z,w]`\r\n   * */\r\n  WeightsSeparateFromCoordinates = 2,\r\n}\r\n/**\r\n * interface for points returned from getPointGrid, with annotation of physical and weighting dimensions.\r\n * @public\r\n */\r\nexport interface PackedPointGrid {\r\n  /**\r\n   * Array of coordinate data.\r\n   * * points[row] is all the data for a grid row.\r\n   * * points[row][j] is the j'th point across the row\r\n   * * points[row][j][k] is numeric value k.\r\n   */\r\n  points: number[][][];\r\n  /**\r\n   * Description of how weights are present in the coordinate data.\r\n  */\r\n  weightStyle?: WeightStyle;\r\n  /**\r\n   * number of cartesian dimensions, e.g. 2 or 3.\r\n   */\r\n  numCartesianDimensions: number;\r\n}\r\n/** Interface for methods supported by both regular (xyz) and weighted (xyzw) bspline surfaces.\r\n * @public\r\n */\r\nexport interface BSplineSurface3dQuery {\r\n  /** Evaluate xyz coordinates at fractional parameter u,v */\r\n  fractionToPoint(uFraction: number, vFraction: number): Point3d;\r\n  /** Evaluate a rigid frame at fractional parameter u,v\r\n   * * origin is at the surface point\r\n   * * x column is a unit vector in the direction of the u derivative\r\n   * * y column is a unit vector in the direction of the v derivative\r\n   * * z direction is the surface normal\r\n   */\r\n  fractionToRigidFrame(uFraction: number, vFraction: number): Transform | undefined;\r\n  /** Evaluate xyz coordinates at knot values (uKnot, vKnot) */\r\n  knotToPoint(uKnot: number, vKnot: number): Point3d;\r\n  /**  appply a transform to the surface */\r\n  tryTransformInPlace(transform: Transform): boolean;\r\n  /** clone the surface */\r\n  clone(): BSplineSurface3dQuery;\r\n  /** clone and transform */\r\n  cloneTransformed(transform: Transform): BSplineSurface3dQuery;\r\n  /** Reverse one of the parameterization directions. */\r\n  reverseInPlace(select: UVSelect): void;\r\n  /** Test if `this` and `other` are the same geometry class. */\r\n  isSameGeometryClass(other: any): boolean;\r\n  /** Extend `rangeToExtend` so this surface is included. */\r\n  extendRange(rangeToExtend: Range3d, transform?: Transform): void;\r\n  /** test for nearly equality with `other` */\r\n  isAlmostEqual(other: any): boolean;\r\n  /** ask if the u or v direction could be converted to periodic form */\r\n  isClosable(select: UVSelect): boolean;\r\n  /** Ask if the entire surface is within a plane. */\r\n  isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;\r\n  /** return the total number of poles (product of u,v counts) */\r\n  numPolesTotal(): number;\r\n  /**\r\n   * turn a numeric variable into a UVSelect (strict 0 or 1).\r\n   */\r\n  numberToUVSelect(value: number): UVSelect;\r\n  /**\r\n   * Return the degree in in selected direction (0 for u, 1 for v)\r\n   * @param select 0 for u, 1 for v\r\n   */\r\n  degreeUV(select: UVSelect): number;\r\n  /**\r\n   * Return the order in in selected direction (0 for u, 1 for v)\r\n   * @param select 0 for u, 1 for v\r\n   */\r\n  orderUV(select: UVSelect): number;\r\n  /**\r\n   * Return the number of bezier spans in selected direction (0 for u, 1 for v)\r\n   * @param select 0 for u, 1 for v\r\n   */\r\n  numSpanUV(select: UVSelect): number;\r\n\r\n  /**\r\n   * Return the number of poles in selected direction (0 for u, 1 for v)\r\n   * @param select 0 for u, 1 for v\r\n   */\r\n  numPolesUV(select: UVSelect): number;\r\n\r\n  /**\r\n   * Return the step between adjacent poles in selected direction (0 for u, 1 for v)\r\n   * @param select 0 for u, 1 for v\r\n   */\r\n  poleStepUV(select: UVSelect): number;\r\n\r\n  /*\r\n     * evaluate the surface at u and v fractions. Return a (squared, right handed) coordinate frame at that point on the surface.\r\n     * @param fractionU u parameter\r\n     * @param fractionV v parameter\r\n     * @param result undefined if surface derivatives are parallel (or either alone is zero)\r\n     */\r\n  // fractionToRigidFrame(fractionU: number, fractionV: number, result?: Transform): Transform | undefined;\r\n  /**\r\n  * Return control points json arrays.\r\n  * * Each row of points is an an array.\r\n  * * Within the array for each row, each point is an array [x,y,z] or [x,y,z,w].\r\n  * * The PackedPointGrid indicates if weights are present.\r\n  */\r\n  getPointGridJSON(): PackedPointGrid;\r\n}\r\n/** Bspline knots and poles for 2d-to-Nd.\r\n * * This abstract class in not independently instantiable -- GeometryQuery methods must be implemented by derived classes.\r\n * @public\r\n */\r\nexport abstract class BSpline2dNd extends GeometryQuery {\r\n  /** String name for schema properties */\r\n  public readonly geometryCategory = \"bsurf\";\r\n\r\n  /** Array of (exactly 2) knot vectors for the u, v directions */\r\n  public knots: KnotVector[];\r\n  /** flat array of coordinate daa, blocked by poleDimension and row */\r\n  public coffs: Float64Array;\r\n  /** Number of componets per pole.\r\n   * * 3 for conventional xyz surface\r\n   * * 4 for weighted (wx, wy, wz, w) surface.\r\n   */\r\n  public poleDimension: number;\r\n  private _numPoles: number[];\r\n  /** Return the degree (one less than order) for the `select` direction (0 or 1) */\r\n  public degreeUV(select: UVSelect): number { return this.knots[select].degree; }\r\n  /** Return the order (one more than degree) for the `select` direction (0 or 1) */\r\n  public orderUV(select: UVSelect): number { return this.knots[select].degree + 1; }\r\n  /** Return the number of spans (INCLUDING NULL SPANS) for the `select` direction (0 or 1) */\r\n  public numSpanUV(select: UVSelect): number { return this._numPoles[select] - this.knots[select].degree; }\r\n  /** Return the total number of poles (product of x and y pole counts) */\r\n  public numPolesTotal(): number { return this.coffs.length / this.poleDimension; }\r\n  /** Return the number of poles for the `select` direction (0 or 1) */\r\n  public numPolesUV(select: UVSelect): number { return this._numPoles[select]; }\r\n  /** Return the step between adjacent poles for the `select` direction (0 or 1) */\r\n  public poleStepUV(select: UVSelect): number { return select === 0 ? 1 : this._numPoles[0]; }\r\n  /** Confirm that order and pole counts agree for both u and v directions */\r\n  public static validOrderAndPoleCounts(orderU: number, numPolesU: number, orderV: number, numPolesV: number, numUV: number): boolean {\r\n    if (orderU < 2 || numPolesU < orderU)\r\n      return false;\r\n    if (orderV < 2 || numPolesV < orderV)\r\n      return false;\r\n    if (numPolesU * numPolesV !== numUV)\r\n      return false;\r\n    return true;\r\n  }\r\n  /** Get the Point3d by row and column.\r\n   * * (IMPORTANT) This assumes this is an xyz surface.  Data will be incorrect if this is an xyzw surface.\r\n   */\r\n  public getPoint3dPole(i: number, j: number, result?: Point3d): Point3d | undefined {\r\n    return Point3d.createFromPacked(this.coffs, i + j * this._numPoles[0], result);\r\n  }\r\n  /** Get the Point3d by row and column, projecting the weight away to get to xyz\r\n   * * (IMPORTANT) This assumes this is an xyzw surface.  Data will be incorrect if this is an xyz surface.\r\n   */\r\n  public getPoint3dPoleXYZW(i: number, j: number, result?: Point3d): Point3d | undefined {\r\n    return Point3d.createFromPackedXYZW(this.coffs, i + j * this._numPoles[0], result);\r\n  }\r\n  /**\r\n   * Return 0 for 0 input, 1 for any nonzero input.\r\n   * @param value numeric value to convert to strict 0 or 1.\r\n   */\r\n  public numberToUVSelect(value: number): UVSelect { return value === 0 ? 0 : 1; }\r\n  /** extend a range, treating each block as simple XYZ */\r\n  public extendRangeXYZ(rangeToExtend: Range3d, transform?: Transform) {\r\n    const buffer = this.coffs;\r\n    const pd = this.poleDimension;\r\n    const n = buffer.length + 1 - pd;\r\n    if (transform) {\r\n      for (let i0 = 0; i0 < n; i0 += pd)\r\n        rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\r\n    } else {\r\n      for (let i0 = 0; i0 < n; i0 += pd)\r\n        rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\r\n    }\r\n  }\r\n\r\n  /** extend a range, treating each block as homogeneous xyzw, with weight at offset 3 */\r\n  public extendRangeXYZH(rangeToExtend: Range3d, transform?: Transform) {\r\n    const buffer = this.coffs;\r\n    const pd = this.poleDimension;\r\n    const n = buffer.length + 1 - pd;\r\n    let w = 0;\r\n    let divW = 0;\r\n    if (transform) {\r\n      for (let i0 = 0; i0 < n; i0 += pd) {\r\n        w = buffer[i0 + 3];\r\n        if (w !== 0.0) {\r\n          divW = 1.0 / w;\r\n          rangeToExtend.extendTransformedXYZ(transform,\r\n            buffer[i0] * divW,\r\n            buffer[i0 + 1] * divW,\r\n            buffer[i0 + 2] * divW);\r\n        }\r\n      }\r\n    } else {\r\n      for (let i0 = 0; i0 < n; i0 += pd) {\r\n        w = buffer[i0 + 3];\r\n        if (w !== 0.0) {\r\n          divW = 1.0 / w;\r\n          rangeToExtend.extendXYZ(\r\n            buffer[i0] * divW,\r\n            buffer[i0 + 1] * divW,\r\n            buffer[i0 + 2] * divW);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * abstract declaration for evaluation of (unweighted) 3d point and derivatives.\r\n   * Derived classes must implement to get fractionToRigidFrame support.\r\n   * @param _fractionU u parameter\r\n   * @param _fractionV v parameter\r\n   * @param _result optional result.\r\n   */\r\n  public abstract fractionToPointAndDerivatives(_fractionU: number, _fractionV: number, _result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined;\r\n  /**\r\n   * evaluate the surface at u and v fractions. Return a (squared, right handed) coordinate frame at that point on the surface.\r\n   * @param fractionU u parameter\r\n   * @param fractionV v parameter\r\n   * @param result undefined if surface derivatives are parallel (or either alone is zero)\r\n   */\r\n  public fractionToRigidFrame(fractionU: number, fractionV: number, result?: Transform): Transform | undefined {\r\n    const skewVectors = this.fractionToPointAndDerivatives(fractionU, fractionV);\r\n    if (!skewVectors)\r\n      return undefined;\r\n    const axes = Matrix3d.createColumnsInAxisOrder(AxisOrder.XYZ,\r\n      skewVectors.vectorU, skewVectors.vectorV, undefined);\r\n    const axes1 = Matrix3d.createRigidFromMatrix3d(axes, AxisOrder.XYZ, axes);\r\n    if (axes1)\r\n      result = Transform.createOriginAndMatrix(skewVectors.origin, axes1, result);\r\n    return result;\r\n  }\r\n  /** a scratch array sized for `order` numbers */\r\n  protected _basisBufferUV: Float64Array[]; //  basis function buffers for u, v directions.   ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** a scratch array sized for `order` numbers */\r\n  protected _basisBuffer1UV: Float64Array[]; // basis function buffers for u, v directions.   ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n\r\n  /** a scratch array sized for one pole */\r\n  protected _poleBuffer: Float64Array; // one set of target values.  ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** array of 2 scratch array, each sized for one pole\r\n   * * used in derivative evaluations, with respective u and v derivatives in the respective arrays.\r\n  */\r\n  protected _poleBuffer1UV: Float64Array[]; // one set of target values.  ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n\r\n  /**\r\n   * initialize arrays for given spline dimensions.\r\n   */\r\n  protected constructor(numPolesU: number, numPolesV: number, poleLength: number, knotsU: KnotVector, knotsV: KnotVector) {\r\n    super();\r\n    const orderU = knotsU.degree + 1;\r\n    const orderV = knotsV.degree + 1;\r\n    this.knots = [knotsU, knotsV];\r\n    this.coffs = new Float64Array(numPolesU * numPolesV * poleLength);\r\n    this.poleDimension = poleLength;\r\n    this._basisBufferUV = [new Float64Array(orderU), new Float64Array(orderV)];\r\n    this._basisBuffer1UV = [new Float64Array(orderU), new Float64Array(orderV)];\r\n    this._numPoles = [numPolesU, numPolesV];\r\n    this._poleBuffer = new Float64Array(poleLength);\r\n    this._poleBuffer1UV = [new Float64Array(poleLength), new Float64Array(poleLength)];\r\n\r\n  }\r\n  /**\r\n   * Map a position, specified as (uv direction, bezier span, fraction within the bezier), to an overall knot value.\r\n   * @param select selector indicating U or V direction.\r\n   * @param span index of bezier span\r\n   * @param localFraction fractional coordinate within the bezier span\r\n   */\r\n  public spanFractionToKnot(select: UVSelect, span: number, localFraction: number): number {\r\n    return this.knots[select].spanFractionToKnot(span, localFraction);\r\n  }\r\n\r\n  /** Evaluate basis functions given\r\n   * * choice of u or v\r\n   * * span index\r\n   * * local fraction within the span.\r\n   */\r\n  public spanFractionsToBasisFunctions(select: UVSelect, spanIndex: number, spanFraction: number, f: Float64Array, df?: Float64Array) {\r\n    spanIndex = Geometry.clampToStartEnd(spanIndex, 0, this.numSpanUV(select));\r\n    const knotIndex0 = spanIndex + this.degreeUV(select) - 1;\r\n    const globalKnot = this.knots[select].baseKnotFractionToKnot(knotIndex0, spanFraction);\r\n    return df ?\r\n      this.knots[select].evaluateBasisFunctions1(knotIndex0, globalKnot, f, df) :\r\n      this.knots[select].evaluateBasisFunctions(knotIndex0, globalKnot, f);\r\n  }\r\n  /** sum poles by the weights in the basisBuffer, using poles for given span */\r\n  public sumPoleBufferForSpan(spanIndexU: number, spanIndexV: number) {\r\n    const poleBuffer = this._poleBuffer;\r\n    const coffs = this.coffs;\r\n    poleBuffer.fill(0);\r\n    const m = this.poleDimension;\r\n    const stepV = this.poleDimension * this._numPoles[0];\r\n    let kU = m * spanIndexU + spanIndexV * stepV;\r\n    let g = 0;\r\n    for (const fV of this._basisBufferUV[1]) {\r\n      let k = kU;\r\n      for (const fU of this._basisBufferUV[0]) {\r\n        g = fU * fV;\r\n        for (let j = 0; j < m; j++) {\r\n          poleBuffer[j] += g * coffs[k++];\r\n        }\r\n      }\r\n      kU += stepV;\r\n    }\r\n  }\r\n  /** sum derivatives by the weights in the basisBuffer, using poles for given span */\r\n  public sumpoleBufferDerivativesForSpan(spanIndexU: number, spanIndexV: number) {\r\n    const poleBuffer1U = this._poleBuffer1UV[0];\r\n    const poleBuffer1V = this._poleBuffer1UV[1];\r\n    poleBuffer1U.fill(0);\r\n    poleBuffer1V.fill(0);\r\n    const m = this.poleDimension;\r\n    const stepV = this.poleDimension * this._numPoles[0];\r\n    let kU = m * spanIndexU + spanIndexV * stepV;\r\n    // U partial derivatives ...\r\n    let g = 0;\r\n    for (const fV of this._basisBufferUV[1]) {\r\n      let k = kU;\r\n      for (const fU of this._basisBuffer1UV[0]) {\r\n        g = fU * fV;\r\n        for (let j = 0; j < m; j++) {\r\n          poleBuffer1U[j] += g * this.coffs[k++];\r\n        }\r\n      }\r\n      kU += stepV;\r\n    }\r\n\r\n    // V partial derivatives ...\r\n    kU = m * spanIndexU + spanIndexV * stepV;\r\n    for (const fV of this._basisBuffer1UV[1]) {\r\n      let k = kU;\r\n      for (const fU of this._basisBufferUV[0]) {\r\n        g = fU * fV;\r\n        for (let j = 0; j < m; j++) {\r\n          poleBuffer1V[j] += g * this.coffs[k++];\r\n        }\r\n      }\r\n      kU += stepV;\r\n    }\r\n  }\r\n  /**\r\n   * Evaluate the _basisBuffer, _poleBuffer and (optionally) _basisBuffer1 and _poleBuffer1 arrays at given knot.\r\n   *\r\n   * @param u u knot value\r\n   * @param v v not value\r\n   * @param numDerivative number of derivatives needed\r\n   */\r\n  public evaluateBuffersAtKnot(u: number, v: number, numDerivative: number = 0) {\r\n    const knotIndex0U = this.knots[0].knotToLeftKnotIndex(u);\r\n    const knotIndex0V = this.knots[1].knotToLeftKnotIndex(v);\r\n    const poleIndex0U = knotIndex0U - this.degreeUV(0) + 1;\r\n    const poleIndex0V = knotIndex0V - this.degreeUV(1) + 1;\r\n\r\n    if (numDerivative < 1) {\r\n      this.knots[0].evaluateBasisFunctions(knotIndex0U, u, this._basisBufferUV[0]);\r\n      this.knots[1].evaluateBasisFunctions(knotIndex0V, v, this._basisBufferUV[1]);\r\n      this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);\r\n    } else {\r\n      this.knots[0].evaluateBasisFunctions1(knotIndex0U, u, this._basisBufferUV[0], this._basisBuffer1UV[0]);\r\n      this.knots[1].evaluateBasisFunctions1(knotIndex0V, v, this._basisBufferUV[1], this._basisBuffer1UV[1]);\r\n      this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);\r\n      this.sumpoleBufferDerivativesForSpan(poleIndex0U, poleIndex0V);\r\n    }\r\n  }\r\n  // Swap numSwap entries in coffs, starting at i0 and i1 (absolute indices -- not blocks)\r\n  private swapBlocks(i0: number, i1: number, numSwap: number) {\r\n    let a: number;\r\n    for (let i = 0; i < numSwap; i++) {\r\n      a = this.coffs[i0 + i];\r\n      this.coffs[i0 + i] = this.coffs[i1 + i];\r\n      this.coffs[i1 + i] = a;\r\n    }\r\n  }\r\n  /**\r\n   * Reverse the parameter direction for either u or v.\r\n   * @param select direction to reverse -- 0 for u, 1 for v.\r\n   */\r\n  public reverseInPlace(select: UVSelect): void {\r\n    const m = this.poleDimension;\r\n    const numU = this.numPolesUV(0);\r\n    const numV = this.numPolesUV(1);\r\n    if (select === 0) {\r\n      // reverse within rows.\r\n      for (let j = 0; j < numV; j++) {\r\n        const rowStart = j * numU * m;\r\n        for (let i0 = 0, i1 = numU - 1; i0 < i1; i0++ , i1--) {\r\n          this.swapBlocks(rowStart + i0 * m, rowStart + i1 * m, m);\r\n        }\r\n      }\r\n    } else {\r\n      // swap full rows ..\r\n      const numPerRow = m * numU;\r\n      for (let i0 = 0, i1 = (numV - 1) * numPerRow;\r\n        i0 < i1;\r\n        i0 += numPerRow, i1 -= numPerRow) {\r\n        this.swapBlocks(i0, i1, numPerRow);\r\n      }\r\n    }\r\n    this.knots[select].reflectKnots();\r\n  }\r\n  /**\r\n   * Set the flag indicating the bspline might be suitable for having wrapped \"closed\" interpretation.\r\n   */\r\n  public setWrappable(select: UVSelect, value: BSplineWrapMode) {\r\n    this.knots[select].wrappable = value;\r\n  }\r\n  /**\r\n   * Test if `degree` leading and trailing (one of U or V) blocks match, as if the data is an unwrapped closed spline in the selected direction.\r\n   * @param select select U or V direction\r\n   * @returns true if coordinates matched.\r\n   */\r\n  public isClosable(select: UVSelect): boolean {\r\n    if (this.knots[select].wrappable === BSplineWrapMode.None)\r\n      return false;\r\n    if (!this.knots[select].testClosable())\r\n      return false;\r\n\r\n    const numU = this.numPolesUV(0);\r\n    const numV = this.numPolesUV(1);\r\n    const blockSize = this.poleDimension;\r\n    const rowToRowStep = numU * blockSize;\r\n    const degreeU = this.degreeUV(0);\r\n    const degreeV = this.degreeUV(1);\r\n    const data = this.coffs;\r\n    if (select === 0) {\r\n      const numTest = blockSize * degreeU;  // degreeU contiguous poles.\r\n      for (let row = 0; row < numV; row++) {\r\n        const i0 = row * rowToRowStep;\r\n        const i1 = i0 + rowToRowStep - numTest;\r\n        for (let i = 0; i < numTest; i++) {\r\n          if (!Geometry.isSameCoordinate(data[i0 + i], data[i1 + i]))\r\n            return false;\r\n        }\r\n      }\r\n    } else {\r\n      // Test the entire multi-row contiguous block in one loop . ..\r\n      const numTest = degreeV * rowToRowStep;\r\n      const i1 = blockSize * numU * numV - numTest;\r\n      for (let i = 0; i < numTest; i++) {\r\n        if (!Geometry.isSameCoordinate(data[i], data[i1 + i]))\r\n          return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n/**  BSplineSurface3d is a parametric surface in xyz space.\r\n * * This (BSplineSurface3d) is an unweighted surface.   Use the separate class BSplineSurface3dH for a weighted surface.\r\n *\r\n * The various static \"create\" methods have subtle differences in how grid sizes are conveyed:\r\n * | Method | control point array | counts |\r\n * | create | flat array of [x,y,z] | arguments numPolesU, numPolesV |\r\n * | createGrid | array of array of [x,y,z ] | There are no `numPolesU` or `numPolesV` args. The counts are conveyed by the deep arrays |\r\n * @public\r\n */\r\nexport class BSplineSurface3d extends BSpline2dNd implements BSplineSurface3dQuery {\r\n  /** Test if `other` is an instance of `BSplineSurface3d */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BSplineSurface3d; }\r\n  /** Apply the transform to the poles */\r\n  public tryTransformInPlace(transform: Transform): boolean { Point3dArray.multiplyInPlace(transform, this.coffs); return true; }\r\n  /** Return a pole by u and v indices */\r\n  public getPole(i: number, j: number, result?: Point3d): Point3d | undefined {\r\n    return this.getPoint3dPole(i, j, result);\r\n  }\r\n\r\n  private constructor(numPolesU: number, numPolesV: number, knotsU: KnotVector, knotsV: KnotVector) {\r\n    super(numPolesU, numPolesV, 3, knotsU, knotsV);\r\n  }\r\n  /**\r\n   * Return control points json arrays.\r\n   * * if `flatArray===true`, each point appears as an array [x,y,z] in row-major order of a containing array.\r\n   * * if `flatArray===false` each row of points is an an array of [x,y,z] in an array.  Each of these row arrays is in the result array.\r\n   */\r\n  public getPointArray(flatArray: boolean = true): any[] {\r\n    if (flatArray)\r\n      return Point3dArray.unpackNumbersToNestedArrays(this.coffs, 3);\r\n    return Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0));\r\n  }\r\n  /**\r\n   * Return control points json arrays.\r\n   * * Each row of points is an an array.\r\n   * * Within the array for each row, each point is an array [x,y,z]\r\n   */\r\n  public getPointGridJSON(): PackedPointGrid {\r\n    const result = {\r\n      points: Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0)),\r\n      weighStyle: WeightStyle.UnWeighted,\r\n      numCartesianDimensions: 3,\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /** Return a simple array of the control points coordinates */\r\n  public copyPointsFloat64Array(): Float64Array { return this.coffs.slice(); }\r\n  /**\r\n   * return a simple array form of the knots.  optionally replicate the first and last\r\n   * in classic over-clamped manner\r\n   */\r\n  public copyKnots(select: UVSelect, includeExtraEndKnot: boolean): number[] { return this.knots[select].copyKnots(includeExtraEndKnot); }\r\n\r\n  /** Create a bspline surface.\r\n   * * This `create` variant takes control points in a \"flattened\" array, with\r\n   *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in\r\n   *  a row-by-row grid structure\r\n   * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omitted (undefined).\r\n   * *  When knots are given, two knot count conditions are recognized:\r\n   * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have\r\n   *      the classic unused first and last knot.\r\n   * @param controlPointArray Array of points, ordered along the U direction.\r\n   * @param numPoleU number of poles in each row in the U direction.\r\n   * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayU knots for the V direction.  See note above about knot counts.\r\n   * @param numPoleV number of poles in each row in the U direction.\r\n   * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayV knots for the V direction.  See note above about knot counts.\r\n   */\r\n  public static create(controlPointArray: Point3d[] | Float64Array,\r\n    numPolesU: number,\r\n    orderU: number,\r\n    knotArrayU: number[] | Float64Array | undefined,\r\n    numPolesV: number,\r\n    orderV: number,\r\n    knotArrayV: number[] | Float64Array | undefined): BSplineSurface3d | undefined {\r\n    let numPoles = controlPointArray.length;\r\n    if (controlPointArray instanceof Float64Array)\r\n      numPoles /= 3;\r\n    if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\r\n      return undefined;\r\n    // shift knots-of-interest limits for overclampled case ...\r\n    const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;\r\n    const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;\r\n    const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\r\n    const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\r\n\r\n    const knotsU = knotArrayU ?\r\n      KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :\r\n      KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\r\n    const knotsV = knotArrayV ?\r\n      KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :\r\n      KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);\r\n\r\n    const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV);\r\n    if (controlPointArray instanceof Float64Array) {\r\n      let i = 0;\r\n      for (const coordinate of controlPointArray) { surface.coffs[i++] = coordinate; }\r\n    } else {\r\n      let i = 0;\r\n      for (const p of controlPointArray) { surface.coffs[i++] = p.x; surface.coffs[i++] = p.y; surface.coffs[i++] = p.z; }\r\n    }\r\n    return surface;\r\n  }\r\n\r\n  /** Create a bspline surface.\r\n   * * This `create` variant takes control points in a \"grid\" array, with the points from\r\n   * each grid row `[rowIndex]` being an independent array `points[rowIndex][indexAlongRow][x,y,z]`\r\n   * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omited (undefined).\r\n   * *  When knots are given, two knot count conditions are recognized:\r\n   * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have\r\n   *      the classic unused first and last knot.\r\n   * @param controlPointArray Array of points, ordered along the U direction.\r\n   * @param numPoleU number of poles in each row in the U direction.\r\n   * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayU knots for the V direction.  See note above about knot counts.\r\n   * @param numPoleV number of poles in each row in the U direction.\r\n   * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayV knots for the V direction.  See note above about knot counts.\r\n   */\r\n  public static createGrid(points: number[][][],\r\n    orderU: number,\r\n    knotArrayU: number[] | Float64Array | undefined,\r\n    orderV: number,\r\n    knotArrayV: number[] | Float64Array | undefined): BSplineSurface3d | undefined {\r\n    const numPolesV = points.length;\r\n    const numPolesU = points[0].length;\r\n    const numPoles = numPolesU * numPolesV;\r\n    // shift knots-of-interest limits for overclamped case ...\r\n    const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;\r\n    const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;\r\n    const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\r\n    const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\r\n    if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\r\n      return undefined;\r\n\r\n    const knotsU = knotArrayU ?\r\n      KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :\r\n      KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\r\n    const knotsV = knotArrayV ?\r\n      KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :\r\n      KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\r\n\r\n    const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV);\r\n    let i = 0;\r\n    for (const row of points) {\r\n      for (const xyz of row) {\r\n        surface.coffs[i++] = xyz[0];\r\n        surface.coffs[i++] = xyz[1];\r\n        surface.coffs[i++] = xyz[2];\r\n      }\r\n    }\r\n    return surface;\r\n  }\r\n  /**\r\n   * Return a complete copy of the bspline surface.\r\n   */\r\n  public clone(): BSplineSurface3d {\r\n    const knotVector1U = this.knots[0].clone();\r\n    const knotVector1V = this.knots[1].clone();\r\n    const surface1 = new BSplineSurface3d(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V);\r\n    surface1.coffs = this.coffs.slice();\r\n    return surface1;\r\n  }\r\n  /**\r\n   * Return a complete copy of the bspline surface, with a transform applied to the control points.\r\n   * @param transform transform to apply to the control points\r\n   */\r\n  public cloneTransformed(transform: Transform): BSplineSurface3d {\r\n    const surface1 = this.clone();\r\n    surface1.tryTransformInPlace(transform);\r\n    return surface1;\r\n  }\r\n\r\n  /** Evaluate at a position given by u and v coordinates in knot space.\r\n   * @param u u value, in knot range.\r\n   * @param v v value in knot range.\r\n * @returns Return the xyz coordinates on the surface.\r\n   */\r\n  public knotToPoint(u: number, v: number): Point3d {\r\n    this.evaluateBuffersAtKnot(u, v);\r\n    return Point3d.createFrom(this._poleBuffer);\r\n  }\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPointAndDerivatives(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    this.evaluateBuffersAtKnot(u, v, 1);\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsArrays(\r\n      this._poleBuffer, this._poleBuffer1UV[0], this._poleBuffer1UV[1], result);\r\n  }\r\n  /** Evaluate at a position given by fractional coordinate in each direction.\r\n     * @param fractionU u coordinate, as a fraction of the knot range.\r\n     * @param fractionV v coordinate, as a fraction of the knot range.\r\n   * @returns Return the xyz coordinates on the surface.\r\n   */\r\n  public fractionToPoint(fractionU: number, fractionV: number): Point3d {\r\n    return this.knotToPoint(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));\r\n  }\r\n\r\n  /**\r\n   * evaluate the surface at u and v fractions.\r\n   * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.\r\n   * @param fractionU u coordinate, as a fraction of the knot range.\r\n   * @param fractionV v coordinate, as a fraction of the knot range.\r\n   * @param result optional pre-allocated object for return values.\r\n   * @returns Returns point and derivative directions.\r\n   */\r\n  public fractionToPointAndDerivatives(fractionU: number, fractionV: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const knotU = this.knots[0].fractionToKnot(fractionU);\r\n    const knotV = this.knots[1].fractionToKnot(fractionV);\r\n    return this.knotToPointAndDerivatives(knotU, knotV, result);\r\n  }\r\n  /** test for identical counts and near-equal coordinates */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BSplineSurface3d) {\r\n      return this.knots[0].isAlmostEqual(other.knots[0])\r\n        && this.knots[1].isAlmostEqual(other.knots[1])\r\n        && Point3dArray.isAlmostEqual(this.coffs, other.coffs);\r\n    }\r\n    return false;\r\n  }\r\n  /** Test if all poles are in a plane */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Point3dArray.isCloseToPlane(this.coffs, plane);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBSplineSurface3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBSplineSurface3d(this);\r\n  }\r\n  /** Extend the range to include all poles\r\n   * * This is not a tight range.\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    this.extendRangeXYZ(rangeToExtend, transform);\r\n  }\r\n\r\n}\r\n\r\n/**  BsplinceCurve in xyzw homogeneous space\r\n * @public\r\n */\r\nexport class BSplineSurface3dH extends BSpline2dNd implements BSplineSurface3dQuery {\r\n  /** Test if `other` is an instance of `BSplineSurface3dH */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BSplineSurface3dH; }\r\n  /** Apply the transform to the poles */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    Point4dArray.multiplyInPlace(transform, this.coffs); return true;\r\n  }\r\n  /** Return a pole by u and v indices */\r\n  public getPole(i: number, j: number, result?: Point3d): Point3d | undefined {\r\n    return this.getPoint3dPoleXYZW(i, j, result);\r\n  }\r\n\r\n  private constructor(numPolesU: number, numPolesV: number, knotsU: KnotVector, knotsV: KnotVector) {\r\n    super(numPolesU, numPolesV, 4, knotsU, knotsV);\r\n  }\r\n  /** Return a simple array of the control points. */\r\n  public copyPoints4d(): Point4d[] { return Point4dArray.unpackToPoint4dArray(this.coffs); }\r\n\r\n  /** Return a simple array of the control points. */\r\n  public copyPointsAndWeights(points: Point3d[], weights: number[],\r\n    formatter: (x: number, y: number, z: number) => any = Point3d.create) {\r\n    Point4dArray.unpackFloat64ArrayToPointsAndWeights(this.coffs, points, weights,\r\n      formatter);\r\n  }\r\n\r\n  /**\r\n   * return a simple array form of the knots.  optionally replicate the first and last\r\n   * in classic over-clamped manner\r\n   */\r\n  public copyKnots(select: UVSelect, includeExtraEndKnot: boolean): number[] { return this.knots[select].copyKnots(includeExtraEndKnot); }\r\n\r\n  /** Create a weighted bspline surface, with control points and weights each organized as flattened array of points continuing from one U row to the next.\r\n   * * This `create` variant takes control points in a \"flattened\" array, with\r\n   *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in\r\n   *  a deeper grid array structure.\r\n   * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omitted (undefined).\r\n   * *  When knots are given, two knot count conditions are recognized:\r\n   * * * If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * * * If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have\r\n   *      the classic unused first and last knot.\r\n   * @param controlPointArray Array of points, ordered along the U direction.\r\n   * @param weightArray array of weights, ordered along the U direction.\r\n   * @param numPoleU number of poles in each row in the U direction.\r\n   * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayU optional knots for the V direction.  See note above about knot counts.\r\n   * @param numPoleV number of poles in each row in the U direction.\r\n   * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayV optional knots for the V direction.  See note above about knot counts.\r\n   */\r\n  public static create(\r\n    controlPointArray: Point3d[],\r\n    weightArray: number[],\r\n    numPolesU: number,\r\n    orderU: number,\r\n    knotArrayU: number[] | undefined,\r\n    numPolesV: number,\r\n    orderV: number,\r\n    knotArrayV: number[] | undefined): BSplineSurface3dH | undefined {\r\n    const numPoles = controlPointArray.length;\r\n    if (numPolesU * numPolesV !== numPoles) return undefined;\r\n    if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\r\n      return undefined;\r\n\r\n    const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;\r\n    const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;\r\n    const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\r\n    const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\r\n\r\n    const knotsU = knotArrayU ?\r\n      KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :\r\n      KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\r\n    const knotsV = knotArrayV ?\r\n      KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :\r\n      KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);\r\n\r\n    const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV);\r\n    Point4dArray.packPointsAndWeightsToFloat64Array(controlPointArray, weightArray, surface.coffs);\r\n    return surface;\r\n  }\r\n\r\n  /** Create a bspline with given knots.\r\n   *\r\n   *   Two count conditions are recognized in each direction:\r\n   *\r\n   * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.\r\n   *\r\n   */\r\n  public static createGrid(\r\n    xyzwGrid: number[][][],\r\n    weightStyle: WeightStyle,\r\n    orderU: number,\r\n    knotArrayU: number[],\r\n    orderV: number,\r\n    knotArrayV: number[]): BSplineSurface3dH | undefined {\r\n    const numPolesV = xyzwGrid.length;\r\n    const numPolesU = xyzwGrid[0].length;\r\n    const numPoles = numPolesU * numPolesV;\r\n    if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\r\n      return undefined;\r\n\r\n    // const numPoles = numPolesU * numPolesV;\r\n    // shift knots-of-interest limits for overclamped case ...\r\n    const numKnotsU = knotArrayU.length;\r\n    const numKnotsV = knotArrayV.length;\r\n    const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\r\n    const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\r\n\r\n    const knotsU = KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU);\r\n    const knotsV = KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV);\r\n\r\n    const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV);\r\n\r\n    if (weightStyle === WeightStyle.WeightsSeparateFromCoordinates) {\r\n      let i = 0;\r\n      for (const row of xyzwGrid) {\r\n        for (const point of row) {\r\n          const w = point[3];\r\n          surface.coffs[i++] = point[0] * w;\r\n          surface.coffs[i++] = point[1] * w;\r\n          surface.coffs[i++] = point[2] * w;\r\n          surface.coffs[i++] = point[3];\r\n        }\r\n      }\r\n    } else {\r\n      // implicit WeightStyle.WeightsAlreadyAppliedToCoordinates\r\n      let i = 0;\r\n      for (const row of xyzwGrid) {\r\n        for (const point of row) {\r\n          surface.coffs[i++] = point[0];\r\n          surface.coffs[i++] = point[1];\r\n          surface.coffs[i++] = point[2];\r\n          surface.coffs[i++] = point[3];\r\n        }\r\n      }\r\n    }\r\n    return surface;\r\n  }\r\n  /** Return a deep clone */\r\n  public clone(): BSplineSurface3dH {\r\n    const knotVector1U = this.knots[0].clone();\r\n    const knotVector1V = this.knots[1].clone();\r\n    const surface1 = new BSplineSurface3dH(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V);\r\n    surface1.coffs = this.coffs.slice();\r\n    return surface1;\r\n  }\r\n  /** Return a transformed clone */\r\n  public cloneTransformed(transform: Transform): BSplineSurface3dH {\r\n    const surface1 = this.clone();\r\n    surface1.tryTransformInPlace(transform);\r\n    return surface1;\r\n  }\r\n  /**\r\n    * Return control points json arrays.\r\n    * * Each row of points is an an array.\r\n    * * Within the array for each row, each point is an array [wx,wy,wz,w].\r\n    */\r\n  public getPointGridJSON(): PackedPointGrid {\r\n    const result = {\r\n      points: Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 4, this.numPolesUV(0)),\r\n      numCartesianDimensions: 3,\r\n      weightStyle: WeightStyle.WeightsAlreadyAppliedToCoordinates,\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPoint4d(u: number, v: number): Point4d {\r\n    this.evaluateBuffersAtKnot(u, v);\r\n    return Point4d.createFromPackedXYZW(this._poleBuffer, 0);\r\n  }\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPointAndDerivatives(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    this.evaluateBuffersAtKnot(u, v, 1);\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsWeightedArrays(this._poleBuffer, this._poleBuffer1UV[0], this._poleBuffer1UV[1], result);\r\n  }\r\n\r\n  /** Evaluate the Point4d (leaving weights in the point) at given fractional coordinates. */\r\n  public fractionToPoint4d(fractionU: number, fractionV: number): Point4d {\r\n    return this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));\r\n  }\r\n  /**\r\n   * * evaluate the surface and return the cartesian (weight = 1) point.\r\n   * * if the surface XYZW point has weight0, returns point3d at 000.\r\n   * @param fractionU u direction fraction\r\n   * @param fractionV v direction fraction\r\n   * @param result optional result\r\n   */\r\n  public fractionToPoint(fractionU: number, fractionV: number, result?: Point3d): Point3d {\r\n    const point4d = this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));\r\n    return point4d.realPointDefault000(result);\r\n  }\r\n  /**\r\n * * evaluate the surface and return the cartesian (weight = 1) point.\r\n * * if the surface XYZW point has weight0, returns point3d at 000.\r\n * @param knotU u direction knot\r\n * @param knotV v direction knot\r\n * @param result optional result\r\n */\r\n  public knotToPoint(knotU: number, knotV: number, result?: Point3d): Point3d {\r\n    const point4d = this.knotToPoint4d(knotU, knotV);\r\n    return point4d.realPointDefault000(result);\r\n  }\r\n  /**\r\n   * evaluate the surface at u and v fractions.\r\n   * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.\r\n   * @param fractionU u coordinate, as a fraction of the knot range.\r\n   * @param fractionV v coordinate, as a fraction of the knot range.\r\n   * @param result optional pre-allocated object for return values.\r\n   * @returns Returns point and derivative directions.\r\n   */\r\n  public fractionToPointAndDerivatives(fractionU: number, fractionV: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const knotU = this.knots[0].fractionToKnot(fractionU);\r\n    const knotV = this.knots[1].fractionToKnot(fractionV);\r\n    return this.knotToPointAndDerivatives(knotU, knotV, result);\r\n  }\r\n  /** test for identical counts and near-equal coordinates */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BSplineSurface3dH) {\r\n      return this.knots[0].isAlmostEqual(other.knots[0])\r\n        && this.knots[1].isAlmostEqual(other.knots[1])\r\n        && Point4dArray.isAlmostEqual(this.coffs, other.coffs);\r\n    }\r\n    return false;\r\n  }\r\n  /** Test if all poles are in a plane */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Point4dArray.isCloseToPlane(this.coffs, plane);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBSplineSurface3dH(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBSplineSurface3dH(this);\r\n  }\r\n  /**\r\n   * extend a range to include the (optionally transformed) points of this surface\r\n   * @param rangeToExtend range that is updated to include this surface range\r\n   * @param transform transform to apply to the surface points\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    this.extendRangeXYZH(rangeToExtend, transform);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\r\nimport { BezierCoffs, UnivariateBezier } from \"../numerics/BezierPolynomials\";\r\nimport { KnotVector } from \"./KnotVector\";\r\n/** @module Bspline */\r\n/**\r\n * Shared implementation details for derived bezier curve classes\r\n * * BezierCurve3d implements with blockSize 3.\r\n * * BezierCurve3dH implements with blockSize 4.\r\n * @public\r\n */\r\nexport class Bezier1dNd {\r\n  private _packedData: Float64Array;\r\n  private _order: number; // bezier order.   probably low\r\n  private _blockSize: number; // loosely expected to be 1 to 4.\r\n  private _basis: BezierCoffs; // server for basis queries.  It carries coefficients that we don't use.\r\n  // constructor CAPTURES the control points array.\r\n  public constructor(blockSize: number, polygon: Float64Array) {\r\n    this._blockSize = blockSize;\r\n    this._order = Math.floor(polygon.length / blockSize); // This should be an integer!!!\r\n    this._packedData = polygon;\r\n    this._basis = new UnivariateBezier(this._order);\r\n  }\r\n  /** return a clone of the data array */\r\n  public clonePolygon(result?: Float64Array): Float64Array {\r\n    const n = this._packedData.length;\r\n    if (!result || result.length !== n)\r\n      return this._packedData.slice();\r\n    /** move data into the supplied result */\r\n    for (let i = 0; i < n; i++)\r\n      result[i] = this._packedData[i];\r\n    return result;\r\n  }\r\n  /** Return the bezier order */\r\n  public get order() { return this._order; }\r\n  /** return the packed data array.  This is a REFERENCE to the array. */\r\n  public get packedData() { return this._packedData; }\r\n  /** Create a Bezier1dNd, using the structure of `data[0]` to determine the bezier order. */\r\n  public static create(data: Point2d[] | Point3d[] | Point4d[]): Bezier1dNd | undefined {\r\n    if (data.length < 1)\r\n      return undefined;\r\n    if (data[0] instanceof Point3d) {\r\n      const polygon = new Float64Array(data.length * 3);\r\n      let i = 0;\r\n      for (const p of (data as Point3d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = p.z;\r\n      }\r\n      return new Bezier1dNd(3, polygon);\r\n    } else if (data[0] instanceof Point4d) {\r\n      const polygon = new Float64Array(data.length * 4);\r\n      let i = 0;\r\n      for (const p of (data as Point4d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = p.z;\r\n        polygon[i++] = p.w;\r\n      }\r\n      return new Bezier1dNd(4, polygon);\r\n    } else if (data[0] instanceof Point2d) {\r\n      const polygon = new Float64Array(data.length * 2);\r\n      let i = 0;\r\n      for (const p of (data as Point2d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n      }\r\n      return new Bezier1dNd(2, polygon);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return the curve value at bezier fraction `s`\r\n   * @return buffer of length `blockSize`.\r\n   */\r\n  public evaluate(s: number, buffer?: Float64Array): Float64Array {\r\n    return this._basis.sumBasisFunctions(s, this._packedData, this._blockSize, buffer);\r\n  }\r\n  /** Return the curve derivative value at bezier fraction `s`\r\n   * @return buffer of length `blockSize`.\r\n   */\r\n  public evaluateDerivative(s: number, buffer?: Float64Array): Float64Array {\r\n    return this._basis.sumBasisFunctionDerivatives(s, this._packedData, this._blockSize, buffer);\r\n  }\r\n  /** get a single point of the polygon as a simple array.  */\r\n  public getPolygonPoint(i: number, buffer?: Float64Array): Float64Array | undefined {\r\n    if (!buffer)\r\n      buffer = new Float64Array(this._blockSize);\r\n    if (i >= 0 && i < this._order) {\r\n      const k0 = this._blockSize * i;\r\n      for (let k = 0; k < this._blockSize; k++)\r\n        buffer[k] = this._packedData[k0 + k];\r\n      return buffer;\r\n    }\r\n    return undefined;\r\n  }\r\n  /** set a single point of the polygon as a simple array.  */\r\n  public setPolygonPoint(i: number, buffer: Float64Array) {\r\n    if (i >= 0 && i < this._order) {\r\n      const k0 = this._blockSize * i;\r\n      for (let k = 0; k < this._blockSize; k++)\r\n        this._packedData[k0 + k] = buffer[k];\r\n    }\r\n  }\r\n  /** Load order * dimension doubles from data[dimension * spanIndex] as poles\r\n   * @param data packed source array.  block size in `data` assumed to match dimension for this.\r\n   * @param spanIndex block index in data.\r\n   */\r\n  public loadSpanPoles(data: Float64Array, spanIndex: number) {\r\n    let k = spanIndex * this._blockSize;\r\n    for (let i = 0; i < this._packedData.length; i++)\r\n      this._packedData[i] = data[k++];\r\n  }\r\n  /** Load order * (dataDimension + 1)  doubles from data[dataDimension * spanIndex] as poles with weight inserted\r\n   * @param data packed array of data.\r\n   * @param dataDimension dimension of data. Must have `dataDimension+1=this.order`\r\n   * @param spanIndex index of first data block to access.\r\n   * @param weight weight to append to each block\r\n   */\r\n  public loadSpanPolesWithWeight(data: Float64Array, dataDimension: number, spanIndex: number, weight: number) {\r\n    let destIndex = 0;\r\n    const order = this._order;\r\n    let dataIndex = spanIndex * dataDimension;\r\n    for (let i = 0; i < order; i++) {\r\n      for (let j = 0; j < dataDimension; j++)\r\n        this._packedData[destIndex++] = data[dataIndex++];\r\n      this._packedData[destIndex++] = weight;\r\n    }\r\n  }\r\n  /**  return a json array of arrays with each control point as a lower level array of numbers */\r\n  public unpackToJsonArrays(): any[] {\r\n    return Point3dArray.unpackNumbersToNestedArrays(this._packedData, this._blockSize);\r\n  }\r\n  /** equality test with usual metric tolerances */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof Bezier1dNd) {\r\n      if (this._blockSize !== other._blockSize)\r\n        return false;\r\n      if (this._order !== other._order)\r\n        return false;\r\n      if (this._packedData.length !== other._packedData.length)\r\n        return false;\r\n      for (let i = 0; i < this._packedData.length; i++) {\r\n        if (!Geometry.isSameCoordinate(this._packedData[i], other._packedData[i]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** block-by-block reversal */\r\n  public reverseInPlace() {\r\n    const m = this._blockSize;\r\n    const n = this._order;\r\n    let i, j;\r\n    let a;\r\n    for (i = 0, j = (n - 1) * m; i < j; i += m, j -= m) {\r\n      for (let k = 0; k < m; k++) {\r\n        a = this._packedData[i + k];\r\n        this._packedData[i + k] = this._packedData[j + k];\r\n        this._packedData[j + k] = a;\r\n      }\r\n    }\r\n  }\r\n  //\r\n  /**\r\n   * interpolate at `fraction` between poleA and poleB.\r\n   * * Data is left \"in place\" in poleIndexA\r\n   * @param poleIndexA first pole index\r\n   * @param fraction fractional position\r\n   * @param poleIndexB second pole index\r\n   */\r\n  public interpolatePoleInPlace(poleIndexA: number, fraction: number, poleIndexB: number) {\r\n    let i0 = poleIndexA * this._blockSize;\r\n    let i1 = poleIndexB * this._blockSize;\r\n    const data = this._packedData;\r\n    for (let i = 0; i < this._blockSize; i++ , i0++ , i1++) {\r\n      data[i0] += fraction * (data[i1] - data[i0]);\r\n    }\r\n  }\r\n  private static _knotTolerance = 1.0e-8;\r\n  /**\r\n   * Compute new control points to \"clamp\" bspline unsaturated support to saturated form.\r\n   * * At input time, the control points are associated with the input knots (unsaturated)\r\n   * * At output, they control points are modified by repeated knot insertion to be fully clamped.\r\n   * @param knots knot values for the current (unsaturated) pole set\r\n   * @param spanIndex index of span whose (unsaturated) poles are in the bezier.\r\n   * @param optional function for `setInterval (knotA, knotB)` call to announce knot limits.\r\n   */\r\n  public saturateInPlace(knots: KnotVector, spanIndex: number): boolean {\r\n    const degree = knots.degree;\r\n    const kA = spanIndex + degree - 1; // left knot index of the active span\r\n    const kB = kA + 1;\r\n    if (spanIndex < 0 || spanIndex >= knots.numSpans)\r\n      return false;\r\n    const knotArray = knots.knots;\r\n    const knotA = knotArray[kA];\r\n    const knotB = knotArray[kB];\r\n    this.setInterval(knotA, knotB);\r\n    if (knotB <= knotA + Bezier1dNd._knotTolerance)\r\n      return false;\r\n    for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\r\n      //  left numInsert poles are pulled forward\r\n      let k0 = kA - numInsert;\r\n      if (knotArray[k0] < knotA) {\r\n        let k1 = kB;\r\n        for (let i = 0; i < numInsert; i++ , k0++ , k1++) {\r\n          const knot0 = knotArray[k0];\r\n          const knot1 = knotArray[k1];\r\n          const fraction = (knotA - knot0) / (knot1 - knot0);\r\n          this.interpolatePoleInPlace(i, fraction, i + 1);\r\n        }\r\n      }\r\n    }\r\n    for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\r\n      let k2 = kB + numInsert;\r\n      if (knotArray[k2] > knotB) {\r\n        for (let i = 0; i < numInsert; i++ , k2--) {\r\n          const knot2 = knotArray[k2]; // right side of moving window\r\n          // left side of window ia always the (previously saturated) knotA\r\n          const fraction = (knotB - knot2) / (knotA - knot2);\r\n          this.interpolatePoleInPlace(degree - i, fraction, degree - i - 1);\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Saturate a univariate bspline coefficient array in place\r\n   * * On input, the array is the coefficients one span of a bspline, packed in an array of `(knots.order)` values.\r\n   * * These are modified in place, and on return are a bezier for the same knot interval.\r\n   * @param coffs input as bspline coefficients, returned as bezier coefficients\r\n   * @param knots knot vector\r\n   * @param spanIndex index of span whose (unsaturated) poles are in the coefficients.\r\n   * @param optional function for `setInterval (knotA, knotB)` call to announce knot limits.\r\n   */\r\n  public static saturate1dInPlace(coffs: Float64Array, knots: KnotVector, spanIndex: number): boolean {\r\n    const degree = knots.degree;\r\n    const kA = spanIndex + degree - 1; // left knot index of the active span\r\n    const kB = kA + 1;\r\n    if (spanIndex < 0 || spanIndex >= knots.numSpans)\r\n      return false;\r\n    const knotArray = knots.knots;\r\n    const knotA = knotArray[kA];\r\n    const knotB = knotArray[kB];\r\n    for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\r\n      //  left numInsert poles are pulled forward\r\n      let k0 = kA - numInsert;\r\n      if (knotArray[k0] < knotA) {\r\n        let k1 = kB;\r\n        for (let i = 0; i < numInsert; i++ , k0++ , k1++) {\r\n          const knot0 = knotArray[k0];\r\n          const knot1 = knotArray[k1];\r\n          const fraction = (knotA - knot0) / (knot1 - knot0);\r\n          coffs[i] = coffs[i] + fraction * (coffs[i + 1] - coffs[i]);\r\n        }\r\n      }\r\n    }\r\n    for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\r\n      let k2 = kB + numInsert;\r\n      let k;\r\n      if (knotArray[k2] > knotB) {\r\n        for (let i = 0; i < numInsert; i++ , k2--) {\r\n          const knot2 = knotArray[k2]; // right side of moving window\r\n          // left side of window ia always the (previously saturated) knotA\r\n          const fraction = (knotB - knot2) / (knotA - knot2);\r\n          k = degree - i;\r\n          coffs[k] += fraction * (coffs[k - 1] - coffs[k]);\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Apply deCasteljou interpolations to isolate a smaller bezier polygon, representing interval 0..fraction of the original\r\n   * @param fraction \"end\" fraction for split.\r\n   * @returns false if fraction is 0 -- no changes applied.\r\n   */\r\n  public subdivideInPlaceKeepLeft(fraction: number): boolean {\r\n    if (Geometry.isAlmostEqualNumber(fraction, 1.0))\r\n      return true;\r\n    if (Geometry.isAlmostEqualNumber(fraction, 0.0))\r\n      return false;\r\n    const g = 1.0 - fraction;   // interpolations will pull towards right indices\r\n    const order = this.order;\r\n    for (let level = 1; level < order; level++) {\r\n      for (let i1 = order - 1; i1 >= level; i1--) {\r\n        this.interpolatePoleInPlace(i1, g, i1 - 1); // leave updates to right\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Apply deCasteljou interpolations to isolate a smaller bezier polygon, representing interval 0..fraction of the original\r\n   * @param fraction \"end\" fraction for split.\r\n   * @returns false if fraction is 0 -- no changes applied.\r\n   */\r\n  public subdivideInPlaceKeepRight(fraction: number): boolean {\r\n    if (Geometry.isAlmostEqualNumber(fraction, 0.0))\r\n      return true;\r\n    if (Geometry.isAlmostEqualNumber(fraction, 1.0))\r\n      return false;\r\n    const order = this.order;\r\n    for (let level = 1; level < order; level++) {\r\n      for (let i0 = 0; i0 + level < order; i0++)\r\n        this.interpolatePoleInPlace(i0, fraction, i0 + 1);   // leave updates to left.\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Saturate a univariate bspline coefficient array in place\r\n   * @param fraction0 fraction for first split.   This is the start of the output polygon\r\n   * @param fraction1 fraction for first split.   This is the start of the output polygon\r\n   * @return false if fractions are (almost) identical.\r\n   */\r\n  public subdivideToIntervalInPlace(fraction0: number, fraction1: number): boolean {\r\n    if (Geometry.isAlmostEqualNumber(fraction0, fraction1))\r\n      return false;\r\n    if (fraction1 < fraction0) {\r\n      this.subdivideToIntervalInPlace(fraction0, fraction1);\r\n      this.reverseInPlace();\r\n      return true;\r\n    }\r\n    this.subdivideInPlaceKeepLeft(fraction1);\r\n    this.subdivideInPlaceKeepRight(fraction0 / fraction1);\r\n    return true;\r\n  }\r\n\r\n  /** optional interval for mapping to a parent object */\r\n  public interval?: Segment1d;\r\n  /** create or update the mapping to parent curve. */\r\n  public setInterval(a: number, b: number) {\r\n    this.interval = Segment1d.create(a, b, this.interval);\r\n  }\r\n  /** map a fraction to the parent space. */\r\n  public fractionToParentFraction(fraction: number): number { return this.interval ? this.interval.fractionToPoint(fraction) : fraction; }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { BezierCurveBase } from \"./BezierCurveBase\";\r\nimport { BezierPolynomialAlgebra } from \"../numerics/BezierPolynomials\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\n/** @module Bspline */\r\n\r\n// ================================================================================================================\r\n// ================================================================================================================\r\n// ================================================================================================================\r\n// ================================================================================================================\r\n/** 3d Bezier curve class.\r\n * * Use BezierCurve3dH if the curve has weights.\r\n * * The control points (xyz) are managed as the _packedData buffer in the _polygon member of BezierCurveBase.\r\n * @public\r\n */\r\nexport class BezierCurve3d extends BezierCurveBase {\r\n  /** test if `other` is also a BezierCurve3d. */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BezierCurve3d; }\r\n  /** apply the transform to the control points. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    const data = this._workData0;\r\n    for (let i = 0; i < this._polygon.order; i++) {\r\n      this._polygon.getPolygonPoint(i, data);\r\n      transform.multiplyXYZToFloat64Array(data[0], data[1], data[2], data);\r\n      this._polygon.setPolygonPoint(i, data);\r\n    }\r\n    return true;\r\n  }\r\n  private _workRay0: Ray3d;\r\n  private _workRay1: Ray3d;\r\n  /** Return a specific pole as a full `[x,y,z] Point3d` */\r\n  public getPolePoint3d(i: number, result?: Point3d): Point3d | undefined {\r\n    const data = this._polygon.getPolygonPoint(i, this._workData0);\r\n    if (data)\r\n      return Point3d.create(data[0], data[1], data[2], result);\r\n    return undefined;\r\n  }\r\n  /** Return a specific pole as a full `[w*x,w*y,w*z, w] Point4d` */\r\n  public getPolePoint4d(i: number, result?: Point4d): Point4d | undefined {\r\n    const data = this._polygon.getPolygonPoint(i, this._workData0);\r\n    if (data)\r\n      return Point4d.create(data[0], data[1], data[2], 1.0, result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Capture a polygon as the data for a new `BezierCurve3d`\r\n   * @param polygon complete packed data and order.\r\n   */\r\n  private constructor(polygon: Float64Array) {\r\n    super(3, polygon);\r\n    this._workRay0 = Ray3d.createXAxis();\r\n    this._workRay1 = Ray3d.createXAxis();\r\n  }\r\n  /** Return poles as a linestring */\r\n  public copyPointsAsLineString(): LineString3d {\r\n    const result = LineString3d.create();\r\n    for (let i = 0; i < this._polygon.order; i++)\r\n      result.addPoint(this.getPolePoint3d(i)!);\r\n    return result;\r\n  }\r\n  /** Create a curve with given points.\r\n   * * If input is `Point2d[]`, the points are promoted with `z=0` and `w=1`\r\n   * * If input is `Point3d[]`, the points are promoted with w=1`\r\n   *\r\n   */\r\n  public static create(data: Point3d[] | Point2d[]): BezierCurve3d | undefined {\r\n    if (data.length < 1)\r\n      return undefined;\r\n    const polygon = new Float64Array(data.length * 3);\r\n    if (data[0] instanceof Point3d) {\r\n      let i = 0;\r\n      for (const p of (data as Point3d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = p.z;\r\n      }\r\n      return new BezierCurve3d(polygon);\r\n    } else if (data[0] instanceof Point2d) {\r\n      let i = 0;\r\n      for (const p of (data as Point2d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = 0.0;\r\n      }\r\n      return new BezierCurve3d(polygon);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** create a bezier curve of specified order, filled with zeros */\r\n  public static createOrder(order: number): BezierCurve3d {\r\n    const polygonArray = new Float64Array(order * 3); // This is initialized to zeros!!\r\n    return new BezierCurve3d(polygonArray);\r\n  }\r\n  /** Load order * 3 doubles from data[3 * spanIndex] as poles */\r\n  public loadSpanPoles(data: Float64Array, spanIndex: number) {\r\n    this._polygon.loadSpanPoles(data, spanIndex);\r\n  }\r\n  /** Clone as a bezier 3d. */\r\n  public clone(): BezierCurve3d {\r\n    return new BezierCurve3d(this._polygon.clonePolygon());\r\n  }\r\n  /** Clone the interval from f0 to f1. */\r\n  public clonePartialCurve(f0: number, f1: number): BezierCurve3d | undefined {\r\n    const partialCurve = new BezierCurve3d(this._polygon.clonePolygon());\r\n    partialCurve._polygon.subdivideToIntervalInPlace(f0, f1);\r\n    return partialCurve;\r\n  }\r\n\r\n  /**\r\n   * Return a curve after transform.\r\n   */\r\n  public cloneTransformed(transform: Transform): BezierCurve3d {\r\n    const curve1 = this.clone();\r\n    curve1.tryTransformInPlace(transform);\r\n    return curve1;\r\n  }\r\n  /** Return a (de-weighted) point on the curve. If de-weight fails, returns 000 */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    this._polygon.evaluate(fraction, this._workData0);\r\n    return Point3d.create(this._workData0[0], this._workData0[1], this._workData0[2], result);\r\n  }\r\n  /** Return the cartesian point and derivative vector. */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    this._polygon.evaluate(fraction, this._workData0);\r\n    this._polygon.evaluateDerivative(fraction, this._workData1);\r\n    return Ray3d.createXYZUVW(this._workData0[0], this._workData0[1], this._workData0[2], this._workData1[0], this._workData1[1], this._workData1[2], result);\r\n  }\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the arc\r\n   * * x axis is the first derivative, i.e. tangent along the arc\r\n   * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\r\n   * If the arc is circular, the second derivative is directly towards the center\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const epsilon = 1.0e-8;\r\n    const a = 1.0 / (2.0 * epsilon);\r\n    if (!result)\r\n      result = Plane3dByOriginAndVectors.createXYPlane();\r\n    const ray = this.fractionToPointAndDerivative(fraction, this._workRay0);\r\n    result.origin.setFrom(ray.origin);\r\n    result.vectorU.setFrom(ray.direction);\r\n    const ray0 = this.fractionToPointAndDerivative(fraction - epsilon, this._workRay0);\r\n    const ray1 = this.fractionToPointAndDerivative(fraction + epsilon, this._workRay1);\r\n    Vector3d.createAdd2Scaled(ray0.direction, -a, ray1.direction, a, result.vectorV);\r\n    return result;\r\n  }\r\n  /** Near-equality test on poles. */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BezierCurve3d) {\r\n      return this._polygon.isAlmostEqual(other._polygon);\r\n    }\r\n    return false;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBezierCurve3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBezierCurve3d(this);\r\n  }\r\n  /** Extend `rangeToExtend`, using candidate extrema at\r\n   * * both end points\r\n   * * any internal extrema in x,y,z\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform) {\r\n    const order = this.order;\r\n    if (!transform) {\r\n      this.allocateAndZeroBezierWorkData(order - 1, 0, 0);\r\n      const bezier = this._workBezier!;\r\n      this.getPolePoint3d(0, this._workPoint0);\r\n      rangeToExtend.extend(this._workPoint0);\r\n      this.getPolePoint3d(order - 1, this._workPoint0);\r\n      rangeToExtend.extend(this._workPoint0);\r\n      for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\r\n        BezierPolynomialAlgebra.componentDifference(bezier.coffs, this._polygon.packedData, 3, order, axisIndex);\r\n        const roots = bezier.roots(0.0, true);\r\n        if (roots) {\r\n          for (const r of roots) {\r\n            this.fractionToPoint(r, this._workPoint0);\r\n            rangeToExtend.extend(this._workPoint0);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      this.allocateAndZeroBezierWorkData(order - 1, order, 0);\r\n      const bezier = this._workBezier!;\r\n      const componentCoffs = this._workCoffsA!;   // to hold transformed copy of x,y,z in turn.\r\n\r\n      this.getPolePoint3d(0, this._workPoint0);\r\n      rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n      this.getPolePoint3d(order - 1, this._workPoint0);\r\n      rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n      const data = this._polygon.packedData;\r\n      for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\r\n        // apply one row of the transform to get the transformed coff by itself\r\n        for (let i = 0, k = 0; i < order; i++ , k += 3)\r\n          componentCoffs[i] = transform.multiplyComponentXYZ(axisIndex, data[k], data[k + 1], data[k + 2]);\r\n        BezierPolynomialAlgebra.univariateDifference(componentCoffs, bezier.coffs);\r\n        const roots = bezier.roots(0.0, true);\r\n        if (roots && roots.length > 0) {\r\n          for (const r of roots) {\r\n            this.fractionToPoint(r, this._workPoint0);\r\n            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n          }\r\n        }\r\n      }\r\n\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { CurveLocationDetail } from \"../curve/CurveLocationDetail\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { BezierPolynomialAlgebra } from \"../numerics/BezierPolynomials\";\r\nimport { BezierCurveBase } from \"./BezierCurveBase\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\n/** @module Bspline */\r\n\r\n/** 3d curve with homogeneous weights.\r\n * * A control point with weight w and cartesian (projected) coordinates x,y,z has the weight multiplied into the coordinates,\r\n *    hence the control point as stored is (xw, yw, zw, w).\r\n * @public\r\n */\r\nexport class BezierCurve3dH extends BezierCurveBase {\r\n  /** test if `other` is also a BezierCurve3dH. */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BezierCurve3dH; }\r\n  /**\r\n   * Apply (multiply by) an affine transform\r\n   * @param transform\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    const data = this._workData0;\r\n    for (let i = 0; i < this._polygon.order; i++) {\r\n      this._polygon.getPolygonPoint(i, data);\r\n      transform.multiplyXYZWToFloat64Array(data[0], data[1], data[2], data[3], data);\r\n      this._polygon.setPolygonPoint(i, data);\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Apply (multiply by) a perspective transform\r\n   * @param matrix\r\n   */\r\n  public tryMultiplyMatrix4dInPlace(matrix: Matrix4d) {\r\n    matrix.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData);\r\n  }\r\n  private _workRay0: Ray3d;\r\n  private _workRay1: Ray3d;\r\n  /** Return a specific pole as a full `[x,y,z,x] Point4d` */\r\n  public getPolePoint4d(i: number, result?: Point4d): Point4d | undefined {\r\n    const data = this._polygon.getPolygonPoint(i, this._workData0);\r\n    if (data)\r\n      return Point4d.create(data[0], data[1], data[2], data[3], result);\r\n    return undefined;\r\n  }\r\n  /** Return a specific pole normalized to weight 1\r\n   */\r\n  public getPolePoint3d(i: number, result?: Point3d): Point3d | undefined {\r\n    const data = this._polygon.getPolygonPoint(i, this._workData0);\r\n    if (data)\r\n      return Point3d.createFromPackedXYZW(data, 0, result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Returns true if all weights are within tolerance of 1.0\r\n   */\r\n  public isUnitWeight(tolerance?: number): boolean {\r\n    if (tolerance === undefined)\r\n      tolerance = Geometry.smallAngleRadians;\r\n    const aLow = 1.0 - tolerance;\r\n    const aHigh = 1.0 + tolerance;\r\n    const data = this._polygon.packedData;\r\n    const n = data.length;\r\n    let a;\r\n    for (let i = 3; i < n; i += 4) {\r\n      a = data[i];\r\n      if (a < aLow || a > aHigh)\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Capture a polygon as the data for a new `BezierCurve3dH`\r\n   * @param polygon complete packed data and order.\r\n   */\r\n  private constructor(polygon: Float64Array) {\r\n    super(4, polygon);\r\n    this._workRay0 = Ray3d.createXAxis();\r\n    this._workRay1 = Ray3d.createXAxis();\r\n  }\r\n  /** Create a curve with given points.\r\n   * * If input is `Point2d[]`, the points are promoted with `z=0` and `w=1`\r\n   * * If input is `Point3d[]`, the points are promoted with w=1`\r\n   *\r\n   */\r\n  public static create(data: Point3d[] | Point4d[] | Point2d[]): BezierCurve3dH | undefined {\r\n    if (data.length < 1)\r\n      return undefined;\r\n    const polygon = new Float64Array(data.length * 4);\r\n    if (data[0] instanceof Point3d) {\r\n      let i = 0;\r\n      for (const p of (data as Point3d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = p.z;\r\n        polygon[i++] = 1.0;\r\n      }\r\n      return new BezierCurve3dH(polygon);\r\n    } else if (data[0] instanceof Point4d) {\r\n      let i = 0;\r\n      for (const p of (data as Point4d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = p.z;\r\n        polygon[i++] = p.w;\r\n      }\r\n      return new BezierCurve3dH(polygon);\r\n    } else if (data[0] instanceof Point2d) {\r\n      let i = 0;\r\n      for (const p of (data as Point2d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = 0.0;\r\n        polygon[i++] = 1.0;\r\n      }\r\n      return new BezierCurve3dH(polygon);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** create a bezier curve of specified order, filled with zeros */\r\n  public static createOrder(order: number): BezierCurve3dH {\r\n    const polygonArray = new Float64Array(order * 4); // and we trust that this is all zeros !!!\r\n    return new BezierCurve3dH(polygonArray);\r\n  }\r\n  /** Load order * 4 doubles from data[3 * spanIndex] as poles (with added weight) */\r\n  public loadSpan3dPolesWithWeight(data: Float64Array, spanIndex: number, weight: number) {\r\n    this._polygon.loadSpanPolesWithWeight(data, 3, spanIndex, weight);\r\n  }\r\n  /** Load order * 4 doubles from data[3 * spanIndex] as poles (with added weight) */\r\n  public loadSpan4dPoles(data: Float64Array, spanIndex: number) {\r\n    this._polygon.loadSpanPoles(data, spanIndex);\r\n  }\r\n  /** Clone the entire curve. */\r\n  public clone(): BezierCurve3dH {\r\n    return new BezierCurve3dH(this._polygon.clonePolygon());\r\n  }\r\n  /**\r\n   * Return a curve after transform.\r\n   */\r\n  public cloneTransformed(transform: Transform): BezierCurve3dH {\r\n    const curve1 = this.clone();\r\n    curve1.tryTransformInPlace(transform);\r\n    return curve1;\r\n  }\r\n  /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    this._polygon.evaluate(fraction, this._workData0);\r\n    result = Point3d.createFromPackedXYZW(this._workData0, 0, result);\r\n    return result ? result : Point3d.createZero();\r\n  }\r\n  /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */\r\n  public fractionToPoint4d(fraction: number, result?: Point4d): Point4d {\r\n    this._polygon.evaluate(fraction, this._workData0);\r\n    return Point4d.createFromPackedXYZW(this._workData0, 0, result);\r\n  }\r\n  /** Return the cartesian point and derivative vector. */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    this._polygon.evaluate(fraction, this._workData0);\r\n    this._polygon.evaluateDerivative(fraction, this._workData1);\r\n    result = Ray3d.createWeightedDerivative(this._workData0, this._workData1, result);\r\n    if (result)\r\n      return result;\r\n    // Bad. Very Bad.  Return origin and x axis.   Should be undefined, but usual cartesian types do not allow that\r\n    return Ray3d.createXAxis();\r\n  }\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the arc\r\n   * * x axis is the first derivative, i.e. tangent along the arc\r\n   * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\r\n   * If the arc is circular, the second derivative is directly towards the center\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const epsilon = 1.0e-8;\r\n    const a = 1.0 / (2.0 * epsilon);\r\n    if (!result)\r\n      result = Plane3dByOriginAndVectors.createXYPlane();\r\n    const ray = this.fractionToPointAndDerivative(fraction, this._workRay0);\r\n    result.origin.setFrom(ray.origin);\r\n    result.vectorU.setFrom(ray.direction);\r\n    const ray0 = this.fractionToPointAndDerivative(fraction - epsilon, this._workRay0);\r\n    const ray1 = this.fractionToPointAndDerivative(fraction + epsilon, this._workRay1);\r\n    Vector3d.createAdd2Scaled(ray0.direction, -a, ray1.direction, a, result.vectorV);\r\n    return result;\r\n  }\r\n  /** test for nearly equal control points */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BezierCurve3dH) {\r\n      return this._polygon.isAlmostEqual(other._polygon);\r\n    }\r\n    return false;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBezierCurve3dH(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBezierCurve3dH(this);\r\n  }\r\n  /**\r\n   * Form dot products of each pole with given coefficients. Return as entries in products array.\r\n   * @param products array of (scalar) dot products\r\n   * @param ax x coefficient\r\n   * @param ay y coefficient\r\n   * @param az z coefficient\r\n   * @param aw w coefficient\r\n   */\r\n  public poleProductsXYZW(products: Float64Array, ax: number, ay: number, az: number, aw: number) {\r\n    const n = this.numPoles;\r\n    const data = this._polygon.packedData;\r\n    for (let i = 0, k = 0; i < n; i++ , k += 4)\r\n      products[i] = ax * data[k] + ay * data[k + 1] + az * data[k + 2] + aw * data[k + 3];\r\n  }\r\n  /** Find the closest point within the bezier span, using true perpendicular test (but no endpoint test)\r\n   * * If closer than previously recorded, update the CurveLocationDetail\r\n   * * This assumes this bezier is saturated.\r\n   * @param spacePoint point being projected\r\n   * @param detail pre-allocated detail to record (evolving) closest point.\r\n   * @returns true if an updated occurred, false if either (a) no perpendicular projections or (b) perpendiculars were not closer.\r\n   */\r\n  public updateClosestPointByTruePerpendicular(spacePoint: Point3d, detail: CurveLocationDetail): boolean {\r\n    let numUpdates = 0;\r\n    let roots: number[] | undefined;\r\n    if (this.isUnitWeight()) {\r\n      // unweighted !!!\r\n      const productOrder = 2 * this.order - 2;\r\n      this.allocateAndZeroBezierWorkData(productOrder, 0, 0);\r\n      const bezier = this._workBezier!;\r\n      // closestPoint condition is:\r\n      //   (spacePoint - curvePoint) DOT curveTangent = 0;\r\n      // Each product (x,y,z) of the DOT is the product of two bezier polynomials\r\n      BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 0, -spacePoint.x, 0);\r\n      BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 1, -spacePoint.y, 1);\r\n      BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 2, -spacePoint.z, 2);\r\n      roots = bezier.roots(0.0, true);\r\n    } else {\r\n      // This bezier has weights.\r\n      // The pure cartesian closest point condition is\r\n      //   (spacePoint - X/w) DOT (X' w - w' X)/ w^2 = 0\r\n      // ignoring denominator and using bezier coefficient differences for the derivative, making the numerator 0 is\r\n      //   (w * spacePoint - X) DOT ( DELTA X * w - DELTA w * X) = 0\r\n      const orderA = this.order;\r\n      const orderB = 2 * this.order - 2; // products of component and component difference.\r\n      const productOrder = orderA + orderB - 1;\r\n      this.allocateAndZeroBezierWorkData(productOrder, orderA, orderB);\r\n      const bezier = this._workBezier!;\r\n      const workA = this._workCoffsA!;\r\n      const workB = this._workCoffsB!;\r\n      const packedData = this._polygon.packedData;\r\n      for (let i = 0; i < 3; i++) {\r\n        // x representing loop pass:   (w * spacePoint.x - curve.x(s), 1.0) * (curveDelta.x(s) * curve.w(s) - curve.x(s) * curveDelta.w(s))\r\n        // (and p.w is always 1)\r\n        BezierPolynomialAlgebra.scaledComponentSum(workA, packedData, 4, orderA, 3, spacePoint.at(i), // w * spacePoint.x\r\n          i, -1.0); // curve.x(s) * 1.0\r\n        BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(workB, packedData, 4, orderA, 1.0, 3, 1.0, i);\r\n        BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(workB, packedData, 4, orderA, -1.0, i, 1.0, 3);\r\n        BezierPolynomialAlgebra.accumulateProduct(bezier.coffs, workA, workB);\r\n      }\r\n      roots = bezier.roots(0.0, true);\r\n    }\r\n    if (roots) {\r\n      for (const fraction of roots) {\r\n        const xyz = this.fractionToPoint(fraction);\r\n        const a = xyz.distance(spacePoint);\r\n        numUpdates += detail.updateIfCloserCurveFractionPointDistance(this, fraction, xyz, a) ? 1 : 0;\r\n      }\r\n    }\r\n    return numUpdates > 0;\r\n  }\r\n  /** Extend `rangeToExtend`, using candidate extrema at\r\n   * * both end points\r\n   * * any internal extrema in x,y,z\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform) {\r\n    const order = this.order;\r\n    if (!transform) {\r\n      this.allocateAndZeroBezierWorkData(order * 2 - 2, 0, 0);\r\n      const bezier = this._workBezier!;\r\n      const data = this._polygon.packedData;\r\n      this.getPolePoint3d(0, this._workPoint0);\r\n      rangeToExtend.extend(this._workPoint0);\r\n      this.getPolePoint3d(order - 1, this._workPoint0);\r\n      rangeToExtend.extend(this._workPoint0);\r\n      // Example:\r\n      // For x component ...\r\n      //     coefficients of (weighted x) are at axisIndex=0\r\n      //     deweighted polynomial is (x(s)/w(s))\r\n      //    its derivative (to be zeroed) is\r\n      //              (x'(s)*w(s) -x(s) * w'(s)) / w^2(s)\r\n      // The coefficients of the derivatives are (degree times) differences of successive coffs.\r\n      // Make the numerator zero to get extrema\r\n      for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\r\n        bezier.zero();\r\n        BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(\r\n          bezier.coffs,\r\n          data, 4, order,\r\n          1.0,\r\n          axisIndex, 0.0,\r\n          3);\r\n        BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(\r\n          bezier.coffs,\r\n          data, 4, order,\r\n          -1.0,\r\n          3, 0.0,\r\n          axisIndex);\r\n        const roots = bezier.roots(0.0, true);\r\n        if (roots) {\r\n          for (const r of roots) {\r\n            this.fractionToPoint(r, this._workPoint0);\r\n            rangeToExtend.extend(this._workPoint0);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      this.allocateAndZeroBezierWorkData(order * 2 - 2, order, order);\r\n      const componentCoffs = this._workCoffsA!;   // to hold transformed copy of x,y,z in turn.\r\n      const weightCoffs = this._workCoffsB!;    // to hold weights\r\n      const bezier = this._workBezier!;\r\n\r\n      this.getPolePoint3d(0, this._workPoint0);\r\n      rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n      this.getPolePoint3d(order - 1, this._workPoint0);\r\n      rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n\r\n      const data = this._polygon.packedData;      // Example:\r\n      // For x component ...\r\n      //     coefficients of (weighted x) are at axisIndex=0\r\n      //     deweighted polynomial is (x(s)/w(s))\r\n      //    its derivative (to be zeroed) is\r\n      //              (x'(s)*w(s) -x(s) * w'(s)) / w^2(s)\r\n      // The coefficients of the derivatives are (degree times) differences of successive coffs.\r\n      // Make the numerator zero to get extrema\r\n      // apply one row of the transform to get the transformed coff by itself\r\n      let weight;\r\n      for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\r\n        bezier.zero();\r\n        for (let i = 0, k = 0; i < order; i++ , k += 4) {\r\n          weight = data[k + 3];\r\n          componentCoffs[i] = transform.multiplyComponentXYZW(axisIndex, data[k], data[k + 1], data[k + 2], weight);\r\n          weightCoffs[i] = weight;\r\n        }\r\n        BezierPolynomialAlgebra.accumulateProductWithDifferences(bezier.coffs, componentCoffs, weightCoffs, 1.0);\r\n        BezierPolynomialAlgebra.accumulateProductWithDifferences(bezier.coffs, weightCoffs, componentCoffs, -1.0);\r\n        const roots = bezier.roots(0.0, true);\r\n        if (roots && roots.length > 0) {\r\n          for (const r of roots) {\r\n            this.fractionToPoint(r, this._workPoint0);\r\n            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"../Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\n\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { KnotVector } from \"./KnotVector\";\r\nimport { Bezier1dNd } from \"./Bezier1dNd\";\r\nimport { UnivariateBezier } from \"../numerics/BezierPolynomials\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\n/**\r\n * Base class for CurvePrimitive (necessarily 3D) with _polygon.\r\n * * This has a Bezier1dNd polygon as a member, and implements dimension-independent methods\r\n * * This exists to support\r\n *    * BezierCurve3d -- 3 coordinates x,y,z per block in the Bezier1dNd poles\r\n *    * BezierCurve3dH -- 4 coordinates x,y,z,w per block in the Bezier1dNd poles\r\n * * The implementations of \"pure 3d\" queries is based on calling `getPolePoint3d`.\r\n * * This has the subtle failure difference that `getPolePoint3d` call with a valid index on on a 3d curve always succeeds, but on 3dH curve fails when weight is zero.\r\n * @public\r\n */\r\nexport abstract class BezierCurveBase extends CurvePrimitive {\r\n  /** String name for schema properties */\r\n  public readonly curvePrimitiveType = \"bezierCurve\";\r\n\r\n  /** Control points */\r\n  protected _polygon: Bezier1dNd;\r\n  /** scratch data blocks accessible by concrete class.   Initialized to correct blockSize in constructor. */\r\n  protected _workData0: Float64Array;\r\n  /** scratch data blocks accessible by concrete class.   Initialized to correct blockSize in constructor. */\r\n  protected _workData1: Float64Array;\r\n  /** Scratch xyz point accessible by derived classes. */\r\n  protected _workPoint0: Point3d;\r\n  /** Scratch xyz point accessible by derived classes. */\r\n  protected _workPoint1: Point3d;\r\n\r\n  protected constructor(blockSize: number, data: Float64Array) {\r\n    super();\r\n    this._polygon = new Bezier1dNd(blockSize, data);\r\n    this._workPoint0 = Point3d.create();\r\n    this._workPoint1 = Point3d.create();\r\n    this._workData0 = new Float64Array(blockSize);\r\n    this._workData1 = new Float64Array(blockSize);\r\n\r\n  }\r\n  /** reverse the poles in place */\r\n  public reverseInPlace(): void { this._polygon.reverseInPlace(); }\r\n  /** saturate the pole in place, using knot intervals from `spanIndex` of the `knotVector` */\r\n  public saturateInPlace(knotVector: KnotVector, spanIndex: number): boolean {\r\n    const boolStat = this._polygon.saturateInPlace(knotVector, spanIndex);\r\n    if (boolStat) {\r\n      this.setInterval(\r\n        knotVector.spanFractionToFraction(spanIndex, 0.0),\r\n        knotVector.spanFractionToFraction(spanIndex, 1.0));\r\n    }\r\n    return boolStat;\r\n  }\r\n  /** (property accessor) Return the polynomial degree (one less than order) */\r\n  public get degree(): number {\r\n    return this._polygon.order - 1;\r\n  }\r\n  /** (property accessor) Return the polynomial order */\r\n  public get order(): number { return this._polygon.order; }\r\n  /** (property accessor) Return the number of poles (aka control points) */\r\n  public get numPoles(): number { return this._polygon.order; }\r\n  /** Get pole `i` as a Point3d.\r\n   * * For 3d curve, this is simple a pole access, and only fails (return `undefined`) for invalid index\r\n   * * For 4d curve, this deweights the homogeneous pole and can fail due to 0 weight.\r\n   */\r\n  public abstract getPolePoint3d(i: number, point?: Point3d): Point3d | undefined;\r\n\r\n  /** Get pole `i` as a Point4d.\r\n   * * For 3d curve, this accesses the simple pole and returns with weight 1.\r\n   * * For 4d curve, this accesses the (weighted) pole.\r\n   */\r\n  public abstract getPolePoint4d(i: number, point?: Point4d): Point4d | undefined;\r\n  /** Set mapping to parent curve (e.g. if this bezier is a span extracted from a bspline, this is the knot interval of the span) */\r\n  public setInterval(a: number, b: number) { this._polygon.setInterval(a, b); }\r\n  /** map `fraction` from this Bezier curves inherent 0..1 range to the (a,b) range of parent\r\n   * * ( The parent range should have been previously defined with `setInterval`)\r\n   */\r\n  public fractionToParentFraction(fraction: number): number { return this._polygon.fractionToParentFraction(fraction); }\r\n\r\n  /** append stroke points to a linestring, based on `strokeCount` and `fractionToPoint` from derived class*/\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const numPerSpan = this.computeStrokeCountForOptions(options);\r\n    const fractionStep = 1.0 / numPerSpan;\r\n    for (let i = 0; i <= numPerSpan; i++) {\r\n      const fraction = i * fractionStep;\r\n      this.fractionToPoint(fraction, this._workPoint0);\r\n      dest.appendStrokePoint(this._workPoint0);\r\n    }\r\n  }\r\n  /** announce intervals with stroke counts */\r\n  public emitStrokableParts(handler: IStrokeHandler, _options?: StrokeOptions): void {\r\n    const numPerSpan = this.computeStrokeCountForOptions(_options);\r\n    handler.announceIntervalForUniformStepStrokes(this, numPerSpan, 0.0, 1.0);\r\n  }\r\n  /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */\r\n  public copyPolesAsJsonArray(): any[] { return this._polygon.unpackToJsonArrays(); }\r\n\r\n  /** return true if all poles are on a plane. */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    let point: Point3d | undefined = this._workPoint0;\r\n    for (let i = 0; ; i++) {\r\n      point = this.getPolePoint3d(i, point);\r\n      if (!point)\r\n        return true;\r\n      if (!plane.isPointInPlane(point))\r\n        break;    // which gets to return false, which is otherwise unreachable . . .\r\n    }\r\n    return false;\r\n  }\r\n  /** Return the length of the control polygon. */\r\n  public polygonLength(): number {\r\n    if (!this.getPolePoint3d(0, this._workPoint0))\r\n      return 0.0;\r\n    let i = 0;\r\n    let sum = 0.0;\r\n    while (this.getPolePoint3d(++i, this._workPoint1)) {\r\n      sum += this._workPoint0.distance(this._workPoint1);\r\n      this._workPoint0.setFrom(this._workPoint1);\r\n    }\r\n    return sum;\r\n  }\r\n  /** Return the start point.  (first control point) */\r\n  public startPoint(): Point3d {\r\n    const result = this.getPolePoint3d(0)!;   // ASSUME non-trivial pole set -- if null comes back, it bubbles out\r\n    return result;\r\n  }\r\n  /** Return the end point.  (last control point) */\r\n  public endPoint(): Point3d {\r\n    const result = this.getPolePoint3d(this.order - 1)!;    // ASSUME non-trivial pole set\r\n    return result;\r\n  }\r\n  /** Return the control polygon length as a quick length estimate. */\r\n  public quickLength(): number { return this.polygonLength(); }\r\n  /** Concrete classes must implement extendRange . . .  */\r\n  public abstract extendRange(rangeToExtend: Range3d, transform?: Transform): void;\r\n  /**\r\n   * 1D bezier coefficients for use in range computations.\r\n   * @internal\r\n   */\r\n  protected _workBezier?: UnivariateBezier; // available for bezier logic within a method\r\n  /** scratch array for use by derived classes, using allocateAndZeroBezierWorkData for sizing. */\r\n  protected _workCoffsA?: Float64Array;\r\n  /** scratch array for use by derived classes, using allocateAndZeroBezierWorkData for sizing. */\r\n  protected _workCoffsB?: Float64Array;\r\n\r\n  /**\r\n   * set up the _workBezier members with specific order.\r\n   * * Try to reuse existing members if their sizes match.\r\n   * * Ignore members corresponding to args that are 0 or negative.\r\n   * @param primaryBezierOrder order of expected bezier\r\n   * @param orderA length of _workCoffsA (simple array)\r\n   * @param orderB length of _workCoffsB (simple array)\r\n   */\r\n  protected allocateAndZeroBezierWorkData(primaryBezierOrder: number, orderA: number, orderB: number) {\r\n    if (primaryBezierOrder > 0) {\r\n      if (this._workBezier !== undefined && this._workBezier.order === primaryBezierOrder) {\r\n        this._workBezier.zero();\r\n      } else\r\n        this._workBezier = new UnivariateBezier(primaryBezierOrder);\r\n    }\r\n    if (orderA > 0) {\r\n      if (this._workCoffsA !== undefined && this._workCoffsA.length === orderA)\r\n        this._workCoffsA.fill(0);\r\n      else\r\n        this._workCoffsA = new Float64Array(orderA);\r\n    }\r\n    if (orderB > 0) {\r\n      if (this._workCoffsB !== undefined && this._workCoffsB.length === orderB)\r\n        this._workCoffsB.fill(0);\r\n      else\r\n        this._workCoffsB = new Float64Array(orderB);\r\n    }\r\n  }\r\n  /**\r\n   * Assess length and turn to determine a stroke count.\r\n   * * this method is used by both BSplineCurve3d and BSplineCurve3dH.\r\n   * * points are accessed via getPolePoint3d.\r\n   *   * Hence a zero-weight pole will be a problem\r\n   * @param options stroke options structure.\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n\r\n    this.getPolePoint3d(0, this._workPoint0);\r\n    this.getPolePoint3d(1, this._workPoint1);\r\n    let numStrokes = 1;\r\n    if (this._workPoint0 && this._workPoint1) {\r\n      let dx0 = this._workPoint1.x - this._workPoint0.x;\r\n      let dy0 = this._workPoint1.y - this._workPoint0.y;\r\n      let dz0 = this._workPoint1.z - this._workPoint0.z;\r\n      let dx1, dy1, dz1; // first differences of leading edge\r\n      let sumRadians = 0.0;\r\n      let thisLength = Geometry.hypotenuseXYZ(dx0, dy0, dz0);\r\n      this._workPoint1.setFromPoint3d(this._workPoint0);\r\n      let sumLength = thisLength;\r\n      let maxLength = thisLength;\r\n      let maxRadians = 0.0;\r\n      let thisRadians;\r\n      for (let i = 2; this.getPolePoint3d(i, this._workPoint1); i++) {\r\n        dx1 = this._workPoint1.x - this._workPoint0.x;\r\n        dy1 = this._workPoint1.y - this._workPoint0.y;\r\n        dz1 = this._workPoint1.z - this._workPoint0.z;\r\n        thisRadians = Angle.radiansBetweenVectorsXYZ(dx0, dy0, dz0, dx1, dy1, dz1);\r\n        sumRadians += thisRadians;\r\n        maxRadians = Geometry.maxAbsXY(thisRadians, maxRadians);\r\n        thisLength = Geometry.hypotenuseXYZ(dx1, dy1, dz1);\r\n        sumLength += thisLength;\r\n        maxLength = Geometry.maxXY(maxLength, thisLength);\r\n        dx0 = dx1;\r\n        dy0 = dy1;\r\n        dz0 = dz1;\r\n        this._workPoint0.setFrom(this._workPoint1);\r\n      }\r\n      const length1 = maxLength * this.degree;    // This may be larger than sumLength\r\n      const length2 = Math.sqrt(length1 * sumLength);  // This is in between\r\n      let radians1 = maxRadians * (this.degree - 1);  // As if worst case keeps happening.\r\n      if (this.degree < 3)\r\n        radians1 *= 3;  // so quadratics aren't under-stroked\r\n      const radians2 = Math.sqrt(radians1 * sumRadians);\r\n      numStrokes = StrokeOptions.applyAngleTol(options,\r\n        StrokeOptions.applyMaxEdgeLength(options, this.degree, length2), radians2, 0.1);\r\n      if (options) {\r\n        numStrokes = options.applyChordTolToLengthAndRadians(numStrokes, sumLength, radians1);\r\n      }\r\n    }\r\n    return numStrokes;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"../Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\nimport { Geometry } from \"../Geometry\";\r\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\r\n/**\r\n * Enumeration of the possible ways of converting a \"periodic\" knot vector to an open knot vector.\r\n * None (0) ==> no wrap possible\r\n * OpenByAddintControlPoints (1)  ==> wrapped by adding poles\r\n * OpenByRemovingKnots (2)  ==> wrapped by deleting extreme knots.\r\n * @public\r\n */\r\nexport enum BSplineWrapMode {\r\n  /** No conversion to periodic */\r\n  None = 0,\r\n  /** Convert to periodic by removing control points.  This is typical for closed bcurve constructed by control points with maximum continuity.\r\n   * * Knots stay the same in open and periodic form.\r\n   * * Periodic form omits {degree} control points.\r\n   */\r\n  OpenByAddingControlPoints = 1,\r\n  /** Convert to periodic by adding special knots.  This is typical of closed bcurve constructed as exact circular or elliptic arc\r\n   * * 2 knots on each end are omitted in open form\r\n   * * poles stay the same.\r\n   */\r\n  OpenByRemovingKnots = 2,\r\n}\r\n/**\r\n * Array of non-decreasing numbers acting as a knot array for bsplines.\r\n *\r\n * * Essential identity: numKnots = numPoles + order = numPoles + degree - 1\r\n * * Various bspline libraries have confusion over how many \"end knots\" are needed. \"Many\" libraries (including MicroStation)\r\n *     incorrectly demand \"order\" knots at each end for clamping.   But only \"order - 1\" are really needed.\r\n * * This class uses the \"order-1\" convention.\r\n * * This class provides queries to convert among spanIndex and knotIndex\r\n * * A span is a single interval of the knots.\r\n * * The left knot of span {k} is knot {k+degree-1}\r\n * * This class provides queries to convert among spanFraction, fraction of knot range, and knot\r\n * * core computations (evaluateBasisFunctions) have leftKnotIndex and global knot value as inputs.  Caller's need to\r\n * know their primary values (global knot, spanFraction).\r\n * @public\r\n */\r\nexport class KnotVector {\r\n  /** The simple array of knot values. */\r\n  public knots: Float64Array;\r\n  /** Return the degree of basis functions defined in these knots. */\r\n  public degree: number;\r\n  private _knot0: number;\r\n  private _knot1: number;\r\n\r\n  private _wrapMode?: BSplineWrapMode;\r\n  /** tolerance for considering two knots to be the same. */\r\n  public static readonly knotTolerance = 1.0e-9;\r\n  /** Return the leftmost knot value (of the active interval, ignoring unclamped leading knots)*/\r\n  public get leftKnot() { return this._knot0; }\r\n  /** Return the rightmost knot value (of the active interval, ignoring unclamped leading knots)*/\r\n  public get rightKnot() { return this._knot1; }\r\n  /** Return the index of the leftmost knot of the active interval */\r\n  public get leftKnotIndex() { return this.degree - 1; }\r\n  /** Return the index of the rightmost knot of the active interval */\r\n  public get rightKnotIndex() { return this.knots.length - this.degree; }\r\n  /**\r\n   * Return true if the bspline was created by adding poles in to \"closed\" structure\r\n   */\r\n  public get wrappable() { return this._wrapMode === undefined ? BSplineWrapMode.None : this._wrapMode; }\r\n  /** Set the wrappable flag.  This is used by serialize/deserialize to mark knotVector's that were converted from periodic style. */\r\n  public set wrappable(value: BSplineWrapMode) { this._wrapMode = value; }\r\n  /** Return the number of bezier spans.  Not that this includes zero-length spans if there are repeated knots. */\r\n  public get numSpans() { return this.rightKnotIndex - this.leftKnotIndex; }\r\n  /**\r\n   *\r\n   * * If knots is a number array or Float64Array, the those values become the local knot array.\r\n   * * If knots is a simple number, the local knot array is allocated to that size but left as zeros.\r\n   * @param knots\r\n   * @param degree\r\n   */\r\n  private constructor(knots: number[] | Float64Array | number, degree: number) {\r\n    this.degree = degree;\r\n    // default values to satisfy compiler -- real values hapn setupFixedValues or final else defers to user\r\n    this._knot0 = 0.0;\r\n    this._knot1 = 1.0;\r\n    // satisfy the initialize checker ..\r\n    if (Array.isArray(knots)) { // remark:  This ctor is private.  The callers (as of April 2019) do not use this path.\r\n      this.knots = new Float64Array(knots.length);\r\n      this.setKnots(knots);\r\n      this.setupFixedValues();\r\n    } else if (knots instanceof Float64Array) {\r\n      this.knots = knots.slice();\r\n      this.setupFixedValues();\r\n    } else { // caller is responsible for filling array separately ...\r\n      this.knots = new Float64Array(knots);\r\n    }\r\n  }\r\n  /** copy degree and knots to a new KnotVector. */\r\n  public clone(): KnotVector { return new KnotVector(this.knots, this.degree); }\r\n  private setupFixedValues() {\r\n    // These should be read-only . ..\r\n    this._knot0 = this.knots[this.degree - 1];\r\n    this._knot1 = this.knots[this.knots.length - this.degree];\r\n  }\r\n  /** Return the total knot distance from beginning to end. */\r\n  public get knotLength01(): number { return this._knot1 - this._knot0; }\r\n  /**\r\n   * Returns true if all numeric values have wraparound conditions for \"closed\" knotVector with specified wrap mode\r\n   * @param mode optional test mode.  If undefined, use the this.wrappable.\r\n   */\r\n  public testClosable(mode?: BSplineWrapMode): boolean {\r\n    if (mode === undefined)\r\n      mode = this.wrappable;\r\n    const leftKnotIndex = this.leftKnotIndex;\r\n    const rightKnotIndex = this.rightKnotIndex;\r\n    const period = this.rightKnot - this.leftKnot;\r\n    const degree = this.degree;\r\n    const indexDelta = rightKnotIndex - leftKnotIndex;\r\n    // maximum continuity mode .  . .\r\n    if (mode === BSplineWrapMode.OpenByAddingControlPoints) {\r\n      for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {\r\n        const k1 = k0 + indexDelta;\r\n        if (!Geometry.isSameCoordinate(this.knots[k0] + period, this.knots[k1]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    // arc mode ...\r\n    if (mode === BSplineWrapMode.OpenByRemovingKnots) {\r\n      // we expect {degree} replicated knots at each end . . .\r\n      const numRepeated = degree - 1;\r\n      const leftKnot = this.knots[leftKnotIndex];\r\n      const rightKnot = this.knots[rightKnotIndex];\r\n      for (let i = 0; i < numRepeated; i++) {\r\n        if (!Geometry.isSameCoordinate(leftKnot, this.knots[leftKnotIndex - i - 1]))\r\n          return false;\r\n        if (!Geometry.isSameCoordinate(rightKnot, this.knots[rightKnotIndex + i + 1]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /** Test matching degree and knot values */\r\n  public isAlmostEqual(other: KnotVector): boolean {\r\n    if (this.degree !== other.degree) return false;\r\n    return NumberArray.isAlmostEqual(this.knots, other.knots, KnotVector.knotTolerance);\r\n  }\r\n  /** install knot values from an array, optionally ignoring first and last.\r\n   */\r\n  public setKnots(knots: number[] | Float64Array, skipFirstAndLast?: boolean) {\r\n    const numAllocate = skipFirstAndLast ? knots.length - 2 : knots.length;\r\n    if (numAllocate !== this.knots.length)\r\n      this.knots = new Float64Array(numAllocate);\r\n    if (skipFirstAndLast) {\r\n      for (let i = 1; i + 1 < knots.length; i++)\r\n        this.knots[i - 1] = knots[i];\r\n\r\n    } else {\r\n      for (let i = 0; i < knots.length; i++)\r\n        this.knots[i] = knots[i];\r\n    }\r\n    this.setupFixedValues();\r\n  }\r\n  /**\r\n   * Create knot vector with {degree-1} replicated knots at start and end, and uniform knots between.\r\n   * @param numPoles Number of poles\r\n   * @param degree degree of polynomial\r\n   * @param a0 left knot value for active interval\r\n   * @param a1 right knot value for active interval\r\n   */\r\n  public static createUniformClamped(numPoles: number, degree: number, a0: number, a1: number): KnotVector {\r\n    const knots = new KnotVector(numPoles + degree - 1, degree);\r\n    let k = 0;\r\n    for (let m = 0; m < degree; m++)knots.knots[k++] = a0;\r\n    const du = 1.0 / (numPoles - degree);\r\n    for (let i = 1; i + degree < numPoles; i++)\r\n      knots.knots[k++] = a0 + i * du * (a1 - a0);\r\n    for (let m = 0; m < degree; m++)knots.knots[k++] = a1;\r\n    knots.setupFixedValues();\r\n    return knots;\r\n  }\r\n  /**\r\n   * Create knot vector with {degree-1} replicated knots at start and end, and uniform knots between.\r\n   * @param  numInterval number of intervals in knot space.  (NOT POLE COUNT)\r\n   * @param degree degree of polynomial\r\n   * @param a0 left knot value for active interval\r\n   * @param a1 right knot value for active interval\r\n   */\r\n  public static createUniformWrapped(numInterval: number, degree: number, a0: number, a1: number): KnotVector {\r\n    const knots = new KnotVector(numInterval + 2 * degree - 1, degree);\r\n    const du = 1.0 / numInterval;\r\n    for (let i = 1 - degree, k = 0; i < numInterval + degree; i++ , k++) {\r\n      knots.knots[k] = Geometry.interpolate(a0, i * du, a1);\r\n    }\r\n    knots.setupFixedValues();\r\n    return knots;\r\n  }\r\n\r\n  /**\r\n   * Create knot vector with given knot values and degree.\r\n   * @param knotArray knot values\r\n   * @param degree degree of polynomial\r\n   * @param skipFirstAndLast true to skip class overclamped end knots.\r\n   */\r\n  public static create(knotArray: number[] | Float64Array, degree: number, skipFirstAndLast?: boolean): KnotVector {\r\n    const numAllocate = skipFirstAndLast ? knotArray.length - 2 : knotArray.length;\r\n    const knots = new KnotVector(numAllocate, degree);\r\n    knots.setKnots(knotArray, skipFirstAndLast);\r\n    return knots;\r\n  }\r\n\r\n  /**\r\n   * Return the average of degree consecutive knots beginning at spanIndex.\r\n   */\r\n  public grevilleKnot(spanIndex: number): number {\r\n    if (spanIndex < 0) return this.leftKnot;\r\n    if (spanIndex > this.rightKnotIndex) return this.rightKnot;\r\n    let sum = 0.0;\r\n    for (let i = spanIndex; i < spanIndex + this.degree; i++)\r\n      sum += this.knots[i];\r\n    return sum / this.degree;\r\n  }\r\n  /** Return an array sized for a set of the basis function values. */\r\n  public createBasisArray(): Float64Array { return new Float64Array(this.degree + 1); }\r\n  /** Convert localFraction within the interval following an indexed knot to a knot value. */\r\n  public baseKnotFractionToKnot(knotIndex0: number, localFraction: number): number {\r\n    const knot0 = this.knots[knotIndex0];\r\n    return knot0 + localFraction * (this.knots[knotIndex0 + 1] - knot0);\r\n  }\r\n  /** Convert localFraction within an indexed bezier span to a knot value. */\r\n  public spanFractionToKnot(spanIndex: number, localFraction: number): number {\r\n    const k = this.spanIndexToLeftKnotIndex(spanIndex);\r\n    return this.knots[k] + localFraction * (this.knots[k + 1] - this.knots[k]);\r\n  }\r\n  /** Convert localFraction within an indexed bezier span to fraction of active knot range. */\r\n  public spanFractionToFraction(spanIndex: number, localFraction: number): number {\r\n    const knot = this.spanFractionToKnot(spanIndex, localFraction);\r\n    return (knot - this.leftKnot) / (this.rightKnot - this.leftKnot);\r\n  }\r\n  /** Return fraction of active knot range to knot value. */\r\n  public fractionToKnot(fraction: number): number {\r\n    return Geometry.interpolate(this.knots[this.degree - 1], fraction, this.knots[this.knots.length - this.degree]);\r\n  }\r\n  /**\r\n   * Evaluate basis functions f[] at knot value u.\r\n   *\r\n   * @param u knot value for evaluation\r\n   * @param f array of basis values.  ASSUMED PROPER LENGTH\r\n   */\r\n  public evaluateBasisFunctions(knotIndex0: number, u: number, f: Float64Array) {\r\n    f[0] = 1.0;\r\n    if (this.degree < 1) return;\r\n    // direct compute for linear part ...\r\n    const u0 = this.knots[knotIndex0];\r\n    const u1 = this.knots[knotIndex0 + 1];\r\n    f[1] = (u - u0) / (u1 - u0);\r\n    f[0] = 1.0 - f[1];\r\n    if (this.degree < 2) return;\r\n\r\n    for (let depth = 1; depth < this.degree; depth++) {\r\n      let kLeft = knotIndex0 - depth;\r\n      let kRight = kLeft + depth + 1;\r\n      let gCarry = 0.0;\r\n      for (let step = 0; step <= depth; step++) {\r\n        const tLeft = this.knots[kLeft++];\r\n        const tRight = this.knots[kRight++];\r\n        const fraction = (u - tLeft) / (tRight - tLeft);\r\n        const g1 = f[step] * fraction;\r\n        const g0 = f[step] * (1.0 - fraction);\r\n        f[step] = gCarry + g0;\r\n        gCarry = g1;\r\n      }\r\n      f[depth + 1] = gCarry;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluate basis fucntions f[] at knot value u.\r\n   *\r\n   * @param u knot value for evaluation\r\n   * @param f array of basis values.  ASSUMED PROPER LENGTH\r\n   */\r\n  public evaluateBasisFunctions1(knotIndex0: number, u: number, f: Float64Array, df: Float64Array, ddf?: Float64Array) {\r\n    f[0] = 1.0; df[0] = 0.0;\r\n    if (this.degree < 1) return;\r\n    // direct compute for linear part ...\r\n    const u0 = this.knots[knotIndex0];\r\n    const u1 = this.knots[knotIndex0 + 1];\r\n    // ah = 1/(u1-u0)      is the derivative of fraction0\r\n    // (-ah) is the derivative of fraction1.\r\n    let ah = 1.0 / (u1 - u0);\r\n    f[1] = (u - u0) * ah;\r\n    f[0] = 1.0 - f[1];\r\n    df[0] = -ah; df[1] = ah;\r\n    if (ddf) {  // first derivative started constant, second derivative started zero.\r\n      ddf[0] = 0.0; ddf[1] = 0.0;\r\n    }\r\n    if (this.degree < 2) return;\r\n    for (let depth = 1; depth < this.degree; depth++) {\r\n      let kLeft = knotIndex0 - depth;\r\n      let kRight = kLeft + depth + 1;\r\n      let gCarry = 0.0;\r\n      let dgCarry = 0.0;\r\n      let ddgCarry = 0.0;\r\n      // f, df, ddf, are each row vectors with product of `step` linear terms.\r\n      // f is multiplied on the right by matrix V.  Each row has 2 nonzero entries (which sum to 1)  (0,0,1-fraction, fraction,0,0,0)\r\n      //    Each row of the derivative dV is two entries (0,0, -1/h, 1/h,0,0,0)\r\n      // Hence fnew = f * V\r\n      //      dfnew = df * V + f * dV\r\n      //      ddfnew = ddf * V + df*dV + df * dV + f * ddV\r\n      // but ddV is zero so\r\n      //      ddfnew = ddf * V + 2 * df * dV\r\n      for (let step = 0; step <= depth; step++) {\r\n        const tLeft = this.knots[kLeft++];\r\n        const tRight = this.knots[kRight++];\r\n        ah = 1.0 / (tRight - tLeft);\r\n        const fraction = (u - tLeft) * ah;\r\n        const fraction1 = 1.0 - fraction;\r\n        const g1 = f[step] * fraction;\r\n        const g0 = f[step] * fraction1;\r\n        const dg1 = df[step] * fraction + f[step] * ah;\r\n        const dg0 = df[step] * fraction1 - f[step] * ah;\r\n        const dfSave = 2.0 * df[step] * ah;\r\n        f[step] = gCarry + g0;\r\n        df[step] = dgCarry + dg0;\r\n        gCarry = g1;\r\n        dgCarry = dg1;\r\n        if (ddf) {  // do the backward reference to df before rewriting df !!!\r\n          const ddg1 = ddf[step] * fraction + dfSave;\r\n          const ddg0 = ddf[step] * fraction1 - dfSave;\r\n          ddf[step] = ddgCarry + ddg0;\r\n          ddgCarry = ddg1;\r\n        }\r\n      }\r\n      f[depth + 1] = gCarry;\r\n      df[depth + 1] = dgCarry;\r\n      if (ddf)\r\n        ddf[depth + 1] = ddgCarry;\r\n    }\r\n  }\r\n  /** Return the (highest) index of the knot less than or equal to u */\r\n  public knotToLeftKnotIndex(u: number): number {\r\n    // Anything to left is in the first span . .\r\n    const firstLeftKnot = this.degree - 1;\r\n    if (u < this.knots[firstLeftKnot + 1]) return firstLeftKnot;\r\n    // Anything to right is in the last span ...\r\n    const lastLeftKnot = this.knots.length - this.degree - 1;\r\n    if (u >= this.knots.length - this.degree) return this.knots[lastLeftKnot];\r\n    // ugh ... linear search ...\r\n    for (let i = firstLeftKnot + 1; i < lastLeftKnot; i++)\r\n      if (u < this.knots[i + 1]) return i;  // testing against right side skips over multiple knot cases???\r\n    return lastLeftKnot;\r\n  }\r\n  /**\r\n   * Given a span index, return the index of the knot at its left.\r\n   * @param spanIndex index of span\r\n   */\r\n  public spanIndexToLeftKnotIndex(spanIndex: number): number {\r\n    const d = this.degree;\r\n    if (spanIndex <= 0.0) return d - 1;\r\n    return Math.min(spanIndex + d - 1, this.knots.length - d);\r\n  }\r\n  /** Return the knot interval length of indexed bezier span. */\r\n  public spanIndexToSpanLength(spanIndex: number): number {\r\n    const k = this.spanIndexToLeftKnotIndex(spanIndex);\r\n    return this.knots[k + 1] - this.knots[k];\r\n  }\r\n  /**\r\n   * Given a span index, test if it is within range and has nonzero length.\r\n   * * note that a false return does not imply there are no more spans.  This may be a double knot (zero length span) followed by more real spans\r\n   * @param spanIndex index of span to test.\r\n   */\r\n  public isIndexOfRealSpan(spanIndex: number): boolean {\r\n    if (spanIndex >= 0 && spanIndex < this.knots.length - this.degree)\r\n      return !Geometry.isSmallMetricDistance(this.spanIndexToSpanLength(spanIndex));\r\n    return false;\r\n  }\r\n  /** Reflect all knots so `leftKnot` and `rightKnot` are maintained but interval lengths reverse. */\r\n  public reflectKnots() {\r\n    const a = this.leftKnot;\r\n    const b = this.rightKnot;\r\n    const numKnots = this.knots.length;\r\n    for (let i = 0; i < numKnots; i++)\r\n      this.knots[i] = a + (b - this.knots[i]);\r\n    this.knots.reverse();\r\n  }\r\n  /**\r\n   * return a simple array form of the knots.  optionally replicate the first and last\r\n   * in classic over-clamped manner\r\n   */\r\n  public copyKnots(includeExtraEndKnot: boolean): number[] {\r\n    const wrap = this.wrappable === BSplineWrapMode.OpenByAddingControlPoints && this.testClosable();\r\n    const leftIndex = this.leftKnotIndex;\r\n    const rightIndex = this.rightKnotIndex;\r\n    const a0 = this.leftKnot;\r\n    const a1 = this.rightKnot;\r\n    const delta = a1 - a0;\r\n    const degree = this.degree;\r\n    const values: number[] = [];\r\n    if (includeExtraEndKnot) {\r\n      if (wrap) {\r\n        values.push(this.knots[rightIndex - degree] - delta);\r\n      } else {\r\n        values.push(this.knots[0]);\r\n      }\r\n    }\r\n    for (const u of this.knots) values.push(u);\r\n    if (includeExtraEndKnot) {\r\n      if (wrap) {\r\n        values.push(this.knots[leftIndex + degree] + delta);\r\n      } else\r\n        values.push(values[values.length - 1]);\r\n    }\r\n    return values;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { UVSurface } from \"../geometry3d/GeometryHandler\";\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { CurveLocationDetail } from \"../curve/CurveLocationDetail\";\r\n/**\r\n * CurveLocationDetail carries point and paramter data about a point evaluated on a curve.\r\n * * These are returned by a variety of queries.\r\n * * Particular contents can vary among the queries.\r\n * @public\r\n */\r\nexport class UVSurfaceLocationDetail {\r\n  /** The surface being evaluated */\r\n  public surface?: UVSurface;\r\n  /** uv coordinates in the surface */\r\n  public uv: Point2d;\r\n  /** The point on the surface */\r\n  public point: Point3d;\r\n  /** A context-specific numeric value.  (E.g. a distance) */\r\n  public a: number;\r\n  /** Construct with empty data. */\r\n  public constructor(surface?: UVSurface, uv?: Point2d, point?: Point3d) {\r\n    this.surface = surface;\r\n    this.point = point ? point : Point3d.createZero();\r\n    this.uv = uv ? uv : Point2d.createZero();\r\n    this.a = 0.0;\r\n  }\r\n  /**\r\n   * Create a new detail structure.\r\n   * @param surface\r\n   * @param uv coordinates to copy (not capture) into the `detail.uv`\r\n   * @param point coordinates to copy (not capture) into the `detail.point`\r\n   */\r\n  public static createSurfaceUVPoint(surface: UVSurface | undefined, uv: Point2d, point: Point3d): UVSurfaceLocationDetail {\r\n    const detail = new UVSurfaceLocationDetail(surface);\r\n    if (uv)\r\n      detail.uv.setFrom(uv);\r\n    detail.point.setFromPoint3d(point);\r\n    return detail;\r\n  }\r\n}\r\n/**\r\n * Carrier for both curve and surface data, e.g. from intersection calculations.\r\n * @public\r\n */\r\nexport class CurveAndSurfaceLocationDetail {\r\n  /** detailed location on the curve */\r\n  public curveDetail: CurveLocationDetail;\r\n  /** detailed location on the surface */\r\n  public surfaceDetail: UVSurfaceLocationDetail;\r\n  /** CAPTURE both details . . */\r\n  public constructor(curveDetail: CurveLocationDetail, surfaceDetail: UVSurfaceLocationDetail) {\r\n    this.curveDetail = curveDetail;\r\n    this.surfaceDetail = surfaceDetail;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Geometry, AxisOrder, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { AnalyticRoots } from \"../numerics/Polynomials\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { Clipper, ClipUtilities } from \"./ClipUtils\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { AnnounceNumberNumberCurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { Point3dArrayPolygonOps, IndexedXYZCollectionPolygonOps } from \"../geometry3d/PolygonOps\";\r\n\r\n/** A ClipPlane is a single plane represented as\r\n * * An inward unit normal (u,v,w)\r\n * * A signedDistance\r\n *\r\n * Hence\r\n * * The halfspace function evaluation for \"point\" [x,y,z,] is: ([x,y,z] DOT (u,v,w)l - signedDistance)\r\n * * POSITIVE values of the halfspace function are \"inside\"\r\n * * ZERO value of the halfspace function is \"on\"\r\n * * NEGATIVE value of the halfspace function is \"outside\"\r\n * * A representative point on the plane is (signedDistance*u, signedDistance * v, signedDistance *w)\r\n * * Given a point and inward normal, the signedDistance is (point DOT normal)\r\n * @public\r\n */\r\nexport class ClipPlane implements Clipper, PlaneAltitudeEvaluator {\r\n  private _inwardNormal: Vector3d;\r\n  /** Construct a parallel plane through the origin.\r\n   * * Move it to the actual position.\r\n   * * _distanceFromOrigin is the distance it moved, with the (inward) normal direction as positive\r\n   */\r\n  private _distanceFromOrigin: number;\r\n  private _invisible: boolean;\r\n  private _interior: boolean;\r\n\r\n  private constructor(normal: Vector3d, distance: number, invisible: boolean, interior: boolean) {\r\n    this._invisible = invisible;\r\n    this._interior = interior;\r\n    this._inwardNormal = normal;\r\n    this._distanceFromOrigin = distance;\r\n  }\r\n  private safeSetXYZDistance(nx: number, ny: number, nz: number, d: number) {\r\n    this._inwardNormal.set(nx, ny, nz);\r\n    this._distanceFromOrigin = d;\r\n  }\r\n  /**\r\n   * Return true if all members are almostEqual to corresponding members of other.\r\n   * @param other clip plane to compare\r\n   */\r\n  public isAlmostEqual(other: ClipPlane): boolean {\r\n    return Geometry.isSameCoordinate(this._distanceFromOrigin, other._distanceFromOrigin)\r\n      && this._inwardNormal.isAlmostEqual(other._inwardNormal)\r\n      && this._interior === other._interior\r\n      && this._invisible === other._invisible;\r\n  }\r\n  /** return a cloned plane */\r\n  public clone(): ClipPlane {\r\n    const result = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);\r\n    return result;\r\n  }\r\n  /** return Return a cloned plane with coordinate data negated. */\r\n  public cloneNegated(): ClipPlane {\r\n    const plane = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);\r\n    plane.negateInPlace();\r\n    return plane;\r\n  }\r\n  /** Create a ClipPlane from Plane3dByOriginAndUnitNormal. */\r\n  public static createPlane(plane: Plane3dByOriginAndUnitNormal, invisible: boolean = false, interior: boolean = false, result?: ClipPlane): ClipPlane {\r\n    const distance = plane.getNormalRef().dotProduct(plane.getOriginRef());\r\n    if (result) {\r\n      result._invisible = invisible;\r\n      result._interior = interior;\r\n      result._inwardNormal = plane.getNormalRef().clone();\r\n      result._distanceFromOrigin = distance;\r\n      return result;\r\n    }\r\n    return new ClipPlane(plane.getNormalRef().clone(), distance, invisible, interior);\r\n  }\r\n  /**\r\n   * * Create a ClipPlane with direct normal and signedDistance.\r\n   * * The vector is normalized for storage.\r\n   */\r\n  public static createNormalAndDistance(normal: Vector3d, distance: number, invisible: boolean = false, interior: boolean = false, result?: ClipPlane): ClipPlane | undefined {\r\n    const normalized = normal.normalize();\r\n    if (normalized) {\r\n      if (result) {\r\n        result._invisible = invisible;\r\n        result._interior = interior;\r\n        result._inwardNormal = normalized;\r\n        result._distanceFromOrigin = distance;\r\n      }\r\n      return new ClipPlane(normalized, distance, invisible, interior);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Create a ClipPlane\r\n   * * \"normal\" is the inward normal of the plane. (It is internally normalized)\r\n   * * \"point\" is any point of the plane.\r\n   * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as a vector from the origin.)\r\n   */\r\n  public static createNormalAndPoint(normal: Vector3d, point: Point3d, invisible: boolean = false, interior: boolean = false, result?: ClipPlane): ClipPlane | undefined {\r\n    const normalized = normal.normalize();\r\n    if (normalized) {\r\n      const distance = normalized.dotProduct(point);\r\n      if (result) {\r\n        result._invisible = invisible;\r\n        result._interior = interior;\r\n        result._inwardNormal = normalized;\r\n        result._distanceFromOrigin = distance;\r\n      }\r\n      return new ClipPlane(normalized, distance, invisible, interior);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Create a ClipPlane\r\n   * * \"normal\" (normalX, normalY, nz) is the inward normal of the plane.\r\n   * * The given (normalX,normalY,normalZ)\r\n   * * \"point\" is any point of the plane.\r\n   * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as a vector from the origin.)\r\n   */\r\n  public static createNormalAndPointXYZXYZ(normalX: number, normalY: number, normalZ: number,\r\n    originX: number, originY: number, originZ: number,\r\n    invisible: boolean = false, interior: boolean = false, result?: ClipPlane): ClipPlane | undefined {\r\n    const q = Geometry.hypotenuseXYZ(normalX, normalY, normalZ);\r\n    const r = Geometry.conditionalDivideFraction(1, q);\r\n    if (r !== undefined) {\r\n      if (result) {\r\n        result._inwardNormal.set(normalX * r, normalY * r, normalZ * r);\r\n        result._distanceFromOrigin = result._inwardNormal.dotProductXYZ(originX, originY, originZ);\r\n        result._invisible = invisible;\r\n        result._interior = interior;\r\n        return result;\r\n      }\r\n      const normal = Vector3d.create(normalX * r, normalY * r, normalZ * r);\r\n      return new ClipPlane(normal, normal.dotProductXYZ(originX, originY, originZ), invisible, interior);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * return a json object of the form\r\n   * `{\"normal\":[u,v,w],\"dist\":signedDistanceValue,\"interior\":true,\"invisible\":true}`\r\n   */\r\n  public toJSON(): any {\r\n    const val: any = {};\r\n    val.normal = this.inwardNormalRef.toJSON();\r\n    val.dist = this.distance;\r\n    if (this.interior)\r\n      val.interior = true;\r\n    if (this.invisible)\r\n      val.invisible = true;\r\n    return val;\r\n  }\r\n  /** parse json object to ClipPlane instance */\r\n  public static fromJSON(json: any, result?: ClipPlane): ClipPlane | undefined {\r\n    if (json && json.normal && Number.isFinite(json.dist)) {\r\n      return ClipPlane.createNormalAndDistance(Vector3d.fromJSON(json.normal), json.dist, !!json.invisible, !!json.interior);\r\n    }\r\n    return ClipPlane.createNormalAndDistance(Vector3d.unitZ(), 0, false, false, result);\r\n  }\r\n  /** Set both the invisible and interior flags. */\r\n  public setFlags(invisible: boolean, interior: boolean) {\r\n    this._invisible = invisible;\r\n    this._interior = interior;\r\n  }\r\n\r\n  /**\r\n   * Return the stored distanceFromOrigin property.\r\n   */\r\n  public get distance() { return this._distanceFromOrigin; }\r\n  /**\r\n   * Return the stored inward normal property.\r\n   */\r\n  public get inwardNormalRef(): Vector3d { return this._inwardNormal; }\r\n  /**\r\n   * Return the \"interior\" property bit\r\n   */\r\n  public get interior() { return this._interior; }\r\n  /**\r\n   * Return the \"invisible\" property bit.\r\n   */\r\n  public get invisible() { return this._invisible; }\r\n\r\n  /**\r\n   * Create a plane defined by two points, an up vector, and a tilt angle relative to the up vector.\r\n   * @param point0 start point of the edge\r\n   * @param point1 end point of the edge\r\n   * @param upVector vector perpendicular to the plane\r\n   * @param tiltAngle angle to tilt the plane around the edge in the direction of the up vector.\r\n   * @param result optional preallocated plane\r\n   */\r\n  public static createEdgeAndUpVector(point0: Point3d, point1: Point3d, upVector: Vector3d, tiltAngle: Angle, result?: ClipPlane): ClipPlane | undefined {\r\n    const edgeVector = Vector3d.createFrom(point1.minus(point0));\r\n    let normal = (upVector.crossProduct(edgeVector)).normalize();\r\n\r\n    if (normal) {\r\n      if (!tiltAngle.isAlmostZero) {\r\n        const tiltNormal = Vector3d.createRotateVectorAroundVector(normal, edgeVector, tiltAngle);\r\n        if (tiltNormal) {\r\n          normal = tiltNormal.clone();\r\n        }\r\n      }\r\n      normal.negate(normal);\r\n      return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Create a plane perpendicular to the edge between the xy parts of point0 and point1\r\n   */\r\n  public static createEdgeXY(point0: Point3d, point1: Point3d, result?: ClipPlane): ClipPlane | undefined {\r\n    const normal = Vector3d.create(point0.y - point1.y, point1.x - point0.x);\r\n    if (normal.normalizeInPlace())\r\n      return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return the Plane3d form of the plane.\r\n   * * The plane origin is the point `distance * inwardNormal`\r\n   * * The plane normal is the inward normal of the ClipPlane.\r\n   */\r\n  public getPlane3d(): Plane3dByOriginAndUnitNormal {\r\n    const d = this._distanceFromOrigin;\r\n    // Normal should be normalized, will not return undefined\r\n    return Plane3dByOriginAndUnitNormal.create(Point3d.create(this._inwardNormal.x * d, this._inwardNormal.y * d, this._inwardNormal.z * d), this._inwardNormal)!;\r\n  }\r\n\r\n  /**\r\n   * Return the Point4d d form of the plane.\r\n   * * The homogeneous xyz are the inward normal xyz.\r\n   * * The homogeneous weight is the negated ClipPlane distance.\r\n   */\r\n  public getPlane4d(): Point4d {\r\n    return Point4d.create(this._inwardNormal.x, this._inwardNormal.y, this._inwardNormal.z, - this._distanceFromOrigin);\r\n  }\r\n  /**\r\n   * Set the plane from DPoint4d style plane.\r\n   * * The saved plane has its direction normalized.\r\n   * * This preserves the plane itself as a zero set but make plane evaluations act as true distances (even if the plane coefficients are scaled otherwise)\r\n   * @param plane\r\n   */\r\n  public setPlane4d(plane: Point4d) {\r\n    const a = Math.sqrt(plane.x * plane.x + plane.y * plane.y + plane.z * plane.z);\r\n    const r = a === 0.0 ? 1.0 : 1.0 / a;\r\n    this._inwardNormal.x = r * plane.x;\r\n    this._inwardNormal.y = r * plane.y;\r\n    this._inwardNormal.z = r * plane.z;\r\n    this._distanceFromOrigin = -r * plane.w;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the distance from the plane to a point in space, i.e. (dot product with inward normal) minus distance\r\n   * @param point space point to test\r\n   * @deprecated Instead of `clipPlane.evaluatePoint(spacePoint)` use `clipPlane.altitude(spacePoint)` (for compatibility with interface `PlaneAltitudeEvaluator`)\r\n   */\r\n  public evaluatePoint(point: Point3d): number {\r\n    return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z - this._distanceFromOrigin;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the altitude in weighted space, i.e. (dot product with inward normal) minus distance, with point.w scale applied to distance)\r\n   * @param point space point to test\r\n   */\r\n  public weightedAltitude(point: Point4d): number {\r\n    return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z - point.w * this._distanceFromOrigin;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the distance from the plane to a point in space, i.e. (dot product with inward normal) minus distance\r\n   * @param point space point to test\r\n   */\r\n  public altitude(point: Point3d): number {\r\n    return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z - this._distanceFromOrigin;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the distance from the plane to a point in space with point given as x,y,z, i.e. (dot product with inward normal) minus distance\r\n   * @param point space point to test\r\n   */\r\n  public altitudeXYZ(x: number, y: number, z: number): number {\r\n    return x * this._inwardNormal.x + y * this._inwardNormal.y + z * this._inwardNormal.z - this._distanceFromOrigin;\r\n  }\r\n  /** Return the dot product of the plane normal with the vector (NOT using the plane's distanceFromOrigin).\r\n   * @deprecated Instead of `clipPlane.dotProduct (vector)` use `clipPlane.velocity(vector)` for compatibility with interface `PlaneAltitudeEvaluator`\r\n   */\r\n  public dotProductVector(vector: Vector3d): number {\r\n    return vector.x * this._inwardNormal.x + vector.y * this._inwardNormal.y + vector.z * this._inwardNormal.z;\r\n  }\r\n  /** Return the dot product of the plane normal with the vector (NOT using the plane's distanceFromOrigin).\r\n   */\r\n  public velocity(vector: Vector3d): number {\r\n    return vector.x * this._inwardNormal.x + vector.y * this._inwardNormal.y + vector.z * this._inwardNormal.z;\r\n  }\r\n\r\n  /** Return the dot product of the plane normal with the x,yz, vector components (NOT using the plane's distanceFromOrigin).\r\n   */\r\n  public velocityXYZ(x: number, y: number, z: number): number {\r\n    return x * this._inwardNormal.x + y * this._inwardNormal.y + z * this._inwardNormal.z;\r\n  }\r\n\r\n  /** Return the dot product of the plane normal with the point (treating the point xyz as a vector, and NOT using the plane's distanceFromOrigin).\r\n   */\r\n  public dotProductPlaneNormalPoint(point: Point3d): number {\r\n    return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z;\r\n  }\r\n  /**\r\n   * Return true if spacePoint is inside or on the plane, with tolerance applied to \"on\".\r\n   * @param spacePoint point to test.\r\n   * @param tolerance tolerance for considering \"near plane\" to be \"on plane\"\r\n   */\r\n  public isPointOnOrInside(spacePoint: Point3d, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    let value = this.altitude(spacePoint);\r\n    if (tolerance) { value += tolerance; }\r\n    return value >= 0.0;\r\n  }\r\n\r\n  /**\r\n   * Return true if spacePoint is strictly inside the halfspace, with tolerance applied to \"on\".\r\n   * @param spacePoint point to test.\r\n   * @param tolerance tolerance for considering \"near plane\" to be \"on plane\"\r\n   */\r\n  public isPointInside(point: Point3d, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    let value = this.altitude(point);\r\n    if (tolerance) { value -= tolerance; }\r\n    return value > 0.0;\r\n  }\r\n\r\n  /**\r\n   * Return true if spacePoint is strictly on the plane, within tolerance\r\n   * @param spacePoint point to test.\r\n   * @param tolerance tolerance for considering \"near plane\" to be \"on plane\"\r\n   */\r\n  public isPointOn(point: Point3d, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    return Math.abs(this.altitude(point)) <= tolerance;\r\n  }\r\n  /**\r\n   * Compute intersections of an (UNBOUNDED) arc with the plane.  Append them (as radians) to a growing array.\r\n   * @param arc arc to test.  The angle limits of the arc are NOT considered.\r\n   * @param intersectionRadians array to receive results\r\n   */\r\n  public appendIntersectionRadians(arc: Arc3d, intersectionRadians: GrowableFloat64Array) {\r\n    const arcVectors = arc.toVectors();\r\n    const alpha = this.altitude(arc.center);\r\n    const beta = this.velocity(arcVectors.vector0);\r\n    const gamma = this.velocity(arcVectors.vector90);\r\n    AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, undefined, undefined, intersectionRadians);\r\n  }\r\n\r\n  private static _clipArcFractionArray = new GrowableFloat64Array();\r\n  /** Announce fractional intervals of arc clip.\r\n   * * Each call to `announce(fraction0, fraction1, arc)` announces one interval that is inside the clip plane.\r\n   */\r\n  public announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    const breaks = ClipPlane._clipArcFractionArray;\r\n    breaks.clear();\r\n    this.appendIntersectionRadians(arc, breaks);\r\n    arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);\r\n    return ClipUtilities.selectIntervals01(arc, breaks, this, announce);\r\n  }\r\n  /**\r\n   * * Compute intersection of (unbounded) segment with the plane.\r\n   * * If the ends are on the same side of the plane, return undefined.\r\n   * * If the intersection is an endpoint or interior to the segment return the fraction.\r\n   * * If both ends are on, return undefined.\r\n   */\r\n  public getBoundedSegmentSimpleIntersection(pointA: Point3d, pointB: Point3d): number | undefined {\r\n    const h0 = this.altitude(pointA);\r\n    const h1 = this.altitude(pointB);\r\n    if (h0 * h1 > 0.0)\r\n      return undefined;\r\n    if (h0 === 0.0 && h1 === 0.0) {\r\n      return undefined;\r\n    }\r\n    return - h0 / (h1 - h0);\r\n  }\r\n\r\n  /** Apply transform to the origin.  Apply inverse transpose of the matrix part to th normal vector. */\r\n  public transformInPlace(transform: Transform): boolean {\r\n    const plane: Plane3dByOriginAndUnitNormal = this.getPlane3d();\r\n    const matrix: Matrix3d = transform.matrix;\r\n    const newPoint = transform.multiplyPoint3d(plane.getOriginRef());\r\n    // Normal transforms as the inverse transpose of the matrix part\r\n    // BTW: If the matrix is orthogonal, this is a long way to multiply by the matrix part (mumble grumble)\r\n    const newNormal = matrix.multiplyInverseTranspose(plane.getNormalRef());\r\n    if (!newNormal)\r\n      return false;\r\n\r\n    plane.set(newPoint, newNormal);\r\n    const normalized = (plane.getNormalRef()).normalize();\r\n    if (!normalized)\r\n      return false;\r\n    this._inwardNormal = normalized;\r\n    this._distanceFromOrigin = this._inwardNormal.dotProduct(plane.getOriginRef());\r\n    return true;\r\n  }\r\n  /** Set the invisible flag.   Interpretation of this is up to the use code algorithms. */\r\n  public setInvisible(invisible: boolean) {\r\n    this._invisible = invisible;\r\n  }\r\n\r\n  /**  reverse the sign of all coefficients, so outside and inside reverse */\r\n  public negateInPlace() {\r\n    this._inwardNormal = this._inwardNormal.negate();\r\n    this._distanceFromOrigin = - this._distanceFromOrigin;\r\n  }\r\n  /**\r\n   * Move the plane INWARD by given distance\r\n   * @param offset distance of shift inwards\r\n   */\r\n  public offsetDistance(offset: number) {\r\n    this._distanceFromOrigin += offset;\r\n  }\r\n  /**\r\n   * Clip a polygon, returning the clip result in the same object.\r\n   * @param xyz input/output polygon\r\n   * @param work scratch object\r\n   * @param tolerance tolerance for on-plane decision.\r\n   * @deprecated Instead of `clipPlane.convexPolygonClipInPlace (xyz, work, tolerance)` use `PolygonOps.clipConvexPoint3dPolygonInPlace (clipPlane, xyz, work, tolerance)`\r\n   */\r\n  public convexPolygonClipInPlace(xyz: Point3d[], work: Point3d[], tolerance: number = Geometry.smallMetricDistance) {\r\n    return Point3dArrayPolygonOps.convexPolygonClipInPlace(this, xyz, work, tolerance);\r\n  }\r\n  /**\r\n   * Clip a polygon to the inside or outside of the plane.\r\n   * * Results with 2 or fewer points are ignored.\r\n   * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.\r\n   * @param xyz input points.\r\n   * @param work work buffer\r\n   * @param tolerance tolerance for \"on plane\" decision.\r\n   */\r\n  public clipConvexPolygonInPlace(xyz: GrowableXYZArray, work: GrowableXYZArray, inside: boolean = true, tolerance: number = Geometry.smallMetricDistance) {\r\n    return IndexedXYZCollectionPolygonOps.clipConvexPolygonInPlace(this, xyz, work, inside, tolerance);\r\n  }\r\n  /**\r\n   * Split a (convex) polygon into 2 parts.\r\n   * @param xyz original polygon\r\n   * @param xyzIn array to receive inside part\r\n   * @param xyzOut array to receive outside part\r\n   * @param altitudeRange min and max altitudes encountered.\r\n   * @deprecated instead of `plane.convexPolygonSplitInsideOutside (xyz, xyzIn, xyzOut, altitudeRange)` use `PolygonOops.splitConvexPolygonInsideOutsidePlane(this, xyz, xyzIn, xyzOut, altitudeRange)`\r\n   */\r\n  public convexPolygonSplitInsideOutside(xyz: Point3d[], xyzIn: Point3d[], xyzOut: Point3d[], altitudeRange: Range1d) {\r\n    Point3dArrayPolygonOps.convexPolygonSplitInsideOutsidePlane(this, xyz, xyzIn, xyzOut, altitudeRange);\r\n\r\n  }\r\n\r\n  /**\r\n   * Split a (convex) polygon into 2 parts.\r\n   * @param xyz original polygon\r\n   * @param xyzIn array to receive inside part\r\n   * @param xyzOut array to receive outside part\r\n   * @param altitudeRange min and max altitudes encountered.\r\n   * @deprecated instead of `plane.convexPolygonSplitInsideOutsideGrowableArrays (xyz, xyzIn, xyzOut, altitudeRange)` use `PolygonOops.splitConvexPoint3dArrayolygonInsideOutsidePlane(this, xyz, xyzIn, xyzOut, altitudeRange)`\r\n   */\r\n  public convexPolygonSplitInsideOutsideGrowableArrays(xyz: GrowableXYZArray, xyzIn: GrowableXYZArray, xyzOut: GrowableXYZArray, altitudeRange: Range1d) {\r\n    IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(this, xyz, xyzIn, xyzOut, altitudeRange);\r\n  }\r\n\r\n  /**\r\n   * Multiply the ClipPlane's DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   * @return false if unable to invert\r\n   */\r\n  public multiplyPlaneByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    const plane: Point4d = this.getPlane4d();\r\n    if (invert) {\r\n      const inverse = matrix.createInverse();\r\n      if (inverse)\r\n        return this.multiplyPlaneByMatrix4d(inverse, false, transpose);\r\n      return false;\r\n    }\r\n    if (transpose)\r\n      matrix.multiplyTransposePoint4d(plane, plane);\r\n    else\r\n      matrix.multiplyPoint4d(plane, plane);\r\n    this.setPlane4d(plane);\r\n    return true;\r\n  }\r\n  /** Return an array containing\r\n   * * All points that are exactly on the plane.\r\n   * * Crossing points between adjacent points that are (strictly) on opposite sides.\r\n   * @deprecated ClipPlane method `clipPlane.polygonCrossings(polygonPoints, crossings)` is deprecated.  Use Point3dArrayPolygonOps.polygonPlaneCrossings (clipPlane, polygonPoints, crossings)`\r\n   */\r\n  public polygonCrossings( xyz: Point3d[], crossings: Point3d[]) {\r\n    return Point3dArrayPolygonOps.polygonPlaneCrossings (this, xyz, crossings);\r\n  }\r\n\r\n  /** announce the interval (if any) where a line is within the clip plane half space. */\r\n  public announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: (fraction0: number, fraction1: number) => void): boolean {\r\n    if (f1 < f0)\r\n      return false;\r\n    const h0 = - this.altitude(pointA);\r\n    const h1 = - this.altitude(pointB);\r\n    const delta = h1 - h0;\r\n    const f = Geometry.conditionalDivideFraction(-h0, delta);\r\n    if (f === undefined) { // The segment is parallel to the plane.\r\n      if (h0 <= 0.0) { if (announce) announce(f0, f1); return true; }\r\n      return false;\r\n    }\r\n    if (delta > 0) { // segment aims OUT\r\n      if (f < f1) f1 = f;\r\n    } else {\r\n      // segment aims IN\r\n      if (f > f0)\r\n        f0 = f;\r\n    }\r\n    if (f1 < f0)\r\n      return false;\r\n    if (announce) announce(f0, f1);\r\n    return true;\r\n  }\r\n  /**\r\n   * Return a coordinate frame with\r\n   * * origin at closest point to global origin\r\n   * * z axis points in\r\n   * x and y are \"in plane\"\r\n   */\r\n  public getFrame(): Transform {\r\n    const d = this._distanceFromOrigin;\r\n    const origin = Point3d.create(this._inwardNormal.x * d, this._inwardNormal.y * d, this._inwardNormal.z * d);\r\n    const matrix = Matrix3d.createRigidHeadsUp(this._inwardNormal, AxisOrder.ZXY);\r\n    return Transform.createOriginAndMatrix(origin, matrix);\r\n  }\r\n  /**\r\n   * Return the intersection of the plane with a range cube.\r\n   * @param range\r\n   * @param xyzOut intersection polygon.  This is convex.\r\n   */\r\n  public intersectRange(range: Range3d, addClosurePoint: boolean = false): GrowableXYZArray | undefined {\r\n    if (range.isNull)\r\n      return undefined;\r\n    const corners = range.corners();\r\n    const frameOnPlane = this.getFrame();\r\n    frameOnPlane.multiplyInversePoint3dArrayInPlace(corners);\r\n    const localRange = Range3d.createArray(corners);\r\n    if (localRange.low.z * localRange.high.z > 0.0)\r\n      return undefined;\r\n    // oversized polygon on local z= 0\r\n    const xyzOut = new GrowableXYZArray();\r\n    xyzOut.pushXYZ(localRange.low.x, localRange.low.y, 0);\r\n    xyzOut.pushXYZ(localRange.high.x, localRange.low.y, 0);\r\n    xyzOut.pushXYZ(localRange.high.x, localRange.high.y, 0);\r\n    xyzOut.pushXYZ(localRange.low.x, localRange.high.y, 0);\r\n    xyzOut.multiplyTransformInPlace(frameOnPlane);\r\n    ClipPlane.intersectRangeConvexPolygonInPlace(range, xyzOut);\r\n    if (xyzOut.length === 0)\r\n      return undefined;\r\n    if (addClosurePoint)\r\n      xyzOut.pushWrap(1);\r\n    return xyzOut;\r\n  }\r\n  /**\r\n   * Return the intersection of the plane with a range cube.\r\n   * @param range\r\n   * @param xyzOut intersection polygon.  This is convex.\r\n   */\r\n  public static intersectRangeConvexPolygonInPlace(range: Range3d, xyz: GrowableXYZArray) {\r\n    if (range.isNull)\r\n      return undefined;\r\n    const work = new GrowableXYZArray();\r\n    // clip the polygon to each plane of the cubic ...\r\n    const clipper = ClipPlane.createNormalAndPointXYZXYZ(-1, 0, 0, range.high.x, range.high.y, range.high.z)!;\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n    clipper.safeSetXYZDistance(0, -1, 0, -range.high.y);\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n    clipper.safeSetXYZDistance(0, 0, -1, -range.high.z);\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n    clipper.safeSetXYZDistance(1, 0, 0, range.low.x);\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n    clipper.safeSetXYZDistance(0, 1, 0, range.low.y);\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n    clipper.safeSetXYZDistance(0, 0, 1, range.low.z);\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n\r\n    return xyz;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { ClipPlane } from \"./ClipPlane\";\r\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\r\nimport { ClipPlaneContainment } from \"./ClipUtils\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { UnionOfConvexClipPlaneSets } from \"./UnionOfConvexClipPlaneSets\";\r\nimport { Triangulator } from \"../topology/Triangulation\";\r\nimport { HalfEdgeGraph, HalfEdge, HalfEdgeMask } from \"../topology/Graph\";\r\n\r\n/**\r\n * Bit mask type for referencing subsets of 6 planes of range box.\r\n * @public\r\n */\r\nexport enum ClipMaskXYZRangePlanes {\r\n  /** no planes */\r\n  None = 0x00,\r\n  /** low x plane */\r\n  XLow = 0x01,\r\n  /** high x plane */\r\n  XHigh = 0x02,\r\n  /** low y plane */\r\n  YLow = 0x04,\r\n  /** high y plane */\r\n  YHigh = 0x08,\r\n  /** low z plane */\r\n  ZLow = 0x10,\r\n  /** high z plane */\r\n  ZHigh = 0x20,\r\n  /** all x and y planes, neither z plane */\r\n  XAndY = 0x0f,\r\n  /** all 6 planes */\r\n  All = 0x3f,\r\n}\r\n\r\n/**\r\n * * ClipPrimitive is a base class for clipping implementations that use\r\n *   * A ClipPlaneSet designated \"clipPlanes\"\r\n *   * an \"invisible\" flag\r\n * * When constructed directly, objects of type ClipPrimitive (directly, not through a derived class) will have just planes\r\n * * Derived classes (e.g. ClipShape) carry additional data of a swept shape.\r\n * * ClipPrimitive can be constructed with no planes.\r\n *     * Derived class is responsible for filling the plane sets.\r\n *     * At discretion of derived classes, plane construction can be done at construction time or \"on demand when\" queries call `ensurePlaneSets ()`\r\n * * ClipPrimitive can be constructed with planes (and no derived class).\r\n * @public\r\n */\r\nexport class ClipPrimitive {\r\n  /** The (union of) convex regions. */\r\n  protected _clipPlanes?: UnionOfConvexClipPlaneSets;\r\n  /** If true, pointInside inverts the sense of the pointInside for the _clipPlanes */\r\n  protected _invisible: boolean;\r\n  /** Get a reference to the `UnionOfConvexClipPlaneSets`.\r\n   *  * It triggers construction of the sets by `this.ensurePlaneSets()`.\r\n   *  * Derived class typically caches the set on the first such call.\r\n   */\r\n  public fetchClipPlanesRef(): UnionOfConvexClipPlaneSets | undefined { this.ensurePlaneSets(); return this._clipPlanes; }\r\n  /** Ask if this primitive is a hole. */\r\n  public get invisible(): boolean { return this._invisible; }\r\n\r\n  protected constructor(planeSet?: UnionOfConvexClipPlaneSets | undefined, isInvisible: boolean = false) {\r\n    this._clipPlanes = planeSet;\r\n    this._invisible = isInvisible;\r\n  }\r\n  /**\r\n   * Create a ClipPrimitive, capturing the supplied plane set as the clip planes.\r\n   * @param planes clipper\r\n   * @param isInvisible true to invert sense of the test\r\n   */\r\n  public static createCapture(planes: UnionOfConvexClipPlaneSets | ConvexClipPlaneSet | undefined, isInvisible: boolean = false): ClipPrimitive {\r\n    let planeData;\r\n    if (planes instanceof UnionOfConvexClipPlaneSets)\r\n      planeData = planes;\r\n    if (planes instanceof ConvexClipPlaneSet)\r\n      planeData = UnionOfConvexClipPlaneSets.createConvexSets([planes]);\r\n\r\n    return new ClipPrimitive(planeData, isInvisible);\r\n  }\r\n  /** Emit json form of the clip planes */\r\n  public toJSON(): any {\r\n    const data: any = {};\r\n    if (this._clipPlanes)\r\n      data.clips = this._clipPlanes.toJSON();\r\n    if (this._invisible)\r\n      data.invisible = true;\r\n    return { planes: data };\r\n  }\r\n\r\n  /**\r\n   * Returns true if the planes are present.\r\n   * * This can be false (for instance) if a ClipShape is holding a polygon but has not yet been asked to construct the planes.\r\n   */\r\n  public arePlanesDefined(): boolean {\r\n    return this._clipPlanes !== undefined;\r\n  }\r\n  /** Return a deep clone  */\r\n  public clone(): ClipPrimitive {\r\n    const newPlanes = this._clipPlanes ? this._clipPlanes.clone() : undefined;\r\n    const result = new ClipPrimitive(newPlanes, this._invisible);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * * trigger (if needed)  computation of plane sets (if applicable) in the derived class.\r\n   * * Base class is no op.\r\n   * * In derived class, on first call create planes sets from defining data (e.g. swept shape).\r\n   * * In derived class, if planes are present leave them alone.\r\n   */\r\n  public ensurePlaneSets() { }\r\n  /** Return true if the point lies inside/on this polygon (or not inside/on if this polygon is a mask). Otherwise, return false.\r\n   * * Note that a derived class may choose to (a) implement its own test using its defining data, or (b) accept this implementation using planes that it inserted in the base class.\r\n   */\r\n  public pointInside(point: Point3d, onTolerance: number = Geometry.smallMetricDistanceSquared): boolean {\r\n    this.ensurePlaneSets();\r\n    let inside = true;\r\n    if (this._clipPlanes)\r\n      inside = this._clipPlanes.isPointOnOrInside(point, onTolerance);\r\n    if (this._invisible)\r\n      inside = !inside;\r\n    return inside;\r\n  }\r\n\r\n  /**\r\n   * Multiply all ClipPlanes DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   */\r\n  public multiplyPlanesByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    if (invert) {  // form inverse once here, reuse for all planes\r\n      const inverse = matrix.createInverse();\r\n      if (!inverse)\r\n        return false;\r\n      return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\r\n    }\r\n\r\n    if (this._clipPlanes)\r\n      this._clipPlanes.multiplyPlanesByMatrix4d(matrix);\r\n    return true;\r\n  }\r\n\r\n  /** Apply a transform to the clipper (e.g. transform all planes) */\r\n  public transformInPlace(transform: Transform): boolean {\r\n    if (this._clipPlanes)\r\n      this._clipPlanes.transformInPlace(transform);\r\n\r\n    return true;\r\n  }\r\n\r\n  /** Sets both the clip plane set and the mask set visibility */\r\n  public setInvisible(invisible: boolean) {\r\n    this._invisible = invisible;\r\n  }\r\n\r\n  /**\r\n   * Return true if any plane of the primary clipPlanes has (a) non-zero z component in its normal vector and (b) finite distance from origin.\r\n   */\r\n  public containsZClip(): boolean {\r\n    if (this.fetchClipPlanesRef() !== undefined)\r\n      for (const convexSet of this._clipPlanes!.convexSets)\r\n        for (const plane of convexSet.planes)\r\n          if (Math.abs(plane.inwardNormalRef.z) > 1.0e-6 && Math.abs(plane.distance) !== Number.MAX_VALUE)\r\n            return true;\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Quick test of whether the given points fall completely inside or outside.\r\n   * @param points points to test\r\n   * @param ignoreInvisibleSetting if true, do the test with the clip planes and return that, ignoring the invisible setting.\r\n   */\r\n  public classifyPointContainment(points: Point3d[], ignoreInvisibleSetting: boolean): ClipPlaneContainment {\r\n    this.ensurePlaneSets();\r\n    const planes = this._clipPlanes;\r\n    let inside = ClipPlaneContainment.StronglyInside;\r\n    if (planes)\r\n      inside = planes.classifyPointContainment(points, false);\r\n    if (this._invisible && !ignoreInvisibleSetting)\r\n      switch (inside) {\r\n        case ClipPlaneContainment.StronglyInside:\r\n          return ClipPlaneContainment.StronglyOutside;\r\n        case ClipPlaneContainment.StronglyOutside:\r\n          return ClipPlaneContainment.StronglyInside;\r\n        case ClipPlaneContainment.Ambiguous:\r\n          return ClipPlaneContainment.Ambiguous;\r\n      }\r\n    return inside;\r\n  }\r\n  /** Promote json object form to class instance\r\n   * * First try to convert to a ClipShape\r\n   * * then try as a standalone instance of the base class ClipPrimitive.\r\n   */\r\n  public static fromJSON(json: any): ClipPrimitive | undefined {\r\n    // try known derived classes first . . .\r\n    const shape = ClipShape.fromClipShapeJSON(json);\r\n    if (shape)\r\n      return shape;\r\n    const prim = ClipPrimitive.fromJSONClipPrimitive(json);\r\n    if (prim)\r\n      return prim;\r\n    return undefined;\r\n  }\r\n  /** Specific converter producing the base class ClipPrimitive. */\r\n  public static fromJSONClipPrimitive(json: any): ClipPrimitive | undefined {\r\n    if (json && json.planes) {\r\n      const planes = json.planes;\r\n      const clipPlanes = planes.hasOwnProperty(\"clips\") ? UnionOfConvexClipPlaneSets.fromJSON(planes.clips) : undefined;\r\n      const invisible = planes.hasOwnProperty(\"invisible\") ? planes.invisible : false;\r\n      return new ClipPrimitive(clipPlanes, invisible);\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/** Internal helper class holding XYZ components that serves as a representation of polygon edges defined by clip planes */\r\nclass PolyEdge {\r\n  public origin: Point3d;\r\n  public next: Point3d;\r\n  public normal: Vector2d;\r\n\r\n  public constructor(origin: Point3d, next: Point3d, normal: Vector2d, z: number) {\r\n    this.origin = Point3d.create(origin.x, origin.y, z);\r\n    this.next = Point3d.create(next.x, next.y, z);\r\n    this.normal = normal;\r\n  }\r\n}\r\n/**\r\n * A clipping volume defined by a shape (an array of 3d points using only x and y dimensions).\r\n * May be given either a ClipPlaneSet to store directly, or an array of polygon points as well as other parameters\r\n * for parsing clipplanes from the shape later.\r\n * @public\r\n */\r\nexport class ClipShape extends ClipPrimitive {\r\n  /** Points of the polygon, in the xy plane of the local coordinate system.  */\r\n  protected _polygon: Point3d[];\r\n  /** optional low z (in local coordinates) */\r\n  protected _zLow?: number;\r\n  /** optional high z (in local coordinates) */\r\n  protected _zHigh?: number;\r\n  /** true if this is considered a hole (keep geometry outside of the polygon.) */\r\n  protected _isMask: boolean;\r\n  /** transform from local to world */\r\n  protected _transformFromClip?: Transform;\r\n  /** Transform from world to local */\r\n  protected _transformToClip?: Transform;\r\n  protected constructor(polygon: Point3d[] = [], zLow?: number, zHigh?: number, transform?: Transform, isMask: boolean = false, invisible: boolean = false) {\r\n    super(undefined, invisible); // ClipPlaneSets will be set up later after storing points\r\n    this._isMask = false;\r\n    this._polygon = polygon;\r\n    this.initSecondaryProps(isMask, zLow, zHigh, transform);\r\n  }\r\n  /** Returns true if this ClipShape is marked as invisible. */\r\n  public get invisible(): boolean { return this._invisible; }\r\n  /** Return this transformFromClip, which may be undefined. */\r\n  public get transformFromClip(): Transform | undefined { return this._transformFromClip; }\r\n  /** Return this transformToClip, which may be undefined. */\r\n  public get transformToClip(): Transform | undefined { return this._transformToClip; }\r\n  /** Returns true if this ClipShape's transforms are currently set. */\r\n  public get transformValid(): boolean { return this.transformFromClip !== undefined; }\r\n  /** Returns true if this ClipShape's lower z boundary is set. */\r\n  public get zLowValid(): boolean { return this._zLow !== undefined; }\r\n  /** Returns true if this ClipShape's upper z boundary is set. */\r\n  public get zHighValid(): boolean { return this._zHigh !== undefined; }\r\n  /** Return true if this ClipShape has a local to world transform */\r\n  public get transformIsValid(): boolean { return this._transformFromClip !== undefined; }\r\n  /** Return this zLow, which may be undefined. */\r\n  public get zLow(): number | undefined { return this._zLow; }\r\n  /** Return this zHigh, which may be undefined. */\r\n  public get zHigh(): number | undefined { return this._zHigh; }\r\n  /** Returns a reference to this ClipShape's polygon array. */\r\n  public get polygon(): Point3d[] { return this._polygon; }\r\n  /** Returns true if this ClipShape is a masking set. */\r\n  public get isMask(): boolean { return this._isMask; }\r\n  /** Sets the polygon points array of this ClipShape to the array given (by reference). */\r\n  public setPolygon(polygon: Point3d[]) {\r\n    // Add closure point\r\n    if (!polygon[0].isAlmostEqual(polygon[polygon.length - 1]))\r\n      polygon.push(polygon[0].clone());\r\n    this._polygon = polygon;\r\n  }\r\n  /**\r\n   * * If the ClipShape's associated `UnionOfConvexClipPlaneSets` is defined, do nothing.\r\n   * * If the ClipShape's associated `UnionOfConvexClipPlaneSets` is undefined, generate it from the `ClipShape` and transform.\r\n   */\r\n  public ensurePlaneSets() {\r\n    if (this._clipPlanes !== undefined)\r\n      return;\r\n    this._clipPlanes = UnionOfConvexClipPlaneSets.createEmpty();\r\n    this.parseClipPlanes(this._clipPlanes);\r\n    if (this._transformFromClip)\r\n      this._clipPlanes!.transformInPlace(this._transformFromClip!);\r\n  }\r\n  /**\r\n   * Initialize the members of the ClipShape class that may at times be undefined.\r\n   * zLow and zHigh default to Number.MAX_VALUE, and the transform defaults to an identity transform\r\n   */\r\n  public initSecondaryProps(isMask: boolean, zLow?: number, zHigh?: number, transform?: Transform) {\r\n    this._isMask = isMask;\r\n    this._zLow = zLow;\r\n    this._zHigh = zHigh;\r\n\r\n    if (transform !== undefined) {\r\n      this._transformFromClip = transform;\r\n      this._transformToClip = transform.inverse(); // could be undefined\r\n    } else {\r\n      this._transformFromClip = Transform.createIdentity();\r\n      this._transformToClip = Transform.createIdentity();\r\n    }\r\n  }\r\n  /** emit json object form */\r\n  public toJSON(): any {\r\n    const val: any = {};\r\n    val.shape = {};\r\n    val.shape.points = [];\r\n    for (const pt of this._polygon)\r\n      val.shape.points.push(pt.toJSON());\r\n    if (this.invisible)\r\n      val.shape.invisible = true;\r\n    if (this._transformFromClip && !this._transformFromClip.isIdentity)\r\n      val.shape.trans = this._transformFromClip.toJSON();\r\n    if (this.isMask)\r\n      val.shape.mask = true;\r\n    if (typeof (this.zLow) !== \"undefined\" && this.zLow !== -Number.MAX_VALUE)\r\n      val.shape.zlow = this.zLow;\r\n    if (typeof (this.zHigh) !== \"undefined\" && this.zHigh !== Number.MAX_VALUE)\r\n      val.shape.zhigh = this.zHigh;\r\n    return val;\r\n  }\r\n  /** parse `json` to a clip shape. */\r\n  public static fromClipShapeJSON(json: any, result?: ClipShape): ClipShape | undefined {\r\n    if (!json.shape)\r\n      return undefined;\r\n    const points: Point3d[] = [];\r\n    if (json.shape.points)\r\n      for (const pt of json.shape.points)\r\n        points.push(Point3d.fromJSON(pt));\r\n    let trans: Transform | undefined;\r\n    if (json.shape.trans)\r\n      trans = Transform.fromJSON(json.shape.trans);\r\n    let zLow: number | undefined;\r\n    if (undefined !== json.shape.zlow)\r\n      zLow = json.shape.zlow as number;\r\n    let zHigh: number | undefined;\r\n    if (undefined !== json.shape.zhigh)\r\n      zHigh = json.shape.zhigh as number;\r\n    let isMask = false;\r\n    if (json.shape.mask)\r\n      isMask = json.shape.mask as boolean;\r\n    let invisible = false;\r\n    if (json.shape.invisible)\r\n      invisible = true;\r\n    return ClipShape.createShape(points, zLow, zHigh, trans, isMask, invisible, result);\r\n  }\r\n  /** Returns a new ClipShape that is a deep copy of the ClipShape given */\r\n  public static createFrom(other: ClipShape, result?: ClipShape): ClipShape {\r\n    const retVal = ClipShape.createEmpty(false, false, undefined, result);\r\n    retVal._invisible = other._invisible;\r\n    for (const point of other._polygon) {\r\n      retVal._polygon.push(point.clone());\r\n    }\r\n    retVal._isMask = other._isMask;\r\n    retVal._zLow = other._zLow;\r\n    retVal._zHigh = other._zHigh;\r\n    retVal._transformToClip = other._transformToClip ? other._transformToClip.clone() : undefined;\r\n    retVal._transformFromClip = other._transformFromClip ? other._transformFromClip.clone() : undefined;\r\n    return retVal;\r\n  }\r\n  /** Create a new ClipShape from an array of points that make up a 2d shape (stores a deep copy of these points). */\r\n  public static createShape(polygon: Point3d[] = [], zLow?: number, zHigh?: number, transform?: Transform, isMask: boolean = false, invisible: boolean = false, result?: ClipShape): ClipShape | undefined {\r\n    if (polygon.length < 3)\r\n      return undefined;\r\n    const pPoints = polygon.slice(0);\r\n    // Add closure point\r\n    if (!pPoints[0].isExactEqual(pPoints[pPoints.length - 1]))\r\n      pPoints.push(pPoints[0]);\r\n    if (result) {\r\n      result._clipPlanes = undefined; // Start as undefined\r\n      result._invisible = invisible;\r\n      result._polygon = pPoints;\r\n      result.initSecondaryProps(isMask, zLow, zHigh, transform);\r\n      return result;\r\n    } else {\r\n      return new ClipShape(pPoints, zLow, zHigh, transform, isMask, invisible);\r\n    }\r\n  }\r\n  /**\r\n   * Create a ClipShape that exists as a 3 dimensional box of the range given. Optionally choose to\r\n   * also store this shape's zLow and zHigh members from the range through the use of a RangePlaneBitMask.\r\n   */\r\n  public static createBlock(extremities: Range3d, clipMask: ClipMaskXYZRangePlanes, isMask: boolean = false, invisible: boolean = false, transform?: Transform, result?: ClipShape): ClipShape {\r\n    const low = extremities.low;\r\n    const high = extremities.high;\r\n    const blockPoints: Point3d[] = [];\r\n    for (let i = 0; i < 5; i++)\r\n      blockPoints.push(Point3d.create());\r\n    blockPoints[0].x = blockPoints[3].x = blockPoints[4].x = low.x;\r\n    blockPoints[1].x = blockPoints[2].x = high.x;\r\n    blockPoints[0].y = blockPoints[1].y = blockPoints[4].y = low.y;\r\n    blockPoints[2].y = blockPoints[3].y = high.y;\r\n    return ClipShape.createShape(blockPoints, (ClipMaskXYZRangePlanes.None !== (clipMask & ClipMaskXYZRangePlanes.ZLow)) ? low.z : undefined, ClipMaskXYZRangePlanes.None !== (clipMask & ClipMaskXYZRangePlanes.ZHigh) ? high.z : undefined, transform, isMask, invisible, result)!;\r\n  }\r\n  /** Creates a new ClipShape with undefined members and a polygon points array of zero length. */\r\n  public static createEmpty(isMask = false, invisible: boolean = false, transform?: Transform, result?: ClipShape): ClipShape {\r\n    if (result) {\r\n      result._clipPlanes = undefined;\r\n      result._invisible = invisible;\r\n      result._polygon.length = 0;\r\n      result.initSecondaryProps(isMask, undefined, undefined, transform);\r\n      return result;\r\n    }\r\n    return new ClipShape([], undefined, undefined, transform, isMask, invisible);\r\n  }\r\n  /** Checks to ensure that the member polygon has an area, and that the polygon is closed. */\r\n  public get isValidPolygon(): boolean {\r\n    if (this._polygon.length < 3)\r\n      return false;\r\n    if (!this._polygon[0].isExactEqual(this._polygon[this._polygon.length - 1]))\r\n      return false;\r\n    return true;\r\n  }\r\n  /** Returns a deep copy of this instance of ClipShape, storing in an optional result */\r\n  public clone(result?: ClipShape): ClipShape {\r\n    return ClipShape.createFrom(this, result);\r\n  }\r\n  /** Given the current polygon data, parses clip planes that together form an object, storing the result in the set given, either clipplanes or maskplanes. */\r\n  private parseClipPlanes(set: UnionOfConvexClipPlaneSets) {\r\n    const points = this._polygon;\r\n    if (points.length === 3 && !this._isMask && points[0].isExactEqual(points[points.length - 1])) {\r\n      this.parseLinearPlanes(set, this._polygon[0], this._polygon[1]);\r\n      return true;\r\n    }\r\n    const direction = PolygonOps.testXYPolygonTurningDirections(points);\r\n    if (0 !== direction) {\r\n      this.parseConvexPolygonPlanes(set, this._polygon, direction);\r\n      return true;\r\n    } else {\r\n      this.parseConcavePolygonPlanes(set, this._polygon);\r\n      return false;\r\n    }\r\n  }\r\n  /** Given a start and end point, populate the given UnionOfConvexClipPlaneSets with ConvexClipPlaneSets defining the bounded region of linear planes. Returns true if successful. */\r\n  private parseLinearPlanes(set: UnionOfConvexClipPlaneSets, start: Point3d, end: Point3d, cameraFocalLength?: number): boolean {\r\n    // Handles the degenerate case of 2 distinct points (used by select by line).\r\n    const normal = start.vectorTo(end);\r\n    if (normal.magnitude() === 0.0)\r\n      return false;\r\n    normal.normalize(normal);\r\n    const convexSet = ConvexClipPlaneSet.createEmpty();\r\n    if (cameraFocalLength === undefined) {\r\n      const perpendicular = Vector2d.create(-normal.y, normal.x);\r\n      convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(normal.x, normal.y), Point3d.createFrom(start), this._invisible)!);\r\n      convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(-normal.x, -normal.y), Point3d.createFrom(end), this._invisible)!);\r\n      convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(perpendicular.x, perpendicular.y), Point3d.createFrom(start), this._invisible)!);\r\n      convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(-perpendicular.x, -perpendicular.y), Point3d.createFrom(start), this._invisible)!);\r\n    } else {\r\n      const start3d = Point3d.create(start.x, start.y, -cameraFocalLength);\r\n      const end3d = Point3d.create(end.x, end.y, -cameraFocalLength);\r\n      const vecEnd3d = Vector3d.createFrom(end3d);\r\n      const perpendicular = vecEnd3d.crossProduct(Vector3d.createFrom(start3d)).normalize();\r\n      let endNormal = Vector3d.createFrom(start3d).crossProduct(perpendicular!).normalize();\r\n      convexSet.planes.push(ClipPlane.createNormalAndDistance(perpendicular!, 0.0, this._invisible)!);\r\n      convexSet.planes.push(ClipPlane.createNormalAndDistance(endNormal!, 0.0, this._invisible)!);\r\n      perpendicular!.negate();\r\n      endNormal = vecEnd3d.crossProduct(perpendicular!).normalize();\r\n      convexSet.planes.push(ClipPlane.createNormalAndDistance(perpendicular!, 0.0, this._invisible)!);\r\n      convexSet.planes.push(ClipPlane.createNormalAndDistance(endNormal!, 0.0, this._invisible)!);\r\n    }\r\n    convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);\r\n    set.addConvexSet(convexSet);\r\n    return true;\r\n  }\r\n  /** Given a convex polygon defined as an array of points, populate the given UnionOfConvexClipPlaneSets with ConvexClipPlaneSets defining the bounded region. Returns true if successful. */\r\n  private parseConvexPolygonPlanes(set: UnionOfConvexClipPlaneSets, polygon: Point3d[], direction: number, cameraFocalLength?: number): boolean {\r\n    const samePointTolerance = 1.0e-8; // This could possibly be replaced with more widely used constants\r\n    const edges: PolyEdge[] = [];\r\n    const reverse = (direction < 0) !== this._isMask;\r\n    for (let i = 0; i < polygon.length - 1; i++) {\r\n      const z = (cameraFocalLength === undefined) ? 0.0 : -cameraFocalLength;\r\n      const dir = Vector2d.createFrom((polygon[i + 1].minus(polygon[i])));\r\n      const magnitude = dir.magnitude();\r\n      dir.normalize(dir);\r\n      if (magnitude > samePointTolerance) {\r\n        const normal = Vector2d.create(reverse ? dir.y : -dir.y, reverse ? -dir.x : dir.x);\r\n        edges.push(new PolyEdge(polygon[i], polygon[i + 1], normal, z));\r\n      }\r\n    }\r\n    if (edges.length < 3) {\r\n      return false;\r\n    }\r\n    if (this._isMask) {\r\n      const last = edges.length - 1;\r\n      for (let i = 0; i <= last; i++) {\r\n        const edge = edges[i];\r\n        const prevEdge = edges[i ? (i - 1) : last];\r\n        const nextEdge = edges[(i === last) ? 0 : (i + 1)];\r\n        const convexSet = ConvexClipPlaneSet.createEmpty();\r\n        const prevNormal = edge.normal.minus(prevEdge.normal);\r\n        const nextNormal = edge.normal.minus(nextEdge.normal);\r\n        prevNormal.normalize(prevNormal);\r\n        nextNormal.normalize(nextNormal);\r\n        // Create three-sided fans from each edge.   Note we could define the correct region\r\n        // with only two planes for edge, but cannot then designate the \"interior\" status of the edges accurately.\r\n        convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(prevNormal.x, prevNormal.y), edge.origin, this._invisible, true)!);\r\n        convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(edge.normal.x, edge.normal.y), edge.origin, this._invisible, false)!);\r\n        convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(nextNormal.x, nextNormal.y), nextEdge.origin, this._invisible, true)!);\r\n        convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);\r\n        set.addConvexSet(convexSet);\r\n      }\r\n      set.addOutsideZClipSets(this._invisible, this._zLow, this._zHigh);\r\n    } else {\r\n      const convexSet = ConvexClipPlaneSet.createEmpty();\r\n      if (cameraFocalLength === undefined) {\r\n        for (const edge of edges)\r\n          convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(edge.normal.x, edge.normal.y), edge.origin)!);\r\n      } else {\r\n        if (reverse)\r\n          for (const edge of edges)\r\n            convexSet.planes.push(ClipPlane.createNormalAndDistance(Vector3d.createFrom(edge.origin).crossProduct(Vector3d.createFrom(edge.next)).normalize()!, 0.0)!);\r\n        else\r\n          for (const edge of edges)\r\n            convexSet.planes.push(ClipPlane.createNormalAndDistance(Vector3d.createFrom(edge.next).crossProduct(Vector3d.createFrom(edge.origin)).normalize()!, 0.0)!);\r\n      }\r\n      convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);\r\n      set.addConvexSet(convexSet);\r\n    }\r\n    return true;\r\n  }\r\n  /** Given a concave polygon defined as an array of points, populate the given UnionOfConvexClipPlaneSets with multiple ConvexClipPlaneSets defining the bounded region. Returns true if successful. */\r\n  private parseConcavePolygonPlanes(set: UnionOfConvexClipPlaneSets, polygon: Point3d[], cameraFocalLength?: number): boolean {\r\n    const triangulatedPolygon = Triangulator.createTriangulatedGraphFromSingleLoop(polygon);\r\n    Triangulator.flipTriangles(triangulatedPolygon);\r\n    triangulatedPolygon.announceFaceLoops((_graph: HalfEdgeGraph, edge: HalfEdge): boolean => {\r\n      if (!edge.isMaskSet(HalfEdgeMask.EXTERIOR)) {\r\n        const convexFacetPoints = edge.collectAroundFace((node: HalfEdge): any => {\r\n          if (!node.isMaskSet(HalfEdgeMask.EXTERIOR))\r\n            return Point3d.create(node.x, node.y, 0);\r\n        });\r\n        // parseConvexPolygonPlanes expects a closed loop (pushing the reference doesn't matter)\r\n        convexFacetPoints.push(convexFacetPoints[0]);\r\n        const direction = PolygonOps.testXYPolygonTurningDirections(convexFacetPoints); // ###TODO: Can we expect a direction coming out of graph facet?\r\n        this.parseConvexPolygonPlanes(set, convexFacetPoints, direction, cameraFocalLength);\r\n      }\r\n      return true;\r\n    });\r\n    return true;\r\n  }\r\n  /**\r\n   * Multiply all ClipPlanes DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   */\r\n  public multiplyPlanesByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    this.ensurePlaneSets();\r\n    return super.multiplyPlanesByMatrix4d(matrix, invert, transpose);\r\n  }\r\n  /** Apply `transform` to the local to world (`transformFromClip`) transform.\r\n   * * The world to local transform (`transformToClip` is recomputed from the (changed) `transformToClip`\r\n   * * the transform is passed to the base class to be applied to clip plane form of the clipper.\r\n   */\r\n  public transformInPlace(transform: Transform): boolean {\r\n    if (transform.isIdentity)\r\n      return true;\r\n    super.transformInPlace(transform);\r\n    if (this._transformFromClip)\r\n      transform.multiplyTransformTransform(this._transformFromClip!, this._transformFromClip);\r\n    else\r\n      this._transformFromClip = transform.clone();\r\n    this._transformToClip = this._transformFromClip!.inverse(); // could be undefined\r\n    return true;\r\n  }\r\n  /** Return true if\r\n   * * at least one point is defined\r\n   * * The local to world transform (transformFromClip) either\r\n   *   * is undefined\r\n   *   * has no xy parts in its column Z (local frame Z is parallel to global Z)\r\n   */\r\n  public get isXYPolygon(): boolean {\r\n    if (this._polygon.length === 0) // Note: This is a lenient check, as points array could also contain less than 3 points (not a polygon)\r\n      return false;\r\n    if (this._transformFromClip === undefined)\r\n      return true;\r\n    const zVector = this._transformFromClip.matrix.columnZ();\r\n    return zVector.magnitudeXY() < 1.0e-8;\r\n  }\r\n  /** Transform the input point using this instance's transformToClip member */\r\n  public performTransformToClip(point: Point3d) {\r\n    if (this._transformToClip !== undefined)\r\n      this._transformToClip.multiplyPoint3d(point);\r\n  }\r\n  /** Transform the input point using this instance's transformFromClip member */\r\n  public performTransformFromClip(point: Point3d) {\r\n    if (this._transformFromClip !== undefined)\r\n      this._transformFromClip.multiplyPoint3d(point);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { UnionOfConvexClipPlaneSets } from \"./UnionOfConvexClipPlaneSets\";\r\nimport { CurvePrimitive, AnnounceNumberNumber, AnnounceNumberNumberCurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { ClipPrimitive } from \"./ClipPrimitive\";\r\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { ClipVector } from \"./ClipVector\";\r\n/** @module CartesianGeometry */\r\n\r\n/** Enumerated type for describing where geometry lies with respect to clipping planes.\r\n * @public\r\n */\r\nexport enum ClipPlaneContainment {\r\n  /** All points inside */\r\n  StronglyInside = 1,\r\n  /** Inside/outside state unknown. */\r\n  Ambiguous = 2,\r\n  /** All points outside */\r\n  StronglyOutside = 3,\r\n}\r\n\r\n/** Enumerated type for describing what must yet be done to clip a piece of geometry.\r\n * @public\r\n */\r\nexport enum ClipStatus {\r\n  /** some geometry may cross the clip boundaries */\r\n  ClipRequired,\r\n  /** geometry is clearly outside */\r\n  TrivialReject,\r\n  /** geometry is clearly inside */\r\n  TrivialAccept,\r\n}\r\n\r\n/** An object containing clipping planes that can be used to clip geometry.\r\n * @public\r\n */\r\nexport interface Clipper {\r\n  /** test if `point` is on or inside the Clipper's volume. */\r\n  isPointOnOrInside(point: Point3d, tolerance?: number): boolean;\r\n  /** Find the parts of the line segment  (if any) that is within the convex clip volume.\r\n   * * The input fractional interval from fraction0 to fraction1 (increasing!!) is the active part to consider.\r\n   * * To clip to the usual bounded line segment, start with fractions (0,1).\r\n   * If the clip volume is unbounded, the line interval may also be unbounded.\r\n   * * An unbounded line portion will have fraction coordinates positive or negative Number.MAX_VALUE.\r\n   * @param f0 fraction that is the initial lower fraction of the active interval. (e.g. 0.0 for bounded segment)\r\n   * @param f1 fraction that is the initial upper fraction of the active interval.  (e.g. 1.0 for bounded segment)\r\n   * @param pointA segment start (fraction 0)\r\n   * @param pointB segment end (fraction 1)\r\n   * @param announce function to be called to announce a fraction interval that is within the convex clip volume.\r\n   * @returns true if a segment was announced, false if entirely outside.\r\n   */\r\n  announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: AnnounceNumberNumber): boolean;\r\n  /** Find the portion (or portions) of the arc (if any) that are within the convex clip volume.\r\n   * * The input fractional interval from fraction0 to fraction1 (increasing!!) is the active part to consider.\r\n   * @param announce function to be called to announce a fraction interval that is within the convex clip volume.\r\n   * @returns true if one or more arcs portions were announced, false if entirely outside.\r\n   */\r\n  announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean;\r\n}\r\n\r\n/** Static class whose various methods are functions for clipping geometry\r\n * @public\r\n */\r\nexport class ClipUtilities {\r\n  private static _selectIntervals01TestPoint = Point3d.create();\r\n  /**\r\n   * * Augment the unsortedFractionsArray with 0 and 1\r\n   * * sort\r\n   * * test the midpoint of each interval with `clipper.isPointOnOrInside`\r\n   * * pass accepted intervals to `announce(f0,f1,curve)`\r\n   */\r\n  public static selectIntervals01(curve: CurvePrimitive, unsortedFractions: GrowableFloat64Array, clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    unsortedFractions.push(0);\r\n    unsortedFractions.push(1);\r\n    unsortedFractions.sort();\r\n    let f0 = unsortedFractions.atUncheckedIndex(0);\r\n    let f1;\r\n    let fMid;\r\n    const testPoint = ClipUtilities._selectIntervals01TestPoint;\r\n    const n = unsortedFractions.length;\r\n    for (let i = 1; i < n; i++ , f0 = f1) {\r\n      f1 = unsortedFractions.atUncheckedIndex(i);\r\n      fMid = 0.5 * (f0 + f1);\r\n      if (f1 > f0 && (fMid >= 0.0 && fMid <= 1.0)) {\r\n        curve.fractionToPoint(fMid, testPoint);\r\n        if (clipper.isPointOnOrInside(testPoint)) {\r\n          if (announce)\r\n            announce(f0, f1, curve);\r\n          else\r\n            return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * Announce triples of (low, high, cp) for each entry in intervals\r\n   * @param intervals source array\r\n   * @param cp CurvePrimitive for announcement\r\n   * @param announce function to receive data\r\n   */\r\n  public static announceNNC(intervals: Range1d[], cp: CurvePrimitive, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    if (announce) {\r\n      for (const ab of intervals) {\r\n        announce(ab.low, ab.high, cp);\r\n      }\r\n    }\r\n    return intervals.length > 0;\r\n  }\r\n\r\n  /** Find portions of the curve that are within the clipper.\r\n   * Collect them into an array of curve primitives.\r\n   */\r\n  public static collectClippedCurves(curve: CurvePrimitive, clipper: Clipper): CurvePrimitive[] {\r\n    const result: CurvePrimitive[] = [];\r\n    curve.announceClipIntervals(clipper,\r\n      (fraction0: number, fraction1: number, curveA: CurvePrimitive) => {\r\n        if (fraction1 !== fraction0) {\r\n          const partialCurve = curveA.clonePartialCurve(fraction0, fraction1);\r\n          if (partialCurve)\r\n            result.push(partialCurve);\r\n        }\r\n      });\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Clip a polygon down to regions defined by each shape of a ClipShape.\r\n   * @return An multidimensional array of points, where each array is the boundary of part of the remaining polygon.\r\n   */\r\n  public static clipPolygonToClipShape(polygon: Point3d[], clipShape: ClipPrimitive): Point3d[][] {\r\n    const outputA = this.clipPolygonToClipShapeReturnGrowableXYZArrays(polygon, clipShape);\r\n    const output = [];\r\n    for (const g of outputA)\r\n      output.push(g.getPoint3dArray());\r\n    return output;\r\n  }\r\n\r\n  /**\r\n   * Clip a polygon down to regions defined by each shape of a ClipShape.\r\n   * @return An multidimensional array of points, where each array is the boundary of part of the remaining polygon.\r\n   */\r\n  public static clipPolygonToClipShapeReturnGrowableXYZArrays(polygon: Point3d[], clipShape: ClipPrimitive): GrowableXYZArray[] {\r\n    const output: GrowableXYZArray[] = [];\r\n    const clipper = clipShape.fetchClipPlanesRef();\r\n    // NEEDS WORK -- what if it is a mask !!!!\r\n    if (clipper) {\r\n      clipper.polygonClip(polygon, output);\r\n    }\r\n    return output;\r\n  }\r\n\r\n  /** Given an array of points, test for trivial containment conditions.\r\n   * * ClipStatus.TrivialAccept if all points are in any one of the convexSet's.\r\n   * * ClipStatus.ClipRequired if (in any single convexSet) there were points on both sides of any single plane.\r\n   * * ClipStatus.TrivialReject if neither of those occurred.\r\n   */\r\n  public static pointSetSingleClipStatus(points: GrowableXYZArray, planeSet: UnionOfConvexClipPlaneSets, tolerance: number): ClipStatus {\r\n    if (planeSet.convexSets.length === 0)\r\n      return ClipStatus.TrivialAccept;\r\n\r\n    for (const convexSet of planeSet.convexSets) {\r\n      let allOutsideSinglePlane = false, anyOutside = false;\r\n\r\n      for (const plane of convexSet.planes) {\r\n        let numInside = 0, numOutside = 0;\r\n        const planeDistance = plane.distance - tolerance;\r\n\r\n        const currPt = Point3d.create();\r\n        const currVec = Vector3d.create();\r\n        for (let i = 0; i < points.length; i++) {\r\n          points.getPoint3dAtUncheckedPointIndex(i, currPt);\r\n          currVec.setFrom(currPt);\r\n          currVec.dotProduct(plane.inwardNormalRef) > planeDistance ? numInside++ : numOutside++;\r\n        }\r\n\r\n        anyOutside = (numOutside !== 0) ? true : anyOutside;\r\n        if (numInside === 0) {\r\n          allOutsideSinglePlane = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!anyOutside)  // totally inside this set - no clip required\r\n        return ClipStatus.TrivialAccept;\r\n      if (!allOutsideSinglePlane)\r\n        return ClipStatus.ClipRequired;\r\n    }\r\n    return ClipStatus.TrivialReject;\r\n  }\r\n\r\n  /**\r\n   * Emit point loops for intersection of a convex set with a range.\r\n   * * return zero length array for (a) null range or (b) no intersections\r\n   * @param range range to intersect\r\n   * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.\r\n   * @param includeRangeFaces if false, do not compute facets originating as range faces\r\n   * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.\r\n   */\r\n  public static announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet: ConvexClipPlaneSet, range: Range3d, loopFunction: (loopPoints: GrowableXYZArray) => void,\r\n    includeConvexSetFaces: boolean = true, includeRangeFaces: boolean = true, ignoreInvisiblePlanes = false) {\r\n    const work = new GrowableXYZArray();\r\n    if (includeConvexSetFaces) {\r\n      // Clip convexSet planes to the range and to the rest of the convexSet . .\r\n      for (const plane of convexSet.planes) {\r\n        if (ignoreInvisiblePlanes && plane.invisible)\r\n          continue;\r\n        const pointsClippedToRange = plane.intersectRange(range, true);\r\n        const finalPoints = new GrowableXYZArray();\r\n        if (pointsClippedToRange) {\r\n          convexSet.polygonClip(pointsClippedToRange, finalPoints, work, plane);\r\n          if (finalPoints.length > 0)\r\n            loopFunction(finalPoints);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (includeRangeFaces) {\r\n      // clip range faces to the convex set . . .\r\n      const corners = range.corners();\r\n      for (let i = 0; i < 6; i++) {\r\n        const indices = Range3d.faceCornerIndices(i);\r\n        const finalPoints = new GrowableXYZArray();\r\n        const lineString = LineString3d.createIndexedPoints(corners, indices);\r\n        convexSet.polygonClip(lineString.packedPoints, finalPoints, work);\r\n        if (finalPoints.length > 0)\r\n          loopFunction(finalPoints);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return a (possibly empty) array of geometry (Loops !!) which are facets of the intersection of the convex set intersecting a range.\r\n   * * return zero length array for (a) null range or (b) no intersections\r\n   * @param range range to intersect\r\n   * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.\r\n   * @param includeRangeFaces if false, do not compute facets originating as range faces\r\n   * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.\r\n   */\r\n  public static loopsOfConvexClipPlaneIntersectionWithRange(convexSet: ConvexClipPlaneSet, range: Range3d,\r\n    includeConvexSetFaces: boolean = true, includeRangeFaces: boolean = true, ignoreInvisiblePlanes = false): GeometryQuery[] {\r\n    const result: GeometryQuery[] = [];\r\n    this.announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet, range,\r\n      (points: GrowableXYZArray) => {\r\n        if (points.length > 0) result.push(Loop.createPolygon(points));\r\n      },\r\n      includeConvexSetFaces, includeRangeFaces, ignoreInvisiblePlanes);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the (possibly null) range of the intersection of the convex set with a range.\r\n   * * The convex set is permitted to be unbounded (e.g. a single plane).  The range parameter provides bounds.\r\n   * @param convexSet convex set for intersection.\r\n   * @param range range to intersect\r\n   */\r\n  public static rangeOfConvexClipPlaneSetIntersectionWithRange(convexSet: ConvexClipPlaneSet, range: Range3d): Range3d {\r\n    const result = Range3d.createNull();\r\n    this.announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet, range,\r\n      (points: GrowableXYZArray) => {\r\n        if (points.length > 0) result.extendArray(points);\r\n      },\r\n      true, true, false);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the range of various types of clippers\r\n   * * `ConvexClipPlaneSet` -- dispatch to `rangeOfConvexClipPlaneSetIntersectionWithRange`\r\n   * * `UnionOfConvexClipPlaneSet` -- union of ranges of member `ConvexClipPlaneSet`\r\n   * * `ClipPrimitive` -- access its `UnionOfConvexClipPlaneSet`.\r\n   * * `ClipVector` -- intersection of the ranges of its `ClipPrimitive`.\r\n   * * `undefined` -- entire input range.\r\n   * * If `observeInvisibleFlag` is false, the \"invisible\" properties are ignored, and this effectively returns the range of the edge work of the members\r\n   * * If `observeInvisibleFlag` is false, the \"invisible\" properties are observed, and \"invisible\" parts do not restrict the range.\r\n   * @param clipper\r\n   * @param range non-null range.\r\n   * @param observeInvisibleFlag indicates how \"invisible\" bit is applied for ClipPrimitive.\r\n   */\r\n  public static rangeOfClipperIntersectionWithRange(clipper: ConvexClipPlaneSet | UnionOfConvexClipPlaneSets | ClipPrimitive | ClipVector | undefined, range: Range3d, observeInvisibleFlag: boolean = true): Range3d {\r\n    if (clipper === undefined)\r\n      return range.clone();\r\n    if (clipper instanceof ConvexClipPlaneSet)\r\n      return this.rangeOfConvexClipPlaneSetIntersectionWithRange(clipper, range);\r\n    if (clipper instanceof UnionOfConvexClipPlaneSets) {\r\n      const rangeUnion = Range3d.createNull();\r\n      for (const c of clipper.convexSets) {\r\n        const rangeC = this.rangeOfConvexClipPlaneSetIntersectionWithRange(c, range);\r\n        rangeUnion.extendRange(rangeC);\r\n      }\r\n      return rangeUnion;\r\n    }\r\n    if (clipper instanceof ClipPrimitive) {\r\n      if (observeInvisibleFlag && clipper.invisible)\r\n        return range.clone();\r\n      return this.rangeOfClipperIntersectionWithRange(clipper.fetchClipPlanesRef(), range);\r\n    }\r\n    if (clipper instanceof ClipVector) {\r\n      const rangeIntersection = range.clone();\r\n      for (const c of clipper.clips) {\r\n        if (observeInvisibleFlag && c.invisible) {\r\n          // trivial range tests do not expose the effects.   Assume the hole allows everything.\r\n        } else {\r\n          const rangeC = this.rangeOfClipperIntersectionWithRange(c, range, observeInvisibleFlag);\r\n          rangeIntersection.intersect(rangeC, rangeIntersection);\r\n        }\r\n      }\r\n      return rangeIntersection;\r\n\r\n    }\r\n    return range.clone();\r\n  }\r\n  /**\r\n   * Test if various types of clippers have any intersection with a range.\r\n   * * This follows the same logic as `rangeOfClipperIntersectionWithRange` but attempts to exit at earliest point of confirmed intersection\r\n   * * `ConvexClipPlaneSet` -- dispatch to `doesConvexClipPlaneSetIntersectRange`\r\n   * * `UnionOfConvexClipPlaneSet` -- union of ranges of member `ConvexClipPlaneSet`\r\n   * * `ClipPrimitive` -- access its `UnionOfConvexClipPlaneSet`.\r\n   * * `ClipVector` -- intersection of the ranges of its `ClipPrimitive`.\r\n   * * `undefined` -- entire input range.\r\n   * * If `observeInvisibleFlag` is false, the \"invisible\" properties are ignored, and holes do not affect the result.\r\n   * * If `observeInvisibleFlag` is true, the \"invisible\" properties are observed, and may affect the result.\r\n   * @param clipper\r\n   * @param range non-null range.\r\n   * @param observeInvisibleFlag indicates how \"invisible\" bit is applied for ClipPrimitive.\r\n   */\r\n  public static doesClipperIntersectRange(clipper: ConvexClipPlaneSet | UnionOfConvexClipPlaneSets | ClipPrimitive | ClipVector | undefined, range: Range3d, observeInvisibleFlag: boolean = true): boolean {\r\n    if (clipper === undefined)\r\n      return true;\r\n\r\n    if (clipper instanceof ConvexClipPlaneSet)\r\n      return this.doesConvexClipPlaneSetIntersectRange(clipper, range);\r\n\r\n    if (clipper instanceof UnionOfConvexClipPlaneSets) {\r\n      for (const c of clipper.convexSets) {\r\n        if (this.doesConvexClipPlaneSetIntersectRange(c, range))\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    if (clipper instanceof ClipPrimitive) {\r\n      if (observeInvisibleFlag && clipper.invisible)    // um is there an easy way to detect range-completely-inside?\r\n        return true;\r\n      return this.doesClipperIntersectRange(clipper.fetchClipPlanesRef(), range);\r\n    }\r\n\r\n    if (clipper instanceof ClipVector) {\r\n      const rangeIntersection = range.clone();\r\n      for (const c of clipper.clips) {\r\n        if (observeInvisibleFlag && c.invisible) {\r\n          // trivial range tests do not expose the effects.   Assume the hole allows everything.\r\n        } else {\r\n          const rangeC = this.rangeOfClipperIntersectionWithRange(c, range, observeInvisibleFlag);\r\n          rangeIntersection.intersect(rangeC, rangeIntersection);\r\n        }\r\n      }\r\n      return !rangeIntersection.isNull;\r\n    }\r\n    /** If the case statement above is complete for the variant inputs, this is unreachable .. */\r\n    return false;\r\n  }\r\n  /**\r\n   * Emit point loops for intersection of a convex set with a range.\r\n   * * return zero length array for (a) null range or (b) no intersections\r\n   * @param range range to intersect\r\n   * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.\r\n   * @param includeRangeFaces if false, do not compute facets originating as range faces\r\n   * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.\r\n   */\r\n  public static doesConvexClipPlaneSetIntersectRange(convexSet: ConvexClipPlaneSet, range: Range3d,\r\n    includeConvexSetFaces: boolean = true, includeRangeFaces: boolean = true, ignoreInvisiblePlanes = false): boolean {\r\n    const work = new GrowableXYZArray();\r\n    if (includeConvexSetFaces) {\r\n      // Clip convexSet planes to the range and to the rest of the convexSet . .\r\n      for (const plane of convexSet.planes) {\r\n        if (ignoreInvisiblePlanes && plane.invisible)\r\n          continue;\r\n        const pointsClippedToRange = plane.intersectRange(range, true);\r\n        if (pointsClippedToRange) {\r\n          const finalPoints = new GrowableXYZArray();\r\n          convexSet.polygonClip(pointsClippedToRange, finalPoints, work, plane);\r\n          if (finalPoints.length > 0)\r\n            return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (includeRangeFaces) {\r\n      // clip range faces to the convex set . . .\r\n      const corners = range.corners();\r\n      for (let i = 0; i < 6; i++) {\r\n        const indices = Range3d.faceCornerIndices(i);\r\n        const finalPoints = new GrowableXYZArray();\r\n        const lineString = LineString3d.createIndexedPoints(corners, indices);\r\n        convexSet.polygonClip(lineString.packedPoints, finalPoints, work);\r\n        if (finalPoints.length > 0)\r\n          return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { ClipPrimitive, ClipMaskXYZRangePlanes, ClipShape } from \"./ClipPrimitive\";\r\nimport { ClipPlaneContainment } from \"./ClipUtils\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\n\r\n/** Class holding an array structure of shapes defined by `ClipPrimitive`\r\n * * The `ClipVector` defines an intersection of the member `ClipPrimitive` regions.\r\n * * In the most common usage, one of the `ClipPrimitive` will be an outer region, and all others are holes with marker flag indicating that they outside of each hole is live.\r\n * @public\r\n */\r\nexport class ClipVector {\r\n  private _clips: ClipPrimitive[];\r\n  /** range acting as first filter.\r\n   * * This is understood as overall range limit, not as precise planes.\r\n   * * applying any rotation to the whole ClipVector generally expands this range, rather than exactly transforming its planes.\r\n   */\r\n  public boundingRange: Range3d = Range3d.createNull();\r\n\r\n  /** Returns a reference to the array of ClipShapes. */\r\n  public get clips() { return this._clips; }\r\n\r\n  private constructor(clips?: ClipPrimitive[]) {\r\n    this._clips = clips ? clips : [];\r\n  }\r\n\r\n  /** Returns true if this ClipVector contains a ClipPrimitive. */\r\n  public get isValid(): boolean { return this._clips.length > 0; }\r\n\r\n  /** Create a ClipVector with an empty set of ClipShapes. */\r\n  public static createEmpty(result?: ClipVector): ClipVector {\r\n    if (result) {\r\n      result._clips.length = 0;\r\n      return result;\r\n    }\r\n    return new ClipVector();\r\n  }\r\n\r\n  /** Create a ClipVector from an array of ClipPrimitives (or derived classes) (capture the pointers) */\r\n  public static createCapture(clips: ClipPrimitive[], result?: ClipVector): ClipVector {\r\n    if (result) {\r\n      result._clips = clips;\r\n      return result;\r\n    }\r\n    return new ClipVector(clips);\r\n  }\r\n\r\n  /** Create a ClipVector from (clones of) an array of ClipPrimitives */\r\n  public static create(clips: ClipPrimitive[], result?: ClipVector): ClipVector {\r\n    const clipClones: ClipPrimitive[] = [];\r\n    for (const clip of clips)\r\n      clipClones.push(clip.clone());\r\n    return ClipVector.createCapture(clipClones, result);\r\n  }\r\n\r\n  /** Create a deep copy of another ClipVector */\r\n  public clone(result?: ClipVector): ClipVector {\r\n    const retVal = result ? result : new ClipVector();\r\n    retVal._clips.length = 0;\r\n    for (const clip of this._clips) {\r\n      retVal._clips.push(clip.clone());\r\n    }\r\n    retVal.boundingRange.setFrom(this.boundingRange);\r\n    return retVal;\r\n  }\r\n\r\n  /** Parse this ClipVector into a JSON object. */\r\n  public toJSON(): any {\r\n    if (!this.isValid)\r\n      return [];\r\n\r\n    const val: any = [];\r\n    for (const clipShape of this.clips)\r\n      val.push(clipShape.toJSON());\r\n\r\n    return val;\r\n  }\r\n\r\n  /** Parse a JSON object into a new ClipVector. */\r\n  public static fromJSON(json: any, result?: ClipVector): ClipVector {\r\n    result = result ? result : new ClipVector();\r\n    result.clear();\r\n\r\n    try {\r\n      for (const clip of json) {\r\n        const clipPrim = ClipPrimitive.fromJSON(clip);\r\n        if (clipPrim)\r\n          result._clips.push(clipPrim);\r\n      }\r\n    } catch (e) {\r\n      result.clear();\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /** Empties out the array of ClipShapes. */\r\n  public clear() {\r\n    this._clips.length = 0;\r\n  }\r\n\r\n  /** Append a deep copy of the given ClipPrimitive to this ClipVector. */\r\n  public appendClone(clip: ClipPrimitive) {\r\n    this._clips.push(clip.clone());\r\n  }\r\n\r\n  /** Append a reference of the given ClipPrimitive to this ClipVector. */\r\n  public appendReference(clip: ClipPrimitive) {\r\n    this._clips.push(clip);\r\n  }\r\n\r\n  /** Create and append a new ClipPrimitive to the array given a shape as an array of points. Returns true if successful. */\r\n  public appendShape(shape: Point3d[], zLow?: number, zHigh?: number,\r\n    transform?: Transform, isMask: boolean = false, invisible: boolean = false): boolean {\r\n    const clip = ClipShape.createShape(shape, zLow, zHigh, transform, isMask, invisible);\r\n    if (!clip)\r\n      return false;\r\n    this._clips.push(clip);\r\n    return true;\r\n  }\r\n\r\n  /** Returns true if the given point lies inside all of this ClipVector's ClipShapes (by rule of intersection). */\r\n  public pointInside(point: Point3d, onTolerance: number = Geometry.smallMetricDistanceSquared): boolean {\r\n    if (!this.boundingRange.isNull && !this.boundingRange.containsPoint(point))\r\n      return false;\r\n\r\n    for (const clip of this._clips) {\r\n      if (!clip.pointInside(point, onTolerance))\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Transforms this ClipVector to a new coordinate-system.\r\n   * Note that if the transform has rotate and scale the boundingRange member expands.\r\n   * Returns true if successful.\r\n   */\r\n  public transformInPlace(transform: Transform): boolean {\r\n    for (const clip of this._clips)\r\n      if (clip.transformInPlace(transform) === false)\r\n        return false;\r\n\r\n    if (!this.boundingRange.isNull)\r\n      transform.multiplyRange(this.boundingRange, this.boundingRange);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * A simple way of packaging this ClipVector's ClipShape points into a multidimensional array, while also\r\n   * taking into account each ClipPrimitive's individual transforms.\r\n   *\r\n   * ClipPrimitives OTHER THAN ClipShape are ignored.\r\n   *\r\n   * Information out:\r\n   *  - All of the loop points are stored in the multidimensional Point3d array given (will return unchanged upon failure)\r\n   *  - If given a transform, will be set from the transformFromClip of the first ClipPrimitive\r\n   *  - The ClipMask of the final ClipPrimitive is stored in the returned array at index 0\r\n   *  - The last valid zLow found is stored in the returned array at index 1\r\n   *  - The last valid zHigh found is stored in the returned array at index 2\r\n   */\r\n  public extractBoundaryLoops(loopPoints: Point3d[][], transform?: Transform): number[] {\r\n    let clipM = ClipMaskXYZRangePlanes.None;\r\n    let zBack = -Number.MAX_VALUE;\r\n    let zFront = Number.MAX_VALUE;\r\n    const retVal: number[] = [];\r\n    let nLoops = 0;\r\n\r\n    if (this._clips.length === 0)\r\n      return retVal;\r\n    let firstClipShape: ClipShape | undefined;\r\n    const deltaTrans = Transform.createIdentity();\r\n\r\n    for (const clip of this._clips) {\r\n      if (clip instanceof ClipShape) {\r\n        if (firstClipShape !== undefined && clip !== firstClipShape) {      // Is not the first iteration\r\n          let fwdTrans = Transform.createIdentity();\r\n          let invTrans = Transform.createIdentity();\r\n\r\n          if (firstClipShape.transformValid && clip.transformValid) {\r\n            fwdTrans = clip.transformFromClip!.clone();\r\n            invTrans = firstClipShape.transformToClip!.clone();\r\n          }\r\n          deltaTrans.setFrom(invTrans.multiplyTransformTransform(fwdTrans));\r\n        }\r\n        if (!firstClipShape)\r\n          firstClipShape = clip;\r\n        loopPoints[nLoops] = [];\r\n\r\n        if (clip.polygon !== undefined) {\r\n          clipM = ClipMaskXYZRangePlanes.XAndY;\r\n\r\n          if (clip.zHighValid) {\r\n            clipM = clipM | ClipMaskXYZRangePlanes.ZHigh;\r\n            zFront = clip.zHigh!;\r\n          }\r\n          if (clip.zLowValid) {\r\n            clipM = clipM | ClipMaskXYZRangePlanes.ZLow;\r\n            zBack = clip.zLow!;\r\n          }\r\n\r\n          for (const point of clip.polygon)\r\n            loopPoints[nLoops].push(point.clone());\r\n          deltaTrans.multiplyPoint3dArray(loopPoints[nLoops], loopPoints[nLoops]);\r\n          nLoops++;\r\n        }\r\n      }\r\n    }\r\n\r\n    retVal.push(clipM);\r\n    retVal.push(zBack);\r\n    retVal.push(zFront);\r\n\r\n    if (transform && firstClipShape)\r\n      transform.setFrom(firstClipShape.transformFromClip!);\r\n\r\n    return retVal;\r\n  }\r\n\r\n  /** Sets this ClipVector and all of its members to the visibility specified. */\r\n  public setInvisible(invisible: boolean) {\r\n    for (const clip of this._clips)\r\n      clip.setInvisible(invisible);\r\n  }\r\n\r\n  /** For every clip, parse the member point array into the member clip plane object (only for clipPlanes member, not the mask) */\r\n  public parseClipPlanes() {\r\n    for (const clip of this._clips)\r\n      clip.fetchClipPlanesRef();\r\n  }\r\n\r\n  /**\r\n   * Multiply all ClipPlanes DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   * @returns false if matrix inversion fails.\r\n   */\r\n  public multiplyPlanesByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    if (invert) {  // form inverse once here, reuse for all planes\r\n      const inverse = matrix.createInverse();\r\n      if (!inverse)\r\n        return false;\r\n      return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\r\n    }\r\n    // no inverse necessary -- lower level cannot fail.\r\n    for (const clip of this._clips)\r\n      clip.multiplyPlanesByMatrix4d(matrix, false, transpose);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Determines whether the given points fall inside or outside this set of ClipShapes. If any set is defined by masking planes,\r\n   * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the _clipplanes member.\r\n   */\r\n  public classifyPointContainment(points: Point3d[], ignoreMasks: boolean = false): ClipPlaneContainment {\r\n    let currentContainment = ClipPlaneContainment.Ambiguous;\r\n\r\n    for (const primitive of this._clips) {\r\n      const thisContainment = primitive.classifyPointContainment(points, ignoreMasks);\r\n\r\n      if (ClipPlaneContainment.Ambiguous === thisContainment)\r\n        return ClipPlaneContainment.Ambiguous;\r\n\r\n      if (ClipPlaneContainment.Ambiguous === currentContainment)\r\n        currentContainment = thisContainment;\r\n      else if (currentContainment !== thisContainment)\r\n        return ClipPlaneContainment.Ambiguous;\r\n    }\r\n    return currentContainment;\r\n  }\r\n\r\n  /**\r\n   * Determines whether a 3D range lies inside or outside this set of ClipShapes. If any set is defined by masking planes,\r\n   * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the _clipplanes member.\r\n   */\r\n  public classifyRangeContainment(range: Range3d, ignoreMasks: boolean): ClipPlaneContainment {\r\n    const corners: Point3d[] = range.corners();\r\n    return this.classifyPointContainment(corners, ignoreMasks);\r\n  }\r\n\r\n  /**\r\n   * For an array of points (making up a LineString), tests whether the segment between each point lies inside the ClipVector.\r\n   * If true, returns true immediately.\r\n   */\r\n  public isAnyLineStringPointInside(points: Point3d[]): boolean {\r\n    for (const clip of this._clips) {\r\n      const clipPlaneSet = clip.fetchClipPlanesRef();\r\n      if (clipPlaneSet !== undefined) {\r\n        for (let i = 0; i + 1 < points.length; i++) {\r\n          const segment = LineSegment3d.create(points[i], points[i + 1]);\r\n          if (clipPlaneSet.isAnyPointInOrOnFromSegment(segment))\r\n            return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Note: Line segments are used to represent 1 dimensional intervals here, rather than segments. */\r\n  public sumSizes(intervals: Segment1d[], begin: number, end: number): number {\r\n    let s = 0.0;\r\n    for (let i = begin; i < end; i++)\r\n      s += (intervals[i].x1 - intervals[i].x0);\r\n    return s;\r\n  }\r\n\r\n  private static readonly _TARGET_FRACTION_SUM = 0.99999999;\r\n  /**\r\n   * For an array of points that make up a LineString, develops a line segment between each point pair,\r\n   * and returns true if all segments lie inside this ClipVector.\r\n   */\r\n  public isLineStringCompletelyContained(points: Point3d[]): boolean {\r\n    const clipIntervals: Segment1d[] = [];\r\n\r\n    for (let i = 0; i + 1 < points.length; i++) {\r\n      const segment = LineSegment3d.create(points[i], points[i + 1]);\r\n      let fractionSum = 0.0;\r\n      let index0 = 0;\r\n\r\n      for (const clip of this._clips) {\r\n        const clipPlaneSet = clip.fetchClipPlanesRef();\r\n        if (clipPlaneSet !== undefined) {\r\n          clipPlaneSet.appendIntervalsFromSegment(segment, clipIntervals);\r\n          const index1 = clipIntervals.length;\r\n          fractionSum += this.sumSizes(clipIntervals, index0, index1);\r\n          index0 = index1;\r\n          // ASSUME primitives are non-overlapping...\r\n          if (fractionSum >= ClipVector._TARGET_FRACTION_SUM)\r\n            break;\r\n        }\r\n      }\r\n      if (fractionSum < ClipVector._TARGET_FRACTION_SUM)\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { ClipPlane } from \"./ClipPlane\";\r\nimport { ClipPlaneContainment, Clipper, ClipUtilities } from \"./ClipUtils\";\r\nimport { AnnounceNumberNumberCurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { Range3d, Range1d } from \"../geometry3d/Range\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n\r\n/**\r\n * A ConvexClipPlaneSet is a collection of ClipPlanes, often used for bounding regions of space.\r\n * @public\r\n */\r\nexport class ConvexClipPlaneSet implements Clipper {\r\n  /** Value acting as \"at infinity\" for coordinates along a ray. */\r\n  public static readonly hugeVal = 1e37;\r\n  private _planes: ClipPlane[];\r\n  // private _parity: number;   <--- Not yet used\r\n  // public get parity() { return this._parity; }\r\n  // public set parity(value: number) { this._parity = value; }\r\n  private constructor(planes?: ClipPlane[]) {\r\n    // this._parity = 1;\r\n    this._planes = planes ? planes : [];\r\n  }\r\n  /** Return an array containing all the planes of the convex set.\r\n   * * Note that this has no leading keyword identifying it as a ConvexClipPlaneSet.\r\n   */\r\n  public toJSON(): any {\r\n    const val: any = [];\r\n    for (const plane of this._planes) {\r\n      val.push(plane.toJSON());\r\n    }\r\n    return val;\r\n  }\r\n  /** Extract clip planes from a json array `[  clipPlane, clipPlane ]`.\r\n   * * Non-clipPlane members are ignored.\r\n   */\r\n  public static fromJSON(json: any, result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    result._planes.length = 0;\r\n    if (!Array.isArray(json))\r\n      return result;\r\n    for (const thisJson of json) {\r\n      const plane = ClipPlane.fromJSON(thisJson);\r\n      if (plane)\r\n        result._planes.push(plane);\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Return true if all members are almostEqual to corresponding members of other.  This includes identical order in array.\r\n   * @param other clip plane to compare\r\n   */\r\n  public isAlmostEqual(other: ConvexClipPlaneSet): boolean {\r\n    if (this._planes.length !== other._planes.length)\r\n      return false;\r\n    for (let i = 0; i < this._planes.length; i++)\r\n      if (!this._planes[i].isAlmostEqual(other._planes[i]))\r\n        return false;\r\n    return true;\r\n  }\r\n  /** create from an array of planes.\r\n   * * Each plane reference in the `planes` array is taken into the result.\r\n   * * The input array itself is NOT taken into the result.\r\n   */\r\n  public static createPlanes(planes: ClipPlane[], result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    for (const plane of planes)\r\n      result._planes.push(plane);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create new convex set using selected planes of a Range3d.\r\n   * @param range range with coordinates\r\n   * @param lowX true to clip at the low x plane\r\n   * @param highX true to clip at the high x plane\r\n   * @param lowY true to clip at the low y plane\r\n   * @param highY true to clip at the high z plane\r\n   * @param lowZ true to clip at the low z plane\r\n   * @param highZ true to clip at the high z plane\r\n   */\r\n  public static createRange3dPlanes(range: Range3d,\r\n    lowX: boolean = true, highX: boolean = true,\r\n    lowY: boolean = true, highY: boolean = true,\r\n    lowZ: boolean = true, highZ: boolean = true): ConvexClipPlaneSet {\r\n    const result = ConvexClipPlaneSet.createEmpty();\r\n\r\n    if (lowX)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(1, 0, 0, range.low.x, 0, 0)!);\r\n    if (highX)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(-1, 0, 0, range.high.x, 0, 0)!);\r\n\r\n    if (lowY)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 1, 0, 0, range.low.y, 0)!);\r\n    if (highY)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, -1, 0, 0, range.high.y, 0)!);\r\n\r\n    if (lowZ)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 0, 1, 0, 0, range.low.z)!);\r\n    if (highZ)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 0, -1, 0, 0, range.high.z)!);\r\n\r\n    return result;\r\n  }\r\n  /** create an empty `ConvexClipPlaneSet` */\r\n  public static createEmpty(result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    if (result) {\r\n      result._planes.length = 0;\r\n      return result;\r\n    }\r\n    return new ConvexClipPlaneSet();\r\n  }\r\n  /** negate all planes of the set. */\r\n  public negateAllPlanes(): void {\r\n    for (const plane of this._planes)\r\n      plane.negateInPlace();\r\n  }\r\n  /** Create a convex clip plane set that clips to `x0 <= x <= x1` and `y0 <= y <= y1`.\r\n   * * Note that there is no test for the usual ordering `x0 <= x1` or `y0 <= y1`.\r\n   *    * if the usual ordering is violated, the convex set is an empty set.\r\n   */\r\n  public static createXYBox(x0: number, y0: number, x1: number, y1: number, result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    result._planes.length = 0;\r\n    const clip0 = ClipPlane.createNormalAndDistance(Vector3d.create(-1, 0, 0), -x1, false, true);\r\n    const clip1 = ClipPlane.createNormalAndDistance(Vector3d.create(1, 0, 0), x0, false, true);\r\n    const clip2 = ClipPlane.createNormalAndDistance(Vector3d.create(0, -1, 0), -y1, false, true);\r\n    const clip3 = ClipPlane.createNormalAndDistance(Vector3d.create(0, 1, 0), y0, false, true);\r\n    if (clip0 && clip1 && clip2 && clip3) {\r\n      result._planes.push(clip0, clip1, clip2, clip3);\r\n    }\r\n    return result;\r\n  }\r\n  /** Create a convex set containing a half space for each edge between points of a polyline.\r\n   * * Caller is responsible for assuring the polyline is convex.\r\n   * @param points array of points.  Only xy parts are considered.\r\n   * @param interior array whose boolean value is used as both the `interior` and `invisible` bits of the plane for the succeeding segment.\r\n   * @param leftIsInside if true, the interior is \"to the left\" of the segments.  If false, interior is \"to the right\"\r\n   */\r\n  public static createXYPolyLine(points: Point3d[], interior: boolean[], leftIsInside: boolean, result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    result._planes.length = 0;\r\n    for (let i0 = 0; (i0 + 1) < points.length; i0++) {\r\n      const edgeVector: Vector3d = Vector3d.createStartEnd(points[i0], points[i0 + 1]);\r\n      const perp: Vector3d = edgeVector.unitPerpendicularXY();\r\n      perp.z = 0.0;\r\n\r\n      if (!leftIsInside)\r\n        perp.negate();\r\n\r\n      const perpNormalized = perp.normalize();\r\n      if (perpNormalized) {\r\n        const clip = ClipPlane.createNormalAndPoint(perp, points[i0], interior[i0], interior[i0]);\r\n        if (clip) { result._planes.push(clip); }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a convexClipPlaneSet with planes whose \"inside\" normal is to the left of each segment.\r\n   * @param points array of points.\r\n   */\r\n  public static createXYPolyLineInsideLeft(points: Point3d[], result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    result._planes.length = 0;\r\n    for (let i0 = 0; (i0 + 1) < points.length; i0++) {\r\n      const edgeVector: Vector3d = Vector3d.createStartEnd(points[i0], points[i0 + 1]);\r\n      const perp: Vector3d = edgeVector.unitPerpendicularXY();\r\n      perp.z = 0.0;\r\n\r\n      const perpNormalized = perp.normalize();\r\n      if (perpNormalized) {\r\n        const clip = ClipPlane.createNormalAndPoint(perp, points[i0], false, false);\r\n        if (clip) { result._planes.push(clip); }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * (re)set a plane and ConvexClipPlaneSet for a convex array, such as a convex facet used for xy clip.\r\n   * * The planeOfPolygon is (re)initialized with the normal from 3 points, but not otherwise referenced.\r\n   * * The ConvexClipPlaneSet is filled with outward normals of the facet edges as viewed to xy plane.\r\n   * @param points\r\n   * @param result\r\n   */\r\n  public static setPlaneAndXYLoopCCW(points: GrowableXYZArray, planeOfPolygon: ClipPlane, frustum: ConvexClipPlaneSet) {\r\n    let i0 = points.length - 1;\r\n    const n = points.length;\r\n    let x0 = points.getXAtUncheckedPointIndex(i0);\r\n    let y0 = points.getYAtUncheckedPointIndex(i0);\r\n    let x1, y1, nx, ny;\r\n    frustum._planes.length = 0;\r\n    const z0 = points.getZAtUncheckedPointIndex(i0);  // z for planes can stay fixed\r\n    const planeNormal = points.crossProductIndexIndexIndex(0, 2, 1)!;\r\n    ClipPlane.createNormalAndPointXYZXYZ(planeNormal.x, planeNormal.y, planeNormal.z, x0, y0, z0, false, false, planeOfPolygon);\r\n    if (planeNormal.normalizeInPlace()) {\r\n      for (let i1 = 0; i1 < n; i0 = i1, i1++ , x0 = x1, y0 = y1) {\r\n        x1 = points.getXAtUncheckedPointIndex(i1);\r\n        y1 = points.getYAtUncheckedPointIndex(i1);\r\n        nx = -(y1 - y0);\r\n        ny = x1 - x0;\r\n        const clipper = ClipPlane.createNormalAndPointXYZXYZ(nx, ny, 0, x1, y1, z0);\r\n        if (clipper)\r\n          frustum._planes.push(clipper);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Deep clone of all planes. */\r\n  public clone(result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    result._planes.length = 0;\r\n    for (const plane of this._planes)\r\n      result._planes.push(plane.clone());\r\n    return result;\r\n  }\r\n  /** Return the (reference to the) array of `ClipPlane` */\r\n  public get planes(): ClipPlane[] {\r\n    return this._planes;\r\n  }\r\n\r\n  /** Test if there is any intersection with a ray defined by origin and direction.\r\n   * * Optionally record the range (null or otherwise) in caller-allocated result.\r\n   * * If the ray is unbounded inside the clip, result can contain positive or negative \"Geometry.hugeCoordinate\" values\r\n   * * If no result is provide, there are no object allocations.\r\n   * @param result optional Range1d to receive parameters along the ray.\r\n   */\r\n  public hasIntersectionWithRay(ray: Ray3d, result?: Range1d): boolean {\r\n    // form low and high values in locals that do not require allocation.\r\n    // transfer to caller-supplied result at end\r\n    let t0 = -Geometry.hugeCoordinate;\r\n    let t1 = Geometry.hugeCoordinate;\r\n    if (result)\r\n      result.setNull();\r\n    for (const plane of this._planes) {\r\n      const vD = plane.velocity(ray.direction);\r\n      const vN = plane.altitude(ray.origin);\r\n\r\n      if (vD === 0.0) {\r\n        // Ray is parallel... No need to continue testing if outside halfspace.\r\n        if (vN < 0.0)\r\n          return false;   // and result is a null range.\r\n      } else {\r\n        const rayFraction = - vN / vD;\r\n        if (vD < 0.0) {\r\n          if (rayFraction < t1)\r\n            t1 = rayFraction;\r\n        } else {\r\n          if (rayFraction > t0)\r\n            t0 = rayFraction;\r\n        }\r\n      }\r\n    }\r\n    if (t1 < t0)\r\n      return false;   // and result is a null range.\r\n    if (result) {\r\n      result.extendX(t0);\r\n      result.extendX(t1);\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Multiply all the ClipPlanes DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   */\r\n  public multiplyPlanesByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    if (invert) {  // form inverse once here, reuse for all planes\r\n      const inverse = matrix.createInverse();\r\n      if (!inverse)\r\n        return false;\r\n      return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\r\n    }\r\n    for (const plane of this._planes) {\r\n      plane.multiplyPlaneByMatrix4d(matrix, false, transpose);\r\n    }\r\n    return true;\r\n  }\r\n  /** Return true if `point` satisfies `point.isPointInside` for all planes */\r\n  public isPointInside(point: Point3d): boolean {\r\n    for (const plane of this._planes) {\r\n      if (!plane.isPointInside(point))  // Defaults to strict inside check. Other clipping classes may use \"on or inside\" check for the \"on\" case\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Return true if `point` satisfies `point.isPointOnOrInside` for all planes */\r\n  public isPointOnOrInside(point: Point3d, tolerance: number): boolean {\r\n    const interiorTolerance = Math.abs(tolerance);   // Interior tolerance should always be positive. (TFS# 246598).\r\n    for (const plane of this._planes) {\r\n      if (!plane.isPointOnOrInside(point, (plane.interior ? interiorTolerance : tolerance)))\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Test if a sphere is completely inside the convex set.\r\n   * @param centerPoint center of sphere\r\n   * @param radius radius of sphere.\r\n   */\r\n  public isSphereInside(centerPoint: Point3d, radius: number): boolean {\r\n    const r1 = Math.abs(radius) + Geometry.smallMetricDistance;\r\n    for (const plane of this._planes) {\r\n      if (!plane.isPointOnOrInside(centerPoint, r1)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Find the parts of the line segment  (if any) that is within the convex clip volume.\r\n   * * The input fractional interval from fraction0 to fraction1 (increasing!!) is the active part to consider.\r\n   * * To clip to the usual bounded line segment, starts with fractions (0,1).\r\n   * If the clip volume is unbounded, the line interval may also be unbounded.\r\n   * * An unbounded line portion will have fraction coordinates positive or negative Number.MAX_VALUE.\r\n   * @param fraction0 fraction that is the initial lower fraction of the active interval. (e.g. 0.0 for bounded segment)\r\n   * @param fraction1 fraction that is the initial upper fraction of the active interval.  (e.g. 1.0 for bounded segment)\r\n   * @param pointA segment start (fraction 0)\r\n   * @param pointB segment end (fraction 1)\r\n   * @param announce function to be called to announce a fraction interval that is within the convex clip volume.\r\n   * @returns true if a segment was announced, false if entirely outside.\r\n   */\r\n  public announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: (fraction0: number, fraction1: number) => void): boolean {\r\n    let fraction: number | undefined;\r\n    if (f1 < f0)\r\n      return false;\r\n    for (const plane of this._planes) {\r\n      const hA = - plane.altitude(pointA);\r\n      const hB = - plane.altitude(pointB);\r\n      fraction = Geometry.safeDivideFraction(-hA, (hB - hA), 0.0);\r\n      if (fraction === undefined) {\r\n        // LIne parallel to the plane.  If positive, it is all OUT\r\n        if (hA > 0.0)\r\n          return false;\r\n      } else if (hB > hA) {    // STRICTLY moving outward\r\n        if (fraction < f0)\r\n          return false;\r\n        if (fraction < f1)\r\n          f1 = fraction;\r\n      } else if (hA > hB) { // STRICTLY moving inward\r\n        if (fraction > f1)\r\n          return false;\r\n        if (fraction > f0)\r\n          f0 = fraction;\r\n      } else {\r\n        // Strictly equal evaluations\r\n        if (hA > 0.0)\r\n          return false;\r\n      }\r\n    }\r\n    if (f1 >= f0) {\r\n      if (announce)\r\n        announce(f0, f1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private static _clipArcFractionArray = new GrowableFloat64Array();\r\n  /** Find fractional parts of the arc that are within this ClipPlaneSet, and announce each as\r\n   * * `announce(fraction, fraction, curve)`\r\n   */\r\n  public announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    const breaks = ConvexClipPlaneSet._clipArcFractionArray;\r\n    breaks.clear();\r\n    for (const clipPlane of this.planes) {\r\n      clipPlane.appendIntersectionRadians(arc, breaks);\r\n    }\r\n    arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);\r\n    return ClipUtilities.selectIntervals01(arc, breaks, this, announce);\r\n  }\r\n  /** Find the parts of the (unbounded) line segment  (if any) that is within the convex clip volume.\r\n   * @param pointA segment start (fraction 0)\r\n   * @param pointB segment end (fraction 1)\r\n   * @param announce function to be called to announce a fraction interval that is within the convex clip volume.\r\n   * @returns true if a segment was announced, false if entirely outside.\r\n   */\r\n  public clipUnboundedSegment(pointA: Point3d, pointB: Point3d, announce?: (fraction0: number, fraction1: number) => void): boolean {\r\n    return this.announceClippedSegmentIntervals(-Number.MAX_VALUE, Number.MAX_VALUE, pointA, pointB, announce);\r\n  }\r\n  /** transform each plane in place. */\r\n  public transformInPlace(transform: Transform) {\r\n    for (const plane of this._planes) {\r\n      plane.transformInPlace(transform);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clip a polygon to the inside of the convex set.\r\n   * * Results with 2 or fewer points are ignored.\r\n   * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.\r\n   * @param xyz input points.\r\n   * @param work work buffer\r\n   * @param tolerance tolerance for \"on plane\" decision.\r\n   */\r\n  public clipConvexPolygonInPlace(xyz: GrowableXYZArray, work: GrowableXYZArray, tolerance: number = Geometry.smallMetricDistance) {\r\n    for (const plane of this._planes) {\r\n      plane.clipConvexPolygonInPlace(xyz, work, true, tolerance);\r\n      if (xyz.length < 3)\r\n        return;\r\n    }\r\n  }\r\n\r\n  /** Returns 1, 2, or 3 based on whether point array is strongly inside, ambiguous, or strongly outside respectively.\r\n   * * This has a peculiar expected use case as a very fast pre-filter for more precise clipping.\r\n   * * The expected point set is for a polygon.\r\n   * * Hence any clipping will eventually have to consider the lines between the points.\r\n   * * This method looks for the special case of a single clip plane that has all the points outside.\r\n   * * In this case the whole polygon must be outside.\r\n   * * Note that this does not detect a polygon that is outside but \"crosses a corner\" -- it is mixed with respect to\r\n   *     multiple planes.\r\n   */\r\n  public classifyPointContainment(points: Point3d[], onIsOutside: boolean): ClipPlaneContainment {\r\n    let allInside = true;\r\n    const onTolerance = onIsOutside ? 1.0e-8 : -1.0e-8;\r\n    const interiorTolerance = 1.0e-8;   // Interior tolerance should always be positive\r\n\r\n    for (const plane of this._planes) {\r\n      let nOutside = 0;\r\n      for (const point of points) {\r\n        if (plane.altitude(point) < (plane.interior ? interiorTolerance : onTolerance)) {\r\n          nOutside++;\r\n          allInside = false;\r\n        }\r\n      }\r\n\r\n      if (nOutside === points.length)\r\n        return ClipPlaneContainment.StronglyOutside;\r\n    }\r\n\r\n    return allInside ? ClipPlaneContainment.StronglyInside : ClipPlaneContainment.Ambiguous;\r\n  }\r\n\r\n  /**\r\n   * * Create a convex clip set for a polygon swept with possible tilt angle.\r\n   * * planes are constructed by ClipPlane.createEdgeAndUpVector, using successive points from the array.\r\n   * * If the first and last points match, the polygon area is checked.  If the area is negative, points are used in reverse order.\r\n   * * If first and last points do not match, points are used in order given\r\n   * @param points polygon points. (Closure point optional)\r\n   * @param upVector primary sweep direction, as applied by ClipPlane.createEdgeAndUpVector\r\n   * @param tiltAngle angle to tilt sweep planes away from the sweep direction.\r\n   */\r\n  public static createSweptPolyline(points: Point3d[], upVector: Vector3d, tiltAngle: Angle): ConvexClipPlaneSet | undefined {\r\n    const result = ConvexClipPlaneSet.createEmpty();\r\n    let reverse = false;\r\n    if (points.length > 3 && points[0].isAlmostEqual(points[points.length - 1])) {\r\n      const polygonNormal: Vector3d = PolygonOps.areaNormal(points);\r\n      const normalDot = polygonNormal.dotProduct(upVector);\r\n      if (normalDot > 0.0)\r\n        reverse = true;\r\n    }\r\n    for (let i = 0; (i + 1) < points.length; i++) {\r\n      if (reverse) {\r\n        const toAdd = ClipPlane.createEdgeAndUpVector(points[i + 1], points[i], upVector, tiltAngle);\r\n        if (toAdd) {   // clipPlane creation could result in undefined\r\n          result.addPlaneToConvexSet(toAdd);\r\n        } else {\r\n          return undefined;\r\n        }\r\n      } else {\r\n        const toAdd = ClipPlane.createEdgeAndUpVector(points[i], points[i + 1], upVector, tiltAngle);\r\n        if (toAdd) {   // clipPlane creation could result in undefined\r\n          result.addPlaneToConvexSet(toAdd);\r\n        } else {\r\n          return undefined;\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Add a plane to the convex set.\r\n   * @param plane plane to add\r\n   */\r\n  public addPlaneToConvexSet(plane: ClipPlane | undefined) {\r\n    if (plane)\r\n      this._planes.push(plane);\r\n  }\r\n  /**\r\n   * test many points.  Distribute them to arrays depending on in/out result.\r\n   * @param points points to test\r\n   * @param inOrOn points that are in or on the set\r\n   * @param out points that are out.\r\n   */\r\n  public clipPointsOnOrInside(points: Point3d[], inOrOn: Point3d[], out: Point3d[]) {\r\n    inOrOn.length = 0;\r\n    out.length = 0;\r\n    for (const xyz of points) {\r\n      if (this.isPointOnOrInside(xyz, 0.0)) {\r\n        inOrOn.push(xyz);\r\n      } else {\r\n        out.push(xyz);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Clip a polygon to the planes of the clip plane set.\r\n   * * For a convex input polygon, the output is another convex polygon.\r\n   * * For a non-convex input, the output may have double-back edges along plane intersections.  This is still a valid clip in a parity sense.\r\n   * * The containingPlane parameter allows callers within ConvexClipPlane set to bypass planes known to contain the polygon\r\n   * @param input input polygon, usually convex.\r\n   * @param output output polygon\r\n   * @param work work array.\r\n   * @param containingPlane if this plane is found in the convex set, it is NOT applied.\r\n   */\r\n  public polygonClip(input: GrowableXYZArray | Point3d[], output: GrowableXYZArray, work: GrowableXYZArray, planeToSkip?: ClipPlane) {\r\n    if (input instanceof GrowableXYZArray)\r\n      input.clone(output);\r\n    else\r\n      GrowableXYZArray.create(input, output);\r\n\r\n    for (const plane of this._planes) {\r\n      if (planeToSkip === plane)\r\n        continue;\r\n      if (output.length === 0)\r\n        break;\r\n      plane.clipConvexPolygonInPlace(output, work);\r\n    }\r\n  }\r\n  /**\r\n   * * Define new planes in this ConvexClipPlaneSet so it clips to the inside of a polygon.\r\n   * * always create planes for the swept edges of the polygon\r\n   * * optionally (with nonzero sideSelect) create a cap plane using the polygon normal.\r\n   * @param points Points of a bounding polygon\r\n   * @param sweepDirection direction to sweep.\r\n   * @param sideSelect 0 to have no cap polygon, 1 if the sweep vector side is in, -1 if sweep vector side is out.\r\n   */\r\n  public reloadSweptPolygon(points: Point3d[], sweepDirection: Vector3d, sideSelect: number): number {\r\n    this._planes.length = 0;\r\n    const n = points.length;\r\n    if (n <= 2)\r\n      return 0;\r\n\r\n    const planeNormal: Vector3d = PolygonOps.areaNormal(points);\r\n    const isCCW = sweepDirection.dotProduct(planeNormal) > 0.0;\r\n\r\n    const delta = isCCW ? 1 : n - 1;\r\n    for (let i = 0; i < n; i++) {\r\n      const i1 = (i + delta) % n;\r\n      const xyz0: Point3d = points[i];\r\n      const xyz1: Point3d = points[i1];\r\n      if (xyz0.isAlmostEqual(xyz1))\r\n        continue;\r\n      const edgeVector: Vector3d = Vector3d.createStartEnd(xyz0, xyz1);\r\n      const inwardNormal: Vector3d = Vector3d.createCrossProduct(sweepDirection.x, sweepDirection.y, sweepDirection.z,\r\n        edgeVector.x, edgeVector.y, edgeVector.z);\r\n      const inwardNormalNormalized = inwardNormal.normalize();\r\n      let distance;\r\n      if (inwardNormalNormalized) { // Should never fail... simply a check due to the format of the normalize function return\r\n        distance = inwardNormalNormalized.dotProduct(xyz0);\r\n        const clipToAdd = ClipPlane.createNormalAndDistance(inwardNormalNormalized, distance, false, false);\r\n        if (clipToAdd) { this._planes.push(clipToAdd); }  // clipPlane creation could result in undefined\r\n      }\r\n    }\r\n    if (sideSelect !== 0.0) {\r\n      let planeNormalNormalized = planeNormal.normalize();\r\n      if (planeNormalNormalized) { // Again.. should never fail\r\n        const a = sweepDirection.dotProduct(planeNormalNormalized) * sideSelect;\r\n        if (a < 0.0)\r\n          planeNormalNormalized = planeNormalNormalized.negate();\r\n        const xyz0: Point3d = points[0];\r\n        const distance = planeNormalNormalized.dotProduct(xyz0);\r\n        const clipToAdd = ClipPlane.createNormalAndDistance(planeNormalNormalized, distance, false, false);\r\n        if (clipToAdd) { this._planes.push(clipToAdd); }  // clipPlane creation could result in undefined\r\n      }\r\n    }\r\n    return isCCW ? 1 : -1;\r\n  }\r\n\r\n  /**\r\n   * Compute intersections among all combinations of 3 planes in the convex set.\r\n   * * optionally throw out points that are not in the set.\r\n   * * optionally push the points in the caller-supplied point array.\r\n   * * optionally extend a caller supplied range.\r\n   * * In the common case where the convex set is (a) a slab or (b) a view frustum, there will be 8 points and the range is the range of the convex set.\r\n   * * If the convex set is unbounded, the range only contains the range of the accepted (corner) points, and the range is not a representative of the \"range of all points in the set\" .\r\n   * @param transform (optional) transform to apply to the points.\r\n   * @param points (optional) array to which computed points are to be added.\r\n   * @param range (optional) range to be extended by the computed points\r\n   * @param transform (optional) transform to apply to the accepted points.\r\n   * @param testContainment if true, test each point to see if it is within the convex set.  (Send false if confident that the convex set is rectilinear set such as a slab.  Send true if chiseled corners are possible)\r\n   * @returns number of points.\r\n   */\r\n  public computePlanePlanePlaneIntersections(points: Point3d[] | undefined, rangeToExtend: Range3d | undefined, transform?: Transform, testContainment: boolean = true): number {\r\n\r\n    const normalRows = Matrix3d.createIdentity();\r\n    const allPlanes = this._planes;\r\n    const n = allPlanes.length;\r\n    let numPoints = 0;    // explicitly count points -- can't wait to end for points.length because it may be an optional output.\r\n    for (let i = 0; i < n; i++) {\r\n      for (let j = i + 1; j < n; j++)\r\n        for (let k = j + 1; k < n; k++) {\r\n          Matrix3d.createRowValues(\r\n            allPlanes[i].inwardNormalRef.x, allPlanes[i].inwardNormalRef.y, allPlanes[i].inwardNormalRef.z,\r\n            allPlanes[j].inwardNormalRef.x, allPlanes[j].inwardNormalRef.y, allPlanes[j].inwardNormalRef.z,\r\n            allPlanes[k].inwardNormalRef.x, allPlanes[k].inwardNormalRef.y, allPlanes[k].inwardNormalRef.z,\r\n            normalRows);\r\n          if (normalRows.computeCachedInverse(false)) {\r\n            const xyz = normalRows.multiplyInverseXYZAsPoint3d(allPlanes[i].distance, allPlanes[j].distance, allPlanes[k].distance)!;\r\n            if (!testContainment || this.isPointOnOrInside(xyz, Geometry.smallMetricDistance)) {\r\n              numPoints++;\r\n              if (transform)\r\n                transform.multiplyPoint3d(xyz, xyz);\r\n              if (points)\r\n                points.push(xyz);\r\n              if (rangeToExtend)\r\n                rangeToExtend.extendPoint(xyz);\r\n            }\r\n          }\r\n        }\r\n    }\r\n    return numPoints;\r\n  }\r\n  /**\r\n   * Set the `invisible` property on each plane of the convex set.\r\n   * @param invisible value to store\r\n   */\r\n  public setInvisible(invisible: boolean) {\r\n    for (const plane of this._planes) {\r\n      plane.setInvisible(invisible);\r\n    }\r\n  }\r\n  /**\r\n   * Add planes for z-direction clip between low and high z levels.\r\n   * @param invisible value to apply to the `invisible` bit for the new planes\r\n   * @param zLow low z value.  The plane clips out points with z below this.\r\n   * @param zHigh high z value.  The plane clips out points with z above this.\r\n   */\r\n  public addZClipPlanes(invisible: boolean, zLow?: number, zHigh?: number) {\r\n    if (zLow !== undefined)\r\n      this._planes.push(ClipPlane.createNormalAndDistance(Vector3d.create(0, 0, 1), zLow, invisible)!);\r\n    if (zHigh !== undefined)\r\n      this._planes.push(ClipPlane.createNormalAndDistance(Vector3d.create(0, 0, -1), -zHigh, invisible)!);\r\n  }\r\n\r\n  // FUNCTIONS SKIPPED DUE TO BSPLINES, VU, OR NON-USAGE IN NATIVE CODE----------------------------------------------------------------\r\n\r\n  // Uses bsplines... skipping for now:\r\n  // public convexAppendIntervalsFromBspline();\r\n\r\n  // Uses pushing and clearing from/to a cache and added functionality for arrays. . . skipping for now\r\n  // public convexPolygonClipInsideOutside(input: Point3d[], inside: Point3d[], outside: Point3d[], work1: Point3d[], work2: Point3d[],\r\n  // clearOutside: boolean, distanceTolerance: number)\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module CartesianGeometry */\r\n\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { Range3d, Range1d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { ClipPlaneContainment, Clipper, ClipUtilities } from \"./ClipUtils\";\r\nimport { AnnounceNumberNumberCurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n\r\n/**\r\n * A collection of ConvexClipPlaneSets.\r\n * * A point is \"in\" the clip plane set if it is \"in\" one or more of  the ConvexClipPlaneSet\r\n * * Hence the boolean logic is that the ClipPlaneSet is a UNION of its constituents.\r\n * @public\r\n */\r\nexport class UnionOfConvexClipPlaneSets implements Clipper {\r\n  private _convexSets: ConvexClipPlaneSet[];\r\n  /** (property accessor)  Return the (reference to the) array of `ConvexClipPlaneSet` */\r\n  public get convexSets(): ConvexClipPlaneSet[] { return this._convexSets; }\r\n\r\n  private constructor() {\r\n    this._convexSets = [];\r\n  }\r\n  /** Return an array with the `toJSON` form of each  `ConvexClipPlaneSet` */\r\n  public toJSON(): any {\r\n    const val: any = [];\r\n    for (const convex of this._convexSets) {\r\n      val.push(convex.toJSON());\r\n    }\r\n    return val;\r\n  }\r\n  /** Convert json `UnionOfConvexClipPlaneSets`, using `setFromJSON`. */\r\n  public static fromJSON(json: any, result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets {\r\n    result = result ? result : new UnionOfConvexClipPlaneSets();\r\n    result._convexSets.length = 0;\r\n    if (!Array.isArray(json))\r\n      return result;\r\n    for (const thisJson of json) {\r\n      result._convexSets.push(ConvexClipPlaneSet.fromJSON(thisJson));\r\n    }\r\n    return result;\r\n  }\r\n  /** Create a `UnionOfConvexClipPlaneSets` with no members. */\r\n  public static createEmpty(result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets {\r\n    if (result) {\r\n      result._convexSets.length = 0;\r\n      return result;\r\n    }\r\n    return new UnionOfConvexClipPlaneSets();\r\n  }\r\n  /**\r\n   * Return true if all member convex sets are almostEqual to corresponding members of other.  This includes identical order in array.\r\n   * @param other clip plane to compare\r\n   */\r\n  public isAlmostEqual(other: UnionOfConvexClipPlaneSets): boolean {\r\n    if (this._convexSets.length !== other._convexSets.length)\r\n      return false;\r\n    for (let i = 0; i < this._convexSets.length; i++)\r\n      if (!this._convexSets[i].isAlmostEqual(other._convexSets[i]))\r\n        return false;\r\n    return true;\r\n  }\r\n  /** Create a `UnionOfConvexClipPlaneSets` with given `ConvexClipPlaneSet` members */\r\n  public static createConvexSets(convexSets: ConvexClipPlaneSet[], result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets {\r\n    result = result ? result : new UnionOfConvexClipPlaneSets();\r\n    for (const set of convexSets)\r\n      result._convexSets.push(set);\r\n    return result;\r\n  }\r\n  /** return a deep copy. */\r\n  public clone(result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets {\r\n    result = result ? result : new UnionOfConvexClipPlaneSets();\r\n    result._convexSets.length = 0;\r\n    for (const convexSet of this._convexSets)\r\n      result._convexSets.push(convexSet.clone());\r\n    return result;\r\n  }\r\n  /** Append `toAdd` to the array of `ConvexClipPlaneSet` */\r\n  public addConvexSet(toAdd: ConvexClipPlaneSet) {\r\n    this._convexSets.push(toAdd);\r\n  }\r\n\r\n  /** Test if there is any intersection with a ray defined by origin and direction.\r\n   * * Optionally record the range (null or otherwise) in caller-allocated result.\r\n   * * If the ray is unbounded inside the clip, result can contain positive or negative \"Geometry.hugeCoordinate\" values\r\n   * * If no result is provide, there are no object allocations.\r\n   * @param maximalRange optional Range1d to receive parameters along the ray.\r\n   */\r\n  public hasIntersectionWithRay(ray: Ray3d, maximalRange?: Range1d): boolean {\r\n    if (maximalRange === undefined) {\r\n      // if complete result is not requested, return after any hit.\r\n      for (const planeSet of this._convexSets) {\r\n        if (planeSet.hasIntersectionWithRay(ray))\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n    maximalRange.setNull();\r\n    const rangeA = Range1d.createNull();\r\n    for (const planeSet of this._convexSets) {\r\n      if (planeSet.hasIntersectionWithRay(ray, rangeA))\r\n        maximalRange.extendRange(rangeA);\r\n    }\r\n    return !maximalRange.isNull;\r\n  }\r\n\r\n  /** Return true if true is returned for any contained convex set returns true for `convexSet.isPointInside (point, tolerance)`  */\r\n  public isPointInside(point: Point3d): boolean {\r\n    for (const convexSet of this._convexSets) {\r\n      if (convexSet.isPointInside(point)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Return true if true is returned for any contained convex set returns true for `convexSet.isPointOnOrInside (point, tolerance)`  */\r\n  public isPointOnOrInside(point: Point3d, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    for (const convexSet of this._convexSets) {\r\n      if (convexSet.isPointOnOrInside(point, tolerance))\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Return true if true is returned for any contained convex set returns true for `convexSet.isSphereOnOrInside (point, tolerance)`  */\r\n  public isSphereInside(point: Point3d, radius: number) {\r\n    for (const convexSet of this._convexSets) {\r\n      if (convexSet.isSphereInside(point, radius))\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** test if any part of a line segment is within the volume */\r\n  public isAnyPointInOrOnFromSegment(segment: LineSegment3d): boolean {\r\n    for (const convexSet of this._convexSets) {\r\n      if (convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref))\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Intervals must be Segment1d array, as there may be multiple intervals along segment that pass through set regions,\r\n  // and so splitting the intervals into segments aids in better organization\r\n  /** Returns the fractions of the segment that pass through the set region, as 1 dimensional pieces */\r\n  public appendIntervalsFromSegment(segment: LineSegment3d, intervals: Segment1d[]) {\r\n    for (const convexSet of this._convexSets) {\r\n      convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref,\r\n        (fraction0: number, fraction1: number) =>\r\n          intervals.push(Segment1d.create(fraction0, fraction1)));\r\n    }\r\n  }\r\n  /** apply `transform` to all the ConvexClipPlaneSet's */\r\n  public transformInPlace(transform: Transform) {\r\n    for (const convexSet of this._convexSets) {\r\n      convexSet.transformInPlace(transform);\r\n    }\r\n  }\r\n\r\n  /** Returns 1, 2, or 3 based on whether point is strongly inside, ambiguous, or strongly outside respectively */\r\n  public classifyPointContainment(points: Point3d[], onIsOutside: boolean): number {\r\n    for (const convexSet of this._convexSets) {\r\n      const thisStatus = convexSet.classifyPointContainment(points, onIsOutside);\r\n      if (thisStatus !== ClipPlaneContainment.StronglyOutside)\r\n        return thisStatus;\r\n    }\r\n    return ClipPlaneContainment.StronglyOutside;\r\n  }\r\n\r\n  /** Clip a polygon using this ClipPlaneSet, returning new polygon boundaries. Note that each polygon may lie next to the previous, or be disconnected. */\r\n  public polygonClip(input: GrowableXYZArray | Point3d[], output: GrowableXYZArray[]) {\r\n    output.length = 0;\r\n    if (Array.isArray(input))\r\n      input = GrowableXYZArray.create(input);\r\n    const work = new GrowableXYZArray();\r\n    for (const convexSet of this._convexSets) {\r\n      const convexSetOutput = new GrowableXYZArray();\r\n      convexSet.polygonClip(input, convexSetOutput, work);\r\n      if (convexSetOutput.length !== 0)\r\n        output.push(convexSetOutput);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * * announce clipSegment() for each convexSet in this ClipPlaneSet.\r\n   * * all clipPlaneSets are inspected\r\n   * * announced intervals are for each individual clipPlaneSet -- adjacent intervals are not consolidated.\r\n   * @param f0 active interval start.\r\n   * @param f1 active interval end\r\n   * @param pointA line segment start\r\n   * @param pointB line segment end\r\n   * @param announce function to announce interval.\r\n   * @returns Return true if any announcements are made.\r\n   */\r\n  public announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: (fraction0: number, fraction1: number) => void): boolean {\r\n    let numAnnounce = 0;\r\n    for (const convexSet of this._convexSets) {\r\n      if (convexSet.announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce))\r\n        numAnnounce++;\r\n    }\r\n    return numAnnounce > 0;\r\n  }\r\n\r\n  private static _clipArcFractionArray = new GrowableFloat64Array();\r\n  /** Find parts of an arc that are inside any member clipper.\r\n   * Announce each with `announce(startFraction, endFraction, this)`\r\n   */\r\n  public announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    const breaks = UnionOfConvexClipPlaneSets._clipArcFractionArray;\r\n    breaks.clear();\r\n    for (const convexSet of this._convexSets) {\r\n      for (const clipPlane of convexSet.planes) {\r\n        clipPlane.appendIntersectionRadians(arc, breaks);\r\n      }\r\n    }\r\n    arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);\r\n    return ClipUtilities.selectIntervals01(arc, breaks, this, announce);\r\n  }\r\n\r\n  /**\r\n   * Collect the output from computePlanePlanePlaneIntersections in all the contained convex sets.\r\n   *\r\n   * @param transform (optional) transform to apply to the points.\r\n   * @param points (optional) array to which computed points are to be added.\r\n   * @param range (optional) range to be extended by the computed points\r\n   * @param transform (optional) transform to apply to the accepted points.\r\n   * @param testContainment if true, test each point to see if it is within the convex set.  (Send false if confident that the convex set is rectilinear set such as a slab.  Send true if chiseled corners are possible)\r\n   * @returns number of points.\r\n   */\r\n  public computePlanePlanePlaneIntersectionsInAllConvexSets(points: Point3d[] | undefined, rangeToExtend: Range3d | undefined, transform?: Transform, testContainment: boolean = true): number {\r\n    let n = 0;\r\n    for (const convexSet of this._convexSets) {\r\n      n += convexSet.computePlanePlanePlaneIntersections(points, rangeToExtend, transform, testContainment);\r\n    }\r\n    return n;\r\n  }\r\n  /**\r\n   * Multiply all ClipPlanes DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   */\r\n  public multiplyPlanesByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    if (invert) {  // form inverse once here, reuse for all planes\r\n      const inverse = matrix.createInverse();\r\n      if (!inverse)\r\n        return false;\r\n      return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\r\n    }\r\n    // (no inversion -- no failures possible)\r\n    for (const convexSet of this._convexSets) {\r\n      convexSet.multiplyPlanesByMatrix4d(matrix, false, transpose);\r\n    }\r\n    return true;\r\n  }\r\n  /** Recursively call `setInvisible` on all member convex sets. */\r\n  public setInvisible(invisible: boolean) {\r\n    for (const convexSet of this._convexSets) {\r\n      convexSet.setInvisible(invisible);\r\n    }\r\n  }\r\n  /** add convex sets that accept points below `zLow` and above `zHigh` */\r\n  public addOutsideZClipSets(invisible: boolean, zLow?: number, zHigh?: number) {\r\n    if (zLow) {\r\n      const convexSet = ConvexClipPlaneSet.createEmpty();\r\n      convexSet.addZClipPlanes(invisible, zLow);\r\n      this._convexSets.push(convexSet);\r\n    }\r\n    if (zHigh) {\r\n      const convexSet = ConvexClipPlaneSet.createEmpty();\r\n      convexSet.addZClipPlanes(invisible, undefined, zHigh);\r\n      this._convexSets.push(convexSet);\r\n    }\r\n  }\r\n\r\n  /* FUNCTIONS SKIPPED DUE TO BSPLINES, VU, OR NON-USAGE IN NATIVE CODE----------------------------------------------------------------\r\n\r\n  Involves vu: skipping for now...\r\n    public fromSweptPolygon(points: Point3d[], directions: Vector3d[]): ClipPlaneSet;\r\n    public parseConcavePolygonPlanes(...)\r\n\r\n  Uses bsplines... skipping for now:\r\n    public appendIntervalsClipPlaneSetFromCurve();\r\n\r\n  Uses bsplines... skipping for now:\r\n    public isAnyPointInOrOnFrom();\r\n\r\n  Skipped fromSweptPolygon(...), which is overloaded function from first, due to presence of vu\r\n    public fromSweptPolygon(points: Point3d[], directions: Vector3d[], shapes: Point3d[])\r\n  */\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry, AxisOrder, BeJSONFunctions, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { TrigPolynomial, SmallSystem } from \"../numerics/Polynomials\";\r\nimport { XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { CurvePrimitive, AnnounceNumberNumberCurvePrimitive } from \"./CurvePrimitive\";\r\nimport { VariantCurveExtendParameter, CurveExtendOptions } from \"./CurveExtendMode\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurveLocationDetail, CurveSearchStatus, CurveIntervalRole } from \"./CurveLocationDetail\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { Clipper } from \"../clipping/ClipUtils\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\n\r\n/* tslint:disable:variable-name no-empty*/\r\n/**\r\n * Compact vector form of an elliptic arc defined by center, vectors for angle coordinates 0 and 90 degrees, and sweep.\r\n * * See `Arc3d` for further details of the parameterization and meaning of the vectors.\r\n * @public\r\n */\r\nexport interface ArcVectors {\r\n  /** center point of arc. */\r\n  center: Point3d;\r\n  /** vector to point at angle 0 in parameter space */\r\n  vector0: Vector3d;\r\n  /** vector to point at angle 90 degrees in parameter space */\r\n  vector90: Vector3d;\r\n  /** angle swept by the subset of the complete arc. */\r\n  sweep: AngleSweep;\r\n}\r\n/**\r\n * Circular or elliptic arc.\r\n *\r\n * * The angle to point equation is:\r\n *\r\n * **  `X = center + cos(theta) * vector0 + sin(theta) * vector90`\r\n * * When the two vectors are perpendicular and have equal length, it is a true circle.\r\n * * Non-perpendicular vectors are always elliptic.\r\n * *  vectors of unequal length are always elliptic.\r\n * * To create an ellipse in the common \"major and minor axis\" form of an ellipse:\r\n * ** vector0 is the vector from the center to the major axis extreme.\r\n * ** vector90 is the vector from the center to the minor axis extreme.\r\n * ** note the constructing the vectors to the extreme points makes them perpendicular.\r\n * *  The method toScaledMatrix3d () can be called to convert the unrestricted vector0,vector90 to perpendicular form.\r\n * * The unrestricted form is much easier to work with for common calculations -- stroking, projection to 2d, intersection with plane.\r\n * @public\r\n */\r\nexport class Arc3d extends CurvePrimitive implements BeJSONFunctions {\r\n  /** String name for schema properties */\r\n  public readonly curvePrimitiveType = \"arc\";\r\n\r\n  /**\r\n   * Test if this and other are both instances of Arc3d.\r\n   */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof Arc3d; }\r\n  private _center: Point3d;\r\n  private _matrix: Matrix3d; // columns are [vector0, vector90, unitNormal]\r\n  private _sweep: AngleSweep; // sweep limits.\r\n  private static _workPointA = Point3d.create();\r\n  private static _workPointB = Point3d.create();\r\n  /**\r\n   * read property for (clone of) center\r\n   */\r\n  public get center(): Point3d { return this._center.clone(); }\r\n  /**\r\n   * read property for (clone of) vector0\r\n   */\r\n  public get vector0(): Vector3d { return this._matrix.columnX(); }\r\n  /**\r\n   * read property for (clone of) vector90\r\n   */\r\n  public get vector90(): Vector3d { return this._matrix.columnY(); }\r\n  /**\r\n   * read property for (clone of) plane normal, with arbitrary length.\r\n   */\r\n  public get perpendicularVector(): Vector3d { return this._matrix.columnZ(); }\r\n  /**\r\n   * read property for (clone of!) matrix of vector0, vector90, unit normal\r\n   */\r\n  public get matrix(): Matrix3d { return this._matrix.clone(); }\r\n  /**\r\n   * read property for (reference to !!) matrix of vector0, vector90, unit normal\r\n   */\r\n  public get matrixRef(): Matrix3d { return this._matrix; }\r\n  /** property getter for the angle sweep */\r\n  public get sweep(): AngleSweep { return this._sweep; }\r\n  /** property setter for angle sweep */\r\n  public set sweep(value: AngleSweep) { this._sweep.setFrom(value); }\r\n  /**\r\n   * An Arc3d extends along its complete elliptic arc\r\n   */\r\n  public get isExtensibleFractionSpace(): boolean { return true; }\r\n\r\n  // constructor copies the pointers !!!\r\n  private constructor(center: Point3d, matrix: Matrix3d, sweep: AngleSweep) {\r\n    super();\r\n    this._center = center;\r\n    this._matrix = matrix;\r\n    this._sweep = sweep;\r\n  }\r\n  /**\r\n   *  Return a clone of the arc, with transform applied\r\n   * @param transform\r\n   */\r\n  public cloneTransformed(transform: Transform): CurvePrimitive {  // we know tryTransformInPlace succeeds.\r\n    const c = this.clone();\r\n    c.tryTransformInPlace(transform);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Redefine the arc with (captured references to) given data.\r\n   * @param center arc center\r\n   * @param matrix matrix with columns vector0, vector 90, and their unit cross product\r\n   * @param sweep angle sweep\r\n   */\r\n  public setRefs(center: Point3d, matrix: Matrix3d, sweep: AngleSweep) {\r\n    this._center = center;\r\n    this._matrix = matrix;\r\n    this._sweep = sweep;\r\n  }\r\n  /**\r\n   * Redefine the arc with (clones of) given data.\r\n   * @param center arc center\r\n   * @param matrix matrix with columns vector0, vector 90, and their unit cross product\r\n   * @param sweep angle sweep\r\n   */\r\n  public set(center: Point3d, matrix: Matrix3d, sweep: AngleSweep | undefined) {\r\n    this.setRefs(center.clone(), matrix.clone(), sweep ? sweep.clone() : AngleSweep.create360());\r\n  }\r\n  /**\r\n   * Copy center, matrix, and sweep from other Arc3d.\r\n   */\r\n  public setFrom(other: Arc3d) {\r\n    this._center.setFrom(other._center);\r\n    this._matrix.setFrom(other._matrix);\r\n    this._sweep.setFrom(other._sweep);\r\n  }\r\n  /** Return a clone of this arc. */\r\n  public clone(): Arc3d {\r\n    return new Arc3d(this._center.clone(), this._matrix.clone(), this._sweep.clone());\r\n  }\r\n  /**\r\n   * Create an arc, capturing references to center, matrix and sweep.\r\n   * @param center center point\r\n   * @param matrix matrix with columns vector0, vector90, and unit cross product\r\n   * @param sweep sweep limits\r\n   * @param result optional preallocated result.\r\n   */\r\n  public static createRefs(center: Point3d, matrix: Matrix3d, sweep: AngleSweep, result?: Arc3d): Arc3d {\r\n    if (result) {\r\n      result.setRefs(center, matrix, sweep);\r\n      return result;\r\n    }\r\n    return new Arc3d(center, matrix, sweep);\r\n  }\r\n  /**\r\n   * Create an arc from center, x column to be scaled, and y column to be scaled.\r\n   * @param center center of ellipse\r\n   * @param matrix matrix whose x and y columns are unit vectors to be scaled by radius0 and radius90\r\n   * @param radius0 radius in x direction.\r\n   * @param radius90 radius in y direction.\r\n   * @param sweep sweep limits\r\n   * @param result optional preallocated result.\r\n   */\r\n  public static createScaledXYColumns(center: Point3d, matrix: Matrix3d, radius0: number, radius90: number, sweep?: AngleSweep, result?: Arc3d): Arc3d {\r\n    const vector0 = matrix.columnX();\r\n    const vector90 = matrix.columnY();\r\n    return Arc3d.create(center, vector0.scale(radius0, vector0), vector90.scale(radius90, vector90), sweep, result);\r\n  }\r\n  /**\r\n   * Create a (full circular) arc from center, normal and radius\r\n   * @param center center of ellipse\r\n   * @param normal normal vector\r\n   * @param radius radius in x direction.\r\n   * @param result optional preallocated result.\r\n   */\r\n  public static createCenterNormalRadius(center: Point3d, normal: Vector3d, radius: number, result?: Arc3d): Arc3d {\r\n    const frame = Matrix3d.createRigidHeadsUp(normal, AxisOrder.ZYX);\r\n    return Arc3d.createScaledXYColumns(center, frame, radius, radius, undefined, result);\r\n  }\r\n\r\n  /**\r\n   * Creat an arc by center with vectors to points at 0 and 90 degrees in parameter space.\r\n   * @param center arc center\r\n   * @param vector0 vector to 0 degrees (commonly major axis)\r\n   * @param vector90 vector to 90 degree point (commonly minor axis)\r\n   * @param sweep sweep limits\r\n   * @param result optional preallocated result\r\n   */\r\n  public static create(center: Point3d, vector0: Vector3d, vector90: Vector3d, sweep?: AngleSweep, result?: Arc3d): Arc3d {\r\n    const normal = vector0.unitCrossProductWithDefault(vector90, 0, 0, 0); // normal will be 000 for degenerate case ! !!\r\n    const matrix = Matrix3d.createColumns(vector0, vector90, normal);\r\n    return Arc3d.createRefs(center.clone(), matrix, sweep ? sweep.clone() : AngleSweep.create360(), result);\r\n  }\r\n  /** Return a clone of this arc, projected to given z value.\r\n   * * If `z` is omitted, the clone is at the z of the center.\r\n   * * Note that projection to fixed z can change circle into ellipse (and (rarely) ellipse to circle)\r\n   */\r\n  public cloneAtZ(z?: number): Arc3d {\r\n    if (z === undefined)\r\n      z = this._center.z;\r\n    return Arc3d.createXYZXYZXYZ(\r\n      this._center.x, this._center.y, this._center.z,\r\n      this._matrix.coffs[0], this._matrix.coffs[3], z,\r\n      this._matrix.coffs[1], this._matrix.coffs[4], z,\r\n      this._sweep);\r\n  }\r\n\r\n  /**\r\n   * Create an arc by center (cx,cy,xz) with vectors (ux,uy,uz) and (vx,vy,vz) to points at 0 and 90 degrees in parameter space.\r\n   * @param result optional preallocated result\r\n   */\r\n  public static createXYZXYZXYZ(cx: number, cy: number, cz: number, ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, sweep?: AngleSweep, result?: Arc3d): Arc3d {\r\n    return Arc3d.create(Point3d.create(cx, cy, cz), Vector3d.create(ux, uy, uz), Vector3d.create(vx, vy, vz), sweep, result);\r\n  }\r\n\r\n  /**\r\n   * Return a quick estimate of the eccentricity of the ellipse.\r\n   * * The estimator is the cross magnitude of the product of vectors U and V, divided by square of the larger magnitude\r\n   * * for typical Arc3d with perpendicular UV, this is exactly the small axis divided by large.\r\n   * * note that the eccentricity is AT MOST ONE.\r\n   */\r\n  public quickEccentricity(): number {\r\n    const magX = this._matrix.columnXMagnitude();\r\n    const magY = this._matrix.columnYMagnitude();\r\n    const jacobian = this._matrix.columnXYCrossProductMagnitude();\r\n    const largeAxis = Geometry.maxXY(magX, magY);\r\n    return jacobian / (largeAxis * largeAxis);\r\n  }\r\n  /** Create a circular arc defined by start point, any intermediate point, and end point.\r\n   * If the points are colinear, assemble them into a linestring.\r\n   */\r\n  public static createCircularStartMiddleEnd(\r\n    pointA: XYAndZ,\r\n    pointB: XYAndZ,\r\n    pointC: XYAndZ,\r\n    result?: Arc3d): Arc3d | LineString3d | undefined {\r\n    const vectorAB = Vector3d.createStartEnd(pointA, pointB);\r\n    const vectorAC = Vector3d.createStartEnd(pointA, pointC);\r\n    const ab = vectorAB.magnitude();\r\n    const bc = vectorAC.magnitude();\r\n    const normal = vectorAB.sizedCrossProduct(vectorAC, Math.sqrt(ab * bc));\r\n    if (normal) {\r\n      const vectorToCenter = SmallSystem.linearSystem3d(\r\n        normal.x, normal.y, normal.z,\r\n        vectorAB.x, vectorAB.y, vectorAB.z,\r\n        vectorAC.x, vectorAC.y, vectorAC.z,\r\n        0,              // vectorToCenter DOT normal = 0\r\n        0.5 * ab * ab,  // vectorToCenter DOT vectorBA = 0.5 * vectorBA DOT vectorBA  (Rayleigh quotient)\r\n        0.5 * bc * bc); // vectorToCenter DOT vectorBC = 0.5 * vectorBC DOT vectorBC  (Rayleigh quotient)\r\n      if (vectorToCenter) {\r\n        const center = Point3d.create(pointA.x, pointA.y, pointA.z).plus(vectorToCenter);\r\n        const vectorX = Vector3d.createStartEnd(center, pointA);\r\n        const vectorY = Vector3d.createRotateVectorAroundVector(vectorX, normal, Angle.createDegrees(90));\r\n        if (vectorY) {\r\n          const vectorCenterToC = Vector3d.createStartEnd(center, pointC);\r\n          const sweepAngle = vectorX.signedAngleTo(vectorCenterToC, normal);\r\n          if (sweepAngle.radians < 0.0)\r\n            sweepAngle.addMultipleOf2PiInPlace(1.0);\r\n          return Arc3d.create(center, vectorX, vectorY,\r\n            AngleSweep.createStartEndRadians(0.0, sweepAngle.radians), result);\r\n        }\r\n      }\r\n    }\r\n    return LineString3d.create(pointA, pointB, pointC);\r\n  }\r\n  /** The arc has simple proportional arc length if and only if it is a circular arc. */\r\n  public getFractionToDistanceScale(): number | undefined {\r\n    const radius = this.circularRadius();\r\n    if (radius !== undefined)\r\n      return Math.abs(radius * this._sweep.sweepRadians);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Convert a fractional position to xyz coordinates\r\n   * @param fraction fractional position on arc\r\n   * @param result optional preallocated result\r\n   */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    const radians = this._sweep.fractionToRadians(fraction);\r\n    return this._matrix.originPlusMatrixTimesXY(this._center, Math.cos(radians), Math.sin(radians), result);\r\n  }\r\n  /**\r\n   * Convert fractional arc and radial positions to xyz coordinates\r\n   * @param fraction fractional position on arc\r\n   * @param result optional preallocated result\r\n   */\r\n  public fractionAndRadialFractionToPoint(arcFraction: number, radialFraction: number, result?: Point3d): Point3d {\r\n    const radians = this._sweep.fractionToRadians(arcFraction);\r\n    return this._matrix.originPlusMatrixTimesXY(this._center, radialFraction * Math.cos(radians), radialFraction * Math.sin(radians), result);\r\n  }\r\n\r\n  /**\r\n   * Convert a fractional position to xyz coordinates and derivative with respect to fraction.\r\n   * @param fraction fractional position on arc\r\n   * @param result optional preallocated result\r\n   */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    result = this.radiansToPointAndDerivative(this._sweep.fractionToRadians(fraction), result);\r\n    result.direction.scaleInPlace(this._sweep.sweepRadians);\r\n    return result;\r\n  }\r\n\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the arc\r\n   * * x axis is the first derivative, i.e. tangent along the arc\r\n   * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\r\n   * If the arc is circular, the second derivative is directly towards the center\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const radians = this._sweep.fractionToRadians(fraction);\r\n    if (!result) result = Plane3dByOriginAndVectors.createXYPlane();\r\n    const c = Math.cos(radians);\r\n    const s = Math.sin(radians);\r\n    this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);\r\n    const a = this._sweep.sweepRadians;\r\n    this._matrix.multiplyXY(-a * s, a * c, result.vectorU);\r\n    const aa = a * a;\r\n    this._matrix.multiplyXY(- aa * c, -aa * s, result.vectorV);\r\n    return result;\r\n  }\r\n  /**\r\n   * Evaluate the point and derivative with respect to the angle (in radians)\r\n   * @param radians angular position\r\n   * @param result optional preallocated ray.\r\n   */\r\n  public radiansToPointAndDerivative(radians: number, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    const c = Math.cos(radians);\r\n    const s = Math.sin(radians);\r\n    this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);\r\n    this._matrix.multiplyXY(-s, c, result.direction);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return a parametric plane with\r\n   * * origin at arc center\r\n   * * vectorU from center to arc at angle (in radians)\r\n   * * vectorV from center to arc at 90 degrees past the angle.\r\n   * @param radians angular position\r\n   * @param result optional preallocated plane\r\n   */\r\n  public radiansToRotatedBasis(radians: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    result = result ? result : Plane3dByOriginAndVectors.createXYPlane();\r\n    const c = Math.cos(radians);\r\n    const s = Math.sin(radians);\r\n    result.origin.setFromPoint3d(this.center);\r\n    this._matrix.multiplyXY(c, s, result.vectorU);\r\n    this._matrix.multiplyXY(-s, c, result.vectorV);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the point and derivative with respect to the angle (in radians)\r\n   * @param theta angular position\r\n   * @param result optional preallocated ray.\r\n   */\r\n  public angleToPointAndDerivative(theta: Angle, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    const c = theta.cos();\r\n    const s = theta.sin();\r\n    this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);\r\n    this._matrix.multiplyXY(-s, c, result.direction);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the start point tof the arc.\r\n   * @param result optional preallocated result\r\n   */\r\n  public startPoint(result?: Point3d): Point3d { return this.fractionToPoint(0.0, result); }\r\n\r\n  /**\r\n   * Return the end point tof the arc.\r\n   * @param result optional preallocated result\r\n   */\r\n  public endPoint(result?: Point3d): Point3d { return this.fractionToPoint(1.0, result); }\r\n  /** * If this is a circular arc, return the simple length derived from radius and sweep.\r\n   * * Otherwise (i.e. if this elliptical) fall through to CurvePrimitive base implementation which\r\n   *     Uses quadrature.\r\n   */\r\n  public curveLength(): number {\r\n    return this.curveLengthBetweenFractions(0, 1);\r\n  }\r\n  // !! misspelled Gauss in the published static !!!   Declare it ok.\r\n  // cspell::word Guass\r\n  /** Gauss point quadrature count for evaluating curve length.   (The number of intervals is adjusted to the arc sweep) */\r\n  public static readonly quadratureGuassCount = 5;\r\n  /** In quadrature for arc length, use this interval (divided by quickEccentricity) */\r\n  public static readonly quadratureIntervalAngleDegrees = 10.0;\r\n  /** * If this is a circular arc, return the simple length derived from radius and sweep.\r\n   * * Otherwise (i.e. if this elliptical) fall through CurvePrimitive integrator.\r\n   */\r\n  public curveLengthBetweenFractions(fraction0: number, fraction1: number): number {\r\n    const simpleLength = this.getFractionToDistanceScale();\r\n    if (simpleLength !== undefined)\r\n      return simpleLength * Math.abs(fraction1 - fraction0);\r\n    // fall through for true ellipse . .. stroke and accumulate quadrature with typical count .  ..\r\n    let f0 = fraction0;\r\n    let f1 = fraction1;\r\n    if (fraction0 > fraction1) {\r\n      f0 = fraction1;\r\n      f1 = fraction0;\r\n    }\r\n    const sweepDegrees = (f1 - f0) * this._sweep.sweepDegrees;\r\n    let eccentricity = this.quickEccentricity();\r\n    if (eccentricity < 0.00001)\r\n      eccentricity = 0.00001;\r\n    let numInterval = Math.ceil(sweepDegrees / (eccentricity * Arc3d.quadratureIntervalAngleDegrees));\r\n    if (numInterval > 400)\r\n      numInterval = 400;\r\n    if (numInterval < 1)\r\n      numInterval = 1;\r\n    return super.curveLengthWithFixedIntervalCountQuadrature(f0, f1, numInterval, Arc3d.quadratureGuassCount);\r\n  }\r\n\r\n  /**\r\n   * Return an approximate (but easy to compute) arc length.\r\n   * The estimate is:\r\n   * * Form 8 chords on full circle, proportionally fewer for partials.  (But 2 extras if less than half circle.)\r\n   * * sum the chord lengths\r\n   * * For a circle, we know this crude approximation has to be increased by a factor (theta/(2 sin (theta/2)))\r\n   * * Apply that factor.\r\n   * * Experiments confirm that this is within 3 percent for a variety of eccentricities and arc sweeps.\r\n   */\r\n  public quickLength(): number {\r\n    const totalSweep = Math.abs(this._sweep.sweepRadians);\r\n    let numInterval = Math.ceil(4 * totalSweep / Math.PI);\r\n    if (numInterval < 1)\r\n      numInterval = 1;\r\n    if (numInterval < 4)\r\n      numInterval += 3;\r\n    else if (numInterval < 6)\r\n      numInterval += 2;   // force extras for short arcs\r\n    const pointA = Arc3d._workPointA;\r\n    const pointB = Arc3d._workPointB;\r\n    let chordSum = 0.0;\r\n    this.fractionToPoint(0.0, pointA);\r\n    for (let i = 1; i <= numInterval; i++) {\r\n      this.fractionToPoint(i / numInterval, pointB);\r\n      chordSum += pointA.distance(pointB);\r\n      pointA.setFromPoint3d(pointB);\r\n    }\r\n    // The chord sum is always shorter.\r\n    // if it is a true circular arc, the ratio of correct over sum is easy ...\r\n    const dTheta = totalSweep / numInterval;\r\n    const factor = dTheta / (2.0 * Math.sin(0.5 * dTheta));\r\n    return chordSum * factor;\r\n  }\r\n  /**\r\n   * * See extended comments on `CurvePrimitive.moveSignedDistanceFromFraction`\r\n   * * A zero length line generates `CurveSearchStatus.error`\r\n   * * Nonzero length line generates `CurveSearchStatus.success` or `CurveSearchStatus.stoppedAtBoundary`\r\n   */\r\n  public moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: false, result?: CurveLocationDetail): CurveLocationDetail {\r\n    if (!this.isCircular) // suppress extension !!!\r\n      return super.moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result);\r\n    const totalLength = this.curveLength();\r\n    const signedFractionMove = Geometry.conditionalDivideFraction(signedDistance, totalLength);\r\n    if (signedFractionMove === undefined) {\r\n      return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(\r\n        this, startFraction, this.fractionToPoint(startFraction), 0.0, CurveSearchStatus.error);\r\n    }\r\n    return CurveLocationDetail.createConditionalMoveSignedDistance(\r\n      allowExtension,\r\n      this,\r\n      startFraction,\r\n      startFraction + signedFractionMove,\r\n      signedDistance,\r\n      result);\r\n  }\r\n  /**\r\n   * Return all angles (in radians) where the ellipse tangent is perpendicular to the vector to a spacePoint.\r\n   * @param spacePoint point of origin of vectors to the ellipse\r\n   * @param _extend (NOT SUPPORTED -- ALWAYS ACTS AS \"true\")\r\n   * @param _endpoints if true, force the end radians into the result.\r\n   */\r\n  public allPerpendicularAngles(spacePoint: Point3d, _extend: boolean = true, _endpoints: boolean = false): number[] {\r\n    const radians: number[] = [];\r\n    const vectorQ = spacePoint.vectorTo(this.center);\r\n    const uu = this._matrix.columnXMagnitudeSquared();\r\n    const uv = this._matrix.columnXDotColumnY();\r\n    const vv = this._matrix.columnYMagnitudeSquared();\r\n    TrigPolynomial.solveUnitCircleImplicitQuadricIntersection(\r\n      uv,\r\n      vv - uu,\r\n      -uv,\r\n      this._matrix.dotColumnY(vectorQ),\r\n      -this._matrix.dotColumnX(vectorQ),\r\n      0.0, radians);\r\n    if (_endpoints) {\r\n      radians.push(this.sweep.startRadians);\r\n      radians.push(this.sweep.endRadians);\r\n    }\r\n\r\n    return radians;\r\n  }\r\n  /**\r\n   * Return details of the closest point on the arc, optionally extending to full ellipse.\r\n   * @param spacePoint search for point closest to this point.\r\n   * @param extend if true, consider projections to the complete ellipse.   If false, consider only endpoints and projections within the arc sweep.\r\n   * @param result optional preallocated result.\r\n   */\r\n  public closestPoint(spacePoint: Point3d, extend: VariantCurveExtendParameter, result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = CurveLocationDetail.create(this, result);\r\n    const allRadians = this.allPerpendicularAngles(spacePoint, true, true);\r\n    if (!extend && !this._sweep.isFullCircle) {\r\n      allRadians.push(this._sweep.startRadians);\r\n      allRadians.push(this._sweep.endRadians);\r\n    }\r\n    // hm... logically there must at least two angles there ...  but if it happens return the start point ...\r\n    const workRay = Ray3d.createZero();\r\n    if (allRadians.length === 0) {\r\n      result.setFR(0.0, this.radiansToPointAndDerivative(this._sweep.startRadians, workRay));\r\n      result.a = spacePoint.distance(result.point);\r\n    } else {\r\n      let dMin = Number.MAX_VALUE;\r\n      let d = 0;\r\n      for (const radians of allRadians) {\r\n        const fraction = CurveExtendOptions.resolveRadiansToSweepFraction(extend, radians, this.sweep);\r\n        if (fraction !== undefined) {\r\n          this.fractionToPointAndDerivative(fraction, workRay);\r\n\r\n          d = spacePoint.distance(workRay.origin);\r\n          if (d < dMin) {\r\n            dMin = d;\r\n            result.setFR(fraction, workRay);\r\n            result.a = d;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Reverse the sweep  of the arc. */\r\n  public reverseInPlace(): void { this._sweep.reverseInPlace(); }\r\n  /** apply a transform to the arc basis vectors.\r\n   * * nonuniform (i.e. skewing) transforms are allowed.\r\n   * * The transformed vector0 and vector90 are NOT squared up as major minor axes.  (This is a good feature!!)\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    this._center = transform.multiplyPoint3d(this._center, this._center);\r\n    this._matrix = transform.matrix.multiplyMatrixMatrix(this._matrix, this._matrix);\r\n    // force re-normalization of columnZ.\r\n    this.setVector0Vector90(this._matrix.columnX(), this._matrix.columnY());\r\n    return true;\r\n  }\r\n  /**\r\n   * Return true if the ellipse center and basis vectors are in the plane\r\n   * @param plane\r\n   */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    const normal = plane.getNormalRef();\r\n    // The ellipse vectors are full-length  -- true distance comparisons say things.\r\n    return Geometry.isSmallMetricDistance(plane.altitude(this._center))\r\n      && Geometry.isSmallMetricDistance(this._matrix.dotColumnX(normal))\r\n      && Geometry.isSmallMetricDistance(this._matrix.dotColumnY(normal));\r\n  }\r\n  /**\r\n   * Return true if the vector0 and vector90 are of equal length and perpendicular.\r\n   */\r\n  public get isCircular(): boolean {\r\n    const axx = this._matrix.columnXMagnitudeSquared();\r\n    const ayy = this._matrix.columnYMagnitudeSquared();\r\n    const axy = this._matrix.columnXDotColumnY();\r\n    return Angle.isPerpendicularDotSet(axx, ayy, axy) && Geometry.isSameCoordinateSquared(axx, ayy);\r\n  }\r\n  /** If the arc is circular, return its radius.  Otherwise return undefined */\r\n  public circularRadius(): number | undefined {\r\n    return this.isCircular ? this._matrix.columnXMagnitude() : undefined;\r\n  }\r\n\r\n  /** Return the larger of the two defining vectors. */\r\n  public maxVectorLength(): number { return Math.max(this._matrix.columnXMagnitude(), this._matrix.columnYMagnitude()); }\r\n  /**\r\n   * compute intersections with a plane.\r\n   * @param plane plane to intersect\r\n   * @param result array of locations on the curve.\r\n   */\r\n  public appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number {\r\n    const constCoff = plane.altitude(this._center);\r\n    const coffs = this._matrix.coffs;\r\n    const cosCoff = plane.velocityXYZ(coffs[0], coffs[3], coffs[6]);\r\n    const sinCoff = plane.velocityXYZ(coffs[1], coffs[4], coffs[7]);\r\n    const trigPoints = Geometry.solveTrigForm(constCoff, cosCoff, sinCoff);\r\n    let numIntersection = 0;\r\n    if (trigPoints !== undefined) {\r\n      numIntersection = trigPoints.length;\r\n      let xy;\r\n      for (xy of trigPoints) {\r\n        const radians = Math.atan2(xy.y, xy.x);\r\n        const fraction = this._sweep.radiansToPositivePeriodicFraction(radians);\r\n        const detail = CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction));\r\n        detail.intervalRole = CurveIntervalRole.isolated;\r\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._sweep.startRadians))\r\n          detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\r\n        else if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._sweep.startRadians))\r\n          detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\r\n        result.push(detail);\r\n      }\r\n    }\r\n    return numIntersection;\r\n  }\r\n  /**\r\n   * Extend a range to include the range of the arc.\r\n   * @param range range being extended.\r\n   * @param transform optional transform to apply to the arc.\r\n   */\r\n  public extendRange(range: Range3d, transform?: Transform): void {\r\n    const df = 1.0 / 32;\r\n    // KLUDGE --- evaluate lots of points ...\r\n    let point = Point3d.create();\r\n    for (let fraction = 0; fraction <= 1.001; fraction += df) {\r\n      point = this.fractionToPoint(fraction, point);\r\n      if (transform)\r\n        range.extendTransformedPoint(transform, point);\r\n      else\r\n        range.extendPoint(point);\r\n    }\r\n  }\r\n  /**\r\n   * Create a new arc which is a unit circle centered at the origin.\r\n   */\r\n  public static createUnitCircle(): Arc3d {\r\n    return Arc3d.createRefs(Point3d.create(0, 0, 0), Matrix3d.createIdentity(), AngleSweep.create360());\r\n  }\r\n  /**\r\n   * Create a new arc which is parallel to the xy plane, with given center and radius and optional angle sweep.\r\n   * @param center center of arc\r\n   * @param radius radius of arc\r\n   * @param sweep sweep limits.  defaults to full circle.\r\n   */\r\n  public static createXY(\r\n    center: Point3d,\r\n    radius: number,\r\n    sweep: AngleSweep = AngleSweep.create360()): Arc3d {\r\n    return new Arc3d(center.clone(), Matrix3d.createScale(radius, radius, 1.0), sweep);\r\n  }\r\n  /**\r\n   * Create a new arc which is parallel to the xy plane, with given center and x,y radii, and optional angle sweep\r\n   * @param center center of ellipse\r\n   * @param radiusA x axis radius\r\n   * @param radiusB y axis radius\r\n   * @param sweep angle sweep\r\n   */\r\n  public static createXYEllipse(\r\n    center: Point3d,\r\n    radiusA: number,\r\n    radiusB: number,\r\n    sweep: AngleSweep = AngleSweep.create360()): Arc3d {\r\n    return new Arc3d(center.clone(), Matrix3d.createScale(radiusA, radiusB, 1.0), sweep);\r\n  }\r\n  /**\r\n   * Replace the arc's 0 and 90 degree vectors.\r\n   * @param vector0 vector from center to ellipse point at 0 degrees in parameter space\r\n   * @param vector90 vector from center to ellipse point at 90 degrees in parameter space\r\n   */\r\n  public setVector0Vector90(vector0: Vector3d, vector90: Vector3d) {\r\n    this._matrix.setColumns(vector0, vector90,\r\n      vector0.unitCrossProductWithDefault(vector90, 0, 0, 0), // normal will be 000 for degenerate case !!!;\r\n    );\r\n  }\r\n  /** Return the arc definition with rigid matrix form with axis radii.\r\n   */\r\n  public toScaledMatrix3d(): { center: Point3d, axes: Matrix3d, r0: number, r90: number, sweep: AngleSweep } {\r\n    const angleData = Angle.dotProductsToHalfAngleTrigValues(\r\n      this._matrix.columnXMagnitudeSquared(),\r\n      this._matrix.columnYMagnitudeSquared(),\r\n      this._matrix.columnXDotColumnY(), true);\r\n    const vector0A = this._matrix.multiplyXY(angleData.c, angleData.s);\r\n    const vector90A = this._matrix.multiplyXY(-angleData.s, angleData.c);\r\n\r\n    const axes = Matrix3d.createRigidFromColumns(vector0A, vector90A, AxisOrder.XYZ);\r\n    return {\r\n      axes: (axes ? axes : Matrix3d.createIdentity()),\r\n      center: this._center,\r\n      r0: vector0A.magnitude(),\r\n      r90: vector90A.magnitude(),\r\n      sweep: this.sweep.cloneMinusRadians(angleData.radians),\r\n    };\r\n  }\r\n  /** Return the arc definition with center, two vectors, and angle sweep;\r\n   */\r\n  public toVectors(): ArcVectors {\r\n    return {\r\n      center: this.center,\r\n      vector0: this._matrix.columnX(),\r\n      vector90: this._matrix.columnY(),\r\n      sweep: this.sweep,\r\n    };\r\n  }\r\n\r\n  /** Return the arc definition with center, two vectors, and angle sweep, optionally transformed.\r\n   */\r\n  public toTransformedVectors(transform?: Transform): { center: Point3d, vector0: Vector3d, vector90: Vector3d, sweep: AngleSweep } {\r\n    return transform ? {\r\n      center: transform.multiplyPoint3d(this._center),\r\n      vector0: transform.multiplyVector(this._matrix.columnX()),\r\n      vector90: transform.multiplyVector(this._matrix.columnY()),\r\n      sweep: this.sweep,\r\n    }\r\n      : {\r\n        center: this._center.clone(),\r\n        vector0: this._matrix.columnX(),\r\n        vector90: this._matrix.columnY(),\r\n        sweep: this.sweep,\r\n      };\r\n  }\r\n\r\n  /** Return the arc definition with center, two vectors, and angle sweep, transformed to 4d points.\r\n   */\r\n  public toTransformedPoint4d(matrix: Matrix4d): { center: Point4d, vector0: Point4d, vector90: Point4d, sweep: AngleSweep } {\r\n    return {\r\n      center: matrix.multiplyPoint3d(this._center, 1.0),\r\n      vector0: matrix.multiplyPoint3d(this._matrix.columnX(), 0.0),\r\n      vector90: matrix.multiplyPoint3d(this._matrix.columnY(), 0.0),\r\n      sweep: this.sweep,\r\n    };\r\n  }\r\n  /**\r\n   * Set this arc from a json object with these values:\r\n   * * center center point\r\n   * * vector0 vector from center to 0 degree point in parameter space (commonly but not always the major axis vector)\r\n   * * vector90 vector from center to 90 degree point in parameter space (commonly but not always the minor axis vector)\r\n   * @param json\r\n   */\r\n  public setFromJSON(json?: any) {\r\n    if (json && json.center && json.vector0 && json.vector90 && json.sweep) {\r\n      this._center.setFromJSON(json.center);\r\n      const vector0 = Vector3d.create();\r\n      const vector90 = Vector3d.create();\r\n      vector0.setFromJSON(json.vector0);\r\n      vector90.setFromJSON(json.vector90);\r\n      this.setVector0Vector90(vector0, vector90);\r\n      this._sweep.setFromJSON(json.sweep);\r\n    } else {\r\n      this._center.set(0, 0, 0);\r\n      this._matrix.setFrom(Matrix3d.identity);\r\n      this._sweep.setStartEndRadians();\r\n    }\r\n  }\r\n  /**\r\n   * Convert to a JSON object.\r\n   * @return {*} [center:  [], vector0:[], vector90:[], sweep []}\r\n   */\r\n  public toJSON(): any {\r\n    return {\r\n      center: this._center.toJSON(),\r\n      sweep: this._sweep.toJSON(),\r\n      vector0: this._matrix.columnX().toJSON(),\r\n      vector90: this._matrix.columnY().toJSON(),\r\n    };\r\n  }\r\n  /**\r\n   * Test if this arc is almost equal to another GeometryQuery object\r\n   */\r\n  public isAlmostEqual(otherGeometry: GeometryQuery): boolean {\r\n    if (otherGeometry instanceof Arc3d) {\r\n      const other = otherGeometry as Arc3d;\r\n      return this._center.isAlmostEqual(other._center)\r\n        && this._matrix.isAlmostEqual(other._matrix)\r\n        && this._sweep.isAlmostEqualAllowPeriodShift(other._sweep);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Emit strokes to caller-supplied linestring */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const numStrokes = this.computeStrokeCountForOptions(options);\r\n    dest.appendFractionalStrokePoints(this, numStrokes, 0.0, 1.0, true);\r\n  }\r\n\r\n  /** Emit strokes to caller-supplied handler */\r\n  public emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void {\r\n    const numStrokes = this.computeStrokeCountForOptions(options);\r\n    handler.startCurvePrimitive(this);\r\n    handler.announceIntervalForUniformStepStrokes(this, numStrokes, 0.0, 1.0);\r\n    handler.endCurvePrimitive(this);\r\n  }\r\n\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    let numStroke = 1;\r\n    if (options) {\r\n      const rMax = this.maxVectorLength();\r\n      numStroke = options.applyTolerancesToArc(rMax, this._sweep.sweepRadians);\r\n    } else {\r\n      numStroke = StrokeOptions.applyAngleTol(undefined, 1, this._sweep.sweepRadians);\r\n    }\r\n    return numStroke;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleArc3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleArc3d(this);\r\n  }\r\n  /** Return (if possible) an arc which is a portion of this curve.\r\n   * @param fractionA [in] start fraction\r\n   * @param fractionB [in] end fraction\r\n   */\r\n  public clonePartialCurve(fractionA: number, fractionB: number): CurvePrimitive | undefined {\r\n    if (fractionB < fractionA) {\r\n      const arcA = this.clonePartialCurve(fractionB, fractionA);\r\n      if (arcA)\r\n        arcA.reverseInPlace();\r\n      return arcA;\r\n    }\r\n    const arcB = this.clone();\r\n\r\n    arcB.sweep.setStartEndRadians(\r\n      this.sweep.fractionToRadians(fractionA),\r\n      this.sweep.fractionToRadians(fractionB));\r\n    return arcB;\r\n  }\r\n  /** Return an arc whose basis vectors are rotated by given angle within the current basis space.\r\n   * * the result arc will have its zero-degree point (new `vector0`) at the current `vector0 * cos(theta) + vector90 * sin(theta)`\r\n   * * the result sweep is adjusted so all fractional coordinates (e.g. start and end) evaluate to the same xyz.\r\n   *   * Specifically, theta is subtracted from the original start and end angles.\r\n   * @param theta the angle (in the input arc space) which is to become the 0-degree point in the new arc.\r\n   */\r\n  public cloneInRotatedBasis(theta: Angle): Arc3d {\r\n    const c = theta.cos();\r\n    const s = theta.sin();\r\n    const vector0 = this._matrix.multiplyXY(c, s);\r\n    const vector90 = this.matrix.multiplyXY(-s, c);\r\n\r\n    const newSweep = AngleSweep.createStartEndRadians(this._sweep.startRadians - theta.radians, this._sweep.endRadians - theta.radians);\r\n    const arcB = Arc3d.create(this._center.clone(), vector0, vector90, newSweep);\r\n    return arcB;\r\n  }\r\n\r\n  /**\r\n   * Find intervals of this CurvePrimitive that are interior to a clipper\r\n   * @param clipper clip structure (e.g.clip planes)\r\n   * @param announce(optional) function to be called announcing fractional intervals\"  ` announce(fraction0, fraction1, curvePrimitive)`\r\n   * @returns true if any \"in\" segments are announced.\r\n   */\r\n  public announceClipIntervals(clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    return clipper.announceClippedArcIntervals(this, announce);\r\n  }\r\n  /** Compute the center and vectors of another arc as local coordinates within this arc's frame. */\r\n  public otherArcAsLocalVectors(other: Arc3d): ArcVectors | undefined {\r\n    const otherOrigin = this._matrix.multiplyInverseXYZAsPoint3d(\r\n      other.center.x - this.center.x, other.center.y - this.center.y, other.center.z - this.center.z);\r\n    const otherVector0 = this._matrix.multiplyInverse(other.vector0);\r\n    const otherVector90 = this._matrix.multiplyInverse(other.vector90);\r\n    if (otherOrigin && otherVector0 && otherVector90) {\r\n      return { center: otherOrigin, vector0: otherVector0, vector90: otherVector90, sweep: this.sweep.clone() };\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Determine an arc \"at a point of inflection\" of a point sequence.\r\n   * * Return the arc along with the fractional positions of the tangency points.\r\n   * * In the returned object:\r\n   *   * `arc` is the (bounded) arc\r\n   *   * `fraction10` is the tangency point's position as an interpolating fraction of the line segment from `point1` (backwards) to `point0`\r\n   *   * `fraction12` is the tangency point's position as an interpolating fraction of the line segment from `point1` (forward) to `point2`\r\n   *   * `point1` is the `point1` input.\r\n   * * If unable to construct the arc:\r\n   *   * `point` is the `point` input.\r\n   *   * both fractions are zero\r\n   *   * `arc` is undefined.\r\n   * @param point0 first point of path. (the point before the point of inflection)\r\n   * @param point1 second point of path (the point of inflection)\r\n   * @param point2 third point of path (the point after the point of inflection)\r\n   * @param radius arc radius\r\n   *\r\n   */\r\n  public static createFilletArc(point0: Point3d, point1: Point3d, point2: Point3d, radius: number): ArcBlendData {\r\n    const vector10 = Vector3d.createStartEnd(point1, point0);\r\n    const vector12 = Vector3d.createStartEnd(point1, point2);\r\n    const d10 = vector10.magnitude();\r\n    const d12 = vector12.magnitude();\r\n    if (vector10.normalizeInPlace() && vector12.normalizeInPlace()) {\r\n      const bisector = vector10.plus(vector12);\r\n      if (bisector.normalizeInPlace()) {\r\n        // const theta = vector12.angleTo(bisector);\r\n        // vector10, vector12, and bisector are UNIT vectors\r\n        // bisector splits the angle between vector10 and vector12\r\n        const perpendicular = vector12.minus(vector10);\r\n        const perpendicularMagnitude = perpendicular.magnitude();  // == 2 * sin(theta)\r\n        const sinTheta = 0.5 * perpendicularMagnitude;\r\n        if (!Geometry.isSmallAngleRadians(sinTheta)) {  // (for small theta, sinTheta is almost equal to theta)\r\n          const cosTheta = Math.sqrt(1 - sinTheta * sinTheta);\r\n          const tanTheta = sinTheta / cosTheta;\r\n          const alphaRadians = Math.acos(sinTheta);\r\n          const distanceToCenter = radius / sinTheta;\r\n          const distanceToTangency = radius / tanTheta;\r\n          const f10 = distanceToTangency / d10;\r\n          const f12 = distanceToTangency / d12;\r\n          const center = point1.plusScaled(bisector, distanceToCenter);\r\n          bisector.scaleInPlace(-radius);\r\n          perpendicular.scaleInPlace(radius / perpendicularMagnitude);\r\n          const arc02 = Arc3d.create(center, bisector, perpendicular, AngleSweep.createStartEndRadians(-alphaRadians, alphaRadians));\r\n          return { arc: arc02, fraction10: f10, fraction12: f12, point: point1.clone() };\r\n        }\r\n      }\r\n    }\r\n    return { fraction10: 0.0, fraction12: 0.0, point: point1.clone() };\r\n  }\r\n}\r\n/**\r\n * Carrier structure for an arc with fractional data on incoming, outgoing curves.\r\n * @public\r\n */\r\nexport interface ArcBlendData {\r\n  /** Constructed arc */\r\n  arc?: Arc3d;\r\n  /** fraction \"moving backward\" on the inbound curve */\r\n  fraction10: number;\r\n  /** fraction \"moving forward\" on the outbound curve */\r\n  fraction12: number;\r\n  /** optional reference point */\r\n  point?: Point3d;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { BagOfCurves } from \"./CurveCollection\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { Path } from \"./Path\";\r\n/**\r\n * Manage a growing array of arrays of curve primitives that are to be joined \"head to tail\" in paths.\r\n * * The caller makes a sequence of calls to announce individual primitives.\r\n * * Ordering so \"head to tail\" is obvious is the caller's responsibility.\r\n * * This class manages the tedium of distinguishing isolated primitives, paths, and multiple paths.\r\n * * Construction logic makes each chain internally continuous, i.e. suitable for being a Path.\r\n * * Chaining only occurs between primitives that are consecutive in the announcement stream.\r\n * * Usage pattern is\r\n *   * initialization: `context = new ChainCollectorContext (makeClones: boolean)`\r\n *   * many times: `   context.announceCurvePrimitive (primitive)`\r\n *   * end:        ` result = context.grabResults ()`\r\n * @internal\r\n */\r\nexport class ChainCollectorContext {\r\n  private _chains: CurvePrimitive[][];\r\n  private _makeClones: boolean;\r\n  /**\r\n   * Push a new chain with an optional first primitive.\r\n   */\r\n  private pushNewChain(primitive?: CurvePrimitive) {\r\n    const chain = [];\r\n    if (primitive)\r\n      chain.push(primitive);\r\n    this._chains.push(chain);\r\n  }\r\n  private findOrCreateTailChain(): CurvePrimitive[] {\r\n    if (this._chains.length === 0)\r\n      this.pushNewChain();\r\n    return this._chains[this._chains.length - 1];\r\n  }\r\n  /** Initialize with an empty array of chains.\r\n   * @param makeClones if true, all CurvePrimitives sent to `announceCurvePrimitive` is immediately cloned.  If false, the reference to the original curve is maintained.\r\n   */\r\n  public constructor(makeClones: boolean) {\r\n    this._chains = [];\r\n    this._makeClones = makeClones;\r\n  }\r\n  /** Announce a curve primitive\r\n   * * If possible, append it to the current chain.\r\n   * * Otherwise start a new chain.\r\n   */\r\n  public announceCurvePrimitive(candidate: CurvePrimitive) {\r\n    if (candidate) {\r\n      if (this._makeClones) {\r\n        const candidate1 = candidate.clone();\r\n        if (!candidate1 || !(candidate1 instanceof CurvePrimitive))\r\n          return;\r\n        this.transferMarkup(candidate, candidate1);\r\n        candidate = candidate1;\r\n      }\r\n      const activeChain = this.findOrCreateTailChain();\r\n      if (activeChain.length === 0 || !ChainCollectorContext.needBreakBetweenPrimitives(activeChain[activeChain.length - 1], candidate))\r\n        activeChain.push(candidate);\r\n      else\r\n        this.pushNewChain(candidate);\r\n    }\r\n  }\r\n  /** Transfer markup (e.g. isCutAtStart, isCutAtEnd) from source to destination */\r\n  private transferMarkup(source: CurvePrimitive, dest: CurvePrimitive) {\r\n    if (source && dest) {\r\n      dest.startCut = source.startCut;\r\n      dest.endCut = source.endCut;\r\n    }\r\n  }\r\n  /** turn an array of curve primitives into the simplest possible strongly typed curve structure.\r\n   * * The input array is assumed to be connected appropriately to act as the curves of a Path.\r\n   * * When a path is created the curves array is CAPTURED.\r\n   */\r\n  private promoteArrayToCurves(curves: CurvePrimitive[]): CurvePrimitive | Path | undefined {\r\n    if (curves.length === 0)\r\n      return undefined;\r\n    if (curves.length === 1)\r\n      return curves[0];\r\n    return Path.createArray(curves);\r\n  }\r\n  /** Return the collected results, structured as the simplest possible type. */\r\n  public grabResult(): CurvePrimitive | Path | BagOfCurves | undefined {\r\n    const chains = this._chains;\r\n    if (chains.length === 0)\r\n      return undefined;\r\n    if (chains.length === 1)\r\n      return this.promoteArrayToCurves(chains[0]);\r\n    const bag = BagOfCurves.create();\r\n    for (const chain of chains) {\r\n      const q = this.promoteArrayToCurves(chain);\r\n      bag.tryAddChild(q);\r\n    }\r\n    return bag;\r\n  }\r\n  private static _workPointA?: Point3d;\r\n  private static _workPointB?: Point3d;\r\n  /** test if there is a break between primitiveA and primitiveB, due to any condition such as\r\n   * * primitiveA.isCutAtEnd\r\n   * * primitiveB.isCutAtStart\r\n   * * physical gap between primitives.\r\n   */\r\n  private static needBreakBetweenPrimitives(primitiveA: CurvePrimitive, primitiveB: CurvePrimitive, isXYOnly: boolean = false): boolean {\r\n    if (primitiveA === undefined)\r\n      return true;\r\n    if (primitiveB === undefined)\r\n      return true;\r\n    if (primitiveA.endCut !== undefined)\r\n      return true;\r\n    if (primitiveB.startCut !== undefined)\r\n      return true;\r\n    ChainCollectorContext._workPointA = primitiveA.endPoint(ChainCollectorContext._workPointA);\r\n    ChainCollectorContext._workPointB = primitiveA.startPoint(ChainCollectorContext._workPointB);\r\n    return isXYOnly\r\n      ? ChainCollectorContext._workPointA.isAlmostEqualXY(ChainCollectorContext._workPointB)\r\n      : ChainCollectorContext._workPointA.isAlmostEqual(ChainCollectorContext._workPointB);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { NullGeometryHandler } from \"../geometry3d/GeometryHandler\";\r\n\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { Arc3d } from \"./Arc3d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Geometry } from \"../Geometry\";\r\n\r\n/**\r\n * Context for constructing a curve that is interpolated between two other curves.\r\n * * The only callable method is the static `InterpolateBetween`.\r\n * * Other methods are called only by `dispatchToGeometryHandler`\r\n * @public\r\n */\r\nexport class ConstructCurveBetweenCurves extends NullGeometryHandler {\r\n  // private geometry0: GeometryQuery;  <-- Never used\r\n  private _geometry1: GeometryQuery;\r\n  private _fraction: number;\r\n  private constructor(_geometry0: GeometryQuery, _fraction: number, _geometry1: GeometryQuery) {\r\n    super();\r\n    // this.geometry0 = _geometry0;   <-- Never used\r\n    this._geometry1 = _geometry1;\r\n    this._fraction = _fraction;\r\n  }\r\n\r\n  /**\r\n   * * To be directly called only by double dispatcher\r\n   * * Assumes this.geometry1 was set by calling context.\r\n   * * Construct the interpolated curve between this.geometry1 and the supplied segment0.\r\n   */\r\n  public handleLineSegment3d(segment0: LineSegment3d): any {\r\n    if (this._geometry1 instanceof LineSegment3d) {\r\n      const segment1 = this._geometry1 as LineSegment3d;\r\n      return LineSegment3d.create(\r\n        segment0.startPoint().interpolate(this._fraction, segment1.startPoint()),\r\n        segment0.endPoint().interpolate(this._fraction, segment1.endPoint()));\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * * To be directly called only by double dispatcher\r\n   * * Assumes this.geometry1 was set by calling context.\r\n   * * Construct the interpolated curve between this.geometry1 and the supplied ls0.\r\n   */\r\n  public handleLineString3d(ls0: LineString3d): any {\r\n    if (this._geometry1 instanceof LineString3d) {\r\n      const ls1 = this._geometry1 as LineString3d;\r\n      if (ls0.numPoints() === ls1.numPoints()) {\r\n        const numPoints = ls0.numPoints();\r\n        const ls = LineString3d.create();\r\n        const workPoint = Point3d.create();\r\n        const workPoint0 = Point3d.create();\r\n        const workPoint1 = Point3d.create();\r\n        let workVector0;\r\n        let workVector1;\r\n        const fraction = this._fraction;\r\n        for (let i = 0; i < numPoints; i++) {\r\n          ls0.pointAt(i, workPoint0);\r\n          ls1.pointAt(i, workPoint1);\r\n          workPoint0.interpolate(fraction, workPoint1, workPoint);\r\n          ls.addPoint(workPoint);\r\n        }\r\n        if (ls0.fractions && ls1.fractions) {\r\n          for (let i = 0; i < numPoints; i++) {\r\n            ls.addFraction(Geometry.interpolate(ls0.fractions.atUncheckedIndex(i), fraction, ls1.fractions.atUncheckedIndex(i)));\r\n          }\r\n        }\r\n        if (ls0.strokeData && ls1.strokeData) {\r\n          // Policy: simple clone of stroke count map from ls0.\r\n          // The curveLength will not match.\r\n          // But we expect to be called at a time compatible count and a0,a1 are the important thing.\r\n          ls.strokeData = ls0.strokeData.clone();\r\n        }\r\n        if (ls0.packedDerivatives && ls1.packedDerivatives) {\r\n          if (!workVector0)\r\n            workVector0 = Vector3d.create();\r\n          if (!workVector1)\r\n            workVector1 = Vector3d.create();\r\n          for (let i = 0; i < numPoints; i++) {\r\n            ls0.packedDerivatives.getVector3dAtCheckedVectorIndex(i, workVector0);\r\n            ls1.packedDerivatives.getVector3dAtCheckedVectorIndex(i, workVector1);\r\n            ls.addDerivative(workVector0.interpolate(fraction, workVector1));\r\n          }\r\n\r\n        }\r\n        return ls;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * * To be directly called only by double dispatcher\r\n   * * Assumes this.geometry1 was set by calling context.\r\n   * * Construct the interpolated curve between this.geometry1 and the supplied arc0.\r\n   */\r\n  public handleArc3d(arc0: Arc3d): any {\r\n    if (this._geometry1 instanceof Arc3d) {\r\n      const arc1 = this._geometry1 as Arc3d;\r\n      return Arc3d.create(\r\n        arc0.center.interpolate(this._fraction, arc1.center),\r\n        arc0.vector0.interpolate(this._fraction, arc1.vector0),\r\n        arc0.vector90.interpolate(this._fraction, arc1.vector90),\r\n        arc0.sweep.interpolate(this._fraction, arc1.sweep));\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Construct a geometry item which is fractionally interpolated between two others.\r\n   * * The construction is only supported between certain types:\r\n   * * * LineSegment3d+LineSegment3d -- endpoints are interpolated\r\n   * * * LineString3d+LineString3d with matching counts.  Each point is interpolated.\r\n   * * * Arc3d+Arc3d -- center, vector0, vector90, and limit angles of the sweep are interpolated.\r\n   * @param geometry0 geometry \"at fraction 0\"\r\n   * @param fraction  fractional position\r\n   * @param geometry1 geometry \"at fraction 1\"\r\n   */\r\n  public static interpolateBetween(geometry0: GeometryQuery, fraction: number, geometry1: GeometryQuery): GeometryQuery | undefined {\r\n    const handler = new ConstructCurveBetweenCurves(geometry0, fraction, geometry1);\r\n    return geometry0.dispatchToGeometryHandler(handler);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\n\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\n\r\n/** A Coordinate is a Point3d with supporting methods from the GeometryQuery abstraction.\r\n * @public\r\n */\r\nexport class CoordinateXYZ extends GeometryQuery {\r\n  /** String name for interface properties */\r\n  public readonly geometryCategory = \"point\";\r\n\r\n  private _xyz: Point3d;\r\n  /** Return a (REFERENCE TO) the coordinate data. */\r\n  public get point() { return this._xyz; }\r\n  /**\r\n   * @param xyz point to be CAPTURED.\r\n   */\r\n  private constructor(xyz: Point3d) {\r\n    super();\r\n    this._xyz = xyz;\r\n  }\r\n  /** Create a new CoordinateXYZ containing a CLONE of point */\r\n  public static create(point: Point3d): CoordinateXYZ {\r\n    return new CoordinateXYZ(point.clone());\r\n  }\r\n  /** Create a new CoordinateXYZ */\r\n  public static createXYZ(x: number = 0, y: number = 0, z: number = 0): CoordinateXYZ {\r\n    return new CoordinateXYZ(Point3d.create(x, y, z));\r\n  }\r\n\r\n  /** return the range of the point */\r\n  public range(): Range3d { return Range3d.create(this._xyz); }\r\n\r\n  /** extend `rangeToExtend` to include this point (optionally transformed) */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    if (transform)\r\n      rangeToExtend.extendTransformedXYZ(transform, this._xyz.x, this._xyz.y, this._xyz.z);\r\n    else\r\n      rangeToExtend.extend(this._xyz);\r\n  }\r\n  /** Apply transform to the Coordinate's point. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    transform.multiplyPoint3d(this._xyz, this._xyz);\r\n    return true;\r\n  }\r\n  /** return a transformed clone.\r\n   */\r\n  public cloneTransformed(transform: Transform): GeometryQuery | undefined {\r\n    const result = new CoordinateXYZ(this._xyz.clone());\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n  /** return a clone */\r\n  public clone(): GeometryQuery | undefined {\r\n    return new CoordinateXYZ(this._xyz.clone());\r\n  }\r\n  /** return GeometryQuery children for recursive queries.\r\n   *\r\n   * * leaf classes do not need to implement.\r\n   */\r\n\r\n  /** test if (other instanceof Coordinate).  */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean {\r\n    return other instanceof CoordinateXYZ;\r\n  }\r\n  /** test for exact structure and nearly identical geometry.\r\n   *\r\n   * *  Leaf classes must implement !!!\r\n   * *  base class implementation recurses through children.\r\n   * *  base implementation is complete for classes with children and no properties.\r\n   * *  classes with both children and properties must implement for properties, call super for children.\r\n   */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    return (other instanceof CoordinateXYZ) && this._xyz.isAlmostEqual(other._xyz);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleCoordinateXYZ(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleCoordinateXYZ(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { IStrokeHandler, GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurveChain } from \"./CurveCollection\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { CurveLocationDetail } from \"./CurveLocationDetail\";\r\nimport { VariantCurveExtendParameter, CurveExtendMode, CurveExtendOptions } from \"./CurveExtendMode\";\r\n/**\r\n * * Annotation of an interval of a curve.\r\n * * The interval is marked with two pairs of numbers:\r\n * * * fraction0, fraction1 = fraction parameters along the child curve\r\n * * * distance0,distance1 = distances within containing CurveChainWithDistanceIndex\r\n * @public\r\n */\r\nexport class PathFragment {\r\n  /** distance along parent to this fragment start */\r\n  public chainDistance0: number;\r\n  /** distance along parent to this fragment end */\r\n  public chainDistance1: number;\r\n  /** Fractional position of this fragment start within its curve primitive. */\r\n  public childFraction0: number;\r\n  /** Fractional position of this fragment end within its curve primitive.. */\r\n  public childFraction1: number;\r\n  /** Curve primitive of this fragment */\r\n  public childCurve: CurvePrimitive;\r\n  /** Create a fragment with complete fraction, distance and child data. */\r\n  public constructor(childFraction0: number, childFraction1: number, distance0: number, distance1: number, childCurve: CurvePrimitive) {\r\n    this.childFraction0 = childFraction0;\r\n    this.childFraction1 = childFraction1;\r\n    this.chainDistance0 = distance0;\r\n    this.chainDistance1 = distance1;\r\n    this.childCurve = childCurve;\r\n  }\r\n  /**\r\n   * Return true if the distance is within the distance limits of this fragment.\r\n   * @param distance\r\n   */\r\n  public containsChainDistance(distance: number): boolean {\r\n    return distance >= this.chainDistance0 && distance <= this.chainDistance1;\r\n  }\r\n\r\n  /**\r\n   * Return true if this fragment addresses `curve` and brackets `fraction`\r\n   * @param distance\r\n   */\r\n  public containsChildCurveAndChildFraction(curve: CurvePrimitive, fraction: number): boolean {\r\n    return this.childCurve === curve && fraction >= this.childFraction0 && fraction <= this.childFraction1;\r\n  }\r\n\r\n  /** Convert distance to local fraction, and apply that to interpolate between the stored curve fractions.\r\n   * Note that proportional calculation does NOT account for nonuniform parameterization in the child curve.\r\n   */\r\n  public chainDistanceToInterpolatedChildFraction(distance: number): number {\r\n    return Geometry.inverseInterpolate(\r\n      this.childFraction0, this.chainDistance0,\r\n      this.childFraction1, this.chainDistance1,\r\n      distance, this.childFraction0)!;    // the interval \"must\" have nonzero length, division should be safe . ..\r\n  }\r\n  /** Convert chainDistance to true chidFraction, using detailed moveSignedDistanceFromFraction\r\n   */\r\n  public chainDistanceToAccurateChildFraction(chainDistance: number): number {\r\n    // The fragments are really expected to do good mappings in their distance range ...\r\n    const childDetail = this.childCurve.moveSignedDistanceFromFraction(\r\n      this.childFraction0, chainDistance - this.chainDistance0, false);\r\n    return childDetail.fraction;\r\n  }\r\n  /** Return the scale factor to map childCurve fraction derivatives to chain fraction derivatives\r\n   * @param globalDistance total length of the global curve.\r\n   */\r\n  public fractionScaleFactor(globalDistance: number): number {\r\n    return globalDistance * (this.childFraction1 - this.childFraction0) / (this.chainDistance1 - this.chainDistance0);\r\n  }\r\n  /** Reverse the fraction and distance data.\r\n   * * each child fraction `f` is replaced by `1-f`\r\n   * * each `chainDistance` is replaced by `totalDistance-chainDistance`\r\n   */\r\n  public reverseFractionsAndDistances(totalDistance: number) {\r\n    const f0 = this.childFraction0;\r\n    const f1 = this.childFraction1;\r\n    const d0 = this.chainDistance0;\r\n    const d1 = this.chainDistance1;\r\n    this.childFraction0 = 1.0 - f1;\r\n    this.childFraction1 = 1.0 - f0;\r\n    this.chainDistance0 = totalDistance - d1;\r\n    this.chainDistance1 = totalDistance - d0;\r\n  }\r\n  /**\r\n   * convert a fractional position on the childCurve to distance in the chain space.\r\n   * * Return value is SIGNED -- will be negative when fraction < this.childFraction0.\r\n   * @param fraction fraction along the curve within this fragment\r\n   */\r\n  public childFractionTChainDistance(fraction: number): number {\r\n    let d = this.childCurve.curveLengthBetweenFractions(this.childFraction0, fraction);\r\n    if (fraction < this.childFraction0)\r\n      d = -d;\r\n    return this.chainDistance0 + d;\r\n  }\r\n}\r\n/** Non-instantiable class to build a distance index for a path. */\r\nclass DistanceIndexConstructionContext implements IStrokeHandler {\r\n  private _fragments: PathFragment[];\r\n  private _accumulatedDistance: number;\r\n  private constructor() {\r\n    this._accumulatedDistance = 0;\r\n    this._fragments = [];\r\n  }\r\n  // ignore curve announcements -- they are repeated in stroke announcements\r\n  public startParentCurvePrimitive(_cp: CurvePrimitive) { }\r\n  public startCurvePrimitive(_cp: CurvePrimitive) { }\r\n  public endParentCurvePrimitive(_cp: CurvePrimitive) { }\r\n  public endCurvePrimitive(_cp: CurvePrimitive) { }\r\n  // um .. we need to see curves? how to reject?\r\n  public announcePointTangent(_xyz: Point3d, _fraction: number, _tangent: Vector3d) { }\r\n  /** Announce numPoints interpolated between point0 and point1, with associated fractions */\r\n  public announceSegmentInterval(\r\n    cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    let d0 = this._accumulatedDistance;\r\n    if (numStrokes <= 1) {\r\n      this._accumulatedDistance += point0.distance(point1);\r\n      this._fragments.push(new PathFragment(fraction0, fraction1, d0, this._accumulatedDistance, cp));\r\n    } else {\r\n      let f1;\r\n      for (let i = 1, f0 = 0.0; i <= numStrokes; i++ , f0 = f1) {\r\n        f1 = Geometry.interpolate(fraction0, i / numStrokes, fraction1);\r\n        d0 = this._accumulatedDistance;\r\n        this._accumulatedDistance += (Math.abs(f1 - f0) * point0.distance(point1));\r\n        this._fragments.push(new PathFragment(f0, f1, d0, this._accumulatedDistance, cp));\r\n      }\r\n    }\r\n  }\r\n  public announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    let f1, d, d0;\r\n    for (let i = 1, f0 = fraction0; i <= numStrokes; i++ , f0 = f1) {\r\n      f1 = Geometry.interpolate(fraction0, i / numStrokes, fraction1);\r\n      d = cp.curveLengthBetweenFractions(f0, f1);\r\n      d0 = this._accumulatedDistance;\r\n      this._accumulatedDistance += d;\r\n      this._fragments.push(new PathFragment(f0, f1, d0, this._accumulatedDistance, cp));\r\n    }\r\n  }\r\n  public static createPathFragmentIndex(path: CurveChain, options?: StrokeOptions): PathFragment[] {\r\n    const handler = new DistanceIndexConstructionContext();\r\n    for (const curve of path.children) {\r\n      curve.emitStrokableParts(handler, options);\r\n    }\r\n    const fragments = handler._fragments;\r\n    return fragments;\r\n  }\r\n}\r\n/**\r\n * `CurveChainWithDistanceIndex` is a CurvePrimitive whose fractional parameterization is proportional to true\r\n * distance along a CurveChain.\r\n * * The curve chain can be any type derived from CurveChain.\r\n * * * i.e. either a `Path` or a `Loop`\r\n * @public\r\n */\r\nexport class CurveChainWithDistanceIndex extends CurvePrimitive {\r\n  /** String name for schema properties */\r\n  public readonly curvePrimitiveType = \"curveChainWithDistanceIndex\";\r\n\r\n  private _path: CurveChain;\r\n  private _fragments: PathFragment[];\r\n  private _totalLength: number; // matches final fragment distance1.\r\n  /** Test if other is a `CurveChainWithDistanceIndex` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof CurveChainWithDistanceIndex; }\r\n  // final assembly of CurveChainWithDistanceIndex -- caller must create valid fragment index.\r\n  private constructor(path: CurveChain, fragments: PathFragment[]) {\r\n    super();\r\n    this._path = path;\r\n    this._fragments = fragments;\r\n    this._totalLength = fragments[fragments.length - 1].chainDistance1;\r\n  }\r\n  /**\r\n   * Create a clone, transformed and with its own distance index.\r\n   * @param transform transform to apply in the clone.\r\n   */\r\n  public cloneTransformed(transform: Transform): CurvePrimitive | undefined {\r\n    const c = this._path.clone();\r\n    if (c !== undefined && c instanceof CurveChain && c.tryTransformInPlace(transform))\r\n      return CurveChainWithDistanceIndex.createCapture(c as CurveChain);\r\n    return undefined;\r\n  }\r\n  /** Reference to the contained path.\r\n   * * Do not modify the path.  The distance index will be wrong.\r\n   */\r\n  public get path(): CurveChain { return this._path; }\r\n\r\n  /** Return a deep clone */\r\n  public clone(): CurvePrimitive | undefined {\r\n    const c = this._path.clone();\r\n    if (c !== undefined && c instanceof CurveChain)\r\n      return CurveChainWithDistanceIndex.createCapture(c as CurveChain);\r\n    return undefined;\r\n  }\r\n  /** Ask if the curve is within tolerance of a plane.\r\n   * @returns Returns true if the curve is completely within tolerance of the plane.\r\n   */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    for (const c of this._path.children) {\r\n      if (!c.isInPlane(plane))\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** return the start point of the primitive.  The default implementation returns fractionToPoint (0.0) */\r\n  public startPoint(result?: Point3d): Point3d {\r\n    const c = this._path.cyclicCurvePrimitive(0);\r\n    if (c)\r\n      return c.startPoint(result);\r\n    return Point3d.createZero(result);\r\n  }\r\n  /** Return the end point of the primitive. The default implementation returns fractionToPoint(1.0) */\r\n  public endPoint(result?: Point3d): Point3d {\r\n    const c = this._path.cyclicCurvePrimitive(-1);\r\n    if (c)\r\n      return c.endPoint(result);\r\n    return Point3d.createZero(result);\r\n  }\r\n  /** Add strokes to caller-supplied linestring */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    for (const c of this._path.children) {\r\n      c.emitStrokes(dest, options);\r\n    }\r\n  }\r\n  /** Ask the curve to announce points and simple subcurve fragments for stroking.\r\n   * See IStrokeHandler for description of the sequence of the method calls.\r\n   */\r\n  public emitStrokableParts(dest: IStrokeHandler, options?: StrokeOptions): void {\r\n    for (const c of this._path.children) {\r\n      c.emitStrokableParts(dest, options);\r\n    }\r\n  }\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    let numStroke = 0;\r\n    for (const c of this._path.children) {\r\n      numStroke += c.computeStrokeCountForOptions(options);\r\n    }\r\n    return numStroke;\r\n  }\r\n  /**\r\n   * construct StrokeCountMap for each child, accumulating data to stroke count map for this primitive.\r\n   * @param options StrokeOptions that determine count\r\n   * @param parentStrokeMap evolving parent map.\r\n   */\r\n  public computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap) {\r\n    const myMap = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap);\r\n    for (const c of this._path.children) {\r\n      c.computeAndAttachRecursiveStrokeCounts(options, myMap);\r\n    }\r\n    CurvePrimitive.installStrokeCountMap(this, myMap, parentStrokeMap);\r\n  }\r\n  /** Second step of double dispatch:  call `this._path.dispatchToGeometryHandler (handler)`\r\n   * * Note that this exposes the children individually to the handler.\r\n   */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return this._path.dispatchToGeometryHandler(handler);\r\n  }\r\n  /** Extend (increase) `rangeToExtend` as needed to include these curves (optionally transformed)\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    this._path.extendRange(rangeToExtend, transform);\r\n  }\r\n  /**\r\n   *\r\n   * * Curve length is always positive.\r\n   * @returns Returns a (high accuracy) length of the curve between fractional positions\r\n   * @returns Returns the length of the curve.\r\n   */\r\n  public curveLengthBetweenFractions(fraction0: number, fraction1: number): number {\r\n    return Math.abs(fraction1 - fraction0) * this._totalLength;\r\n  }\r\n  /**\r\n   * Capture (not clone) a path into a new `CurveChainWithDistanceIndex`\r\n   * @param primitives primitive array to be CAPTURED (not cloned)\r\n   */\r\n  public static createCapture(path: CurveChain, options?: StrokeOptions): CurveChainWithDistanceIndex | undefined {\r\n    if (path.children.length === 0)\r\n      return undefined;\r\n    const fragments = DistanceIndexConstructionContext.createPathFragmentIndex(path, options);\r\n    const result = new CurveChainWithDistanceIndex(path, fragments);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Resolve a fraction of the CurveChain to a PathFragment\r\n   * @param distance\r\n   * @param allowExtrapolation\r\n   */\r\n  protected chainDistanceToFragment(distance: number, allowExtrapolation: boolean = false): PathFragment | undefined {\r\n    const numFragments = this._fragments.length;\r\n    const fragments = this._fragments!;\r\n    if (numFragments > 0) {\r\n      if (distance < 0.0)\r\n        return allowExtrapolation ? fragments[0] : undefined;\r\n      if (distance >= this._totalLength)\r\n        return allowExtrapolation ? fragments[numFragments - 1] : undefined;\r\n      // humbug, linear search\r\n      for (const fragment of fragments) {\r\n        if (fragment.containsChainDistance(distance)) return fragment;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Convert distance along the chain to fraction along the chain.\r\n   * @param distance distance along the chain\r\n   */\r\n  public chainDistanceToChainFraction(distance: number): number { return distance / this._totalLength; }\r\n  /**\r\n   * Resolve a fraction within a specific curve to a fragment.\r\n   * @param curve\r\n   * @param fraction\r\n   */\r\n  protected curveAndChildFractionToFragment(curve: CurvePrimitive, fraction: number): PathFragment | undefined {\r\n    const numFragments = this._fragments.length;\r\n    const fragments = this._fragments!;\r\n    if (numFragments > 0) {\r\n      // humbug, linear search\r\n      for (const fragment of fragments) {\r\n        if (fragment.containsChildCurveAndChildFraction(curve, fraction)) return fragment;\r\n      }\r\n      if (fraction <= 0)\r\n        return fragments[0];\r\n      if (fraction > 1.0)\r\n        return fragments[numFragments - 1];\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the total length of curves.\r\n   */\r\n  public curveLength(): number {\r\n    return this._totalLength;\r\n  }\r\n  /**\r\n   * Returns the total length of the path.\r\n   * * This is exact (and simple property lookup) because the true lengths were summed at construction time.\r\n   */\r\n  public quickLength(): number {\r\n    return this._totalLength;\r\n  }\r\n\r\n  /**\r\n   * Return the point (x,y,z) on the curve at fractional position along the chain.\r\n   * @param fraction fractional position along the geometry.\r\n   * @returns Returns a point on the curve.\r\n   */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    const chainDistance = fraction * this._totalLength;\r\n    let fragment = this.chainDistanceToFragment(chainDistance, true);\r\n    if (fragment) {\r\n      const childFraction = fragment.chainDistanceToAccurateChildFraction(chainDistance);\r\n      return fragment.childCurve.fractionToPoint(childFraction, result);\r\n    }\r\n    fragment = this.chainDistanceToFragment(chainDistance, true);\r\n    return this._fragments[0].childCurve.fractionToPoint(0.0, result);\r\n  }\r\n\r\n  /** Return the point (x,y,z) and derivative on the curve at fractional position.\r\n   *\r\n   * * Note that this derivative is \"derivative of xyz with respect to fraction.\"\r\n   * * this derivative shows the speed of the \"fractional point\" moving along the curve.\r\n   * * this is not generally a unit vector.  use fractionToPointAndUnitTangent for a unit vector.\r\n   * @param fraction fractional position along the geometry.\r\n   * @returns Returns a ray whose origin is the curve point and direction is the derivative with respect to the fraction.\r\n   */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    const distanceAlongPath = fraction * this._totalLength;\r\n    const fragment = this.chainDistanceToFragment(distanceAlongPath, true)!;\r\n    const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath);\r\n    result = fragment.childCurve.fractionToPointAndDerivative(curveFraction, result);\r\n    const a = this._totalLength / result.direction.magnitude();\r\n    result.direction.scaleInPlace(a);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a ray whose origin is the curve point and direction is the unit tangent.\r\n   * @param fraction fractional position on the curve\r\n   * @param result optional receiver for the result.\r\n   * Returns a ray whose origin is the curve point and direction is the unit tangent.\r\n   */\r\n  public fractionToPointAndUnitTangent(fraction: number, result?: Ray3d): Ray3d {\r\n    const distanceAlongPath = fraction * this._totalLength;\r\n    const fragment = this.chainDistanceToFragment(distanceAlongPath, true)!;\r\n    const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath);\r\n    result = fragment.childCurve.fractionToPointAndDerivative(curveFraction, result);\r\n    result.direction.normalizeInPlace();\r\n    return result;\r\n  }\r\n  /** Return a plane with\r\n   *\r\n   * * origin at fractional position along the curve\r\n   * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.\r\n   * * vectorV is the second derivative, i.e.derivative of vectorU.\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined {\r\n    const totalLength = this._totalLength;\r\n    const distanceAlongPath = fraction * totalLength;\r\n    const fragment = this.chainDistanceToFragment(distanceAlongPath, true)!;\r\n    const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath);\r\n    result = fragment.childCurve.fractionToPointAnd2Derivatives(curveFraction, result);\r\n    if (!result)\r\n      return undefined;\r\n    const dotUU = result.vectorU.magnitudeSquared();\r\n    const magU = Math.sqrt(dotUU);\r\n    const dotUV = result.vectorU.dotProduct(result.vectorV);\r\n    const duds = 1.0 / magU;\r\n    const a = duds * duds;\r\n    Vector3d.createAdd2Scaled(result.vectorV, a, result.vectorU, -a * dotUV / dotUU, result.vectorV);   // IN PLACE update to vectorV.\r\n    result.vectorU.scale(duds);\r\n    // scale for 0..1 parameterization ....\r\n    result.vectorU.scaleInPlace(totalLength);\r\n    result.vectorV.scaleInPlace(totalLength * totalLength);\r\n    return result;\r\n  }\r\n  /** Attempt to transform in place.\r\n   * * Warning: If any child fails, this object becomes invalid.  But that should never happen.\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    let numFail = 0;\r\n    for (const c of this._path.children) {\r\n      if (!c.tryTransformInPlace(transform))\r\n        numFail++;\r\n    }\r\n    return numFail === 0;\r\n  }\r\n  /** Reverse the curve's data so that its fractional stroking moves in the opposite direction. */\r\n  public reverseInPlace(): void {\r\n    this._path.reverseChildrenInPlace();\r\n    const totalLength = this._totalLength;\r\n    for (const fragment of this._fragments)\r\n      fragment.reverseFractionsAndDistances(totalLength);\r\n    for (let i = 0, j = this._fragments.length - 1; i < j; i++ , j--) {\r\n      const fragment = this._fragments[i];\r\n      this._fragments[i] = this._fragments[j];\r\n      this._fragments[j] = fragment;\r\n    }\r\n  }\r\n  /**\r\n   * Test for equality conditions:\r\n   * * Mismatched totalLength is a quick exit condition\r\n   * * If totalLength matches, recurse to the path for matching primitives.\r\n   * @param other\r\n   */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof CurveChainWithDistanceIndex) {\r\n      return Geometry.isSameCoordinate(this._totalLength, other._totalLength)\r\n        && this._path.isAlmostEqual(other._path);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Implement moveSignedDistanceFromFraction.\r\n   * * See `CurvePrimitive` for parameter details.\r\n   * * The returned location directly identifies fractional position along the CurveChainWithDistanceIndex, and has pointer to an additional detail for the child curve.\r\n   */\r\n  public moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: boolean, result?: CurveLocationDetail): CurveLocationDetail {\r\n    const distanceA = startFraction * this._totalLength;\r\n    const distanceB = distanceA + signedDistance;\r\n    const fragmentB = this.chainDistanceToFragment(distanceB, true)!;\r\n    const childDetail = fragmentB.childCurve.moveSignedDistanceFromFraction(fragmentB.childFraction0, distanceB - fragmentB.chainDistance0, allowExtension, result);\r\n    const endFraction = startFraction + (signedDistance / this._totalLength);\r\n    const chainDetail = CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, endFraction, signedDistance, result);\r\n    chainDetail.childDetail = childDetail;\r\n    return chainDetail;\r\n  }\r\n\r\n  /** Search for the curve point that is closest to the spacePoint.\r\n   * * The CurveChainWithDistanceIndex invokes the base class CurvePrimitive method, which\r\n   *     (via a handler) determines a CurveLocation detail among the children.\r\n   * * The returned detail directly identifies fractional position along the CurveChainWithDistanceIndex, and has pointer to an additional detail for the child curve.\r\n   * @param spacePoint point in space\r\n   * @param extend true to extend the curve (NOT USED)\r\n   * @returns Returns a CurveLocationDetail structure that holds the details of the close point.\r\n   */\r\n  public closestPoint(spacePoint: Point3d, extend: VariantCurveExtendParameter): CurveLocationDetail | undefined {\r\n    // umm... to \"extend\", would require selective extension of first, last\r\n    let childDetail: CurveLocationDetail | undefined;\r\n    let aMin = Number.MAX_VALUE;\r\n    const numChildren = this.path.children.length;\r\n    if (numChildren === 1) {\r\n      childDetail = this.path.children[0].closestPoint(spacePoint, extend);\r\n    } else {\r\n      const extend0 = [CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extend, 0), CurveExtendMode.None];\r\n      const extend1 = [CurveExtendMode.None, CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extend, 1)];\r\n      for (let childIndex = 0; childIndex < numChildren; childIndex++) {\r\n        const child = this.path.children[childIndex];\r\n        const detailA = child.closestPoint(spacePoint, childIndex === 0 ? extend0 : childIndex + 1 === numChildren ? extend1 : false);\r\n        if (detailA && detailA.a < aMin) {\r\n          aMin = detailA.a;\r\n          childDetail = CurveLocationDetail.createCurveFractionPoint(detailA.curve!, detailA.fraction, detailA.point, childDetail)!;\r\n          childDetail.a = detailA.a;\r\n        }\r\n      }\r\n\r\n    }\r\n    if (!childDetail)\r\n      return undefined;\r\n    const fragment = this.curveAndChildFractionToFragment(childDetail.curve!, childDetail.fraction);\r\n    if (fragment) {\r\n      const chainDistance = fragment.childFractionTChainDistance(childDetail.fraction);\r\n      const chainFraction = this.chainDistanceToChainFraction(chainDistance);\r\n      const chainDetail = CurveLocationDetail.createCurveFractionPoint(this, chainFraction, childDetail.point);\r\n      chainDetail.childDetail = childDetail;\r\n      return chainDetail;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { RecursiveCurveProcessor, RecursiveCurveProcessorWithStack } from \"./CurveProcessor\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { CurveLocationDetail } from \"./CurveLocationDetail\";\r\n\r\n// import { SumLengthsContext, GapSearchContext, CountLinearPartsSearchContext, CloneCurvesContext, TransformInPlaceContext } from \"./CurveSearches\";\r\n\r\n/** Algorithmic class: Accumulate maximum gap between adjacent primitives of CurveChain.\r\n */\r\nclass GapSearchContext extends RecursiveCurveProcessorWithStack {\r\n  public maxGap: number;\r\n  constructor() { super(); this.maxGap = 0.0; }\r\n  public static maxGap(target: CurveCollection): number {\r\n    const context = new GapSearchContext();\r\n    target.announceToCurveProcessor(context);\r\n    return context.maxGap;\r\n  }\r\n  public announceCurvePrimitive(curve: CurvePrimitive, _indexInParent: number): void {\r\n    if (this._stack.length > 0) {\r\n      const parent = this._stack[this._stack.length - 1];\r\n      if (parent instanceof CurveChain) {\r\n        const chain = parent as CurveChain;\r\n        const nextCurve = chain.cyclicCurvePrimitive(_indexInParent + 1);\r\n        if (curve !== undefined && nextCurve !== undefined) {\r\n          this.maxGap = Math.max(this.maxGap, curve.endPoint().distance(nextCurve.startPoint()));\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** Algorithmic class: Count LineSegment3d and LineString3d primitives.\r\n */\r\nclass CountLinearPartsSearchContext extends RecursiveCurveProcessorWithStack {\r\n  public numLineSegment: number;\r\n  public numLineString: number;\r\n  public numOther: number;\r\n  constructor() {\r\n    super();\r\n    this.numLineSegment = 0;\r\n    this.numLineString = 0;\r\n    this.numOther = 0;\r\n  }\r\n  public static hasNonLinearPrimitives(target: CurveCollection): boolean {\r\n    const context = new CountLinearPartsSearchContext();\r\n    target.announceToCurveProcessor(context);\r\n    return context.numOther > 0;\r\n  }\r\n  public announceCurvePrimitive(curve: CurvePrimitive, _indexInParent: number): void {\r\n    if (curve instanceof LineSegment3d)\r\n      this.numLineSegment++;\r\n    else if (curve instanceof LineString3d)\r\n      this.numLineString++;\r\n    else\r\n      this.numOther++;\r\n  }\r\n}\r\n\r\n/** Algorithmic class: Transform curves in place.\r\n */\r\nclass TransformInPlaceContext extends RecursiveCurveProcessor {\r\n  public numFail: number;\r\n  public numOK: number;\r\n  public transform: Transform;\r\n  constructor(transform: Transform) { super(); this.numFail = 0; this.numOK = 0; this.transform = transform; }\r\n  public static tryTransformInPlace(target: CurveCollection, transform: Transform): boolean {\r\n    const context = new TransformInPlaceContext(transform);\r\n    target.announceToCurveProcessor(context);\r\n    return context.numFail === 0;\r\n  }\r\n  public announceCurvePrimitive(curvePrimitive: CurvePrimitive, _indexInParent: number): void {\r\n    if (!curvePrimitive.tryTransformInPlace(this.transform))\r\n      this.numFail++;\r\n    else\r\n      this.numOK++;\r\n  }\r\n}\r\n/** Algorithmic class: Sum lengths of curves */\r\nclass SumLengthsContext extends RecursiveCurveProcessor {\r\n  private _sum: number;\r\n  private constructor() { super(); this._sum = 0.0; }\r\n  public static sumLengths(target: CurveCollection): number {\r\n    const context = new SumLengthsContext();\r\n    target.announceToCurveProcessor(context);\r\n    return context._sum;\r\n  }\r\n  public announceCurvePrimitive(curvePrimitive: CurvePrimitive, _indexInParent: number): void {\r\n    this._sum += curvePrimitive.curveLength();\r\n  }\r\n}\r\n/**\r\n * Algorithmic class for cloning curve collections.\r\n * * recurse through collection nodes, building image nodes as needed and inserting clones of children.\r\n * * for individual primitive, invoke doClone (protected) for direct clone; insert into parent\r\n */\r\nclass CloneCurvesContext extends RecursiveCurveProcessorWithStack {\r\n  protected _result: CurveCollection | undefined;\r\n  private _transform: Transform | undefined;\r\n  protected constructor(transform?: Transform) {\r\n    super();\r\n    this._transform = transform;\r\n    this._result = undefined;\r\n  }\r\n  public static clone(target: CurveCollection, transform?: Transform): CurveCollection | undefined {\r\n    const context = new CloneCurvesContext(transform);\r\n    target.announceToCurveProcessor(context);\r\n    return context._result;\r\n  }\r\n  public enter(c: CurveCollection) {\r\n    if (c instanceof CurveCollection)\r\n      super.enter(c.cloneEmptyPeer());\r\n  }\r\n  public leave(): CurveCollection | undefined {\r\n    const result = super.leave();\r\n    if (result) {\r\n      if (this._stack.length === 0) // this should only happen once !!!\r\n        this._result = result as BagOfCurves;\r\n      else // push this result to top of stack.\r\n        this._stack[this._stack.length - 1].tryAddChild(result);\r\n    }\r\n    return result;\r\n  }\r\n  // specialized clone methods override this (and allow announceCurvePrimitive to insert to parent)\r\n  protected doClone(primitive: CurvePrimitive): CurvePrimitive | CurvePrimitive[] | undefined {\r\n    if (this._transform)\r\n      return primitive.cloneTransformed(this._transform) as CurvePrimitive;\r\n    return primitive.clone() as CurvePrimitive;\r\n  }\r\n\r\n  public announceCurvePrimitive(primitive: CurvePrimitive, _indexInParent: number): void {\r\n    const c = this.doClone(primitive);\r\n    if (c !== undefined && this._stack.length > 0) {\r\n      const parent = this._stack[this._stack.length - 1];\r\n      if (parent instanceof CurveChain || parent instanceof BagOfCurves)\r\n        if (Array.isArray(c)) {\r\n          for (const c1 of c) {\r\n            parent.tryAddChild(c1);\r\n          }\r\n        } else {\r\n          parent.tryAddChild(c);\r\n        }\r\n    }\r\n  }\r\n}\r\n/**\r\n * Algorithmic class for cloning with linestrings expanded to line segments\r\n */\r\nclass CloneWithExpandedLineStrings extends CloneCurvesContext {\r\n  public constructor() {\r\n    // we have no transform ....\r\n    super(undefined);\r\n  }\r\n  // We know we have no transform !!!\r\n  protected doClone(primitive: CurvePrimitive): CurvePrimitive | CurvePrimitive[] | undefined {\r\n    if (primitive instanceof LineString3d && primitive.numPoints() > 1) {\r\n      const packedPoints = primitive.packedPoints;\r\n      const n = packedPoints.length;\r\n      const segments = [];\r\n      for (let i = 0; i + 1 < n; i++) {\r\n        segments.push(LineSegment3d.createCapture(packedPoints.getPoint3dAtUncheckedPointIndex(i), packedPoints.getPoint3dAtUncheckedPointIndex(i + 1)));\r\n      }\r\n      return segments;\r\n    }\r\n    return primitive.clone() as CurvePrimitive;\r\n  }\r\n  public static clone(target: CurveCollection): CurveCollection | undefined {\r\n    const context = new CloneWithExpandedLineStrings();\r\n    target.announceToCurveProcessor(context);\r\n    return context._result;\r\n  }\r\n}\r\n\r\n/** Describes the concrete type of a [[CurveCollection]]. Each type name maps to a specific subclass and can be used in conditional statements for type-switching.\r\n *    - \"loop\" => [[Loop]]\r\n *    - \"path\" => [[Path]]\r\n *    - \"unionRegion\" => [[UnionRegion]]\r\n *    - \"parityRegion\" => [[ParityRegion]]\r\n *    - \"bagOfCurves\" => [[BagOfCurves]]\r\n * @public\r\n */\r\nexport type CurveCollectionType = \"loop\" | \"path\" | \"unionRegion\" | \"parityRegion\" | \"bagOfCurves\";\r\n\r\n/**\r\n * * A `CurveCollection` is an abstract (non-instantiable) class for various sets of curves with particular structures:\r\n *   * `CurveChain` is a (non-instantiable) intermediate class for a sequence of `CurvePrimitive ` joining head-to-tail.  The two instantiable forms of `CurveChain` are\r\n *     * `Path` - A chain not required to close, and not enclosing a planar area\r\n *     * `Loop` - A chain required to close from last to first so that a planar area is enclosed.\r\n *   * `ParityRegion` -- a collection of coplanar `Loop`s, with \"in/out\" classification by parity rules\r\n *   * `UnionRegion` -- a collection of coplanar `Loop`s, with \"in/out\" classification by union rules\r\n *   * `BagOfCurves` -- a collection of `AnyCurve` with no implied structure.\r\n * @public\r\n */\r\nexport abstract class CurveCollection extends GeometryQuery {\r\n   /** String name for schema properties */\r\n  public readonly geometryCategory = \"curveCollection\";\r\n  /** Type discriminator. */\r\n  public abstract readonly curveCollectionType: CurveCollectionType;\r\n\r\n  /* tslint:disable:variable-name no-empty*/\r\n  /**  Flag for inner loop status. Only used by `Loop`. */\r\n  public isInner: boolean = false;\r\n  /** Return the sum of the lengths of all contained curves. */\r\n  public sumLengths(): number { return SumLengthsContext.sumLengths(this); }\r\n  /** return the max gap between adjacent primitives in Path and Loop collections.\r\n   *\r\n   * * In a Path, gaps are computed between consecutive primitives.\r\n   * * In a Loop, gaps are computed between consecutive primitives and between last and first.\r\n   * * gaps are NOT computed between consecutive CurvePrimitives in \"unstructured\" collections.  The type is \"unstructured\" so gaps should not be semantically meaningful.\r\n   */\r\n  public maxGap(): number { return GapSearchContext.maxGap(this); }\r\n  /** return true if the curve collection has any primitives other than LineSegment3d and LineString3d  */\r\n  public checkForNonLinearPrimitives(): boolean { return CountLinearPartsSearchContext.hasNonLinearPrimitives(this); }\r\n  /** Apply transform recursively to children */\r\n  public tryTransformInPlace(transform: Transform): boolean { return TransformInPlaceContext.tryTransformInPlace(this, transform); }\r\n  /** Return a deep copy. */\r\n  public clone(): CurveCollection | undefined {\r\n    return CloneCurvesContext.clone(this);\r\n  }\r\n  /** Create a deep copy of transformed curves. */\r\n  public cloneTransformed(transform: Transform): CurveCollection | undefined {\r\n    return CloneCurvesContext.clone(this, transform);\r\n  }\r\n  /** Create a deep copy with all linestrings expanded to multiple LineSegment3d. */\r\n  public cloneWithExpandedLineStrings(): CurveCollection | undefined {\r\n    return CloneWithExpandedLineStrings.clone(this);\r\n  }\r\n  /** Recurse through children to collect CurvePrimitive's in flat array. */\r\n  private collectCurvePrimitivesGo(results: CurvePrimitive[]) {\r\n    if (this.children) {\r\n      for (const child of this.children) {\r\n        if (child instanceof CurvePrimitive)\r\n          results.push(child);\r\n        else if (child instanceof CurveCollection)\r\n          child.collectCurvePrimitivesGo(results);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return an array containing only the curve primitives.\r\n   * * These are leaf nodes\r\n   * * If there is a CurveChainWithDistanceIndex, that primitive stands as a leaf. (NOT its constituent curves)\r\n   */\r\n  public collectCurvePrimitives(): CurvePrimitive[] {\r\n    const results: CurvePrimitive[] = [];\r\n    this.collectCurvePrimitivesGo(results);\r\n    return results;\r\n  }\r\n  /** Return true for planar region types:\r\n   * * `Loop`\r\n   * * `ParityRegion`\r\n   * * `UnionRegion`\r\n   */\r\n  public get isAnyRegionType(): boolean {\r\n    return this.dgnBoundaryType() === 2 || this.dgnBoundaryType() === 5 || this.dgnBoundaryType() === 4;\r\n  }\r\n  /** Return true for a `Path`, i.e. a chain of curves joined head-to-tail\r\n   */\r\n  public get isOpenPath(): boolean {\r\n    return this.dgnBoundaryType() === 1;\r\n  }\r\n  /** Return true for a single-loop planar region type, i.e. `Loop`.\r\n   * * This is _not- a test for physical closure of a `Path`\r\n   */\r\n  public get isClosedPath(): boolean {\r\n    return this.dgnBoundaryType() === 2;\r\n  }\r\n  /** Return a CurveCollection with the same structure but all curves replaced by strokes. */\r\n  public abstract cloneStroked(options?: StrokeOptions): AnyCurve;\r\n\r\n  /** Support method for ICurvePrimitive ... one line call to specific announce method . . */\r\n  public abstract announceToCurveProcessor(processor: RecursiveCurveProcessor): void;\r\n  /** clone an empty collection. */\r\n  public abstract cloneEmptyPeer(): CurveCollection;\r\n  /** Return the boundary type of a corresponding  MicroStation CurveVector.\r\n   * * Derived class must implement.\r\n   */\r\n  public abstract dgnBoundaryType(): number;\r\n  /**\r\n   * Try to add a child.\r\n   * @param child child to add.\r\n   * @return true if child is an acceptable type for this collection.\r\n   */\r\n  public abstract tryAddChild(child: AnyCurve | undefined): boolean;\r\n  /** Return a child identified by by index */\r\n  public abstract getChild(i: number): AnyCurve | undefined;\r\n  /** Extend (increase) `rangeToExtend` as needed to include these curves (optionally transformed) */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    const children = this.children;\r\n    if (children) {\r\n      for (const c of children) {\r\n        c.extendRange(rangeToExtend, transform);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * * Find any curve primitive in the source.\r\n   * * Evaluate it at a fraction (which by default is an interior fraction)\r\n   * @param source containing `CurvePrimitive` or `CurveCollection`\r\n   * @param fraction fraction to use in `curve.fractionToPoint(fraction)`\r\n   */\r\n  public static createCurveLocationDetailOnAnyCurvePrimitive(source: GeometryQuery | undefined, fraction: number = 0.5): CurveLocationDetail | undefined {\r\n    if (!source)\r\n      return undefined;\r\n    if (source instanceof CurvePrimitive) {\r\n      return CurveLocationDetail.createCurveEvaluatedFraction(source, fraction);\r\n    } else if (source instanceof CurveCollection && source.children !== undefined)\r\n      for (const child of source.children) {\r\n        const detail = this.createCurveLocationDetailOnAnyCurvePrimitive(child, fraction);\r\n        if (detail)\r\n          return detail;\r\n      }\r\n    return undefined;\r\n  }\r\n}\r\n/** Shared base class for use by both open and closed paths.\r\n * * A `CurveChain` contains only curvePrimitives.  No other paths, loops, or regions allowed.\r\n * * A single entry in the chain can in fact contain multiple curve primitives if the entry itself is (for instance) `CurveChainWithDistanceIndex`\r\n *   which presents itself (through method interface) as a CurvePrimitive with well defined mappings from fraction to xyz, but in fact does all the\r\n *    calculations over multiple primitives.\r\n * * The specific derived classes are `Path` and `Loop`\r\n * * `CurveChain` is an intermediate class.   It is not instantiable on its own.\r\n * @public\r\n */\r\nexport abstract class CurveChain extends CurveCollection {\r\n  /** The curve primitives in the chain. */\r\n  protected _curves: CurvePrimitive[];\r\n  protected constructor() { super(); this._curves = []; }\r\n  /** Return the array of `CurvePrimitive` */\r\n  public get children(): CurvePrimitive[] {\r\n    if (this._curves === undefined)\r\n      this._curves = [];\r\n    return this._curves;\r\n  }\r\n  /**\r\n   * Return curve primitive by index, interpreted cyclically for both Loop and Path\r\n   * @param index index to array\r\n   */\r\n  /**\r\n   * Return the `[index]` curve primitive, using `modulo` to map`index` to the cyclic indexing.\r\n   * * In particular, `-1` is the final curve.\r\n   * @param index cyclic index\r\n   */\r\n  public cyclicCurvePrimitive(index: number): CurvePrimitive | undefined {\r\n    const n = this.children.length;\r\n    if (n === 0)\r\n      return undefined;\r\n\r\n    const index2 = Geometry.modulo(index, n);\r\n    return this.children[index2];\r\n  }\r\n  /** Stroke the chain into a simple xyz array.\r\n   * @param options tolerance parameters controlling the stroking.\r\n   */\r\n  public getPackedStrokes(options?: StrokeOptions): GrowableXYZArray | undefined {\r\n    const tree = this.cloneStroked(options);\r\n    if (tree instanceof CurveChain) {\r\n      const children = tree.children;\r\n      if (children.length === 1) {\r\n        const ls = children[0];\r\n        if (ls instanceof LineString3d)\r\n          return ls.packedPoints;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return a structural clone, with CurvePrimitive objects stroked. */\r\n  public cloneStroked(options?: StrokeOptions): AnyCurve {\r\n    const strokes = LineString3d.create();\r\n    for (const curve of this.children)\r\n      curve.emitStrokes(strokes, options);\r\n    return strokes;\r\n  }\r\n  /** add a child curve.\r\n   * * Returns false if the given child is not a CurvePrimitive.\r\n   */\r\n  public tryAddChild(child: AnyCurve | undefined): boolean {\r\n    if (child && child instanceof CurvePrimitive) {\r\n      this._curves.push(child);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** Return a child by index */\r\n  public getChild(i: number): CurvePrimitive | undefined {\r\n    if (i < this._curves.length) return this._curves[i];\r\n    return undefined;\r\n  }\r\n  /** invoke `curve.extendRange(range, transform)` for each child  */\r\n  public extendRange(range: Range3d, transform?: Transform): void {\r\n    for (const curve of this._curves)\r\n      curve.extendRange(range, transform);\r\n  }\r\n  /**\r\n   * Reverse each child curve (in place)\r\n   * Reverse the order of the children in the CurveChain array.\r\n   */\r\n  public reverseChildrenInPlace() {\r\n    for (const curve of this._curves)\r\n      curve.reverseInPlace();\r\n    this._curves.reverse();\r\n  }\r\n}\r\n\r\n/**\r\n * * A `BagOfCurves` object is a collection of `AnyCurve` objects.\r\n * * A `BagOfCurves` has no implied properties such as being planar.\r\n * @public\r\n */\r\nexport class BagOfCurves extends CurveCollection {\r\n   /** String name for schema properties */\r\n  public readonly curveCollectionType = \"bagOfCurves\";\r\n\r\n  /** test if `other` is an instance of `BagOfCurves` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof BagOfCurves; }\r\n  /** Array of children.\r\n   * * No restrictions on type.\r\n   */\r\n  protected _children: AnyCurve[];\r\n  /** Construct an empty `BagOfCurves` */\r\n  public constructor() { super(); this._children = []; }\r\n  /** Return the (reference to) array of children */\r\n  public get children(): AnyCurve[] { return this._children; }\r\n  /** create with given curves. */\r\n  public static create(...data: AnyCurve[]): BagOfCurves {\r\n    const result = new BagOfCurves();\r\n    for (const child of data) {\r\n      result.tryAddChild(child);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return the boundary type (0) of a corresponding  MicroStation CurveVector */\r\n  public dgnBoundaryType(): number { return 0; }\r\n  /** invoke `processor.announceBagOfCurves(this, indexInParent);` */\r\n  public announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent: number = -1): void {\r\n    return processor.announceBagOfCurves(this, indexInParent);\r\n  }\r\n  /** Clone all children in stroked form. */\r\n  public cloneStroked(options?: StrokeOptions): BagOfCurves {\r\n    const clone = new BagOfCurves();\r\n    let child;\r\n    for (child of this.children) {\r\n      if (child instanceof CurvePrimitive) {\r\n        const ls = LineString3d.create();\r\n        (child as CurvePrimitive).emitStrokes(ls, options);\r\n        if (ls)\r\n          clone.children.push(ls);\r\n      } else if (child instanceof CurveCollection) {\r\n        const childStrokes = (child as CurveCollection).cloneStroked(options);\r\n        if (childStrokes)\r\n          clone.children.push(childStrokes);\r\n      }\r\n    }\r\n    return clone;\r\n  }\r\n  /** Return an empty `BagOfCurves` */\r\n  public cloneEmptyPeer(): BagOfCurves { return new BagOfCurves(); }\r\n  /** Add a child  */\r\n  public tryAddChild(child: AnyCurve | undefined): boolean {\r\n    if (child)\r\n      this._children.push(child);\r\n    return true;\r\n  }\r\n  /** Get a child by index */\r\n  public getChild(i: number): AnyCurve | undefined {\r\n    if (i < this._children.length)\r\n      return this._children[i];\r\n    return undefined;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBagOfCurves(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBagOfCurves(this);\r\n  }\r\n}\r\n/**\r\n * * Options to control method `RegionOps.consolidateAdjacentPrimitives`\r\n * @public\r\n */\r\nexport class ConsolidateAdjacentCurvePrimitivesOptions {\r\n  /** True to consolidated linear geometry   (e.g. separate LineSegment3d and LineString3d) into LineString3d */\r\n  public consolidateLinearGeometry: boolean = true;\r\n  /** True to consolidate contiguous arcs */\r\n  public consolidateCompatibleArcs: boolean = true;\r\n  /** Tolerance for collapsing identical points */\r\n  public duplicatePointTolerance = Geometry.smallMetricDistance;\r\n  /** Tolerance for removing interior colinear points. */\r\n  public colinearPointTolerance = Geometry.smallMetricDistance;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { CurveLocationDetailArrayPair, CurveCurveIntersectXY } from \"./CurveCurveIntersectXY\";\r\nimport { CurveCurveIntersectXYZ } from \"./CurveCurveIntersectXYZ\";\r\nimport { CurveCollection } from \"./CurveCollection\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { CurveLocationDetailPair } from \"./CurveLocationDetail\";\r\n/** @module Curve */\r\n/**\r\n * `CurveCurve` has static method for various computations that work on a pair of curves or curve collections.\r\n * @public\r\n */\r\nexport class CurveCurve {\r\n  /**\r\n   * Return xy intersections of 2 curves.\r\n   * @param geometryA second geometry\r\n   * @param extendA true to allow geometryA to extend\r\n   * @param geometryB second geometry\r\n   * @param extendB true to allow geometryB to extend\r\n   * @deprecated Use CurveCurve.intersectionXYPairs (..) to get results in preferred directly paired form.\r\n   */\r\n  public static intersectionXY(geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean): CurveLocationDetailArrayPair {\r\n    const handler = new CurveCurveIntersectXY(undefined, geometryA, extendA, geometryB, extendB);\r\n    geometryA.dispatchToGeometryHandler(handler);\r\n    return handler.grabResults();\r\n  }\r\n  /**\r\n   * Return xy intersections of 2 curves.\r\n   * @param geometryA second geometry\r\n   * @param extendA true to allow geometryA to extend\r\n   * @param geometryB second geometry\r\n   * @param extendB true to allow geometryB to extend\r\n   */\r\n  public static intersectionXYPairs(geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean): CurveLocationDetailPair[] {\r\n    const handler = new CurveCurveIntersectXY(undefined, geometryA, extendA, geometryB, extendB);\r\n    if (geometryB instanceof CurvePrimitive) {\r\n      geometryA.dispatchToGeometryHandler(handler);\r\n    } else if (geometryB instanceof CurveCollection) {\r\n      const allCurves = geometryB.collectCurvePrimitives();\r\n      for (const child of allCurves) {\r\n        handler.resetGeometry(geometryA, false, child, false);\r\n        geometryA.dispatchToGeometryHandler(handler);\r\n      }\r\n    }\r\n    return handler.grabPairedResults();\r\n  }\r\n  /**\r\n   * Return xy intersections of 2 projected curves\r\n   * @param geometryA second geometry\r\n   * @param extendA true to allow geometryA to extend\r\n   * @param geometryB second geometry\r\n   * @param extendB true to allow geometryB to extend\r\n   */\r\n  public static intersectionProjectedXY(worldToLocal: Matrix4d, geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean): CurveLocationDetailArrayPair {\r\n    const handler = new CurveCurveIntersectXY(worldToLocal, geometryA, extendA, geometryB, extendB);\r\n    geometryA.dispatchToGeometryHandler(handler);\r\n    return handler.grabResults();\r\n  }\r\n  /**\r\n   * Return full 3d xyz intersections of 2 curves.\r\n   *  * Implemented for combinations of LineSegment3d, LineString3d, Arc3d.\r\n   *  * Not Implemented for bspline and bezier curves.\r\n   * @beta\r\n   * @param geometryA second geometry\r\n   * @param extendA true to allow geometryA to extend\r\n   * @param geometryB second geometry\r\n   * @param extendB true to allow geometryB to extend\r\n   */\r\n  public static intersectionXYZ(geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean): CurveLocationDetailArrayPair {\r\n    const handler = new CurveCurveIntersectXYZ(geometryA, extendA, geometryB, extendB);\r\n    geometryA.dispatchToGeometryHandler(handler);\r\n    return handler.grabResults();\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { NullGeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { CurveLocationDetail, CurveIntervalRole, CurveLocationDetailPair } from \"./CurveLocationDetail\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { LineString3d } from \"./LineString3d\";\r\n// import { Arc3d } from \"./Arc3d\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\n// import { LineString3d } from \"./LineString3d\";\r\nimport { SmallSystem, AnalyticRoots, TrigPolynomial } from \"../numerics/Polynomials\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Arc3d } from \"./Arc3d\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { BSplineCurve3d, BSplineCurve3dBase } from \"../bspline/BSplineCurve\";\r\nimport { BezierCurveBase } from \"../bspline/BezierCurveBase\";\r\nimport { BezierCurve3dH } from \"../bspline/BezierCurve3dH\";\r\nimport { UnivariateBezier } from \"../numerics/BezierPolynomials\";\r\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { NewtonEvaluatorRRtoRRD, Newton2dUnboundedWithDerivative } from \"../numerics/Newton\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\n// cspell:word XYRR\r\n/**\r\n * * Private class for refining bezier-bezier intersections.\r\n * * The inputs are assumed pre-transformed so that the target condition is to match x and y coordinates.\r\n * @public\r\n */\r\nclass BezierBezierIntersectionXYRRToRRD extends NewtonEvaluatorRRtoRRD {\r\n  private _curveA: BezierCurveBase;\r\n  private _curveB: BezierCurveBase;\r\n  constructor(curveA: BezierCurveBase, curveB: BezierCurveBase) {\r\n    super();\r\n    this._curveA = curveA;\r\n    this._curveB = curveB;\r\n    this._rayA = Ray3d.createZero();\r\n    this._rayB = Ray3d.createZero();\r\n\r\n  }\r\n  private _rayA: Ray3d;\r\n  private _rayB: Ray3d;\r\n  public evaluate(fractionA: number, fractionB: number): boolean {\r\n    this._curveA.fractionToPointAndDerivative(fractionA, this._rayA);\r\n    this._curveB.fractionToPointAndDerivative(fractionB, this._rayB);\r\n    this.currentF.setOriginAndVectorsXYZ(\r\n      this._rayB.origin.x - this._rayA.origin.x, this._rayB.origin.y - this._rayA.origin.y, 0.0,\r\n      -this._rayA.direction.x, -this._rayA.direction.y, 0.0,\r\n      this._rayB.direction.x, this._rayB.direction.y, 0.0);\r\n    return true;\r\n  }\r\n}\r\n/**\r\n * Data bundle for a pair of arrays of CurveLocationDetail structures such as produced by CurveCurve,IntersectXY and\r\n * CurveCurve.ClosestApproach\r\n * @public\r\n */\r\nexport class CurveLocationDetailArrayPair {\r\n  /** first array of details ... */\r\n  public dataA: CurveLocationDetail[];\r\n  /** second array of details ... */\r\n  public dataB: CurveLocationDetail[];\r\n  public constructor() {\r\n    this.dataA = [];\r\n    this.dataB = [];\r\n  }\r\n}\r\n/**\r\n * * Instances are initialized and called from CurveCurve.\r\n * * Constructor is told two geometry items A and B\r\n *   * geometryB is saved for later reference\r\n *   * type-specific handler methods will \"see\" geometry A repeatedly.\r\n *   * Hence geometryA is NOT saved by the constructor.\r\n * @internal\r\n */\r\nexport class CurveCurveIntersectXY extends NullGeometryHandler {\r\n  // private geometryA: GeometryQuery;  // nb never used -- passed through handlers.\r\n  private _extendA: boolean;\r\n  private _geometryB: GeometryQuery;\r\n  private _extendB: boolean;\r\n  private _results!: CurveLocationDetailPair[];\r\n  private _worldToLocalPerspective: Matrix4d | undefined;\r\n  private _worldToLocalAffine: Transform | undefined;\r\n  private reinitialize() {\r\n    this._results = [];\r\n  }\r\n\r\n  /**\r\n   * @param worldToLocal optional transform (possibly perspective) to project to xy plane for intersection.\r\n   * @param _geometryA first curve for intersection.  This is NOT saved.\r\n   * @param extendA flag to enable using extension of geometryA.\r\n   * @param geometryB second curve for intersection.  Saved for reference by specific handler methods.\r\n   * @param extendB flag for extension of geometryB.\r\n   */\r\n  public constructor(worldToLocal: Matrix4d | undefined, _geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean) {\r\n    super();\r\n    // this.geometryA = _geometryA;\r\n    this._extendA = extendA;\r\n    this._geometryB = geometryB;\r\n    this._extendB = extendB;\r\n    this._worldToLocalPerspective = undefined;\r\n    this._worldToLocalAffine = undefined;\r\n    if (worldToLocal !== undefined && !worldToLocal.isIdentity()) {\r\n      this._worldToLocalAffine = worldToLocal.asTransform;\r\n      if (!this._worldToLocalAffine)\r\n        this._worldToLocalPerspective = worldToLocal.clone();\r\n    }\r\n    this.reinitialize();\r\n  }\r\n  /** Reset the geometry flags, leaving all other parts unchanged (and preserving accumulated intersections) */\r\n  public resetGeometry(_geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean) {\r\n    this._extendA = extendA;\r\n    this._geometryB = geometryB;\r\n    this._extendB = extendB;\r\n  }\r\n  /**\r\n   * * Return the results structure for the intersection calculation, structured as two separate arrays of CurveLocationDetail.\r\n   * @deprecated use `CurveCurveIntersectXY.grabPairedResults` instead of `CurveCurveIntersectXY.grabResults`\r\n   * @param reinitialize if true, a new results structure is created for use by later calls.\r\n   *\r\n   */\r\n  public grabResults(reinitialize: boolean = false): CurveLocationDetailArrayPair {\r\n    const resultPairs = this._results;\r\n    if (reinitialize)\r\n      this.reinitialize();\r\n    const oldResult = new CurveLocationDetailArrayPair();\r\n    for (const pair of resultPairs) {\r\n      oldResult.dataA.push(pair.detailA);\r\n      oldResult.dataB.push(pair.detailB);\r\n    }\r\n    return oldResult;\r\n\r\n  }\r\n\r\n  private static _workVector2dA = Vector2d.create();\r\n\r\n  private acceptFraction(extend0: boolean, fraction: number, extend1: boolean) {\r\n    if (!extend0 && fraction < 0.0)\r\n      return false;\r\n    if (!extend1 && fraction > 1.0)\r\n      return false;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * * Return the results structure for the intersection calculation, structured as an array of CurveLocationDetailPair\r\n   * @param reinitialize if true, a new results structure is created for use by later calls.\r\n   *\r\n   */\r\n  public grabPairedResults(reinitialize: boolean = false): CurveLocationDetailPair[] {\r\n    const result = this._results;\r\n    if (reinitialize)\r\n      this.reinitialize();\r\n    return result;\r\n  }\r\n  /** compute intersection of two line segments.\r\n   * filter by extension rules.\r\n   * record with fraction mapping.\r\n   */\r\n  private recordPointWithLocalFractions(\r\n    localFractionA: number,\r\n    cpA: CurvePrimitive,\r\n    fractionA0: number,\r\n    fractionA1: number,\r\n    localFractionB: number,   // Computed intersection fraction\r\n    cpB: CurvePrimitive,\r\n    fractionB0: number,\r\n    fractionB1: number,\r\n    reversed: boolean,\r\n  ) {\r\n    const globalFractionA = Geometry.interpolate(fractionA0, localFractionA, fractionA1);\r\n    const globalFractionB = Geometry.interpolate(fractionB0, localFractionB, fractionB1);\r\n    // ignore duplicate of most recent point .  ..\r\n    const numPrevious = this._results.length;\r\n    if (numPrevious > 0) {\r\n      const topFractionA = this._results[numPrevious - 1].detailA.fraction;\r\n      const topFractionB = this._results[numPrevious - 1].detailB.fraction;\r\n      if (reversed) {\r\n        if (Geometry.isAlmostEqualNumber(topFractionA, globalFractionB) && Geometry.isAlmostEqualNumber(topFractionB, globalFractionA))\r\n          return;\r\n      } else {\r\n        if (Geometry.isAlmostEqualNumber(topFractionA, globalFractionA) && Geometry.isAlmostEqualNumber(topFractionB, globalFractionB))\r\n          return;\r\n      }\r\n    }\r\n    const detailA = CurveLocationDetail.createCurveFractionPoint(cpA,\r\n      globalFractionA, cpA.fractionToPoint(globalFractionA));\r\n    detailA.setIntervalRole(CurveIntervalRole.isolated);\r\n    const detailB = CurveLocationDetail.createCurveFractionPoint(cpB,\r\n      globalFractionB, cpB.fractionToPoint(globalFractionB));\r\n    detailB.setIntervalRole(CurveIntervalRole.isolated);\r\n    if (reversed) {\r\n      this._results.push(new CurveLocationDetailPair(detailB, detailA));\r\n    } else {\r\n      this._results.push(new CurveLocationDetailPair(detailA, detailB));\r\n    }\r\n  }\r\n  /** compute intersection of two line segments.\r\n   * filter by extension rules.\r\n   * record with fraction mapping.\r\n   */\r\n  private computeSegmentSegment3D(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    cpB: CurvePrimitive,\r\n    extendB0: boolean,\r\n    pointB0: Point3d,\r\n    fractionB0: number,\r\n    pointB1: Point3d,\r\n    fractionB1: number,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n\r\n    const uv = CurveCurveIntersectXY._workVector2dA;\r\n    if (SmallSystem.lineSegment3dXYTransverseIntersectionUnbounded(\r\n      pointA0, pointA1,\r\n      pointB0, pointB1, uv)\r\n      && this.acceptFraction(extendA0, uv.x, extendA1)\r\n      && this.acceptFraction(extendB0, uv.y, extendB1)\r\n    ) {\r\n      this.recordPointWithLocalFractions(uv.x, cpA, fractionA0, fractionA1, uv.y, cpB, fractionB0, fractionB1, reversed);\r\n    }\r\n  }\r\n  private static _workPointA0H = Point4d.create();\r\n  private static _workPointA1H = Point4d.create();\r\n  private static _workPointB0H = Point4d.create();\r\n  private static _workPointB1H = Point4d.create();\r\n  // intersection of PROJECTED homogeneous segments ...  assumes caller knows the _worldToLocal is present\r\n  private computeSegmentSegment3DH(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    cpB: CurvePrimitive,\r\n    extendB0: boolean,\r\n    pointB0: Point3d,\r\n    fractionB0: number,\r\n    pointB1: Point3d,\r\n    fractionB1: number,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    const hA0 = CurveCurveIntersectXY._workPointA0H;\r\n    const hA1 = CurveCurveIntersectXY._workPointA1H;\r\n    const hB0 = CurveCurveIntersectXY._workPointB0H;\r\n    const hB1 = CurveCurveIntersectXY._workPointB1H;\r\n    this._worldToLocalPerspective!.multiplyPoint3d(pointA0, 1, hA0);\r\n    this._worldToLocalPerspective!.multiplyPoint3d(pointA1, 1, hA1);\r\n    this._worldToLocalPerspective!.multiplyPoint3d(pointB0, 1, hB0);\r\n    this._worldToLocalPerspective!.multiplyPoint3d(pointB1, 1, hB1);\r\n    const fractionAB = SmallSystem.lineSegment3dHXYTransverseIntersectionUnbounded(hA0, hA1, hB0, hB1);\r\n    if (fractionAB !== undefined) {\r\n      const fractionA = fractionAB.x;\r\n      const fractionB = fractionAB.y;\r\n      if (this.acceptFraction(extendA0, fractionA, extendA1) && this.acceptFraction(extendB0, fractionB, extendB1)) {\r\n        // final fraction acceptance uses original world points, with perspective-aware fractions\r\n        this.recordPointWithLocalFractions(fractionA, cpA, fractionA0, fractionA1,\r\n          fractionB, cpB, fractionB0, fractionB1, reversed);\r\n      }\r\n    }\r\n  }\r\n  // Caller accesses data from a line segment and passes to here.\r\n  // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.  The fraction and extend parameters\r\n  // allow all combinations to be passed in)\r\n  // This method applies transform.\r\n  private dispatchSegmentSegment(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    cpB: CurvePrimitive,\r\n    extendB0: boolean,\r\n    pointB0: Point3d,\r\n    fractionB0: number,\r\n    pointB1: Point3d,\r\n    fractionB1: number,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    if (this._worldToLocalAffine) {\r\n      // non-perspective projection\r\n      CurveCurveIntersectXY.setTransformedWorkPoints(this._worldToLocalAffine, pointA0, pointA1, pointB0, pointB1);\r\n      this.computeSegmentSegment3D(\r\n        cpA, extendA0, CurveCurveIntersectXY._workPointA0, fractionA0, CurveCurveIntersectXY._workPointA1, fractionA1, extendA1,\r\n        cpB, extendB0, CurveCurveIntersectXY._workPointB0, fractionB0, CurveCurveIntersectXY._workPointB1, fractionB1, extendB1,\r\n        reversed);\r\n    } else if (this._worldToLocalPerspective) {\r\n      this.computeSegmentSegment3DH(\r\n        cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1,\r\n        cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1,\r\n        reversed);\r\n    } else {\r\n      this.computeSegmentSegment3D(\r\n        cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1,\r\n        cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1,\r\n        reversed);\r\n    }\r\n  }\r\n\r\n  // Caller accesses data from a linestring or segment and passes it here.\r\n  // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.  The fraction and extend parameters\r\n  // allow all combinations to be passed in)\r\n  private dispatchSegmentArc(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    arc: Arc3d,\r\n    extendB0: boolean,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    // Arc: X = C + cU + sV\r\n    // Line:  contains points A0,A1\r\n    // Arc point colinear with line if det (A0, A1, X) = 0\r\n    // with homogeneous xyw points and vectors.\r\n    // With equational X:   det (A0, A1, C) + c det (A0, A1,U) + s det (A0, A1, V) = 0.\r\n    // solve for theta.\r\n    // evaluate points.\r\n    // project back to line.\r\n    if (this._worldToLocalPerspective) {\r\n      const data = arc.toTransformedPoint4d(this._worldToLocalPerspective);\r\n      const pointA0H = this._worldToLocalPerspective.multiplyPoint3d(pointA0, 1);\r\n      const pointA1H = this._worldToLocalPerspective.multiplyPoint3d(pointA1, 1);\r\n      const alpha = Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.center);\r\n      const beta = Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.vector0);\r\n      const gamma = Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.vector90);\r\n      const cosines = new GrowableFloat64Array(2);\r\n      const sines = new GrowableFloat64Array(2);\r\n      const radians = new GrowableFloat64Array(2);\r\n      const numRoots = AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosines, sines, radians);\r\n      for (let i = 0; i < numRoots; i++) {\r\n        const arcPoint = data.center.plus2Scaled(data.vector0, cosines.atUncheckedIndex(i), data.vector90, sines.atUncheckedIndex(i));\r\n        const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.atUncheckedIndex(i));\r\n        const lineFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, arcPoint);\r\n        if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB0, arcFraction, extendB1)) {\r\n          this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1,\r\n            arcFraction, arc, 0, 1, reversed);\r\n        }\r\n      }\r\n    } else {\r\n      const data = arc.toTransformedVectors(this._worldToLocalAffine);\r\n      let pointA0Local = pointA0;\r\n      let pointA1Local = pointA1;\r\n      if (this._worldToLocalAffine) {\r\n        pointA0Local = this._worldToLocalAffine.multiplyPoint3d(pointA0);\r\n        pointA1Local = this._worldToLocalAffine.multiplyPoint3d(pointA1);\r\n      }\r\n      const alpha = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.center, 1);\r\n      const beta = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector0, 0);\r\n      const gamma = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector90, 0);\r\n      const cosines = new GrowableFloat64Array(2);\r\n      const sines = new GrowableFloat64Array(2);\r\n      const radians = new GrowableFloat64Array(2);\r\n      const numRoots = AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosines, sines, radians);\r\n      for (let i = 0; i < numRoots; i++) {\r\n        const arcPoint = data.center.plus2Scaled(data.vector0, cosines.atUncheckedIndex(i), data.vector90, sines.atUncheckedIndex(i));\r\n        const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.atUncheckedIndex(i));\r\n        const lineFraction = SmallSystem.lineSegment3dXYClosestPointUnbounded(pointA0Local, pointA1Local, arcPoint);\r\n        if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB0, arcFraction, extendB1)) {\r\n          this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1,\r\n            arcFraction, arc, 0, 1, reversed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Caller accesses data from two arcs.\r\n  // each matrix has [U V C] in (x,y,w) form from projection.\r\n  // invert the projection matrix matrixA.\r\n  // apply the inverse to matrixB. Then arc b is an ellipse in the circular space of A\r\n\r\n  private dispatchArcArcThisOrder(\r\n    cpA: Arc3d,\r\n    matrixA: Matrix3d,  // homogeneous xyw projection !!!\r\n    extendA: boolean,\r\n    cpB: Arc3d,\r\n    matrixB: Matrix3d,  // homogeneous xyw projection !!!\r\n    extendB: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    const inverseA = matrixA.inverse();\r\n    if (inverseA) {\r\n      const localB = inverseA.multiplyMatrixMatrix(matrixB);\r\n      const ellipseRadians: number[] = [];\r\n      const circleRadians: number[] = [];\r\n      TrigPolynomial.solveUnitCircleHomogeneousEllipseIntersection(\r\n        localB.coffs[2], localB.coffs[5], localB.coffs[8],  // center xyw\r\n        localB.coffs[0], localB.coffs[3], localB.coffs[6],  // center xyw\r\n        localB.coffs[1], localB.coffs[4], localB.coffs[7],  // center xyw\r\n        ellipseRadians, circleRadians);\r\n      for (let i = 0; i < ellipseRadians.length; i++) {\r\n        const fractionA = cpA.sweep.radiansToSignedPeriodicFraction(circleRadians[i]);\r\n        const fractionB = cpB.sweep.radiansToSignedPeriodicFraction(ellipseRadians[i]);\r\n        // hm .. do we really need to check the fractions?  We know they are internal to the beziers\r\n        if (this.acceptFraction(extendA, fractionA, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n          this.recordPointWithLocalFractions(fractionA, cpA, 0, 1,\r\n            fractionB, cpB, 0, 1, reversed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Caller accesses data from two arcs.\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchArcArc(\r\n    cpA: Arc3d,\r\n    extendA: boolean,\r\n    cpB: Arc3d,\r\n    extendB: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    // Arc: X = C + cU + sV\r\n    // Line:  contains points A0,A1\r\n    // Arc point colinear with line if det (A0, A1, X) = 0\r\n    // with homogeneous xyw points and vectors.\r\n    // With equational X:   det (A0, A1, C) + c det (A0, A1,U) + s det (A0, A1, V) = 0.\r\n    // solve for theta.\r\n    // evaluate points.\r\n    // project back to line.\r\n    let matrixA: Matrix3d;\r\n    let matrixB: Matrix3d;\r\n    if (this._worldToLocalPerspective) {\r\n      const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);\r\n      const dataB = cpB.toTransformedPoint4d(this._worldToLocalPerspective);\r\n      matrixA = Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);\r\n      matrixB = Matrix3d.createColumnsXYW(dataB.vector0, dataB.vector0.w, dataB.vector90, dataA.vector90.w, dataB.center, dataB.center.w);\r\n    } else {\r\n      const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);\r\n      const dataB = cpB.toTransformedVectors(this._worldToLocalAffine);\r\n      matrixA = Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);\r\n      matrixB = Matrix3d.createColumnsXYW(dataB.vector0, 0, dataB.vector90, 0, dataB.center, 1);\r\n    }\r\n    const conditionA = matrixA.conditionNumber();\r\n    const conditionB = matrixB.conditionNumber();\r\n    if (conditionA > conditionB)\r\n      this.dispatchArcArcThisOrder(cpA, matrixA, extendA, cpB, matrixB, extendB, reversed);\r\n    else\r\n      this.dispatchArcArcThisOrder(cpB, matrixB, extendB, cpA, matrixA, extendA, !reversed);\r\n  }\r\n  // Caller accesses data from two arcs.\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchArcBsplineCurve3d(\r\n    cpA: Arc3d,\r\n    extendA: boolean,\r\n    cpB: BSplineCurve3d,\r\n    extendB: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    // Arc: X = C + cU + sV\r\n    // implicitize the arc as viewed.  This \"3d\" matrix is homogeneous \"XYW\" not \"xyz\"\r\n    let matrixA: Matrix3d;\r\n    if (this._worldToLocalPerspective) {\r\n      const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);\r\n      matrixA = Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);\r\n    } else {\r\n      const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);\r\n      matrixA = Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);\r\n    }\r\n    // The worldToLocal has moved the arc vectors into screen space.\r\n    // matrixA captures the xyw parts (ignoring z)\r\n    // for any point in world space,\r\n    // THIS CODE ONLY WORKS FOR\r\n    const matrixAInverse = matrixA.inverse();\r\n    if (matrixAInverse) {\r\n      const orderF = cpB.order; // order of the beziers for simple coordinates\r\n      const orderG = 2 * orderF - 1;  // order of the (single) bezier for squared coordinates.\r\n      const coffF = new Float64Array(orderF);\r\n      const univariateBezierG = new UnivariateBezier(orderG);\r\n      const axx = matrixAInverse.at(0, 0); const axy = matrixAInverse.at(0, 1); const axz = 0.0; const axw = matrixAInverse.at(0, 2);\r\n      const ayx = matrixAInverse.at(1, 0); const ayy = matrixAInverse.at(1, 1); const ayz = 0.0; const ayw = matrixAInverse.at(1, 2);\r\n      const awx = matrixAInverse.at(2, 0); const awy = matrixAInverse.at(2, 1); const awz = 0.0; const aww = matrixAInverse.at(2, 2);\r\n\r\n      if (matrixAInverse) {\r\n        let bezier: BezierCurve3dH | undefined;\r\n        for (let spanIndex = 0; ; spanIndex++) {\r\n          bezier = cpB.getSaturatedBezierSpan3dH(spanIndex, bezier);\r\n          if (!bezier) break;\r\n          if (this._worldToLocalPerspective)\r\n            bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);\r\n          else if (this._worldToLocalAffine)\r\n            bezier.tryTransformInPlace(this._worldToLocalAffine);\r\n          univariateBezierG.zero();\r\n          bezier.poleProductsXYZW(coffF, axx, axy, axz, axw);\r\n          univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);\r\n          bezier.poleProductsXYZW(coffF, ayx, ayy, ayz, ayw);\r\n          univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);\r\n          bezier.poleProductsXYZW(coffF, awx, awy, awz, aww);\r\n          univariateBezierG.addSquaredSquaredBezier(coffF, -1.0);\r\n          const roots = univariateBezierG.roots(0.0, true);\r\n          if (roots) {\r\n            for (const root of roots) {\r\n              const fractionB = bezier.fractionToParentFraction(root);\r\n              // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space\r\n              const bcurvePoint4d = bezier.fractionToPoint4d(root);\r\n              const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);\r\n              const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);\r\n              const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));\r\n              if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n                this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,\r\n                  fractionB, cpB, 0, 1, reversed);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /** apply the transformation to bezier curves. optionally construct ranges.\r\n   *\r\n   */\r\n  private transformBeziers(beziers: BezierCurve3dH[]) {\r\n    if (this._worldToLocalAffine) {\r\n      for (const bezier of beziers) bezier.tryTransformInPlace(this._worldToLocalAffine);\r\n    } else if (this._worldToLocalPerspective) {\r\n      for (const bezier of beziers) bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);\r\n    }\r\n  }\r\n  private getRanges(beziers: BezierCurveBase[]): Range3d[] {\r\n    const ranges: Range3d[] = [];\r\n    ranges.length = 0;\r\n    for (const b of beziers) {\r\n      ranges.push(b.range());\r\n    }\r\n    return ranges;\r\n  }\r\n  private _xyzwA0?: Point4d;\r\n  private _xyzwA1?: Point4d;\r\n  private _xyzwPlane?: Point4d;\r\n  private _xyzwB?: Point4d;\r\n\r\n  private dispatchBezierBezierStrokeFirst(\r\n    bezierA: BezierCurve3dH,\r\n    bcurveA: BSplineCurve3dBase,\r\n    strokeCountA: number,\r\n    bezierB: BezierCurve3dH,\r\n    bcurveB: BSplineCurve3dBase,\r\n    _strokeCountB: number,\r\n    univariateBezierB: UnivariateBezier,  // caller-allocated for univariate coefficients.\r\n    reversed: boolean) {\r\n    if (!this._xyzwA0) this._xyzwA0 = Point4d.create();\r\n    if (!this._xyzwA1) this._xyzwA1 = Point4d.create();\r\n    if (!this._xyzwPlane) this._xyzwPlane = Point4d.create();\r\n    if (!this._xyzwB) this._xyzwB = Point4d.create();\r\n    /*\r\n\r\n              const roots = univariateBezierG.roots(0.0, true);\r\n              if (roots) {\r\n                for (const root of roots) {\r\n                  const fractionB = bezier.fractionToParentFraction(root);\r\n                  // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space\r\n                  const bcurvePoint4d = bezier.fractionToPoint4d(root);\r\n                  const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);\r\n                  const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);\r\n                  const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));\r\n                  if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n                    this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,\r\n                      fractionB, cpB, 0, 1, reversed);\r\n                  }\r\n                }\r\n    */\r\n    bezierA.fractionToPoint4d(0.0, this._xyzwA0);\r\n    let f0 = 0.0;\r\n    let f1 = 1.0;\r\n    const intervalTolerance = 1.0e-5;\r\n    const df = 1.0 / strokeCountA;\r\n    for (let i = 1; i <= strokeCountA; i++ , f0 = f1, this._xyzwA0.setFrom(this._xyzwA1)) {\r\n      f1 = i * df;\r\n      bezierA.fractionToPoint4d(f1, this._xyzwA1);\r\n      Point4d.createPlanePointPointZ(this._xyzwA0, this._xyzwA1, this._xyzwPlane);\r\n      bezierB.poleProductsXYZW(univariateBezierB.coffs, this._xyzwPlane.x, this._xyzwPlane.y, this._xyzwPlane.z, this._xyzwPlane.w);\r\n      let errors = 0;\r\n      const roots = univariateBezierB.roots(0.0, true);\r\n      if (roots)\r\n        for (const r of roots) {\r\n          let bezierBFraction = r;\r\n          bezierB.fractionToPoint4d(bezierBFraction, this._xyzwB);\r\n          const segmentAFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0, this._xyzwA1, this._xyzwB);\r\n          if (segmentAFraction && Geometry.isIn01WithTolerance(segmentAFraction, intervalTolerance)) {\r\n            let bezierAFraction = Geometry.interpolate(f0, segmentAFraction, f1);\r\n            const xyMatchingFunction = new BezierBezierIntersectionXYRRToRRD(bezierA, bezierB);\r\n            const newtonSearcher = new Newton2dUnboundedWithDerivative(xyMatchingFunction);\r\n            newtonSearcher.setUV(bezierAFraction, bezierBFraction);\r\n            if (newtonSearcher.runIterations()) {\r\n              bezierAFraction = newtonSearcher.getU();\r\n              bezierBFraction = newtonSearcher.getV();\r\n            }\r\n            // We have a near intersection at fractions on the two beziers !!!\r\n            // Iterate on the curves for a true intersection ....\r\n            // NEEDS WORK -- just accept . . .\r\n            const bcurveAFraction = bezierA.fractionToParentFraction(bezierAFraction);\r\n            const bcurveBFraction = bezierB.fractionToParentFraction(bezierBFraction);\r\n            const xyzA0 = bezierA.fractionToPoint(bezierAFraction);\r\n            const xyzA1 = bcurveA.fractionToPoint(bcurveAFraction);\r\n            const xyzB0 = bezierB.fractionToPoint(bezierBFraction);\r\n            const xyzB1 = bcurveB.fractionToPoint(bcurveBFraction);\r\n            if (!xyzA0.isAlmostEqualXY(xyzA1))\r\n              errors++;\r\n            if (!xyzB0.isAlmostEqualXY(xyzB1))\r\n              errors++;\r\n            if (errors > 0 && !xyzA0.isAlmostEqual(xyzB0))\r\n              errors++;\r\n            if (errors > 0 && !xyzA1.isAlmostEqual(xyzB1))\r\n              errors++;\r\n            if (this.acceptFraction(false, bcurveAFraction, false) && this.acceptFraction(false, bcurveBFraction, false)) {\r\n              this.recordPointWithLocalFractions(bcurveAFraction, bcurveA, 0, 1,\r\n                bcurveBFraction, bcurveB, 0, 1, reversed);\r\n            }\r\n          }\r\n        }\r\n    }\r\n  }\r\n  // Caller accesses data from two arcs.\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchBSplineCurve3dBSplineCurve3d(\r\n    bcurveA: BSplineCurve3dBase,\r\n    bcurveB: BSplineCurve3dBase,\r\n    _reversed: boolean) {\r\n    const bezierSpanA = bcurveA.collectBezierSpans(true) as BezierCurve3dH[];\r\n    const bezierSpanB = bcurveB.collectBezierSpans(true) as BezierCurve3dH[];\r\n    const numA = bezierSpanA.length;\r\n    const numB = bezierSpanB.length;\r\n    this.transformBeziers(bezierSpanA);\r\n    this.transformBeziers(bezierSpanB);\r\n    const rangeA = this.getRanges(bezierSpanA);\r\n    const rangeB = this.getRanges(bezierSpanB);\r\n    const orderA = bcurveA.order;\r\n    const orderB = bcurveB.order;\r\n    const univariateCoffsA = new UnivariateBezier(orderA);\r\n    const univariateCoffsB = new UnivariateBezier(orderB);\r\n    for (let a = 0; a < numA; a++) {\r\n      for (let b = 0; b < numB; b++) {\r\n        if (rangeA[a].intersectsRangeXY(rangeB[b])) {\r\n          const strokeCountA = bezierSpanA[a].computeStrokeCountForOptions();\r\n          const strokeCountB = bezierSpanB[b].computeStrokeCountForOptions();\r\n          if (strokeCountA < strokeCountB)\r\n            this.dispatchBezierBezierStrokeFirst(bezierSpanA[a], bcurveA, strokeCountA, bezierSpanB[b], bcurveB, strokeCountB, univariateCoffsB, !_reversed);\r\n          else\r\n            this.dispatchBezierBezierStrokeFirst(bezierSpanB[b], bcurveB, strokeCountB, bezierSpanA[a], bcurveA, strokeCountA, univariateCoffsA, _reversed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply the projection transform (if any) to (xyz, w)\r\n   * @param xyz xyz parts of input point.\r\n   * @param w   weight to use for homogeneous effects\r\n   */\r\n  private projectPoint(xyz: XYAndZ, w: number = 1.0): Point4d {\r\n    if (this._worldToLocalPerspective)\r\n      return this._worldToLocalPerspective.multiplyPoint3d(xyz, w);\r\n    if (this._worldToLocalAffine)\r\n      return this._worldToLocalAffine.multiplyXYZW(xyz.x, xyz.y, xyz.z, w);\r\n    return Point4d.createFromPointAndWeight(xyz, w);\r\n  }\r\n  private mapNPCPlaneToWorld(npcPlane: Point4d, worldPlane: Point4d) {\r\n    // for NPC pointY, Y^ * H = 0 is \"on\" plane H.  (Hat is transpose)\r\n    // NPC Y is A*X for our transform A and worldPointX.\r\n    // hence (A X)^ * H = 0\r\n    // hence X^ * A^ * H = 0\r\n    // hence K = A^ * H\r\n    if (this._worldToLocalAffine) {\r\n      this._worldToLocalAffine.multiplyTransposeXYZW(npcPlane.x, npcPlane.y, npcPlane.z, npcPlane.w, worldPlane);\r\n    } else if (this._worldToLocalPerspective) {\r\n      this._worldToLocalPerspective.multiplyTransposePoint4d(npcPlane, worldPlane);\r\n    } else {\r\n      npcPlane.clone(worldPlane);\r\n    }\r\n  }\r\n  // Caller accesses data from segment and bsplineCurve\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchSegmentBsplineCurve(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    bcurve: BSplineCurve3d,\r\n    extendB: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    const pointA0H = this.projectPoint(pointA0);\r\n    const pointA1H = this.projectPoint(pointA1);\r\n    const planeCoffs = Point4d.createPlanePointPointZ(pointA0H, pointA1H);\r\n    this.mapNPCPlaneToWorld(planeCoffs, planeCoffs);\r\n    // NOW .. we have a plane in world space.  Intersect it with the bspline:\r\n    const intersections: CurveLocationDetail[] = [];\r\n    bcurve.appendPlaneIntersectionPoints(planeCoffs, intersections);\r\n    // intersections has WORLD points with bspline fractions.   (The bspline fractions are all good 0..1 fractions within the spline.)\r\n    // accept those that are within the segment range.\r\n    for (const detail of intersections) {\r\n      const fractionB = detail.fraction;\r\n      const curvePoint = detail.point;\r\n      const curvePointH = this.projectPoint(curvePoint);\r\n      const lineFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, curvePointH);\r\n      if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n        this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1,\r\n          fractionB, bcurve, 0, 1, reversed);\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _workPointAA0 = Point3d.create();\r\n  private static _workPointAA1 = Point3d.create();\r\n  private static _workPointBB0 = Point3d.create();\r\n  private static _workPointBB1 = Point3d.create();\r\n  /** low level dispatch of linestring with (beziers of) a bspline curve */\r\n  public dispatchLineStringBSplineCurve(lsA: LineString3d, extendA: boolean, curveB: BSplineCurve3d, extendB: boolean, reversed: boolean): any {\r\n    const numA = lsA.numPoints();\r\n    if (numA > 1) {\r\n      const dfA = 1.0 / (numA - 1);\r\n      let fA0;\r\n      let fA1;\r\n      fA0 = 0.0;\r\n      const pointA0 = CurveCurveIntersectXY._workPointA0;\r\n      const pointA1 = CurveCurveIntersectXY._workPointA1;\r\n      lsA.pointAt(0, pointA0);\r\n      for (let iA = 1; iA < numA; iA++ , pointA0.setFrom(pointA1), fA0 = fA1) {\r\n        lsA.pointAt(iA, pointA1);\r\n        fA1 = iA * dfA;\r\n        this.dispatchSegmentBsplineCurve(\r\n          lsA, iA === 1 && extendA, pointA0, fA0, pointA1, fA1, (iA + 1) === numA && extendA,\r\n          curveB, extendB, reversed);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Detail computation for segment intersecting linestring. */\r\n  public computeSegmentLineString(lsA: LineSegment3d, extendA: boolean, lsB: LineString3d, extendB: boolean, reversed: boolean): any {\r\n    const pointA0 = lsA.point0Ref;\r\n    const pointA1 = lsA.point1Ref;\r\n    const pointB0 = CurveCurveIntersectXY._workPointBB0;\r\n    const pointB1 = CurveCurveIntersectXY._workPointBB1;\r\n    const numB = lsB.numPoints();\r\n    if (numB > 1) {\r\n      const dfB = 1.0 / (numB - 1);\r\n      let fB0;\r\n      let fB1;\r\n      fB0 = 0.0;\r\n      lsB.pointAt(0, pointB0);\r\n      for (let ib = 1; ib < numB; ib++ , pointB0.setFrom(pointB1), fB0 = fB1) {\r\n        lsB.pointAt(ib, pointB1);\r\n        fB1 = ib * dfB;\r\n        this.dispatchSegmentSegment(\r\n          lsA, extendA, pointA0, 0.0, pointA1, 1.0, extendA,\r\n          lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB,\r\n          reversed);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Detail computation for arcA intersecting lsB. */\r\n  public computeArcLineString(arcA: Arc3d, extendA: boolean, lsB: LineString3d, extendB: boolean, reversed: boolean): any {\r\n    const pointB0 = CurveCurveIntersectXY._workPointBB0;\r\n    const pointB1 = CurveCurveIntersectXY._workPointBB1;\r\n    const numB = lsB.numPoints();\r\n    if (numB > 1) {\r\n      const dfB = 1.0 / (numB - 1);\r\n      let fB0;\r\n      let fB1;\r\n      fB0 = 0.0;\r\n      lsB.pointAt(0, pointB0);\r\n      for (let ib = 1; ib < numB; ib++ , pointB0.setFrom(pointB1), fB0 = fB1) {\r\n        lsB.pointAt(ib, pointB1);\r\n        fB1 = ib * dfB;\r\n        this.dispatchSegmentArc(\r\n          lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB,\r\n          arcA, extendA, extendA,\r\n          !reversed);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private static _workPointA0 = Point3d.create();\r\n  private static _workPointA1 = Point3d.create();\r\n  private static _workPointB0 = Point3d.create();\r\n  private static _workPointB1 = Point3d.create();\r\n  private static setTransformedWorkPoints(transform: Transform, pointA0: Point3d, pointA1: Point3d, pointB0: Point3d, pointB1: Point3d) {\r\n    transform.multiplyPoint3d(pointA0, this._workPointA0);\r\n    transform.multiplyPoint3d(pointA1, this._workPointA1);\r\n    transform.multiplyPoint3d(pointB0, this._workPointB0);\r\n    transform.multiplyPoint3d(pointB1, this._workPointB1);\r\n  }\r\n  /** double dispatch handler for strongly typed segment.. */\r\n  public handleLineSegment3d(segmentA: LineSegment3d): any {\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      const segmentB = this._geometryB;\r\n      this.dispatchSegmentSegment(\r\n        segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA,\r\n        segmentB, this._extendB, segmentB.point0Ref, 0.0, segmentB.point1Ref, 1.0, this._extendB,\r\n        false);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.computeSegmentLineString(segmentA, this._extendA, this._geometryB, this._extendB, false);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchSegmentArc(\r\n        segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA,\r\n        this._geometryB, this._extendB, this._extendB, false);\r\n    } else if (this._geometryB instanceof BSplineCurve3d) {\r\n      this.dispatchSegmentBsplineCurve(\r\n        segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA,\r\n        this._geometryB, this._extendB, false);\r\n    }\r\n  }\r\n\r\n  /** double dispatch handler for strongly typed linestring.. */\r\n  public handleLineString3d(lsA: LineString3d): any {\r\n    if (this._geometryB instanceof LineString3d) {\r\n      const lsB = this._geometryB as LineString3d;\r\n      const pointA0 = CurveCurveIntersectXY._workPointAA0;\r\n      const pointA1 = CurveCurveIntersectXY._workPointAA1;\r\n      const pointB0 = CurveCurveIntersectXY._workPointBB0;\r\n      const pointB1 = CurveCurveIntersectXY._workPointBB1;\r\n      const numA = lsA.numPoints();\r\n      const numB = lsB.numPoints();\r\n      if (numA > 1 && numB > 1) {\r\n        lsA.pointAt(0, pointA0);\r\n        const dfA = 1.0 / (numA - 1);\r\n        const dfB = 1.0 / (numB - 1);\r\n        let fA0 = 0.0;\r\n        let fB0;\r\n        let fA1;\r\n        let fB1;\r\n        const extendA = this._extendA;\r\n        const extendB = this._extendB;\r\n        lsA.pointAt(0, pointA0);\r\n        for (let ia = 1; ia < numA; ia++ , pointA0.setFrom(pointA1), fA0 = fA1) {\r\n          fA1 = ia * dfA;\r\n          fB0 = 0.0;\r\n          lsA.pointAt(ia, pointA1);\r\n          lsB.pointAt(0, pointB0);\r\n          for (let ib = 1; ib < numB; ib++ , pointB0.setFrom(pointB1), fB0 = fB1) {\r\n            lsB.pointAt(ib, pointB1);\r\n            fB1 = ib * dfB;\r\n            this.dispatchSegmentSegment(\r\n              lsA, ia === 1 && extendA, pointA0, fA0, pointA1, fA1, (ia + 1) === numA && extendA,\r\n              lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB,\r\n              false);\r\n          }\r\n        }\r\n      }\r\n    } else if (this._geometryB instanceof LineSegment3d) {\r\n      this.computeSegmentLineString(this._geometryB, this._extendB, lsA, this._extendA, true);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.computeArcLineString(this._geometryB, this._extendB, lsA, this._extendA, true);\r\n    } else if (this._geometryB instanceof BSplineCurve3d) {\r\n      this.dispatchLineStringBSplineCurve(lsA, this._extendA, this._geometryB, this._extendB, false);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** double dispatch handler for strongly typed arc .. */\r\n  public handleArc3d(arc0: Arc3d): any {\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      this.dispatchSegmentArc(\r\n        this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\r\n        arc0, this._extendA, this._extendA, true);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.computeArcLineString(arc0, this._extendA, this._geometryB, this._extendB, false);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchArcArc(arc0, this._extendA, this._geometryB, this._extendB, false);\r\n    } else if (this._geometryB instanceof BSplineCurve3d) {\r\n      this.dispatchArcBsplineCurve3d(arc0, this._extendA, this._geometryB, this._extendB, false);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** double dispatch handler for strongly typed bspline curve .. */\r\n  public handleBSplineCurve3d(curve: BSplineCurve3d): any {\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      this.dispatchSegmentBsplineCurve(\r\n        this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\r\n        curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof BSplineCurve3dBase) {\r\n      this.dispatchBSplineCurve3dBSplineCurve3d(curve, this._geometryB, false);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** double dispatch handler for strongly typed homogeneous bspline curve .. */\r\n  public handleBSplineCurve3dH(_curve: BSplineCurve3dH): any {\r\n    /* NEEDS WORK -- make \"dispatch\" methods tolerant of both 3d and 3dH ...\"easy\" if both present BezierCurve3dH span loaders\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      this.dispatchSegmentBsplineCurve(\r\n        this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\r\n        curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    }\r\n    */\r\n    return undefined;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { NullGeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { CurveLocationDetail, CurveIntervalRole } from \"./CurveLocationDetail\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { LineString3d } from \"./LineString3d\";\r\n// import { Arc3d } from \"./Arc3d\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\n// import { XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\n// import { LineString3d } from \"./LineString3d\";\r\nimport { SmallSystem, TrigPolynomial } from \"../numerics/Polynomials\";\r\n// import { Point4d } from \"../geometry4d/Point4d\";\r\n// import { Transform } from \"../geometry3d/Transform\";\r\n// import { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Arc3d } from \"./Arc3d\";\r\nimport { BSplineCurve3d, BSplineCurve3dBase } from \"../bspline/BSplineCurve\";\r\n// import { BezierCurveBase } from \"../bspline/BezierCurveBase\";\r\n// import { BezierCurve3dH } from \"../bspline/BezierCurve3dH\";\r\n// import { UnivariateBezier } from \"../numerics/BezierPolynomials\";\r\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\r\n// import { Range3d } from \"../geometry3d/Range\";\r\nimport { CurveLocationDetailArrayPair } from \"./CurveCurveIntersectXY\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\n// cspell:word XYRR\r\n/**\r\n * * Handler class for XYZ intersections.\r\n * * Instances are initialized and called from CurveCurve.\r\n * * Constructor is told two geometry items A and B\r\n *   * geometryB is saved for later reference\r\n *   * type-specific handler methods will \"see\" geometry A repeatedly.\r\n *   * Hence geometryA is NOT saved by the constructor.\r\n * @internal\r\n */\r\nexport class CurveCurveIntersectXYZ extends NullGeometryHandler {\r\n  // private geometryA: GeometryQuery;  // nb never used -- passed through handlers.\r\n  private _extendA: boolean;\r\n  private _geometryB: GeometryQuery;\r\n  private _extendB: boolean;\r\n  private _results!: CurveLocationDetailArrayPair;\r\n  private reinitialize() {\r\n    this._results = new CurveLocationDetailArrayPair();\r\n  }\r\n  /**\r\n   *\r\n   * @param _geometryA first curve for intersection.  This is NOT saved.\r\n   * @param extendA flag to enable using extension of geometryA.\r\n   * @param geometryB second curve for intersection.  Saved for reference by specific handler methods.\r\n   * @param extendB flag for extension of geometryB.\r\n   */\r\n  public constructor(_geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean) {\r\n    super();\r\n    // this.geometryA = _geometryA;\r\n    this._extendA = extendA;\r\n    this._geometryB = geometryB;\r\n    this._extendB = extendB;\r\n    this.reinitialize();\r\n  }\r\n  /**\r\n   * * Return the results structure for the intersection calculation.\r\n   * @param reinitialize if true, a new results structure is created for use by later calls.\r\n   *\r\n   */\r\n  public grabResults(reinitialize: boolean = false): CurveLocationDetailArrayPair {\r\n    const result = this._results;\r\n    if (reinitialize)\r\n      this.reinitialize();\r\n    return result;\r\n  }\r\n\r\n  private static _workVector2dA = Vector2d.create();\r\n\r\n  private acceptFraction(extend0: boolean, fraction: number, extend1: boolean) {\r\n    if (!extend0 && fraction < 0.0)\r\n      return false;\r\n    if (!extend1 && fraction > 1.0)\r\n      return false;\r\n    return true;\r\n  }\r\n\r\n  /** compute intersection of two line segments.\r\n   * filter by extension rules.\r\n   * reject if evaluated points do not match coordinates (e.g. close approach point)\r\n   * record with fraction mapping.\r\n   */\r\n  private recordPointWithLocalFractions(\r\n    localFractionA: number,\r\n    cpA: CurvePrimitive,\r\n    fractionA0: number,\r\n    fractionA1: number,\r\n    localFractionB: number,   // Computed intersection fraction\r\n    cpB: CurvePrimitive,\r\n    fractionB0: number,\r\n    fractionB1: number,\r\n    reversed: boolean,\r\n  ) {\r\n    const globalFractionA = Geometry.interpolate(fractionA0, localFractionA, fractionA1);\r\n    const globalFractionB = Geometry.interpolate(fractionB0, localFractionB, fractionB1);\r\n    // ignore duplicate of most recent point .  ..\r\n    const numPrevious = this._results.dataA.length;\r\n    if (numPrevious > 0) {\r\n      const topFractionA = this._results.dataA[numPrevious - 1].fraction;\r\n      const topFractionB = this._results.dataB[numPrevious - 1].fraction;\r\n      if (reversed) {\r\n        if (Geometry.isAlmostEqualNumber(topFractionA, globalFractionB) && Geometry.isAlmostEqualNumber(topFractionB, globalFractionA))\r\n          return;\r\n      } else {\r\n        if (Geometry.isAlmostEqualNumber(topFractionA, globalFractionA) && Geometry.isAlmostEqualNumber(topFractionB, globalFractionB))\r\n          return;\r\n      }\r\n    }\r\n    const pointA = cpA.fractionToPoint(globalFractionA);\r\n    const pointB = cpB.fractionToPoint(globalFractionB);\r\n    if (!pointA.isAlmostEqualMetric(pointB))\r\n      return;\r\n\r\n    const detailA = CurveLocationDetail.createCurveFractionPoint(cpA,\r\n      globalFractionA, pointA);\r\n    detailA.setIntervalRole(CurveIntervalRole.isolated);\r\n    const detailB = CurveLocationDetail.createCurveFractionPoint(cpB,\r\n      globalFractionB, pointB);\r\n    detailB.setIntervalRole(CurveIntervalRole.isolated);\r\n    if (reversed) {\r\n      this._results.dataA.push(detailB);\r\n      this._results.dataB.push(detailA);\r\n    } else {\r\n      this._results.dataA.push(detailA);\r\n      this._results.dataB.push(detailB);\r\n    }\r\n  }\r\n  /** compute intersection of two line segments.\r\n   * filter by extension rules.\r\n   * record with fraction mapping.\r\n   */\r\n  private computeSegmentSegment3D(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    cpB: CurvePrimitive,\r\n    extendB0: boolean,\r\n    pointB0: Point3d,\r\n    fractionB0: number,\r\n    pointB1: Point3d,\r\n    fractionB1: number,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n\r\n    const uv = CurveCurveIntersectXYZ._workVector2dA;\r\n    if (SmallSystem.lineSegment3dClosestApproachUnbounded(\r\n      pointA0, pointA1,\r\n      pointB0, pointB1, uv)\r\n      && this.acceptFraction(extendA0, uv.x, extendA1)\r\n      && this.acceptFraction(extendB0, uv.y, extendB1)\r\n    ) {\r\n      this.recordPointWithLocalFractions(uv.x, cpA, fractionA0, fractionA1, uv.y, cpB, fractionB0, fractionB1, reversed);\r\n    }\r\n  }\r\n  // Caller accesses data from a line segment and passes to here.\r\n  // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.  The fraction and extend parameters\r\n  // allow all combinations to be passed in)\r\n  // This method applies transform.\r\n  private dispatchSegmentSegment(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    cpB: CurvePrimitive,\r\n    extendB0: boolean,\r\n    pointB0: Point3d,\r\n    fractionB0: number,\r\n    pointB1: Point3d,\r\n    fractionB1: number,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    this.computeSegmentSegment3D(\r\n      cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1,\r\n      cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1,\r\n      reversed);\r\n  }\r\n  /**\r\n   * Create a plane whose normal is a \"better\" cross product as a choice of `vectorA cross vectorB` or `vectorA cross vectorC`\r\n   * * The heuristic for \"better\" is:\r\n   *   * first choice is cross product with `vectorB`.  Use it if the cosine of the angel from vectorA to vectorB is less than cosineValue.\r\n   *   * otherwise use vectorC\r\n   * @param origin plane origin\r\n   * @param vectorA vector which must be in the plane.\r\n   * @param cosineValue typically cosine of something near 90 degrees.\r\n   * @param vectorB first candidate for additional in-plane vector\r\n   * @param vectorC second candidate for additional in-plane vector\r\n   */\r\n  public createPlaneWithPreferredPerpendicular(origin: Point3d, vectorA: Vector3d, cosineValue: number, vectorB: Vector3d, vectorC: Vector3d): Plane3dByOriginAndUnitNormal | undefined {\r\n    const dotAA = vectorA.magnitudeSquared();\r\n    const dotBB = vectorB.magnitudeSquared();\r\n    const dotAB = Math.abs(vectorA.dotProduct(vectorB));\r\n    const cross = vectorA.unitCrossProduct(dotAB < cosineValue * dotAA * dotBB ? vectorB : vectorC);\r\n    if (cross)\r\n      return Plane3dByOriginAndUnitNormal.create(origin, cross);\r\n    return undefined;\r\n  }\r\n  // Caller accesses data from a linestring or segment and passes it here.\r\n  // (The line segment in question might be (a) a full line segment or (b) a fragment within a linestring.  The fraction and extend parameters\r\n  // allow all combinations to be passed in)\r\n  private dispatchSegmentArc(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    arc: Arc3d,\r\n    extendB0: boolean,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    const lineVector = Vector3d.createStartEnd(pointA0, pointA1);\r\n    const plane = this.createPlaneWithPreferredPerpendicular(pointA0, lineVector, 0.9, arc.perpendicularVector, arc.vector0);\r\n    if (plane !== undefined) {\r\n      const candidates: CurveLocationDetail[] = [];\r\n      arc.appendPlaneIntersectionPoints(plane, candidates);\r\n      let lineFraction;\r\n      let linePoint: Point3d | undefined;\r\n      for (const c of candidates) {\r\n        if (this.acceptFraction(extendB0, c.fraction, extendB1)) {\r\n          lineFraction = SmallSystem.lineSegment3dXYClosestPointUnbounded(pointA0, pointA1, c.point);\r\n          if (lineFraction !== undefined) {\r\n            linePoint = pointA0.interpolate(lineFraction, pointA1, linePoint);\r\n            if (linePoint.isAlmostEqualMetric(c.point)\r\n              && this.acceptFraction(extendA0, lineFraction, extendA1)) {\r\n              this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1,\r\n                c.fraction, arc, 0, 1, reversed);\r\n\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Caller promises arcs are coplanar.\r\n  // Passes \"other\" as {center, vector0, vector90} in local xy space of cpA\r\n  // Solves the arc-arc equations for that local ellipse with unit circle.\r\n  // Solution fractions map directly to original arcs.\r\n  private dispatchArcArcInPlane(\r\n    cpA: Arc3d,\r\n    extendA: boolean,\r\n    cpB: Arc3d,\r\n    extendB: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    const otherVectors = cpA.otherArcAsLocalVectors(cpB);\r\n    if (otherVectors !== undefined) {\r\n      const ellipseRadians: number[] = [];\r\n      const circleRadians: number[] = [];\r\n      TrigPolynomial.solveUnitCircleHomogeneousEllipseIntersection(\r\n        otherVectors.center.x, otherVectors.center.y, 1.0,\r\n        otherVectors.vector0.x, otherVectors.vector0.y, 0.0,\r\n        otherVectors.vector90.x, otherVectors.vector90.y, 0.0,\r\n        ellipseRadians, circleRadians);\r\n      for (let i = 0; i < ellipseRadians.length; i++) {\r\n        const fractionA = cpA.sweep.radiansToSignedPeriodicFraction(circleRadians[i]);\r\n        const fractionB = cpA.sweep.radiansToSignedPeriodicFraction(ellipseRadians[i]);\r\n        // hm .. do we really need to check the fractions?  We know they are internal to the beziers\r\n        if (this.acceptFraction(extendA, fractionA, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n          this.recordPointWithLocalFractions(fractionA, cpA, 0, 1,\r\n            fractionB, cpB, 0, 1, reversed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Caller accesses data from two arcs.\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchArcArc(\r\n    cpA: Arc3d,\r\n    extendA: boolean,\r\n    cpB: Arc3d,\r\n    extendB: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    // If arcs are in different planes:\r\n    // 1) Intersect each plane with the other arc (quadratic)\r\n    // 2) accept points that appear in both intersection sets.\r\n    // If arcs are in parallel planes -- no intersections\r\n    // If arcs are in the same plane -- xy intersection in that plane.\r\n    const planeA = Plane3dByOriginAndUnitNormal.create(cpA.center, cpA.perpendicularVector);\r\n    const planeB = Plane3dByOriginAndUnitNormal.create(cpB.center, cpB.perpendicularVector);\r\n    if (planeA === undefined || planeB === undefined)\r\n      return;\r\n\r\n    if (planeA.getNormalRef().isParallelTo(planeB.getNormalRef())) {\r\n      if (planeA.isPointInPlane(planeB.getOriginRef()) && planeB.isPointInPlane(planeA.getOriginRef())) {\r\n        // coplanar !!!\r\n        this.dispatchArcArcInPlane(cpA, extendA, cpB, extendB, reversed);\r\n      }\r\n    } else {\r\n      const arcBPoints: CurveLocationDetail[] = [];\r\n      cpB.appendPlaneIntersectionPoints(planeA, arcBPoints);\r\n      const arcAPoints: CurveLocationDetail[] = [];\r\n      cpA.appendPlaneIntersectionPoints(planeB, arcAPoints);\r\n      for (const detailB of arcBPoints) {\r\n        for (const detailA of arcAPoints) {\r\n          if (detailA.point.isAlmostEqual(detailB.point)) {\r\n            if (this.acceptFraction(extendA, detailA.fraction, extendA)\r\n              && this.acceptFraction(extendB, detailB.fraction, extendB)) {\r\n              this.recordPointWithLocalFractions(detailA.fraction, cpA, 0, 1,\r\n                detailB.fraction, cpB, 0, 1, reversed);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Caller accesses data from two arcs.\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchArcBsplineCurve3d(\r\n    _: Arc3d,\r\n    _extendA: boolean,\r\n    _cpB: BSplineCurve3d,\r\n    _extendB: boolean,\r\n    _reversed: boolean,\r\n  ) {\r\n    /*\r\n    // Arc: X = C + cU + sV\r\n    // implicitize the arc as viewed.  This \"3d\" matrix is homogeneous \"XYW\" not \"xyz\"\r\n    let matrixA: Matrix3d;\r\n    if (this._worldToLocalPerspective) {\r\n      const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);\r\n      matrixA = Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);\r\n    } else {\r\n      const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);\r\n      matrixA = Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);\r\n    }\r\n    // The worldToLocal has moved the arc vectors into screen space.\r\n    // matrixA captures the xyw parts (ignoring z)\r\n    // for any point in world space,\r\n    // THIS CODE ONLY WORKS FOR\r\n    const matrixAInverse = matrixA.inverse();\r\n    if (matrixAInverse) {\r\n      const orderF = cpB.order; // order of the beziers for simple coordinates\r\n      const orderG = 2 * orderF - 1;  // order of the (single) bezier for squared coordinates.\r\n      const coffF = new Float64Array(orderF);\r\n      const univariateBezierG = new UnivariateBezier(orderG);\r\n      const axx = matrixAInverse.at(0, 0); const axy = matrixAInverse.at(0, 1); const axz = 0.0; const axw = matrixAInverse.at(0, 2);\r\n      const ayx = matrixAInverse.at(1, 0); const ayy = matrixAInverse.at(1, 1); const ayz = 0.0; const ayw = matrixAInverse.at(1, 2);\r\n      const awx = matrixAInverse.at(2, 0); const awy = matrixAInverse.at(2, 1); const awz = 0.0; const aww = matrixAInverse.at(2, 2);\r\n\r\n      if (matrixAInverse) {\r\n        let bezier: BezierCurve3dH | undefined;\r\n        for (let spanIndex = 0; ; spanIndex++) {\r\n          bezier = cpB.getSaturatedBezierSpan3dH(spanIndex, bezier);\r\n          if (!bezier) break;\r\n          if (this._worldToLocalPerspective)\r\n            bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);\r\n          else if (this._worldToLocalAffine)\r\n            bezier.tryTransformInPlace(this._worldToLocalAffine);\r\n          univariateBezierG.zero();\r\n          bezier.poleProductsXYZW(coffF, axx, axy, axz, axw);\r\n          univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);\r\n          bezier.poleProductsXYZW(coffF, ayx, ayy, ayz, ayw);\r\n          univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);\r\n          bezier.poleProductsXYZW(coffF, awx, awy, awz, aww);\r\n          univariateBezierG.addSquaredSquaredBezier(coffF, -1.0);\r\n          const roots = univariateBezierG.roots(0.0, true);\r\n          if (roots) {\r\n            for (const root of roots) {\r\n              const fractionB = bezier.fractionToParentFraction(root);\r\n              // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space\r\n              const bcurvePoint4d = bezier.fractionToPoint4d(root);\r\n              const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);\r\n              const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);\r\n              const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));\r\n              if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n                this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,\r\n                  fractionB, cpB, 0, 1, reversed);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    */\r\n  }\r\n  /*\r\n  // apply the transformation to bezier curves. optionally construct ranges.\r\n  private transformBeziers(beziers: BezierCurve3dH[]) {\r\n    if (this._worldToLocalAffine) {\r\n      for (const bezier of beziers) bezier.tryTransformInPlace(this._worldToLocalAffine);\r\n    } else if (this._worldToLocalPerspective) {\r\n      for (const bezier of beziers) bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);\r\n    }\r\n  }\r\n  */\r\n  /*\r\n  private getRanges(beziers: BezierCurveBase[]): Range3d[] {\r\n    const ranges: Range3d[] = [];\r\n    ranges.length = 0;\r\n    for (const b of beziers) {\r\n      ranges.push(b.range());\r\n    }\r\n    return ranges;\r\n  }\r\n  private _xyzwA0?: Point4d;\r\n  private _xyzwA1?: Point4d;\r\n  private _xyzwPlane?: Point4d;\r\n  private _xyzwB?: Point4d;\r\n\r\n  private dispatchBezierBezierStrokeFirst(\r\n    bezierA: BezierCurve3dH,\r\n    bcurveA: BSplineCurve3dBase,\r\n    strokeCountA: number,\r\n    bezierB: BezierCurve3dH,\r\n    bcurveB: BSplineCurve3dBase,\r\n    _strokeCountB: number,\r\n    univariateBezierB: UnivariateBezier,  // caller-allocated for univariate coefficients.\r\n    reversed: boolean) {\r\n    if (!this._xyzwA0) this._xyzwA0 = Point4d.create();\r\n    if (!this._xyzwA1) this._xyzwA1 = Point4d.create();\r\n    if (!this._xyzwPlane) this._xyzwPlane = Point4d.create();\r\n    if (!this._xyzwB) this._xyzwB = Point4d.create();\r\n    /-*\r\n\r\n              const roots = univariateBezierG.roots(0.0, true);\r\n              if (roots) {\r\n                for (const root of roots) {\r\n                  const fractionB = bezier.fractionToParentFraction(root);\r\n                  // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space\r\n                  const bcurvePoint4d = bezier.fractionToPoint4d(root);\r\n                  const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);\r\n                  const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);\r\n                  const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));\r\n                  if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n                    this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,\r\n                      fractionB, cpB, 0, 1, reversed);\r\n                  }\r\n                }\r\n    *-/\r\n    bezierA.fractionToPoint4d(0.0, this._xyzwA0);\r\n    let f0 = 0.0;\r\n    let f1 = 1.0;\r\n    const intervalTolerance = 1.0e-5;\r\n    const df = 1.0 / strokeCountA;\r\n    for (let i = 1; i <= strokeCountA; i++ , f0 = f1, this._xyzwA0.setFrom(this._xyzwA1)) {\r\n      f1 = i * df;\r\n      bezierA.fractionToPoint4d(f1, this._xyzwA1);\r\n      Point4d.createPlanePointPointZ(this._xyzwA0, this._xyzwA1, this._xyzwPlane);\r\n      bezierB.poleProductsXYZW(univariateBezierB.coffs, this._xyzwPlane.x, this._xyzwPlane.y, this._xyzwPlane.z, this._xyzwPlane.w);\r\n      let errors = 0;\r\n      const roots = univariateBezierB.roots(0.0, true);\r\n      if (roots)\r\n        for (const r of roots) {\r\n          const bezierBFraction = r;\r\n          bezierB.fractionToPoint4d(bezierBFraction, this._xyzwB);\r\n          const segmentAFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0, this._xyzwA1, this._xyzwB);\r\n          if (segmentAFraction && Geometry.isIn01WithTolerance(segmentAFraction, intervalTolerance)) {\r\n            const bezierAFraction = Geometry.interpolate(f0, segmentAFraction, f1);\r\n            /*- TODO implement newton search\r\n            const xyMatchingFunction = new BezierBezierIntersectionXYRRToRRD(bezierA, bezierB);\r\n            const newtonSearcher = new Newton2dUnboundedWithDerivative(xyMatchingFunction);\r\n            newtonSearcher.setUV(bezierAFraction, bezierBFraction);\r\n            if (newtonSearcher.runIterations()) {\r\n              bezierAFraction = newtonSearcher.getU();\r\n              bezierBFraction = newtonSearcher.getV();\r\n            }\r\n            *-/\r\n            // We have a near intersection at fractions on the two beziers !!!\r\n            // Iterate on the curves for a true intersection ....\r\n            // NEEDS WORK -- just accept . . .\r\n            const bcurveAFraction = bezierA.fractionToParentFraction(bezierAFraction);\r\n            const bcurveBFraction = bezierB.fractionToParentFraction(bezierBFraction);\r\n            const xyzA0 = bezierA.fractionToPoint(bezierAFraction);\r\n            const xyzA1 = bcurveA.fractionToPoint(bcurveAFraction);\r\n            const xyzB0 = bezierB.fractionToPoint(bezierBFraction);\r\n            const xyzB1 = bcurveB.fractionToPoint(bcurveBFraction);\r\n            if (!xyzA0.isAlmostEqualXY(xyzA1))\r\n              errors++;\r\n            if (!xyzB0.isAlmostEqualXY(xyzB1))\r\n              errors++;\r\n            if (errors > 0 && !xyzA0.isAlmostEqual(xyzB0))\r\n              errors++;\r\n            if (errors > 0 && !xyzA1.isAlmostEqual(xyzB1))\r\n              errors++;\r\n            if (this.acceptFraction(false, bcurveAFraction, false) && this.acceptFraction(false, bcurveBFraction, false)) {\r\n              this.recordPointWithLocalFractions(bcurveAFraction, bcurveA, 0, 1,\r\n                bcurveBFraction, bcurveB, 0, 1, reversed);\r\n            }\r\n          }\r\n        }\r\n    }\r\n  }\r\n  */\r\n\r\n  // Caller accesses data from two arcs.\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchBSplineCurve3dBSplineCurve3d(\r\n    _bcurveA: BSplineCurve3dBase,\r\n    _bcurveB: BSplineCurve3dBase,\r\n    _reversed: boolean) {\r\n    /*\r\n  const bezierSpanA = bcurveA.collectBezierSpans(true) as BezierCurve3dH[];\r\n  const bezierSpanB = bcurveB.collectBezierSpans(true) as BezierCurve3dH[];\r\n  const numA = bezierSpanA.length;\r\n  const numB = bezierSpanB.length;\r\n  this.transformBeziers(bezierSpanA);\r\n  this.transformBeziers(bezierSpanB);\r\n  const rangeA = this.getRanges(bezierSpanA);\r\n  const rangeB = this.getRanges(bezierSpanB);\r\n  const orderA = bcurveA.order;\r\n  const orderB = bcurveB.order;\r\n  const univariateCoffsA = new UnivariateBezier(orderA);\r\n  const univariateCoffsB = new UnivariateBezier(orderB);\r\n  for (let a = 0; a < numA; a++) {\r\n    for (let b = 0; b < numB; b++) {\r\n      if (rangeA[a].intersectsRangeXY(rangeB[b])) {\r\n        const strokeCountA = bezierSpanA[a].computeStrokeCountForOptions();\r\n        const strokeCountB = bezierSpanB[b].computeStrokeCountForOptions();\r\n        if (strokeCountA < strokeCountB)\r\n          this.dispatchBezierBezierStrokeFirst(bezierSpanA[a], bcurveA, strokeCountA, bezierSpanB[b], bcurveB, strokeCountB, univariateCoffsB, !_reversed);\r\n        else\r\n          this.dispatchBezierBezierStrokeFirst(bezierSpanB[b], bcurveB, strokeCountB, bezierSpanA[a], bcurveA, strokeCountA, univariateCoffsA, _reversed);\r\n      }\r\n    }\r\n  }\r\n  */\r\n  }\r\n\r\n  /**\r\n   * Apply the projection transform (if any) to (xyz, w)\r\n   * @param xyz xyz parts of input point.\r\n   * @param w   weight to use for homogeneous effects\r\n   */\r\n  /*\r\n  private projectPoint(xyz: XYAndZ, w: number = 1.0): Point4d {\r\n    if (this._worldToLocalPerspective)\r\n      return this._worldToLocalPerspective.multiplyPoint3d(xyz, w);\r\n    if (this._worldToLocalAffine)\r\n      return this._worldToLocalAffine.multiplyXYZW(xyz.x, xyz.y, xyz.z, w);\r\n    return Point4d.createFromPointAndWeight(xyz, w);\r\n  }\r\n  private mapNPCPlaneToWorld(npcPlane: Point4d, worldPlane: Point4d) {\r\n    // for NPC pointY, Y^ * H = 0 is \"on\" plane H.  (Hat is transpose)\r\n    // NPC Y is A*X for our transform A and worldPointX.\r\n    // hence (A X)^ * H = 0\r\n    // hence X^ * A^ * H = 0\r\n    // hence K = A^ * H\r\n    if (this._worldToLocalAffine) {\r\n      this._worldToLocalAffine.multiplyTransposeXYZW(npcPlane.x, npcPlane.y, npcPlane.z, npcPlane.w, worldPlane);\r\n    } else if (this._worldToLocalPerspective) {\r\n      this._worldToLocalPerspective.multiplyTransposePoint4d(npcPlane, worldPlane);\r\n    } else {\r\n      npcPlane.clone(worldPlane);\r\n    }\r\n  }\r\n  */\r\n  // Caller accesses data from segment and bsplineCurve\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchSegmentBsplineCurve(\r\n    _cpA: CurvePrimitive,\r\n    _extendA0: boolean,\r\n    _pointA0: Point3d,\r\n    _fractionA0: number,\r\n    _pointA1: Point3d,\r\n    _fractionA1: number,\r\n    _extendA1: boolean,\r\n    _bcurve: BSplineCurve3d,\r\n    _extendB: boolean,\r\n    _reversed: boolean,\r\n  ) {\r\n    /*\r\n    const pointA0H = this.projectPoint(pointA0);\r\n    const pointA1H = this.projectPoint(pointA1);\r\n    const planeCoffs = Point4d.createPlanePointPointZ(pointA0H, pointA1H);\r\n    this.mapNPCPlaneToWorld(planeCoffs, planeCoffs);\r\n    // NOW .. we have a plane in world space.  Intersect it with the bspline:\r\n    const intersections: CurveLocationDetail[] = [];\r\n    bcurve.appendPlaneIntersectionPoints(planeCoffs, intersections);\r\n    // intersections has WORLD points with bspline fractions.   (The bspline fractions are all good 0..1 fractions within the spline.)\r\n    // accept those that are within the segment range.\r\n    for (const detail of intersections) {\r\n      const fractionB = detail.fraction;\r\n      const curvePoint = detail.point;\r\n      const curvePointH = this.projectPoint(curvePoint);\r\n      const lineFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, curvePointH);\r\n      if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n        this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1,\r\n          fractionB, bcurve, 0, 1, reversed);\r\n      }\r\n    }\r\n    */\r\n  }\r\n\r\n  private static _workPointAA0 = Point3d.create();\r\n  private static _workPointAA1 = Point3d.create();\r\n  private static _workPointBB0 = Point3d.create();\r\n  private static _workPointBB1 = Point3d.create();\r\n  /** low lever bspline curve -- STUB  .. */\r\n  public dispatchLineStringBSplineCurve(_lsA: LineString3d, _extendA: boolean, _curveB: BSplineCurve3d, _extendB: boolean, _reversed: boolean): any {\r\n    /*\r\n    const numA = lsA.numPoints();\r\n    if (numA > 1) {\r\n      const dfA = 1.0 / (numA - 1);\r\n      let fA0;\r\n      let fA1;\r\n      fA0 = 0.0;\r\n      const pointA0 = CurveCurveIntersectXYZ._workPointA0;\r\n      const pointA1 = CurveCurveIntersectXYZ._workPointA1;\r\n      lsA.pointAt(0, pointA0);\r\n      for (let iA = 1; iA < numA; iA++ , pointA0.setFrom(pointA1), fA0 = fA1) {\r\n        lsA.pointAt(iA, pointA1);\r\n        fA1 = iA * dfA;\r\n        this.dispatchSegmentBsplineCurve(\r\n          lsA, iA === 1 && extendA, pointA0, fA0, pointA1, fA1, (iA + 1) === numA && extendA,\r\n          curveB, extendB, reversed);\r\n      }\r\n    }\r\n    return undefined;\r\n    */\r\n  }\r\n\r\n  /** low lever segment intersect linestring .. */\r\n  public computeSegmentLineString(lsA: LineSegment3d, extendA: boolean, lsB: LineString3d, extendB: boolean, reversed: boolean): any {\r\n    const pointA0 = lsA.point0Ref;\r\n    const pointA1 = lsA.point1Ref;\r\n    const pointB0 = CurveCurveIntersectXYZ._workPointBB0;\r\n    const pointB1 = CurveCurveIntersectXYZ._workPointBB1;\r\n    const numB = lsB.numPoints();\r\n    if (numB > 1) {\r\n      const dfB = 1.0 / (numB - 1);\r\n      let fB0;\r\n      let fB1;\r\n      fB0 = 0.0;\r\n      lsB.pointAt(0, pointB0);\r\n      for (let ib = 1; ib < numB; ib++ , pointB0.setFrom(pointB1), fB0 = fB1) {\r\n        lsB.pointAt(ib, pointB1);\r\n        fB1 = ib * dfB;\r\n        this.dispatchSegmentSegment(\r\n          lsA, extendA, pointA0, 0.0, pointA1, 1.0, extendA,\r\n          lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB,\r\n          reversed);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** low lever arc intersect linestring .. */\r\n public computeArcLineString(arcA: Arc3d, extendA: boolean, lsB: LineString3d, extendB: boolean, reversed: boolean): any {\r\n    const pointB0 = CurveCurveIntersectXYZ._workPointBB0;\r\n    const pointB1 = CurveCurveIntersectXYZ._workPointBB1;\r\n    const numB = lsB.numPoints();\r\n    if (numB > 1) {\r\n      const dfB = 1.0 / (numB - 1);\r\n      let fB0;\r\n      let fB1;\r\n      fB0 = 0.0;\r\n      lsB.pointAt(0, pointB0);\r\n      for (let ib = 1; ib < numB; ib++ , pointB0.setFrom(pointB1), fB0 = fB1) {\r\n        lsB.pointAt(ib, pointB1);\r\n        fB1 = ib * dfB;\r\n        this.dispatchSegmentArc(\r\n          lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB,\r\n          arcA, extendA, extendA,\r\n          !reversed);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** double dispatch handler for strongly typed segment.. */\r\npublic handleLineSegment3d(segmentA: LineSegment3d): any {\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      const segmentB = this._geometryB;\r\n      this.dispatchSegmentSegment(\r\n        segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA,\r\n        segmentB, this._extendB, segmentB.point0Ref, 0.0, segmentB.point1Ref, 1.0, this._extendB,\r\n        false);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.computeSegmentLineString(segmentA, this._extendA, this._geometryB, this._extendB, false);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchSegmentArc(\r\n        segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA,\r\n        this._geometryB, this._extendB, this._extendB, false);\r\n    } else if (this._geometryB instanceof BSplineCurve3d) {\r\n      this.dispatchSegmentBsplineCurve(\r\n        segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA,\r\n        this._geometryB, this._extendB, false);\r\n    }\r\n  }\r\n/** double dispatch handler for strongly typed linestring .. */\r\n  public handleLineString3d(lsA: LineString3d): any {\r\n    if (this._geometryB instanceof LineString3d) {\r\n      const lsB = this._geometryB as LineString3d;\r\n      const pointA0 = CurveCurveIntersectXYZ._workPointAA0;\r\n      const pointA1 = CurveCurveIntersectXYZ._workPointAA1;\r\n      const pointB0 = CurveCurveIntersectXYZ._workPointBB0;\r\n      const pointB1 = CurveCurveIntersectXYZ._workPointBB1;\r\n      const numA = lsA.numPoints();\r\n      const numB = lsB.numPoints();\r\n      if (numA > 1 && numB > 1) {\r\n        lsA.pointAt(0, pointA0);\r\n        const dfA = 1.0 / (numA - 1);\r\n        const dfB = 1.0 / (numB - 1);\r\n        let fA0 = 0.0;\r\n        let fB0;\r\n        let fA1;\r\n        let fB1;\r\n        const extendA = this._extendA;\r\n        const extendB = this._extendB;\r\n        lsA.pointAt(0, pointA0);\r\n        for (let ia = 1; ia < numA; ia++ , pointA0.setFrom(pointA1), fA0 = fA1) {\r\n          fA1 = ia * dfA;\r\n          fB0 = 0.0;\r\n          lsA.pointAt(ia, pointA1);\r\n          lsB.pointAt(0, pointB0);\r\n          for (let ib = 1; ib < numB; ib++ , pointB0.setFrom(pointB1), fB0 = fB1) {\r\n            lsB.pointAt(ib, pointB1);\r\n            fB1 = ib * dfB;\r\n            this.dispatchSegmentSegment(\r\n              lsA, ia === 1 && extendA, pointA0, fA0, pointA1, fA1, (ia + 1) === numA && extendA,\r\n              lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB,\r\n              false);\r\n          }\r\n        }\r\n      }\r\n    } else if (this._geometryB instanceof LineSegment3d) {\r\n      this.computeSegmentLineString(this._geometryB, this._extendB, lsA, this._extendA, true);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.computeArcLineString(this._geometryB, this._extendB, lsA, this._extendA, true);\r\n    } else if (this._geometryB instanceof BSplineCurve3d) {\r\n      this.dispatchLineStringBSplineCurve(lsA, this._extendA, this._geometryB, this._extendB, false);\r\n    }\r\n    return undefined;\r\n  }\r\n/** double dispatch handler for strongly typed arc .. */\r\n  public handleArc3d(arc0: Arc3d): any {\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      this.dispatchSegmentArc(\r\n        this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\r\n        arc0, this._extendA, this._extendA, true);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.computeArcLineString(arc0, this._extendA, this._geometryB, this._extendB, false);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchArcArc(arc0, this._extendA, this._geometryB, this._extendB, false);\r\n    } else if (this._geometryB instanceof BSplineCurve3d) {\r\n      this.dispatchArcBsplineCurve3d(arc0, this._extendA, this._geometryB, this._extendB, false);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** double dispatch handler for strongly typed bspline curve.. */\r\n  public handleBSplineCurve3d(curve: BSplineCurve3d): any {\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      this.dispatchSegmentBsplineCurve(\r\n        this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\r\n        curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof BSplineCurve3dBase) {\r\n      this.dispatchBSplineCurve3dBSplineCurve3d(curve, this._geometryB, false);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** double dispatch handler for strongly typed homogeneous bspline curve. */\r\n  public handleBSplineCurve3dH(_curve: BSplineCurve3dH): any {\r\n    /* NEEDS WORK -- make \"dispatch\" methods tolerant of both 3d and 3dH ...\"easy\" if both present BezierCurve3dH span loaders\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      this.dispatchSegmentBsplineCurve(\r\n        this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\r\n        curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    }\r\n    */\r\n    return undefined;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Geometry } from \"../Geometry\";\r\n/** module Curve */\r\n/** enumeration of condition for extending a curve beyond start or end point.\r\n * * Not all CurvePrimitives support these modes.\r\n * @public\r\n */\r\nexport enum CurveExtendMode {\r\n  /** No extension allowed. */\r\n  None = 0,\r\n  /** Extend along continuation of the end tangent */\r\n  OnTangent = 1,\r\n  /** Extend along continuation of the curve. */\r\n  OnCurve = 2,\r\n}\r\n/** Logic for deciding how a curve may be extended for closest point or intersection searches.\r\n * @public\r\n */\r\nexport class CurveExtendOptions {\r\n  /** Given an ExtendParameter, isolate the particular CurveExtendOptions in effect at an end.\r\n   * * Return undefined if `param === false`\r\n   * * return the (strongly typed) pointer to the param if it is a single CurveExtendOptions.\r\n   * * Return dereferenced array entry 0 or 1 if the param is an array of CurveExtendOptions.\r\n   */\r\n  public static resolveVariantCurveExtendParameterToCurveExtendMode(param: VariantCurveExtendParameter, endIndex: 0 | 1): CurveExtendMode {\r\n    if (param === false)\r\n      return CurveExtendMode.None;\r\n    if (param === true)\r\n      return CurveExtendMode.OnCurve;\r\n    if (Array.isArray(param))\r\n      return param[endIndex];\r\n    return param;\r\n  }\r\n  /**\r\n   *\r\n   * * if fraction is between 0 and 1 return it unchanged.\r\n   * * if fraction is less than 0 use the variant param to choose the fraction or 0\r\n   * * if fraction is greater than 1 use the variant param to choose the fraction or 1\r\n   *\r\n   */\r\n  public static correctFraction(extendParam: VariantCurveExtendParameter, fraction: number): number {\r\n    if (fraction < 0) {\r\n      const mode = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 0);\r\n      if (mode === CurveExtendMode.None)\r\n        fraction = 0.0;\r\n    } else if (fraction > 1.0) {\r\n      const mode = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 1);\r\n      if (mode === CurveExtendMode.None)\r\n        fraction = 1.0;\r\n    }\r\n    return fraction;\r\n  }\r\n  /**\r\n   * Adjust a radians value to an angle sweep, allowing the extendParam to affect choice among periodic fractions.\r\n   * * if radians is within the sweep, convert it to a fraction of the sweep.\r\n   * * if radians is outside, use the extendParam to choose among:\r\n   *    * fraction below 0\r\n   *    * fraction above 1\r\n   */\r\n  public static resolveRadiansToSweepFraction(extendParam: VariantCurveExtendParameter, radians: number, sweep: AngleSweep): number {\r\n    let fraction = sweep.radiansToSignedPeriodicFraction(radians);\r\n    if (!sweep.isRadiansInSweep(radians)) {\r\n      const fractionPeriod = sweep.fractionPeriod();\r\n      const mode0 = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 0);\r\n      const mode1 = CurveExtendOptions.resolveVariantCurveExtendParameterToCurveExtendMode(extendParam, 1);\r\n      if (mode0 !== CurveExtendMode.None) {\r\n        if (mode1 !== CurveExtendMode.None) {\r\n          // both extensions possible ... let the sweep resolve to the \"closer\" end\r\n          fraction = sweep.radiansToSignedPeriodicFraction(radians);\r\n        } else {\r\n          // only extend to negative .....\r\n          if (fraction > 1.0)\r\n            fraction -= fractionPeriod;\r\n        }\r\n      } else if (mode1 !== CurveExtendMode.None) {\r\n        if (fraction < 0.0)\r\n          fraction += fractionPeriod;\r\n      } else {    // both clamped !!!!\r\n        fraction = Geometry.clamp(fraction, 0, 1);\r\n      }\r\n    }\r\n    return fraction;\r\n  }\r\n}\r\n/** Variants of a single parameter.\r\n * Use this type in a function signature where caller may want simple true, false, or same extend mode for both ends.\r\n * @public\r\n */\r\nexport type VariantCurveExtendParameter = boolean | CurveExtendMode | CurveExtendMode[];\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\n// import { Geometry, Angle, AngleSweep } from \"../Geometry\";\r\n\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Arc3d, ArcBlendData } from \"./Arc3d\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { Point3dArrayCarrier } from \"../geometry3d/Point3dArrayCarrier\";\r\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\r\nimport { Path } from \"./Path\";\r\nimport { Geometry } from \"../Geometry\";\r\n/**\r\n * The `CurveFactory` class contains methods for specialized curve constructions.\r\n * @public\r\n */\r\nexport class CurveFactory {\r\n  /** (cautiously) construct and save a line segment between fractional positions. */\r\n  private static addPartialSegment(path: Path, allowBackup: boolean, pointA: Point3d | undefined, pointB: Point3d | undefined, fraction0: number, fraction1: number) {\r\n    if (allowBackup || (fraction1 > fraction0)) {\r\n      if (pointA !== undefined && pointB !== undefined && !Geometry.isAlmostEqualNumber(fraction0, fraction1))\r\n        path.tryAddChild(LineSegment3d.create(pointA.interpolate(fraction0, pointB), pointA.interpolate(fraction1, pointB)));\r\n    }\r\n  }\r\n  /**\r\n   * Construct a sequence of alternating lines and arcs with the arcs creating tangent transition between consecutive edges.\r\n   * @param points point source\r\n   * @param radius fillet radius\r\n   * @param allowBackupAlongEdge true to allow edges to be created going \"backwards\" along edges if needed to create the blend.\r\n   */\r\n  public static createFilletsInLineString(points: LineString3d | IndexedXYZCollection | Point3d[], radius: number, allowBackupAlongEdge: boolean = true): Path | undefined {\r\n    if (Array.isArray(points))\r\n      return this.createFilletsInLineString(new Point3dArrayCarrier(points), radius, allowBackupAlongEdge);\r\n    if (points instanceof LineString3d)\r\n      return this.createFilletsInLineString(points.packedPoints, radius, allowBackupAlongEdge);\r\n    const n = points.length;\r\n    if (n <= 1)\r\n      return undefined;\r\n    const pointA = points.getPoint3dAtCheckedPointIndex(0)!;\r\n    const pointB = points.getPoint3dAtCheckedPointIndex(1)!;\r\n    // remark: n=2 and n=3 cases should fall out from loop logic\r\n    const blendArray: ArcBlendData[] = [];\r\n    // build one-sided blends at each end . .\r\n    blendArray.push({ fraction10: 0.0, fraction12: 0.0, point: pointA.clone() });\r\n\r\n    for (let i = 1; i + 1 < n; i++) {\r\n      const pointC = points.getPoint3dAtCheckedPointIndex(i + 1)!;\r\n      blendArray.push(Arc3d.createFilletArc(pointA, pointB, pointC, radius));\r\n      pointA.setFromPoint3d(pointB);\r\n      pointB.setFromPoint3d(pointC);\r\n    }\r\n    blendArray.push({ fraction10: 0.0, fraction12: 0.0, point: pointB.clone() });\r\n    if (!allowBackupAlongEdge) {\r\n      // suppress arcs that have overlap with both neighbors or flood either neighbor ..\r\n      for (let i = 1; i + 1 < n; i++) {\r\n        const b = blendArray[i];\r\n        if (b.fraction10 > 1.0\r\n          || b.fraction12 > 1.0\r\n          || 1.0 - b.fraction10 < blendArray[i - 1].fraction12\r\n          || b.fraction12 > 1.0 - blendArray[i + 1].fraction10) {\r\n          b.fraction10 = 0.0;\r\n          b.fraction12 = 0.0;\r\n          blendArray[i].arc = undefined;\r\n        }\r\n      }\r\n      // on edge with conflict, suppress the arc with larger fraction\r\n      for (let i = 1; i < n; i++) {\r\n        const b0 = blendArray[i - 1];\r\n        const b1 = blendArray[i];\r\n        if (b0.fraction12 > 1 - b1.fraction10) {\r\n          const b = b0.fraction12 > b1.fraction12 ? b1 : b0;\r\n          b.fraction10 = 0.0;\r\n          b.fraction12 = 0.0;\r\n          blendArray[i].arc = undefined;\r\n        }\r\n      }\r\n    }\r\n    const path = Path.create();\r\n    this.addPartialSegment(path, allowBackupAlongEdge, blendArray[0].point, blendArray[1].point, blendArray[0].fraction12, 1.0 - blendArray[1].fraction10);\r\n    // add each path and successor edge ...\r\n    for (let i = 1; i + 1 < points.length; i++) {\r\n      const b0 = blendArray[i];\r\n      const b1 = blendArray[i + 1];\r\n      path.tryAddChild(b0.arc);\r\n      this.addPartialSegment(path, allowBackupAlongEdge, b0.point, b1.point, b0.fraction12, 1.0 - b1.fraction10);\r\n    }\r\n    return path;\r\n  }\r\n\r\n  /**\r\n   * If `arcB` is a continuation of `arcA`, extend `arcA` (in place) to include the range of `arcB`\r\n   * * This only succeeds if the two arcs are part of identical complete arcs and end of `arcA` matches the beginning of `arcB`.\r\n   * * \"Reversed\"\r\n   * @param arcA\r\n   * @param arcB\r\n   */\r\n  public static appendToArcInPlace(arcA: Arc3d, arcB: Arc3d, allowReverse: boolean = false): boolean {\r\n    if (arcA.center.isAlmostEqual(arcB.center)) {\r\n      const sweepSign = Geometry.split3WaySign(arcA.sweep.sweepRadians * arcB.sweep.sweepRadians, -1, 0, 1);\r\n      // evaluate derivatives wrt radians (not fraction!), but adjust direction for sweep signs\r\n      const endA = arcA.angleToPointAndDerivative(arcA.sweep.fractionToAngle(1.0));\r\n      if (arcA.sweep.sweepRadians < 0)\r\n        endA.direction.scaleInPlace(-1.0);\r\n      const startB = arcB.angleToPointAndDerivative(arcB.sweep.fractionToAngle(0.0));\r\n      if (arcB.sweep.sweepRadians < 0)\r\n        startB.direction.scaleInPlace(-1.0);\r\n\r\n      if (endA.isAlmostEqual(startB)) {\r\n        arcA.sweep.setStartEndRadians(arcA.sweep.startRadians, arcA.sweep.startRadians + arcA.sweep.sweepRadians + sweepSign * arcB.sweep.sweepRadians);\r\n        return true;\r\n      }\r\n      // Also ok if negated tangent . ..\r\n      if (allowReverse) {\r\n        startB.direction.scaleInPlace(-1.0);\r\n        if (endA.isAlmostEqual(startB)) {\r\n          arcA.sweep.setStartEndRadians(arcA.sweep.startRadians, arcA.sweep.startRadians + arcA.sweep.sweepRadians - sweepSign * arcB.sweep.sweepRadians);\r\n          return true;\r\n        }\r\n      }\r\n\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { Geometry } from \"../Geometry\";\r\n/**\r\n * An enumeration of special conditions being described by a CurveLocationDetail.\r\n * @public\r\n */\r\nexport enum CurveIntervalRole {\r\n  /** This point is an isolated point NOT at a primary vertex. */\r\n  isolated = 0,\r\n  /**  This point is an isolated vertex hit */\r\n  isolatedAtVertex = 1,\r\n  /** This is the beginning of an interval */\r\n  intervalStart = 10,\r\n  /** This is an interior point of an interval. */\r\n  intervalInterior = 11,\r\n  /** This is the end of an interval */\r\n  intervalEnd = 12,\r\n}\r\n/**\r\n * Return code for CurvePrimitive method `moveSignedDistanceFromFraction`\r\n * @public\r\n */\r\nexport enum CurveSearchStatus {\r\n  /** unimplemented or zero length curve  */\r\n  error,\r\n  /** complete success of search */\r\n  success = 1,\r\n  /** search ended prematurely (e.g. at incomplete distance moved) at start or end of curve */\r\n  stoppedAtBoundary = 2,\r\n}\r\n\r\n/**\r\n * use to update a vector in case where source and prior result are both possibly undefined.\r\n * * Any undefined source returns undefined.\r\n * * For defined source, reuse optional result if available.\r\n * @param source optional source\r\n * @param result optional result\r\n */\r\nfunction optionalVectorUpdate(source: Vector3d | undefined, result: Vector3d | undefined): Vector3d | undefined {\r\n  if (source) {\r\n    return source.clone(result);\r\n  }\r\n  return undefined;\r\n}\r\n/**\r\n * CurveLocationDetail carries point and paramter data about a point evaluated on a curve.\r\n * * These are returned by a variety of queries.\r\n * * Particular contents can vary among the queries.\r\n * @public\r\n */\r\nexport class CurveLocationDetail {\r\n  /** The curve being evaluated */\r\n  public curve?: CurvePrimitive;\r\n  /** optional ray */\r\n  public ray?: Ray3d;\r\n  /** The fractional position along the curve */\r\n  public fraction: number;\r\n  /** Detail condition of the role this point has in some context */\r\n  public intervalRole?: CurveIntervalRole;\r\n  /** The point on the curve */\r\n  public point: Point3d;\r\n  /** A vector (e.g. tangent vector) in context */\r\n  public vectorInCurveLocationDetail?: Vector3d;\r\n  /** A context-specific numeric value.  (E.g. a distance) */\r\n  public a: number;\r\n  /** optional CurveLocationDetail with more detail of location.  For instance, a detail for fractional position within\r\n   * a CurveChainWithDistanceIndex returns fraction and distance along the chain as its primary data and\r\n   * further detail of the particular curve within the chain in the childDetail.\r\n   */\r\n  public childDetail?: CurveLocationDetail;\r\n  /** A status indicator for certain searches.\r\n   * * e.g. CurvePrimitive.moveSignedDistanceFromFraction\r\n   */\r\n  public curveSearchStatus?: CurveSearchStatus;\r\n  /** A context-specific additional point */\r\n  public pointQ: Point3d;  // extra point for use in computations\r\n\r\n  public constructor() {\r\n    this.pointQ = Point3d.createZero();\r\n    this.fraction = 0;\r\n    this.point = Point3d.createZero();\r\n    this.a = 0.0;\r\n  }\r\n  /** Set the (optional) intervalRole field */\r\n  public setIntervalRole(value: CurveIntervalRole): void {\r\n    this.intervalRole = value;\r\n  }\r\n  /** test if this is an isolated point. This is true if intervalRole is any of (undefined, isolated, isolatedAtVertex) */\r\n  public get isIsolated(): boolean {\r\n    return this.intervalRole === undefined\r\n      || this.intervalRole === CurveIntervalRole.isolated\r\n      || this.intervalRole === CurveIntervalRole.isolatedAtVertex;\r\n  }\r\n\r\n  /** Return a complete copy, WITH CAVEATS . . .\r\n   * * curve member is copied as a reference.\r\n   * * point and vector members are cloned.\r\n   */\r\n  public clone(result?: CurveLocationDetail): CurveLocationDetail {\r\n    if (result === this)\r\n      return result;\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = this.curve;\r\n    result.fraction = this.fraction;\r\n    result.point.setFromPoint3d(this.point);\r\n    result.vectorInCurveLocationDetail = optionalVectorUpdate(this.vectorInCurveLocationDetail, result.vectorInCurveLocationDetail);\r\n    result.a = this.a;\r\n    result.curveSearchStatus = this.curveSearchStatus;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Updated in this instance.\r\n   * * Note that if caller omits `vector` and `a`, those fields are updated to the call-list defaults (NOT left as-is)\r\n   * * point and vector updates are by data copy (not capture of pointers)\r\n   * @param fraction (required) fraction to install\r\n   * @param point  (required) point to install\r\n   * @param vector (optional) vector to install.\r\n   * @param a (optional) numeric value to install.\r\n   */\r\n  public setFP(fraction: number, point: Point3d, vector?: Vector3d, a: number = 0.0) {\r\n    this.fraction = fraction;\r\n    this.point.setFrom(point);\r\n    this.vectorInCurveLocationDetail = optionalVectorUpdate(vector, this.vectorInCurveLocationDetail);\r\n    this.a = a;\r\n  }\r\n\r\n  /**\r\n   * Updated in this instance.\r\n   * * Note that if caller omits a`, that field is updated to the call-list default (NOT left as-is)\r\n   * * point and vector updates are by data copy (not capture of the ray members)\r\n   * @param fraction (required) fraction to install\r\n   * @param ray  (required) point and vector to install\r\n   * @param a (optional) numeric value to install.\r\n   */\r\n  public setFR(fraction: number, ray: Ray3d, a: number = 0) {\r\n    return this.setFP(fraction, ray.origin, ray.direction, a);\r\n  }\r\n  /** Set the CurvePrimitive pointer, leaving all other properties untouched.\r\n   */\r\n  public setCurve(curve: CurvePrimitive) { this.curve = curve; }\r\n\r\n  /** record the distance from the CurveLocationDetail's point to the parameter point. */\r\n  public setDistanceTo(point: Point3d) {\r\n    this.a = this.point.distance(point);\r\n  }\r\n\r\n  /** create with a CurvePrimitive pointer but no coordinate data.\r\n   */\r\n  public static create(\r\n    curve: CurvePrimitive,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    return result;\r\n  }\r\n\r\n  /** create with CurvePrimitive pointer, fraction, and point coordinates.\r\n   */\r\n  public static createCurveFractionPoint(\r\n    curve: CurvePrimitive,\r\n    fraction: number,\r\n    point: Point3d,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    result.fraction = fraction;\r\n    result.point.setFromPoint3d(point);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.a = 0.0;\r\n    result.curveSearchStatus = undefined;\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a new detail with only ray, fraction, and point.\r\n   */\r\n  public static createRayFractionPoint(ray: Ray3d, fraction: number, point: Point3d, result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.fraction = fraction;\r\n    result.ray = ray;\r\n    result.point.setFromPoint3d(point);\r\n    return result;\r\n  }\r\n\r\n  /** create with CurvePrimitive pointer, fraction, and point coordinates\r\n   */\r\n  public static createCurveFractionPointDistanceCurveSearchStatus(\r\n    curve: CurvePrimitive,\r\n    fraction: number,\r\n    point: Point3d,\r\n    distance: number,\r\n    status: CurveSearchStatus,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    result.fraction = fraction;\r\n    result.point.setFromPoint3d(point);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.a = distance;\r\n    result.curveSearchStatus = status;\r\n    return result;\r\n  }\r\n  /** create with curveSearchStatus affected by allowExtension.\r\n   * *\r\n   */\r\n  public static createConditionalMoveSignedDistance(\r\n    allowExtension: boolean,\r\n    curve: CurvePrimitive,\r\n    startFraction: number,\r\n    endFraction: number,\r\n    requestedSignedDistance: number,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    let a = requestedSignedDistance;\r\n    let status = CurveSearchStatus.success;\r\n    if (!allowExtension && !Geometry.isIn01(endFraction)) {\r\n      // cap the movement at the endpoint\r\n      if (endFraction < 0.0) {\r\n        a = - curve.curveLengthBetweenFractions(startFraction, 0.0);\r\n        endFraction = 0.0;\r\n        status = CurveSearchStatus.stoppedAtBoundary;\r\n      } else if (endFraction > 1.0) {\r\n        endFraction = 1.0;\r\n        a = curve.curveLengthBetweenFractions(startFraction, 1.0);\r\n        status = CurveSearchStatus.stoppedAtBoundary;\r\n      }\r\n    }\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    result.fraction = endFraction;\r\n    result.point = curve.fractionToPoint(endFraction, result.point);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.a = a;\r\n    result.curveSearchStatus = status;\r\n    return result;\r\n  }\r\n\r\n  /** create with CurvePrimitive pointer, fraction, and point coordinates.\r\n   */\r\n  public static createCurveEvaluatedFraction(\r\n    curve: CurvePrimitive,\r\n    fraction: number,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    result.fraction = fraction;\r\n    result.point = curve.fractionToPoint(fraction);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.curveSearchStatus = undefined;\r\n    result.a = 0.0;\r\n    return result;\r\n  }\r\n  /** create with CurvePrimitive pointer, fraction, and point coordinates.\r\n   */\r\n  public static createCurveFractionPointDistance(\r\n    curve: CurvePrimitive,\r\n    fraction: number,\r\n    point: Point3d,\r\n    a: number,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    result.fraction = fraction;\r\n    result.point.setFromPoint3d(point);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.a = a;\r\n    result.curveSearchStatus = undefined;\r\n    return result;\r\n  }\r\n\r\n  /** update or create if closer than current contents.\r\n   * @param curve candidate curve\r\n   * @param fraction candidate fraction\r\n   * @param point candidate point\r\n   * @param a candidate distance\r\n   * @returns true if the given distance is smaller (and hence this detail was updated.)\r\n   */\r\n  public updateIfCloserCurveFractionPointDistance(\r\n    curve: CurvePrimitive,\r\n    fraction: number,\r\n    point: Point3d,\r\n    a: number): boolean {\r\n    if (this.a < a)\r\n      return false;\r\n    CurveLocationDetail.createCurveFractionPointDistance(curve, fraction, point, a, this);\r\n    return true;\r\n  }\r\n\r\n}\r\n/** Enumeration of configurations for intersections and min/max distance-between-curve\r\n * @public\r\n */\r\nexport enum CurveCurveApproachType {\r\n  /** Intersection at a single point */\r\n  Intersection = 0,\r\n  /** Distinct points on the two curves, with each curve's tangent perpendicular to the chord between the points */\r\n  PerpendicularChord = 1,\r\n  /** Completely coincident geometry */\r\n  CoincidentGeometry = 2,\r\n  /** Completely parallel geometry. */\r\n  ParallelGeometry = 3,\r\n}\r\n/** A pair of CurveLocationDetail.\r\n * @public\r\n */\r\nexport class CurveLocationDetailPair {\r\n  /** The first of the two details ... */\r\n  public detailA: CurveLocationDetail;\r\n  /** The second of the two details ... */\r\n  public detailB: CurveLocationDetail;\r\n  /** enumeration of how the detail pairs relate.\r\n   * * This is set only by certain closeApproach calculations.\r\n   */\r\n  public approachType?: CurveCurveApproachType;\r\n\r\n  public constructor(detailA?: CurveLocationDetail, detailB?: CurveLocationDetail) {\r\n    this.detailA = detailA ? detailA : new CurveLocationDetail();\r\n    this.detailB = detailB ? detailB : new CurveLocationDetail();\r\n  }\r\n\r\n  /** Create a curve detail pair using references to two CurveLocationDetails */\r\n  public static createCapture(detailA: CurveLocationDetail, detailB: CurveLocationDetail, result?: CurveLocationDetailPair): CurveLocationDetailPair {\r\n    result = result ? result : new CurveLocationDetailPair();\r\n    result.detailA = detailA;\r\n    result.detailB = detailB;\r\n    return result;\r\n  }\r\n\r\n  /** Make a deep copy of this CurveLocationDetailPair */\r\n  public clone(result?: CurveLocationDetailPair): CurveLocationDetailPair {\r\n    result = result ? result : new CurveLocationDetailPair();\r\n    result.detailA = this.detailA.clone();\r\n    result.detailB = this.detailB.clone();\r\n    result.approachType = this.approachType;\r\n    return result;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { AxisOrder, Geometry, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { Order2Bezier } from \"../numerics/BezierPolynomials\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { NewtonEvaluatorRtoR, Newton1dUnboundedApproximateDerivative } from \"../numerics/Newton\";\r\nimport { GaussMapper } from \"../numerics/Quadrature\";\r\nimport { IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Clipper } from \"../clipping/ClipUtils\";\r\nimport { CurveLocationDetail, CurveSearchStatus, CurveIntervalRole } from \"./CurveLocationDetail\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\r\nimport { VariantCurveExtendParameter, CurveExtendOptions } from \"./CurveExtendMode\";\r\n\r\n/** Describes the concrete type of a [[CurvePrimitive]]. Each type name maps to a specific subclass and can be used for type-switching in conditional statements.\r\n *  - \"arc\" => [[Arc3d]]\r\n *  - \"lineSegment\" => [[LineSegment3d]]\r\n *  - \"lineString\" => [[LineString3d]]\r\n *  - \"bsplineCurve\" => [[BSplineCurve3dBase]] which is an intermediate class implemented by [[BSplineCurve3d and BsplineCurve3dH]]\r\n *  - \"bezierCurve\" => [[BezierCurveBase]] which is an intermediate class implemented by [[BezierCurve3d and BezierCurve3dH]]\r\n *  - \"transitionSpiral\" => [[TransitionSpiral3d]]\r\n *  - \"curveChainWithDistanceIndex\" => [[CurveChainWithDistanceIndex]]\r\n *\r\n * @public\r\n */\r\nexport type CurvePrimitiveType = \"arc\" | \"lineSegment\" | \"lineString\" | \"bsplineCurve\" | \"bezierCurve\" | \"transitionSpiral\" | \"curveChainWithDistanceIndex\";\r\n\r\n/** function signature for callback which announces a pair of numbers, such as a fractional interval, along with a containing CurvePrimitive.\r\n * @public\r\n */\r\nexport type AnnounceNumberNumberCurvePrimitive = (a0: number, a1: number, cp: CurvePrimitive) => void;\r\n/** Function signature for a callback which announces a pair of numbers\r\n * @public\r\n */\r\n\r\nexport type AnnounceNumberNumber = (a0: number, a1: number) => void;\r\n/** Function signature for a callback which announces a curve primitive\r\n * @public\r\n */\r\nexport type AnnounceCurvePrimitive = (cp: CurvePrimitive) => void;\r\n/**\r\n * A curve primitive is bounded\r\n * A curve primitive maps fractions in 0..1 to points in space.\r\n * As the fraction proceeds from 0 towards 1, the point moves \"forward\" along the curve.\r\n * True distance along the curve is not always strictly proportional to fraction.\r\n * * LineSegment3d always has proportional fraction and distance\r\n * * an Arc3d which is true circular has proportional fraction and distance\r\n * *  A LineString3d is not proportional (except for special case of all segments of equal length)\r\n * * A Spiral3d is proportional\r\n * * A BsplineCurve3d is only proportional for special cases.\r\n *\r\n * For fractions outside 0..1, the curve primitive class may either (a) return the near endpoint or (b) evaluate an extended curve.\r\n * @public\r\n */\r\nexport abstract class CurvePrimitive extends GeometryQuery {\r\n  /** String name for schema properties */\r\n  public readonly geometryCategory = \"curvePrimitive\";\r\n    /** String name for schema properties */\r\npublic abstract readonly curvePrimitiveType: CurvePrimitiveType;\r\n\r\n  protected constructor() { super(); }\r\n  /**\r\n   * data attached during stroking for facets.\r\n   */\r\n  public strokeData?: StrokeCountMap;\r\n  /**\r\n   * data attached in curve cutting.\r\n   * @internal\r\n   */\r\n  public startCut?: CurveLocationDetail;\r\n  /**\r\n   * data attached in curve cutting.\r\n   * @internal\r\n   */\r\n  public endCut?: CurveLocationDetail;\r\n\r\n  /** Return the point (x,y,z) on the curve at fractional position.\r\n   * @param fraction fractional position along the geometry.\r\n   * @returns Returns a point on the curve.\r\n   */\r\n  public abstract fractionToPoint(fraction: number, result?: Point3d): Point3d;\r\n  /** Return the point (x,y,z) and derivative on the curve at fractional position.\r\n   *\r\n   * * Note that this derivative is \"derivative of xyz with respect to fraction.\"\r\n   * * this derivative shows the speed of the \"fractional point\" moving along the curve.\r\n   * * this is not generally a unit vector.  use fractionToPointAndUnitTangent for a unit vector.\r\n   * @param fraction fractional position along the geometry.\r\n   * @returns Returns a ray whose origin is the curve point and direction is the derivative with respect to the fraction.\r\n   */\r\n  public abstract fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;\r\n  /**\r\n   * Returns a ray whose origin is the curve point and direction is the unit tangent.\r\n   * @param fraction fractional position on the curve\r\n   * @param result optional preallocated ray.\r\n   */\r\n  public fractionToPointAndUnitTangent(fraction: number, result?: Ray3d): Ray3d {\r\n    const ray = this.fractionToPointAndDerivative(fraction, result);\r\n    ray.trySetDirectionMagnitudeInPlace(1.0);\r\n    return ray;\r\n  }\r\n  /** Return a plane with\r\n   *\r\n   * * origin at fractional position along the curve\r\n   * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.\r\n   * * vectorV is the second derivative, i.e.derivative of vectorU.\r\n   */\r\n  public abstract fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined;\r\n\r\n  /** Construct a frenet frame:\r\n   * * origin at the point on the curve\r\n   * * x axis is unit vector along the curve (tangent)\r\n   * * y axis is perpendicular and in the plane of the osculating circle.\r\n   * * z axis perpendicular to those.\r\n   */\r\n  public fractionToFrenetFrame(fraction: number, result?: Transform): Transform | undefined {\r\n    const plane = this.fractionToPointAnd2Derivatives(fraction);\r\n    if (!plane) return undefined;\r\n    let axes = Matrix3d.createRigidFromColumns(plane.vectorU, plane.vectorV, AxisOrder.XYZ);\r\n    if (axes)\r\n      return Transform.createRefs(plane.origin, axes, result);\r\n    // 2nd derivative not distinct -- do arbitrary headsUP ...\r\n    const perpVector = Matrix3d.createPerpendicularVectorFavorXYPlane(plane.vectorU, plane.vectorV);\r\n    axes = Matrix3d.createRigidFromColumns(plane.vectorU, perpVector, AxisOrder.XYZ);\r\n    if (axes)\r\n      return Transform.createRefs(plane.origin, axes, result);\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Construct a point extrapolated along tangent at fraction.\r\n   * @param fraction fractional position on the primitive\r\n   * @param distance (signed) distance to move on the tangent.\r\n   */\r\n  public fractionAndDistanceToPointOnTangent(fraction: number, distance: number): Point3d {\r\n    const ray = this.fractionToPointAndUnitTangent(fraction);\r\n    return ray.fractionToPoint(distance);\r\n  }\r\n\r\n  /**\r\n   * return the length of the curve.\r\n   * * Curve length is always positive.\r\n   */\r\n  public curveLength(): number {\r\n    const context = new CurveLengthContext();\r\n    this.emitStrokableParts(context);\r\n    return context.getSum();\r\n  }\r\n  /**\r\n   * Returns a (high accuracy) length of the curve between fractional positions\r\n   * * Curve length is always positive.\r\n   * * Default implementation applies a generic gaussian integration.\r\n   * * Most curve classes (certainly LineSegment, LineString, Arc) are expected to provide efficient implementations.\r\n   */\r\n  public curveLengthBetweenFractions(fraction0: number, fraction1: number): number {\r\n    if (fraction0 === fraction1)\r\n      return 0.0;\r\n    const scale = this.getFractionToDistanceScale();\r\n    if (scale !== undefined) {\r\n      // We are in luck! simple proportions determine it all  !!!\r\n      // (for example, a LineSegment3d or a circular arc)\r\n      const totalLength = this.curveLength();\r\n      return Math.abs((fraction1 - fraction0) * totalLength);\r\n    }\r\n    const context = new CurveLengthContext(fraction0, fraction1);\r\n    this.emitStrokableParts(context);\r\n    return Math.abs(context.getSum());\r\n  }\r\n\r\n  /**\r\n   *\r\n   * * Run an integration (with a default gaussian quadrature) with a fixed fractional step\r\n   * * This is typically called by specific curve type implementations of curveLengthBetweenFractions.\r\n   *   * For example, in Arc3d implementation of curveLengthBetweenFractions:\r\n   *     * If the Arc3d is true circular, it the arc is true circular, use the direct `arcLength = radius * sweepRadians`\r\n   *     * If the Arc3d is not true circular, call this method with an interval count appropriate to eccentricity and sweepRadians.\r\n   * @returns Returns an integral estimated by numerical quadrature between the fractional positions.\r\n   * @param fraction0 start fraction for integration\r\n   * @param fraction1 end fraction for integration\r\n   * @param numInterval number of quadrature intervals\r\n   */\r\n  public curveLengthWithFixedIntervalCountQuadrature(fraction0: number, fraction1: number, numInterval: number, numGauss: number = 5): number {\r\n    if (fraction0 > fraction1) {\r\n      const fSave = fraction0;\r\n      fraction0 = fraction1;\r\n      fraction1 = fSave;\r\n    }\r\n    const context = new CurveLengthContext(fraction0, fraction1, numGauss);\r\n    context.announceIntervalForUniformStepStrokes(this, numInterval, fraction0, fraction1);\r\n    return Math.abs(context.getSum());\r\n  }\r\n\r\n  /**\r\n   *\r\n   * * (Attempt to) find a position on the curve at a signed distance from start fraction.\r\n   * * Return the position as a CurveLocationDetail.\r\n   * * In the `CurveLocationDetail`, record:\r\n   *   * `fractional` position\r\n   *   * `fraction` = coordinates of the point\r\n   *   * `search\r\n   *   * `a` = (signed!) distance moved.   If `allowExtension` is false and the move reached the start or end of the curve, this distance is smaller than the requested signedDistance.\r\n   *   * `curveSearchStatus` indicates one of:\r\n   *     * `error` (unusual) computation failed not supported for this curve.\r\n   *     * `success` full movement completed\r\n   *     * `stoppedAtBoundary` partial movement completed. This can be due to either\r\n   *        * `allowExtension` parameter sent as `false`\r\n   *        * the curve type (e.g. bspline) does not support extended range.\r\n   * * if `allowExtension` is true, movement may still end at the startPoint or end point for curves that do not support extended geometry (specifically bsplines)\r\n   * * if the curve returns a value (i.e. not `undefined`) for `curve.getFractionToDistanceScale()`, the base class carries out the computation\r\n   *    and returns a final location.\r\n   *   * LineSegment3d relies on this.\r\n   * * If the curve does not implement the computation or the curve has zero length, the returned `CurveLocationDetail` has\r\n   *    * `fraction` = the value of `startFraction`\r\n   *    * `point` = result of `curve.fractionToPoint(startFraction)`\r\n   *    * `a` = 0\r\n   *    * `curveStartState` = `CurveSearchStatus.error`\r\n   * @param startFraction fractional position where the move starts\r\n   * @param signedDistance distance to move.   Negative distance is backwards in the fraction space\r\n   * @param allowExtension if true, all the move to go beyond the startPoint or endpoint of the curve.  If false, do not allow movement beyond the startPoint or endpoint\r\n   * @param result optional result.\r\n   * @returns A CurveLocationDetail annotated as above.  Note that if the curve does not support the calculation, there is still a result which contains the point at the input startFraction, with failure indicated in the `curveStartState` member\r\n   */\r\n  public moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: boolean, result?: CurveLocationDetail): CurveLocationDetail {\r\n    const scale = this.getFractionToDistanceScale();\r\n    if (scale !== undefined) {\r\n      // We are in luck! simple proportions determine it all  !!!\r\n      // (for example, a LineSegment3d or a circular arc)\r\n      const totalLength = this.curveLength();\r\n      const signedFractionMove = Geometry.conditionalDivideFraction(signedDistance, totalLength);\r\n      if (signedFractionMove === undefined) {\r\n        return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(\r\n          this, startFraction, this.fractionToPoint(startFraction), 0.0, CurveSearchStatus.error);\r\n      }\r\n      return CurveLocationDetail.createConditionalMoveSignedDistance(\r\n        allowExtension,\r\n        this,\r\n        startFraction,\r\n        startFraction + signedFractionMove,\r\n        signedDistance,\r\n        result);\r\n    }\r\n    return this.moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result);\r\n  }\r\n  /**\r\n   * Generic algorithm to search for point at signed distance from a fractional startPoint.\r\n   * * This will work for well for smooth curves.\r\n   * * Curves with tangent or other low-order-derivative discontinuities may need to implement specialized algorithms.\r\n   * * We need to find an endFraction which is the end-of-interval (usually upper) limit of integration of the tangent magnitude from startFraction to endFraction\r\n   * * That integral is a function of endFraction.\r\n   * * The derivative of that integral with respect to end fraction is the tangent magnitude at end fraction.\r\n   * * Use that function and (easily evaluated!) derivative for a Newton iteration\r\n   * * TO ALL WHO HAVE FUZZY MEMORIES OF CALCULUS CLASS: \"The derivative of the integral wrt upper limit is the value of the integrand there\" is the\r\n   *       fundamental theorem of integral calculus !!! The fundamental theorem is not just an abstraction !!! It is being used\r\n   *       here in its barest possible form !!!\r\n   * * See https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus\r\n   * @param startFraction\r\n   * @param signedDistance\r\n   * @param _allowExtension\r\n   * @param result\r\n   */\r\n  protected moveSignedDistanceFromFractionGeneric(startFraction: number, signedDistance: number, allowExtension: boolean, result?: CurveLocationDetail): CurveLocationDetail {\r\n    const limitFraction = signedDistance > 0.0 ? 1.0 : 0.0;\r\n    const absDistance = Math.abs(signedDistance);\r\n    const directionFactor = signedDistance < 0.0 ? -1.0 : 1.0;\r\n    const availableLength = this.curveLengthBetweenFractions(startFraction, limitFraction);    // that is always positive\r\n    if (availableLength < absDistance && !allowExtension)\r\n      return CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, limitFraction, signedDistance, result);\r\n    const fractionStep = absDistance / availableLength;\r\n    let fractionB = Geometry.interpolate(startFraction, fractionStep, limitFraction);\r\n    let fractionA = startFraction;\r\n    let distanceA = 0.0;\r\n    const tol = 1.0e-12 * availableLength;\r\n    let numConverged = 0;\r\n    const tangent = Ray3d.createXAxis();\r\n    // on each loop entry:\r\n    // fractionA is the most recent endOfInterval.  (It may have been reached by a mixture of forward and backward step.)\r\n    // distanceA is the distance to (the point at) fractionA\r\n    // fractionB is the next end fraction\r\n    for (let iterations = 0; iterations < 10; iterations++) {\r\n      const distanceAB = this.curveLengthBetweenFractions(fractionA, fractionB);\r\n      const directionAB = fractionB > fractionA ? directionFactor : -directionFactor;\r\n      const distance0B = distanceA + directionAB * distanceAB;\r\n      const distanceError = absDistance - distance0B;\r\n      if (Math.abs(distanceError) < tol) {\r\n        numConverged++;\r\n        if (numConverged > 1)\r\n          break;\r\n      } else {\r\n        numConverged = 0;\r\n      }\r\n      this.fractionToPointAndDerivative(fractionB, tangent);\r\n      const tangentMagnitude = tangent.direction.magnitude();\r\n      fractionA = fractionB;\r\n      fractionB = fractionA + directionFactor * distanceError / tangentMagnitude;\r\n      if (fractionA === fractionB) { // YES -- that is an exact equality test.   When it happens, there's no need for confirming with another iteration.\r\n        numConverged = 100;\r\n        break;\r\n      }\r\n      distanceA = distance0B;\r\n    }\r\n    if (numConverged > 1)\r\n      return CurveLocationDetail.createConditionalMoveSignedDistance(false, this, startFraction, fractionB, signedDistance, result);\r\n\r\n    result = CurveLocationDetail.createCurveEvaluatedFraction(this, startFraction, result);\r\n    result.a = 0.0;\r\n    result.curveSearchStatus = CurveSearchStatus.error;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * * Returns true if the curve's fraction queries extend beyond 0..1.\r\n   * * Base class default implementation returns false.\r\n   * * These class (and perhaps others in the future) will return true:\r\n   *   * LineSegment3d\r\n   *   * LineString3d\r\n   *   * Arc3d\r\n   */\r\n  public get isExtensibleFractionSpace(): boolean { return false; }\r\n  /**\r\n   * Compute a length which may be an fast approximation to the true length.\r\n   * This is expected to be either (a) exact or (b) larger than the actual length, but by no more than\r\n   * a small multiple, perhaps up to PI/2, but commonly much closer to 1.\r\n   *\r\n   * * An example use of this is for setting a tolerance which is a small multiple of the curve length.\r\n   * * Simple line, circular arc, and transition spiral may return exact length\r\n   * * Ellipse may return circumference of some circle or polygon that encloses the ellipse.\r\n   * * bspline curve may return control polygon length\r\n   * *\r\n   */\r\n  public abstract quickLength(): number;\r\n  /** Search for the curve point that is closest to the spacePoint.\r\n   *\r\n   * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.\r\n   * * Since CurvePrimitive should always have start and end available as candidate points, this method should always succeed\r\n   * @param spacePoint point in space\r\n   * @param extend true to extend the curve (if possible), false for no extend, single CurveExtendOptions (for both directions), or array of distinct CurveExtendOptions for start and end.\r\n   * @returns Returns a CurveLocationDetail structure that holds the details of the close point.\r\n   */\r\n  public closestPoint(spacePoint: Point3d, extend: VariantCurveExtendParameter): CurveLocationDetail | undefined {\r\n    const strokeHandler = new ClosestPointStrokeHandler(spacePoint, extend);\r\n    this.emitStrokableParts(strokeHandler);\r\n    return strokeHandler.claimResult();\r\n  }\r\n  /**\r\n   * Find intervals of this curvePrimitive that are interior to a clipper\r\n   * @param clipper clip structure (e.g. clip planes)\r\n   * @param announce (optional) function to be called announcing fractional intervals\"  ` announce(fraction0, fraction1, curvePrimitive)`\r\n   * @returns true if any \"in\" segments are announced.\r\n   */\r\n  public announceClipIntervals(_clipper: Clipper, _announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    // DEFAULT IMPLEMENTATION -- no interior parts\r\n    return false;\r\n  }\r\n\r\n  /** Return (if possible) a curve primitive which is a portion of this curve.\r\n   * @param _fractionA [in] start fraction\r\n   * @param _fractionB [in] end fraction\r\n   */\r\n  public clonePartialCurve(_fractionA: number, _fractionB: number): CurvePrimitive | undefined {\r\n    return undefined;\r\n  }\r\n  /**\r\n   * * If the curve primitive has distance-along-curve strictly proportional to curve fraction, return true\r\n   * * If distance-along-the-curve is not proportional, return undefined.\r\n   * * When defined, the scale factor is always the length of the curve.\r\n   * * This scale factor is typically available for these curve types:\r\n   * * * All `LineSegment3d`\r\n   * * * Arc3d which is a true circular arc (axes perpendicular and of equal length).\r\n   * * * CurveChainWithDistanceIndex\r\n   * * This scale factor is undefined for these curve types:\r\n   * * * Arc3d which is a true ellipse, i.e. unequal lengths of defining vectors or non-perpendicular defining vectors.\r\n   * * * bspline and bezier curves\r\n   * @returns scale factor or undefined\r\n   */\r\n  public getFractionToDistanceScale(): number | undefined { return undefined; }\r\n\r\n  /** Reverse the curve's data so that its fractional stroking moves in the opposite direction. */\r\n  public abstract reverseInPlace(): void;\r\n  /**\r\n   * Compute intersections with a plane.\r\n   * * The intersections are appended to the result array.\r\n   * * The base class implementation emits strokes to an AppendPlaneIntersectionStrokeHandler object, which uses a Newton iteration to get\r\n   *     high-accuracy intersection points within strokes.\r\n   * * Derived classes should override this default implementation if there are easy analytic solutions.\r\n   * * Derived classes are free to implement extended intersections (e.g. arc!!!)\r\n   * @param plane The plane to be intersected.\r\n   * @param result Array to receive intersections\r\n   * @returns Return the number of CurveLocationDetail's added to the result array.\r\n   */\r\n  public appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number {\r\n    const strokeHandler = new AppendPlaneIntersectionStrokeHandler(plane, result);\r\n    const n0 = result.length;\r\n    this.emitStrokableParts(strokeHandler);\r\n    return result.length - n0;\r\n  }\r\n  /**\r\n   * Examine contents of an array of CurveLocationDetail.\r\n   * Filter the intersections according to the parameters.\r\n   * @param allowExtend if false, remove points on the extension.\r\n   * @param applySnappedCoordinates if true, change the stored fractions and coordinates to exact end values.  Otherwise\r\n   *     use the exact values only for purpose of updating the curveIntervalRole.\r\n   * @param startEndFractionTolerance if nonzero, adjust fraction to 0 or 1 with this tolerance.\r\n   * @param startEndXYZTolerance if nonzero, adjust to endpoint with this tolerance.\r\n   * @internal\r\n   */\r\n  public static snapAndRestrictDetails(\r\n    details: CurveLocationDetail[],\r\n    allowExtend: boolean = true,\r\n    applySnappedCoordinates: boolean = false,\r\n    startEndFractionTolerance = Geometry.smallAngleRadians,\r\n    startEndXYZTolerance = Geometry.smallMetricDistance) {\r\n    const n0 = details.length;\r\n    let acceptIndex = 0;\r\n    const point0 = Point3d.create();\r\n    const point1 = Point3d.create();\r\n    let snappedCoordinates: Point3d | undefined;\r\n    for (let candidateIndex = 0; candidateIndex < n0; candidateIndex++) {\r\n      snappedCoordinates = undefined;\r\n      const detail = details[candidateIndex];\r\n      let fraction = detail.fraction;\r\n      let accept = allowExtend || Geometry.isIn01(fraction);\r\n      if (detail.curve) {\r\n        detail.curve.startPoint(point0);\r\n        detail.curve.endPoint(point1);\r\n      }\r\n\r\n      if (startEndFractionTolerance > 0) {\r\n        if (Math.abs(fraction) < startEndFractionTolerance) {\r\n          fraction = 0.0;\r\n          accept = true;\r\n          detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\r\n          snappedCoordinates = point0;\r\n        }\r\n        if (Math.abs(fraction - 1.0) < startEndFractionTolerance) {\r\n          fraction = 1.0;\r\n          accept = true;\r\n          detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\r\n          snappedCoordinates = point1;\r\n          if (detail.curve)\r\n            snappedCoordinates = detail.curve.startPoint(point1);\r\n        }\r\n      }\r\n      if (startEndXYZTolerance > 0 && detail.curve !== undefined) {\r\n        // REMARK: always test both endpoints.   If there is a cyclic fraction space, an intersection marked as \"after\" the end might have wrapped all the way to the beginning.\r\n        if (detail.point.distance(point0) <= startEndXYZTolerance) {\r\n          fraction = 0.0;\r\n          detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\r\n          snappedCoordinates = point0;\r\n        } else if (detail.point.distance(point1) <= startEndXYZTolerance) {\r\n          fraction = 1.0;\r\n          detail.intervalRole = CurveIntervalRole.isolatedAtVertex;\r\n          snappedCoordinates = point1;\r\n        }\r\n      }\r\n      if (accept) {\r\n        if (applySnappedCoordinates) {\r\n          detail.fraction = fraction;\r\n          if (snappedCoordinates !== undefined)\r\n            detail.point.setFrom(snappedCoordinates);\r\n        }\r\n        if (acceptIndex < candidateIndex)\r\n          details[acceptIndex] = detail;\r\n        acceptIndex++;\r\n      }\r\n\r\n    }\r\n    if (acceptIndex < n0)\r\n      details.length = acceptIndex;\r\n\r\n  }\r\n\r\n  /** Ask if the curve is within tolerance of a plane.\r\n   * @returns Returns true if the curve is completely within tolerance of the plane.\r\n   */\r\n  public abstract isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;\r\n  /** return the startPoint of the primitive.  The default implementation returns fractionToPoint (0.0) */\r\n  public startPoint(result?: Point3d): Point3d { return this.fractionToPoint(0.0, result); }\r\n  /** return the end point of the primitive. The default implementation returns fractionToPoint(1.0) */\r\n  public endPoint(result?: Point3d): Point3d { return this.fractionToPoint(1.0, result); }\r\n  /** Add strokes to caller-supplied linestring */\r\n  public abstract emitStrokes(dest: LineString3d, options?: StrokeOptions): void;\r\n  /** Ask the curve to announce points and simple subcurve fragments for stroking.\r\n   * See IStrokeHandler for description of the sequence of the method calls.\r\n   */\r\n  public abstract emitStrokableParts(dest: IStrokeHandler, options?: StrokeOptions): void;\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * * This returns a single number\r\n   * * See computeComponentStrokeCountForOptions to get structured per-component counts and fraction mappings.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public abstract computeStrokeCountForOptions(options?: StrokeOptions): number;\r\n\r\n  /**\r\n   * attach StrokeCountMap structure to this primitive (and recursively to any children)\r\n   * * Base class implementation (here) gets the simple count from computeStrokeCountForOptions and attaches it.\r\n   * * LineString3d, arc3d, BezierCurve3d, BezierCurve3dH accept that default.\r\n   * * Subdivided primitives (linestring, bspline curve) implement themselves and attach a StrokeCountMap containing the\r\n   *       total count, and also containing an array of StrokeCountMap per component.\r\n   * * For CurvePrimitiveWithDistanceIndex, the top level gets (only) a total count, and each child gets\r\n   *       its own StrokeCountMap with appropriate structure.\r\n   * @param options StrokeOptions that determine count\r\n   * @param parentStrokeMap optional map from parent.  Its count, curveLength, and a1 values are increased with count and distance from this primitive.\r\n   * @return sum of `a0+this.curveLength()`, for use as `a0` of successor in chain.\r\n   */\r\n  public computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentMap?: StrokeCountMap) {\r\n    const n = this.computeStrokeCountForOptions(options);\r\n    const a = this.curveLength();\r\n    CurvePrimitive.installStrokeCountMap(\r\n      this,\r\n      StrokeCountMap.createWithCurvePrimitive(this, n, a, 0, a),\r\n      parentMap);\r\n  }\r\n\r\n  /**\r\n   * * evaluate strokes at fractions indicated in a StrokeCountMap.\r\n   *   * Base class implementation (here) gets the simple count from computeStrokeCountForOptions and strokes at uniform fractions.\r\n   *   * LineString3d, arc3d, BezierCurve3d, BezierCurve3dH accept that default.\r\n   *   * Subdivided primitives (linestring, bspline curve) implement themselves and evaluate within components.\r\n   *   * CurvePrimitiveWithDistanceIndex recurses to its children.\r\n   * * if packedFraction and packedDerivative arrays are present in the LineString3d, fill them.\r\n   * @param map = stroke count data.\r\n   * @param linestring = receiver linestring.\r\n   * @return number of strokes added.  0 if any errors matching the map to the curve primitive.\r\n   */\r\n  public addMappedStrokesToLineString3D(map: StrokeCountMap, linestring: LineString3d): number {\r\n    const numPoint0 = linestring.numPoints();\r\n    if (map.primitive && map.primitive === this && map.numStroke > 0) {\r\n      for (let i = 0; i <= map.numStroke; i++) {\r\n        const fraction = i / map.numStroke;\r\n        linestring.appendFractionToPoint(this, fraction);\r\n      }\r\n    }\r\n    return linestring.numPoints() - numPoint0;\r\n  }\r\n\r\n  /**\r\n   * final install step to save curveMap in curve.  If parentMap is given, update its length, count, and a1 fields\r\n   * @param curve curve to receive the annotation\r\n   * @param map\r\n   * @param parentMap\r\n   */\r\n  public static installStrokeCountMap(curve: CurvePrimitive, curveMap: StrokeCountMap, parentMap?: StrokeCountMap) {\r\n    if (parentMap)\r\n      parentMap.addToCountAndLength(curveMap.numStroke, curveMap.curveLength);\r\n    curve.strokeData = curveMap;\r\n  }\r\n}\r\n\r\n/** Intermediate class for managing the parentCurve announcements from an IStrokeHandler */\r\nabstract class NewtonRotRStrokeHandler extends NewtonEvaluatorRtoR {\r\n  protected _parentCurvePrimitive: CurvePrimitive | undefined;\r\n  constructor() {\r\n    super();\r\n    this._parentCurvePrimitive = undefined;\r\n  }\r\n  /** retain the parentCurvePrimitive.\r\n   * * Calling this method tells the handler that the parent curve is to be used for detail searches.\r\n   * * Example: Transition spiral search is based on linestring first, then the exact spiral.\r\n   * * Example: CurveChainWithDistanceIndex does NOT do this announcement -- the constituents act independently.\r\n   */\r\n  public startParentCurvePrimitive(curve: CurvePrimitive | undefined) { this._parentCurvePrimitive = curve; }\r\n  /** Forget the parentCurvePrimitive */\r\n  public endParentCurvePrimitive(_curve: CurvePrimitive | undefined) { this._parentCurvePrimitive = undefined; }\r\n}\r\n\r\nclass AppendPlaneIntersectionStrokeHandler extends NewtonRotRStrokeHandler implements IStrokeHandler {\r\n  private _curve: CurvePrimitive | undefined;\r\n  private _plane: PlaneAltitudeEvaluator;\r\n  private _intersections: CurveLocationDetail[];\r\n  private _fractionA: number = 0;\r\n  private _functionA: number = 0;\r\n  // private derivativeA: number;   <---- Not currently used\r\n  private _functionB: number = 0;\r\n  private _fractionB: number = 0;\r\n  private _derivativeB: number = 0;\r\n  private _numThisCurve: number = 0;\r\n  // scratch vars for use within methods.\r\n  private _ray: Ray3d;\r\n  private _newtonSolver: Newton1dUnboundedApproximateDerivative;\r\n\r\n  // Return the first defined curve among: this.parentCurvePrimitive, this.curve;\r\n  public effectiveCurve(): CurvePrimitive | undefined {\r\n    if (this._parentCurvePrimitive)\r\n      return this._parentCurvePrimitive;\r\n    return this._curve;\r\n  }\r\n  public get getDerivativeB() { return this._derivativeB; }    // <--- DerivativeB is not currently used anywhere. Provided getter to suppress tslint error\r\n\r\n  public constructor(plane: PlaneAltitudeEvaluator, intersections: CurveLocationDetail[]) {\r\n    super();\r\n    this._plane = plane;\r\n    this._intersections = intersections;\r\n    this.startCurvePrimitive(undefined);\r\n    this._ray = Ray3d.createZero();\r\n    this._newtonSolver = new Newton1dUnboundedApproximateDerivative(this);\r\n  }\r\n  public startCurvePrimitive(curve: CurvePrimitive | undefined) {\r\n    this._curve = curve;\r\n    this._fractionA = 0.0;\r\n    this._numThisCurve = 0;\r\n    this._functionA = 0.0;\r\n    // this.derivativeA = 0.0;\r\n  }\r\n  public endCurvePrimitive() { }\r\n  public announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    this.startCurvePrimitive(cp);\r\n    if (numStrokes < 1) numStrokes = 1;\r\n    const df = 1.0 / numStrokes;\r\n    for (let i = 0; i <= numStrokes; i++) {\r\n      const fraction = Geometry.interpolate(fraction0, i * df, fraction1);\r\n      cp.fractionToPointAndDerivative(fraction, this._ray);\r\n      this.announcePointTangent(this._ray.origin, fraction, this._ray.direction);\r\n    }\r\n  }\r\n  public announceSegmentInterval(\r\n    _cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    _numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    const h0 = this._plane.altitude(point0);\r\n    const h1 = this._plane.altitude(point1);\r\n    if (h0 * h1 > 0.0)\r\n      return;\r\n    const fraction01 = Order2Bezier.solveCoffs(h0, h1);\r\n    // let numIntersection = 0;\r\n    if (fraction01 !== undefined) {\r\n      // numIntersection++;\r\n      const fraction = Geometry.interpolate(fraction0, fraction01, fraction1);\r\n      this._newtonSolver.setX(fraction);\r\n      if (this._newtonSolver.runIterations()) {\r\n        this.announceSolutionFraction(this._newtonSolver.getX());\r\n      }\r\n      // this.intersections.push(CurveLocationDetail.createCurveFractionPoint(cp, fraction, cp.fractionToPoint(fraction)));\r\n    }\r\n  }\r\n  private announceSolutionFraction(fraction: number) {\r\n    const curve = this.effectiveCurve();\r\n    if (curve) {\r\n      this._ray = curve.fractionToPointAndDerivative(fraction, this._ray);\r\n      this._intersections.push(CurveLocationDetail.createCurveFractionPoint(curve, fraction, this._ray.origin));\r\n    }\r\n  }\r\n  public evaluate(fraction: number): boolean {\r\n    const curve = this.effectiveCurve();\r\n    if (!curve)\r\n      return false;\r\n    this.currentF = this._plane.altitude(curve.fractionToPoint(fraction));\r\n    return true;\r\n  }\r\n  /**\r\n   * * ASSUME both the \"A\" and \"B\"  evaluations (fraction, function, and derivative) are known.\r\n   * * If function value changed sign between, interpolate an approximate root and improve it with\r\n   *     the newton solver.\r\n   */\r\n  private searchInterval() {\r\n    if (this._functionA * this._functionB > 0) return;\r\n    if (this._functionA === 0) this.announceSolutionFraction(this._fractionA);\r\n    if (this._functionB === 0) this.announceSolutionFraction(this._fractionB);\r\n    if (this._functionA * this._functionB < 0) {\r\n      const fraction = Geometry.inverseInterpolate(this._fractionA, this._functionA, this._fractionB, this._functionB);\r\n      if (fraction) {\r\n        this._newtonSolver.setX(fraction);\r\n        if (this._newtonSolver.runIterations())\r\n          this.announceSolutionFraction(this._newtonSolver.getX());\r\n      }\r\n    }\r\n  }\r\n  /** Evaluate and save _functionB, _derivativeB, and _fractionB. */\r\n  private evaluateB(xyz: Point3d, fraction: number, tangent: Vector3d) {\r\n    this._functionB = this._plane.altitude(xyz);\r\n    this._derivativeB = this._plane.velocity(tangent);\r\n    this._fractionB = fraction;\r\n  }\r\n  /**\r\n   * Announce point and tangent for evaluations.\r\n   * * The function evaluation is saved as the \"B\" function point.\r\n   * * The function point count is incremented\r\n   * * If function point count is greater than 1, the current interval is searched.\r\n   * * The just-evaluated point (\"B\") is saved as the \"old\" (\"A\") evaluation point.\r\n   * @param xyz\r\n   * @param fraction\r\n   * @param tangent\r\n   */\r\n  public announcePointTangent(xyz: Point3d, fraction: number, tangent: Vector3d): void {\r\n    this.evaluateB(xyz, fraction, tangent);\r\n    if (this._numThisCurve++ > 0) this.searchInterval();\r\n    this._functionA = this._functionB;\r\n    this._fractionA = this._fractionB;\r\n    this._fractionA = this._fractionB;\r\n  }\r\n}\r\n\r\nclass CurveLengthContext implements IStrokeHandler {\r\n  private _curve: CurvePrimitive | undefined;\r\n  private _summedLength: number;\r\n  private _ray: Ray3d;\r\n  private _fraction0: number;\r\n  private _fraction1: number;\r\n  private _gaussMapper: GaussMapper;\r\n\r\n  private tangentMagnitude(fraction: number): number {\r\n    this._ray = (this._curve as CurvePrimitive).fractionToPointAndDerivative(fraction, this._ray);\r\n    return this._ray.direction.magnitude();\r\n  }\r\n  public getSum() { return this._summedLength; }\r\n\r\n  public constructor(fraction0: number = 0.0, fraction1: number = 1.0, numGaussPoints: number = 5) {\r\n    this.startCurvePrimitive(undefined);\r\n    this._summedLength = 0.0;\r\n    this._ray = Ray3d.createZero();\r\n    if (fraction0 < fraction1) {\r\n      this._fraction0 = fraction0;\r\n      this._fraction1 = fraction1;\r\n    } else {\r\n      this._fraction0 = fraction1;\r\n      this._fraction1 = fraction0;\r\n    }\r\n    this._gaussMapper = new GaussMapper(numGaussPoints);\r\n  }\r\n  public startCurvePrimitive(curve: CurvePrimitive | undefined) {\r\n    this._curve = curve;\r\n  }\r\n  public startParentCurvePrimitive(_curve: CurvePrimitive) { }\r\n  public endParentCurvePrimitive(_curve: CurvePrimitive) { }\r\n\r\n  public endCurvePrimitive() { }\r\n  public announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    if (fraction0 < this._fraction0) fraction0 = this._fraction0;\r\n    if (fraction1 > this._fraction1) fraction1 = this._fraction1;\r\n    if (fraction1 > fraction0) {\r\n      this.startCurvePrimitive(cp);\r\n      if (numStrokes < 1) numStrokes = 1;\r\n      const df = 1.0 / numStrokes;\r\n      for (let i = 1; i <= numStrokes; i++) {\r\n        const fractionA = Geometry.interpolate(fraction0, (i - 1) * df, fraction1);\r\n        const fractionB = i === numStrokes ? fraction1 : Geometry.interpolate(fraction0, (i) * df, fraction1);\r\n        const numGauss = this._gaussMapper.mapXAndW(fractionA, fractionB);\r\n        for (let k = 0; k < numGauss; k++) {\r\n          this._summedLength += this._gaussMapper.gaussW[k] * this.tangentMagnitude(this._gaussMapper.gaussX[k]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  public announceSegmentInterval(\r\n    _cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    _numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    const segmentLength = point0.distance(point1);\r\n    if (this._fraction0 <= fraction0 && fraction1 <= this._fraction1)\r\n      this._summedLength += segmentLength;\r\n    else {\r\n      let g0 = fraction0;\r\n      let g1 = fraction1;\r\n      if (g0 < this._fraction0) g0 = this._fraction0;\r\n      if (g1 > this._fraction1) g1 = this._fraction1;\r\n      if (g1 > g0) {\r\n        this._summedLength += segmentLength * (g1 - g0) / (fraction1 - fraction0);\r\n      }\r\n    }\r\n  }\r\n  public announcePointTangent(_xyz: Point3d, _fraction: number, _tangent: Vector3d): void {\r\n    // uh oh -- need to retain point for next interval\r\n  }\r\n}\r\n// context for searching for closest point .. .\r\nclass ClosestPointStrokeHandler extends NewtonRotRStrokeHandler implements IStrokeHandler {\r\n  private _curve: CurvePrimitive | undefined;\r\n  private _closestPoint: CurveLocationDetail | undefined;\r\n  private _spacePoint: Point3d;\r\n  private _extend: VariantCurveExtendParameter;\r\n  private _fractionA: number = 0;\r\n  private _functionA: number = 0;\r\n  private _functionB: number = 0;\r\n  private _fractionB: number = 0;\r\n  private _numThisCurve: number = 0;\r\n  // scratch vars for use within methods.\r\n  private _workPoint: Point3d;\r\n  private _workRay: Ray3d;\r\n  private _newtonSolver: Newton1dUnboundedApproximateDerivative;\r\n\r\n  public constructor(spacePoint: Point3d, extend: VariantCurveExtendParameter) {\r\n    super();\r\n    this._spacePoint = spacePoint;\r\n    this._workPoint = Point3d.create();\r\n    this._workRay = Ray3d.createZero();\r\n    this._closestPoint = undefined;\r\n    this._extend = extend;\r\n    this.startCurvePrimitive(undefined);\r\n    this._newtonSolver = new Newton1dUnboundedApproximateDerivative(this);\r\n  }\r\n\r\n  public claimResult(): CurveLocationDetail | undefined {\r\n    if (this._closestPoint) {\r\n      this._newtonSolver.setX(this._closestPoint.fraction);\r\n      this._curve = this._closestPoint.curve;\r\n      if (this._newtonSolver.runIterations()) {\r\n        let fraction = this._newtonSolver.getX();\r\n        fraction = CurveExtendOptions.correctFraction(this._extend, fraction);\r\n        this.announceSolutionFraction(fraction);\r\n      }\r\n    }\r\n    return this._closestPoint;\r\n  }\r\n  public startCurvePrimitive(curve: CurvePrimitive | undefined) {\r\n    this._curve = curve;\r\n    this._fractionA = 0.0;\r\n    this._numThisCurve = 0;\r\n    this._functionA = 0.0;\r\n  }\r\n  public endCurvePrimitive() { }\r\n  public announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    this.startCurvePrimitive(cp);\r\n    if (numStrokes < 1) numStrokes = 1;\r\n    const df = 1.0 / numStrokes;\r\n    for (let i = 0; i <= numStrokes; i++) {\r\n      const fraction = Geometry.interpolate(fraction0, i * df, fraction1);\r\n      cp.fractionToPointAndDerivative(fraction, this._workRay);\r\n      this.announceRay(fraction, this._workRay);\r\n    }\r\n  }\r\n\r\n  private announceCandidate(cp: CurvePrimitive, fraction: number, point: Point3d) {\r\n    const distance = this._spacePoint.distance(point);\r\n    if (this._closestPoint && distance > this._closestPoint.a)\r\n      return;\r\n    this._closestPoint = CurveLocationDetail.createCurveFractionPoint(cp, fraction, point, this._closestPoint);\r\n    this._closestPoint.a = distance;\r\n    if (this._parentCurvePrimitive !== undefined)\r\n      this._closestPoint.curve = this._parentCurvePrimitive;\r\n  }\r\n  public announceSegmentInterval(\r\n    cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    _numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    let localFraction = this._spacePoint.fractionOfProjectionToLine(point0, point1, 0.0);\r\n    // only consider extending the segment if the immediate caller says we are at endpoints ...\r\n    if (!this._extend)\r\n      localFraction = Geometry.clampToStartEnd(localFraction, 0.0, 1.0);\r\n    else {\r\n      if (fraction0 !== 0.0)\r\n        localFraction = Math.max(localFraction, 0.0);\r\n      if (fraction1 !== 1.0)\r\n        localFraction = Math.min(localFraction, 1.0);\r\n    }\r\n    this._workPoint = point0.interpolate(localFraction, point1);\r\n    const globalFraction = Geometry.interpolate(fraction0, localFraction, fraction1);\r\n    this.announceCandidate(cp, globalFraction, this._workPoint);\r\n  }\r\n  private searchInterval() {\r\n    if (this._functionA * this._functionB > 0) return;\r\n    if (this._functionA === 0) this.announceSolutionFraction(this._fractionA);\r\n    if (this._functionB === 0) this.announceSolutionFraction(this._fractionB);\r\n    if (this._functionA * this._functionB < 0) {\r\n      const fraction = Geometry.inverseInterpolate(this._fractionA, this._functionA, this._fractionB, this._functionB);\r\n      if (fraction) {\r\n        this._newtonSolver.setX(fraction);\r\n        if (this._newtonSolver.runIterations())\r\n          this.announceSolutionFraction(this._newtonSolver.getX());\r\n      }\r\n    }\r\n  }\r\n  private evaluateB(fractionB: number, dataB: Ray3d) {\r\n    this._functionB = dataB.dotProductToPoint(this._spacePoint);\r\n    this._fractionB = fractionB;\r\n  }\r\n  private announceSolutionFraction(fraction: number) {\r\n    if (this._curve)\r\n      this.announceCandidate(this._curve, fraction, this._curve.fractionToPoint(fraction));\r\n  }\r\n  public evaluate(fraction: number): boolean {\r\n    let curve = this._curve;\r\n    if (this._parentCurvePrimitive)\r\n      curve = this._parentCurvePrimitive;\r\n    if (curve) {\r\n      this._workRay = curve.fractionToPointAndDerivative(fraction, this._workRay);\r\n      this.currentF = this._workRay.dotProductToPoint(this._spacePoint);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  public announceRay(fraction: number, data: Ray3d): void {\r\n    this.evaluateB(fraction, data);\r\n    if (this._numThisCurve++ > 0) this.searchInterval();\r\n    this._functionA = this._functionB;\r\n    this._fractionA = this._fractionB;\r\n    this._fractionA = this._fractionB;\r\n  }\r\n  public announcePointTangent(point: Point3d, fraction: number, tangent: Vector3d) {\r\n    this._workRay.set(point, tangent);\r\n    this.announceRay(fraction, this._workRay);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\nimport { UnionRegion } from \"./UnionRegion\";\r\nimport { BagOfCurves, CurveCollection } from \"./CurveCollection\";\r\nimport { ParityRegion } from \"./ParityRegion\";\r\nimport { Loop } from \"./Loop\";\r\nimport { Path } from \"./Path\";\r\n/* tslint:disable:variable-name no-empty*/\r\n\r\n/** base class for detailed traversal of curve artifacts.\r\n * * This recurses to children in the quickest way (no records of path)\r\n * * Use the RecursiveCurveProcessorWithStack to record the path along the visit.\r\n * @public\r\n */\r\nexport abstract class RecursiveCurveProcessor {\r\n  protected constructor() {\r\n  }\r\n\r\n  /** process error content */\r\n  public announceUnexpected(_data: AnyCurve, _indexInParent: number) { }\r\n  /** process a leaf primitive. */\r\n  public announceCurvePrimitive(_data: CurvePrimitive, _indexInParent = -1): void { }\r\n\r\n  /** announce a path (recurse to children) */\r\n  public announcePath(data: Path, _indexInParent: number = -1): void {\r\n    let i = 0;\r\n    for (const curve of data.children)\r\n      this.announceCurvePrimitive(curve, i++);\r\n  }\r\n  /** announce a loop (recurse to children) */\r\n  public announceLoop(data: Loop, _indexInParent: number = -1): void {\r\n    let i = 0;\r\n    for (const curve of data.children)\r\n      this.announceCurvePrimitive(curve, i++);\r\n  }\r\n\r\n  /** announce beginning or end of loops in a parity region */\r\n  public announceParityRegion(data: ParityRegion, _indexInParent: number = -1): void {\r\n    let i = 0;\r\n    for (const loop of data.children)\r\n      this.announceLoop(loop, i++);\r\n  }\r\n  /** announce beginning or end of a parity region */\r\n  public announceUnionRegion(data: UnionRegion, _indexInParent: number = -1): void {\r\n    let i = 0;\r\n    for (const child of data.children) {\r\n      child.announceToCurveProcessor(this, i++);\r\n    }\r\n  }\r\n\r\n  /** announce a bag of curves.\r\n   * * The default implementation visits each child and calls the appropriate dispatch to\r\n   * * `this.announceCurvePrimitive(child)`\r\n   * * `child.announceToCurveProcessor(this)`\r\n   */\r\n  public announceBagOfCurves(data: BagOfCurves, _indexInParent: number = -1): void {\r\n    for (const child of data.children) {\r\n      if (child instanceof CurvePrimitive)\r\n        this.announceCurvePrimitive(child);\r\n      else\r\n        child.announceToCurveProcessor(this);\r\n    }\r\n  }\r\n}\r\n\r\n/** base class for detailed traversal of curve artifacts\r\n * * During recursion,  maintains a stack that shows complete path to each artifact.\r\n * * Use the QuickRecursiveCurveProcessor to visit without recording the path.\r\n * @public\r\n */\r\nexport abstract class RecursiveCurveProcessorWithStack extends RecursiveCurveProcessor {\r\n  /** Stack of curve collections that are \"up the tree\" from the current point of the traversal. */\r\n  protected _stack: CurveCollection[];\r\n  protected constructor() {\r\n    super();\r\n    this._stack = [];\r\n  }\r\n  /** Push `data` onto the stack so its status is available during processing of children.\r\n   * * Called when `data` is coming into scope.\r\n   */\r\n  public enter(data: CurveCollection) { this._stack.push(data); }\r\n  /** Pop the stack\r\n   * * called when the top of the stack goes out of scope\r\n   */\r\n  public leave(): CurveCollection | undefined { return this._stack.pop(); }\r\n\r\n  /** process error content */\r\n  public announceUnexpected(_data: AnyCurve, _indexInParent: number) { }\r\n  /** process a leaf primitive. */\r\n  public announceCurvePrimitive(_data: CurvePrimitive, _indexInParent = -1): void { }\r\n\r\n  /** announce a path (recurse to children) */\r\n  public announcePath(data: Path, indexInParent: number = -1): void {\r\n    this.enter(data);\r\n    super.announcePath(data, indexInParent);\r\n    this.leave();\r\n  }\r\n  /** announce a loop (recurse to children) */\r\n  public announceLoop(data: Loop, indexInParent: number = -1): void {\r\n    this.enter(data);\r\n    super.announceLoop(data, indexInParent);\r\n    this.leave();\r\n  }\r\n\r\n  /** announce beginning or end of loops in a parity region */\r\n  public announceParityRegion(data: ParityRegion, _indexInParent: number = -1): void {\r\n    this.enter(data);\r\n    let i = 0;\r\n    for (const loop of data.children)\r\n      this.announceLoop(loop, i++);\r\n    this.leave();\r\n  }\r\n  /** announce beginning or end of a parity region */\r\n  public announceUnionRegion(data: UnionRegion, indexInParent: number = -1): void {\r\n    this.enter(data);\r\n    super.announceUnionRegion(data, indexInParent);\r\n    this.leave();\r\n  }\r\n  /**\r\n   * Announce members of an unstructured collection.\r\n   * * push the collection reference on the stack\r\n   * * announce children\r\n   * * pop the stack\r\n   * @param data the collection\r\n   * @param _indexInParent index where the collection appears in its parent.\r\n   */\r\n  public announceBagOfCurves(data: BagOfCurves, _indexInParent: number = -1): void {\r\n    this.enter(data);\r\n    let i = 0;\r\n    for (const child of data.children) {\r\n      if (child instanceof CurvePrimitive)\r\n        this.announceCurvePrimitive(child, i++);\r\n      else\r\n        child.announceToCurveProcessor(this);\r\n    }\r\n    this.leave();\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\n// import { Geometry, Angle, AngleSweep } from \"../Geometry\";\r\n\r\nimport { MomentData } from \"../geometry4d/MomentData\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { CurveCollection } from \"./CurveCollection\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\nimport { GaussMapper } from \"../numerics/Quadrature\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\n/**\r\n * Class to visit curve primitives and accumulate wire moment integrations.\r\n * @internal\r\n */\r\nexport class CurveWireMomentsXYZ implements IStrokeHandler {\r\n  private _activeMomentData: MomentData;\r\n  private _gaussMapper: GaussMapper;\r\n\r\n  public constructor(numGaussPoints: number = 5) {\r\n    this._activeMomentData = MomentData.create();\r\n    this._activeMomentData.needOrigin = true;\r\n    this._gaussMapper = new GaussMapper(numGaussPoints);\r\n  }\r\n  public get momentData(): MomentData { return this._activeMomentData; }\r\n\r\n  public startParentCurvePrimitive(_cp: CurvePrimitive) { }\r\n  public startCurvePrimitive(_cp: CurvePrimitive) { }\r\n  public endCurvePrimitive(_cp: CurvePrimitive) { }\r\n  public endParentCurvePrimitive(_cp: CurvePrimitive) { }\r\n  public announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    this.startCurvePrimitive(cp);\r\n    if (numStrokes < 1) numStrokes = 1;\r\n    const df = 1.0 / numStrokes;\r\n    let scaleFactor, fraction;\r\n    for (let i = 1; i <= numStrokes; i++) {\r\n      const fractionA = Geometry.interpolate(fraction0, (i - 1) * df, fraction1);\r\n      const fractionB = i === numStrokes ? fraction1 : Geometry.interpolate(fraction0, (i) * df, fraction1);\r\n      const numGauss = this._gaussMapper.mapXAndW(fractionA, fractionB);\r\n      for (let k = 0; k < numGauss; k++) {\r\n        fraction = this._gaussMapper.gaussX[k];\r\n        const ray = cp.fractionToPointAndDerivative(fraction)!;\r\n        scaleFactor = this._gaussMapper.gaussW[k] * ray.direction.magnitude();\r\n        this._activeMomentData!.accumulateScaledOuterProduct(ray.origin, scaleFactor);\r\n      }\r\n    }\r\n  }\r\n\r\n  public announceSegmentInterval(\r\n    _cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    _numStrokes: number,\r\n    _fraction0: number,\r\n    _fraction1: number): void {\r\n    this._activeMomentData!.accumulateLineMomentsXYZ(point0, point1);\r\n  }\r\n  public announcePointTangent(_xyz: Point3d, _fraction: number, _tangent: Vector3d): void {\r\n    // umm ... this should not happen.  We need to know intervals. The other functions should have prevented this.\r\n  }\r\n  /** Recurse to leaf-level primitives */\r\n  public visitLeaves(root: AnyCurve) {\r\n    if (root instanceof CurvePrimitive)\r\n      root.emitStrokableParts(this);\r\n    else if (root instanceof CurveCollection) {\r\n      if (root.children !== undefined)\r\n        for (const child of root.children) {\r\n          this.visitLeaves(child as AnyCurve);\r\n        }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { Polyface } from \"../polyface/Polyface\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { CurveCollection } from \"./CurveCollection\";\r\nimport { SolidPrimitive } from \"../solid/SolidPrimitive\";\r\nimport { CoordinateXYZ } from \"./CoordinateXYZ\";\r\nimport { PointString3d } from \"./PointString3d\";\r\nimport { BSpline2dNd } from \"../bspline/BSplineSurface\";\r\n\r\n/** Describes the category of a [[GeometryQuery]], enabling type-switching like:\r\n * ```ts\r\n *   function processGeometryQuery(q: GeometryQuery): void {\r\n *     if (\"solid\" === q.geometryCategory)\r\n *       alert(\"Solid type = \" + q.solidPrimitiveType; // compiler knows q is an instance of SolidPrimitive\r\n *    // ...etc...\r\n * ```\r\n *\r\n * Each string maps to a particular subclass of [[GeometryQuery]]:\r\n *  - \"polyface\" => [[Polyface]]\r\n *  - \"curvePrimitive\" => [[CurvePrimitive]]\r\n *  - \"curveCollection\" => [[CurveCollection]]\r\n *  - \"solid\" => [[SolidPrimitive]]\r\n *  - \"point\" => [[CoordinateXYZ]]\r\n *  - \"pointCollection\" => [[PointString3d]]\r\n *  - \"bsurf\" => [[BSpline2dNd]]  (which is an intermediate class shared by [[BSplineSurface3d]] and [[BSplineSurface3dH]])\r\n *\r\n *  @see [[AnyGeometryQuery]]\r\n * @public\r\n */\r\nexport type GeometryQueryCategory = \"polyface\" | \"curvePrimitive\" | \"curveCollection\" | \"solid\" | \"point\" | \"pointCollection\" | \"bsurf\";\r\n\r\n/** Union type for subclasses of [[GeometryQuery]]. Specific subclasses can be discriminated at compile- or run-time using [[GeometryQuery.geometryCategory]].\r\n * @public\r\n */\r\nexport type AnyGeometryQuery = Polyface | CurvePrimitive | CurveCollection | SolidPrimitive | CoordinateXYZ | PointString3d | BSpline2dNd;\r\n\r\n/** Queries to be supported by Curve, Surface, and Solid objects */\r\n/**\r\n * * `GeometryQuery` is an abstract base class with (abstract) methods for querying curve, solid primitive, mesh, and bspline surfaces\r\n * @public\r\n */\r\nexport abstract class GeometryQuery {\r\n  /** Type discriminator. */\r\n  public abstract readonly geometryCategory: GeometryQueryCategory;\r\n\r\n  /** return the range of the entire (tree) GeometryQuery */\r\n  public range(transform?: Transform, result?: Range3d): Range3d {\r\n    if (result) result.setNull();\r\n    const range = result ? result : Range3d.createNull();\r\n    this.extendRange(range, transform);\r\n    return range;\r\n  }\r\n\r\n  /** extend rangeToExtend by the range of this geometry multiplied by the transform */\r\n  public abstract extendRange(rangeToExtend: Range3d, transform?: Transform): void;\r\n\r\n  /** Attempt to transform in place.\r\n   *\r\n   * * LineSegment3d, Arc3d, LineString3d, BsplineCurve3d always succeed.\r\n   * * Some geometry types may fail if scaling is non-uniform.\r\n   */\r\n  public abstract tryTransformInPlace(transform: Transform): boolean;\r\n\r\n  /** try to move the geometry by dx,dy,dz */\r\n  public tryTranslateInPlace(dx: number, dy: number = 0.0, dz: number = 0.0): boolean {\r\n    return this.tryTransformInPlace(Transform.createTranslationXYZ(dx, dy, dz));\r\n  }\r\n  /** return a transformed clone.\r\n   */\r\n  public abstract cloneTransformed(transform: Transform): GeometryQuery | undefined;\r\n  /** return a clone */\r\n  public abstract clone(): GeometryQuery | undefined;\r\n  /** return GeometryQuery children for recursive queries.\r\n   *\r\n   * * leaf classes do not need to implement.\r\n   */\r\n  public get children(): GeometryQuery[] | undefined { return undefined; }\r\n  /** test if (other instanceof this.Type).  REQUIRED IN ALL CONCRETE CLASSES */\r\n  public abstract isSameGeometryClass(other: GeometryQuery): boolean;\r\n  /** test for exact structure and nearly identical geometry.\r\n   *\r\n   * *  Leaf classes must implement !!!\r\n   * *  base class implementation recurses through children.\r\n   * *  base implementation is complete for classes with children and no properties.\r\n   * *  classes with both children and properties must implement for properties, call super for children.\r\n   */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (this.isSameGeometryClass(other)) {\r\n      const childrenA = this.children;\r\n      const childrenB = other.children;\r\n      if (childrenA && childrenB) {\r\n        if (childrenA.length !== childrenB.length)\r\n          return false;\r\n        for (let i = 0; i < childrenA.length; i++) {\r\n          if (!childrenA[i].isAlmostEqual(childrenB[i])) return false;\r\n        }\r\n        return true;\r\n      } else if (childrenA || childrenB) {  // CurveCollections start with empty arrays for children.  So these null pointer cases are never reached.\r\n        return false;   // plainly different .\r\n      } else {\r\n        // both children null. call it equal?   This class should probably have implemented.\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * * \"double dispatch\" call pattern.\r\n   * * User code implements a `GeometryHandler` with specialized methods to handle `LineSegment3d`, `Arc3d` etc as relevant to its use case.\r\n   * * Each such `GeometryQuery` class implements this method as a one-line method containing the appropriate call such as `handler.handleLineSegment3d ()`\r\n   * * This allows each type-specific method to be called without a switch or `instanceof` test.\r\n   * @param handler handler to be called by the particular geometry class\r\n   */\r\n  public abstract dispatchToGeometryHandler(handler: GeometryHandler): any;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry, BeJSONFunctions, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { Order2Bezier } from \"../numerics/BezierPolynomials\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive, AnnounceNumberNumberCurvePrimitive } from \"./CurvePrimitive\";\r\nimport { CurveExtendOptions, VariantCurveExtendParameter } from \"./CurveExtendMode\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurveLocationDetail, CurveIntervalRole } from \"./CurveLocationDetail\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Clipper } from \"../clipping/ClipUtils\";\r\n/* tslint:disable:variable-name no-empty*/\r\n/**\r\n * A LineSegment3d is:\r\n *\r\n * * A 3d line segment represented by its start and end coordinates\r\n *   * startPoint\r\n *   * endPoint\r\n * * The segment is parameterized with fraction 0 at the start and fraction 1 at the end, i.e. either of these equivalent forms to map fraction `f` to a point `X(f)`\r\n *   *  `X(f) = startPoint + f * (endPoint - startPoint)`\r\n *   * `X(f) = (1-f)*startPoint  + f * endPoint`\r\n * @public\r\n */\r\nexport class LineSegment3d extends CurvePrimitive implements BeJSONFunctions {\r\n  /** String name for schema properties */\r\n  public readonly curvePrimitiveType = \"lineSegment\";\r\n\r\n  /** test if `other` is of class `LineSegment3d` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof LineSegment3d; }\r\n  private _point0: Point3d;\r\n  private _point1: Point3d;\r\n  /** Return REFERENCE to the start point of this segment.\r\n   * * (This is distinct from the `CurvePrimitive` abstract method `endPoint()` which creates a returned point\r\n   */\r\n  public get point0Ref(): Point3d { return this._point0; }\r\n  /** Return REFERENCE to the end point of this segment.\r\n   * * (This is distinct from the `CurvePrimitive` abstract method `endPoint()` which creates a returned point\r\n   */\r\n  public get point1Ref(): Point3d { return this._point1; }\r\n  /**\r\n   * A LineSegment3d extends along its infinite line.\r\n   */\r\n  public get isExtensibleFractionSpace(): boolean { return true; }\r\n\r\n  /**\r\n   * CAPTURE point references as a `LineSegment3d`\r\n   * @param point0\r\n   * @param point1\r\n   */\r\n  private constructor(point0: Point3d, point1: Point3d) { super(); this._point0 = point0; this._point1 = point1; }\r\n  /** Set the start and endpoints by capturing input references. */\r\n  public setRefs(point0: Point3d, point1: Point3d) { this._point0 = point0; this._point1 = point1; }\r\n  /** Set the start and endpoints by cloning the input parameters. */\r\n  public set(point0: Point3d, point1: Point3d) { this._point0 = point0.clone(); this._point1 = point1.clone(); }\r\n  /** copy (clone) data from other */\r\n  public setFrom(other: LineSegment3d) { this._point0.setFrom(other._point0); this._point1.setFrom(other._point1); }\r\n  /** Return a (clone of) the start point. (This is NOT a reference to the stored start point) */\r\n  public startPoint(result?: Point3d): Point3d {\r\n    if (result) { result.setFrom(this._point0); return result; }\r\n    return this._point0.clone();\r\n  }\r\n  /** Return a (clone of) the end point. (This is NOT a reference to the stored end point) */\r\n  public endPoint(result?: Point3d): Point3d {\r\n    if (result) { result.setFrom(this._point1); return result; }\r\n    return this._point1.clone();\r\n  }\r\n  /** Return the point and derivative vector at fractional position along the line segment. */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    result.direction.setStartEnd(this._point0, this._point1);\r\n    this._point0.interpolate(fraction, this._point1, result.origin);\r\n    return result;\r\n  }\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the line segment\r\n   * * x axis is the first derivative, i.e. along the line segment\r\n   * * y axis is the second derivative, i.e. 000\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    result = result ? result : Plane3dByOriginAndVectors.createXYPlane();\r\n    result.vectorU.setStartEnd(this._point0, this._point1);\r\n    result.vectorV.set(0, 0, 0);\r\n    this._point0.interpolate(fraction, this._point1, result.origin);\r\n    return result;\r\n  }\r\n\r\n  /** Clone the LineSegment3d */\r\n  public clone(): LineSegment3d { return LineSegment3d.create(this._point0, this._point1); }\r\n  /** Clone and apply transform to the clone. */\r\n  public cloneTransformed(transform: Transform): CurvePrimitive {  // we know tryTransformInPlace succeeds.\r\n    const c = this.clone();\r\n    c.tryTransformInPlace(transform);\r\n    return c;\r\n  }\r\n  /** Create with start and end points.  The point contents are cloned into the LineSegment3d. */\r\n  public static create(point0: Point3d, point1: Point3d, result?: LineSegment3d): LineSegment3d {\r\n    if (result) {\r\n      result.set(point0, point1);  // and this will clone them !!\r\n      return result;\r\n    }\r\n    return new LineSegment3d(point0.clone(), point1.clone());\r\n  }\r\n\r\n  /** Create with start and end points.  The point contents are CAPTURED into the result */\r\n  public static createCapture(point0: Point3d, point1: Point3d): LineSegment3d {\r\n    return new LineSegment3d(point0, point1);\r\n  }\r\n  /** create a LineSegment3d from xy coordinates of start and end, with common z.\r\n   * @param x0 start point x coordinate.\r\n   * @param y0 start point y coordinate.\r\n   * @param x1 end point x coordinate.\r\n   * @param y1 end point y coordinate.\r\n   * @param z z coordinate to use for both points.\r\n   * @param result optional existing LineSegment to be reinitialized.\r\n   */\r\n  public static createXYXY(x0: number, y0: number, x1: number, y1: number, z: number = 0, result?: LineSegment3d) {\r\n    if (result) {\r\n      result._point0.set(x0, y0, z);\r\n      result._point1.set(x1, y1, z);\r\n      return result;\r\n    }\r\n    return new LineSegment3d(Point3d.create(x0, y0, z), Point3d.create(x1, y1, z));\r\n  }\r\n\r\n  /** create a LineSegment3d from xy coordinates of start and end, with common z.\r\n   * @param x0 start point x coordinate.\r\n   * @param y0 start point y coordinate.\r\n   * @param x1 end point x coordinate.\r\n   * @param y1 end point y coordinate.\r\n   * @param z z coordinate to use for both points.\r\n   * @param result optional existing LineSegment to be reinitialized.\r\n   */\r\n  public static createXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, result?: LineSegment3d) {\r\n    if (result) {\r\n      result._point0.set(x0, y0, z0);\r\n      result._point1.set(x1, y1, z1);\r\n      return result;\r\n    }\r\n    return new LineSegment3d(Point3d.create(x0, y0, z0), Point3d.create(x1, y1, z1));\r\n  }\r\n\r\n  /** Return the point at fractional position along the line segment. */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d { return this._point0.interpolate(fraction, this._point1, result); }\r\n  /** Return the length of the segment. */\r\n  public curveLength(): number { return this._point0.distance(this._point1); }\r\n  /** Return the length of the partial segment between fractions. */\r\n  public curveLengthBetweenFractions(fraction0: number, fraction1: number): number {\r\n    return Math.abs(fraction1 - fraction0) * this._point0.distance(this._point1);\r\n  }\r\n  /** Return the length of the segment. */\r\n  public quickLength(): number { return this.curveLength(); }\r\n\r\n  /**\r\n   * Returns a curve location detail with both xyz and fractional coordinates of the closest point.\r\n   * @param spacePoint point in space\r\n   * @param extend if false, only return points within the bounded line segment. If true, allow the point to be on the unbounded line that contains the bounded segment.\r\n   */\r\n  public closestPoint(spacePoint: Point3d, extend: VariantCurveExtendParameter, result?: CurveLocationDetail): CurveLocationDetail {\r\n    let fraction = spacePoint.fractionOfProjectionToLine(this._point0, this._point1, 0.0);\r\n    fraction = CurveExtendOptions.correctFraction(extend, fraction);\r\n    result = CurveLocationDetail.create(this, result);\r\n    // remark: This can be done by result.setFP (fraction, thePoint, undefined, a)\r\n    //   but that creates a temporary point.\r\n    result.fraction = fraction;\r\n    this._point0.interpolate(fraction, this._point1, result.point);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.a = result.point.distance(spacePoint);\r\n    return result;\r\n  }\r\n  /** swap the endpoint references. */\r\n  public reverseInPlace(): void {\r\n    const a = this._point0;\r\n    this._point0 = this._point1;\r\n    this._point1 = a;\r\n  }\r\n  /** Transform the two endpoints of this LinSegment. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    this._point0 = transform.multiplyPoint3d(this._point0, this._point0);\r\n    this._point1 = transform.multiplyPoint3d(this._point1, this._point1);\r\n    return true;\r\n  }\r\n  /** Test if both endpoints are in a plane (within tolerance) */\r\n  public isInPlane(plane: PlaneAltitudeEvaluator): boolean {\r\n    return Geometry.isSmallMetricDistance(plane.altitude(this._point0))\r\n      && Geometry.isSmallMetricDistance(plane.altitude(this._point1));\r\n  }\r\n  /** Compute points of simple (transverse) with a plane.\r\n   * * Use isInPlane to test if the line segment is completely in the plane.\r\n   */\r\n  public appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number {\r\n    const h0 = plane.altitude(this._point0);\r\n    const h1 = plane.altitude(this._point1);\r\n    const fraction = Order2Bezier.solveCoffs(h0, h1);\r\n    let numIntersection = 0;\r\n    if (fraction !== undefined) {\r\n      numIntersection++;\r\n      const detail = CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction));\r\n      detail.intervalRole = CurveIntervalRole.isolated;\r\n      result.push(detail);\r\n    }\r\n    return numIntersection;\r\n  }\r\n  /**\r\n   * Extend a range to include the (optionally transformed) line segment\r\n   * @param range range to extend\r\n   * @param transform optional transform to apply to the end points\r\n   */\r\n  public extendRange(range: Range3d, transform?: Transform): void {\r\n    if (transform) {\r\n      range.extendTransformedPoint(transform, this._point0);\r\n      range.extendTransformedPoint(transform, this._point1);\r\n    } else {\r\n      range.extendPoint(this._point0);\r\n      range.extendPoint(this._point1);\r\n    }\r\n  }\r\n  /**\r\n   * Construct a line from either of these json forms:\r\n   *\r\n   * * object with named start and end:\r\n   * `{startPoint: pointValue, endPoint: pointValue}`\r\n   * * array of two point values:\r\n   * `[pointValue, pointValue]`\r\n   * The point values are any values accepted by the Point3d method setFromJSON.\r\n   * @param json data to parse.\r\n   */\r\n  public setFromJSON(json?: any) {\r\n    if (!json) {\r\n      this._point0.set(0, 0, 0);\r\n      this._point1.set(1, 0, 0);\r\n      return;\r\n    } else if (json.startPoint && json.endPoint) { // {startPoint:json point, endPoint:json point}\r\n      this._point0.setFromJSON(json.startPoint);\r\n      this._point1.setFromJSON(json.endPoint);\r\n    } else if (Array.isArray(json)\r\n      && json.length > 1) { // [json point, json point]\r\n      this._point0.setFromJSON(json[0]);\r\n      this._point1.setFromJSON(json[1]);\r\n    }\r\n  }\r\n  /** A simple line segment's fraction and distance are proportional. */\r\n  public getFractionToDistanceScale(): number | undefined { return this.curveLength(); }\r\n  /**\r\n   * Place the lineSegment3d start and points in a json object\r\n   * @return {*} [[x,y,z],[x,y,z]]\r\n   */\r\n  public toJSON(): any { return [this._point0.toJSON(), this._point1.toJSON()]; }\r\n  /** Create a new `LineSegment3d` with coordinates from json object.   See `setFromJSON` for object layout description. */\r\n  public static fromJSON(json?: any): LineSegment3d {\r\n    const result = new LineSegment3d(Point3d.createZero(), Point3d.create());\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Near equality test with `other`. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof LineSegment3d) {\r\n      const ls = other as LineSegment3d;\r\n      return this._point0.isAlmostEqual(ls._point0) && this._point1.isAlmostEqual(ls._point1);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Emit strokes to caller-supplied linestring */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const numStroke = this.computeStrokeCountForOptions(options);\r\n    dest.appendFractionalStrokePoints(this, numStroke, 0.0, 1.0);\r\n  }\r\n  /** Emit strokes to caller-supplied handler */\r\n  public emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void {\r\n    handler.startCurvePrimitive(this);\r\n    const numStroke = this.computeStrokeCountForOptions(options);\r\n    handler.announceSegmentInterval(this, this._point0, this._point1, numStroke, 0.0, 1.0);\r\n    handler.endCurvePrimitive(this);\r\n  }\r\n\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    let numStroke = 1;\r\n    if (options) {\r\n      if (options.maxEdgeLength)\r\n        numStroke = options.applyMaxEdgeLength(numStroke, this.curveLength());\r\n      numStroke = options.applyMinStrokesPerPrimitive(numStroke);\r\n    }\r\n    return numStroke;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleLineSegment3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleLineSegment3d(this);\r\n  }\r\n\r\n  /**\r\n   * Find intervals of this curve primitive that are interior to a clipper\r\n   * @param clipper clip structure (e.g. clip planes)\r\n   * @param announce function to be called announcing fractional intervals\"  ` announce(fraction0, fraction1, curvePrimitive)`\r\n   */\r\n  public announceClipIntervals(clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    return clipper.announceClippedSegmentIntervals(0.0, 1.0, this._point0, this._point1,\r\n      announce ? (fraction0: number, fraction1: number) => announce(fraction0, fraction1, this) : undefined);\r\n  }\r\n\r\n  /** Return (if possible) a curve primitive which is a portion of this curve.\r\n   * @param fractionA [in] start fraction\r\n   * @param fractionB [in] end fraction\r\n   */\r\n  public clonePartialCurve(fractionA: number, fractionB: number): CurvePrimitive | undefined {\r\n    return LineString3d.create(this.fractionToPoint(fractionA), this.fractionToPoint(fractionB));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { Geometry, AxisOrder, BeJSONFunctions, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { XAndY } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive, AnnounceNumberNumberCurvePrimitive } from \"./CurvePrimitive\";\r\nimport { StrokeCountMap } from \"./Query/StrokeCountMap\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurveLocationDetail, CurveSearchStatus, CurveIntervalRole } from \"./CurveLocationDetail\";\r\nimport { Clipper } from \"../clipping/ClipUtils\";\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { MultiLineStringDataVariant } from \"../topology/Triangulation\";\r\nimport { PointStreamGrowableXYZArrayCollector, VariantPointDataStream } from \"../geometry3d/PointStreaming\";\r\n\r\n/* tslint:disable:variable-name no-empty*/\r\n\r\n/* Starting with baseIndex and moving index by stepDirection:\r\nIf the vector from baseIndex to baseIndex +1 crossed with vectorA can be normalized, accumulate it (scaled) to normal.\r\nReturn when successful.\r\n(Do nothing if everything is parallel through limits of the array)\r\n*/\r\nfunction accumulateGoodUnitPerpendicular(\r\n  points: GrowableXYZArray,\r\n  vectorA: Vector3d,\r\n  baseIndex: number,\r\n  stepDirection: number,\r\n  weight: number,\r\n  normal: Vector3d,\r\n  workVector: Vector3d): boolean {\r\n  const n = points.length;\r\n  if (stepDirection > 0) {\r\n    for (let i = baseIndex; i + 1 < n; i++) {\r\n      points.vectorIndexIndex(i, i + 1, workVector);\r\n      vectorA.crossProduct(workVector, workVector);\r\n      if (workVector.normalizeInPlace()) {\r\n        normal.addScaledInPlace(workVector, weight);\r\n        return true;\r\n      }\r\n    }\r\n  } else {\r\n    if (baseIndex + 1 >= n)\r\n      baseIndex = n - 2;\r\n    for (let i = baseIndex; i >= 0; i--) {\r\n      points.vectorIndexIndex(i, i + 1, workVector);\r\n      workVector.crossProduct(vectorA, workVector);\r\n      if (workVector.normalizeInPlace()) {\r\n        normal.addScaledInPlace(workVector, weight);\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n/**\r\n * * A LineString3d (sometimes called a PolyLine) is a sequence of xyz coordinates that are to be joined by line segments.\r\n * * The point coordinates are stored in a GrowableXYZArray, not as full point objects\r\n * * The parameterization of \"fraction along\" is\r\n *    * In a linestring with `N` segments (i.e. `N+1` points), each segment (regardless of physical length) occupies the same fraction (1/N) of the 0-to-1 fraction space.\r\n *    * Within segment `i`, the fraction interval `i/N` to `(i+1)/N` is mapped proportionally to the segment\r\n *    * Note that this `fraction` is therefore NOT fraction of true distance along.\r\n *       * Use `moveSignedDistanceFromFraction` to do true-length evaluations.\r\n * @public\r\n */\r\nexport class LineString3d extends CurvePrimitive implements BeJSONFunctions {\r\n  /** String name for schema properties */\r\n  public readonly curvePrimitiveType = \"lineString\";\r\n\r\n  private static _workPointA = Point3d.create();\r\n  private static _workPointB = Point3d.create();\r\n  private static _workPointC = Point3d.create();\r\n  private static _workRay = Ray3d.createXAxis();\r\n  /** test if `other` is an instance of `LineString3d` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof LineString3d; }\r\n  /**\r\n   * A LineString3d extends along its first and final segments.\r\n   */\r\n  public get isExtensibleFractionSpace(): boolean { return true; }\r\n\r\n  private _points: GrowableXYZArray;\r\n  private _fractions?: GrowableFloat64Array;\r\n  private _uvParams?: GrowableXYArray;\r\n  private _derivatives?: GrowableXYZArray;\r\n  private _surfaceNormals?: GrowableXYZArray;\r\n\r\n  private _pointIndices?: GrowableFloat64Array;\r\n  private _uvIndices?: GrowableFloat64Array;\r\n  private _normalIndices?: GrowableFloat64Array;\r\n\r\n  /** return the points array (cloned). */\r\n  public get points(): Point3d[] { return this._points.getPoint3dArray(); }\r\n  /** Return (reference to) point data in packed GrowableXYZArray. */\r\n  public get packedPoints(): GrowableXYZArray { return this._points; }\r\n  /** Return array of fraction parameters.\r\n   * * These Are only present during certain constructions such as faceting.\r\n   * * When present, these fractions are fractions of some other curve being stroked, and are NOT related to the linestring fraction parameters.\r\n   */\r\n  public get fractions(): GrowableFloat64Array | undefined { return this._fractions; }\r\n  /** Return the (optional) array of derivatives. These Are only present during certain constructions such as faceting. */\r\n  public get packedDerivatives(): GrowableXYZArray | undefined { return this._derivatives; }\r\n  /** Return the (optional) array of uv params. These Are only present during certain constructions such as faceting. */\r\n  public get packedUVParams(): GrowableXYArray | undefined { return this._uvParams; }\r\n  /** Return the (optional) array of surface normals. These Are only present during certain constructions such as faceting. */\r\n  public get packedSurfaceNormals(): GrowableXYZArray | undefined { return this._surfaceNormals; }\r\n  /** Return the (optional) array of normal indices. These Are only present during certain constructions such as faceting. */\r\n  public get normalIndices(): GrowableFloat64Array | undefined { return this._normalIndices; }\r\n  /** Return the (optional) array of param indices. These Are only present during certain constructions such as faceting. */\r\n  public get paramIndices(): GrowableFloat64Array | undefined { return this._uvIndices; }\r\n  /** Return the (optional) array of point indices. These Are only present during certain constructions such as faceting. */\r\n  public get pointIndices(): GrowableFloat64Array | undefined { return this._pointIndices; }\r\n\r\n  private constructor(points?: GrowableXYZArray) {\r\n    super();\r\n    if (points)\r\n      this._points = points;\r\n    else\r\n      this._points = new GrowableXYZArray();\r\n  }\r\n  /** Clone this linestring and apply the transform to the clone points. */\r\n  public cloneTransformed(transform: Transform): CurvePrimitive {  // we know tryTransformInPlace succeeds.\r\n    const c = this.clone();\r\n    c.tryTransformInPlace(transform);\r\n    return c;\r\n  }\r\n  /** Create a linestring, using flex length arg list and any typical combination of points such as\r\n   * Point3d, Point2d, `[1,2,3]', array of any of those, or GrowableXYZArray\r\n   */\r\n  public static create(...points: any[]): LineString3d {\r\n    const result = new LineString3d();\r\n    result.addPoints(points);\r\n    return result;\r\n  }\r\n  /** Create a linestring, capturing the given GrowableXYZArray as the points.\r\n   * Point3d, Point2d, `[1,2,3]', array of any of those, or GrowableXYZArray\r\n   */\r\n  public static createCapture(points: GrowableXYZArray): LineString3d {\r\n    return new LineString3d(points);\r\n\r\n  }\r\n\r\n  /** Create a linestring from `XAndY` points, with a specified z applied to all. */\r\n  public static createXY(points: XAndY[], z: number, enforceClosure: boolean = false): LineString3d {\r\n    const result = new LineString3d();\r\n    const xyz = result._points;\r\n    for (const xy of points) {\r\n      xyz.pushXYZ(xy.x, xy.y, z);\r\n    }\r\n    if (enforceClosure && points.length > 1) {\r\n      const distance = xyz.distanceIndexIndex(0, xyz.length - 1);\r\n      if (distance !== undefined && distance !== 0.0) {\r\n        if (Geometry.isSameCoordinate(0, distance)) {\r\n          xyz.pop();   // nonzero but small distance -- to be replaced by point 0 exactly.\r\n          const xyzA = xyz.front();\r\n          xyz.push(xyzA!);\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Add points to the linestring.\r\n   * Valid inputs are:\r\n   * * a Point2d\r\n   * * a point3d\r\n   * * An array of 2 doubles\r\n   * * An array of 3 doubles\r\n   * * A GrowableXYZArray\r\n   * * An array of any of the above\r\n   */\r\n  public addPoints(...points: any[]) {\r\n    this._points.pushFrom(points);\r\n  }\r\n  /** Add points accessed by index in a GrowableXYZArray, with a specified index step. */\r\n  public addSteppedPoints(source: GrowableXYZArray, pointIndex0: number, step: number, numAdd: number) {\r\n    this._points.addSteppedPoints(source, pointIndex0, step, numAdd);\r\n  }\r\n\r\n  /**\r\n   * Add a point to the linestring.\r\n   * @param point\r\n   */\r\n  public addPoint(point: Point3d) {\r\n    this._points.push(point);\r\n  }\r\n  /**\r\n   * Add a point to the linestring.\r\n   * @param point\r\n   */\r\n  public addPointXYZ(x: number, y: number, z: number = 0) {\r\n    this._points.pushXYZ(x, y, z);\r\n  }\r\n  /**\r\n   * Append a fraction to the fractions array.\r\n   * @param fraction\r\n   */\r\n  public addFraction(fraction: number) {\r\n    if (!this._fractions)\r\n      this._fractions = new GrowableFloat64Array();\r\n    this._fractions.push(fraction);\r\n  }\r\n\r\n  /** Ensure that the fraction array exists with no fractions but at least the capacity of the point array. */\r\n  public ensureEmptyFractions(): GrowableFloat64Array {\r\n    const n = this.numPoints();\r\n    if (!this._fractions) {\r\n      this._fractions = new GrowableFloat64Array(n);\r\n      return this._fractions;\r\n    }\r\n    this._fractions.clear();\r\n    this._fractions.ensureCapacity(n);\r\n    return this._fractions;\r\n  }\r\n  /** Ensure that the parameter array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptyUVParams(): GrowableXYArray {\r\n    const n = this.numPoints();\r\n    if (!this._uvParams) {\r\n      this._uvParams = new GrowableXYArray(n);\r\n      return this._uvParams;\r\n    }\r\n    this._uvParams.clear();\r\n    this._uvParams.ensureCapacity(n);\r\n    return this._uvParams;\r\n  }\r\n  /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptySurfaceNormals(): GrowableXYZArray {\r\n    const n = this.numPoints();\r\n    if (!this._surfaceNormals) {\r\n      this._surfaceNormals = new GrowableXYZArray(n);\r\n      return this._surfaceNormals;\r\n    }\r\n    this._surfaceNormals.clear();\r\n    this._surfaceNormals.ensureCapacity(n);\r\n    return this._surfaceNormals;\r\n  }\r\n\r\n  /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptyDerivatives(): GrowableXYZArray {\r\n    const n = this.numPoints();\r\n    if (!this._derivatives) {\r\n      this._derivatives = new GrowableXYZArray(n);\r\n      return this._derivatives;\r\n    }\r\n    this._derivatives.clear();\r\n    this._derivatives.ensureCapacity(n);\r\n    return this._derivatives;\r\n  }\r\n\r\n  /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptyNormalIndices(): GrowableFloat64Array {\r\n    const n = this.numPoints();\r\n    if (!this._normalIndices) {\r\n      this._normalIndices = new GrowableFloat64Array(n);\r\n      return this._normalIndices;\r\n    }\r\n    this._normalIndices.clear();\r\n    this._normalIndices.ensureCapacity(n);\r\n    return this._normalIndices;\r\n  }\r\n\r\n  /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptyUVIndices(): GrowableFloat64Array {\r\n    const n = this.numPoints();\r\n    if (!this._uvIndices) {\r\n      this._uvIndices = new GrowableFloat64Array(n);\r\n      return this._uvIndices;\r\n    }\r\n    this._uvIndices.clear();\r\n    this._uvIndices.ensureCapacity(n);\r\n    return this._uvIndices;\r\n  }\r\n\r\n  /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptyPointIndices(): GrowableFloat64Array {\r\n    const n = this.numPoints();\r\n    if (!this._pointIndices) {\r\n      this._pointIndices = new GrowableFloat64Array(n);\r\n      return this._pointIndices;\r\n    }\r\n    this._pointIndices.clear();\r\n    this._pointIndices.ensureCapacity(n);\r\n    return this._pointIndices;\r\n  }\r\n\r\n  /**\r\n   * Append a uv coordinate to the uvParams array\r\n   * @param uv\r\n   */\r\n  public addUVParam(uvParam: XAndY) {\r\n    if (!this._uvParams)\r\n      this._uvParams = new GrowableXYArray();\r\n    this._uvParams.pushXY(uvParam.x, uvParam.y);\r\n  }\r\n\r\n  /**\r\n   * Append a uv coordinate to the uvParams array\r\n   * @param uv\r\n   */\r\n  public addUVParamAsUV(u: number, v: number) {\r\n    if (!this._uvParams)\r\n      this._uvParams = new GrowableXYArray();\r\n    this._uvParams.pushXY(u, v);\r\n  }\r\n\r\n  /**\r\n   * Append a derivative to the derivative array\r\n   * @param vector\r\n   */\r\n  public addDerivative(vector: Vector3d) {\r\n    if (!this._derivatives)\r\n      this._derivatives = new GrowableXYZArray();\r\n    this._derivatives.push(vector);\r\n  }\r\n\r\n  /**\r\n   * Append a surface normal to the surface normal array.\r\n   * @param vector\r\n   */\r\n  public addSurfaceNormal(vector: Vector3d) {\r\n    if (!this._surfaceNormals)\r\n      this._surfaceNormals = new GrowableXYZArray();\r\n    this._surfaceNormals.push(vector);\r\n  }\r\n\r\n  /**\r\n   * If the linestring is not already closed, add a closure point.\r\n   */\r\n  public addClosurePoint() {\r\n    const distance = this._points.distanceIndexIndex(0, this._points.length - 1);\r\n    if (distance !== undefined && !Geometry.isSameCoordinate(distance, 0))\r\n      this._points.pushWrap(1);\r\n  }\r\n  /** Eliminate (but do not return!!) the final point of the linestring */\r\n  public popPoint() {\r\n    this._points.pop();\r\n  }\r\n  /** Compute `uvParams` array as (xy parts of) a linear transform of the xyz coordinates */\r\n  public computeUVFromXYZTransform(transform: Transform) {\r\n    this._uvParams = GrowableXYArray.createFromGrowableXYZArray(this._points, transform);\r\n  }\r\n  /** Create the linestring for a rectangle parallel to the xy plane.\r\n   * * The z coordinate from `point0` is used for all points.\r\n   * * `ax` and `ay` are signed.\r\n   * * The point sequence is:\r\n   *    * Start at `point0`\r\n   *    * move by (signed !) `ax` in the x direction.\r\n   *    * move by (signed !) `ay` in the y direction.\r\n   *    * move by (signed !) negative `ax` in the x direction.\r\n   *    * move by (signed !) negative `ay` in the y direction.\r\n   *    * (this returns to `point0`)\r\n   */\r\n  public static createRectangleXY(point0: Point3d, ax: number, ay: number, closed: boolean = true): LineString3d {\r\n    const ls = LineString3d.create();\r\n    const x0 = point0.x;\r\n    const x1 = point0.x + ax;\r\n    const y0 = point0.y;\r\n    const y1 = point0.y + ay;\r\n    const z = point0.z;\r\n    ls.addPointXYZ(x0, y0, z);\r\n    ls.addPointXYZ(x1, y0, z);\r\n    ls.addPointXYZ(x1, y1, z);\r\n    ls.addPointXYZ(x0, y1, z);\r\n    if (closed)\r\n      ls.addClosurePoint();\r\n    return ls;\r\n  }\r\n  /**\r\n   * Create a regular polygon centered\r\n   * @param center center of the polygon.\r\n   * @param edgeCount number of edges.\r\n   * @param radius distance to vertex or edge (see `radiusToVertices`)\r\n   * @param radiusToVertices true if polygon is inscribed in circle (radius measured to vertices); false if polygon is outside circle (radius to edges)\r\n   */\r\n  public static createRegularPolygonXY(center: Point3d, edgeCount: number, radius: number, radiusToVertices: boolean = true): LineString3d {\r\n    if (edgeCount < 3)\r\n      edgeCount = 3;\r\n    const ls = LineString3d.create();\r\n    const i0 = radiusToVertices ? 0 : -1;   // offset to make first vector (radius,0,0)\r\n    const radiansStep = Math.PI / edgeCount;\r\n    let c;\r\n    let s;\r\n    let radians;\r\n    if (!radiusToVertices)\r\n      radius = radius / Math.cos(radiansStep);\r\n    for (let i = 0; i < edgeCount; i++) {\r\n      radians = (i0 + 2 * i) * radiansStep;\r\n      c = Angle.cleanupTrigValue(Math.cos(radians));\r\n      s = Angle.cleanupTrigValue(Math.sin(radians));\r\n      ls.addPointXYZ(center.x + radius * c, center.y + radius * s, center.z);\r\n    }\r\n    ls.addClosurePoint();\r\n    return ls;\r\n  }\r\n\r\n  /**\r\n   * Copy coordinate data from another linestring.\r\n   *  * The copied content is:\r\n   *    * points\r\n   *    * derivatives (if present)\r\n   *    * fractions (if present)\r\n   *    * surfaceNormals (if present)\r\n   *    * uvParams (if present)\r\n   * @param other\r\n   */\r\n  public setFrom(other: LineString3d) {\r\n    // ugly -- \"clone\" methods are inconsistent about 'reuse' and 'result' parameter . . .\r\n    this._points = other._points.clone(this._points);\r\n    if (other._derivatives)\r\n      this._derivatives = other._derivatives.clone(this._derivatives);\r\n    else\r\n      this._derivatives = undefined;\r\n    if (other._fractions)\r\n      this._fractions = other._fractions.clone(false);\r\n    else this._fractions = undefined;\r\n    if (other._surfaceNormals)\r\n      this._surfaceNormals = other._surfaceNormals.clone(this._surfaceNormals);\r\n    else\r\n      this._surfaceNormals = undefined;\r\n    if (other._uvParams)\r\n      this._uvParams = other._uvParams.clone();\r\n    else\r\n      this._uvParams = undefined;\r\n  }\r\n  /** Create a linestring from an array of points. */\r\n  public static createPoints(points: Point3d[]): LineString3d {\r\n    const ls = new LineString3d();\r\n    let point;\r\n    for (point of points)\r\n      ls._points.push(point);\r\n    return ls;\r\n  }\r\n  /** Create a linestring, taking points at specified indices from an array of points. */\r\n  public static createIndexedPoints(points: Point3d[], index: number[], addClosure: boolean = false): LineString3d {\r\n    const ls = new LineString3d();\r\n    for (const i of index)\r\n      ls._points.push(points[i]); // no clone needed -- we know this reformats to packed array.\r\n    if (addClosure && index.length > 1)\r\n      ls._points.push(points[index[0]]);\r\n    return ls;\r\n  }\r\n\r\n  /** Create a LineString3d from xyz coordinates packed in a Float64Array */\r\n  public static createFloat64Array(xyzData: Float64Array): LineString3d {\r\n    const ls = new LineString3d();\r\n    for (let i = 0; i + 3 <= xyzData.length; i += 3)\r\n      ls._points.push(Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));\r\n    return ls;\r\n  }\r\n  /** Return a clone of this linestring. */\r\n  public clone(): LineString3d {\r\n    const retVal = new LineString3d();\r\n    retVal.setFrom(this);\r\n    return retVal;\r\n  }\r\n  /** Set point coordinates from a json array, e.g. `[[1,2,3],[4,5,6] . . .]`\r\n   * * The `json` parameter must be an array.\r\n   * * Each member `i` of the array is converted to a point with `Point3d.fromJSON(json[i]`)\r\n   */\r\n  public setFromJSON(json?: any) {\r\n    this._points.clear();\r\n    if (Array.isArray(json)) {\r\n      let xyz;\r\n      for (xyz of json)\r\n        this._points.push(Point3d.fromJSON(xyz));\r\n    }\r\n  }\r\n  /**\r\n   * Convert an LineString3d to a JSON object.\r\n   * * The returned object is an array of arrays of x,y,z coordinates, `[[x,y,z],...[x,y,z]]`\r\n   */\r\n  public toJSON(): any {\r\n    const value = [];\r\n    let i = 0;\r\n    while (this._points.isIndexValid(i)) {\r\n      value.push(this._points.getPoint3dAtUncheckedPointIndex(i).toJSON());\r\n      i++;\r\n    }\r\n    return value;\r\n  }\r\n  /** construct a new linestring.\r\n   * * See `LineString3d.setFromJSON ()` for remarks on `json` structure.\r\n   */\r\n  public static fromJSON(json?: any): LineString3d {\r\n    const ls = new LineString3d(); ls.setFromJSON(json); return ls;\r\n  }\r\n  /**\r\n   * Evaluate a point a fractional position along this linestring.\r\n   * * See `LineString3d` class comments for description of how fraction relates to the linestring points.\r\n   * @param fraction fractional position\r\n   * @param result optional result\r\n   */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    const n = this._points.length;\r\n    if (n === 0)\r\n      return Point3d.createZero();\r\n    if (n === 1)\r\n      return Point3d.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0), result);\r\n    const df = 1.0 / (n - 1);\r\n    if (fraction <= df)\r\n      return this._points.interpolate(0, fraction / df, 1, result)!;\r\n    if (fraction + df >= 1.0)\r\n      return this._points.interpolate(n - 1, (1.0 - fraction) / df, n - 2, result)!;\r\n    const index0 = Math.floor(fraction / df);\r\n    return this._points.interpolate(index0, (fraction - index0 * df) / df, index0 + 1, result)!;\r\n  }\r\n\r\n  /**\r\n   * Evaluate a point a fractional position and derivative with respect to fraction along this linestring.\r\n   * * See `LineString3d` class comments for description of how fraction relates to the linestring points.\r\n   * @param fraction fractional position\r\n   * @param result optional result\r\n   */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    const n = this._points.length;\r\n    if (n <= 1) {\r\n      result.direction.setZero();\r\n      if (n === 1)\r\n        result.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0));\r\n      else result.origin.setZero();\r\n      return result;\r\n    }\r\n    const numSegment = n - 1;\r\n    const df = 1.0 / numSegment;\r\n    if (fraction <= df) {\r\n      result = result ? result : Ray3d.createZero();\r\n      this._points.interpolate(0, fraction / df, 1, result.origin);\r\n      this._points.vectorIndexIndex(0, 1, result.direction);\r\n      result.direction.scaleInPlace(1.0 / df);\r\n      return result;\r\n    }\r\n\r\n    if (fraction + df >= 1.0) {\r\n      result = result ? result : Ray3d.createZero();\r\n      this._points.interpolate(n - 2, 1.0 - (1.0 - fraction) / df, n - 1, result.origin);\r\n      this._points.vectorIndexIndex(n - 2, n - 1, result.direction);\r\n      result.direction.scaleInPlace(1.0 / df);\r\n      return result;\r\n    }\r\n\r\n    /* true interior point */\r\n    result = result ? result : Ray3d.createZero();\r\n    const index0 = Math.floor(fraction / df);\r\n    const localFraction = (fraction - index0 * df) / df;\r\n    this._points.interpolate(index0, localFraction, index0 + 1, result.origin);\r\n    this._points.vectorIndexIndex(index0, index0 + 1, result.direction);\r\n    result.direction.scaleInPlace(1.0 / df);\r\n    return result;\r\n  }\r\n\r\n  /** Return point and derivative at fraction, with 000 second derivative. */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const ray = this.fractionToPointAndDerivative(fraction);\r\n    result = Plane3dByOriginAndVectors.createCapture(ray.origin, ray.direction, Vector3d.createZero(), result);\r\n    return result;\r\n  }\r\n  /**\r\n   * Convert a segment index and local fraction to a global fraction.\r\n   * @param index index of segment being evaluated\r\n   * @param localFraction local fraction within that segment\r\n   */\r\n  public segmentIndexAndLocalFractionToGlobalFraction(index: number, localFraction: number): number {\r\n    const numSegment = this._points.length - 1;\r\n    if (numSegment < 1)\r\n      return 0.0;\r\n    return (index + localFraction) / numSegment;\r\n  }\r\n  /** Return a frenet frame, using nearby points to estimate a plane. */\r\n  public fractionToFrenetFrame(fraction: number, result?: Transform): Transform {\r\n    const n = this._points.length;\r\n    if (n <= 1) {\r\n      if (n === 1)\r\n        return Transform.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0), result);\r\n      return Transform.createIdentity(result);\r\n    }\r\n\r\n    if (n === 2)\r\n      return Transform.createRefs(\r\n        this._points.interpolate(0, fraction, 1)!,\r\n        Matrix3d.createRigidHeadsUp(this._points.vectorIndexIndex(0, 1)!, AxisOrder.XYZ));\r\n\r\n    /** 3 or more points. */\r\n    const numSegment = n - 1;\r\n    const df = 1.0 / numSegment;\r\n    let baseIndex = 0;\r\n    let localFraction = 0;\r\n    if (fraction <= df) {\r\n      localFraction = fraction / df;\r\n      baseIndex = 0;\r\n    } else if (fraction + df >= 1.0) {\r\n      baseIndex = n - 2;\r\n      localFraction = 1.0 - (1.0 - fraction) / df;\r\n    } else {\r\n      baseIndex = Math.floor(fraction / df);\r\n      localFraction = fraction * numSegment - baseIndex;\r\n    }\r\n\r\n    const origin = this._points.interpolate(baseIndex, localFraction, baseIndex + 1)!;\r\n    const vectorA = this._points.vectorIndexIndex(baseIndex, baseIndex + 1)!;\r\n    // tricky stuff to handle colinear points.   But if vectorA is zero it is still a mess . ..\r\n    const normal = Vector3d.create();\r\n    const workVector = Vector3d.create();\r\n    if (baseIndex === 0) {  // only look forward\r\n      accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, 1.0, normal, workVector);\r\n    } else if (baseIndex + 2 >= n) { // only look back\r\n      accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, 1.0, normal, workVector);\r\n    } else {\r\n      accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, (1.0 - localFraction), normal, workVector);\r\n      accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, (localFraction), normal, workVector);\r\n    }\r\n    const matrix = Matrix3d.createRigidFromColumns(normal, vectorA, AxisOrder.ZXY);\r\n    if (matrix)\r\n      return Transform.createOriginAndMatrix(origin, matrix, result);\r\n    return Transform.createTranslation(origin, result);\r\n  }\r\n  /** evaluate the start point of the linestring. */\r\n  public startPoint() {\r\n    if (this._points.length === 0)\r\n      return Point3d.createZero();\r\n    return this._points.getPoint3dAtUncheckedPointIndex(0);\r\n  }\r\n  /** If i is a valid index, return that point. */\r\n  public pointAt(i: number, result?: Point3d): Point3d | undefined {\r\n    if (this._points.isIndexValid(i))\r\n      return this._points.getPoint3dAtUncheckedPointIndex(i, result);\r\n    return undefined;\r\n  }\r\n  /** If i and j are both valid indices, return the vector from point i to point j\r\n   */\r\n  public vectorBetween(i: number, j: number, result?: Vector3d): Vector3d | undefined {\r\n    return this._points.vectorIndexIndex(i, j, result);\r\n  }\r\n  /** If i is a valid index, return that stored derivative vector. */\r\n  public derivativeAt(i: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this._derivatives && this._derivatives.isIndexValid(i))\r\n      return this._derivatives.getVector3dAtCheckedVectorIndex(i, result);\r\n    return undefined;\r\n  }\r\n\r\n  /** If i is a valid index, return that stored surfaceNormal vector. */\r\n  public surfaceNormalAt(i: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this._surfaceNormals && this._surfaceNormals.isIndexValid(i))\r\n      return this._surfaceNormals.getVector3dAtCheckedVectorIndex(i, result);\r\n    return undefined;\r\n  }\r\n  /** Return the number of points in this linestring. */\r\n  public numPoints(): number { return this._points.length; }\r\n  /** evaluate the end point of the linestring. */\r\n  public endPoint() {\r\n    if (this._points.length === 0)\r\n      return Point3d.createZero();\r\n    return this._points.getPoint3dAtUncheckedPointIndex(this._points.length - 1);\r\n  }\r\n  /** Reverse the points within the linestring. */\r\n  public reverseInPlace(): void {\r\n    if (this._points.length >= 2) {\r\n      let i0 = 0;\r\n      let i1 = this._points.length - 1;\r\n      let a: Point3d = this._points.getPoint3dAtUncheckedPointIndex(0);\r\n      while (i0 < i1) {\r\n        a = this._points.getPoint3dAtUncheckedPointIndex(i0);\r\n        this._points.setAtCheckedPointIndex(i0, this._points.getPoint3dAtUncheckedPointIndex(i1));\r\n        this._points.setAtCheckedPointIndex(i1, a);\r\n        i0++;\r\n        i1--;\r\n      }\r\n    }\r\n  }\r\n  /** Apply `transform` to each point of this linestring. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    this._points.multiplyTransformInPlace(transform);\r\n    if (this._derivatives)\r\n      this._derivatives.multiplyMatrix3dInPlace(transform.matrix);\r\n    if (this._surfaceNormals)\r\n      this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(transform.matrix);\r\n    return true;\r\n  }\r\n\r\n  /** Sum the lengths of segments within the linestring */\r\n  public curveLength(): number { return this._points.sumLengths(); }\r\n  /** Sum the lengths of segments between fractional positions on a linestring. */\r\n  public curveLengthBetweenFractions(fraction0: number, fraction1: number): number {\r\n    const numSegments = this._points.length - 1;\r\n    if (fraction1 === fraction0 || numSegments < 1)\r\n      return 0.0;\r\n    if (fraction1 < fraction0)\r\n      return this.curveLengthBetweenFractions(fraction1, fraction0);\r\n    const scaledFraction0 = fraction0 * numSegments;\r\n    const scaledFraction1 = fraction1 * numSegments;\r\n    const index0 = Math.max(1, Math.ceil(scaledFraction0));\r\n    const index1 = Math.min(Math.floor(scaledFraction1), numSegments - 1);\r\n    const localFraction0 = index0 - scaledFraction0;\r\n    const localFraction1 = scaledFraction1 - index1;\r\n    if (index0 > index1) {\r\n      // the interval is entirely within a single segment\r\n      return Math.abs(scaledFraction1 - scaledFraction0) * this._points.distanceIndexIndex(index0 - 1, index0)!;\r\n    } else {\r\n      // there is leading partial interval, 0 or more complete segments, and a trailing partial interval.\r\n      // (either or both partial may be zero length)\r\n      let sum = localFraction0 * this._points.distanceIndexIndex(index0 - 1, index0)!\r\n        + localFraction1 * (this._points.distanceIndexIndex(index1, index1 + 1))!;\r\n      for (let i = index0; i < index1; i++)\r\n        sum += this._points.distanceIndexIndex(i, i + 1)!;\r\n      return sum;\r\n    }\r\n  }\r\n  /**\r\n   * * Implementation of `CurvePrimitive.moveSignedDistanceFromFraction`.  (see comments there!)\r\n   * * Find the segment that contains the start fraction\r\n   * * Move point-by-point from that position to the start or end (respectively for negative or positive signedDistance)\r\n   * * Optionally extrapolate\r\n   * @param startFraction\r\n   * @param signedDistance\r\n   * @param allowExtension\r\n   * @param result\r\n   */\r\n  public moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: false, result?: CurveLocationDetail): CurveLocationDetail {\r\n    const numSegments = this._points.length - 1;\r\n    const scaledFraction = startFraction * numSegments;\r\n    let leftPointIndex = Geometry.restrictToInterval(Math.floor(scaledFraction), 0, numSegments - 1);  // lower point index on active segment.\r\n    const localFraction = scaledFraction - leftPointIndex;\r\n    const point0 = this._points.interpolate(leftPointIndex, localFraction, leftPointIndex + 1, LineString3d._workPointA)!;\r\n    const point1 = LineString3d._workPointB;\r\n    const context = new MoveByDistanceContext(point0, startFraction, signedDistance);\r\n\r\n    if (signedDistance > 0.0) {\r\n      for (; leftPointIndex <= numSegments;) {\r\n        leftPointIndex++;\r\n        this._points.getPoint3dAtCheckedPointIndex(leftPointIndex, point1);\r\n        if (context.announcePoint(point1, leftPointIndex / numSegments))\r\n          return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0,\r\n            signedDistance, CurveSearchStatus.success, result);\r\n      }\r\n      // fall through for extrapolation from final segment\r\n      if (allowExtension)\r\n        context.announceExtrapolation(this._points, numSegments - 1, numSegments,\r\n          (numSegments - 1) / numSegments, 1.0);\r\n      return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0,\r\n        signedDistance, context.distanceStatus(), result);\r\n    } else { // (moving backwards)\r\n      if (localFraction <= 0.0)\r\n        leftPointIndex--;\r\n      for (; leftPointIndex >= 0; leftPointIndex--) {\r\n        this._points.getPoint3dAtCheckedPointIndex(leftPointIndex, point1);\r\n        if (context.announcePoint(point1, leftPointIndex / numSegments))\r\n          return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0,\r\n            signedDistance, CurveSearchStatus.success, result);\r\n      }\r\n      // fall through for backward extrapolation from initial segment\r\n      if (allowExtension)\r\n        context.announceExtrapolation(this._points, 1, 0, 1.0 / numSegments, 0.0);\r\n      return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0,\r\n        -context.distance0, context.distanceStatus(), result);\r\n    }\r\n  }\r\n\r\n  /** sum lengths of segments in the linestring.  (This is a true length.) */\r\n  public quickLength(): number { return this.curveLength(); }\r\n  /**\r\n   * compute and normalize cross product among 3 points on the linestring.\r\n   * * \"any\" 3 points are acceptable -- no test for positive overall sense.\r\n   * * This is appropriate for polygon known to be convex.\r\n   * * use points spread at index step n/3, hopefully avoiding colinear points.\r\n   * * If that fails, try points 012\r\n   * @param result computed normal.\r\n   */\r\n  public quickUnitNormal(result?: Vector3d): Vector3d | undefined {\r\n    let step = Math.floor(this._points.length / 3);\r\n    if (step < 1)\r\n      step = 1;\r\n    result = this._points.crossProductIndexIndexIndex(0, step, step + step);\r\n    if (result && result.normalizeInPlace())\r\n      return result;\r\n    return undefined;\r\n  }\r\n\r\n  /** Find the point on the linestring (including its segment interiors) that is closest to spacePoint. */\r\n  public closestPoint(spacePoint: Point3d, extend: boolean, result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = CurveLocationDetail.create(this, result);\r\n\r\n    const numPoints = this._points.length;\r\n    if (numPoints > 0) {\r\n      const lastIndex = numPoints - 1;\r\n      result.setFP(1.0, this._points.getPoint3dAtUncheckedPointIndex(lastIndex), undefined);\r\n      result.setDistanceTo(spacePoint);\r\n      if (numPoints > 1) {\r\n        let segmentFraction = 0;\r\n        let d = 0;\r\n        const df = 1.0 / lastIndex;\r\n        for (let i = 1; i < numPoints; i++) {\r\n          segmentFraction = spacePoint.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i));\r\n          if (segmentFraction < 0) {\r\n            if (!extend || i > 1)\r\n              segmentFraction = 0.0;\r\n          } else if (segmentFraction > 1.0) {\r\n            if (!extend || i < lastIndex)\r\n              segmentFraction = 1.0;\r\n          }\r\n          this._points.getPoint3dAtUncheckedPointIndex(i - 1).interpolate(segmentFraction, this._points.getPoint3dAtUncheckedPointIndex(i), result.pointQ);\r\n          d = result.pointQ.distance(spacePoint);\r\n          if (d < result.a) {\r\n            result.setFP((i - 1 + segmentFraction) * df, result.pointQ, undefined, d);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Test if all points of the linestring are in a plane. */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return this._points.isCloseToPlane(plane, Geometry.smallMetricDistance);\r\n  }\r\n\r\n  /** push a hit, fixing up the prior entry if needed.\r\n   * return the incremented counter.\r\n   */\r\n  private static pushVertexHit(result: CurveLocationDetail[], counter: number, cp: CurvePrimitive, fraction: number, point: Point3d) {\r\n    const detail = CurveLocationDetail.createCurveFractionPoint(cp, fraction, point);\r\n    result.push(detail);\r\n    if (counter === 0) {\r\n      detail.setIntervalRole(CurveIntervalRole.isolatedAtVertex);\r\n    } else if (counter === 1) {  // last entry must be isolatedAtVertex !!!\r\n      result[result.length - 2].setIntervalRole(CurveIntervalRole.intervalStart);\r\n      detail.setIntervalRole(CurveIntervalRole.intervalEnd);\r\n    } else {\r\n      result[result.length - 2].setIntervalRole(CurveIntervalRole.intervalInterior);\r\n      detail.setIntervalRole(CurveIntervalRole.intervalEnd);\r\n    }\r\n  }\r\n  /** find intersections with a plane.\r\n   *  Intersections within segments are recorded as CurveIntervalRole.isolated\r\n   *   Intersections at isolated \"on\" vertex are recoded as CurveIntervalRole.isolatedAtVertex.\r\n   */\r\n  public appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number {\r\n    if (this._points.length < 1) return 0;\r\n    const initialLength = result.length;\r\n    const n = this._points.length;\r\n    const divisor = n === 1 ? 1.0 : n - 1;\r\n    const pointA = LineString3d._workPointA;\r\n    const pointB = LineString3d._workPointB;\r\n    const pointC = LineString3d._workPointC;\r\n    this._points.getPoint3dAtUncheckedPointIndex(0, pointA);\r\n    let hB = 0;\r\n    let numConsecutiveZero = 0;\r\n    let hA = 0;\r\n    let segmentFraction = 0;\r\n    for (let i = 0; i < this._points.length; i++ , pointA.setFrom(pointB), hA = hB) {\r\n      this._points.getPoint3dAtUncheckedPointIndex(i, pointB);\r\n      hB = Geometry.correctSmallMetricDistance(plane.altitude(pointB));\r\n      if (hB === 0.0)\r\n        LineString3d.pushVertexHit(result, numConsecutiveZero++, this, i / divisor, pointB);\r\n      else {\r\n        if (hA * hB < 0.0) {  // at point0, hA=0 will keep us out of here . ..\r\n          segmentFraction = hA / (hA - hB); // this division is safe because the signs are different.\r\n          pointA.interpolate(segmentFraction, pointB, pointC);\r\n          const detail = CurveLocationDetail.createCurveFractionPoint(this, (i - 1 + segmentFraction) / divisor, pointC);\r\n          detail.setIntervalRole(CurveIntervalRole.isolated);\r\n          result.push(detail);\r\n          numConsecutiveZero = 0;\r\n        }\r\n      }\r\n    }\r\n    return result.length - initialLength;\r\n  }\r\n  /** Extend `rangeToExtend` to include all points of this linestring. */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void { this._points.extendRange(rangeToExtend, transform); }\r\n  /** Test if each point of this linestring isAlmostEqual with corresponding point in `other`. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (!(other instanceof LineString3d))\r\n      return false;\r\n    if (!GrowableXYZArray.isAlmostEqual(this._points, other._points)) return false;\r\n    return true;\r\n  }\r\n  /** Append (clone of) one point.\r\n   * * BUT ... skip if duplicates the tail of prior points.\r\n   * * if fraction is given, \"duplicate\" considers both point and fraction.\r\n   */\r\n  public appendStrokePoint(point: Point3d, fraction?: number) {\r\n    const n = this._points.length;\r\n    let add = true;\r\n    const addFraction = fraction !== undefined && this._fractions !== undefined;\r\n    if (n > 0) {\r\n      if (addFraction && Geometry.isSameCoordinate(fraction!, this._fractions!.back()))\r\n        add = false;\r\n      if (point.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(n - 1)))\r\n        add = false;\r\n    }\r\n\r\n    if (add) {\r\n      this._points.push(point);\r\n      if (addFraction)\r\n        this.addFraction(fraction!);\r\n    }\r\n\r\n  }\r\n\r\n  /** Append a suitable evaluation of a curve ..\r\n   * * always append the curve point\r\n   * * if fraction array is present, append the fraction\r\n   * * if derivative array is present, append the derivative\r\n   * BUT ... skip if duplicates the tail of prior points.\r\n   */\r\n  public appendFractionToPoint(curve: CurvePrimitive, fraction: number) {\r\n    if (this._derivatives) {\r\n      const ray = curve.fractionToPointAndDerivative(fraction, LineString3d._workRay);\r\n      if (this._fractions)\r\n        this._fractions.push(fraction);\r\n      this._points.push(ray.origin);\r\n      if (this._derivatives)\r\n        this._derivatives.push(ray.direction);\r\n\r\n    } else {\r\n      const point = curve.fractionToPoint(fraction, LineString3d._workPointA);\r\n      if (this._fractions)\r\n        this._fractions.push(fraction);\r\n      this._points.push(point);\r\n    }\r\n  }\r\n  /**\r\n   * clear all array data:\r\n   * * points\r\n   * * optional fractions.\r\n   * * optional derivatives.\r\n   */\r\n  public clear() {\r\n    this._points.clear();\r\n    if (this._fractions)\r\n      this._fractions.clear();\r\n    if (this._derivatives)\r\n      this._derivatives.clear();\r\n  }\r\n  /**\r\n   * * options.needParams triggers creation of fraction array and uvParams array.\r\n   * * options.needNormals triggers creation of derivatives array\r\n   * @param capacity if positive, initial capacity of arrays\r\n   * @param options  optional, to indicate if fraction and derivative arrays are required.\r\n   */\r\n  public static createForStrokes(capacity: number = 0, options: StrokeOptions | undefined): LineString3d {\r\n    const ls = LineString3d.create();\r\n    if (capacity > 0)\r\n      ls._points.ensureCapacity(capacity);\r\n    if (options) {\r\n      if (options.needParams) {\r\n        ls._fractions = new GrowableFloat64Array(capacity);\r\n        ls._uvParams = new GrowableXYArray(capacity);\r\n      }\r\n      if (options.needNormals) {\r\n        ls._derivatives = new GrowableXYZArray(capacity);\r\n        ls._surfaceNormals = new GrowableXYZArray(capacity);\r\n      }\r\n    }\r\n    return ls;\r\n  }\r\n\r\n  /** Evaluate a curve at uniform fractions.  Append the evaluations to this linestring.\r\n   * @param curve primitive to evaluate.\r\n   * @param numStrokes number of strokes (edges).\r\n   * @param fraction0 starting fraction coordinate\r\n   * @param fraction1 end fraction coordinate\r\n   * @param include01 if false, points at fraction0 and fraction1 are omitted.\r\n   */\r\n  public appendFractionalStrokePoints(\r\n    curve: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number = 0,\r\n    fraction1: number = 1,\r\n    include01: boolean = true): void {\r\n    let i0 = 1;\r\n    let i1 = numStrokes - 1;\r\n    if (include01) {\r\n      i0 = 0;\r\n      i1 = numStrokes;\r\n    }\r\n    if (numStrokes >= 1) {\r\n      const df = (fraction1 - fraction0) / numStrokes;\r\n      for (let i = i0; i <= i1; i++)\r\n        this.appendFractionToPoint(curve, fraction0 + i * df);\r\n    }\r\n  }\r\n\r\n  /** Append points constructed as interpolation between two points.\r\n   * @param numStrokes number of strokes.\r\n   * @param point0 first point\r\n   * @param point1 last point\r\n   * @param include01 if false, OMIT both start and end points (i.e. only compute and add true interior points)\r\n   */\r\n  public appendInterpolatedStrokePoints(numStrokes: number, point0: Point3d, point1: Point3d, include01: boolean): void {\r\n    if (include01)\r\n      this.appendStrokePoint(point0, 0.0);\r\n    if (numStrokes > 1) {\r\n      const df = 1.0 / numStrokes;\r\n      for (let i = 1; i < numStrokes; i++) {\r\n        const f = i * df;\r\n        this.appendStrokePoint(point0.interpolate(f, point1), f);\r\n      }\r\n    }\r\n    if (include01)\r\n      this.appendStrokePoint(point1, 1.0);\r\n  }\r\n\r\n  /** Emit strokes to caller-supplied linestring */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const n = this._points.length;\r\n    const pointA = LineString3d._workPointA;\r\n    const pointB = LineString3d._workPointB;\r\n\r\n    if (n > 0) {\r\n      // This is a linestring.\r\n      // There is no need for chordTol and angleTol within a segment.\r\n      // Do NOT apply min strokes per primitive.\r\n      if (options && options.hasMaxEdgeLength) {\r\n        dest.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));\r\n        for (let i = 1; i < n; i++) {\r\n          this._points.getPoint3dAtUncheckedPointIndex(i - 1, pointA);\r\n          this._points.getPoint3dAtUncheckedPointIndex(i, pointB);\r\n          const numStroke = options.applyMaxEdgeLength(1, pointA.distance(pointB));\r\n          if (numStroke > 1)\r\n            dest.appendInterpolatedStrokePoints(numStroke, pointA, pointB, false);\r\n          dest.appendStrokePoint(pointB);\r\n        }\r\n      } else {\r\n        for (let i = 0; i < n; i++) {\r\n          dest.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(i));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Emit strokable parts of the curve to a caller-supplied handler.\r\n   * If the stroke options does not have a maxEdgeLength, one stroke is emitted for each segment of the linestring.\r\n   * If the stroke options has a maxEdgeLength, smaller segments are emitted as needed.\r\n   */\r\n  public emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void {\r\n    const n = this._points.length;\r\n    handler.startCurvePrimitive(this);\r\n    if (n > 1) {\r\n      const df = 1.0 / (n - 1);\r\n      // This is a linestring.\r\n      // There is no need for chordTol and angleTol within a segment.\r\n      // Do NOT apply min strokes per primitive.\r\n      if (options && options.hasMaxEdgeLength) {\r\n        for (let i = 1; i < n; i++) {\r\n          const numStroke = options.applyMaxEdgeLength(1, this._points.getPoint3dAtUncheckedPointIndex(i - 1).distance(this._points.getPoint3dAtUncheckedPointIndex(i)));\r\n          handler.announceSegmentInterval(this, this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i), numStroke, (i - 1) * df, i * df);\r\n        }\r\n      } else {\r\n        for (let i = 1; i < n; i++) {\r\n          handler.announceSegmentInterval(this, this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i), 1, (i - 1) * df, i * df);\r\n        }\r\n      }\r\n    }\r\n    handler.endCurvePrimitive(this);\r\n  }\r\n\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    const numPoints = this._points.length;\r\n    let numStroke = numPoints - 1;\r\n\r\n    if (options && options.hasMaxEdgeLength) {\r\n      numStroke = 0;\r\n      for (let i = 1; i < numPoints; i++) {\r\n        numStroke += options.applyMaxEdgeLength(1, this._points.distanceIndexIndex(i - 1, i)!);\r\n      }\r\n    }\r\n    return numStroke;\r\n  }\r\n  /**\r\n   * Compute individual segment stroke counts.  Attach in a StrokeCountMap.\r\n   * @param options StrokeOptions that determine count\r\n   * @param parentStrokeMap evolving parent map.\r\n   */\r\n  public computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap) {\r\n    const numPoints = this._points.length;\r\n    const applyOptions = options !== undefined && options.hasMaxEdgeLength;\r\n    const myData = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);\r\n    for (let i = 1; i < numPoints; i++) {\r\n      const segmentLength = this._points.distanceIndexIndex(i - 1, i)!;\r\n      const numStrokeOnSegment = applyOptions ? options!.applyMaxEdgeLength(1, segmentLength)! : 1;\r\n      myData.addToCountAndLength(numStrokeOnSegment, segmentLength);\r\n    }\r\n    CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleLineString3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleLineString3d(this);\r\n  }\r\n  // HARD TO TEST -- tests that get to announceClipInterval for arc, bspline do NOT get here with\r\n  // linestring because the controller has special case loops through segments?\r\n  /**\r\n   * Find intervals of this CurvePrimitive that are interior to a clipper\r\n   * @param clipper clip structure (e.g. clip planes)\r\n   * @param announce (optional) function to be called announcing fractional intervals\"  ` announce(fraction0, fraction1, curvePrimitive)`\r\n   * @returns true if any \"in\" segments are announced.\r\n   */\r\n  public announceClipIntervals(clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    const n = this._points.length;\r\n    if (n < 2) return false;\r\n    let globalFractionA = 0.0;\r\n    let globalFractionB = 1.0;\r\n    const capture = (localFraction0: number, localFraction1: number) => {\r\n      if (announce)\r\n        announce(\r\n          Geometry.interpolate(globalFractionA, localFraction0, globalFractionB),\r\n          Geometry.interpolate(globalFractionA, localFraction1, globalFractionB),\r\n          this);\r\n    };\r\n    const pointA = LineString3d._workPointA;\r\n    const pointB = LineString3d._workPointB;\r\n    this._points.getPoint3dAtUncheckedPointIndex(0, pointA);\r\n    let status = false;\r\n    for (let i = 1; i < n; i++ , pointA.setFrom(pointB), globalFractionA = globalFractionB) {\r\n      this._points.getPoint3dAtUncheckedPointIndex(i, pointB);\r\n      globalFractionB = i / (n - 1);\r\n      if (clipper.announceClippedSegmentIntervals(0.0, 1.0, pointA, pointB, capture))\r\n        status = true;\r\n    }\r\n    return status;\r\n  }\r\n  private static _indexPoint = Point3d.create();  // private point for indexAndFractionToPoint.\r\n  private addResolvedPoint(index: number, fraction: number, dest: GrowableXYZArray) {\r\n    const n = this._points.length;\r\n    if (n === 0) return;\r\n    if (n === 1) {\r\n      this._points.getPoint3dAtUncheckedPointIndex(0, LineString3d._indexPoint);\r\n      dest.push(LineString3d._indexPoint);\r\n      return;\r\n    }\r\n    if (index < 0)\r\n      index = 0;\r\n    if (index >= n) {\r\n      index = n - 1;\r\n      fraction += 1;\r\n    }\r\n    this._points.interpolate(index, fraction, index + 1, LineString3d._indexPoint);\r\n    dest.push(LineString3d._indexPoint);\r\n  }\r\n  /** Return (if possible) a LineString which is a portion of this curve.\r\n   * * This implementation does NOT extrapolate the linestring -- fractions are capped at 0 and 1.\r\n   * @param fractionA [in] start fraction\r\n   * @param fractionB [in] end fraction\r\n   */\r\n  public clonePartialCurve(fractionA: number, fractionB: number): CurvePrimitive | undefined {\r\n    if (fractionB < fractionA) {\r\n      const linestringA = this.clonePartialCurve(fractionB, fractionA);\r\n      if (linestringA)\r\n        linestringA.reverseInPlace();\r\n      return linestringA;\r\n    }\r\n    const n = this._points.length;\r\n    const numEdge = n - 1;\r\n    if (n < 2 || fractionA >= 1.0 || fractionB <= 0.0)\r\n      return undefined;\r\n    if (fractionA < 0)\r\n      fractionA = 0;\r\n    if (fractionB > 1)\r\n      fractionB = 1;\r\n    const gA = fractionA * numEdge;\r\n    const gB = fractionB * numEdge;\r\n    const indexA = Math.floor(gA);\r\n    const indexB = Math.floor(gB);\r\n    const localFractionA = gA - indexA;\r\n    const localFractionB = gB - indexB;\r\n    const result = LineString3d.create();\r\n    this.addResolvedPoint(indexA, localFractionA, result._points);\r\n    for (let index = indexA + 1; index <= indexB; index++) {\r\n      this._points.getPoint3dAtUncheckedPointIndex(index, LineString3d._workPointA);\r\n      result._points.push(LineString3d._workPointA);\r\n    }\r\n    if (!Geometry.isSmallRelative(localFractionB)) {\r\n      this.addResolvedPoint(indexB, localFractionB, result._points);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return (if possible) a specific segment of the linestring */\r\n  public getIndexedSegment(index: number): LineSegment3d | undefined {\r\n    if (index >= 0 && index + 1 < this._points.length)\r\n      return LineSegment3d.create(this._points.getPoint3dAtCheckedPointIndex(index)!, this._points.getPoint3dAtCheckedPointIndex(index + 1)!);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Returns true if first and last points are within metric tolerance.\r\n   */\r\n  public get isPhysicallyClosed(): boolean {\r\n    return this._points.length > 0 && Geometry.isSmallMetricDistance(this._points.distanceIndexIndex(0, this._points.length - 1)!);\r\n  }\r\n\r\n  /**\r\n   * evaluate strokes at fractions indicated in a StrokeCountMap.\r\n   * * The map must have an array of component counts corresponding to the segment of this linestring.\r\n   * * \"fractions\" in the output are mapped within a0,a1 of the map.componentData\r\n   * @param map = stroke count data.\r\n   * @param destLinestring = receiver linestring.\r\n   * @return number of strokes added.  0 if `map.componentData` does not match the linestring\r\n   */\r\n  public addMappedStrokesToLineString3D(map: StrokeCountMap, destLinestring: LineString3d): number {\r\n    const numPoint0 = destLinestring.numPoints();\r\n    const needFractions = destLinestring._fractions !== undefined;\r\n    const needDerivatives = destLinestring._derivatives !== undefined;\r\n    const points = this._points;\r\n    const pointA = LineString3d._workPointA;\r\n    const pointB = LineString3d._workPointB;\r\n    const pointC = LineString3d._workPointC;\r\n    const numParentPoint = points.length;\r\n    if (map.primitive && map.primitive === this && map.componentData && map.componentData.length + 1 === numParentPoint) {\r\n      points.getPoint3dAtUncheckedPointIndex(0, pointA);\r\n      for (let k = 0; k + 1 < numParentPoint; k++ , pointA.setFromPoint3d(pointB)) {\r\n        points.getPoint3dAtUncheckedPointIndex(k + 1, pointB);\r\n        const segmentMap = map.componentData![k];\r\n        const m = segmentMap.numStroke;\r\n        const vectorAB = pointA.vectorTo(pointB);\r\n        vectorAB.scale(m);\r\n        for (let i = 0; i <= m; i++) {\r\n          const fraction = i / m;\r\n          const outputFraction = segmentMap.fractionToA(fraction);\r\n          destLinestring.addPoint(pointA.interpolate(fraction, pointB, pointC));\r\n          if (needFractions)\r\n            destLinestring._fractions!.push((outputFraction));\r\n          if (needDerivatives)\r\n            destLinestring._derivatives!.push(vectorAB);\r\n\r\n        }\r\n      }\r\n    }\r\n    return destLinestring.numPoints() - numPoint0;\r\n  }\r\n  /** convert variant point data to a single level array of linestrings.\r\n   * * The result is always an array of LineString3d.\r\n   *   * Single linestring is NOT bubbled out as a special case.\r\n   *   * data with no point is an empty array.\r\n   *   * \"deep\" data is flattened to a single array of linestrings, losing structure.\r\n   */\r\n  public static createArrayOfLineString3dFromVariantData(data: MultiLineStringDataVariant): LineString3d[] {\r\n    const collector = new PointStreamGrowableXYZArrayCollector();\r\n    VariantPointDataStream.streamXYZ(data, collector);\r\n    const growableArrays = collector.claimArrayOfGrowableXYZArray();\r\n    const result = [];\r\n    if (growableArrays !== undefined) {\r\n      for (const points of growableArrays)\r\n        result.push(LineString3d.createCapture(points));\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * This method name is deprecated. Use `LineString3d.createArrayOfLineString3dFromVariantData`\r\n   * @deprecated use LineString3d.createArrayOfLineString3dFromVariantData\r\n   */\r\n  public static createArrayOfLineString3d(data: MultiLineStringDataVariant): LineString3d[] {\r\n    return this.createArrayOfLineString3dFromVariantData(data);\r\n\r\n  }\r\n}\r\n/** An AnnotatedLineString3d is a linestring with additional surface-related data attached to each point\r\n * * This is useful in facet construction.\r\n * @internal\r\n */\r\nexport class AnnotatedLineString3d {\r\n  /** parameter along curve being faceted.  */\r\n  public curveParam?: GrowableFloat64Array;\r\n  /** uv parameters, stored as uvw with the w possibly used for distinguishing among multiple \"faces\". */\r\n  public uvwParam?: GrowableXYZArray;\r\n  /** u direction tangent vectors from surface being faceted. */\r\n  public vectorU?: GrowableXYZArray;\r\n  /** v direction tangent vectors from surface being faceted. */\r\n  public vectorV?: GrowableXYZArray;\r\n}\r\n/**\r\n * context to be called to incrementally accumulate distance along line segments.\r\n */\r\nclass MoveByDistanceContext {\r\n  public distance0: number;   // accumulated distance through point0\r\n  public point0: Point3d;      // most recent point\r\n  public fraction0: number;   // most recent fraction position\r\n  public targetDistance: number;  // this is always positive.\r\n  /** CAPTURE point0, fraction0, targetDistance */\r\n  public constructor(point0: Point3d, fraction0: number, targetDistance: number) {\r\n    this.point0 = point0;\r\n    this.distance0 = 0.0;\r\n    this.targetDistance = Math.abs(targetDistance);\r\n    this.fraction0 = fraction0;\r\n  }\r\n  // Return CurveSearchStatus indicating whether the accumulated distance has reached the target.\r\n  public distanceStatus(): CurveSearchStatus {\r\n    return Geometry.isSameCoordinate(this.distance0, this.targetDistance) ?\r\n      CurveSearchStatus.success : CurveSearchStatus.stoppedAtBoundary;\r\n  }\r\n  /**\r\n   * Announce next point on the polyline.\r\n   * * if the additional segment does NOT reach the target:\r\n   *   * accumulate the segment length\r\n   *   * update point0 and fraction0\r\n   *   * return false\r\n   *  * if the additional segment DOES reach the target:\r\n   *    * update point0 and fraction0 to the (possibly interpolated) final point and fraction\r\n   *    * return true\r\n   * @param point1 new point\r\n   * @param fraction1 fraction at point1\r\n   * @return true if targetDistance reached.\r\n   */\r\n  public announcePoint(point1: Point3d, fraction1: number): boolean {\r\n    const a = this.point0.distance(point1);\r\n    const distance1 = this.distance0 + a;\r\n    if (distance1 < this.targetDistance && !Geometry.isSameCoordinate(distance1, this.targetDistance)) {\r\n      this.point0.setFromPoint3d(point1);\r\n      this.distance0 = distance1;\r\n      this.fraction0 = fraction1;\r\n      return false;\r\n    }\r\n    const b = this.targetDistance - this.distance0;\r\n    const intervalFraction = Geometry.safeDivideFraction(b, a, 0.0);\r\n    this.point0.interpolate(intervalFraction, point1, this.point0);\r\n    this.fraction0 = Geometry.interpolate(this.fraction0, intervalFraction, fraction1);\r\n    this.distance0 = this.targetDistance;\r\n    return true;\r\n  }\r\n  /**\r\n   * Update point0, fraction0, and distance0 based on extrapolation of a segment between indices of a point array.\r\n   * @returns true if extrapolation succeeded.  (False if indexed points are coincident)\r\n   * @param points\r\n   * @param index0\r\n   * @param index1\r\n   * @param fraction0\r\n   * @param fraction1\r\n   * @param result\r\n   * @param CurveLocationDetail\r\n   */\r\n  public announceExtrapolation(points: GrowableXYZArray,\r\n    index0: number, index1: number,\r\n    fraction0: number, fraction1: number): boolean {\r\n    const residual = this.targetDistance - this.distance0;\r\n    const d01 = points.distanceIndexIndex(index0, index1);\r\n    if (!d01)\r\n      return false;\r\n    const extensionFraction = Geometry.conditionalDivideFraction(residual, d01);\r\n    if (extensionFraction === undefined)\r\n      return false;\r\n    // (Remark: indices are swapped and extensionFraction negated to prevent incidental precision\r\n    // loss with the alternative call with (index0, 1 + extensionFraction, index1);\r\n    points.interpolate(index1, -extensionFraction, index0, this.point0);\r\n    this.distance0 = this.targetDistance;\r\n    this.fraction0 = Geometry.interpolate(fraction1, -extensionFraction, fraction0);\r\n    return true;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { RecursiveCurveProcessor } from \"./CurveProcessor\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { CurveChain } from \"./CurveCollection\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n\r\n/**\r\n * A `Loop` is a curve chain that is the boundary of a closed (planar) loop.\r\n * @public\r\n */\r\nexport class Loop extends CurveChain {\r\n   /** String name for schema properties */\r\n  public readonly curveCollectionType = \"loop\";\r\n\r\n  /** tag value that can be set to true for user code to mark inner and outer loops. */\r\n  public isInner: boolean = false;\r\n  /** test if `other` is a `Loop` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof Loop; }\r\n  /** Test if `other` is an instance of `Loop` */\r\n  public constructor() { super(); }\r\n  /**\r\n   * Create a loop from variable length list of CurvePrimitives\r\n   * @param curves array of individual curve primitives\r\n   */\r\n  public static create(...curves: CurvePrimitive[]): Loop {\r\n    const result = new Loop();\r\n    for (const curve of curves) {\r\n      result.children.push(curve);\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a loop from an array of curve primitives\r\n   * @param curves array of individual curve primitives\r\n   */\r\n  public static createArray(curves: CurvePrimitive[]): Loop {\r\n    const result = new Loop();\r\n    for (const curve of curves) {\r\n      result.children.push(curve);\r\n    }\r\n    return result;\r\n  }\r\n  /** Create a loop from an array of points */\r\n  public static createPolygon(points: GrowableXYZArray | Point3d[]): Loop {\r\n    const linestring = LineString3d.create(points);\r\n    linestring.addClosurePoint();\r\n    return Loop.create(linestring);\r\n  }\r\n  /** Create a loop with the stroked form of this loop. */\r\n  public cloneStroked(options?: StrokeOptions): AnyCurve {\r\n    const strokes = LineString3d.create();\r\n    for (const curve of this.children)\r\n      curve.emitStrokes(strokes, options);\r\n    return Loop.create(strokes);\r\n  }\r\n  /** Return the boundary type (2) of a corresponding  MicroStation CurveVector */\r\n  public dgnBoundaryType(): number { return 2; } // (2) all \"Loop\" become \"outer\"\r\n  /** invoke `processor.announceLoop(this, indexInParent)` */\r\n  public announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent: number = -1): void {\r\n    return processor.announceLoop(this, indexInParent);\r\n  }\r\n  /** Create a new `Loop` with no children */\r\n  public cloneEmptyPeer(): Loop { return new Loop(); }\r\n  /** Second step of double dispatch:  call `handler.handleLoop(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleLoop(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { RecursiveCurveProcessor } from \"./CurveProcessor\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { CurveCollection } from \"./CurveCollection\";\r\nimport { Loop } from \"./Loop\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\n/**\r\n * * A `ParityRegion` is a collection of `Loop` objects.\r\n * * The loops collectively define a planar region.\r\n * * A point is \"in\" the composite region if it is \"in\" an odd number of the loops.\r\n * @public\r\n */\r\nexport class ParityRegion extends CurveCollection {\r\n   /** String name for schema properties */\r\n  public readonly curveCollectionType = \"parityRegion\";\r\n\r\n  /** Test if `other` is an instance of `ParityRegion` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof ParityRegion; }\r\n  /** Array of loops in this parity region. */\r\n  protected _children: Loop[];\r\n  /** Return the array of loops in this parity region. */\r\n  public get children(): Loop[] { return this._children; }\r\n  /** Construct parity region with empty loop array */\r\n  public constructor() { super(); this._children = []; }\r\n  /**\r\n   * Add loops (recursively) to this region's children\r\n   */\r\n  public addLoops(data?: Loop | Loop[] | Loop[][]) {\r\n    if (data === undefined) {\r\n    } else if (data instanceof Loop)\r\n      this.children.push(data);\r\n    else if (Array.isArray(data)) {\r\n      for (const child of data) {\r\n        if (child instanceof Loop)\r\n          this.children.push(child);\r\n        else if (Array.isArray(child))\r\n          this.addLoops(child);\r\n      }\r\n    }\r\n  }\r\n  /** Return a single loop or parity region with given loops.\r\n   * * The returned structure CAPTURES the loops.\r\n   * * The loops are NOT reorganized by hole analysis.\r\n   */\r\n  public static createLoops(data?: Loop | Loop[] | Loop[][]): Loop | ParityRegion {\r\n    if (data instanceof Loop)\r\n      return data;\r\n    const result = new ParityRegion();\r\n    result.addLoops(data);\r\n    return result;\r\n  }\r\n\r\n  /** Create a parity region with given loops */\r\n  public static create(...data: Loop[]): ParityRegion {\r\n    const result = new ParityRegion();\r\n    for (const child of data) {\r\n      result.children.push(child);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return the boundary type (4) of a corresponding  MicroStation CurveVector */\r\n  public dgnBoundaryType(): number { return 4; }\r\n  /** invoke `processor.announceParityRegion(this, indexInParent)` */\r\n  public announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent: number = -1): void {\r\n    return processor.announceParityRegion(this, indexInParent);\r\n  }\r\n  /** Return a deep copy. */\r\n  public clone(): ParityRegion {\r\n    const clone = new ParityRegion();\r\n    let child;\r\n    for (child of this.children) {\r\n      const childClone = child.clone();\r\n      if (childClone instanceof Loop)\r\n        clone.children.push(childClone);\r\n    }\r\n    return clone;\r\n  }\r\n  /** Stroke these curves into a new ParityRegion. */\r\n  public cloneStroked(options?: StrokeOptions): ParityRegion {\r\n    const clone = new ParityRegion();\r\n    let child;\r\n    for (child of this.children) {\r\n      const childStrokes = child.cloneStroked(options) as Loop;\r\n      if (childStrokes)\r\n        clone.children.push(childStrokes);\r\n    }\r\n    return clone;\r\n  }\r\n  /** Create a new empty parity region. */\r\n  public cloneEmptyPeer(): ParityRegion { return new ParityRegion(); }\r\n  /** Add `child` to this parity region.\r\n   * * any child type other than `Loop` is ignored.\r\n   */\r\n  public tryAddChild(child: AnyCurve | undefined): boolean {\r\n    if (child && child instanceof Loop) {\r\n      this._children.push(child);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** Get child `i` by index. */\r\n  public getChild(i: number): Loop | undefined {\r\n    if (i < this._children.length)\r\n      return this._children[i];\r\n    return undefined;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleRegion(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleParityRegion(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { RecursiveCurveProcessor } from \"./CurveProcessor\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\nimport { CurveChain } from \"./CurveCollection\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\n\r\n/**\r\n * * A `Path` object is a collection of curves that join head-to-tail to form a path.\r\n * * A `Path` object does not bound a planar region.  Use `Loop` to indicate region bounding.\r\n * @public\r\n */\r\nexport class Path extends CurveChain {\r\n   /** String name for schema properties */\r\n  public readonly curveCollectionType = \"path\";\r\n\r\n  /** Test if `other` is an instance of `Path` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof Path; }\r\n  /** invoke `processor.announcePath(this, indexInParent)` */\r\n  public announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent: number = -1): void {\r\n    return processor.announcePath(this, indexInParent);\r\n  }\r\n  /** Construct an empty path. */\r\n  public constructor() { super(); }\r\n  /**\r\n   * Create a path from a variable length list of curve primitives\r\n   * * CurvePrimitive params are captured !!!\r\n   * @param curves variable length list of individual curve primitives or point arrays.\r\n   */\r\n  public static create(...curves: Array<CurvePrimitive | Point3d[]>): Path {\r\n    const result = new Path();\r\n    for (const curve of curves) {\r\n      if (curve instanceof CurvePrimitive)\r\n        result.children.push(curve);\r\n      else if (Array.isArray(curve) && curve.length > 0 && curve[0] instanceof Point3d) {\r\n        result.children.push(LineString3d.create(curve));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a path from a an array of curve primitives\r\n   * @param curves array of individual curve primitives\r\n   */\r\n  public static createArray(curves: CurvePrimitive[]): Path {\r\n    const result = new Path();\r\n    for (const curve of curves) {\r\n      result.children.push(curve);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return a deep copy, with leaf-level curve primitives stroked. */\r\n  public cloneStroked(options?: StrokeOptions): AnyCurve {\r\n    const strokes = LineString3d.create();\r\n    for (const curve of this.children)\r\n      curve.emitStrokes(strokes, options);\r\n    return Path.create(strokes);\r\n  }\r\n  /** Return the boundary type (1) of a corresponding  MicroStation CurveVector */\r\n  public dgnBoundaryType(): number { return 1; }\r\n  /** Clone as a new `Path` with no primitives */\r\n  public cloneEmptyPeer(): Path { return new Path(); }\r\n  /** Second step of double dispatch:  call `handler.handlePath(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handlePath(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry, BeJSONFunctions } from \"../Geometry\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\n/* tslint:disable:variable-name no-empty*/\r\n\r\n/**\r\n * A PointString3d is an array of points.\r\n * * PointString3D is first class (persistible, displayable) geometry derived from the GeometryQuery base class.\r\n * * The various points in the PointString3d are NOT connected by line segments for display or other calculations.\r\n * @public\r\n */\r\nexport class PointString3d extends GeometryQuery implements BeJSONFunctions {\r\n  /** String name for schema properties */\r\n  public readonly geometryCategory = \"pointCollection\";\r\n\r\n  /** Test if `other` is a PointString3d */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof PointString3d; }\r\n  private _points: Point3d[];\r\n  /** return a clone of the points array. */\r\n  public get points(): Point3d[] { return this._points; }\r\n  private constructor() {\r\n    super();\r\n    this._points = [];\r\n  }\r\n  /** Clone and apply a transform. */\r\n  public cloneTransformed(transform: Transform): PointString3d {  // we know tryTransformInPlace succeeds.\r\n    const c = this.clone();\r\n    c.tryTransformInPlace(transform);\r\n    return c;\r\n  }\r\n  private static flattenArray(arr: any): any {\r\n    return arr.reduce((flat: any, toFlatten: any) => {\r\n      return flat.concat(Array.isArray(toFlatten) ? PointString3d.flattenArray(toFlatten) : toFlatten);\r\n    }, []);\r\n  }\r\n  /** Create a PointString3d from points. */\r\n  public static create(...points: any[]): PointString3d {\r\n    const result = new PointString3d();\r\n    result.addPoints(points);\r\n    return result;\r\n  }\r\n\r\n  /** Add multiple points to the PointString3d */\r\n  public addPoints(...points: any[]) {\r\n    const toAdd: any[] = PointString3d.flattenArray(points);\r\n    for (const p of toAdd) {\r\n      if (p instanceof Point3d)\r\n        this._points.push(p);\r\n    }\r\n  }\r\n  /** Add a single point to the PointString3d */\r\n  public addPoint(point: Point3d) {\r\n    this._points.push(point);\r\n  }\r\n  /** Remove the last point added to the PointString3d */\r\n  public popPoint() {\r\n    this._points.pop();\r\n  }\r\n\r\n  /** Replace this PointString3d's point array by a clone of the array in `other` */\r\n  public setFrom(other: PointString3d) {\r\n    this._points = Point3dArray.clonePoint3dArray(other._points);\r\n  }\r\n  /** Create from an array of Point3d */\r\n  public static createPoints(points: Point3d[]): PointString3d {\r\n    const ps = new PointString3d();\r\n    ps._points = Point3dArray.clonePoint3dArray(points);\r\n    return ps;\r\n  }\r\n  /** Create a PointString3d from xyz coordinates packed in a Float64Array */\r\n  public static createFloat64Array(xyzData: Float64Array): PointString3d {\r\n    const ps = new PointString3d();\r\n    for (let i = 0; i + 3 <= xyzData.length; i += 3)\r\n      ps._points.push(Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));\r\n    return ps;\r\n  }\r\n  /** Return a deep clone. */\r\n  public clone(): PointString3d {\r\n    const retVal = new PointString3d();\r\n    retVal.setFrom(this);\r\n    return retVal;\r\n  }\r\n  /** Replace this instance's points by those from a json array, e.g. `[[1,2,3], [4,2,2]]` */\r\n  public setFromJSON(json?: any) {\r\n    this._points.length = 0;\r\n    if (Array.isArray(json)) {\r\n      let xyz;\r\n      for (xyz of json)\r\n        this._points.push(Point3d.fromJSON(xyz));\r\n    }\r\n  }\r\n  /**\r\n   * Convert an PointString3d to a JSON object.\r\n   * @return {*} [[x,y,z],...[x,y,z]]\r\n   */\r\n  public toJSON(): any {\r\n    const value = [];\r\n    for (const p of this._points) value.push(p.toJSON());\r\n    return value;\r\n  }\r\n  /** Create a PointString3d from a json array, e.g. `[[1,2,3], [4,2,2]]` */\r\n  public static fromJSON(json?: any): PointString3d {\r\n    const ps = new PointString3d(); ps.setFromJSON(json); return ps;\r\n  }\r\n  /** Access a single point by index. */\r\n  public pointAt(i: number, result?: Point3d): Point3d | undefined {\r\n    if (i >= 0 && i < this._points.length) {\r\n      if (result) { result.setFrom(this._points[i]); return result; }\r\n      return this._points[i].clone();\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return the number of points. */\r\n  public numPoints(): number { return this._points.length; }\r\n\r\n  /** Reverse the point order */\r\n  public reverseInPlace(): void {\r\n    if (this._points.length >= 2) {\r\n      let i0 = 0;\r\n      let i1 = this._points.length - 1;\r\n      while (i0 < i1) {\r\n        const a = this._points[i0];\r\n        this._points[i1] = this._points[i0];\r\n        this._points[i0] = a;\r\n        i0++;\r\n        i1--;\r\n      }\r\n    }\r\n  }\r\n  /** Return the number of points. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    transform.multiplyPoint3dArrayInPlace(this._points);\r\n    return true;\r\n  }\r\n  /** Return the index and coordinates of the closest point to spacepoint. */\r\n  public closestPoint(spacePoint: Point3d): { index: number, xyz: Point3d } {\r\n    const result = { index: -1, xyz: Point3d.create() };\r\n    const index = Point3dArray.closestPointIndex(this._points, spacePoint);\r\n    if (index >= 0) {\r\n      result.index = index;\r\n      result.xyz.setFrom(this._points[index]);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return true if all points are in the given plane. */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Point3dArray.isCloseToPlane(this._points, plane, Geometry.smallMetricDistance);\r\n  }\r\n  /** Extend a range to include the points in this PointString3d. */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    rangeToExtend.extendArray(this._points, transform);\r\n  }\r\n  /** Return true if corresponding points are almost equal. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (!(other instanceof PointString3d))\r\n      return false;\r\n    return Point3dArray.isAlmostEqual(this._points, other._points);\r\n  }\r\n  /** Reduce to empty set of points. */\r\n  public clear() { this._points.length = 0; }\r\n  /** Second step of double dispatch:  call `handler.handlePointString(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handlePointString3d(this);\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/* tslint:disable: no-console */\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { CurveCollection } from \"./CurveCollection\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { CurveCurveApproachType } from \"./CurveLocationDetail\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Path } from \"./Path\";\r\nimport { Loop } from \"./Loop\";\r\nimport { Arc3d } from \"./Arc3d\";\r\nimport { CurveCurve } from \"./CurveCurve\";\r\nimport { CurveLocationDetailArrayPair } from \"./CurveCurveIntersectXY\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { RegionOps } from \"./RegionOps\";\r\n\r\n/**\r\n * Classification of contortions at a joint.\r\n * @internal\r\n */\r\nenum JointMode {\r\n  Unknown = 0,\r\n  Cap = 1,\r\n  Extend = 2,\r\n  Trim = -1,\r\n  JustGeometry = 3,\r\n  Gap = 4,\r\n}\r\n\r\n/**\r\n * * control parameters for joint construction.\r\n * * Decision order is:\r\n *   * if turn angle is greater than minArcDegrees, make an arc.\r\n *   * if turn angle is less than or equal maxChamferTurnDegrees, extend curves along tangent to single intersection point.\r\n *   * if turn angle is greater than maxChamferTurnDegrees,  construct multiple lines that are tangent to the turn circle \"from the outside\",\r\n *           with each equal turn less than maxChamferTurnDegrees.\r\n *   * otherwise make single edge.\r\n * @public\r\n */\r\nexport class JointOptions {\r\n  /** smallest arc to construct.\r\n   * * If this control angle is large, arcs are never created.\r\n   */\r\n  public minArcDegrees = 180.0;\r\n  public maxChamferTurnDegrees = 90;\r\n  public leftOffsetDistance: number = 0;\r\n  /** Construct JointOptions.\r\n   * * leftOffsetDistance is required\r\n   * * minArcDegrees and maxChamferDegrees are optional.\r\n   */\r\n  constructor(leftOffsetDistance: number, minArcDegrees = 180, maxChamferDegrees = 90) {\r\n    this.leftOffsetDistance = leftOffsetDistance;\r\n    this.minArcDegrees = minArcDegrees;\r\n    this.maxChamferTurnDegrees = maxChamferDegrees;\r\n  }\r\n  /**\r\n   * Parse a number of JointOptions up to JointOptions:\r\n   * * If leftOffsetDistanceOptions is a number, create a JointOptions with default arc and chamfer values.\r\n   * * If leftOffsetDistanceOrOptions is a JointOptions, return it unchanged.\r\n   * @param leftOffsetDistanceOrOptions\r\n   */\r\n  public static create(leftOffsetDistanceOrOptions: number | JointOptions): JointOptions {\r\n    if (leftOffsetDistanceOrOptions instanceof JointOptions)\r\n      return leftOffsetDistanceOrOptions;\r\n    // if (Number.isFinite(leftOffsetDistanceOrOptions))\r\n    return new JointOptions(leftOffsetDistanceOrOptions);\r\n  }\r\n  /** return true if the options indicate this amount of turn should be handled with an arc. */\r\n  public needArc(theta: Angle): boolean {\r\n    return Math.abs(theta.degrees) >= this.minArcDegrees;\r\n  }\r\n  /** Test if turn by theta should be output as single point. */\r\n  public numChamferPoints(theta: Angle): number {\r\n    const degrees = Math.abs(theta.degrees);\r\n    const stepDegrees = Geometry.clamp(this.maxChamferTurnDegrees, 10, 120);\r\n    if (degrees <= stepDegrees)\r\n      return 1;\r\n    return Math.ceil(degrees / stepDegrees);\r\n  }\r\n}\r\n/**\r\n * Description of geometry around a joint.\r\n * @internal\r\n */\r\nclass Joint {\r\n  /** Enumeration of how the joint is constructed */\r\n  public flexure: JointMode;\r\n\r\n  /** curve before the joint */\r\n  public curve0?: CurvePrimitive;\r\n  /** fractional position on curve0 (may be a trim or extension) */\r\n  public fraction0?: number;\r\n  /** curve after the joint (may be a trim or extension) */\r\n  public curve1?: CurvePrimitive;\r\n  /** fractional position on curve1 */\r\n  public fraction1?: number;\r\n  /** curve to be added within the joint */\r\n  public jointCurve?: CurvePrimitive;\r\n  /** common point on the original curves */\r\n  public swingPoint?: Point3d;\r\n  /** pointer to next joint */\r\n  public nextJoint?: Joint;\r\n  /** pointer to previous joint */\r\n  public previousJoint?: Joint;\r\n  // capture references to all data . . .\r\n  public constructor(curve0: CurvePrimitive | undefined, curve1: CurvePrimitive | undefined, swingPoint: Point3d | undefined) {\r\n    this.curve0 = curve0;\r\n    this.curve1 = curve1;\r\n    this.swingPoint = swingPoint;\r\n    this.flexure = JointMode.Unknown;\r\n  }\r\n  /** try to construct an arc transition from ray0 to ray1 with given center. */\r\n  public static constructArc(ray0: Ray3d, center: Point3d | undefined, ray1: Ray3d): Arc3d | undefined {\r\n    if (center !== undefined && Geometry.isSameCoordinate(ray0.origin.distance(center), ray1.origin.distance(center))) {\r\n      const angle = ray0.direction.angleToXY(ray1.direction);\r\n      const vector0 = Vector3d.createStartEnd(center, ray0.origin);\r\n      const vector90 = vector0.rotate90CCWXY();\r\n      return Arc3d.create(center, vector0, vector90, AngleSweep.createStartEndRadians(0.0, angle.radians));\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Extract a json object of {curve0:data, fraction0:data, curve1:data, fraction1:data} */\r\n  public shallowExtract(): any {\r\n    return { curve0: this.curve0, curve1: this.curve1, fraction0: this.fraction0, fraction1: this.fraction1 };\r\n  }\r\n  /** Establish the nextJoint and previousJoint links from joint0 to joint1. */\r\n  public static link(joint0: Joint, joint1: Joint | undefined) {\r\n    joint0.nextJoint = joint1;\r\n    if (joint1)\r\n      joint1.previousJoint = joint0;\r\n    if (joint0.curve1 && joint1 && !joint1.curve0)\r\n      joint1.curve0 = joint0.curve1;\r\n    else if (!joint0.curve1 && joint1 && joint1.curve0)\r\n      joint0.curve1 = joint1.curve0;\r\n  }\r\n  /**\r\n   * * If nextJoint and nextJoint.fraction0 are defined, return them.\r\n   * * Otherwise return defaultValue\r\n   */\r\n  public nextJointFraction0(defaultValue: number): number {\r\n    if (this.nextJoint && this.nextJoint.fraction0 !== undefined)\r\n      return this.nextJoint.fraction0;\r\n    return defaultValue;\r\n  }\r\n\r\n  private static addStrokes(destination: LineString3d, curve?: CurvePrimitive) {\r\n    if (curve) {\r\n      curve.emitStrokes(destination);\r\n    }\r\n  }\r\n\r\n  private static addPoint(destination: LineString3d, point: Point3d) {\r\n    if (destination.packedPoints.length > 0) {\r\n      const pointA = destination.endPoint();\r\n      if (!pointA.isAlmostEqual(point))\r\n        destination.packedPoints.push(point);\r\n    }\r\n  }\r\n\r\n  public static collectStrokesFromChain(start: Joint, destination: LineString3d, maxTest: number = 100) {\r\n    let numOut = -2 * maxTest;    // allow extra things to happen\r\n    Joint.visitJointsOnChain(start, (joint: Joint) => {\r\n      this.addStrokes(destination, joint.jointCurve);\r\n\r\n      if (joint.curve1 && joint.fraction1 !== undefined) {\r\n        const fA = joint.fraction1;\r\n        const fB = joint.nextJointFraction0(1.0);\r\n        let curve1;\r\n        if (fA === 0.0 && fB === 1.0)\r\n          curve1 = joint.curve1.clone() as CurvePrimitive;\r\n        else if (fA < fB)\r\n          curve1 = joint.curve1.clonePartialCurve(fA, fB);\r\n        if (curve1) {\r\n          if (!joint.jointCurve) {\r\n            this.addPoint(destination, curve1.startPoint());\r\n          }\r\n        }\r\n        this.addStrokes(destination, curve1);\r\n      }\r\n      return numOut++ < maxTest;\r\n    }, maxTest);\r\n  }\r\n\r\n  private static collectPrimitive(destination: CurvePrimitive[], primitive?: CurvePrimitive) {\r\n    if (primitive)\r\n      destination.push(primitive);\r\n  }\r\n  public static collectCurvesFromChain(start: Joint, destination: CurvePrimitive[], maxTest: number = 100) {\r\n    let numOut = -2 * maxTest;    // allow extra things to happen\r\n    Joint.visitJointsOnChain(start, (joint: Joint) => {\r\n      this.collectPrimitive(destination, joint.jointCurve);\r\n\r\n      if (joint.curve1 && joint.fraction1 !== undefined) {\r\n        const fA = joint.fraction1;\r\n        const fB = joint.nextJointFraction0(1.0);\r\n        let curve1;\r\n        if (fA === 0.0 && fB === 1.0)\r\n          curve1 = joint.curve1.clone() as CurvePrimitive;\r\n        else if (fA < fB)\r\n          curve1 = joint.curve1.clonePartialCurve(fA, fB);\r\n        this.collectPrimitive(destination, curve1);\r\n      }\r\n      return numOut++ < maxTest;\r\n    }, maxTest);\r\n  }\r\n\r\n  /** Execute `joint.annotateJointMode()` at all joints on the chain. */\r\n  public static annotateChain(start: Joint, options: JointOptions, maxTest: number = 100) {\r\n    Joint.visitJointsOnChain(start, (joint: Joint) => { joint.annotateJointMode(options); return true; }, maxTest);\r\n  }\r\n\r\n  /**\r\n   * Visit joints on a chain.\r\n   * * terminate on `false` return from `callback`\r\n   * @param start first (and, for cyclic chain, final) Joint\r\n   * @param callback function to call with each Joint as a single parameter.\r\n   */\r\n  public static visitJointsOnChain(start: Joint, callback: (joint: Joint) => boolean, maxTest: number = 100): boolean {\r\n    let joint: Joint | undefined = start;\r\n    if (joint) {\r\n      let numTest = 0;\r\n      while (joint !== undefined) {\r\n        if (numTest++ >= maxTest + 5)\r\n          return true;\r\n        if (!callback(joint)) return false;\r\n        joint = joint.nextJoint;\r\n        if (joint === start)\r\n          break;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  private annotateExtension(options: JointOptions) {\r\n    if (this.curve0 && this.curve1) {\r\n      const ray0 = this.curve0.fractionToPointAndDerivative(1.0); // And we know that is full length ray !\r\n      const ray1 = this.curve1.fractionToPointAndDerivative(0.0); // ditto\r\n      const intersection = Ray3d.closestApproachRay3dRay3d(ray0, ray1);\r\n      if (intersection.approachType === CurveCurveApproachType.Intersection) {\r\n        this.fraction0 = 1.0;\r\n        this.fraction1 = 0.0;\r\n        if (intersection.detailA.fraction >= 0.0 && intersection.detailB.fraction <= 0.0) {\r\n          this.flexure = JointMode.Extend;\r\n          const theta = ray0.getDirectionRef().angleToXY(ray1.getDirectionRef());\r\n          if (options.needArc(theta)) {\r\n            const arc = Joint.constructArc(ray0, (this.curve0 as any).baseCurveEnd, ray1);\r\n            if (arc) {\r\n              this.fraction0 = 1.0;\r\n              this.fraction1 = 0.0;\r\n              this.jointCurve = arc;\r\n              return;\r\n            }\r\n          }\r\n          const numChamferPoints = options.numChamferPoints(theta);\r\n          if (numChamferPoints <= 1) {\r\n            this.jointCurve = LineString3d.create(ray0.origin, intersection.detailA.point, ray1.origin);\r\n            return;\r\n          }\r\n\r\n          if (numChamferPoints > 1) {\r\n            // A nontrivial linestring ...\r\n            const radians0 = theta.radians;\r\n            const numHalfStep = 2.0 * numChamferPoints;\r\n            const halfStepRadians = radians0 / numHalfStep;\r\n            const arc = Joint.constructArc(ray0, (this.curve0 as any).baseCurveEnd, ray1);\r\n            if (arc !== undefined) {\r\n              const radialFraction = 1 / Math.cos(halfStepRadians);\r\n              const jointCurve = LineString3d.create();\r\n              this.jointCurve = jointCurve;\r\n              jointCurve.addPoint(ray0.origin);   // possibly extend segment or line string\r\n\r\n              for (let i = 0; i < numChamferPoints; i++) {\r\n                const arcFraction = (1 + 2 * i) / numHalfStep;\r\n                jointCurve.addPoint(arc.fractionAndRadialFractionToPoint(arcFraction, radialFraction));\r\n              }\r\n              jointCurve.addPoint(ray1.origin); // possibly extend segment or line string.\r\n              return;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      // desperation appears ...\r\n      this.flexure = JointMode.Gap;\r\n      this.jointCurve = LineSegment3d.create(this.curve0.fractionToPoint(1.0), this.curve1.fractionToPoint(0.0));\r\n      this.fraction0 = 1.0;\r\n      this.fraction1 = 0.0;\r\n    }\r\n  }\r\n  // Select the index at which summed fraction difference is smallest.\r\n  private selectIntersectionIndexByFraction(fractionA: number, fractionB: number, intersections: CurveLocationDetailArrayPair): number {\r\n    let index = -1;\r\n    let aMin = Number.MAX_VALUE;\r\n    for (let i = 0; i < intersections.dataA.length; i++) {\r\n      const a = Math.abs(intersections.dataA[i].fraction - fractionA) + Math.abs(intersections.dataB[i].fraction - fractionB);\r\n      if (a < aMin) {\r\n        aMin = a;\r\n        index = i;\r\n      }\r\n    }\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * Examine the adjacent geometry\r\n   * * set JointMode:  one of Cap Extend, or Trim\r\n   * * set fraction0 and fraction1 of intersection of curve0 and curve1\r\n   * * this REFERENCES curve0, curve1, fraction0, fraction1\r\n   * * this does not reference nextJoint and previousJoint\r\n   */\r\n  public annotateJointMode(options: JointOptions) {\r\n    if (this.curve0 && !this.curve1) {\r\n      this.flexure = JointMode.Cap;\r\n      this.fraction0 = 1.0;\r\n    } else if (this.curve1 && !this.curve0) {\r\n      this.flexure = JointMode.Cap;\r\n      this.fraction1 = 0.0;\r\n    } else if (this.curve0 && this.curve1) {\r\n      const ray0 = this.curve0.fractionToPointAndDerivative(0.0); // And we know that is full length ray !\r\n      const ray1 = this.curve1.fractionToPointAndDerivative(0.0); // ditto\r\n      if (this.curve0 instanceof LineSegment3d && this.curve1 instanceof LineSegment3d) {\r\n        // check for direct intersection -- occurs on offset of colinear base segments.\r\n        if (this.curve0.endPoint().isAlmostEqual(this.curve1.startPoint())) {\r\n          this.fraction0 = 1.0;\r\n          this.fraction1 = 0.0;\r\n          this.flexure = JointMode.Trim;\r\n        } else {\r\n          const intersection = Ray3d.closestApproachRay3dRay3d(ray0, ray1);\r\n          if (intersection.approachType === CurveCurveApproachType.Intersection) {\r\n            this.fraction0 = intersection.detailA.fraction;\r\n            this.fraction1 = intersection.detailB.fraction;\r\n            if (this.fraction0 >= 1.0 && this.fraction1 <= 0.0) {\r\n              this.annotateExtension(options);\r\n            } else if (this.fraction0 < 1.0 && this.fraction1 > 0.0) {\r\n              this.flexure = JointMode.Trim;\r\n            } else if (this.fraction0 > 1.0 && this.fraction1 > 1.0) {\r\n              this.flexure = JointMode.Gap;\r\n              this.jointCurve = LineSegment3d.create(this.curve0.fractionToPoint(1.0), this.curve1.fractionToPoint(0.0));\r\n              this.fraction0 = 1.0;\r\n              this.fraction1 = 0.0;\r\n            }\r\n          }\r\n        }\r\n      } else {\r\n        // generic pair of curves ...\r\n        const intersections = CurveCurve.intersectionXY(this.curve0, false, this.curve1, false);\r\n        const intersectionIndex = this.selectIntersectionIndexByFraction(1.0, 0.0, intersections);\r\n        if (intersectionIndex >= 0) {\r\n          this.flexure = JointMode.Trim;\r\n          this.fraction0 = intersections.dataA[intersectionIndex].fraction;\r\n          this.fraction1 = intersections.dataB[intersectionIndex].fraction;\r\n        } else {\r\n          this.annotateExtension(options);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * * Examine the primitive trim fractions between each pair of joints.\r\n   * * If trim fractions indicate the primitive must disappear, replace the joint pair by a new joint pointing at surrounding primitives\r\n   * @param start\r\n   */\r\n  public static removeDegeneratePrimitives(start: Joint, options: JointOptions, maxTest: number): { newStart: Joint; numJointRemoved: number } {\r\n    /*\r\n    if (Checker.noisy.PolygonOffset)\r\n      console.log(\"\\nENTER removeDegenerates\");\r\n    */\r\n    let jointA: Joint | undefined = start;\r\n    let numRemoved = 0;\r\n    const maxRemove = 1;\r\n    let numTest = 0;\r\n    if (jointA) {\r\n      while (jointA !== undefined && numTest++ < maxTest) {\r\n        const jointB = jointA.nextJoint;\r\n        if (jointA\r\n          && jointB\r\n          && jointA.previousJoint\r\n          && jointB.nextJoint\r\n          && jointA.fraction1 !== undefined\r\n          && jointB.fraction0 !== undefined) {\r\n          const f0 = jointA.fraction1;\r\n          const f1 = jointB.fraction0;\r\n          const g0 = jointB.fraction1;\r\n          const g1 = jointB.nextJoint.fraction0;\r\n          // f0 and f1 are fractions on the single primitive between these joints.\r\n          /*\r\n            if (Checker.noisy.PolygonOffset) {\r\n              console.log(\"joint candidate\");\r\n              console.log(prettyPrint(jointA.shallowExtract()));\r\n              console.log(prettyPrint(jointB.shallowExtract()));\r\n              console.log(\"FRACTIONS \", { fA1: f0, fB0: f1 });\r\n            }\r\n          */\r\n          const eliminateF = f0 >= f1 || f0 > 1.0;\r\n          const eliminateG = (g0 !== undefined && g0 > 1.0)\r\n            || (g0 !== undefined && g1 !== undefined && g0 >= g1);\r\n          if (eliminateF && eliminateG) {\r\n            const jointC = jointB.nextJoint;\r\n            const newJoint: Joint = new Joint(jointA.curve0, jointC.curve1, undefined);\r\n            Joint.link(jointA.previousJoint, newJoint);\r\n            Joint.link(newJoint, jointC.nextJoint);\r\n            newJoint.annotateJointMode(options);\r\n            newJoint.previousJoint!.annotateJointMode(options);\r\n            if (newJoint.nextJoint)\r\n              newJoint.nextJoint.annotateJointMode(options);\r\n            /*\r\n            if (Checker.noisy.PolygonOffset) {\r\n              console.log(\" NEW DOUBLE CUT\");\r\n              console.log(prettyPrint(newJoint.shallowExtract()));\r\n            }\r\n            */\r\n          } else if (eliminateF) {\r\n            const newJoint: Joint = new Joint(jointA.curve0, jointB.curve1, undefined);\r\n            Joint.link(jointA.previousJoint, newJoint);\r\n            Joint.link(newJoint, jointB.nextJoint);\r\n            newJoint.annotateJointMode(options);\r\n            newJoint.previousJoint!.annotateJointMode(options);\r\n            newJoint.nextJoint!.annotateJointMode(options);\r\n            /*\r\n            if (Checker.noisy.PolygonOffset) {\r\n              console.log(\" NEW JOINT\");\r\n              console.log(prettyPrint(newJoint.shallowExtract()));\r\n            }\r\n          */\r\n            numRemoved++;\r\n            if (jointA === start)\r\n              start = newJoint;\r\n            jointA = newJoint;\r\n            if (numRemoved >= maxRemove) {\r\n              /*\r\n              if (Checker.noisy.PolygonOffset)\r\n                console.log(\" EXIT removeDegenerates at maxRemove\\n\");\r\n              */\r\n              return { newStart: start, numJointRemoved: numRemoved };\r\n            }\r\n          }\r\n        }\r\n        jointA = jointA.nextJoint;\r\n        if (jointA === start)\r\n          break;\r\n      }\r\n    }\r\n    return { newStart: start, numJointRemoved: numRemoved };\r\n  }\r\n}\r\n/**\r\n * Context for building a wire offset.\r\n * @internal\r\n */\r\nexport class PolygonWireOffsetContext {\r\n  /** construct a context. */\r\n  public constructor() {\r\n  }\r\n  private static _unitAlong = Vector3d.create();\r\n  private static _unitPerp = Vector3d.create();\r\n  private static _offsetA = Point3d.create();\r\n  private static _offsetB = Point3d.create();\r\n\r\n  // Construct a single offset from base points\r\n  private static createOffsetSegment(basePointA: Point3d, basePointB: Point3d, distance: number): CurvePrimitive | undefined {\r\n    Vector3d.createStartEnd(basePointA, basePointB, this._unitAlong);\r\n    if (this._unitAlong.normalizeInPlace()) {\r\n      this._unitAlong.rotate90CCWXY(this._unitPerp);\r\n      const segment = LineSegment3d.create(\r\n        basePointA.plusScaled(this._unitPerp, distance, this._offsetA),\r\n        basePointB.plusScaled(this._unitPerp, distance, this._offsetB));\r\n      CurveChainWireOffsetContext.applyBasePoints(segment, basePointA.clone(), basePointB.clone());\r\n      return segment;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Construct curves that are offset from a polygon.\r\n   * * The construction will remove \"some\" local effects of features smaller than the offset distance, but will not detect self intersection with far-away edges.\r\n   * @param points\r\n   * @param wrap\r\n   * @param offsetDistance\r\n   */\r\n  public constructPolygonWireXYOffset(points: Point3d[], wrap: boolean, leftOffsetDistanceOrOptions: number | JointOptions): CurveCollection | undefined {\r\n    const options = JointOptions.create(leftOffsetDistanceOrOptions);\r\n    const numPoints = points.length;\r\n    let fragment0 = PolygonWireOffsetContext.createOffsetSegment(points[0], points[1], options.leftOffsetDistance);\r\n    let joint0 = new Joint(undefined, fragment0, points[0]);\r\n    let newJoint;\r\n    let previousJoint = joint0;\r\n    for (let i = 1; i + 1 < numPoints; i++) {\r\n      const fragment1 = PolygonWireOffsetContext.createOffsetSegment(points[i], points[i + 1], options.leftOffsetDistance);\r\n      newJoint = new Joint(fragment0, fragment1, points[i]);\r\n      Joint.link(previousJoint, newJoint);\r\n      previousJoint = newJoint;\r\n      fragment0 = fragment1;\r\n    }\r\n    if (wrap)\r\n      Joint.link(previousJoint, joint0);\r\n    else {\r\n      newJoint = new Joint(fragment0, undefined, points[numPoints - 1]);\r\n      Joint.link(previousJoint, newJoint);\r\n    }\r\n    Joint.annotateChain(joint0, options, numPoints);\r\n    for (let pass = 0; pass++ < 5;) {\r\n      const state = Joint.removeDegeneratePrimitives(joint0, options, numPoints);\r\n      joint0 = state.newStart;\r\n      if (state.numJointRemoved === 0)\r\n        break;\r\n      /*\r\n      if (Checker.noisy.PolygonOffset) {\r\n        console.log(\"  POST REMOVE DEGENERATES  \" + state.numJointRemoved);\r\n        Joint.visitJointsOnChain(joint0, (joint: Joint) => { console.log(prettyPrint(joint.shallowExtract())); return true; });\r\n      }\r\n      */\r\n    }\r\n\r\n    // Joint.collectPrimitivesFromChain(joint0, result, numPoints);\r\n    const chain = LineString3d.create();\r\n    Joint.collectStrokesFromChain(joint0, chain, numPoints);\r\n    const n = chain.packedPoints.length;\r\n    if (n > 1) {\r\n      if (chain.packedPoints.front()!.isAlmostEqual(chain.packedPoints.back()!))\r\n        return Loop.create(chain);\r\n      else\r\n        return Path.create(chain);\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/**\r\n * Context for building a wire offset from a Path or Loop of CurvePrimitives\r\n * @internal\r\n */\r\nexport class CurveChainWireOffsetContext {\r\n  /** construct a context. */\r\n  public constructor() {\r\n  }\r\n\r\n  private static _unitAlong = Vector3d.create();\r\n  private static _unitPerp = Vector3d.create();\r\n  private static _offsetA = Point3d.create();\r\n  private static _offsetB = Point3d.create();\r\n\r\n  // Construct a single offset from base points\r\n  private static createOffsetSegment(basePointA: Point3d, basePointB: Point3d, distanceLeft: number): CurvePrimitive | undefined {\r\n    Vector3d.createStartEnd(basePointA, basePointB, this._unitAlong);\r\n    if (this._unitAlong.normalizeInPlace()) {\r\n      this._unitAlong.rotate90CCWXY(this._unitPerp);\r\n      return LineSegment3d.create(\r\n        basePointA.plusScaled(this._unitPerp, distanceLeft, this._offsetA),\r\n        basePointB.plusScaled(this._unitPerp, distanceLeft, this._offsetB));\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Annotate a CurvePrimitive with properties `baseCurveStart` and `baseCurveEnd`.\r\n   * * return cp\r\n   * @param cp primitive to annotate\r\n   * @param startPoint optional start point\r\n   * @param endPoint optional end point\r\n   */\r\n  public static applyBasePoints(cp: CurvePrimitive | undefined, startPoint: Point3d | undefined, endPoint: Point3d | undefined): CurvePrimitive | undefined {\r\n    if (cp !== undefined) {\r\n      if (startPoint !== undefined)\r\n        (cp as any).baseCurveStart = startPoint;\r\n      if (endPoint !== undefined)\r\n        (cp as any).baseCurveEnd = endPoint;\r\n    }\r\n    return cp;\r\n  }\r\n  /**\r\n   * Create the offset of a single primitive.\r\n   * * each primitive may be labeled (as an `any` object) with start or end point of base curve:\r\n   *   * `(primitive as any).baseCurveStart: Point3d`\r\n   *   * `(primitive as any).baseCurveEnd: Point3d`\r\n   * @param g primitive to offset\r\n   * @param distanceLeft\r\n   */\r\n  public static createSingleOffsetPrimitiveXY(g: CurvePrimitive, distanceLeft: number): CurvePrimitive | CurvePrimitive[] | undefined {\r\n    const point0 = g.fractionToPoint(0.0);\r\n    const point1 = g.fractionToPoint(1.0);\r\n    if (g instanceof LineSegment3d) {\r\n      return this.applyBasePoints(this.createOffsetSegment(point0, point1, distanceLeft), point0, point1);\r\n    } else if (g instanceof Arc3d) {\r\n      const g1 = g.cloneAtZ();\r\n      if (g1.isCircular) {\r\n        const sign = g1.sweep.sweepRadians * g1.matrix.coffs[8] >= 0.0 ? 1.0 : -1.0;\r\n        const r = g1.matrix.columnXMagnitude();\r\n        const r1 = r - sign * distanceLeft;\r\n        if (r1 >= 0) {\r\n          const factor = r1 / r;\r\n          const matrix = g1.matrix;\r\n          matrix.scaleColumnsInPlace(factor, factor, 1.0);\r\n          return this.applyBasePoints(Arc3d.createRefs(g1.center.clone(), matrix, g1.sweep.clone()), g.startPoint(), g.endPoint());\r\n        }\r\n      }\r\n    } else if (g instanceof LineString3d) {\r\n      const n = g.numPoints();\r\n      if (n > 1) {\r\n        const offsets = [];\r\n        const pointA = Point3d.create();\r\n        const pointB = Point3d.create();\r\n        g.packedPoints.getPoint3dAtUncheckedPointIndex(0, pointA);\r\n        for (let i = 1; i < n; i++) {\r\n          g.packedPoints.getPoint3dAtUncheckedPointIndex(i, pointB);\r\n          const g1 = this.applyBasePoints(this.createOffsetSegment(pointA, pointB, distanceLeft), pointA.clone(), pointB.clone());\r\n          if (g1 !== undefined)\r\n            offsets.push(g1);\r\n          pointA.setFromPoint3d(pointB);\r\n        }\r\n        return offsets;\r\n      }\r\n\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Construct curves that are offset from a Path or Loop\r\n   * * The construction will remove \"some\" local effects of features smaller than the offset distance, but will not detect self intersection among widely separated edges.\r\n   * * Offset distance is defined as positive to the left.\r\n   * * If offsetDistanceOrOptions is given as a number, default options are applied.\r\n   * * When the offset needs to do an \"outside\" turn, the first applicable construction is applied:\r\n   *   * If the turn is larger than `options.minArcDegrees`, a circular arc is constructed.\r\n   *   * if the turn is larger than `options.maxChamferDegrees`, the turn is constructed as a sequence of straight lines that are\r\n   *      * outside the arc\r\n   *      * have uniform turn angle less than `options.maxChamferDegrees`\r\n   *      * each line segment (except first and last) touches the arc at its midpoint.\r\n   *   * Otherwise the prior and successor curves are extended to simple intersection.\r\n   * @param curves input curves\r\n   * @param offsetDistanceOrOptions offset controls.\r\n   */\r\n  public static constructCurveXYOffset(curves: Path | Loop, options: JointOptions): CurveCollection | undefined {\r\n    const wrap = curves instanceof Loop;\r\n    if (options === undefined)\r\n      return undefined;\r\n\r\n    const simpleOffsets: CurvePrimitive[] = [];\r\n    // setup pass: get simple offsets of each primitive\r\n    for (const c of curves.children) {\r\n      const c1 = CurveChainWireOffsetContext.createSingleOffsetPrimitiveXY(c, options.leftOffsetDistance);\r\n      if (c1 === undefined)\r\n        return undefined;\r\n      if (c1 instanceof CurvePrimitive)\r\n        simpleOffsets.push(c1);\r\n      else if (Array.isArray(c1)) {\r\n        for (const c2 of c1) {\r\n          if (c2 instanceof CurvePrimitive)\r\n            simpleOffsets.push(c2);\r\n        }\r\n      }\r\n    }\r\n    let fragment0 = simpleOffsets[0];\r\n    const joint0 = new Joint(undefined, fragment0, fragment0.fractionToPoint(0.0));\r\n    let newJoint;\r\n    let previousJoint = joint0;\r\n    for (let i = 1; i < simpleOffsets.length; i++) {\r\n      const fragment1 = simpleOffsets[i];\r\n      newJoint = new Joint(fragment0, fragment1, fragment1.fractionToPoint(0.0));\r\n      Joint.link(previousJoint, newJoint);\r\n      previousJoint = newJoint;\r\n      fragment0 = fragment1;\r\n    }\r\n    if (curves instanceof Loop)\r\n      Joint.link(previousJoint, joint0);\r\n\r\n    const numOffset = simpleOffsets.length;\r\n    Joint.annotateChain(joint0, options, numOffset);\r\n\r\n    const outputCurves: CurvePrimitive[] = [];\r\n    Joint.collectCurvesFromChain(joint0, outputCurves, numOffset);\r\n    return RegionOps.createLoopPathOrBagOfCurves(outputCurves, wrap);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { ConsolidateAdjacentCurvePrimitivesOptions, CurveChain } from \"../CurveCollection\";\r\nimport { NullGeometryHandler } from \"../../geometry3d/GeometryHandler\";\r\nimport { Loop } from \"../Loop\";\r\nimport { Path } from \"../Path\";\r\nimport { LineSegment3d } from \"../LineSegment3d\";\r\nimport { LineString3d } from \"../LineString3d\";\r\nimport { PolylineOps } from \"../../geometry3d/PolylineOps\";\r\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\r\nimport { Arc3d } from \"../Arc3d\";\r\nimport { CurveFactory } from \"../CurveFactory\";\r\n/** @module Curve */\r\n/**\r\n * * Implementation class for ConsolidateAdjacentCurvePrimitives.\r\n *\r\n * @internal\r\n */\r\nexport class ConsolidateAdjacentCurvePrimitivesContext extends NullGeometryHandler {\r\n  private _options: ConsolidateAdjacentCurvePrimitivesOptions;\r\n  public constructor(options?: ConsolidateAdjacentCurvePrimitivesOptions) {\r\n    super();\r\n    this._options = options ? options : new ConsolidateAdjacentCurvePrimitivesOptions();\r\n  }\r\n  /** look for adjacent compatible primitives in a path or loop. */\r\n  public handleCurveChain(g: CurveChain) {\r\n    const children = g.children;\r\n    const numOriginal = children.length;\r\n    const points: Point3d[] = [];\r\n    let numAccept = 0;\r\n    // i0 <=i < i1 is a range of child indices.\r\n    // numAccept is the number of children accepted (contiguously at front of children)\r\n    for (let i0 = 0; i0 < numOriginal;) {\r\n      const basePrimitive = g.children[i0];\r\n      if (this._options.consolidateLinearGeometry && (basePrimitive instanceof LineSegment3d || basePrimitive instanceof LineString3d)) {\r\n        points.length = 0;\r\n        let i1 = i0;\r\n        // on exit, i1 is beyond the block of linear primitives  . ..\r\n        for (; i1 < g.children.length; i1++) {\r\n          const nextPrimitive = g.children[i1];\r\n          if (nextPrimitive instanceof LineSegment3d) {\r\n            points.push(nextPrimitive.startPoint());\r\n            points.push(nextPrimitive.endPoint());\r\n          } else if (nextPrimitive instanceof LineString3d) {\r\n            const source = nextPrimitive.packedPoints;\r\n            for (let k = 0; k < source.length; k++) {\r\n              points.push(source.getPoint3dAtUncheckedPointIndex(k));\r\n            }\r\n          } else {\r\n            break;\r\n          }\r\n        }\r\n        if (points.length > 1) {\r\n          const compressedPointsA = PolylineOps.compressShortEdges(points, this._options.colinearPointTolerance);\r\n          const compressedPointsB = PolylineOps.compressByPerpendicularDistance(compressedPointsA, this._options.colinearPointTolerance);\r\n          if (compressedPointsB.length < 2) {\r\n            // Collapsed to a point?  Make a single point linestring\r\n            g.children[numAccept++] = LineString3d.create(compressedPointsB[0]);\r\n          } else if (compressedPointsB.length === 2) {\r\n            g.children[numAccept++] = LineSegment3d.create(compressedPointsB[0], compressedPointsB[1]);\r\n          } else {\r\n            g.children[numAccept++] = LineString3d.createPoints(compressedPointsB);\r\n          }\r\n        } else {\r\n          g.children[numAccept++] = basePrimitive;\r\n        }\r\n        i0 = i1;\r\n      } else if (this._options.consolidateCompatibleArcs && basePrimitive instanceof Arc3d) {\r\n        // subsume subsequent arcs into basePrimitive.\r\n        // always accept base primitive.\r\n        for (; ++i0 < g.children.length;) {\r\n          const nextPrimitive = g.children[i0];\r\n          if (!(nextPrimitive instanceof Arc3d))\r\n            break;\r\n          if (!CurveFactory.appendToArcInPlace(basePrimitive, nextPrimitive))\r\n            break;\r\n        }\r\n        // i0 has already advanced\r\n        g.children[numAccept++] = basePrimitive;    // which has been extended 0 or more times.\r\n      } else {\r\n        g.children[numAccept++] = basePrimitive;\r\n        i0++;\r\n      }\r\n    }\r\n    g.children.length = numAccept;\r\n  }\r\n\r\n  public handlePath(g: Path): any { return this.handleCurveChain(g); }\r\n  public handleLoop(g: Loop): any { return this.handleCurveChain(g); }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { CurveLocationDetailPair, CurveLocationDetail } from \"../CurveLocationDetail\";\r\nimport { CurvePrimitive } from \"../CurvePrimitive\";\r\nimport { Geometry } from \"../../Geometry\";\r\nimport { CurveCollection, CurveChain } from \"../CurveCollection\";\r\nimport { CurveCurve } from \"../CurveCurve\";\r\nimport { Path } from \"../Path\";\r\n\r\n/**\r\n * Data about a curve cut.\r\n */\r\nclass CutFractionDescriptor {\r\n  /** Fractional position along the curve */\r\n  public fraction: number;\r\n  public otherCurveDetail?: CurveLocationDetail;\r\n  public constructor(fraction: number, otherCurveDetail?: CurveLocationDetail) {\r\n    this.fraction = fraction;\r\n    this.otherCurveDetail = otherCurveDetail;\r\n  }\r\n  /** Transfer data from other to this.\r\n   * * Optionally look at both to set `otherCurveDetail`\r\n   *   * `other.otherCurveDetail` wins over `this.otherCurveDetail`\r\n   */\r\n  public setFrom(other: CutFractionDescriptor, combineCutFlag: boolean) {\r\n    if (combineCutFlag && this.isSameFraction(other))\r\n      this.otherCurveDetail = other.otherCurveDetail ? other.otherCurveDetail : this.otherCurveDetail;\r\n    this.fraction = other.fraction;\r\n  }\r\n  /** Test if a the fractions are almost equal. */\r\n  public isSameFraction(other: CutFractionDescriptor): boolean {\r\n    return Geometry.isSmallAngleRadians(this.fraction - other.fraction);\r\n  }\r\n  /** set from direct data */\r\n  public set(fraction: number, otherCurveDetail?: CurveLocationDetail) {\r\n    this.fraction = fraction;\r\n    this.otherCurveDetail = otherCurveDetail;\r\n  }\r\n}\r\n/**\r\n * Context for splitting curves.\r\n * @internal\r\n */\r\nexport class CurveSplitContext {\r\n  // return true if data has one or more non-endpoint intersections.\r\n  private static hasInteriorDetailAIntersections(data: CurveLocationDetailPair[], fractionTolerance: number = Geometry.smallAngleRadians): boolean {\r\n    if (data.length === 0)\r\n      return false;\r\n    for (const pair of data) {\r\n      if (pair.detailA.fraction > fractionTolerance || pair.detailA.fraction < 1 - fractionTolerance)\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n  private collectFragmentAndAdvanceCut(curveToCut: CurvePrimitive, cutA: CutFractionDescriptor, cutB: CutFractionDescriptor, dest: CurvePrimitive[]) {\r\n    if (!cutA.isSameFraction(cutB)) {\r\n      const fragment = curveToCut.clonePartialCurve(cutA.fraction, cutB.fraction);\r\n      if (fragment !== undefined) {\r\n        fragment.startCut = cutA.otherCurveDetail;\r\n        fragment.endCut = cutB.otherCurveDetail;\r\n        dest.push(fragment);\r\n      }\r\n    }\r\n    cutA.setFrom(cutB, true);\r\n  }\r\n  /** Collect fragments from an intersections array, with the array detailA entries all referencing to curveToCut.\r\n   * * The `intersections` array is sorted on its detailA field.\r\n   */\r\n  private collectSinglePrimitiveFragments(curveToCut: CurvePrimitive, intersections: CurveLocationDetailPair[] | undefined, fragments: CurvePrimitive[]) {\r\n\r\n    if (intersections === undefined || !CurveSplitContext.hasInteriorDetailAIntersections(intersections)) {\r\n      const fragment = curveToCut.clone();\r\n      if (fragment)\r\n        fragments.push(fragment as CurvePrimitive);\r\n      return;\r\n    }\r\n    intersections.sort((pairA: CurveLocationDetailPair, pairB: CurveLocationDetailPair) => (pairA.detailA.fraction - pairB.detailA.fraction));\r\n    const cutA = new CutFractionDescriptor(0.0, undefined);\r\n    const cutB = new CutFractionDescriptor(1.0, undefined); // but those values are immediately reset before use.\r\n    for (const pair of intersections) {\r\n      cutB.set(pair.detailA.fraction, pair.detailB);\r\n      this.collectFragmentAndAdvanceCut(curveToCut, cutA, cutB, fragments);\r\n    }\r\n    cutB.set(1.0, undefined);\r\n    this.collectFragmentAndAdvanceCut(curveToCut, cutA, cutB, fragments);\r\n  }\r\n  public static cloneCurvesWithXYSplitFlags(curvesToCut: CurvePrimitive | CurveCollection | undefined, cutterCurves: CurveCollection): CurveCollection | CurvePrimitive | undefined {\r\n    const context = new CurveSplitContext();\r\n    if (curvesToCut instanceof CurvePrimitive) {\r\n      const result: CurvePrimitive[] = [];\r\n      const intersections = CurveCurve.intersectionXYPairs(curvesToCut, false, cutterCurves, false);\r\n      context.collectSinglePrimitiveFragments(curvesToCut, intersections, result);\r\n      if (result.length === 1)\r\n        return result[0];\r\n      return Path.createArray(result);\r\n\r\n    } else if (curvesToCut instanceof CurveChain) {\r\n      const result: CurvePrimitive[] = [];\r\n      for (const primitive of curvesToCut.children) {\r\n        const intersections = CurveCurve.intersectionXYPairs(primitive, false, cutterCurves, false);\r\n        context.collectSinglePrimitiveFragments(primitive, intersections, result);\r\n      }\r\n      return Path.createArray(result);\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { GeometryQuery } from \"../GeometryQuery\";\r\nimport { RecurseToCurvesGeometryHandler } from \"../../geometry3d/GeometryHandler\";\r\n\r\nimport { LineSegment3d } from \"../LineSegment3d\";\r\nimport { Point3d, Vector3d } from \"../../geometry3d/Point3dVector3d\";\r\nimport { LineString3d } from \"../LineString3d\";\r\nimport { Transform } from \"../../geometry3d/Transform\";\r\nimport { StrokeOptions } from \"../StrokeOptions\";\r\nimport { Arc3d } from \"../Arc3d\";\r\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\r\nimport { AnyCurve } from \"../CurveChain\";\r\n\r\n/**\r\n * Context for computing geometry range around an axis.\r\n * * The publicly called method is `computeZRRange (ray, geometry)\r\n */\r\nexport class CylindricalRangeQuery extends RecurseToCurvesGeometryHandler {\r\n  // private geometry0: GeometryQuery;  <-- Never used\r\n  private _perpVector: Vector3d;\r\n  private _maxDistance: number;\r\n  private _localToWorld: Transform;\r\n  /** capture ray and initialize evolving ranges. */\r\n  private constructor(ray: Ray3d) {\r\n    super();\r\n    this._perpVector = Vector3d.createZero();\r\n    this._maxDistance = 0.0;\r\n    this._localToWorld = ray.toRigidZFrame()!;\r\n  }\r\n  private _localPoint = Point3d.create();\r\n  private _worldPoint = Point3d.create();\r\n  private announcePoint(xyz: Point3d) {\r\n    this._localToWorld.multiplyInversePoint3d(xyz, this._localPoint);\r\n    const distance = this._localPoint.magnitudeXY();\r\n    if (distance >= this._maxDistance) {\r\n      this._maxDistance = distance;\r\n      this._perpVector.setFromPoint3d(this._localPoint);\r\n      this._perpVector.z = 0.0;\r\n      this._localToWorld.matrix.multiplyXY(this._localPoint.x, this._localPoint.y, this._perpVector);\r\n    }\r\n  }\r\n\r\n  public handleLineSegment3d(segment0: LineSegment3d) {\r\n    this.announcePoint(segment0.startPoint(this._worldPoint));\r\n    this.announcePoint(segment0.endPoint(this._worldPoint));\r\n  }\r\n  public handleLineString3d(ls0: LineString3d) {\r\n    for (let i = 0; i < ls0.numPoints(); i++) {\r\n      ls0.pointAt(i, this._worldPoint);\r\n      this.announcePoint(this._worldPoint);\r\n    }\r\n  }\r\n\r\n  public handleArc3d(arc0: Arc3d): any {\r\n    // humbug .. just stroke it ..\r\n    // exact solution is:\r\n    //   project the arc to the z=0 plane of the local system.\r\n    //   find max distance to origin.\r\n    const numStroke = StrokeOptions.applyAngleTol(undefined, 3, arc0.sweep.sweepRadians, 0.1);\r\n    const df = 1.0 / numStroke;\r\n    for (let i = 0; i <= numStroke; i++) {\r\n      arc0.fractionToPoint(i * df, this._worldPoint);\r\n      this.announcePoint(this._worldPoint);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Compute the largest vector perpendicular to a ray and ending on the geometry.\r\n   * @param geometry0 geometry to search\r\n   * @returns vector from ray to geometry.\r\n   */\r\n  public static computeMaxVectorFromRay(ray: Ray3d, geometry: GeometryQuery): Vector3d {\r\n    const accumulator = new CylindricalRangeQuery(ray);\r\n    geometry.dispatchToGeometryHandler(accumulator);\r\n    return accumulator._perpVector.clone();\r\n  }\r\n\r\n  /**\r\n   * Recurse through geometry.children to find linestrings.\r\n   * In each linestring, compute the surface normal annotation from\r\n   *  * the curve tangent stored in the linestring\r\n   *  * the axis of rotation\r\n   *  * a default V vector to be used when the linestring point is close to the axis.\r\n   * @param geometry\r\n   * @param axis\r\n   * @param defaultVectorV\r\n   */\r\n  public static buildRotationalNormalsInLineStrings(geometry: AnyCurve, axis: Ray3d, defaultVectorFromAxis: Vector3d) {\r\n    if (geometry instanceof LineString3d) {\r\n      const points = geometry.packedPoints;\r\n      const derivatives = geometry.packedDerivatives;\r\n      const normals = geometry.ensureEmptySurfaceNormals();\r\n      if (derivatives && normals) {\r\n        const vectorU = Vector3d.create();\r\n        const vectorV = Vector3d.create();  // v direction (forwward along sweep) for surface of rotation.\r\n        const xyz = Point3d.create();\r\n        const n = points.length;\r\n        for (let i = 0; i < n; i++) {\r\n          points.getPoint3dAtUncheckedPointIndex(i, xyz);\r\n          axis.perpendicularPartOfVectorToTarget(xyz, vectorU);\r\n          if (vectorU.isAlmostZero)\r\n            axis.direction.crossProduct(defaultVectorFromAxis, vectorV);\r\n          else\r\n            axis.direction.crossProduct(vectorU, vectorV);\r\n          geometry.packedDerivatives!.getVector3dAtCheckedVectorIndex(i, vectorU); // reuse vector U as curve derivative\r\n          vectorU.crossProduct(vectorV, vectorV);  // reuse vector V as normal!\r\n          vectorV.normalizeInPlace();\r\n          normals.push(vectorV);\r\n        }\r\n      }\r\n    } else if (geometry.children) {\r\n      const children = geometry.children;\r\n      for (const child of children) {\r\n        this.buildRotationalNormalsInLineStrings(child as AnyCurve, axis, defaultVectorFromAxis);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Loop } from \"../Loop\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Angle } from \"../../geometry3d/Angle\";\r\nimport { CurveLocationDetail, CurveIntervalRole } from \"../CurveLocationDetail\";\r\nimport { CurvePrimitive } from \"../CurvePrimitive\";\r\nimport { ParityRegion } from \"../ParityRegion\";\r\nimport { Geometry } from \"../../Geometry\";\r\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\r\nimport { UnionRegion } from \"../UnionRegion\";\r\nimport { AnyRegion } from \"../CurveChain\";\r\n\r\n/**\r\n * Context for testing containment in Loop, ParityRegion and UnionRegion.\r\n * @internal\r\n */\r\nexport class PointInOnOutContext {\r\n  /**\r\n   * In-out test for a single loop.\r\n   * * Test by finding intersections with an xy line (xyz plane) in \"some\" direction.\r\n   * * Test logic gets complicated if the plane has a vertex hit.\r\n   * * If that happens, don't try to figure out the cases.   Just move on to another plane.\r\n   * * Any \"on\" point triggers immediate 0 return.\r\n   *   * (Hence if there are overlapping lines their self-canceling effect might be wrong.)\r\n   * @param loop\r\n   * @param x tested x coordinate\r\n   * @param y tested y coordinate\r\n   */\r\n  public static testPointInOnOutLoopXY(loop: Loop, x: number, y: number): number {\r\n    let plane: Plane3dByOriginAndUnitNormal;\r\n    const xy = Point3d.create(x, y);\r\n    for (let radians = 0.0; Math.abs(radians) < 6.0; radians = -1.2313 * (radians + 0.3212897)) {\r\n      plane = Plane3dByOriginAndUnitNormal.createXYAngle(x, y, Angle.createRadians(radians))!;\r\n      const normal = plane.getNormalRef();\r\n      const intersections: CurveLocationDetail[] = [];\r\n      for (const cp of loop.children) {\r\n        if (cp instanceof CurvePrimitive)\r\n          cp.appendPlaneIntersectionPoints(plane, intersections);\r\n      }\r\n      CurvePrimitive.snapAndRestrictDetails(intersections, false, true);\r\n      let numLeft = 0;\r\n      let numRight = 0;\r\n      let numTricky = 0;\r\n      let wx, wy;\r\n      // Count simple crossings to left and right.\r\n      // Also count tricky crossings (vertex hits, onEdge)\r\n      // If there are any tricky ones, go around with a different plane.\r\n      // A intently devious tester could make every plane hit tricky things.\r\n      for (const intersection of intersections) {\r\n        if (intersection.intervalRole !== CurveIntervalRole.isolated\r\n          && intersection.intervalRole !== undefined) {\r\n          numTricky++;\r\n        }\r\n        wx = intersection.point.x - x;\r\n        wy = intersection.point.y - y;\r\n        if (Geometry.isSameCoordinateXY(wx, wy, 0, 0))\r\n          return 0;\r\n        const cross = Geometry.crossProductXYXY(normal.x, normal.y, wx, wy);\r\n        if (xy.isAlmostEqualXY(intersection.point))\r\n          return 0;\r\n        if (cross < 0.0)\r\n          numLeft++;\r\n        else if (cross > 0.0)\r\n          numRight++;\r\n      }\r\n      if (numTricky !== 0) // try another angle !!\r\n        continue;\r\n      const leftParity = numLeft & (0x01);\r\n      const rightParity = numRight & (0x01);\r\n      if (leftParity === rightParity)\r\n        return leftParity === 1 ? 1 : -1;\r\n    }\r\n    return -1;\r\n  }\r\n  /**\r\n   * strongly-typed parity region handling: XOR of all loops. (But any ON is returned as edge hit.)\r\n   * @param parent\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public static testPointInOnOutParityRegionXY(parent: ParityRegion, x: number, y: number): number {\r\n    let result = -1;\r\n    for (const loop of parent.children) {\r\n      if (loop instanceof Loop) {\r\n        const q = this.testPointInOnOutLoopXY(loop, x, y);\r\n        if (q === 0)\r\n          return 0;\r\n        if (q > 0)\r\n          result = - result;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  public static testPointInOnOutUnionRegionXY(parent: UnionRegion, x: number, y: number): number {\r\n    for (const loop of parent.children) {\r\n        const classify = this.testPointInOnOutRegionXY(loop, x, y);\r\n        if (classify >= 0)\r\n          return classify;\r\n    }\r\n    return -1;\r\n  }\r\n  public static testPointInOnOutRegionXY(parent: AnyRegion, x: number, y: number): number {\r\n    if (parent instanceof Loop)\r\n      return this.testPointInOnOutLoopXY(parent, x, y);\r\n    else if (parent instanceof ParityRegion)\r\n      return this.testPointInOnOutParityRegionXY(parent, x, y);\r\n    else if (parent instanceof UnionRegion)\r\n      return this.testPointInOnOutUnionRegionXY(parent, x, y);\r\n    return -1;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { StrokeCountMap } from \"./StrokeCountMap\";\r\nimport { CurveCollection, CurveChain } from \"../CurveCollection\";\r\nimport { ParityRegion } from \"../ParityRegion\";\r\nimport { StrokeOptions } from \"../StrokeOptions\";\r\nimport { LineString3d } from \"../LineString3d\";\r\nimport { AnyCurve } from \"../CurveChain\";\r\n\r\nimport { Loop } from \"../Loop\";\r\nimport { Range1d } from \"../../geometry3d/Range\";\r\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\r\nimport { Geometry } from \"../../Geometry\";\r\n// cspell:word remapa\r\n/**\r\n * abstract methods for callbacks during sweeps of collections of StrokeCount Structures.\r\n * * A set of StrokeCountMaps are to be visited multiple times.\r\n * * The logic that controls the sweep is as below.\r\n * * The callback object controls the number of sweeps and can adapt its action to the respective sweeps.\r\n * * Note that a \"false\" from cb.startPass() terminates passes for this chainIndex and primitiveIndex, but all others exit the whole sequence.\r\n * * This logic occurs 2 or three levels deep\r\n *   * outer level is \"chains\".   Simple swept path or loops have only one outer; parity regions have one outer per loop of the parity region\r\n *   * second level is primitive within chain.\r\n *     * If the primitives in a set are \"single component\", second level is lowest.\r\n *        * startSweep() and endSweep() calls are two parameters, with undefined componentIndex\r\n *     * If the primitives in a set are multi-component, there is a third level looping through corresponding components.\r\n * `\r\n *    if (!cb.startSweeps (chainIndex, primitiveIndex, componentIndex))\r\n *      return false;\r\n *    for (let pass = 0;cb.startPass (pass); pass++){\r\n *      for (each map in working set)\r\n *            if (!cb.visit (pass, map)) return false;\r\n *       if (!cb.endPass ()) return false;\r\n *        }\r\n *      }\r\n * if (!cb.endSweeps (chainIndex, primitiveIndex, componentIndex)) return false;\r\n * return true;\r\n * `\r\n * @internal\r\n */\r\nexport abstract class StrokeCountMapMultipassVisitor {\r\n  /**\r\n   * called to announce the beginning of one or more sweeps through related StrokeCountMap's\r\n   * @param chainIndex index of loop or path within the various contours.\r\n   * @param primitiveIndex index of primitive within the loop or path.\r\n   * @param componentIndex optional component index.\r\n   * @returns the number of sweeps to perform.\r\n   */\r\n  public startSweeps(_chainIndex: number, _primitiveIndex: number, _componentIndex?: number): boolean { return true; }\r\n  /**\r\n   * announce the beginning of a sweep pass.\r\n   * @param pass the index (0,1...) for this sweep pass.\r\n   * @return true to execute this pass.  false to break from the pass loop (next method called is endSweeps)\r\n   */\r\n  public abstract startPass(pass: number): boolean;\r\n  public abstract visit(pass: number, map: StrokeCountMap): boolean;\r\n  /**\r\n   * announce the end of a pass\r\n   * @param pass the index (0,1...) for this sweep pass.\r\n   * @return true to continue the sweeps.\r\n   */\r\n\r\n  public abstract endPass(pass: number): boolean;\r\n  /**\r\n   * announce the end of handling for particular chainIndex and primitiveIndex;\r\n   * @return true to continue outer loops.\r\n   */\r\n  public endSweeps(_chainIndex: number, _primitiveIndex: number, _componentIndex?: number): boolean { return true; }\r\n\r\n}\r\n/**\r\n * * pass 1: determine max numStroke\r\n * * pass 2: impose max numStroke\r\n * @internal\r\n */\r\nexport class StrokeCountMapVisitorApplyMaxCount extends StrokeCountMapMultipassVisitor {\r\n  public myMap: StrokeCountMap;\r\n  public constructor() {\r\n    super();\r\n    this.myMap = StrokeCountMap.createWithComponentIndex();\r\n  }\r\n  /** set up for a pass through corresponding maps. */\r\n  public startPass(pass: number): boolean {\r\n    if (pass === 0) {\r\n      this.myMap.numStroke = 0;\r\n      return true;\r\n    } else if (pass === 1) {\r\n      // nothing to change == numStroke will be applied to each primitive.\r\n      return true;\r\n    }\r\n    // all other pass numbers are rejected ...\r\n    return false;\r\n  }\r\n  /** visit one of the set of corresponding maps. */\r\n  public visit(pass: number, map: StrokeCountMap): boolean {\r\n    if (pass === 0) {\r\n      if (map.numStroke > this.myMap.numStroke)\r\n        this.myMap.numStroke = map.numStroke;\r\n      return true;\r\n    } else if (pass === 1) {\r\n      // apply the max from prior pass\r\n      map.numStroke = this.myMap.numStroke;\r\n      return true;\r\n    }\r\n    // no other pass values should happen -- canceled by startPass.\r\n    return false;\r\n  }\r\n\r\n  public endPass(_pass: number): boolean { return true; }\r\n}\r\n/**\r\n * * pass 1: determine max curveLength among maps presented.\r\n * * pass 2: set the a0 and a1 values to 0 and that max distance\r\n * @internal\r\n */\r\nexport class StrokeCountMapVisitorApplyMaxCurveLength extends StrokeCountMapMultipassVisitor {\r\n  public maxCurveLength: number;\r\n  public constructor() {\r\n    super();\r\n    this.maxCurveLength = 0.0;\r\n  }\r\n  /** set up for a pass through corresponding maps. */\r\n  public startPass(pass: number): boolean {\r\n    if (pass === 0) {\r\n      this.maxCurveLength = 0;\r\n      return true;\r\n    } else if (pass === 1) {\r\n      // nothing to change == numStroke will be applied to each primitive.\r\n      return true;\r\n    }\r\n    // all other pass numbers are rejected ...\r\n    return false;\r\n  }\r\n  /** visit one of the set of corresponding maps. */\r\n  public visit(pass: number, map: StrokeCountMap): boolean {\r\n    if (pass === 0) {\r\n      this.maxCurveLength = Geometry.maxXY(map.curveLength, this.maxCurveLength);\r\n      return true;\r\n    } else if (pass === 1) {\r\n      // apply the max from prior pass\r\n      map.a0 = 0.0;\r\n      map.a1 = this.maxCurveLength;\r\n      return true;\r\n    }\r\n    // no other pass values should happen -- canceled by startPass.\r\n    return false;\r\n  }\r\n\r\n  public endPass(_pass: number): boolean { return true; }\r\n}\r\n/**\r\n * class `StrokeCountChain` contains:\r\n * * `maps` = an array of `StrokeCountMap`\r\n * * `parent` = parent CurveCollection.\r\n *\r\n * An instance is normally created with either a `Path` or `Loop` as the parent.\r\n */\r\nexport class StrokeCountChain {\r\n  public maps: StrokeCountMap[];\r\n  public parent?: CurveCollection;\r\n  /**\r\n   * options are used (with different purposes) at two times:\r\n   * * When the StrokeCountChain is created, the options affect the stroke counts.  This is just creating markup, not actual strokes.\r\n   * * When actual stroking happens, the options control creation of parameters and tangents.\r\n   */\r\n  public options?: StrokeOptions;\r\n\r\n  private constructor(parent?: CurveCollection, options?: StrokeOptions) {\r\n    this.parent = parent;\r\n    this.maps = [];\r\n    this.options = options;\r\n  }\r\n  public static createForCurveChain(chain: CurveChain, options?: StrokeOptions): StrokeCountChain {\r\n    const result = new StrokeCountChain(chain, options);\r\n    result.parent = chain;\r\n    // A chain can only contain primitives !!!!\r\n    for (const p of chain.children) {\r\n      p.computeAndAttachRecursiveStrokeCounts(options);\r\n      if (p.strokeData)\r\n        result.maps.push(p.strokeData);\r\n    }\r\n    return result;\r\n  }\r\n  public getStrokes(): LineString3d {\r\n    const ls = LineString3d.create();\r\n    if (this.options) {\r\n      if (this.options.needNormals || this.options.needParams) {\r\n        ls.ensureEmptyFractions();\r\n        ls.ensureEmptyDerivatives();\r\n        ls.ensureEmptyUVParams();\r\n      }\r\n    }\r\n    for (const m of this.maps) {\r\n      if (m.primitive)\r\n        m.primitive.addMappedStrokesToLineString3D(m, ls);\r\n    }\r\n    return ls;\r\n\r\n  }\r\n  /** internal form of  */\r\n  private static applySummed01LimitsWithinArray(maps: StrokeCountMap[], incomingSum: number): number {\r\n    let movingSum = incomingSum;\r\n    for (const m of maps) {\r\n      m.a0 += movingSum;\r\n      if (m.componentData) {\r\n        m.a1 = this.applySummed01LimitsWithinArray(m.componentData, m.a0);\r\n      } else {\r\n        m.a1 += movingSum;\r\n      }\r\n      movingSum = m.a1;\r\n    }\r\n    return movingSum;\r\n  }\r\n  /**\r\n   * walk the maps in the array.\r\n   * * in maps with no component data\r\n   *   * increment map.a0 and map.a1 by the incoming distance a0\r\n   * * in maps with component data:\r\n   *   * recurse through the component array.\r\n   *   * increment map.a0 by the incoming a0.\r\n   *   * returned a1 from the componentData array becomes a1\r\n   * @returns upper value of a1 in final map.\r\n   * @param maps\r\n   * @param incomingSum lower value to add to a0 for first map.\r\n   */\r\n  public applySummed01Limits(incomingSum: number): number {\r\n    return StrokeCountChain.applySummed01LimitsWithinArray(this.maps, incomingSum);\r\n  }\r\n}\r\n\r\n/**\r\n * class `StrokeCountSection`\\\r\n * * contains an array of `StrokeCountChain`.\r\n * * Hence it is the internal node level of a (1-level-deep) tree of `StrokeCountChain`\r\n * @internal\r\n */\r\nexport class StrokeCountSection {\r\n  public chains: StrokeCountChain[];\r\n  public parent?: CurveCollection;\r\n  private constructor(parent?: CurveCollection) { this.parent = parent; this.chains = []; }\r\n  /**\r\n   * construct array of arrays of `StrokeCountMap`s\r\n   * @param parent\r\n   */\r\n  public static createForParityRegionOrChain(parent: CurveCollection, options?: StrokeOptions): StrokeCountSection {\r\n    const result = new StrokeCountSection(parent);\r\n    if (parent instanceof ParityRegion) {\r\n      for (const child of parent.children) {\r\n        const p = StrokeCountChain.createForCurveChain(child, options);\r\n        result.chains.push(p);\r\n      }\r\n    } else if (parent instanceof CurveChain) {\r\n      result.chains.push(StrokeCountChain.createForCurveChain(parent, options));\r\n    }\r\n    return result;\r\n  }\r\n  /** test if all sections have the same structure. */\r\n  public static areSectionsCompatible(sections: StrokeCountSection[], enforceCounts: boolean): boolean {\r\n    if (sections.length < 2)\r\n      return true;  // hm.. don't know if that is useful, but nothing to check here.\r\n    const numChains = sections[0].chains.length;\r\n    for (let i = 1; i < sections.length; i++) {\r\n      // first level: must match number of paths or loops\r\n      if (sections[i].chains.length !== numChains)\r\n        return false;\r\n      // second level: must have same number of primitives in each path or loop\r\n      for (let j = 0; j < sections[0].chains.length; j++) {\r\n        const numPrimitive = sections[0].chains[j].maps.length;\r\n        if (sections[i].chains[j].maps.length !== numPrimitive)\r\n          return false;\r\n        for (let k = 0; k < numPrimitive; k++) {\r\n          if (!sections[0].chains[j].maps[k].isCompatibleComponentStructure(sections[i].chains[j].maps[k], enforceCounts))\r\n            return false;\r\n        }\r\n      }\r\n\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Within each section, sweep accumulate curveLength field, recording entry and exit sum in each map.\r\n   * * In expected use, (a0,a1) are (0,a) where a is the (previously computed) max length among corresponding maps up and down the section arrays.\r\n   */\r\n  public static remapa0a1WithinEachChain(sections: StrokeCountSection[]) {\r\n    for (const section of sections) {\r\n      for (const chain of section.chains) {\r\n        chain.applySummed01Limits(0.0);\r\n      }\r\n    }\r\n  }\r\n\r\n  private static applyMultipassVisitorCallbackNoComponents(sections: StrokeCountSection[], chainIndex: number, primitiveIndex: number,\r\n    componentIndex: number | undefined, callback: StrokeCountMapMultipassVisitor) {\r\n    const numSection = sections.length;\r\n    if (!callback.startSweeps(chainIndex, primitiveIndex, componentIndex)) return false;\r\n    if (componentIndex === undefined) {\r\n      // there are corresponding primitives directly at the section, chain, primitive index:\r\n      for (let pass = 0; ; pass++) {\r\n        if (!callback.startPass(pass))\r\n          break;\r\n        for (let sectionIndex = 0; sectionIndex < numSection; sectionIndex++)\r\n          if (!callback.visit(pass, sections[sectionIndex].chains[chainIndex].maps[primitiveIndex]))\r\n            return false;\r\n        if (!callback.endPass(pass))\r\n          return false;\r\n      }\r\n    } else {\r\n      // there are corresponding primitives at the section, chain, primitive,componentIndex\r\n      // there are corresponding primitives directly at the section, chain, primitive index:\r\n      for (let pass = 0; ; pass++) {\r\n        if (!callback.startPass(pass))\r\n          break;\r\n        for (let sectionIndex = 0; sectionIndex < numSection; sectionIndex++)\r\n          if (!callback.visit(pass, sections[sectionIndex].chains[chainIndex].maps[primitiveIndex].componentData![componentIndex]))\r\n            return false;\r\n        if (!callback.endPass(pass))\r\n          return false;\r\n      }\r\n\r\n    }\r\n    if (!callback.endSweeps(chainIndex, primitiveIndex, componentIndex)) return false;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Walk through the sections, emitting callbacks delimiting groups of corresponding primitives.\r\n   * @param sections array of sections (possibly a single path or loop at each section, or possibly a set of parity loops.)\r\n   * @param callback object to be notified during the traversal\r\n   */\r\n  public static runMultiPassVisitorAtCorrespondingPrimitives(sections: StrokeCountSection[], callback: StrokeCountMapMultipassVisitor): boolean {\r\n    const numChainPerSection = sections[0].chains.length;\r\n    for (let chainIndex = 0; chainIndex < numChainPerSection; chainIndex++) {\r\n      const numPrimitive = sections[0].chains[chainIndex].maps.length;\r\n      for (let primitiveIndex = 0; primitiveIndex < numPrimitive; primitiveIndex++) {\r\n        if (sections[0].chains[chainIndex].maps[primitiveIndex].componentData) {\r\n          const numComponent = sections[0].chains[chainIndex].maps[primitiveIndex]!.componentData!.length;\r\n          for (let i = 0; i < numComponent; i++)\r\n            if (!this.applyMultipassVisitorCallbackNoComponents(sections, chainIndex, primitiveIndex, i, callback))\r\n              return false;\r\n\r\n        } else {\r\n          if (!this.applyMultipassVisitorCallbackNoComponents(sections, chainIndex, primitiveIndex, undefined, callback))\r\n            return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * * Confirm that all sections in the array have the same structure.\r\n   * * Within each corresponding set of entries, apply the max count to all.\r\n   * @param sections array of per-section stroke count entries\r\n   */\r\n  public static enforceStrokeCountCompatibility(sections: StrokeCountSection[]): boolean {\r\n\r\n    if (sections.length < 2)\r\n      return true;\r\n    if (!StrokeCountSection.areSectionsCompatible(sections, false))\r\n      return false;\r\n    const visitor = new StrokeCountMapVisitorApplyMaxCount();\r\n    this.runMultiPassVisitorAtCorrespondingPrimitives(sections, visitor);\r\n    return true;\r\n\r\n  }\r\n  /**\r\n   * * Confirm that all sections in the array have the same structure.\r\n   * * Within each corresponding set of entries up and down the sections, set curveLength as the maximum of the respective curve lengths.\r\n   * * Along each section, sum curveLengths (which were just reset) to get consistent along-chain parameters\r\n   * @param sections array of per-section stroke count entries\r\n   */\r\n  public static enforceCompatibleDistanceSums(sections: StrokeCountSection[]): boolean {\r\n\r\n    if (sections.length < 2)\r\n      return true;\r\n    if (!StrokeCountSection.areSectionsCompatible(sections, false))\r\n      return false;\r\n    const visitor = new StrokeCountMapVisitorApplyMaxCurveLength();\r\n    this.runMultiPassVisitorAtCorrespondingPrimitives(sections, visitor);\r\n    this.remapa0a1WithinEachChain(sections);\r\n    return true;\r\n\r\n  }\r\n\r\n  /**\r\n   * Return stroked form of the section.\r\n   */\r\n  public getStrokes(): AnyCurve {\r\n    if (this.chains.length === 1) {\r\n      return this.chains[0].getStrokes();\r\n    } else {\r\n      const region = ParityRegion.create();\r\n      for (const c of this.chains) {\r\n        const strokes = c.getStrokes();\r\n        if (strokes instanceof LineString3d)\r\n          region.tryAddChild(Loop.create(strokes));\r\n      }\r\n      return region;\r\n    }\r\n  }\r\n  /**\r\n   * Given two compatible stroke sets (as returned by getStrokes) extend a range\r\n   * with the distances between corresponding points.\r\n   * * Each set of strokes may be:\r\n   *   * linestring\r\n   *   * ParityRegion\r\n   *   * CurveChain (Loop or Path)\r\n   * @param strokeA first set of strokes\r\n   * @param strokeB second set of strokes\r\n   * @param rangeToExtend caller-allocated range to be extended.\r\n   * @returns true if structures are compatible.\r\n   */\r\n  public static extendDistanceRangeBetweenStrokes(strokeA: AnyCurve, strokeB: AnyCurve, rangeToExtend: Range1d): boolean {\r\n    if (!strokeA.isSameGeometryClass(strokeB))\r\n      return false;\r\n    if (strokeA instanceof LineString3d) {\r\n      if (!(strokeB instanceof LineString3d))\r\n        return false;\r\n      if (strokeA.numPoints() === strokeB.numPoints()) {\r\n        const n = strokeA.numPoints();\r\n        const pointA = Point3d.create();\r\n        const pointB = Point3d.create();\r\n        const allPointA = strokeA.packedPoints;\r\n        const allPointB = strokeB.packedPoints;\r\n\r\n        for (let i = 0; i < n; i++) {\r\n          allPointA.getPoint3dAtCheckedPointIndex(i, pointA);\r\n          allPointB.getPoint3dAtCheckedPointIndex(i, pointB);\r\n          rangeToExtend.extendX(pointA.distance(pointB));\r\n        }\r\n        return true;\r\n      }\r\n    } else if (strokeA instanceof ParityRegion) {\r\n      if (!(strokeB instanceof ParityRegion))\r\n        return false;\r\n      const childrenA = strokeA.children;\r\n      const childrenB = strokeB.children;\r\n      const n = childrenA.length;\r\n      if (n === childrenB.length) {\r\n        for (let i = 0; i < n; i++) {\r\n          if (!this.extendDistanceRangeBetweenStrokes(childrenA[i], childrenB[i], rangeToExtend))\r\n            return false;\r\n        }\r\n        return true;\r\n      }\r\n    } else if (strokeA instanceof CurveChain) {\r\n      if (!(strokeB instanceof CurveChain))\r\n        return false;\r\n      const childrenA = strokeA.children;\r\n      const childrenB = strokeB.children;\r\n      const n = childrenA.length;\r\n      if (n === childrenB.length) {\r\n        for (let i = 0; i < n; i++) {\r\n          if (!this.extendDistanceRangeBetweenStrokes(childrenA[i], childrenB[i], rangeToExtend))\r\n            return false;\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { CurvePrimitive } from \"../CurvePrimitive\";\r\nimport { Geometry } from \"../../Geometry\";\r\n\r\n/** @module Curve */\r\n/**\r\n * data carrier interface for per-primitive stroke counts and distances used by PolyfaceBuilder.\r\n * * For a simple primitive (Line segment or arc) that is stroked with uniform fraction, the members are:\r\n *   * `numStroke` = total number of strokes\r\n *   * `curveLength` = length of this curve\r\n *   * `a0` = external mapped coordinate for fraction 0 on this primitive or component\r\n *   * `a1` = external mapped coordinate for fraction 1 on this primitive or component\r\n *\r\n * * For linestring and bspline curve, those numbers are totals for the overall curve, and breakdown within\r\n *     the components (line segments or bezier spans) is recorded on the optional array `componentData[]`\r\n *   * Members of the array are annotated with componentIndex within the linestring or bspline curve\r\n * @public\r\n */\r\nexport class StrokeCountMap {\r\n/** number of strokes expected in this interval. */\r\n  public numStroke: number;\r\n  /** Length of the curve interval. */\r\n  public curveLength: number;\r\n  /** start coordinate (in user-defined space) for fraction 0 on this primitive or component */\r\n  public a0: number;\r\n  /** end coordinate (in user-defined space) for fraction 0 on this primitive or component */\r\n  public a1: number;\r\n  /** further StrokeCountMap's within this interval (e.g. for individual segments of a linestring.) */\r\n  public componentData?: StrokeCountMap[];\r\n  /** The curve that this map represents */\r\n  public primitive?: CurvePrimitive;\r\n  /** this curve's index within its parent. */\r\n  public componentIndex?: number;\r\n  /**\r\n   * Constructor.  Initialize all fields from arguments.\r\n   * * Callers that expect to announce numStroke and curveLength for multiple components send an empty componentData array.\r\n   * * Callers that do not have multiple components send undefined component data.\r\n   * @param numStroke\r\n   * @param curveLength\r\n   * @param a0\r\n   * @param a1\r\n   * @param componentData\r\n   */\r\n  private constructor(numStroke: number, curveLength: number, a0: number, a1: number, componentData?: StrokeCountMap[]) {\r\n    this.numStroke = numStroke;\r\n    this.curveLength = curveLength;\r\n    this.a0 = a0;\r\n    this.a1 = a1;\r\n    this.componentData = componentData;\r\n  }\r\n  /**\r\n   * Create a `StrokeCountMap` with curve primitive and optional componentData array.\r\n   * @param primitive\r\n   * @param numStroke\r\n   * @param curveLength\r\n   * @param a0\r\n   * @param a1\r\n   * @param componentData\r\n   */\r\n  public static createWithCurvePrimitive(primitive: CurvePrimitive, numStroke: number, curveLength: number, a0: number, a1: number, componentData?: StrokeCountMap[]) {\r\n    const result = new StrokeCountMap(numStroke, curveLength, a0, a1, componentData);\r\n    result.primitive = primitive;\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a `StrokeCountMap` with `componentIndex` (but no primitive or componentData array)\r\n   * @param index\r\n   * @param numStroke\r\n   * @param curveLength\r\n   * @param a0\r\n   * @param a1\r\n   */\r\n  public static createWithComponentIndex(componentIndex: number = 0, numStroke: number = 0, curveLength: number = 0, a0: number = 0, a1: number = 0) {\r\n    const result = new StrokeCountMap(numStroke, curveLength, a0, a1);\r\n    result.componentIndex = componentIndex;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * create a StrokeCountMap, optionally\r\n   * * (a) use parent a1 as new a0\r\n   * * (b) attach a (usually empty) array for component counts.\r\n   * @param parentMap optional map whose a1 becomes a0 in the new map.\r\n   * @param componentData optional array of component StrokeCountMaps.\r\n   */\r\n  public static createWithCurvePrimitiveAndOptionalParent(curvePrimitive: CurvePrimitive, parentMap?: StrokeCountMap, componentData?: StrokeCountMap[]): StrokeCountMap {\r\n    const a0 = parentMap ? parentMap.a1 : 0.0;\r\n    const result = new StrokeCountMap(0, 0, a0, a0, componentData);\r\n    result.primitive = curvePrimitive;\r\n    return result;\r\n\r\n  }\r\n  /**\r\n   * Apply stroke count and curve length from a component to a parent map.\r\n   * If componentData is present, install the new count and length with distance limits\r\n   * @param parentMap map to be updated.\r\n   * @param numStroke number of strokes on new child curve\r\n   * @param curveLength curve length for new child curve.\r\n   */\r\n  public addToCountAndLength(numStroke: number, curveLength: number) {\r\n    const a2 = this.a1 + curveLength;\r\n    if (this.componentData) {\r\n      this.componentData.push(\r\n        new StrokeCountMap(numStroke, curveLength, this.a1, a2));\r\n    }\r\n    this.numStroke += numStroke;\r\n    this.curveLength += curveLength;\r\n    this.a1 = a2;\r\n  }\r\n  /** return true if `other` has the same component structure as `this`\r\n   * * testing recurses through corresponding members of componentData arrays.\r\n   */\r\n  public isCompatibleComponentStructure(other: StrokeCountMap, enforceCounts: boolean): boolean {\r\n    if (enforceCounts && this.numStroke !== other.numStroke)\r\n      return false;\r\n    if (this.componentData === undefined && other.componentData === undefined)\r\n      return true;\r\n    if (this.componentData && other.componentData) {\r\n      // both have components. Recurse . . ..\r\n      if (this.componentData.length !== other.componentData.length)\r\n        return false;\r\n      const n = this.componentData.length;\r\n      for (let i = 0; i < n; i++)\r\n        if (!this.componentData[i].isCompatibleComponentStructure(other.componentData[i], enforceCounts))\r\n          return false;\r\n      return true;\r\n    }\r\n    // one has componentData, the other not.\r\n    return false;\r\n  }\r\n  /**\r\n   * * clone all data from root.\r\n   * * clone componentData arrays recursively.\r\n   */\r\n  public clone(): StrokeCountMap {\r\n    const a = new StrokeCountMap(this.numStroke, this.curveLength, this.a0, this.a1);\r\n    if (this.componentData) {\r\n      a.componentData = [];\r\n      for (const child of this.componentData)\r\n        a.componentData.push(child.clone());\r\n    }\r\n    return a;\r\n  }\r\n  /**\r\n   * interpolate in the a0,a1 mapping.\r\n   * @param fraction fractional position between a0 and a1\r\n   */\r\n  public fractionToA(fraction: number) {\r\n    return Geometry.interpolate(this.a0, fraction, this.a1);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\n// import { Geometry, Angle, AngleSweep } from \"../Geometry\";\r\n\r\nimport { MomentData } from \"../geometry4d/MomentData\";\r\nimport { NullGeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { Arc3d } from \"./Arc3d\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { Loop } from \"./Loop\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\r\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\r\nimport { TransitionSpiral3d } from \"./TransitionSpiral\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { ParityRegion } from \"./ParityRegion\";\r\nimport { UnionRegion } from \"./UnionRegion\";\r\n/**\r\n * Implementation class for computing XY area moments.\r\n * @internal\r\n */\r\nexport class RegionMomentsXY extends NullGeometryHandler {\r\n  private _activeMomentData?: MomentData;\r\n  private _point0 = Point3d.create();\r\n  private _point1 = Point3d.create();\r\n\r\n  /** Accumulate (independent) integrations over\r\n   * * origin to chord of the arc.\r\n   * * origin to the \"cap\" between the chord and arc.\r\n   */\r\n  public handleArc3d(arc: Arc3d): void {\r\n    const momentData = this._activeMomentData!;\r\n    const sweepRadians = arc.sweep.sweepRadians;\r\n    const alphaRadians = sweepRadians * 0.5;\r\n    // from https://apps.dtic.mil/dtic/tr/fulltext/u2/274936.pdf page 71  for radius = 1\r\n    let s = Math.sin(alphaRadians);\r\n    let c = Math.cos(alphaRadians);\r\n    let s1 = Math.sin(sweepRadians);\r\n    if (Angle.isFullCircleRadians(sweepRadians)) {\r\n      s = 0.0;\r\n      c = -1.0;\r\n      s1 = 0.0;\r\n    }\r\n    const q = 2 * s * s * s * c / (alphaRadians - s * c);\r\n    const s3 = s * s * s;\r\n    const s6 = s3 * s3;\r\n    const area = 0.5 * (sweepRadians - s1);\r\n    const inertiaXX = 0.25 * area * (1.0 - q / 3.0);\r\n    const inertiaYY1 = 0.25 * area * (1.0 + q);\r\n    const inertiaYY = inertiaYY1 - 4.0 * s6 / (9.0 * area);\r\n    const productXX = inertiaYY;\r\n    const productYY = inertiaXX;\r\n    const centerToCentroid = 4.0 * s * s * s / (3.0 * (sweepRadians - s1));\r\n    const midRadians = arc.sweep.fractionToRadians(0.5);\r\n    const centralPlane = arc.radiansToRotatedBasis(midRadians);\r\n    const centroid = centralPlane.origin.plusScaled(centralPlane.vectorU, centerToCentroid);\r\n    momentData.accumulateXYProductsInCentroidalFrame(productXX, 0.0, productYY, area, centroid, centralPlane.vectorU, centralPlane.vectorV);\r\n    const pointB = arc.fractionToPoint(0.0);\r\n    const pointC = arc.fractionToPoint(1.0);\r\n    momentData.accumulateTriangleMomentsXY(undefined, pointB, pointC);\r\n  }\r\n\r\n  /** Accumulate integrals over the (triangular) areas from the origin to each line segment */\r\n  public handleLineString3d(ls: LineString3d): void {\r\n    const momentData = this._activeMomentData!;\r\n    momentData.accumulateTriangleToLineStringMomentsXY(undefined, ls.packedPoints);\r\n  }\r\n  /** Accumulate integrals over the (triangular) area from the origin to this line segment */\r\n  public handleLineSegment3d(segment: LineSegment3d): void {\r\n    const momentData = this._activeMomentData!;\r\n    segment.startPoint(this._point0);\r\n    segment.endPoint(this._point1);\r\n    momentData.accumulateTriangleMomentsXY(undefined, this._point0, this._point1);\r\n  }\r\n  /** Accumulate integrals from origin to all primitives in the chain. */\r\n  public handleLoop(loop: Loop): MomentData | undefined {\r\n    const momentData = this._activeMomentData = MomentData.create();\r\n    momentData.needOrigin = false;\r\n    for (const child of loop.children)\r\n      child.dispatchToGeometryHandler(this);\r\n    this._activeMomentData = undefined;\r\n    return momentData;\r\n  }\r\n  /**\r\n   * ASSUMPTIONS FOR ORIENTATION AND CONTAINMENT ISSUES\r\n   * * Largest area is outer\r\n   * * All others are interior (and not overlapping)\r\n   * Hence\r\n   * * Outer area sign must be positive -- negate all integrations as needed\r\n   * * Outer area signs must be positive -- negate all integrations as needed\r\n   * @param region\r\n   */\r\n  public handleParityRegion(region: ParityRegion): MomentData | undefined {\r\n    const allChildMoments: MomentData[] = [];\r\n    let maxAbsArea = 0.0;\r\n    let largestChildMoments: MomentData | undefined;\r\n    for (const child of region.children) {\r\n      if (child instanceof Loop) {\r\n        const childMoments = this.handleLoop(child);\r\n        if (childMoments) {\r\n          allChildMoments.push(childMoments);\r\n          const q = Math.abs(childMoments.quantitySum);\r\n          if (q > maxAbsArea) {\r\n            maxAbsArea = q;\r\n            largestChildMoments = childMoments;\r\n          }\r\n\r\n        }\r\n      }\r\n    }\r\n    if (largestChildMoments) {\r\n      const summedMoments = MomentData.create();\r\n      const sign0 = largestChildMoments.signFactor(1.0);\r\n      summedMoments.accumulateProducts(largestChildMoments, sign0);\r\n      for (const childMoments of allChildMoments) {\r\n        if (childMoments !== largestChildMoments) {\r\n          const sign1 = childMoments.signFactor(-1.0);\r\n          summedMoments.accumulateProducts(childMoments, sign1);\r\n        }\r\n      }\r\n      return summedMoments;\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Accumulate (as simple addition) products over each component of the union region. */\r\n  public handleUnionRegion(region: UnionRegion): MomentData | undefined {\r\n    const summedMoments = MomentData.create();\r\n    for (const child of region.children) {\r\n      const childMoments = child.dispatchToGeometryHandler(this);\r\n      if (childMoments) {\r\n        const sign0 = childMoments.signFactor(1.0);\r\n        summedMoments.accumulateProducts(childMoments, sign0);\r\n      }\r\n    }\r\n    return summedMoments;\r\n  }\r\n\r\n  private _strokeOptions?: StrokeOptions;\r\n  private getStrokeOptions(): StrokeOptions {\r\n    if (this._strokeOptions)\r\n      return this._strokeOptions;\r\n    const options = StrokeOptions.createForCurves();\r\n    // this is unusually fine for stroking, but appropriate for sum.\r\n    options.angleTol = Angle.createDegrees(5.0);\r\n    this._strokeOptions = options;\r\n    return options;\r\n  }\r\n  /** Single curve primitive (not loop . . .).\r\n   * * stroke the curve\r\n   * * accumulate stroke array.\r\n   */\r\n  public handleCurvePrimitive(cp: CurvePrimitive) {\r\n    const strokes = LineString3d.create();\r\n    const options = this.getStrokeOptions();\r\n    cp.emitStrokes(strokes, options);\r\n    this.handleLineString3d(strokes);\r\n  }\r\n  /** handle strongly typed  BSplineCurve3d  as generic curve primitive */\r\n  public handleBSplineCurve3d(g: BSplineCurve3d) { return this.handleCurvePrimitive(g); }\r\n  /** handle strongly typed  BSplineCurve3dH  as generic curve primitive */\r\n  public handleBSplineCurve3dH(g: BSplineCurve3dH) { return this.handleCurvePrimitive(g); }\r\n  /** handle strongly typed  TransitionSpiral as generic curve primitive  */\r\n  public handleTransitionSpiral(g: TransitionSpiral3d) { return this.handleCurvePrimitive(g); }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { AnyRegion, AnyCurve } from \"./CurveChain\";\r\nimport { MomentData } from \"../geometry4d/MomentData\";\r\nimport { RegionMomentsXY } from \"./RegionMomentsXY\";\r\nimport { HalfEdgeGraph, HalfEdge, HalfEdgeMask } from \"../topology/Graph\";\r\nimport { Triangulator, MultiLineStringDataVariant, LineStringDataVariant } from \"../topology/Triangulation\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\r\nimport { RegularizationContext } from \"../topology/RegularizeFace\";\r\nimport { HalfEdgeGraphMerge } from \"../topology/Merging\";\r\nimport { HalfEdgeGraphSearch } from \"../topology/HalfEdgeGraphSearch\";\r\nimport { Polyface } from \"../polyface/Polyface\";\r\nimport { PolyfaceBuilder } from \"../polyface/PolyfaceBuilder\";\r\nimport { PolygonWireOffsetContext, JointOptions, CurveChainWireOffsetContext } from \"./PolygonOffsetContext\";\r\nimport { CurveCollection, BagOfCurves, CurveChain, ConsolidateAdjacentCurvePrimitivesOptions } from \"./CurveCollection\";\r\nimport { CurveWireMomentsXYZ } from \"./CurveWireMomentsXYZ\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { Loop } from \"./Loop\";\r\nimport { Path } from \"./Path\";\r\nimport { PointInOnOutContext } from \"./Query/InOutTests\";\r\nimport { CurveSplitContext } from \"./Query/CurveSplitContext\";\r\nimport { ChainCollectorContext } from \"./ChainCollectorContext\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Point3dArrayCarrier } from \"../geometry3d/Point3dArrayCarrier\";\r\nimport { PolylineCompressionContext } from \"../geometry3d/PolylineCompressionByEdgeOffset\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { ConsolidateAdjacentCurvePrimitivesContext } from \"./Query/ConsolidateAdjacentPrimitivesContext\";\r\n/**\r\n * * `properties` is a string with special characters indicating\r\n *   * \"U\" -- contains unmerged stick data\r\n *   * \"M\" -- merged\r\n *   * \"R\" -- regularized\r\n *   * \"X\" -- has exterior markup\r\n * @internal\r\n */\r\nexport type GraphCheckPointFunction = (name: string, graph: HalfEdgeGraph, properties: string, extraData?: any) => any;\r\n\r\n/**\r\n * base class for callbacks during region sweeps.\r\n * * At start of a component, `startComponent(node)` is called announcing a representative node on the outermost face.\r\n *   * A Component in this usage is a component that is edge connected when ignoring \"exterior bridge edges\".\r\n * * As each face is entered, `enterFace(facePathStack, newFaceNode)` is called\r\n *   * facePathStack[0] is the outermost node of the path from the outer face.\r\n *   * facePathStack[1] is its inside mate.\r\n *   * facePathStack[2k] is the outside node at crossing to face at depth k.\r\n *   * facePathStack[2k+1] is the node where face at depth k was entered.\r\n *   * newFaceNode is the entry node (redundant of stack tip)\r\n *  * On retreat from a face, `leaveFace(facePathStack, faceNode)` is called.\r\n *  * At end of component, `finishComponent (node)` is called.\r\n * * The base class is fully implemented to do nothing during the sweep.\r\n */\r\nabstract class RegionOpsFaceToFaceSearchCallbacks {\r\n  /** Announce a representative node on the outer face of a component */\r\n  public startComponent(_node: HalfEdge): boolean { return true; }\r\n  /** Announce return to outer face */\r\n  public finishComponent(_node: HalfEdge): boolean { return true; }\r\n  /** Announce face entry */\r\n  public enterFace(_facePathStack: HalfEdge[], _newFaceNode: HalfEdge): boolean { return true; }\r\n  /** Announce face exit */\r\n  public leaveFace(_facePathStack: HalfEdge[], _newFaceNode: HalfEdge): boolean { return true; }\r\n}\r\n/** Function signature to test if a pair of boolean states is to be accepted by area booleans (during face-to-face sweeps) */\r\ntype BinaryBooleanAcceptFunction = (stateA: boolean, stateB: boolean) => boolean;\r\n/**\r\n * Implementations of `RegionOpsFaceToFaceSearchCallbacks` for binary boolean sweep.\r\n * * This assumes the each node in the graph has edgeTag set to:\r\n *   * `edgeTag === undefined` if the edge crossing the edge does not change classification.\r\n *     * for example, an edge added by regularization\r\n *   * `edgeTag === 1` if this is a boundary for the first of the boolean input regions\r\n *   * `edgeTag === 2` if this is a boundary for the first of the boolean input regions\r\n * * constructor\r\n *    * takes caller-supplied function to decide whether to accept a face given its state relative to the two boolean terms.\r\n *    * sets the in/out status of both terms to false.\r\n * * `startComponent` marks the entire outer face as `EXTERIOR`\r\n * * `enterFace`\r\n *    * if this is a bounding edge (according to `node.faceTag`) toggle the in/out status if this boolean term.\r\n *    * ask the faceAcceptFunction if the current term states combine to in/out for the result\r\n *    * if out, set the `EXTERIOR` mask around the face.\r\n * * `leaveFace`\r\n *    * if this is a bounding edge (according to `node.faceTag`) toggle the in/out status if this boolean term.\r\n * * `finishComponent` is not reimplemented.\r\n */\r\nclass RegionOpsBooleanSweepCallbacks extends RegionOpsFaceToFaceSearchCallbacks {\r\n  private _faceSelectFunction: BinaryBooleanAcceptFunction;\r\n  private _inComponent: boolean[];\r\n  private _exteriorMask: HalfEdgeMask;\r\n  public constructor(acceptFaceFunction: BinaryBooleanAcceptFunction, exteriorMask: HalfEdgeMask) {\r\n    super();\r\n    this._inComponent = [false, false, false]; // entry 0 is never reused.\r\n    this._exteriorMask = exteriorMask;\r\n    this._faceSelectFunction = acceptFaceFunction;\r\n  }\r\n  /** Mark this face as exterior */\r\n  public startComponent(node: HalfEdge): boolean { node.setMaskAroundFace(this._exteriorMask); return true; }\r\n  /**\r\n   * * If necessary, toggle a term state.\r\n   * * if indicated, mark this face exterior.\r\n   */\r\n  public enterFace(_facePathStack: HalfEdge[], node: HalfEdge): boolean {\r\n    const thisFaceIndex = node.edgeTag;\r\n    if (node.edgeTag === 1 || node.edgeTag === 2) this._inComponent[thisFaceIndex] = !this._inComponent[thisFaceIndex];\r\n    if (!this._faceSelectFunction(this._inComponent[1], this._inComponent[2]))\r\n      node.setMaskAroundFace(this._exteriorMask);\r\n\r\n    return true;\r\n  }\r\n  /**\r\n   * * If necessary, toggle a term state.\r\n   */\r\n  public leaveFace(_facePathStack: HalfEdge[], node: HalfEdge): boolean {\r\n    const thisFaceIndex = node.edgeTag;\r\n    if (node.edgeTag === 1 || node.edgeTag === 2) this._inComponent[thisFaceIndex] = !this._inComponent[thisFaceIndex];\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * run a DFS with face-to-face step announcements.\r\n * * false return from any function terminates search immediately.\r\n * * all reachable nodes assumed to have both visit masks clear.\r\n * @param graph containing graph.\r\n * @param seed first node to visit.\r\n * @param faceHasBeenVisited mask marking faces that have been seen.\r\n * @param nodeHasBeenVisited mask marking node-to-node step around face.\r\n *\r\n */\r\nfunction faceToFaceSearchFromOuterLoop(_graph: HalfEdgeGraph,\r\n  seed: HalfEdge,\r\n  faceHasBeenVisited: HalfEdgeMask,\r\n  nodeHasBeenVisited: HalfEdgeMask,\r\n  callbacks: RegionOpsFaceToFaceSearchCallbacks) {\r\n  if (seed.isMaskSet(faceHasBeenVisited))\r\n    return;\r\n  if (!callbacks.startComponent(seed))\r\n    return;\r\n\r\n  const facePathStack = [];\r\n  seed.setMaskAroundFace(faceHasBeenVisited);\r\n  let faceWalker = seed;\r\n  do {\r\n    let entryNode = faceWalker;\r\n    let mate = faceWalker.edgeMate;\r\n    if (!mate.isMaskSet(faceHasBeenVisited)) {\r\n\r\n      // the faceWalker seed is always on the base of the stack.\r\n      // the stack then contains even-odd pairs of (entryNode, currentNode)\r\n      // * entryNode is the node where a face was entered.\r\n      // * faceNode is another node around that face.\r\n\r\n      facePathStack.push(faceWalker);\r\n      facePathStack.push(mate);\r\n      let faceNode = mate.faceSuccessor;\r\n      mate.setMaskAroundFace(faceHasBeenVisited);\r\n      if (callbacks.enterFace(facePathStack, mate)) {\r\n        for (; ;) {\r\n          mate = faceNode.edgeMate;\r\n          if (!mate.isMaskSet(faceHasBeenVisited)) {\r\n            mate.setMaskAroundFace(faceHasBeenVisited);\r\n            if (!callbacks.enterFace(facePathStack, mate))\r\n              return;\r\n            facePathStack.push(faceNode);\r\n            facePathStack.push(mate);\r\n            faceNode = mate;\r\n            entryNode = mate;\r\n          }\r\n          faceNode.setMask(nodeHasBeenVisited);\r\n          faceNode = faceNode.faceSuccessor;\r\n          if (faceNode === entryNode) {\r\n            callbacks.leaveFace(facePathStack, faceNode);\r\n            if (facePathStack.length <= 2) {\r\n              break;\r\n            }\r\n            facePathStack.pop();\r\n            faceNode = facePathStack[facePathStack.length - 1];\r\n            facePathStack.pop();\r\n            entryNode = facePathStack[facePathStack.length - 1];\r\n          }\r\n          if (faceNode.isMaskSet(nodeHasBeenVisited)) {\r\n            // this is disaster !!!\r\n            return;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // continue at outermost level .....\r\n    faceWalker = faceWalker.faceSuccessor;\r\n  }\r\n  while (faceWalker !== seed);\r\n\r\n  callbacks.finishComponent(seed);\r\n}\r\n/** Complete multi-step process for polygon binary booleans starting with arrays of coordinates.\r\n * * Each of the binary input terms is a collection of loops\r\n *   * Within the binary term, in/out is determined by edge-crossing parity rules.\r\n * * Processing steps are\r\n *   * Build the loops for each set.\r\n *      * Each edge labeled with 1 or 2 as binary term identifier.\r\n *   * find crossings among the edges.\r\n *      * Edges are split as needed, but split preserves the edgeTag\r\n *   * sort edges around vertices\r\n *   * add regularization edges so holes are connected to their parent.\r\n */\r\nfunction doPolygonBoolean(loopsA: MultiLineStringDataVariant, loopsB: MultiLineStringDataVariant, faceSelectFunction: (inA: boolean, inB: boolean) => boolean, graphCheckPoint?: GraphCheckPointFunction): Polyface | undefined {\r\n  const graph = new HalfEdgeGraph();\r\n  const baseMask = HalfEdgeMask.BOUNDARY_EDGE | HalfEdgeMask.PRIMARY_EDGE;\r\n  const seedA = RegionOps.addLoopsWithEdgeTagToGraph(graph, loopsA, baseMask, 1);\r\n  const seedB = RegionOps.addLoopsWithEdgeTagToGraph(graph, loopsB, baseMask, 2);\r\n  if (graphCheckPoint)\r\n    graphCheckPoint(\"unmerged loops\", graph, \"U\");\r\n  if (seedA && seedB) {\r\n    // split edges where they cross . . .\r\n    HalfEdgeGraphMerge.splitIntersectingEdges(graph);\r\n    if (graphCheckPoint)\r\n      graphCheckPoint(\"After splitIntersectingEdges\", graph, \"U\");\r\n    // sort radially around vertices.\r\n    HalfEdgeGraphMerge.clusterAndMergeXYTheta(graph);\r\n    if (graphCheckPoint)\r\n      graphCheckPoint(\"After clusterAndMergeXYTheta\", graph, \"M\");\r\n    // add edges to connect various components  (e.g. holes!!!)\r\n    const context = new RegularizationContext(graph);\r\n    context.regularizeGraph(true, true);\r\n    if (graphCheckPoint)\r\n      graphCheckPoint(\"After regularize\", graph, \"MR\");\r\n    const exteriorHalfEdge = HalfEdgeGraphSearch.findMinimumAreaFace(graph);\r\n    const exteriorMask = HalfEdgeMask.EXTERIOR;\r\n    const faceVisitedMask = graph.grabMask();\r\n\r\n    const nodeVisitedMask = graph.grabMask();\r\n    const allMasksToClear = exteriorMask | faceVisitedMask | nodeVisitedMask;\r\n    graph.clearMask(allMasksToClear);\r\n    const callbacks = new RegionOpsBooleanSweepCallbacks(faceSelectFunction, exteriorMask);\r\n    faceToFaceSearchFromOuterLoop(graph,\r\n      exteriorHalfEdge,\r\n      faceVisitedMask,\r\n      nodeVisitedMask,\r\n      callbacks);\r\n    if (graphCheckPoint)\r\n      graphCheckPoint(\"After faceToFaceSearchFromOuterLoop\", graph, \"MRX\");\r\n    graph.dropMask(faceVisitedMask);\r\n    graph.dropMask(nodeVisitedMask);\r\n    return PolyfaceBuilder.graphToPolyface(graph);\r\n  }\r\n  return undefined;\r\n}\r\n\r\n/**\r\n * class `RegionOps` has static members for calculations on regions (areas).\r\n * * Regions are represented by these `CurveCollection` subclasses:\r\n * * `Loop` -- a single loop\r\n * * `ParityRegion` -- a collection of loops, interpreted by parity rules.\r\n *    * The common \"One outer loop and many Inner loops\" is a parity region.\r\n * * `UnionRegion` -- a collection of `Loop` and `ParityRegion` objects understood as a (probably disjoint) union.\r\n * @beta\r\n */\r\nexport class RegionOps {\r\n  /**\r\n   * Return moment sums for a loop, parity region, or union region.\r\n   * * If `rawMomentData` is the MomentData returned by computeXYAreaMoments, convert to principal axes and moments with\r\n   *    call `principalMomentData = MomentData.inertiaProductsToPrincipalAxes (rawMomentData.origin, rawMomentData.sums);`\r\n   * @param root any Loop, ParityRegion, or UnionRegion.\r\n   */\r\n  public static computeXYAreaMoments(root: AnyRegion): MomentData | undefined {\r\n    const handler = new RegionMomentsXY();\r\n    const result = root.dispatchToGeometryHandler(handler);\r\n    if (result instanceof MomentData) {\r\n      result.shiftOriginAndSumsToCentroidOfSums();\r\n      return result;\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return MomentData with the sums of wire moments.\r\n   * * If `rawMomentData` is the MomentData returned by computeXYAreaMoments, convert to principal axes and moments with\r\n   *    call `principalMomentData = MomentData.inertiaProductsToPrincipalAxes (rawMomentData.origin, rawMomentData.sums);`\r\n   */\r\n  public static computeXYZWireMomentSums(root: AnyCurve): MomentData | undefined {\r\n    const handler = new CurveWireMomentsXYZ();\r\n    handler.visitLeaves(root);\r\n    const result = handler.momentData;\r\n    result.shiftOriginAndSumsToCentroidOfSums();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * * create loops in the graph.\r\n   * @internal\r\n   */\r\n  public static addLoopsToGraph(graph: HalfEdgeGraph, data: MultiLineStringDataVariant, announceIsolatedLoop: (graph: HalfEdgeGraph, seed: HalfEdge) => void) {\r\n    if (data instanceof IndexedXYZCollection) {\r\n      const loopSeed = Triangulator.directCreateFaceLoopFromCoordinates(graph, data as IndexedXYZCollection);\r\n      if (loopSeed !== undefined)\r\n        announceIsolatedLoop(graph, loopSeed);\r\n    } else if (Array.isArray(data)) {\r\n      if (data.length > 0) {\r\n        if (Point3d.isXAndY(data[0])) {\r\n          const loopSeed = Triangulator.directCreateFaceLoopFromCoordinates(graph, data as LineStringDataVariant);\r\n          if (loopSeed !== undefined)\r\n            announceIsolatedLoop(graph, loopSeed);\r\n\r\n        } else if (data[0] instanceof IndexedXYZCollection) {\r\n          for (const loop of data) {\r\n            const loopSeed = Triangulator.directCreateFaceLoopFromCoordinates(graph, loop as IndexedXYZCollection);\r\n            if (loopSeed !== undefined)\r\n              announceIsolatedLoop(graph, loopSeed);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /** Add multiple loops to a graph.\r\n   * * Apply edgeTag and mask to each edge.\r\n   * @internal\r\n   */\r\n  public static addLoopsWithEdgeTagToGraph(graph: HalfEdgeGraph, data: MultiLineStringDataVariant, mask: HalfEdgeMask, edgeTag: any): HalfEdge[] | undefined {\r\n    const loopSeeds: HalfEdge[] = [];\r\n    this.addLoopsToGraph(graph, data, (_graph: HalfEdgeGraph, seed: HalfEdge) => {\r\n      if (seed) {\r\n        loopSeeds.push(seed);\r\n        seed.setMaskAndEdgeTagAroundFace(mask, edgeTag, true);\r\n      }\r\n    });\r\n    if (loopSeeds.length > 0)\r\n      return loopSeeds;\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * return a polyface containing the area union of two XY regions.\r\n   * * Within each region, in and out is determined by parity rules.\r\n   *   * Any face that is an odd number of crossings from the far outside is IN\r\n   *   * Any face that is an even number of crossings from the far outside is OUT\r\n   * @param loopsA first set of loops\r\n   * @param loopsB second set of loops\r\n   */\r\n  public static polygonXYAreaIntersectLoopsToPolyface(loopsA: MultiLineStringDataVariant, loopsB: MultiLineStringDataVariant): Polyface | undefined {\r\n    return doPolygonBoolean(loopsA, loopsB,\r\n      (inA: boolean, inB: boolean) => (inA && inB),\r\n      this._graphCheckPointFunction);\r\n  }\r\n\r\n  /**\r\n   * return a polyface containing the area intersection of two XY regions.\r\n   * * Within each region, in and out is determined by parity rules.\r\n   *   * Any face that is an odd number of crossings from the far outside is IN\r\n   *   * Any face that is an even number of crossings from the far outside is OUT\r\n   * @param loopsA first set of loops\r\n   * @param loopsB second set of loops\r\n   */\r\n  public static polygonXYAreaUnionLoopsToPolyface(loopsA: MultiLineStringDataVariant, loopsB: MultiLineStringDataVariant): Polyface | undefined {\r\n    return doPolygonBoolean(loopsA, loopsB,\r\n      (inA: boolean, inB: boolean) => (inA || inB),\r\n      this._graphCheckPointFunction);\r\n  }\r\n  /**\r\n   * return a polyface containing the area difference of two XY regions.\r\n   * * Within each region, in and out is determined by parity rules.\r\n   *   * Any face that is an odd number of crossings from the far outside is IN\r\n   *   * Any face that is an even number of crossings from the far outside is OUT\r\n   * @param loopsA first set of loops\r\n   * @param loopsB second set of loops\r\n   */\r\n  public static polygonXYAreaDifferenceLoopsToPolyface(loopsA: MultiLineStringDataVariant, loopsB: MultiLineStringDataVariant): Polyface | undefined {\r\n    return doPolygonBoolean(loopsA, loopsB,\r\n      (inA: boolean, inB: boolean) => (inA && !inB),\r\n      this._graphCheckPointFunction);\r\n  }\r\n\r\n  /** Construct a wire (not area!!) that is offset from given polyline or polygon.\r\n   * * This is a simple wire offset, not an area.\r\n   * * The construction algorithm attempts to eliminate some self-intersections within the offsets, but does not guarantee a simple area offset.\r\n   * * The construction algorithm is subject to being changed, resulting in different (hopefully better) self-intersection behavior on the future.\r\n   * @param points a single loop or path\r\n   * @param wrap true to include wraparound\r\n   * @param offsetDistance distance of offset from wire.  Positive is left.\r\n   * @beta\r\n   */\r\n  public static constructPolygonWireXYOffset(points: Point3d[], wrap: boolean, offsetDistance: number): CurveCollection | undefined {\r\n    const context = new PolygonWireOffsetContext();\r\n    return context.constructPolygonWireXYOffset(points, wrap, offsetDistance);\r\n  }\r\n  /**\r\n   * Construct curves that are offset from a Path or Loop\r\n   * * The construction will remove \"some\" local effects of features smaller than the offset distance, but will not detect self intersection among widely separated edges.\r\n   * * Offset distance is defined as positive to the left.\r\n   * * If offsetDistanceOrOptions is given as a number, default options are applied.\r\n   * * When the offset needs to do an \"outside\" turn, the first applicable construction is applied:\r\n   *   * If the turn is larger than `options.minArcDegrees`, a circular arc is constructed.\r\n   *   * if the turn is larger than `options.maxChamferDegrees`, the turn is constructed as a sequence of straight lines that are\r\n   *      * outside the arc\r\n   *      * have uniform turn angle less than `options.maxChamferDegrees`\r\n   *      * each line segment (except first and last) touches the arc at its midpoint.\r\n   *   * Otherwise the prior and successor curves are extended to simple intersection.\r\n   * @param curves input curves\r\n   * @param offsetDistanceOrOptions offset controls.\r\n   */\r\n  public static constructCurveXYOffset(curves: Path | Loop, offsetDistanceOrOptions: number | JointOptions): CurveCollection | undefined {\r\n    const options = JointOptions.create(offsetDistanceOrOptions);\r\n    return CurveChainWireOffsetContext.constructCurveXYOffset(curves, options);\r\n  }\r\n  /**\r\n   * Test if point (x,y) is IN, OUT or ON a polygon.\r\n   * @return (1) for in, (-1) for OUT, (0) for ON\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param points array of xy coordinates.\r\n   */\r\n  public static testPointInOnOutRegionXY(curves: AnyRegion, x: number, y: number): number {\r\n    return PointInOnOutContext.testPointInOnOutRegionXY(curves, x, y);\r\n  }\r\n  /** Create curve collection of subtype determined by gaps between the input curves.\r\n   * * If (a) wrap is requested and (b) all curves connect head-to-tail (including wraparound), assemble as a `loop`.\r\n   * * If all curves connect head-to-tail except for closure, return a `Path`.\r\n   * * If there are internal gaps, return a `BagOfCurves`\r\n   * * If input array has zero length, return undefined.\r\n   */\r\n  public static createLoopPathOrBagOfCurves(curves: CurvePrimitive[], wrap: boolean = true): CurveCollection | undefined {\r\n    const n = curves.length;\r\n    if (n === 0)\r\n      return undefined;\r\n    let maxGap = 0.0;\r\n    if (wrap)\r\n      maxGap = Geometry.maxXY(maxGap, curves[0].startPoint().distance(curves[n - 1].endPoint()));\r\n    for (let i = 0; i + 1 < n; i++)\r\n      maxGap = Geometry.maxXY(maxGap, curves[i].endPoint().distance(curves[i + 1].startPoint()));\r\n    let collection: Loop | Path | BagOfCurves;\r\n    if (Geometry.isSmallMetricDistance(maxGap)) {\r\n      collection = wrap ? Loop.create() : Path.create();\r\n    } else {\r\n      collection = BagOfCurves.create();\r\n    }\r\n    for (const c of curves)\r\n      collection.tryAddChild(c);\r\n    return collection;\r\n  }\r\n\r\n  private static _graphCheckPointFunction?: GraphCheckPointFunction;\r\n  /**\r\n   * Announce Checkpoint function for use during booleans\r\n   * @internal\r\n   */\r\n  public static setCheckPointFunction(f?: GraphCheckPointFunction) { this._graphCheckPointFunction = f; }\r\n  /**\r\n   * * Find all intersections among curves in `curvesToCut` and `cutterCurves`\r\n   * * Return fragments of `curvesToCut`.\r\n   * * For a  `Loop`, `ParityRegion`, or `UnionRegion` in `curvesToCut`\r\n   *    * if it is never cut by any `cutter` curve, it will be left unchanged.\r\n   *    * if cut, the input is downgraded to a set of `Path` curves joining at the cut points.\r\n   * * All cutting is \"as viewed in the xy plane\"\r\n   */\r\n  public static cloneCurvesWithXYSplitFlags(curvesToCut: CurvePrimitive | CurveCollection | undefined, cutterCurves: CurveCollection): CurveCollection | CurvePrimitive | undefined {\r\n    return CurveSplitContext.cloneCurvesWithXYSplitFlags(curvesToCut, cutterCurves);\r\n\r\n  }\r\n  /**\r\n   * Create paths assembled from many curves.\r\n   * * Assemble consecutive curves NOT separated by either end flags or gaps into paths.\r\n   * * Return simplest form -- single primitive, single path, or bag of curves.\r\n   * @param curves\r\n   */\r\n  public static splitToPathsBetweenFlagBreaks(source: CurveCollection | CurvePrimitive | undefined,\r\n    makeClones: boolean): BagOfCurves | Path | CurvePrimitive | undefined {\r\n    if (source === undefined)\r\n      return undefined;\r\n    if (source instanceof CurvePrimitive)\r\n      return source;\r\n    // source is a collection .  ..\r\n    const primitives = source.collectCurvePrimitives();\r\n    const chainCollector = new ChainCollectorContext(makeClones);\r\n    for (const primitive of primitives) {\r\n      chainCollector.announceCurvePrimitive(primitive);\r\n    }\r\n    return chainCollector.grabResult();\r\n  }\r\n  /**\r\n   * * Find intersections of `curvesToCut` with boundaries of `region`.\r\n   * * Break `curvesToCut` into parts inside, outside, and coincident.\r\n   * * Return all fragments, split among `insideParts`, `outsideParts`, and `coincidentParts` in the output object.\r\n   */\r\n  public static splitPathsByRegionInOnOutXY(curvesToCut: CurveCollection | CurvePrimitive | undefined, region: AnyRegion): { insideParts: AnyCurve[], outsideParts: AnyCurve[], coincidentParts: AnyCurve[] } {\r\n    const result = { insideParts: [], outsideParts: [], coincidentParts: [] };\r\n    const pathWithIntersectionMarkup = RegionOps.cloneCurvesWithXYSplitFlags(curvesToCut, region);\r\n    const splitPaths = RegionOps.splitToPathsBetweenFlagBreaks(pathWithIntersectionMarkup, true);\r\n    if (splitPaths instanceof CurveCollection) {\r\n      for (const child of splitPaths.children) {\r\n        const pointOnChild = CurveCollection.createCurveLocationDetailOnAnyCurvePrimitive(child);\r\n        if (pointOnChild) {\r\n          const inOnOut = RegionOps.testPointInOnOutRegionXY(region, pointOnChild.point.x, pointOnChild.point.y);\r\n          pushToInOnOutArrays(child, inOnOut, result.outsideParts, result.coincidentParts, result.insideParts);\r\n        }\r\n      }\r\n    } else if (splitPaths instanceof CurvePrimitive) {\r\n      const pointOnChild = CurveCollection.createCurveLocationDetailOnAnyCurvePrimitive(splitPaths);\r\n      if (pointOnChild) {\r\n        const inOnOut = RegionOps.testPointInOnOutRegionXY(region, pointOnChild.point.x, pointOnChild.point.y);\r\n        pushToInOnOutArrays(splitPaths, inOnOut, result.outsideParts, result.coincidentParts, result.insideParts);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Test if `data` is one of several forms of a rectangle.\r\n   * * If so, return transform with\r\n   *   * origin at one corner\r\n   *   * x and y columns extend along two adjacent sides\r\n   *   * z column is unit normal.\r\n   * * The recognized data forms for simple analysis of points are:\r\n   *   * LineString\r\n   *   * Loop containing rectangle content\r\n   *   * Path containing rectangle content\r\n   *   * Array of Point3d[]\r\n   *   * IndexedXYZCollection\r\n   * * Points are considered a rectangle if\r\n   *   * Within the first 4 points\r\n   *     * vectors from 0 to 1 and 0 to 3 are perpendicular and have a non-zero cross product\r\n   *     * vectors from 0 to 3 and 1 to 2 are the same\r\n   *  * optionally require a 5th point that closes back to point0\r\n   *  * If there are other than the basic number of points (4 or 5) the data\r\n   */\r\n  public static rectangleEdgeTransform(data: AnyCurve | Point3d[] | IndexedXYZCollection, requireClosurePoint: boolean = true): Transform | undefined {\r\n    if (data instanceof LineString3d) {\r\n      return this.rectangleEdgeTransform(data.packedPoints);\r\n    } else if (data instanceof IndexedXYZCollection) {\r\n      let dataToUse;\r\n      if (requireClosurePoint && data.length === 5) {\r\n        if (!Geometry.isSmallMetricDistance(data.distanceIndexIndex(0, 4)!))\r\n          return undefined;\r\n        dataToUse = data;\r\n      } else if (!requireClosurePoint && data.length === 4)\r\n        dataToUse = data;\r\n      else if (data.length < (requireClosurePoint ? 5 : 4)) {\r\n        return undefined;\r\n      } else {\r\n        dataToUse = GrowableXYZArray.create(data);\r\n        PolylineCompressionContext.compressInPlaceByShortEdgeLength(dataToUse, Geometry.smallMetricDistance);\r\n      }\r\n\r\n      const vector01 = dataToUse.vectorIndexIndex(0, 1)!;\r\n      const vector03 = dataToUse.vectorIndexIndex(0, 3)!;\r\n      const vector12 = dataToUse.vectorIndexIndex(1, 2)!;\r\n      const normalVector = vector01.crossProduct(vector03);\r\n      if (normalVector.normalizeInPlace()\r\n        && vector12.isAlmostEqual(vector03)\r\n        && vector01.isPerpendicularTo(vector03)) {\r\n        return Transform.createOriginAndMatrixColumns(dataToUse.getPoint3dAtUncheckedPointIndex(0), vector01, vector03, normalVector);\r\n      }\r\n    } else if (Array.isArray(data)) {\r\n      return this.rectangleEdgeTransform(new Point3dArrayCarrier(data), requireClosurePoint);\r\n    } else if (data instanceof Loop && data.children.length === 1 && data.children[0] instanceof LineString3d) {\r\n      return this.rectangleEdgeTransform((data.children[0] as LineString3d).packedPoints, true);\r\n    } else if (data instanceof Path && data.children.length === 1 && data.children[0] instanceof LineString3d) {\r\n      return this.rectangleEdgeTransform((data.children[0] as LineString3d).packedPoints, requireClosurePoint);\r\n    } else if (data instanceof CurveChain) {\r\n      if (!data.checkForNonLinearPrimitives()) {\r\n        // const linestring = LineString3d.create();\r\n        const strokes = data.getPackedStrokes();\r\n        if (strokes) {\r\n          return this.rectangleEdgeTransform(strokes);\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Look for and simplify:\r\n   * * Contiguous `LineSegment3d` and `LineString3d` objects.\r\n   *   * collect all points\r\n   *   * eliminate duplicated points\r\n   *   * eliminate points colinear with surrounding points.\r\n   *  * Contigous concentric circular or elliptic arcs\r\n   *   * combine angular ranges\r\n   * @param curves Path or loop (or larger collection containing paths and loops) to be simplified\r\n   * @param options options for tolerance and selective simplification.\r\n   */\r\n  public static consolidateAdjacentPrimitives(curves: CurveCollection, options?: ConsolidateAdjacentCurvePrimitivesOptions) {\r\n    const context = new ConsolidateAdjacentCurvePrimitivesContext(options);\r\n    curves.dispatchToGeometryHandler(context);\r\n  }\r\n}\r\n\r\nfunction pushToInOnOutArrays(curve: AnyCurve, select: number, arrayNegative: AnyCurve[], array0: AnyCurve[], arrayPositive: AnyCurve[]) {\r\n  if (select > 0)\r\n    arrayPositive.push(curve);\r\n  else if (select < 0)\r\n    arrayNegative.push(curve);\r\n  else\r\n    array0.push(curve);\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\n/* tslint:disable:variable-name no-empty */\r\n\r\n/** tolerance blob for various stroking methods.\r\n *\r\n * * Across many applications, the critical concepts are:   chordTol, angleTol, maxEdgeLength\r\n * * Chord error is an distance measured from a curve or facet to its approximating stroke or facet.\r\n * * angle is the angle between two contiguous strokes or across a facet edge.\r\n * * maxEdgeLength is the length of a stroke or a edge of a facet.\r\n *\r\n * It is rare for all three to be active at once:\r\n * * Nearly all stroke and facet use cases will apply an angle tolerance.\r\n * * * For curves, 15 degrees is typical\r\n * * * For facets, 22.5 degrees is typical.\r\n * * * Halving the angle tolerance will (roughly) make curves get twice as many strokes, and surfaces get 4 times as many facets.\r\n * * * The angle tolerance has the useful property that its effect is independent of scale of that data.  If data is suddenly scaled into millimeters rather than meters, the facet counts remain the same.\r\n * * When creating output for devices such as 3D printing will want a chord tolerance.\r\n * * For graphics display, use an angle tolerance of around 15 degrees and an chord tolerance which is the size of several pixels.\r\n * * Analysis meshes (e.g. Finite Elements) commonly need to apply maxEdgeLength.\r\n * * * Using maxEdgeLength for graphics probably produces too many facets.   For example, it causes long cylinders to get many nearly-square facets instead of the small number of long quads usually used for graphics.\r\n * * Facet tolerances are, as the Pirates' Code, guidelines, not absolute rules.   Facet and stroke code may ignore tolerances in awkward situations.\r\n * * If multiple tolerances are in effect, the actual count will usually be based on the one that demands the most strokes or facets, unless it is so high that it violates some upper limit on the number of facets on an arc or a section of a curve.\r\n * @public\r\n */\r\nexport class StrokeOptions {\r\n\r\n  /** distance from stroke to actual geometry */\r\n  public chordTol?: number;\r\n  /** turning angle between strokes. */\r\n  public angleTol?: Angle;\r\n  /** maximum length of a single stroke. */\r\n  public maxEdgeLength?: number;\r\n  /** caller expects convex facets.  */\r\n  public needConvexFacets?: boolean;\r\n  /** minimum strokes on a primitive */\r\n  public minStrokesPerPrimitive?: number;\r\n  /** whether or not to triangulate each added facet */\r\n  public shouldTriangulate: boolean = false;\r\n  private _needNormals?: boolean;\r\n  private _needTwoSided?: boolean;\r\n  private _needParams?: boolean;\r\n  /** ask if params are requested. */\r\n  public get needParams(): boolean { return this._needParams !== undefined ? this._needParams : false; }\r\n  /** set the params request flag */\r\n  public set needParams(value: boolean) { this._needParams = value; }\r\n  /** ask if normals are requested */\r\n  public get needNormals(): boolean { return this._needNormals !== undefined ? this._needNormals : false; }\r\n  /** set the normals request flag */\r\n  public set needNormals(value: boolean) { this._needNormals = value; }\r\n  /** set request for two-sided facets. */\r\n  public set needTwoSided(value: boolean) { this._needTwoSided = value; }\r\n  /** ask if twoSided is requested. */\r\n  public get needTwoSided(): boolean { return this._needTwoSided !== undefined ? this._needTwoSided : false; }\r\n  /** optional color request flag */\r\n  public needColors?: boolean;\r\n  /** default number of strokes for a circle. */\r\n  public defaultCircleStrokes = 16;\r\n  /** ask if maxEdgeLength is specified */\r\n  public get hasMaxEdgeLength(): boolean { return this.maxEdgeLength !== undefined && this.maxEdgeLength > 0.0; }\r\n  /** return stroke count which is the larger of the minCount or count needed for edge length condition. */\r\n  public applyMaxEdgeLength(minCount: number, totalLength: number): number {\r\n    if (this.maxEdgeLength && this.maxEdgeLength > 0.0 && minCount * this.maxEdgeLength < totalLength) {\r\n      minCount = Geometry.stepCount(this.maxEdgeLength, totalLength, minCount);\r\n    }\r\n    return minCount;\r\n  }\r\n\r\n  /**\r\n   * return stroke count which is the larger of the existing count or count needed for angle condition for given sweepRadians\r\n   * * defaultStepRadians is assumed to be larger than zero.\r\n   */\r\n  public applyAngleTol(minCount: number, sweepRadians: number, defaultStepRadians: number): number {\r\n    return StrokeOptions.applyAngleTol(this, minCount, sweepRadians, defaultStepRadians);\r\n  }\r\n  /**\r\n   * return stroke count which is the larger of minCount and the count required to turn sweepRadians, using tolerance from the options.\r\n   */\r\n  public static applyAngleTol(options: StrokeOptions | undefined, minCount: number, sweepRadians: number, defaultStepRadians?: number): number {\r\n    sweepRadians = Math.abs(sweepRadians);\r\n    let stepRadians = defaultStepRadians ? defaultStepRadians : Math.PI / 8.0;\r\n    if (options && options.angleTol && options.angleTol.radians > 0.0)\r\n      stepRadians = options.angleTol.radians;\r\n    if (minCount * stepRadians < sweepRadians)\r\n      minCount = Geometry.stepCount(stepRadians, sweepRadians, minCount);\r\n    return minCount;\r\n  }\r\n  /**\r\n   * Return the number of strokes needed for given edgeLength curve.\r\n   * @param options\r\n   * @param minCount smallest allowed count\r\n   * @param edgeLength\r\n   */\r\n  public static applyMaxEdgeLength(options: StrokeOptions | undefined, minCount: number, edgeLength: number): number {\r\n    if (edgeLength < 0)\r\n      edgeLength = - edgeLength;\r\n    if (minCount < 1)\r\n      minCount = 1;\r\n    if (options && options.maxEdgeLength && options.maxEdgeLength * minCount < edgeLength) {\r\n      minCount = Geometry.stepCount(options.maxEdgeLength, edgeLength, minCount);\r\n    }\r\n    return minCount;\r\n  }\r\n  /**\r\n   * Determine a stroke count for a (partial) circular arc of given radius. This considers angle, maxEdgeLength, chord, and minimum stroke.\r\n   */\r\n  public applyTolerancesToArc(radius: number, sweepRadians: number = Math.PI * 2): number {\r\n    let numStrokes = 1;\r\n    numStrokes = this.applyAngleTol(numStrokes, sweepRadians, Math.PI * 0.25);\r\n    numStrokes = this.applyMaxEdgeLength(numStrokes, sweepRadians * radius);\r\n    numStrokes = this.applyChordTol(numStrokes, radius, sweepRadians);\r\n    numStrokes = this.applyMinStrokesPerPrimitive(numStrokes);\r\n    return numStrokes;\r\n  }\r\n\r\n  /** return stroke count which is the larger of existing count or count needed for circular arc chord tolerance condition. */\r\n  public applyChordTol(minCount: number, radius: number, sweepRadians: number): number {\r\n    if (this.chordTol && this.chordTol > 0.0 && this.chordTol < radius) {\r\n      const a = this.chordTol;\r\n      const stepRadians = 2.0 * Math.acos((1.0 - a / radius));\r\n      minCount = Geometry.stepCount(stepRadians, sweepRadians, minCount);\r\n    }\r\n    return minCount;\r\n  }\r\n  /** return stroke count which is the larger of existing count or count needed for circular arc chord tol with given arc length and radians\r\n   */\r\n  public applyChordTolToLengthAndRadians(minCount: number, length: number, sweepRadians: number): number {\r\n    if (this.chordTol && this.chordTol > 0.0) {\r\n      const radius = Geometry.conditionalDivideFraction(length, sweepRadians);\r\n      if (radius !== undefined)\r\n        return this.applyChordTol(minCount, radius, sweepRadians);\r\n    }\r\n    return minCount;\r\n  }\r\n\r\n  /** return stroke count which is the larger of existing count or `this.minStrokesPerPrimitive` */\r\n  public applyMinStrokesPerPrimitive(minCount: number): number {\r\n    if (this.minStrokesPerPrimitive !== undefined && Number.isFinite(this.minStrokesPerPrimitive)\r\n      && this.minStrokesPerPrimitive > minCount)\r\n      minCount = this.minStrokesPerPrimitive;\r\n    return minCount;\r\n  }\r\n\r\n  /** create `StrokeOptions` with defaults appropriate for curves.\r\n   * * angle tolerance of 15 degrees.\r\n   * * all others inactive.\r\n   */\r\n  public static createForCurves(): StrokeOptions {\r\n    const options = new StrokeOptions();\r\n    options.angleTol = Angle.createDegrees(15.0);\r\n    return options;\r\n  }\r\n  /** create `StrokeOptions` with defaults appropriate for surfaces facets\r\n   * * angle tolerance of 22.5 degrees.\r\n   * * all others inactive.\r\n   */\r\n  public static createForFacets(): StrokeOptions {\r\n    const options = new StrokeOptions();\r\n    options.angleTol = Angle.createDegrees(22.5);\r\n    return options;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry, AxisOrder } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Quadrature } from \"../numerics/Quadrature\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\n\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { LineString3d } from \"./LineString3d\";\r\n// import {} from \"./\";\r\n\r\n/** A transition spiral is a curve defined by its curvature, with the curvature function symmetric about midpoint.\r\n * * The symmetry condition creates a relationship among the following 4 quantities:\r\n * ** curvature0 = curvature (i.e. 1/radius) at start\r\n * ** curvature1 = curvature (i.e. 1/radius) at end\r\n * ** sweepRadians = signed turning angle from start to end\r\n * ** arcLength = length of curve\r\n * * The relationship is the equation\r\n * ** `sweepRadians = arcLength * average Curvature = arcLength * 0.5 * (curvature0 + curvature1)`\r\n * * That is, regardless of any curvature properties other than symmetry, specifying any 3 of the quantities fully determines the remaining one.\r\n * @alpha\r\n */\r\nexport class TransitionConditionalProperties {\r\n  /** radius (or 0 at start) */\r\n  public radius0: number | undefined;\r\n  /** radius (or 0) at end */\r\n  public radius1: number | undefined;\r\n  /** bearing at start, measured from x towards y */\r\n  public bearing0: Angle | undefined;\r\n  /** bearing at end, measured from x towards y */\r\n  public bearing1: Angle | undefined;\r\n  /** curve length */\r\n  public curveLength: number | undefined;\r\n  /**\r\n   * capture numeric or undefined values\r\n   * @param radius0 start radius or undefined\r\n   * @param radius1 end radius or undefined\r\n   * @param bearing0 start bearing or undefined\r\n   * @param bearing1 end bearing or undefined\r\n   * @param arcLength arc length or undefined\r\n   */\r\n  public constructor(\r\n    radius0: number | undefined,\r\n    radius1: number | undefined,\r\n    bearing0: Angle | undefined,\r\n    bearing1: Angle | undefined,\r\n    arcLength: number | undefined,\r\n  ) {\r\n    this.radius0 = radius0;\r\n    this.radius1 = radius1;\r\n    this.bearing0 = bearing0;\r\n    this.bearing1 = bearing1;\r\n    this.curveLength = arcLength;\r\n  }\r\n  /** return the number of defined values among the 5 properties. */\r\n  public numDefinedProperties() {\r\n    return Geometry.defined01(this.radius0)\r\n      + Geometry.defined01(this.radius1)\r\n      + Geometry.defined01(this.bearing0)\r\n      + Geometry.defined01(this.bearing1)\r\n      + Geometry.defined01(this.curveLength);\r\n  }\r\n  /** clone with all properties (i.e. preserve undefined states) */\r\n  public clone(): TransitionConditionalProperties {\r\n    return new TransitionConditionalProperties(\r\n      this.radius0,\r\n      this.radius1,\r\n      this.bearing0 === undefined ? undefined : this.bearing0.clone(),\r\n      this.bearing1 === undefined ? undefined : this.bearing1.clone(),\r\n      this.curveLength);\r\n  }\r\n  /** Examine which properties are defined and compute the (single) undefined.\r\n   * @returns Return true if the input state had precisely one undefined member.\r\n   */\r\n  public tryResolveAnySingleUnknown(): boolean {\r\n    if (this.bearing0 && this.bearing1) {\r\n      const sweepRadians = this.bearing1.radians - this.bearing0.radians;\r\n      if (this.curveLength === undefined && this.radius0 !== undefined && this.radius1 !== undefined) {\r\n        this.curveLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(this.radius0, this.radius1, sweepRadians);\r\n        return true;\r\n      }\r\n      if (this.curveLength !== undefined && this.radius0 === undefined && this.radius1 !== undefined) {\r\n        this.radius0 = TransitionSpiral3d.radius1LengthSweepRadiansToRadius0(this.radius1, this.curveLength, sweepRadians);\r\n        return true;\r\n      }\r\n      if (this.curveLength !== undefined && this.radius0 !== undefined && this.radius1 === undefined) {\r\n        this.radius1 = TransitionSpiral3d.radius0LengthSweepRadiansToRadius1(this.radius0, this.curveLength, sweepRadians);\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    // at least one bearing is undefined ...\r\n    if (this.curveLength === undefined || this.radius0 === undefined || this.radius1 === undefined)\r\n      return false;\r\n\r\n    if (this.bearing0) {// bearing 1 is undefined\r\n      this.bearing1 = Angle.createRadians(this.bearing0.radians + TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));\r\n      return true;\r\n    }\r\n\r\n    if (this.bearing1) {// bearing 0 is undefined\r\n      this.bearing0 = Angle.createRadians(this.bearing1.radians - TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  private almostEqualCoordinate(a: number | undefined, b: number | undefined): boolean {\r\n    if (a === undefined && b === undefined)\r\n      return true;\r\n    if (a !== undefined && b !== undefined)\r\n      return Geometry.isSameCoordinate(a, b);\r\n    return false;\r\n  }\r\n  private almostEqualBearing(a: Angle | undefined, b: Angle | undefined): boolean {\r\n    if (a === undefined && b === undefined)\r\n      return true;\r\n    if (a !== undefined && b !== undefined)\r\n      return a.isAlmostEqualNoPeriodShift(b);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Test if this and other have matching numeric and undefined members.\r\n   */\r\n  public isAlmostEqual(other: TransitionConditionalProperties) {\r\n    if (!this.almostEqualCoordinate(this.radius0, other.radius0))\r\n      return false;\r\n    if (!this.almostEqualCoordinate(this.radius1, other.radius1))\r\n      return false;\r\n    if (!this.almostEqualBearing(this.bearing0, other.bearing0))\r\n      return false;\r\n    if (!this.almostEqualBearing(this.bearing1, other.bearing1))\r\n      return false;\r\n    if (!this.almostEqualCoordinate(this.curveLength, other.curveLength))\r\n      return false;\r\n    return true;\r\n  }\r\n  /** Apply a NONZERO scale factor to all distances. */\r\n  public applyScaleFactor(a: number) {\r\n    if (this.radius0 !== undefined)\r\n      this.radius0 *= a;\r\n    if (this.radius1 !== undefined)\r\n      this.radius1 *= a;\r\n    if (this.curveLength !== undefined)\r\n      this.curveLength *= a;\r\n  }\r\n}\r\n/**\r\n * A transition spiral is a curve defined by its curvature, with the curvature function symmetric about midpoint.\r\n * * `TransitionConditionalProperties` implements the computations of the interrelationship of radii, bearing, and length.\r\n * @alpha\r\n */\r\nexport class TransitionSpiral3d extends CurvePrimitive {\r\n  /** String name for schema properties */\r\n  public readonly curvePrimitiveType = \"transitionSpiral\";\r\n\r\n  /** Return 1/r with convention that if true zero is given as radius it represents infinite radius (0 curvature, straight line) */\r\n  public static radiusToCurvature(radius: number): number { return (radius === 0.0) ? 0.0 : 1.0 / radius; }\r\n\r\n  /** Return 1/k with convention that if near-zero is given as curvature, its infinite radius is returned as 0 */\r\n  public static curvatureToRadius(curvature: number): number {\r\n    if (Math.abs(curvature) < Geometry.smallAngleRadians)\r\n      return 0.0;\r\n    return 1.0 / curvature;\r\n  }\r\n\r\n  /** Return the average of the start and end curvatures. */\r\n  public static averageCurvature(radiusLimits: Segment1d): number {\r\n    return 0.5 * (TransitionSpiral3d.radiusToCurvature(radiusLimits.x0) + TransitionSpiral3d.radiusToCurvature(radiusLimits.x1));\r\n  }\r\n  /**\r\n   * Given two radii (or zeros for 0 curvature) return the average curvature\r\n   * @param r0 start radius, or 0 for line\r\n   * @param r1 end radius, or 0 for line\r\n   */\r\n  public static averageCurvatureR0R1(r0: number, r1: number): number {\r\n    return 0.5 * (TransitionSpiral3d.radiusToCurvature(r0) + TransitionSpiral3d.radiusToCurvature(r1));\r\n  }\r\n  /** Return the arc length of a transition spiral with given sweep and radius pair. */\r\n  public static radiusRadiusSweepRadiansToArcLength(radius0: number, radius1: number, sweepRadians: number): number {\r\n    return Math.abs(sweepRadians / TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1));\r\n  }\r\n\r\n  /** Return the turn angle for spiral of given length between two radii */\r\n  public static radiusRadiusLengthToSweepRadians(radius0: number, radius1: number, arcLength: number): number {\r\n    return TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1) * arcLength;\r\n  }\r\n\r\n  /** Return the end radius for spiral of given start radius, length, and turn angle. */\r\n  public static radius0LengthSweepRadiansToRadius1(radius0: number, arcLength: number, sweepRadians: number) {\r\n    return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius0));\r\n  }\r\n  /** Return the start radius for spiral of given end radius, length, and turn angle. */\r\n  public static radius1LengthSweepRadiansToRadius0(radius1: number, arcLength: number, sweepRadians: number) {\r\n    return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius1));\r\n  }\r\n  /** Fractional interval for the \"active\" part of a containing spiral.\r\n   * (The radius, angle, and length conditions define a complete spiral, and some portion of it is \"active\")\r\n   */\r\n  public activeFractionInterval: Segment1d;\r\n  /** start and end radii as a Segment1d */\r\n  public radius01: Segment1d;\r\n  /** start and end bearings as an AngleSweep */\r\n  public bearing01: AngleSweep;\r\n  /** Placement transform */\r\n  public localToWorld: Transform;\r\n  /** stroked approximation of entire spiral. */\r\n  private _globalStrokes: LineString3d;\r\n  /** stroked approximation of active spiral.\r\n   * * Same count as global -- possibly overly fine, but it gives some consistency between same clothoid constructed as partial versus complete.\r\n   * * If no trimming, this points to the same place as the _globalStrokes !!!  Don't double transform!!!\r\n   */\r\n  private _activeStrokes?: LineString3d;\r\n  /** Return the internal stroked form of the (possibly partial) spiral   */\r\n  public get activeStrokes(): LineString3d { return this._activeStrokes !== undefined ? this._activeStrokes : this._globalStrokes; }\r\n\r\n  /** Total curve arc length (computed) */\r\n  private _arcLength01: number;\r\n  /** Curvatures (inverse radii) at start and end */\r\n  private _curvature01: Segment1d;\r\n  /** string name of spiral type */\r\n  private _spiralType: string | undefined;\r\n  /** Original defining properties. */\r\n  private _properties: TransitionConditionalProperties | undefined;\r\n  // constructor demands all bearing, radius, and length data -- caller determines usual dependency of \"any 4 determine the 5th\"\r\n  constructor(spiralType: string | undefined,\r\n    radius01: Segment1d,\r\n    bearing01: AngleSweep,\r\n    activeFractionInterval: Segment1d,\r\n    localToWorld: Transform,\r\n    arcLength: number,\r\n    properties: TransitionConditionalProperties | undefined) {\r\n    super();\r\n    this._spiralType = spiralType;\r\n    this.localToWorld = localToWorld;\r\n    this.radius01 = radius01;\r\n    this.bearing01 = bearing01;\r\n    this.localToWorld = localToWorld;\r\n    this.activeFractionInterval = activeFractionInterval;\r\n    this._arcLength01 = arcLength;\r\n    this._globalStrokes = LineString3d.create();\r\n    // initialize for compiler -- but this will be recomputed in refreshComputeProperties ...\r\n    this._curvature01 = Segment1d.create(0, 1);\r\n    this.refreshComputedProperties();\r\n    this._properties = properties;\r\n  }\r\n  /** Return the original defining properties (if any) saved by the constructor. */\r\n  public get originalProperties(): TransitionConditionalProperties | undefined { return this._properties; }\r\n  /** default spiral type name. (clothoid) */\r\n  public static readonly defaultSpiralType = \"clothoid\";\r\n  /** return the spiral type as a string (undefined resolves to default type \"clothoid\") */\r\n  public getSpiralType(): string { if (this._spiralType === undefined) return TransitionSpiral3d.defaultSpiralType; return this._spiralType; }\r\n  /** Return the bearing at given fraction .... */\r\n  public globalFractionToBearingRadians(fraction: number): number {\r\n    return this.bearing01.startRadians + fraction * this._arcLength01 * (this._curvature01.x0 + 0.5 * fraction * (this._curvature01.x1 - this._curvature01.x0));\r\n  }\r\n  /** Return the curvature at given fraction ... */\r\n  public globalFractionToCurvature(fraction: number): number {\r\n    // BUG? active interval\r\n    return this._curvature01.fractionToPoint(fraction);\r\n  }\r\n\r\n  /** Return the bearing at given fraction of the active interval .... */\r\n  public fractionToBearingRadians(activeFraction: number): number {\r\n    const fraction = this.activeFractionInterval.fractionToPoint(activeFraction);\r\n    return this.bearing01.startRadians + fraction * this._arcLength01 * (this._curvature01.x0 + 0.5 * fraction * (this._curvature01.x1 - this._curvature01.x0));\r\n  }\r\n  /** Return the curvature at given fraction of the active interval ... */\r\n  public fractionToCurvature(activeFraction: number): number {\r\n    // BUG? active interval\r\n    return this._curvature01.fractionToPoint(this.activeFractionInterval.fractionToPoint(activeFraction));\r\n  }\r\n\r\n  // These static variables are reused on calls to integrateFromStartFraction\r\n  private static _gaussFraction: Float64Array;\r\n  private static _gaussWeight: Float64Array;\r\n  private static _gaussMapper: (xA: number, xB: number, arrayX: Float64Array, arrayW: Float64Array) => number;\r\n  /** Initialize class level work arrays. */\r\n  public static initWorkSpace() {\r\n    TransitionSpiral3d._gaussFraction = new Float64Array(5);\r\n    TransitionSpiral3d._gaussWeight = new Float64Array(5);\r\n    TransitionSpiral3d._gaussMapper = Quadrature.setupGauss5;\r\n  }\r\n  /** Evaluate and sum the gauss quadrature formulas to integrate cos(theta), sin(theta) fractional subset of a reference length.\r\n   * (recall that theta is a nonlinear function of the fraction.)\r\n   * * This is a single interval of gaussian integration.\r\n   * * The fraction is on the full spiral (not in the mapped active interval)\r\n   * @param xyz advancing integrated point.\r\n   * @param fractionA fraction at start of interval\r\n   * @param fractionB fraction at end of interval.\r\n   * @param unitArcLength length of curve for 0 to 1 fractional\r\n   */\r\n  private fullSpiralIncrementalIntegral(xyz: Point3d, fractionA: number, fractionB: number, applyMatrix: boolean) {\r\n    const gaussFraction = TransitionSpiral3d._gaussFraction;\r\n    const gaussWeight = TransitionSpiral3d._gaussWeight;\r\n    const numEval = TransitionSpiral3d._gaussMapper(fractionA, fractionB, gaussFraction, gaussWeight);\r\n    const deltaL = this._arcLength01;\r\n    let w = 0;\r\n    let dx = 0.0;\r\n    let dy = 0.0;\r\n    for (let k = 0; k < numEval; k++) {\r\n      const radians = this.globalFractionToBearingRadians(gaussFraction[k]);\r\n      w = gaussWeight[k] * deltaL;\r\n      dx += w * Math.cos(radians);\r\n      dy += w * Math.sin(radians);\r\n    }\r\n    if (applyMatrix)\r\n      Matrix3d.xyzPlusMatrixTimesXYZ(xyz, this.localToWorld.matrix, { x: dx, y: dy, z: 0.0 }, xyz);\r\n    else\r\n      xyz.addXYZInPlace(dx, dy, 0.0);\r\n\r\n  }\r\n  /** Recompute strokes */\r\n  public refreshComputedProperties() {\r\n    this._curvature01 = Segment1d.create(\r\n      TransitionSpiral3d.radiusToCurvature(this.radius01.x0),\r\n      TransitionSpiral3d.radiusToCurvature(this.radius01.x1));\r\n    this._globalStrokes.clear();\r\n    const currentPoint = Point3d.create();\r\n    this._globalStrokes.appendStrokePoint(currentPoint);\r\n    const numInterval = 16;\r\n\r\n    const fractionStep = 1.0 / numInterval;\r\n    for (let i = 1; i <= numInterval; i++) {\r\n      const fraction0 = (i - 1) * fractionStep;\r\n      const fraction1 = i * fractionStep;\r\n      this.fullSpiralIncrementalIntegral(currentPoint, fraction0, fraction1, false);\r\n      this._globalStrokes.appendStrokePoint(currentPoint);\r\n    }\r\n    this._globalStrokes.tryTransformInPlace(this.localToWorld);\r\n    if (!this.activeFractionInterval.isExact01) {\r\n      if (this._activeStrokes === undefined)\r\n        this._activeStrokes = LineString3d.create();\r\n      this._activeStrokes.clear();\r\n      // finer strokes in the active interval ... same fraction step, but mapped\r\n      // This assumes factionToPoint acts normally within refreshComputedProperties -- that depends on the global strokes we just computed, but not on the active strokes\r\n      for (let i = 0; i <= numInterval; i++) {\r\n        const localFraction = i * fractionStep;\r\n        this._activeStrokes.addPoint(this.fractionToPoint(localFraction));\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Create a transition spiral with radius and bearing conditions.\r\n   * @param radius01 radius (inverse curvature) at start and end. (radius of zero means straight line)\r\n   * @param bearing01 bearing angles at start and end.  bearings are measured from the x axis, positive clockwise towards y axis\r\n   * @param activeFractionInterval fractional limits of the active portion of the spiral.\r\n   * @param localToWorld placement frame.  Fractional coordinate 0 is at the origin.\r\n   */\r\n  public static createRadiusRadiusBearingBearing(radius01: Segment1d, bearing01: AngleSweep, activeFractionInterval: Segment1d, localToWorld: Transform) {\r\n    const arcLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(radius01.x0, radius01.x1, bearing01.sweepRadians);\r\n    return new TransitionSpiral3d(\"clothoid\",\r\n      radius01.clone(),\r\n      bearing01.clone(), activeFractionInterval.clone(), localToWorld.clone(), arcLength,\r\n      new TransitionConditionalProperties(radius01.x0, radius01.x1,\r\n        bearing01.startAngle.clone(), bearing01.endAngle.clone(),\r\n        undefined));\r\n  }\r\n  /**\r\n   * Create a transition spiral.\r\n   * * Inputs must provide exactly 4 of the 5 values `[radius0,radius1,bearing0,bearing1,length`.\r\n   * @param spiralType one of \"clothoid\", \"bloss\", \"biquadratic\", \"cosine\", \"sine\".  If undefined, \"clothoid\" is used.\r\n   * @param radius0 radius (or 0 for tangent to line) at start\r\n   * @param radius1 radius (or 0 for tangent to line) at end\r\n   * @param bearing0 bearing, measured CCW from x axis at start.\r\n   * @param bearing1 bearing, measured CCW from x axis at end.\r\n   * @param fractionInterval optional fractional interval for an \"active\" portion of the curve.   if omitted, the full [0,1] is used.\r\n   * @param localToWorld placement transform\r\n   */\r\n  public static create(\r\n    spiralType: string | undefined,\r\n    radius0: number | undefined,\r\n    radius1: number | undefined,\r\n    bearing0: Angle | undefined,\r\n    bearing1: Angle | undefined,\r\n    arcLength: number | undefined,\r\n    fractionInterval: undefined | Segment1d,\r\n    localToWorld: Transform): TransitionSpiral3d | undefined {\r\n    const data = new TransitionConditionalProperties(radius0, radius1, bearing0, bearing1, arcLength);\r\n    const data1 = data.clone();\r\n    if (!data.tryResolveAnySingleUnknown())\r\n      return undefined;\r\n    if (fractionInterval === undefined)\r\n      fractionInterval = Segment1d.create(0, 1);\r\n    return new TransitionSpiral3d(\r\n      spiralType,\r\n      Segment1d.create(data.radius0, data.radius1),\r\n      AngleSweep.createStartEnd(data.bearing0!, data.bearing1!),\r\n      fractionInterval ? fractionInterval.clone() : Segment1d.create(0, 1),\r\n      localToWorld, data.curveLength!, data1);\r\n  }\r\n  /** Copy all defining data from another spiral. */\r\n  public setFrom(other: TransitionSpiral3d): TransitionSpiral3d {\r\n    this.localToWorld.setFrom(other.localToWorld);\r\n    this.radius01.setFrom(other.radius01);\r\n    this._curvature01.setFrom(other._curvature01);\r\n    this.bearing01.setFrom(other.bearing01);\r\n    this.localToWorld.setFrom(other.localToWorld);\r\n    this.activeFractionInterval.setFrom(other.activeFractionInterval);\r\n    this._arcLength01 = other._arcLength01;\r\n    return this;\r\n  }\r\n  /** Deep clone of this spiral */\r\n  public clone(): TransitionSpiral3d {\r\n    return TransitionSpiral3d.createRadiusRadiusBearingBearing(this.radius01, this.bearing01, this.activeFractionInterval, this.localToWorld);\r\n  }\r\n  /** apply `transform` to this spiral's local to world transform. */\r\n  public tryTransformInPlace(transformA: Transform): boolean {\r\n\r\n    const rigidData = transformA.matrix.factorRigidWithSignedScale();\r\n    if (rigidData !== undefined) {\r\n      // [sQ a][R b] = [sQ*R sQb+a]\r\n      // but we save it as [Q*R sQb+a] with spiral data scaled by s.\r\n      const transformC0 = transformA.multiplyTransformTransform(this.localToWorld);\r\n      // BUT pull the scale part out of the matrix ...\r\n      const matrixC = (rigidData.rigidAxes as Matrix3d).multiplyMatrixMatrix(this.localToWorld.matrix);\r\n      this.localToWorld = Transform.createOriginAndMatrix(transformC0.origin, matrixC);\r\n      this._curvature01.x0 /= rigidData.scale;\r\n      this._curvature01.x1 /= rigidData.scale;\r\n      this.radius01.x0 *= rigidData.scale;\r\n      this.radius01.x1 *= rigidData.scale;\r\n      this._arcLength01 *= rigidData.scale;\r\n      if (this.originalProperties)\r\n        this.originalProperties.applyScaleFactor(rigidData.scale);\r\n    }\r\n    this.refreshComputedProperties();\r\n    return true;\r\n  }\r\n  /** Clone with a transform applied  */\r\n  public cloneTransformed(transform: Transform): TransitionSpiral3d {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);  // ok, we're confident it will always work.\r\n    return result;\r\n  }\r\n  /** Return the spiral start point. */\r\n  public startPoint(): Point3d { return this.activeStrokes.startPoint(); }\r\n  /** return the spiral end point. */\r\n  public endPoint(): Point3d { return this.activeStrokes.endPoint(); }\r\n  /** test if the local to world transform places the spiral xy plane into `plane` */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return plane.isPointInPlane(this.localToWorld.origin as Point3d)\r\n      && Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnX(plane.getNormalRef()))\r\n      && Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnY(plane.getNormalRef()));\r\n  }\r\n  /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */\r\n  public quickLength() { return this._arcLength01; }\r\n  /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */\r\n  public curveLength() { return this._arcLength01; }\r\n  /** Test if `other` is an instance of `TransitionSpiral3d` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof TransitionSpiral3d; }\r\n  /** Add strokes from this spiral to `dest`.\r\n   * * Linestrings will usually stroke as just their points.\r\n   * * If maxEdgeLength is given, this will sub-stroke within the linestring -- not what we want.\r\n   */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void { this.activeStrokes.emitStrokes(dest, options); }\r\n  /** emit stroke fragments to `dest` handler. */\r\n  public emitStrokableParts(dest: IStrokeHandler, options?: StrokeOptions): void {\r\n    const n = this.computeStrokeCountForOptions(options);\r\n    const activeStrokes = this.activeStrokes;\r\n    dest.startParentCurvePrimitive(this);\r\n    if (n <= activeStrokes.numPoints()) {\r\n      this.activeStrokes.emitStrokableParts(dest, options);\r\n    } else {\r\n      dest.announceIntervalForUniformStepStrokes(this, n, 0.0, 1.0);\r\n    }\r\n    dest.endParentCurvePrimitive(this);\r\n  }\r\n\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    let numStroke = 1;\r\n    if (options) {\r\n      const rMin = Math.min(Math.abs(this.radius01.x0), Math.abs(this.radius01.x1));\r\n      numStroke = options.applyTolerancesToArc(rMin, this.bearing01.sweepRadians);\r\n      numStroke = options.applyMaxEdgeLength(numStroke, this.curveLength());\r\n      numStroke = options.applyMinStrokesPerPrimitive(numStroke);\r\n    } else {\r\n      numStroke = StrokeOptions.applyAngleTol(undefined, 4, this.bearing01.sweepRadians);\r\n    }\r\n    return numStroke;\r\n  }\r\n\r\n  /** Reverse the active interval and active strokes.\r\n   * * Primary defining data remains unchanged !!!\r\n   */\r\n  public reverseInPlace(): void {\r\n    this.activeFractionInterval.reverseInPlace();\r\n    if (this._activeStrokes === undefined)\r\n      this._activeStrokes = this._globalStrokes.clone();\r\n    this._activeStrokes.reverseInPlace();\r\n  }\r\n  /** Evaluate curve point with respect to fraction. */\r\n  public fractionToPoint(activeFraction: number, result?: Point3d): Point3d {\r\n    let globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);\r\n    globalFraction = Geometry.clampToStartEnd(globalFraction, 0, 1);\r\n    const numStrokes = this._globalStrokes.packedPoints.length - 1;\r\n    const index0 = Math.trunc(globalFraction * numStrokes); // This indexes the point to the left of the query\r\n    const globalFraction0 = index0 / numStrokes;\r\n    result = this._globalStrokes.packedPoints.getPoint3dAtUncheckedPointIndex(index0, result);\r\n    this.fullSpiralIncrementalIntegral(result, globalFraction0, globalFraction, true);\r\n    return result;\r\n  }\r\n  /** Evaluate curve point and derivative with respect to fraction. */\r\n  public fractionToPointAndDerivative(activeFraction: number, result?: Ray3d): Ray3d {\r\n    const globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);\r\n    result = result ? result : Ray3d.createZero();\r\n    this.fractionToPoint(activeFraction, result.origin);\r\n    const radians = this.globalFractionToBearingRadians(globalFraction);\r\n    const a = this._arcLength01 * this.activeFractionInterval.signedDelta();\r\n    this.localToWorld.matrix.multiplyXY(a * Math.cos(radians), a * Math.sin(radians), result.direction);\r\n    return result;\r\n  }\r\n\r\n  /** Return the frenet frame at fractional position. */\r\n  public fractionToFrenetFrame(activeFraction: number, result?: Transform): Transform {\r\n    const globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);\r\n    result = result ? result : Transform.createIdentity();\r\n    result.origin.setFrom(this.fractionToPoint(activeFraction));\r\n    Matrix3d.createRigidFromMatrix3d(this.localToWorld.matrix, AxisOrder.XYZ, result.matrix);\r\n\r\n    const radians = this.globalFractionToBearingRadians(globalFraction);\r\n    const c = Math.cos(radians);\r\n    const s = Math.sin(radians);\r\n    result.matrix.applyGivensColumnOp(0, 1, c, -s);\r\n    return result;\r\n  }\r\n  /** Return a plane with\r\n   *\r\n   * * origin at fractional position along the curve\r\n   * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.\r\n   * * vectorV is the second derivative, i.e.derivative of vectorU.\r\n   */\r\n  public fractionToPointAnd2Derivatives(activeFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined {\r\n    const globalFraction = this.activeFractionInterval.fractionToPoint(activeFraction);\r\n    const origin = this.fractionToPoint(activeFraction);\r\n    const radians = this.globalFractionToBearingRadians(globalFraction);\r\n    const c = Math.cos(radians);\r\n    const s = Math.sin(radians);\r\n    const delta = this.activeFractionInterval.signedDelta();\r\n    const a = this._arcLength01 * delta;\r\n    const b = a * delta;\r\n    const vectorX = this.localToWorld.matrix.multiplyXY(a * c, a * s);\r\n    const vectorY = this.localToWorld.matrix.multiplyXY(-b * s, b * c);\r\n    vectorY.scaleInPlace(this.globalFractionToCurvature(globalFraction));\r\n    return Plane3dByOriginAndVectors.createCapture(origin, vectorX, vectorY, result);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleTransitionSpiral(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleTransitionSpiral(this);\r\n  }\r\n  /** extend the range by the strokes of the spiral */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    this.activeStrokes.extendRange(rangeToExtend, transform);\r\n  }\r\n  /** compare various coordinate quantities */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof TransitionSpiral3d) {\r\n      return this.radius01.isAlmostEqual(other.radius01)\r\n        && this.bearing01.isAlmostEqualAllowPeriodShift(other.bearing01)\r\n        && this.localToWorld.isAlmostEqual(other.localToWorld)\r\n        && Geometry.isSameCoordinate(this._arcLength01, other._arcLength01)\r\n        && this.activeFractionInterval.isAlmostEqual(other.activeFractionInterval)\r\n        && this._curvature01.isAlmostEqual(other._curvature01);\r\n    }\r\n    return false;\r\n  }\r\n\r\n}\r\n// at load time, initialize gauss quadrature workspace\r\nTransitionSpiral3d.initWorkSpace();\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { RecursiveCurveProcessor } from \"./CurveProcessor\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { CurveCollection } from \"./CurveCollection\";\r\nimport { Loop } from \"./Loop\";\r\nimport { ParityRegion } from \"./ParityRegion\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\n/**\r\n * * A `UnionRegion` is a collection of other planar region types -- `Loop` and `ParityRegion`.\r\n * * The composite is the union of the contained regions.\r\n * * A point is \"in\" the composite if it is \"in\" one or more of the contained regions.\r\n * @public\r\n */\r\nexport class UnionRegion extends CurveCollection {\r\n   /** String name for schema properties */\r\n  public readonly curveCollectionType = \"unionRegion\";\r\n\r\n  /** test if `other` is a `UnionRegion` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof UnionRegion; }\r\n  /** collection of Loop and ParityRegion children. */\r\n  protected _children: Array<ParityRegion | Loop>;\r\n  /** Return the array of regions */\r\n  public get children(): Array<ParityRegion | Loop> { return this._children; }\r\n  /** Constructor -- initialize with no children */\r\n  public constructor() { super(); this._children = []; }\r\n  /** Create a `UnionRegion` with given region children */\r\n  public static create(...data: Array<ParityRegion | Loop>): UnionRegion {\r\n    const result = new UnionRegion();\r\n    for (const child of data) {\r\n      result.tryAddChild(child);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return the boundary type (5) of a corresponding  MicroStation CurveVector */\r\n  public dgnBoundaryType(): number { return 5; }\r\n  /** dispatch to more strongly typed  `processor.announceUnionRegion(this, indexInParent)` */\r\n  public announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent: number = -1): void {\r\n    return processor.announceUnionRegion(this, indexInParent);\r\n  }\r\n  /** Return structural clone with stroked primitives. */\r\n  public cloneStroked(options?: StrokeOptions): UnionRegion {\r\n    const clone = new UnionRegion();\r\n    let child;\r\n    for (child of this._children) {\r\n      const childStrokes = child.cloneStroked(options) as ParityRegion | Loop;\r\n      if (childStrokes)\r\n        clone.children.push(childStrokes);\r\n    }\r\n    return clone;\r\n  }\r\n  /** Return new empty `UnionRegion` */\r\n  public cloneEmptyPeer(): UnionRegion { return new UnionRegion(); }\r\n  /** add a child.\r\n   * * Returns false if the `AnyCurve` child is not a region type.\r\n   */\r\n  public tryAddChild(child: AnyCurve): boolean {\r\n    if (child && child instanceof ParityRegion || child instanceof Loop) {\r\n      this._children.push(child);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** Return a child identified by index. */\r\n  public getChild(i: number): Loop | ParityRegion | undefined {\r\n    if (i < this._children.length)\r\n      return this._children[i];\r\n    return undefined;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleUnionRegion(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleUnionRegion(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Utility */\n\n// REMARK:\n// The docs-group-description comments are followed by empty classes with names corresponding to the doc-group.\n// Normally (in committed code) these are commented out.\n// The comments have distinctive strings so that simple search and replace can make the \"real\".\n// This is useful when working on the documentation:  When the empty classes are present, VSCode will format the doc comments\n// for and display them when the mouse hovers over the class name.\n\n/**\n * @docs-package-description\n * The geometry-core package contains classes for working with geometry:  points, vectors, curves, surfaces, and analytic solids\n */\n/**\n * @docs-group-description CartesianGeometry\n * Points, Vectors, Planes, and Transformations for x,y,z geometry.\n * * Fundamental cartesian geometry objects:\n *   * Point2d, Point3d -- points with x,y,z coordinates\n *   * Vector2d, Vector3d -- vectors with x,y,z coordinates\n *   * Matrix3d -- 3x3 matrix\n *   * * commonly used for pure rotations\n *   * * scale and skew entries are also allowed.\n *   * Transform -- an origin and axes.\n *   * Range1d, Range2d, Range3d -- subsets of 1d, 2d, and 3d space bounded by low and high values.\n *   * Ray3d -- a ray defined by origin and direction vector\n *   * Plane3dByOriginAndUnitNormal -- a plane defined by an origin and a single vector which is perpendicular to the plane\n *   * plane3dByOriginAndVectors -- a plane defined by an origin and two vectors in the plane.\n * * Angles\n *   * Angle -- a strongly typed angle object whose method names make it clear whether input and outputs are degrees or radians.\n *   * AngleSweep -- an angular interval\n *   * YawPitchAndRollAngles -- 3 angles that define a rotated coordinate system.\n * * Utility classes\n *   * FrameBuilder -- construction of coordinate frames from mixed data sources.\n *   * ClipPlane -- a single plane\n *   * ConvexClipPlaneSet -- an array of planes bounding a convex volume\n *   * ClipPlaneSet -- an array of ConvexClipPlaneSet, defining the union of their volumes\n *   * BilinearPatch -- twisted quadrilateral defined by 4 points\n *   * BarycentricTriangle -- triangle defined by 3 points.\n *   * Constant -- various numeric values exported as readonly constants\n */\n// doc:export class CartesianGeometryDoc { }\n/**\n * @docs-group-description ArraysAndInterfaces\n * These classes support array operations and inheritance-based algorithms.\n * * Arrays\n *   * GrowableArray -- A carrier for a Float64Array, with methods that hide reallocation of the underlying array as contents are added.\n *   * Point2dArray, Point3dArray, Point4dArray, Vector3dArray -- miscellaneous operations on arrays of 2d and 3d points.\n * * Interfaces\n *   * GeometryHandler -- a double-dispatch protocol used for efficient implementation of algorithms that work on many geometry types.\n *\n */\n// doc:export class ArraysAndInterfacesDoc { }\n\n/**\n * @docs-group-description Bspline\n * A bspline curve or surface is used for curved freeform geometry defined by controls points (sometimes called poles).\n * * BSplineCurve --  a curve in XYZ coordinates\n * * BSplineSurfaceXYZ -- a surface with XYZ\n * * BsplineSurfaceXYZW -- a surface with weighted (rational) XYZ coordinates\n * * KnotVector -- vector of breakpoints in bspline definitions.\n */\n// doc:export class BsplineDoc { }\n\n/**\n * @docs-group-description Curve\n * Curves in the GeometryQuery hierarchy: LineSegment3d, LineString3d, Arc3d, TransitionSpiral3d\n * * CurvePrimitive -- base class for parametric curves\n *   * LineSegment3d -- a (bounded) portion of an unbounded line\n *   * Arc3d -- a circular or elliptic arc\n *   * LineString3d -- a sequence of points joined by line segments\n *   * TransitionSpiral -- controlled transition between curvatures\n * * Support classes\n * * PointString3d -- a sequence of isolated points\n * * StrokeOptions -- tolerances to describe stroking accuracy\n * * RecursiveCurveProcessor, RecursiveCurveProcessorWithStack -- algorithmic support for trees with CurvePrimitives at the leaf level.\n */\n// doc:export class CurveDoc { }\n/**\n * @docs-group-description Numerics\n * The Numerics classes have geometric and numeric methods used during large algorithms in other classes.\n */\n// doc:export class NumericsDoc { }\n/**\n * @docs-group-description Polyface\n * A Polyface is a mesh structure with arrays of points that are shared among multiple incident facets.\n */\n// doc:export class PolyfaceDoc { }\n/**\n * @docs-group-description Serialization\n * These classes are related to serialization of geometry classes.\n * * IModelJson.Reader, IModelJson.Writer -- Conversion of in-memory geometry objects to json objects for persistence and transmission.\n */\n// doc:export class SerializationDoc { }\n/**\n * @docs-group-description Solid\n * Analytic Solids in the GeometryQuery hierarchy: Box, Sphere, Cone, TorusPipe, LinearSweep, RotationalSweep, RuledSweep\n * * Box -- a box solid.  This is usually rectangular on all faces, but can in one directly like a view frustum\n * * Sphere -- a sphere\n * * Cone -- a cone or cylinder\n * * TorusPipe -- a pipe elbow\n * * LinearSweep -- a linear sweep of a base contour\n * * RotationalSweep -- a rotational sweep of a base contour\n * * RuledSweep -- two or more similarly structured contours joined by linear rule lines.\n */\n// doc:export class SolidDOc { }\n/**\n * @docs-group-description Topology\n * The Topology classes provide adjacency structures used in triangulations.\n */\n// doc:export class TopologyDoc { }\n\nexport * from \"./geometry3d/Angle\";\nexport * from \"./geometry3d/AngleSweep\";\nexport * from \"./geometry3d/BarycentricTriangle\";\nexport * from \"./geometry3d/BilinearPatch\";\nexport * from \"./geometry3d/FrameBuilder\";\nexport * from \"./geometry3d/FrustumAnimation\";\nexport * from \"./geometry3d/GeometryHandler\";\nexport * from \"./geometry3d/GrowableBlockedArray\";\nexport * from \"./geometry3d/GrowableFloat64Array\";\nexport * from \"./geometry3d/GrowableXYArray\";\nexport * from \"./geometry3d/GrowableXYZArray\";\nexport * from \"./geometry3d/IndexedCollectionInterval\";\nexport * from \"./geometry3d/IndexedXYCollection\";\nexport * from \"./geometry3d/IndexedXYZCollection\";\nexport * from \"./geometry3d/Matrix3d\";\nexport * from \"./geometry3d/OrderedRotationAngles\";\nexport * from \"./geometry3d/Plane3dByOriginAndUnitNormal\";\nexport * from \"./geometry3d/Plane3dByOriginAndVectors\";\nexport * from \"./geometry3d/Point2dArrayCarrier\";\nexport * from \"./geometry3d/Point2dVector2d\";\nexport * from \"./geometry3d/Point3dVector3d\";\nexport * from \"./geometry3d/PointHelpers\";\nexport * from \"./geometry3d/Point3dArrayCarrier\";\nexport * from \"./geometry3d/PolylineOps\";\nexport * from \"./geometry3d/PolygonOps\";\nexport * from \"./geometry3d/Range\";\nexport * from \"./geometry3d/Ray3d\";\nexport * from \"./geometry3d/Segment1d\";\nexport * from \"./geometry3d/Transform\";\nexport * from \"./geometry3d/XYZProps\";\nexport * from \"./geometry3d/YawPitchRollAngles\";\n\nexport * from \"./Geometry\";\nexport * from \"./Constant\";\nexport * from \"./clipping/ClipPlane\";\nexport * from \"./clipping/ConvexClipPlaneSet\";\nexport * from \"./clipping/UnionOfConvexClipPlaneSets\";\nexport * from \"./clipping/ClipPrimitive\";\nexport * from \"./clipping/ClipVector\";\nexport * from \"./clipping/ClipUtils\";\nexport * from \"./numerics/ConvexPolygon2d\";\nexport * from \"./geometry4d/PlaneByOriginAndVectors4d\";\nexport * from \"./geometry4d/Point4d\";\nexport * from \"./geometry4d/Matrix4d\";\nexport * from \"./geometry4d/Map4d\";\nexport * from \"./geometry4d/MomentData\";\nexport * from \"./numerics/BezierPolynomials\";\nexport * from \"./numerics/ClusterableArray\";\nexport * from \"./numerics/Newton\";\nexport * from \"./numerics/Complex\";\nexport * from \"./numerics/ConvexPolygon2d\";\nexport * from \"./numerics/Newton\";\nexport * from \"./numerics/PascalCoefficients\";\nexport * from \"./numerics/Polynomials\";\nexport * from \"./numerics/Quadrature\";\nexport * from \"./numerics/Range1dArray\";\nexport * from \"./numerics/TriDiagonalSystem\";\n\nexport * from \"./curve/Arc3d\";\nexport * from \"./curve/ConstructCurveBetweenCurves\";\nexport * from \"./curve/CoordinateXYZ\";\nexport * from \"./curve/CurveChain\";\nexport * from \"./curve/CurveChainWithDistanceIndex\";\nexport * from \"./curve/CurveExtendMode\";\nexport * from \"./curve/CurveCollection\";\nexport * from \"./curve/CurveCurve\";\nexport * from \"./curve/CurveCurveIntersectXY\";\nexport * from \"./curve/CurveCurveIntersectXYZ\";\nexport * from \"./curve/CurveLocationDetail\";\nexport * from \"./curve/CurveFactory\";\nexport * from \"./curve/CurvePrimitive\";\nexport * from \"./curve/CurveProcessor\";\nexport * from \"./curve/GeometryQuery\";\nexport * from \"./curve/LineSegment3d\";\nexport * from \"./curve/LineString3d\";\nexport * from \"./curve/Loop\";\nexport * from \"./curve/ParityRegion\";\nexport * from \"./curve/Path\";\nexport * from \"./curve/RegionMomentsXY\";\nexport * from \"./curve/RegionOps\";\nexport * from \"./curve/PolygonOffsetContext\";\nexport * from \"./curve/PointString3d\";\nexport * from \"./curve/StrokeOptions\";\nexport * from \"./curve/TransitionSpiral\";\nexport * from \"./curve/UnionRegion\";\nexport * from \"./curve/Query/StrokeCountMap\";\nexport * from \"./solid/Box\";\nexport * from \"./solid/Cone\";\nexport * from \"./solid/LinearSweep\";\nexport * from \"./solid/RotationalSweep\";\nexport * from \"./solid/RuledSweep\";\nexport * from \"./solid/SolidPrimitive\";\nexport * from \"./solid/Sphere\";\nexport * from \"./solid/SweepContour\";\nexport * from \"./solid/TorusPipe\";\nexport * from \"./bspline/Bezier1dNd\";\nexport * from \"./bspline/BezierCurveBase\";\nexport * from \"./bspline/BezierCurve3d\";\nexport * from \"./bspline/BezierCurve3dH\";\nexport * from \"./bspline/BSplineCurve\";\nexport * from \"./bspline/BSpline1dNd\";\nexport * from \"./bspline/BSplineCurve3dH\";\nexport * from \"./bspline/BSplineSurface\";\nexport * from \"./bspline/KnotVector\";\nexport * from \"./polyface/AuxData\";\nexport * from \"./polyface/BoxTopology\";\nexport * from \"./polyface/FacetFaceData\";\nexport * from \"./polyface/Polyface\";\nexport * from \"./polyface/PolyfaceBuilder\";\nexport * from \"./polyface/PolyfaceData\";\nexport * from \"./polyface/PolyfaceQuery\";\nexport * from \"./polyface/PolyfaceClip\";\nexport * from \"./topology/Graph\";\nexport * from \"./topology/Triangulation\";\nexport * from \"./serialization/IModelJsonSchema\";\nexport * from \"./serialization/DeepCompare\";\nexport * from \"./serialization/GeometrySamples\";\n\n// Set the version number so it can be found at runtime. BUILD_SEMVER is replaced at build time by the webpack DefinePlugin.\ndeclare var BUILD_SEMVER: string;\nif ((typeof (BUILD_SEMVER) !== \"undefined\") && (typeof window !== \"undefined\") && window) {\n  if (!(window as any).iModelJsVersions)\n    (window as any).iModelJsVersions = new Map<string, string>();\n  (window as any).iModelJsVersions.set(\"geometry-core\", BUILD_SEMVER);\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { BeJSONFunctions, AngleProps, Geometry, TrigValues } from \"../Geometry\";\r\n/** @module CartesianGeometry */\r\n/**\r\n * An `Angle` carries the numeric value of an angle, with methods to allow (require!) callers to be clear about whether their angle is degrees or radians.\r\n * * The numeric value is private, and callers should not know or care whether it is in degrees or radians.\r\n * * The various access method are named so that callers can specify whether untyped numbers passed in or out are degrees or radians.\r\n * @public\r\n */\r\nexport class Angle implements BeJSONFunctions {\r\n    /** maximal accuracy value of pi/4 ( 45 degrees), in radians */\r\n    public static readonly piOver4Radians = 7.85398163397448280000e-001;\r\n    /** maximal accuracy value of pi/2 ( 90 degrees), in radians */\r\n    public static readonly piOver2Radians = 1.57079632679489660000e+000;\r\n    /** maximal accuracy value of pi ( 180 degrees), in radians */\r\n    public static readonly piRadians = 3.14159265358979310000e+000;\r\n    /** maximal accuracy value of 2*pi (360 degrees), in radians */\r\n    public static readonly pi2Radians = 6.28318530717958620000e+000;\r\n    /** scale factor for converting degrees to radians */\r\n    public static readonly degreesPerRadian = (45.0 / Angle.piOver4Radians);\r\n    /** scale factor for converting radians to degrees */\r\n    public static readonly radiansPerDegree = (Angle.piOver4Radians / 45.0);\r\n    /** maximal accuracy value of pi/12 ( 15 degrees), in radians */\r\n    public static readonly piOver12Radians = 0.26179938779914943653855361527329;\r\n    private _radians: number;\r\n    private _degrees?: number;\r\n    private constructor(radians = 0, degrees?: number) { this._radians = radians; this._degrees = degrees; }\r\n    /** Return a new angle with the same content. */\r\n    public clone(): Angle { return new Angle(this._radians, this._degrees); }\r\n    /** Freeze this instance so it can be considered read-only */\r\n    public freeze() { Object.freeze(this); }\r\n\r\n    /**\r\n     * Return a new Angle object for angle given in degrees.\r\n     * @param degrees angle in degrees\r\n     */\r\n    public static createDegrees(degrees: number) { return new Angle(Angle.degreesToRadians(degrees), degrees); }\r\n    /**\r\n     * Return a (new) Angle object for a value given in radians.\r\n     * @param radians angle in radians\r\n     */\r\n    public static createRadians(radians: number) { return new Angle(radians); }\r\n    /**\r\n     * Return a (new) Angle object, with angle scaled from existing angle.\r\n     * @param scale scale factor to apply to angle.\r\n     */\r\n    public cloneScaled(scale: number) { return new Angle(this.radians * scale); }\r\n\r\n    /**\r\n     * Set this angle to a value given in radians.\r\n     * @param radians angle given in radians\r\n     */\r\n    public setRadians(radians: number) { this._radians = radians; this._degrees = undefined; }\r\n    /**\r\n     * Set this angle to a value given in degrees.\r\n     * @param degrees angle given in degrees.\r\n     */\r\n    public setDegrees(degrees: number) { this._radians = Angle.degreesToRadians(degrees); this._degrees = degrees; }\r\n    /** Create an angle for a full circle. */\r\n    public static create360() { return new Angle(Math.PI * 2.0, 360.0); }\r\n    /**\r\n     * @return a (strongly typed) Angle whose tangent is `numerator/denominator`, using the signs of both in determining the (otherwise ambiguous)\r\n     * quadrant.\r\n     * @param numerator numerator for tangent\r\n     * @param denominator denominator for tangent\r\n     */\r\n    public static createAtan2(numerator: number, denominator: number): Angle { return new Angle(Math.atan2(numerator, denominator)); }\r\n    /**\r\n     * Copy all contents of `other` to this Angle.\r\n     * @param other source data\r\n     */\r\n    public setFrom(other: Angle) { this._radians = other._radians; this._degrees = other._degrees; }\r\n    /**\r\n     * Create an Angle from a JSON object\r\n     * @param json object from JSON.parse. If a number, value is in *DEGREES*\r\n     * @param defaultValRadians if json is undefined, default value in radians.\r\n     * @return a new Angle\r\n     */\r\n    public static fromJSON(json?: AngleProps, defaultValRadians?: number): Angle {\r\n        const val = new Angle();\r\n        val.setFromJSON(json, defaultValRadians);\r\n        return val;\r\n    }\r\n    /**\r\n     * set an Angle from a JSON object\r\n     * * A simple number is degrees.\r\n     * * specified `json.degrees` or `json._degrees` is degree value.\r\n     * * specified `son.radians` or `json._radians` is radians value.\r\n     * @param json object from JSON.parse. If a number, value is in *DEGREES*\r\n     * @param defaultValRadians if json is undefined, default value in radians.\r\n     */\r\n    public setFromJSON(json?: AngleProps, defaultValRadians?: number) {\r\n        this._radians = defaultValRadians ? defaultValRadians : 0;\r\n        if (!json)\r\n            return;\r\n        if (typeof json === \"number\") {\r\n            this.setDegrees(json);\r\n        } else if (typeof (json as any).degrees === \"number\") {\r\n            this.setDegrees((json as any).degrees);\r\n        } else if (typeof (json as any)._degrees === \"number\") {\r\n            this.setDegrees((json as any)._degrees);\r\n        } else if (typeof (json as any).radians === \"number\") {\r\n            this.setRadians((json as any).radians);\r\n        } else if (typeof (json as any)._radians === \"number\") {\r\n            this.setRadians((json as any)._radians);\r\n        }\r\n    }\r\n    /** Convert an Angle to a JSON object as a number in degrees */\r\n    public toJSON(): AngleProps { return this.degrees; }\r\n    /** Return a json object with radians keyword, e.g. `{ radians: 0.10}` */\r\n    public toJSONRadians(): AngleProps { return { radians: this.radians }; }\r\n    /**  Return the angle measured in radians. */\r\n    public get radians(): number { return this._radians; }\r\n    /**  Return the angle measured in degrees. */\r\n    public get degrees(): number { return this._degrees !== undefined ? this._degrees : Angle.radiansToDegrees(this._radians); }\r\n    /**\r\n     * Convert an angle in degrees to radians.\r\n     * @param degrees angle in degrees\r\n     */\r\n    public static degreesToRadians(degrees: number) { return degrees * Math.PI / 180; }\r\n    /**\r\n     * Convert an angle in radians to degrees.\r\n     * @param degrees angle in radians\r\n     */\r\n    public static radiansToDegrees(radians: number): number {\r\n        if (radians < 0)\r\n            return -Angle.radiansToDegrees(-radians);\r\n        // Now radians is positive ...\r\n        const pi = Math.PI;\r\n        const factor = 180.0 / pi;\r\n        if (radians <= 0.25 * pi)\r\n            return factor * radians;\r\n        if (radians < 0.75 * pi)\r\n            return 90.0 + 180 * ((radians - 0.5 * pi) / pi);\r\n        if (radians <= 1.25 * pi)\r\n            return 180.0 + 180 * ((radians - pi) / pi);\r\n        if (radians <= 1.75 * pi)\r\n            return 270.0 + 180 * ((radians - 1.5 * pi) / pi);\r\n        // all larger radians reference from 360 degrees (2PI)\r\n        return 360.0 + 180 * ((radians - 2.0 * pi) / pi);\r\n    }\r\n    /**\r\n     * Return the cosine of this Angle object's angle.\r\n     */\r\n    public cos(): number { return Math.cos(this._radians); }\r\n    /**\r\n     * Return the sine of this Angle object's angle.\r\n     */\r\n    public sin(): number { return Math.sin(this._radians); }\r\n    /**\r\n     * Return the tangent of this Angle object's angle.\r\n     */\r\n    public tan(): number { return Math.tan(this._radians); }\r\n    /** Test if a radians value is nearly 2PI or larger (!) */\r\n    public static isFullCircleRadians(radians: number) { return Math.abs(radians) >= Geometry.fullCircleRadiansMinusSmallAngle; }\r\n    /** Test if the radians value  is a complete circle */\r\n    public static isHalfCircleRadians(radians: number) { return (Math.abs(Math.abs(radians)) - Math.PI) <= Geometry.smallAngleRadians; }\r\n    /** test if the angle is aa full circle */\r\n    public get isFullCircle(): boolean { return Angle.isFullCircleRadians(this._radians); }\r\n    /** test if the angle is a half circle (in either direction) */\r\n    public get isHalfCircle(): boolean { return Angle.isHalfCircleRadians(this._radians); }\r\n    /** Adjust a radians value so it is positive in 0..360 */\r\n    public static adjustDegrees0To360(degrees: number): number {\r\n        if (degrees >= 0) {\r\n            const period = 360.0;\r\n            if (degrees < period)\r\n                return degrees;\r\n            const numPeriods = Math.floor(degrees / period);\r\n            return degrees - numPeriods * period;\r\n        }\r\n        // negative angle ...\r\n        const radians1 = Angle.adjustDegrees0To360(-degrees);\r\n        return 360.0 - radians1;\r\n    }\r\n    /** Adjust a radians value so it is positive in -180..180 */\r\n    public static adjustDegreesSigned180(degrees: number): number {\r\n        if (Math.abs(degrees) <= 180.0)\r\n            return degrees;\r\n        if (degrees >= 0) {\r\n            const period = 360.0;\r\n            const numPeriods = 1 + Math.floor((degrees - 180.0) / period);\r\n            return degrees - numPeriods * period;\r\n        }\r\n        // negative angle ...\r\n        return -Angle.adjustDegreesSigned180(-degrees);\r\n    }\r\n    /** Adjust a radians value so it is positive in 0..2Pi */\r\n    public static adjustRadians0To2Pi(radians: number): number {\r\n        if (radians >= 0) {\r\n            const period = Math.PI * 2.0;\r\n            if (radians < period)\r\n                return radians;\r\n            const numPeriods = Math.floor(radians / period);\r\n            return radians - numPeriods * period;\r\n        }\r\n        // negative angle ...\r\n        const radians1 = Angle.adjustRadians0To2Pi(-radians);\r\n        return Math.PI * 2.0 - radians1;\r\n    }\r\n    /** Adjust a radians value so it is positive in -PI..PI */\r\n    public static adjustRadiansMinusPiPlusPi(radians: number): number {\r\n        if (Math.abs(radians) <= Math.PI)\r\n            return radians;\r\n        if (radians >= 0) {\r\n            const period = Math.PI * 2.0;\r\n            const numPeriods = 1 + Math.floor((radians - Math.PI) / period);\r\n            return radians - numPeriods * period;\r\n        }\r\n        // negative angle ...\r\n        return -Angle.adjustRadiansMinusPiPlusPi(-radians);\r\n    }\r\n    /** return a (newly allocated) Angle object with value 0 radians */\r\n    public static zero() { return new Angle(0); }\r\n    /** Test if the angle is exactly zero. */\r\n    public get isExactZero() { return this.radians === 0; }\r\n    /** Test if the angle is almost zero (within tolerance `Geometry.smallAngleRadians`) */\r\n    public get isAlmostZero() { return Math.abs(this.radians) < Geometry.smallAngleRadians; }\r\n    /** Create an angle object with degrees adjusted into 0..360. */\r\n    public static createDegreesAdjustPositive(degrees: number): Angle { return Angle.createDegrees(Angle.adjustDegrees0To360(degrees)); }\r\n    /** Create an angle object with degrees adjusted into -180..180. */\r\n    public static createDegreesAdjustSigned180(degrees: number): Angle { return Angle.createDegrees(Angle.adjustDegreesSigned180(degrees)); }\r\n    /**\r\n     * Test if two radians values are equivalent, allowing shift by full circle (i.e. by a multiple of `2*PI`)\r\n     * @param radiansA first radians value\r\n     * @param radiansB second radians value\r\n     */\r\n    public static isAlmostEqualRadiansAllowPeriodShift(radiansA: number, radiansB: number): boolean {\r\n        // try to get simple conclusions with un-shifted radians ...\r\n        const delta = Math.abs(radiansA - radiansB);\r\n        if (delta <= Geometry.smallAngleRadians)\r\n            return true;\r\n        const period = Math.PI * 2.0;\r\n        if (Math.abs(delta - period) <= Geometry.smallAngleRadians)\r\n            return true;\r\n        const numPeriod = Math.round(delta / period);\r\n        const delta1 = delta - numPeriod * period;\r\n        return Math.abs(delta1) <= Geometry.smallAngleRadians;\r\n    }\r\n    /**\r\n     * Test if this angle and other are equivalent, allowing shift by full circle (i.e. by a multiple of 360 degrees)\r\n     */\r\n    public isAlmostEqualAllowPeriodShift(other: Angle): boolean {\r\n        return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians, other._radians);\r\n    }\r\n    /**\r\n     * Test if two this angle and other are almost equal, NOT allowing shift by full circle multiples of 360 degrees.\r\n     */\r\n    public isAlmostEqualNoPeriodShift(other: Angle): boolean { return Math.abs(this._radians - other._radians) < Geometry.smallAngleRadians; }\r\n    /**\r\n     * Test if two angle (in radians)  almost equal, NOT allowing shift by full circle multiples of `2 * PI`.\r\n     * * (Same test as isAlmostEqualRadiansNoPeriodShift)\r\n     */\r\n    public isAlmostEqual(other: Angle): boolean { return this.isAlmostEqualNoPeriodShift(other); }\r\n    /**\r\n     * Test if two angle (in radians)  almost equal, NOT allowing shift by full circle multiples of `2 * PI`.\r\n     */\r\n    public static isAlmostEqualRadiansNoPeriodShift(radiansA: number, radiansB: number): boolean { return Math.abs(radiansA - radiansB) < Geometry.smallAngleRadians; }\r\n    /**\r\n     * Test if dot product values indicate non-zero length perpendicular vectors.\r\n     * @param dotUU dot product of vectorU with itself\r\n     * @param dotVV dot product of vectorV with itself\r\n     * @param dotUV dot product of vectorU with vectorV\r\n     */\r\n    public static isPerpendicularDotSet(dotUU: number, dotVV: number, dotUV: number) {\r\n        return dotUU > Geometry.smallMetricDistanceSquared\r\n            && dotVV > Geometry.smallMetricDistanceSquared\r\n            && dotUV * dotUV <= Geometry.smallAngleRadiansSquared * dotUU * dotVV;\r\n    }\r\n    /**\r\n     * Return cosine, sine, and radians for the half angle of a cosine,sine pair.\r\n     * @param rCos2A cosine value (scaled by radius) for initial angle.\r\n     * @param rSin2A sine value (scaled by radius) for final angle.\r\n     */\r\n    public static trigValuesToHalfAngleTrigValues(rCos2A: number, rSin2A: number): TrigValues {\r\n        const r = Geometry.hypotenuseXY(rCos2A, rSin2A);\r\n        if (r < Geometry.smallMetricDistance) {\r\n            return { c: 1.0, s: 0.0, radians: 0.0 };\r\n        } else {\r\n            /* If the caller really gave you sine and cosine values, r should be 1.  However,*/\r\n            /* to allow scaled values -- e.g. the x and y components of any vector -- we normalize*/\r\n            /* right here.  This adds an extra sqrt and 2 divides to the whole process, but improves*/\r\n            /* both the usefulness and robustness of the computation.*/\r\n            let cosA = 1.0;\r\n            let sinA = 0.0;\r\n            const cos2A = rCos2A / r;\r\n            const sin2A = rSin2A / r;\r\n            if (cos2A >= 0.0) {\r\n                /* Original angle in NE and SE quadrants.  Half angle in same quadrant */\r\n                cosA = Math.sqrt(0.5 * (1.0 + cos2A));\r\n                sinA = sin2A / (2.0 * (cosA));\r\n            } else {\r\n                if (sin2A > 0.0) {\r\n                    /* Original angle in NW quadrant. Half angle in NE quadrant */\r\n                    sinA = Math.sqrt(0.5 * (1.0 - cos2A));\r\n                } else {\r\n                    /* Original angle in SW quadrant. Half angle in SE quadrant*/\r\n                    /* cosA comes out positive because both sines are negative. */\r\n                    sinA = -Math.sqrt(0.5 * (1.0 - cos2A));\r\n                }\r\n                cosA = sin2A / (2.0 * (sinA));\r\n            }\r\n            return { c: cosA, s: sinA, radians: Math.atan2(sinA, cosA) };\r\n        }\r\n    }\r\n    /** If value is close to -1, -0.5, 0, 0.5, 1, adjust it to the exact value. */\r\n    public static cleanupTrigValue(value: number, tolerance: number = 1.0e-15): number {\r\n        const absValue = Math.abs(value);\r\n        if (absValue <= tolerance)\r\n            return 0;\r\n        let a = Math.abs(absValue - 0.5);\r\n        if (a <= tolerance)\r\n            return value < 0.0 ? -0.5 : 0.5;\r\n        a = Math.abs(absValue - 1.0);\r\n        if (a <= tolerance)\r\n            return value < 0.0 ? -1.0 : 1.0;\r\n        return value;\r\n    }\r\n    /**\r\n     * Return the half angle cosine, sine, and radians for given dot products between vectors.\r\n     * @param dotUU dot product of vectorU with itself\r\n     * @param dotVV dot product of vectorV with itself\r\n     * @param dotUV dot product of vectorU with vectorV\r\n     */\r\n    public static dotProductsToHalfAngleTrigValues(dotUU: number, dotVV: number, dotUV: number, favorZero: boolean = true): TrigValues {\r\n        const rCos = dotUU - dotVV;\r\n        const rSin = 2.0 * dotUV;\r\n        if (favorZero && Math.abs(rSin) < Geometry.smallAngleRadians * (Math.abs(dotUU) + Math.abs(dotVV)))\r\n            return { c: 1.0, s: 0.0, radians: 0.0 };\r\n        return Angle.trigValuesToHalfAngleTrigValues(rCos, rSin);\r\n    }\r\n    /**\r\n     * * Returns the angle between two vectors, with the vectors given as xyz components\r\n     * * The returned angle is between 0 and PI\r\n     *\r\n     * @param ux x component of vector u\r\n     * @param uy y component of vector u\r\n     * @param uz z component of vector u\r\n     * @param vx x component of vector v\r\n     * @param vy y component of vector v\r\n     * @param vz z component of vector v\r\n     */\r\n    public static radiansBetweenVectorsXYZ(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): number {\r\n        //  const uu = ux * ux + uy * uy + uz * uz;\r\n        const uDotV = ux * vx + uy * vy + uz * vz; // magU magV cos(theta)\r\n        //    const vv = vx * vx + vy * vy + vz * vz;\r\n        return Math.atan2(Geometry.crossProductMagnitude(ux, uy, uz, vx, vy, vz), uDotV);\r\n    }\r\n    /**\r\n     * Add a multiple of a full circle angle (360 degrees, 2PI) in place.\r\n     * @param multiple multiplier factor\r\n     */\r\n    public addMultipleOf2PiInPlace(multiple: number) {\r\n        if (this._degrees !== undefined) {\r\n            this._degrees += multiple * 360.0;\r\n            this._radians = Angle.degreesToRadians(this._degrees);\r\n        } else {\r\n            this._radians += multiple * Angle.pi2Radians;\r\n        }\r\n    }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { GrowableFloat64Array } from \"./GrowableFloat64Array\";\r\nimport { Angle } from \"./Angle\";\r\nimport { BeJSONFunctions, Geometry, AngleSweepProps } from \"../Geometry\";\r\n/** @module CartesianGeometry */\r\n/**\r\n * An `AngleSweep` is a pair of angles at start and end of an interval.\r\n *\r\n * *  For stroking purposes, the \"included interval\" is all angles numerically reached by theta = start + f*(end-start), where f is between 0 and 1.\r\n * *  This stroking formula is simple numbers -- 2PI shifts are not involved.\r\n * *  2PI shifts do become important in the reverse mapping of an angle to a fraction.\r\n * *  If (start < end) the angle proceeds CCW around the unit circle.\r\n * *  If (end < start) the angle proceeds CW around the unit circle.\r\n * *  Angles beyond 360 are fine as endpoints.\r\n *   *  (350,370) covers the same unit angles as (-10,10).\r\n *   *  (370,350) covers the same unit angles as (10,-10).\r\n * @public\r\n */\r\nexport class AngleSweep implements BeJSONFunctions {\r\n    private _radians0: number;\r\n    private _radians1: number;\r\n    /** Read-property for degrees at the start of this AngleSweep. */\r\n    public get startDegrees() { return Angle.radiansToDegrees(this._radians0); }\r\n    /** Read-property for degrees at the end of this AngleSweep. */\r\n    public get endDegrees() { return Angle.radiansToDegrees(this._radians1); }\r\n    /** Read-property for signed start-to-end sweep in degrees. */\r\n    public get sweepDegrees() { return Angle.radiansToDegrees(this._radians1 - this._radians0); }\r\n    /** Read-property for degrees at the start of this AngleSweep. */\r\n    public get startRadians() { return this._radians0; }\r\n    /** Read-property for degrees at the end of this AngleSweep. */\r\n    public get endRadians() { return this._radians1; }\r\n    /** Read-property for signed start-to-end sweep in radians. */\r\n    public get sweepRadians() { return this._radians1 - this._radians0; }\r\n    /** Return the (strongly typed) start angle */\r\n    public get startAngle() { return Angle.createRadians(this._radians0); }\r\n    /** Return the (strongly typed) end angle */\r\n    public get endAngle() { return Angle.createRadians(this._radians1); }\r\n    /** (private) constructor with start and end angles in radians.\r\n     *  * Use explicitly named static methods to clarify intent and units of inputs:\r\n     *\r\n     * * createStartEndRadians (startRadians:number, endRadians:number)\r\n     * * createStartEndDegrees (startDegrees:number, endDegrees:number)\r\n     * * createStartEnd (startAngle:Angle, endAngle:Angle)\r\n     * * createStartSweepRadians (startRadians:number, sweepRadians:number)\r\n     * * createStartSweepDegrees (startDegrees:number, sweepDegrees:number)\r\n     * * createStartSweep (startAngle:Angle, sweepAngle:Angle)\r\n     */\r\n    private constructor(startRadians: number = 0, endRadians: number = 0) { this._radians0 = startRadians; this._radians1 = endRadians; }\r\n    /** create an AngleSweep from start and end angles given in radians. */\r\n    public static createStartEndRadians(startRadians: number = 0, endRadians: number = 2.0 * Math.PI, result?: AngleSweep): AngleSweep {\r\n        result = result ? result : new AngleSweep();\r\n        result.setStartEndRadians(startRadians, endRadians);\r\n        return result;\r\n    }\r\n    /** Return the angle obtained by subtracting radians from this angle. */\r\n    public cloneMinusRadians(radians: number): AngleSweep { return new AngleSweep(this._radians0 - radians, this._radians1 - radians); }\r\n    /** create an AngleSweep from start and end angles given in degrees. */\r\n    public static createStartEndDegrees(startDegrees: number = 0, endDegrees: number = 360, result?: AngleSweep): AngleSweep {\r\n        return AngleSweep.createStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(endDegrees), result);\r\n    }\r\n    /** create an angle sweep from strongly typed start and end angles */\r\n    public static createStartEnd(startAngle: Angle, endAngle: Angle, result?: AngleSweep): AngleSweep {\r\n        result = result ? result : new AngleSweep();\r\n        result.setStartEndRadians(startAngle.radians, endAngle.radians);\r\n        return result;\r\n    }\r\n    /** Create an angle sweep with limits given as (strongly typed) angles for start and sweep */\r\n    public static createStartSweep(startAngle: Angle, sweepAngle: Angle, result?: AngleSweep): AngleSweep {\r\n        return AngleSweep.createStartSweepRadians(startAngle.radians, sweepAngle.radians, result);\r\n    }\r\n    /** Return a sweep with limits interpolated between this and other. */\r\n    public interpolate(fraction: number, other: AngleSweep): AngleSweep {\r\n        return new AngleSweep(Geometry.interpolate(this._radians0, fraction, other._radians0), Geometry.interpolate(this._radians1, fraction, other._radians1));\r\n    }\r\n    /** create an AngleSweep from start and end angles given in radians. */\r\n    public static createStartSweepRadians(startRadians: number = 0, sweepRadians: number = Math.PI, result?: AngleSweep): AngleSweep {\r\n        result = result ? result : new AngleSweep();\r\n        result.setStartEndRadians(startRadians, startRadians + sweepRadians);\r\n        return result;\r\n    }\r\n    /** create an AngleSweep from start and sweep given in degrees.  */\r\n    public static createStartSweepDegrees(startDegrees: number = 0, sweepDegrees: number = 360, result?: AngleSweep): AngleSweep {\r\n        return AngleSweep.createStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(startDegrees + sweepDegrees), result);\r\n    }\r\n    /** directly set the start and end angles in radians */\r\n    public setStartEndRadians(startRadians: number = 0, endRadians: number = 2.0 * Math.PI) {\r\n        const delta = endRadians - startRadians;\r\n        if (Angle.isFullCircleRadians(delta)) {\r\n            endRadians = startRadians + (delta > 0 ? 2.0 : -2.0) * Math.PI;\r\n        }\r\n        this._radians0 = startRadians;\r\n        this._radians1 = endRadians;\r\n    }\r\n    /** directly set the start and end angles in degrees */\r\n    public setStartEndDegrees(startDegrees: number = 0, endDegrees: number = 360.0) {\r\n        this.setStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(endDegrees));\r\n    }\r\n    /** copy from other AngleSweep. */\r\n    public setFrom(other: AngleSweep) { this._radians0 = other._radians0; this._radians1 = other._radians1; }\r\n    /** create a full circle sweep (CCW). startRadians defaults to 0 */\r\n    public static create360(startRadians?: number): AngleSweep {\r\n        startRadians = startRadians ? startRadians : 0.0;\r\n        return new AngleSweep(startRadians, startRadians + 2.0 * Math.PI);\r\n    }\r\n    /** create a sweep from the south pole to the north pole. */\r\n    public static createFullLatitude() { return AngleSweep.createStartEndRadians(-0.5 * Math.PI, 0.5 * Math.PI); }\r\n    /** Reverse the start and end angle in place. */\r\n    public reverseInPlace() { const a = this._radians0; this._radians0 = this._radians1; this._radians1 = a; }\r\n    /** Restrict start and end angles into the range (-90,+90) in degrees. */\r\n    public capLatitudeInPlace() {\r\n        const limit = 0.5 * Math.PI;\r\n        this._radians0 = Geometry.clampToStartEnd(this._radians0, -limit, limit);\r\n        this._radians1 = Geometry.clampToStartEnd(this._radians1, -limit, limit);\r\n    }\r\n    /** Ask if the sweep is counterclockwise, i.e. positive sweep */\r\n    public get isCCW(): boolean { return this._radians1 >= this._radians0; }\r\n    /** Ask if the sweep is a full circle. */\r\n    public get isFullCircle(): boolean { return Angle.isFullCircleRadians(this.sweepRadians); }\r\n    /** Ask if the sweep is a full sweep from south pole to north pole. */\r\n    public get isFullLatitudeSweep(): boolean {\r\n        const a = Math.PI * 0.5;\r\n        return Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, -a)\r\n            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1, a);\r\n    }\r\n    /** return a clone of this sweep. */\r\n    public clone(): AngleSweep { return new AngleSweep(this._radians0, this._radians1); }\r\n    /** Convert fractional position in the sweep to radians. */\r\n    public fractionToRadians(fraction: number) {\r\n        return fraction < 0.5 ?\r\n            this._radians0 + fraction * (this._radians1 - this._radians0)\r\n            : this._radians1 + (fraction - 1.0) * (this._radians1 - this._radians0);\r\n    }\r\n    /** Convert fractional position in the sweep to strongly typed Angle object. */\r\n    public fractionToAngle(fraction: number) {\r\n        return Angle.createRadians(this.fractionToRadians(fraction));\r\n    }\r\n    /** return 2PI divided by the sweep radians (i.e. 360 degrees divided by sweep angle).\r\n     * This is the number of fractional intervals required to cover a whole circle.\r\n     */\r\n    public fractionPeriod(): number {\r\n        return Geometry.safeDivideFraction(Math.PI * 2.0, Math.abs(this._radians1 - this._radians0), 1.0);\r\n    }\r\n    /** return the fractionalized position of the angle,\r\n     * computed without consideration of 2PI period.\r\n     * That is, an angle that is numerically much beyond than the end angle\r\n     * will produce a large fraction and an angle much beyond the start angle\r\n     * will produce a large negative fraction.\r\n     *\r\n     */\r\n    public angleToUnboundedFraction(theta: Angle): number {\r\n        return Geometry.safeDivideFraction(theta.radians - this._radians0, this._radians1 - this._radians0, 1.0);\r\n    }\r\n    /** map an angle to a fractional coordinate which is:\r\n     *\r\n     * *  the start angle is at fraction 0\r\n     * *  the end angle is at fraction 1\r\n     * *  interior angles are between 0 and 1\r\n     * *  all exterior angles are at fractions greater than 1\r\n     * *  the periodic jump is at full wraparound to the start angle\r\n     */\r\n    public angleToPositivePeriodicFraction(theta: Angle): number { return this.radiansToPositivePeriodicFraction(theta.radians); }\r\n    /**\r\n     * Convert each value in an array from radians to fraction.\r\n     * @param data array that is input as radians, output as fractions\r\n     */\r\n    public radiansArraytoPositivePeriodicFractions(data: GrowableFloat64Array) {\r\n        const n = data.length;\r\n        for (let i = 0; i < n; i++) {\r\n            data.reassign(i, this.radiansToPositivePeriodicFraction(data.atUncheckedIndex(i)));\r\n        }\r\n    }\r\n    /**\r\n     * Convert a radians value to a fraction that is always positive and can wrap.  See `angleToPositivePeriodicFraction` for detailed description.\r\n     * @param radians\r\n     */\r\n    public radiansToPositivePeriodicFraction(radians: number): number {\r\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))\r\n            return 0.0;\r\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))\r\n            return 1.0;\r\n        const sweep = this._radians1 - this._radians0;\r\n        const delta = radians - this._radians0;\r\n        if (sweep > 0) {\r\n            const delta1 = Angle.adjustRadians0To2Pi(delta);\r\n            const fraction1 = Geometry.safeDivideFraction(delta1, sweep, 0.0);\r\n            return fraction1;\r\n        }\r\n        const delta2 = Angle.adjustRadians0To2Pi(-delta);\r\n        const fraction2 = Geometry.safeDivideFraction(delta2, -sweep, 0.0);\r\n        return fraction2;\r\n    }\r\n    /** map an angle to a fractional coordinate which is:\r\n     *\r\n     * *  the start angle is at fraction 0\r\n     * *  the end angle is at fraction 1\r\n     * *  interior angles are between 0 and 1\r\n     * *  small negative for angles just \"before\" the start angle\r\n     * *  more than one for angles just \"after\" the end angle\r\n     * *  the periodic jump is at the middle of the \"outside\" interval\r\n     */\r\n    public angleToSignedPeriodicFraction(theta: Angle): number {\r\n        return this.radiansToSignedPeriodicFraction(theta.radians);\r\n    }\r\n    /**\r\n     * Convert a radians value to a fraction, allowing wraparound.  See `angleToSignedPeriodicFraction` for detailed description.\r\n     */\r\n    public radiansToSignedPeriodicFraction(radians: number): number {\r\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))\r\n            return 0.0;\r\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))\r\n            return 1.0;\r\n        const sweep = this._radians1 - this._radians0;\r\n        // measure from middle of interval ...\r\n        const delta = radians - this._radians0 - 0.5 * sweep;\r\n        if (sweep > 0) {\r\n            const delta1 = Angle.adjustRadiansMinusPiPlusPi(delta);\r\n            const fraction1 = 0.5 + Geometry.safeDivideFraction(delta1, sweep, 0.0);\r\n            return fraction1;\r\n        }\r\n        const delta2 = Angle.adjustRadiansMinusPiPlusPi(-delta);\r\n        const fraction = 0.5 + Geometry.safeDivideFraction(delta2, -sweep, 0.0);\r\n        return fraction;\r\n    }\r\n    /** test if an angle is within the sweep */\r\n    public isAngleInSweep(angle: Angle): boolean { return this.isRadiansInSweep(angle.radians); }\r\n    /** test if radians are within sweep  */\r\n    public isRadiansInSweep(radians: number): boolean {\r\n        // quick out for simple inside ...\r\n        const delta0 = radians - this._radians0;\r\n        const delta1 = radians - this._radians1;\r\n        if (delta0 * delta1 <= 0.0)\r\n            return true;\r\n        return this.radiansToPositivePeriodicFraction(radians) <= 1.0;\r\n    }\r\n    /** set this AngleSweep from various sources:\r\n     *\r\n     * * if json is undefined, a full-circle sweep is returned.\r\n     * * If json is an AngleSweep object it is is cloned\r\n     * * If json is an array of 2 numbers, those numbers are start and end angles in degrees.\r\n     * * If `json.degrees` is an array of 2 numbers, those numbers are start and end angles in degrees.\r\n     * * If `json.radians` is an array of 2 numbers, those numbers are start and end angles in radians.\r\n     */\r\n    public setFromJSON(json?: any) {\r\n        if (!json)\r\n            this.setStartEndRadians(); // default full circle\r\n        else if (json instanceof AngleSweep)\r\n            this.setFrom(json as AngleSweep);\r\n        else if (Geometry.isNumberArray(json.degrees, 2))\r\n            this.setStartEndDegrees(json.degrees[0], json.degrees[1]);\r\n        else if (Geometry.isNumberArray(json.radians, 2))\r\n            this.setStartEndRadians(json.radians[0], json.radians[1]);\r\n        else if (Geometry.isNumberArray(json, 2))\r\n            this.setStartEndDegrees(json[0], json[1]);\r\n    }\r\n    /** create an AngleSweep from a json object. */\r\n    public static fromJSON(json?: AngleSweepProps) {\r\n        const result = AngleSweep.create360();\r\n        result.setFromJSON(json);\r\n        return result;\r\n    }\r\n    /**\r\n     * Convert an AngleSweep to a JSON object.\r\n     * @return {*} {degrees: [startAngleInDegrees, endAngleInDegrees}\r\n     */\r\n    public toJSON(): any {\r\n        // return { degrees: [this.startDegrees, this.endDegrees] };\r\n        return [this.startDegrees, this.endDegrees];\r\n    }\r\n    /** test if start and end angles match, with explicit name to clarify that there is no test for 360-degree shifts. */\r\n    public isAlmostEqualAllowPeriodShift(other: AngleSweep): boolean {\r\n        return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians0, other._radians0)\r\n            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);\r\n    }\r\n    /** test if start and end angles match, explicit name to clarify that 360-degree shifts are allowed. */\r\n    public isAlmostEqualNoPeriodShift(other: AngleSweep): boolean {\r\n        return Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, other._radians0)\r\n            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);\r\n    }\r\n    /** test if start and end angles match with radians tolerance.\r\n     * * This is equivalent to isAlmostEqualNoPeriodShift.\r\n     * * it is present for consistency with other classes\r\n     * * It is recommended that all callers use one of he longer names to be clear of their intentions:\r\n     * * * isAlmostEqualAllowPeriodShift\r\n     * * * isAlmostEqualRadiansNoPeriodShift\r\n     */\r\n    public isAlmostEqual(other: AngleSweep): boolean { return this.isAlmostEqualNoPeriodShift(other); }\r\n}\r\n","import { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Geometry } from \"../Geometry\";\r\n\r\n/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\n/**\r\n * 3 points defining a triangle to be evaluated with Barycentric coordinates.\r\n * @public\r\n */\r\nexport class BarycentricTriangle {\r\n  /** Array of 3 point coordinates for the triangle. */\r\n  public points: Point3d[];\r\n  /** Constructor.\r\n   * * Point references are CAPTURED\r\n   */\r\n  protected constructor(point0: Point3d, point1: Point3d, point2: Point3d) {\r\n    this.points = [];\r\n    this.points.push(point0);\r\n    this.points.push(point1);\r\n    this.points.push(point2);\r\n  }\r\n\r\n  /**\r\n   * Return a `BarycentricTriangle` with coordinates given by enumerated x,y,z of the 3 points.\r\n   * @param result optional pre-allocated triangle.\r\n   */\r\n  public static createXYZXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, x2: number, y2: number, z2: number, result?: BarycentricTriangle): BarycentricTriangle {\r\n    if (!result) return new this(Point3d.create(x0, y0, z0), Point3d.create(x1, y1, z1), Point3d.create(x2, y2, z2));\r\n    result.points[0].set(x0, y0, z0);\r\n    result.points[1].set(x1, y1, z1);\r\n    result.points[2].set(x2, y2, z2);\r\n    return result;\r\n  }\r\n  /** create a triangle with coordinates cloned from given points. */\r\n  public static create(point0: Point3d, point1: Point3d, point2: Point3d, result?: BarycentricTriangle): BarycentricTriangle {\r\n    if (!result)\r\n      return new this(point0.clone(), point1.clone(), point2.clone());\r\n    result.set(point0, point1, point2);\r\n    return result;\r\n  }\r\n  /** Return a new `BarycentricTriangle` with the same coordinates. */\r\n  public clone(result?: BarycentricTriangle): BarycentricTriangle {\r\n    return BarycentricTriangle.create(this.points[0], this.points[1], this.points[2], result);\r\n  }\r\n\r\n  /** Return area divided by sum of squared lengths. */\r\n  public get aspectRatio(): number {\r\n    return Geometry.safeDivideFraction(0.5 * this.points[0].crossProductToPointsMagnitude(this.points[1], this.points[2]),\r\n      (this.points[0].distanceSquared(this.points[1]) + this.points[1].distanceSquared(this.points[2]) + this.points[2].distanceSquared(this.points[0])), 0);\r\n  }\r\n  /** Return the area of the triangle. */\r\n  public get area(): number {\r\n    return 0.5 * this.points[0].crossProductToPointsMagnitude(this.points[1], this.points[2]);\r\n  }\r\n  /** Sum the points with given scales.\r\n   * * In normal use, the scales will add to 1 and the result point is in the plane of the triangle.\r\n   * * If scales do not add to 1, the point is in the triangle scaled (by the scale sum) from the origin.\r\n   */\r\n  public fractionToPoint(a0: number, a1: number, a2: number, result?: Point3d): Point3d {\r\n    return Point3d.createAdd3Scaled(this.points[0], a0, this.points[1], a1, this.points[2], a2, result);\r\n  }\r\n\r\n  /** Copy all values from `other`\r\n   */\r\n  public setFrom(other: BarycentricTriangle) {\r\n    this.points[0].setFromPoint3d(other.points[0]);\r\n    this.points[1].setFromPoint3d(other.points[1]);\r\n    this.points[2].setFromPoint3d(other.points[2]);\r\n  }\r\n  /** copy contents of (not pointers to) the given points. */\r\n  public set(point0: Point3d | undefined, point1: Point3d | undefined, point2: Point3d | undefined) {\r\n    this.points[0].setFromPoint3d(point0);\r\n    this.points[1].setFromPoint3d(point1);\r\n    this.points[2].setFromPoint3d(point2);\r\n\r\n  }\r\n  private static _workVector0?: Vector3d;\r\n  private static _workVector1?: Vector3d;\r\n  /**\r\n   * * For `this` and `other` BarycentricTriangles, compute cross products of vectors from point0 to point1 and from point0 to point2.\r\n   * * return the dot product of those two\r\n   */\r\n  public dotProductOfCrossProductsFromOrigin(other: BarycentricTriangle): number {\r\n    BarycentricTriangle._workVector0 = this.points[0].crossProductToPoints(this.points[1], this.points[2], BarycentricTriangle._workVector0);\r\n    BarycentricTriangle._workVector1 = other.points[0].crossProductToPoints(other.points[1], other.points[2], BarycentricTriangle._workVector1);\r\n    return BarycentricTriangle._workVector0.dotProduct(BarycentricTriangle._workVector1);\r\n  }\r\n  /** Return the centroid of the 3 points. */\r\n  public centroid(result?: Point3d): Point3d {\r\n    // write it out to get single scale application.\r\n    // Do the scale as true division (rather than multiply by precomputed 1/3).  This might protect one bit of result.\r\n    return Point3d.create(\r\n      (this.points[0].x + this.points[1].x + this.points[2].x) / 3.0,\r\n      (this.points[0].y + this.points[1].y + this.points[2].y) / 3.0,\r\n      (this.points[0].z + this.points[1].z + this.points[2].z) / 3.0,\r\n      result);\r\n  }\r\n  /** test for point-by-point `isAlmostEqual` relationship. */\r\n  public isAlmostEqual(other: BarycentricTriangle): boolean {\r\n    return this.points[0].isAlmostEqual(other.points[0])\r\n      && this.points[1].isAlmostEqual(other.points[1])\r\n      && this.points[2].isAlmostEqual(other.points[2]);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d } from \"./Point3dVector3d\";\r\nimport { Range3d } from \"./Range\";\r\nimport { Transform } from \"./Transform\";\r\n\r\nimport { UVSurface } from \"./GeometryHandler\";\r\nimport { Plane3dByOriginAndVectors } from \"./Plane3dByOriginAndVectors\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { SmallSystem } from \"../numerics/Polynomials\";\r\nimport { CurveLocationDetail } from \"../curve/CurveLocationDetail\";\r\nimport { Ray3d } from \"./Ray3d\";\r\nimport { CurveAndSurfaceLocationDetail, UVSurfaceLocationDetail } from \"../bspline/SurfaceLocationDetail\";\r\n\r\n/**\r\n * * A Bilinear patch is defined by its 4 corner points.\r\n * * the corner points do not have to be coplanar\r\n *\r\n * *    v direction (up)\r\n *      |\r\n *      |\r\n *      |\r\n *  point01---A1-----------point11\r\n *      |     |             |\r\n *      B0----X------------B1\r\n *      |     |             |\r\n *  point00--A0-----------point10 -----------> u direction\r\n *\r\n * * To evaluate aa point at (u,v), the following are equivalent:\r\n *   * interpolate with u to get both A0 and A1, viz\r\n *      * A0 = interpolate between point00 and point10 at fraction u\r\n *      * A1 = interpolate between point01 and point11 at fraction u\r\n *      * X = interpolate between A0 and A1 at fraction v\r\n *   * interpolate first with v to get B0 and B1, viz\r\n *      * B0 = interpolate between point00 and point01 at fraction v\r\n *      * B1 = interpolate between point10 and point11 at fraction v\r\n *      * X = interpolate between B0 and B1 at fraction u\r\n *   * sum all at once as\r\n *      * X = (1-u)* (1-v) *point00 + (1-u)*v * point01 + u * (1-v) *point10 + u* v * point11\r\n *\r\n * @internal\r\n */\r\nexport class BilinearPatch implements UVSurface {\r\n  /** corner at parametric coordinate (0,0) */\r\n  public point00: Point3d;\r\n  /** corner at parametric coordinate (1,0) */\r\n  public point10: Point3d;\r\n  /** corner at parametric coordinate (0,1) */\r\n  public point01: Point3d;\r\n  /** corner at parametric coordinate (1,1) */\r\n  public point11: Point3d;\r\n  /**\r\n   * Capture (not clone) corner points, in u direction at v=0, then in same direction at v=1\r\n   * @param point00 Point at uv=0,0\r\n   * @param point10 Point at uv=1,0\r\n   * @param point10 Point at uv=0,1\r\n   * @param point11 Point at uv=11\r\n   */\r\n  public constructor(point00: Point3d, point10: Point3d, point01: Point3d, point11: Point3d) {\r\n    this.point00 = point00;\r\n    this.point10 = point10;\r\n    this.point01 = point01;\r\n    this.point11 = point11;\r\n  }\r\n  /** clone (not capture) corners to create a new BilinearPatch\r\n   * @param point00 Point at uv=0,0\r\n   * @param point10 Point at uv=1,0\r\n   * @param point10 Point at uv=0,1\r\n   * @param point11 Point at uv=11\r\n   */\r\n  public static create(point00: Point3d, point10: Point3d, point01: Point3d, point11: Point3d) {\r\n    return new BilinearPatch(point00.clone(), point10.clone(), point01.clone(), point11.clone());\r\n  }\r\n\r\n  /** create a patch with from xyz values of the 4 corners\r\n   */\r\n  public static createXYZ(x00: number, y00: number, z00: number,\r\n    x10: number, y10: number, z10: number,\r\n    x01: number, y01: number, z01: number,\r\n    x11: number, y11: number, z11: number) {\r\n    return new BilinearPatch(Point3d.create(x00, y00, z00),\r\n      Point3d.create(x10, y10, z10),\r\n      Point3d.create(x01, y01, z01),\r\n      Point3d.create(x11, y11, z11));\r\n  }\r\n\r\n  /** return a clone with same coordinates */\r\n  public clone(): BilinearPatch {\r\n    return new BilinearPatch(\r\n      this.point00.clone(),\r\n      this.point10.clone(),\r\n      this.point01.clone(),\r\n      this.point11.clone());\r\n  }\r\n  /** test equality of the 4 points */\r\n  public isAlmostEqual(other: BilinearPatch): boolean {\r\n    return this.point00.isAlmostEqual(other.point00)\r\n      && this.point10.isAlmostEqual(other.point10)\r\n      && this.point01.isAlmostEqual(other.point01)\r\n      && this.point11.isAlmostEqual(other.point11);\r\n  }\r\n  /** Apply the transform to each point */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    transform.multiplyPoint3d(this.point00, this.point00);\r\n    transform.multiplyPoint3d(this.point10, this.point10);\r\n    transform.multiplyPoint3d(this.point01, this.point01);\r\n    transform.multiplyPoint3d(this.point11, this.point11);\r\n    return true;\r\n  }\r\n  /**\r\n   * return a cloned and transformed patch.\r\n   * @param transform\r\n   */\r\n  public cloneTransformed(transform: Transform): BilinearPatch | undefined {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n  /** Extend a range by the range of the(optionally transformed) patch\r\n   */\r\n  public extendRange(range: Range3d, transform?: Transform) {\r\n    if (transform) {\r\n      range.extendTransformedPoint(transform, this.point00);\r\n      range.extendTransformedPoint(transform, this.point10);\r\n      range.extendTransformedPoint(transform, this.point01);\r\n      range.extendTransformedPoint(transform, this.point11);\r\n    } else {\r\n      range.extendPoint(this.point00);\r\n      range.extendPoint(this.point10);\r\n      range.extendPoint(this.point01);\r\n      range.extendPoint(this.point11);\r\n    }\r\n  }\r\n  /** Evaluate as a uv surface\r\n   * @param u fractional position in minor (phi)\r\n   * @param v fractional position on major (theta) arc\r\n   */\r\n  public uvFractionToPoint(u: number, v: number, result?: Point3d): Point3d {\r\n    const f00 = (1.0 - u) * (1.0 - v);\r\n    const f10 = u * (1.0 - v);\r\n    const f01 = (1.0 - u) * v;\r\n    const f11 = u * v;\r\n    return Point3d.create(\r\n      f00 * this.point00.x + f10 * this.point10.x + f01 * this.point01.x + f11 * this.point11.x,\r\n      f00 * this.point00.y + f10 * this.point10.y + f01 * this.point01.y + f11 * this.point11.y,\r\n      f00 * this.point00.z + f10 * this.point10.z + f01 * this.point01.z + f11 * this.point11.z,\r\n      result);\r\n  }\r\n  /** Evaluate as a uv surface, returning point and two derivative vectors.\r\n   * @param u fractional position\r\n   * @param v fractional position\r\n   */\r\n  public uvFractionToPointAndTangents(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const u0 = 1.0 - u;\r\n    const v0 = 1.0 - v;\r\n    const f00 = u0 * v0;\r\n    const f10 = u * v0;\r\n    const f01 = u0 * v;\r\n    const f11 = u * v;\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(\r\n      f00 * this.point00.x + f10 * this.point10.x + f01 * this.point01.x + f11 * this.point11.x,\r\n      f00 * this.point00.y + f10 * this.point10.y + f01 * this.point01.y + f11 * this.point11.y,\r\n      f00 * this.point00.z + f10 * this.point10.z + f01 * this.point01.z + f11 * this.point11.z,\r\n      // u derivative ..\r\n      v0 * (this.point10.x - this.point00.x) + v * (this.point11.x - this.point01.x),\r\n      v0 * (this.point10.y - this.point00.y) + v * (this.point11.y - this.point01.y),\r\n      v0 * (this.point10.z - this.point00.z) + v * (this.point11.z - this.point01.z),\r\n      // v derivative ..\r\n      u0 * (this.point01.x - this.point00.x) + u * (this.point11.x - this.point10.x),\r\n      u0 * (this.point01.y - this.point00.y) + u * (this.point11.y - this.point10.y),\r\n      u0 * (this.point01.z - this.point00.z) + u * (this.point11.z - this.point10.z),\r\n      result);\r\n  }\r\n  /** if data[ib][pivotColumn] is larger (abs) than data[ia][pivotColumn] swap the iA and iB arrays */\r\n  private static conditionalPivot(pivotColumn: number, data: Float64Array[], iA: number, iB: number) {\r\n    if (Math.abs(data[iB][pivotColumn]) > Math.abs(data[iA][pivotColumn])) {\r\n      const q = data[iA];\r\n      data[iA] = data[iB];\r\n      data[iB] = q;\r\n    }\r\n  }\r\n  /**\r\n   * Compute the (points of) intersection with a ray.\r\n   * @param ray ray in space\r\n   * @returns 1 or 2 points if there are intersections, undefined if no intersections\r\n   */\r\n  public intersectRay(ray: Ray3d): CurveAndSurfaceLocationDetail[] | undefined {\r\n    const vectorU = this.point10.minus(this.point00);\r\n    const vectorV = this.point01.minus(this.point00);\r\n    const vectorW = this.point11.minus(this.point10);\r\n    vectorW.subtractInPlace(vectorV);\r\n    // coefficients of (each component of)\r\n    //    `ray.origin + t * ray.direction = point00 + u * vectorU + v * vectorV + u*v*vectorW`\r\n    // for x as typical direction as x, the scalar equation with coefficient order for arrays is\r\n    //    `0 = -ray.origin.x * t + (point00.x - ray.origin.x) + u * vectorU.x + v * vectorV.x + u * v * vectorW.x`\r\n    // (and that particular equation is invoked to isolate t when uv is known)\r\n    const coffs = [\r\n      new Float64Array([-ray.direction.x, this.point00.x - ray.origin.x, vectorU.x, vectorV.x, vectorW.x]),\r\n      new Float64Array([-ray.direction.y, this.point00.y - ray.origin.y, vectorU.y, vectorV.y, vectorW.y]),\r\n      new Float64Array([-ray.direction.z, this.point00.z - ray.origin.z, vectorU.z, vectorV.z, vectorW.z])];\r\n    // bring the largest ray.direction coefficient to the 0 equation.\r\n    BilinearPatch.conditionalPivot(0, coffs, 0, 1);\r\n    BilinearPatch.conditionalPivot(0, coffs, 0, 2);\r\n    SmallSystem.eliminateFromPivot(coffs[0], 0, coffs[1], -1.0);\r\n    SmallSystem.eliminateFromPivot(coffs[0], 0, coffs[2], -1.0);\r\n    const uvArray = SmallSystem.solveBilinearPair(\r\n      coffs[1][1], coffs[1][2], coffs[1][3], coffs[1][4],\r\n      coffs[2][1], coffs[2][2], coffs[2][3], coffs[2][4]);\r\n    if (uvArray) {\r\n      const result: CurveAndSurfaceLocationDetail[] = [];\r\n      for (const uv of uvArray) {\r\n        const t = -(coffs[0][1] + coffs[0][2] * uv.x + (coffs[0][3] + coffs[0][4] * uv.x) * uv.y) / coffs[0][0];\r\n        const point = ray.fractionToPoint(t);\r\n        result.push(new CurveAndSurfaceLocationDetail(\r\n          CurveLocationDetail.createRayFractionPoint(ray, t, point),\r\n          UVSurfaceLocationDetail.createSurfaceUVPoint(this, uv, point)));\r\n      }\r\n      return result;\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Returns the larger of the u-direction edge lengths at v=0 and v=1\r\n   */\r\n  public maxUEdgeLength(): number {\r\n    return Geometry.maxXY(this.point00.distance(this.point10), this.point01.distance(this.point11));\r\n  }\r\n  /**\r\n   * Returns the larger of the v-direction edge lengths at u=0 and u=1\r\n   */\r\n  public maxVEdgeLength(): number {\r\n    return Geometry.maxXY(this.point00.distance(this.point01), this.point10.distance(this.point11));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { Geometry, AxisOrder, AxisScaleSelect } from \"../Geometry\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { Range3d } from \"./Range\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { Point3dArray } from \"./PointHelpers\";\r\nimport { PolygonOps } from \"./PolygonOps\";\r\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\r\n/**\r\n * Helper class to accumulate points and vectors until there is enough data to define a coordinate system.\r\n *\r\n * * For the common case of building a right handed frame:\r\n *   * create the FrameBuilder and make calls to announcePoint and announceVector.\r\n *   * the frame will be fully determined by an origin and two vectors.\r\n *   * the first call to announcePoint will set the origin.\r\n *   *  additional calls to announcePoint will produce announceVector call with the vector from the origin.\r\n *   * After each announcement, call getValidatedFrame(false)\r\n *   * getValidatedFrame will succeed when it has two independent vectors.\r\n * *  to build a left handed frame,\r\n *   *  an origin and 3 independent vectors are required.\r\n *   *  announce as above, but query with getValidatedFrame (true).\r\n *   *  this will use the third vector to select right or left handed frame.\r\n * @public\r\n */\r\nexport class FrameBuilder {\r\n  private _origin: undefined | Point3d;\r\n  private _vector0: undefined | Vector3d;\r\n  private _vector1: undefined | Vector3d;\r\n  private _vector2: undefined | Vector3d;\r\n  // test if both vectors are defined and have significant angle between.\r\n  private areStronglyIndependentVectors(vector0: Vector3d, vector1: Vector3d, radiansTolerance: number = Geometry.smallAngleRadians): boolean {\r\n    if (vector0 !== undefined && vector1 !== undefined) {\r\n      const q = vector0.smallerUnorientedRadiansTo(vector1);\r\n      return q > radiansTolerance;\r\n    }\r\n    return false;\r\n  }\r\n  /** clear all accumulated point and vector data */\r\n  public clear() { this._origin = undefined; this._vector0 = undefined; this._vector1 = undefined; this._vector2 = undefined; }\r\n  constructor() { this.clear(); }\r\n  /** Try to assemble the data into a non-singular transform.\r\n   *\r\n   * * If allowLeftHanded is false, vector0 and vector1 determine a right handed coordinate system.\r\n   * * if allowLeftHanded is true, the z vector of the right handed system can be flipped to agree with vector2 direction.\r\n   */\r\n  public getValidatedFrame(allowLeftHanded: boolean = false): Transform | undefined {\r\n    if (this._origin && this._vector0 && this._vector1) {\r\n      if (!allowLeftHanded) {\r\n        const matrix = Matrix3d.createRigidFromColumns(this._vector0, this._vector1, AxisOrder.XYZ);\r\n        if (matrix)\r\n          return Transform.createOriginAndMatrix(this._origin, matrix);\r\n        // uh oh -- vector1 was not really independent.  clear everything after vector0.\r\n        this._vector1 = this._vector2 = undefined;\r\n      } else if (this._vector2) {\r\n        const matrix = Matrix3d.createRigidFromColumns(this._vector0, this._vector1, AxisOrder.XYZ);\r\n        if (matrix) {\r\n          if (this._vector0.tripleProduct(this._vector1, this._vector2) < 0)\r\n            matrix.scaleColumns(1.0, 1.0, -1.0);\r\n          return Transform.createOriginAndMatrix(this._origin, matrix);\r\n        }\r\n        // uh oh again -- clear vector1 and vector2, re-announce vector2 as possible vector1??\r\n        const vector2 = this._vector2;\r\n        this._vector1 = this._vector2 = undefined;\r\n        this.announceVector(vector2);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /**If vector0 is known but vector1 is not, make vector1 the cross of the up-vector and vector0 */\r\n  public applyDefaultUpVector(vector?: Vector3d) {\r\n    if (vector && this._vector0 && !this._vector1 && !vector.isParallelTo(this._vector0)) {\r\n      this._vector1 = vector.crossProduct(this._vector0);\r\n    }\r\n  }\r\n  /** Ask if there is a defined origin for the evolving frame */\r\n  public get hasOrigin(): boolean { return this._origin !== undefined; }\r\n  /** Return the number of vectors saved.   Because the save process checks numerics, this should be the rank of the system.\r\n   */\r\n  public savedVectorCount(): number {\r\n    if (!this._vector0)\r\n      return 0;\r\n    if (!this._vector1)\r\n      return 1;\r\n    if (!this._vector2)\r\n      return 2;\r\n    return 3;\r\n  }\r\n  /** announce a new point.  If this point is different from the origin, also compute and announce the vector from the origin.*/\r\n  public announcePoint(point: Point3d): number {\r\n    if (!this._origin) {\r\n      this._origin = point.clone();\r\n      return this.savedVectorCount();\r\n    }\r\n    // the new point may provide an additional vector\r\n    if (this._origin.isAlmostEqual(point))\r\n      return this.savedVectorCount();\r\n    return this.announceVector(this._origin.vectorTo(point));\r\n  }\r\n  /** announce a new vector. */\r\n  public announceVector(vector: Vector3d): number {\r\n    if (vector.isAlmostZero)\r\n      return this.savedVectorCount();\r\n\r\n    if (!this._vector0) { this._vector0 = vector.clone(this._vector0); return 1; }\r\n\r\n    if (!this._vector1) {\r\n      if (this.areStronglyIndependentVectors(vector, this._vector0, 1.0e-5)) { this._vector1 = vector.clone(this._vector1); return 2; }\r\n      return 1;\r\n    }\r\n\r\n    // vector0 and vector1 are independent.\r\n    if (!this._vector2) {\r\n      const unitPerpendicular = this._vector0.unitCrossProduct(this._vector1);\r\n      if (unitPerpendicular && !Geometry.isSameCoordinate(0, unitPerpendicular.dotProduct(vector))) {\r\n        this._vector2 = vector.clone(this._vector2);\r\n        return 3;\r\n      }\r\n      return 2;\r\n    }\r\n    // fall through if prior vectors are all there -- no need for the new one.\r\n    return 3;\r\n  }\r\n  /** Inspect the content of the data.  Announce points and vectors.   Return when savedVectorCount becomes\r\n   * sufficient for a coordinate system.\r\n   */\r\n  public announce(data: any) {\r\n    if (this.savedVectorCount() > 1) return;\r\n    if (data instanceof Point3d)\r\n      this.announcePoint(data);\r\n    else if (data instanceof Vector3d)\r\n      this.announceVector(data);\r\n    else if (Array.isArray(data)) {\r\n      for (const child of data) {\r\n        if (this.savedVectorCount() > 1)\r\n          break;\r\n        this.announce(child);\r\n      }\r\n    } else if (data instanceof CurvePrimitive) {\r\n      if (data instanceof LineSegment3d) {\r\n        this.announcePoint(data.startPoint());\r\n        this.announcePoint(data.endPoint());\r\n      } else if (data instanceof Arc3d) {\r\n        const ray = data.fractionToPointAndDerivative(0.0);\r\n        this.announcePoint(ray.origin);\r\n        this.announceVector(ray.direction);\r\n        this.announceVector(data.matrix.columnZCrossVector(ray.direction));\r\n      } else if (data instanceof LineString3d) {\r\n        for (const point of data.points) {\r\n          this.announcePoint(point);\r\n          if (this.savedVectorCount() > 1)\r\n            break;\r\n        }\r\n      } else if (data instanceof BSplineCurve3d) {\r\n        const point = Point3d.create();\r\n        for (let i = 0; this.savedVectorCount() < 2; i++) {\r\n          if (data.getPolePoint3d(i, point) instanceof Point3d)\r\n            this.announcePoint(point);\r\n          else break;\r\n        }\r\n      }\r\n      // TODO: unknown curve type.  Stroke? FrenetFrame?\r\n    } else if (data instanceof CurveCollection) {\r\n      if (data.children)\r\n        for (const child of data.children) {\r\n          this.announce(child);\r\n          if (this.savedVectorCount() > 1)\r\n            break;\r\n        }\r\n    } else if (data instanceof GrowableXYZArray) {\r\n      const point = Point3d.create();\r\n      for (let i = 0; this.savedVectorCount() < 2; i++) {\r\n        if (data.getPoint3dAtCheckedPointIndex(i, point) instanceof Point3d)\r\n          this.announcePoint(point);\r\n        else break;\r\n      }\r\n    }\r\n  }\r\n  /** create a localToWorld frame for the given data.\r\n   *\r\n   * *  origin is at first point\r\n   * *  x axis in direction of first nonzero vector present or implied by the input.\r\n   * *  y axis is perpendicular to x and contains (in positive side) the next vector present or implied by the input.\r\n   */\r\n  public static createRightHandedFrame(defaultUpVector: Vector3d | undefined, ...params: any[]): Transform | undefined {\r\n    const builder = new FrameBuilder();\r\n    for (const data of params) {\r\n      builder.announce(data);\r\n      builder.applyDefaultUpVector(defaultUpVector);\r\n      const result = builder.getValidatedFrame(false);\r\n      if (result !== undefined) {\r\n        if (defaultUpVector) {\r\n          if (result.matrix.dotColumnZ(defaultUpVector) < 0.0)\r\n            result.matrix.scaleColumnsInPlace(1, -1, -1);\r\n        }\r\n        return result;\r\n      }\r\n    }\r\n    // try direct evaluation of curve primitives?\r\n    for (const data of params) {\r\n      if (data instanceof CurveCollection) {\r\n        const children = data.children;\r\n        if (children) {\r\n          for (const curve of children) {\r\n            if (curve instanceof CurvePrimitive) {\r\n              const frenetFrame = curve.fractionToFrenetFrame(0.0);\r\n              if (frenetFrame)\r\n                return frenetFrame;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    }\r\n    return undefined;\r\n  }\r\n  /** create a transform containing points or vectors in the given data.\r\n   * * The xy columns of the transform contain the first points or vectors of the data.\r\n   * * The z column is perpendicular to that xy plane.\r\n   * * The calculation favors the first points found.  It does not try to get a \"best\" plane.\r\n   */\r\n  public static createRightHandedLocalToWorld(...params: any[]): Transform | undefined {\r\n    const builder = new FrameBuilder();\r\n    for (const data of params) {\r\n      builder.announce(data);\r\n      const localToWorld = builder.getValidatedFrame(false);\r\n      if (localToWorld !== undefined)\r\n        return localToWorld;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * try to create a frame whose xy plane is through points.\r\n   *\r\n   * *  if 3 or more distinct points are present, the x axis is from the first point to the most distance, and y direction is toward the\r\n   * point most distant from that line.\r\n   * @param points array of points\r\n   */\r\n  public static createFrameToDistantPoints(points: Point3d[]): Transform | undefined {\r\n    if (points.length > 2) {\r\n      const origin = points[0].clone();\r\n      const vector01 = Vector3d.create();\r\n      Point3dArray.indexOfMostDistantPoint(points, points[0], vector01);\r\n      const vector02 = Vector3d.create();\r\n      Point3dArray.indexOfPointWithMaxCrossProductMagnitude(points, origin, vector01, vector02);\r\n      const matrix = Matrix3d.createRigidFromColumns(vector01, vector02, AxisOrder.XYZ);\r\n      if (matrix)\r\n        return Transform.createRefs(origin, matrix);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * try to create a frame whose xy plane is through points, with the points appearing CCW in the local frame.\r\n   *\r\n   * *  if 3 or more distinct points are present, the x axis is from the first point to the most distance, and y direction is toward the\r\n   * point most distant from that line.\r\n   * @param points array of points\r\n   */\r\n  public static createFrameWithCCWPolygon(points: Point3d[]): Transform | undefined {\r\n    if (points.length > 2) {\r\n      const ray = PolygonOps.centroidAreaNormal(points);\r\n      if (ray) {\r\n        return ray.toRigidZFrame();\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Create the localToWorld transform from a range to axes of its parent coordinate system.\r\n   * @param range [in] range to inspect\r\n   * @param fractionX  [in] fractional coordinate of frame origin x\r\n   * @param fractionY [in] fractional coordinate of frame origin y\r\n   * @param fractionZ [in] fractional coordinate of frame origin z\r\n   * @param scaleSelect [in] selects size of localToWorld axes.\r\n   * @param defaultAxisLength [in] if true and any axis length is 0, that axis vector takes this physical length.\r\n   */\r\n  public static createLocalToWorldTransformInRange(\r\n    range: Range3d,\r\n    scaleSelect: AxisScaleSelect = AxisScaleSelect.NonUniformRangeContainment,\r\n    fractionX: number = 0,\r\n    fractionY: number = 0,\r\n    fractionZ: number = 0,\r\n    defaultAxisLength: number = 1.0): Transform {\r\n    if (range.isNull)\r\n      return Transform.createIdentity();\r\n    let a = 1.0;\r\n    let b = 1.0;\r\n    let c = 1.0;\r\n    if (scaleSelect === AxisScaleSelect.LongestRangeDirection) {\r\n      a = b = c = Geometry.correctSmallMetricDistance(range.maxLength(), defaultAxisLength);\r\n    } else if (scaleSelect === AxisScaleSelect.NonUniformRangeContainment) {\r\n      a = Geometry.correctSmallMetricDistance(range.xLength(), defaultAxisLength) * Geometry.maxAbsDiff(fractionX, 0, 1);\r\n      b = Geometry.correctSmallMetricDistance(range.yLength(), defaultAxisLength) * Geometry.maxAbsDiff(fractionY, 0, 1);\r\n      c = Geometry.correctSmallMetricDistance(range.zLength(), defaultAxisLength) * Geometry.maxAbsDiff(fractionZ, 0, 1);\r\n    }\r\n    return Transform.createRefs(range.fractionToPoint(fractionX, fractionY, fractionZ), Matrix3d.createScale(a, b, c));\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Point3dArray } from \"./PointHelpers\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { AxisOrder, Geometry } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\n/**\r\n * context for constructing smooth motion a startFrustum and endFrustum.\r\n * The externally interesting calls are\r\n * * Create a context to shift corner0 to corner1, with the(NPC coordinate) point(fractionU, fractionV, fractionW) moving along its connecting segment, all other points rotating smoothly from the start orientation to end orientation:\r\n * `const context = SmoothTransformBetweenFrusta (cornerA, cornerB)`\r\n *  * Get any intermediate 8 corners(at fraction) with `context.fractionToWorldCorners(fraction)`\r\n * * Frustum corners are ordered by \"x varies fastest, then y, then z\", hence (xyz) order on nondimensional space is\r\n *   * (left lower rear) (000)\r\n *   * (right lower rear) (100)\r\n *   * (left upper rear) (010)\r\n *   * (right upper rear) (100)\r\n *   * (left lower front) (001)\r\n *   * (right lower front) (101)\r\n *   * (left upper front) (011)\r\n *   * (right upper front) (101)\r\n * * which uses names\r\n *    * (left,right) for horizontal (x)\r\n *    * (bottom, top) for vertical (y)\r\n *    * (rear, front) for back and front planes (z)\r\n * @public\r\n */\r\nexport class SmoothTransformBetweenFrusta {\r\n  // raw frusta:\r\n  private _localCornerA: Point3d[];\r\n  private _localCornerB: Point3d[];\r\n\r\n  private _localToWorldA: Transform;\r\n  private _localToWorldB: Transform;\r\n  /** (property accessor) rigid frame at start of motion */\r\n  public get localToWorldA(): Transform { return this._localToWorldA; }\r\n  /** (property accessor) rigid frame at end of motion */\r\n  public get localToWorldB(): Transform { return this._localToWorldB; }\r\n  private _rotationAxis: Vector3d;\r\n  private _rotationAngle: Angle;\r\n\r\n  /**\r\n   * CAPTURE local corners, pickup and putdown frames, and rotation-around-vector data\r\n   * @param localCornerA\r\n   * @param localCornerB\r\n   * @param localToWordA\r\n   * @param localToWordB\r\n   * @param rotationAxis\r\n   * @param rotationAngle\r\n   */\r\n  private constructor(localToWorldA: Transform, localCornerA: Point3d[], localToWorldB: Transform, localCornerB: Point3d[], rotationAxis: Vector3d, rotationAngle: Angle) {\r\n    this._localCornerA = localCornerA;\r\n    this._localCornerB = localCornerB;\r\n    this._localToWorldA = localToWorldA;\r\n    this._localToWorldB = localToWorldB;\r\n    this._rotationAxis = rotationAxis;\r\n    this._rotationAngle = rotationAngle;\r\n  }\r\n\r\n  /**\r\n   * Set up rotation data for smooth transition from 8 point frusta cornerA and cornerB\r\n   * @param cornerA\r\n   * @param cornerB\r\n   */\r\n  public static create(cornerA: Point3d[], cornerB: Point3d[], preferSimpleRotation: boolean = true): SmoothTransformBetweenFrusta | undefined {\r\n    const localToWorldA = Point3dArray.evaluateTrilinearDerivativeTransform(cornerA, 0.5, 0.5, 0.5);\r\n    const localToWorldB = Point3dArray.evaluateTrilinearDerivativeTransform(cornerB, 0.5, 0.5, 0.5);\r\n    const rigidA = Transform.createOriginAndMatrix(localToWorldA.origin, Matrix3d.createRigidFromMatrix3d(localToWorldA.matrix, AxisOrder.ZXY));\r\n    const rigidB = Transform.createOriginAndMatrix(localToWorldB.origin, Matrix3d.createRigidFromMatrix3d(localToWorldB.matrix, AxisOrder.ZXY));\r\n    if (rigidA.matrix.computeCachedInverse(true) && rigidB.matrix.computeCachedInverse(true)) {\r\n      const spinMatrix = rigidB.matrix.multiplyMatrixMatrixInverse(rigidA.matrix)!;\r\n      const spinAxis = spinMatrix.getAxisAndAngleOfRotation();\r\n      const localCornerA = rigidA.multiplyInversePoint3dArray(cornerA)!;\r\n      const localCornerB = rigidB.multiplyInversePoint3dArray(cornerB)!;\r\n      /** Is this a pure rotation -- i.e. no clip volume resizing for camera or clip changes */\r\n      if (preferSimpleRotation && Point3dArray.isAlmostEqual(localCornerA, localCornerB) && !spinAxis.angle.isAlmostZero) {\r\n        // world vectors\r\n        const worldOriginShift = Vector3d.createStartEnd(localToWorldA.origin, localToWorldB.origin);\r\n        const chordMidPoint = localToWorldA.getOrigin().interpolate(0.5, localToWorldB.getOrigin());\r\n        const bisector = spinAxis.axis.unitCrossProduct(worldOriginShift);\r\n        if (bisector) {\r\n          const halfChordLength = 0.5 * worldOriginShift.magnitude();\r\n          const alpha = Geometry.conditionalDivideFraction(halfChordLength, Math.tan(spinAxis.angle.radians * 0.5));\r\n          if (alpha !== undefined) {\r\n            const spinCenter = chordMidPoint.plusScaled(bisector, alpha);\r\n            const rigidA1 = Transform.createOriginAndMatrix(spinCenter, rigidA.matrix);\r\n            const rigidB1 = Transform.createOriginAndMatrix(spinCenter, rigidB.matrix);\r\n            const localCornerA1 = rigidA1.multiplyInversePoint3dArray(cornerA)!;\r\n            const localCornerB1 = rigidB1.multiplyInversePoint3dArray(cornerB)!;\r\n            return new SmoothTransformBetweenFrusta(rigidA1, localCornerA1, rigidB1, localCornerB1,\r\n              spinAxis.axis, spinAxis.angle);\r\n          }\r\n        }\r\n      }\r\n      return new SmoothTransformBetweenFrusta(rigidA, localCornerA, rigidB, localCornerB,\r\n        spinAxis.axis, spinAxis.angle);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** interpolate local corner coordinates at fractional move from m_localFrustum0 to m_localFrustum1 */\r\n  public interpolateLocalCorners(fraction: number, result?: Point3d[]): Point3d[] {\r\n    result = result || [];\r\n    result.length = 0;\r\n    const n = this._localCornerA.length;\r\n    for (let i = 0; i < n; i++) {\r\n      result.push(this._localCornerA[i].interpolate(fraction, this._localCornerB[i]));\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * After initialization, call this for various intermediate fractions.\r\n   * The returned corner points are in world coordinates \"between\" start and end positions.\r\n   */\r\n  public fractionToWorldCorners(fraction: number, result?: Point3d[]): Point3d[] {\r\n    const corners = this.interpolateLocalCorners(fraction, result);\r\n    const fractionalRotation = Matrix3d.createRotationAroundVector(this._rotationAxis,\r\n      this._rotationAngle.cloneScaled(fraction))!;\r\n    const axes0 = this._localToWorldA.matrix;\r\n    const fractionalAxes = fractionalRotation.multiplyMatrixMatrix(axes0);\r\n    const fractionalOrigin = this._localToWorldA.getOrigin().interpolate(fraction, this._localToWorldB.origin);\r\n    const putdownFrame = Transform.createOriginAndMatrix(fractionalOrigin, fractionalAxes);\r\n    putdownFrame.multiplyPoint3dArray(corners, corners);\r\n    return corners;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { CoordinateXYZ } from \"../curve/CoordinateXYZ\";\r\nimport { UnionRegion } from \"../curve/UnionRegion\";\r\nimport { BagOfCurves, CurveCollection } from \"../curve/CurveCollection\";\r\nimport { ParityRegion } from \"../curve/ParityRegion\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { Path } from \"../curve/Path\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\r\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\r\nimport { BezierCurve3d } from \"../bspline/BezierCurve3d\";\r\nimport { BezierCurve3dH } from \"../bspline/BezierCurve3dH\";\r\nimport { BSplineSurface3d, BSplineSurface3dH } from \"../bspline/BSplineSurface\";\r\nimport { IndexedPolyface } from \"../polyface/Polyface\";\r\nimport { Sphere } from \"../solid/Sphere\";\r\nimport { Cone } from \"../solid/Cone\";\r\nimport { Box } from \"../solid/Box\";\r\nimport { TorusPipe } from \"../solid/TorusPipe\";\r\nimport { LinearSweep } from \"../solid/LinearSweep\";\r\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\r\nimport { RuledSweep } from \"../solid/RuledSweep\";\r\nimport { TransitionSpiral3d } from \"../curve/TransitionSpiral\";\r\n\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { PointString3d } from \"../curve/PointString3d\";\r\nimport { Plane3dByOriginAndVectors } from \"./Plane3dByOriginAndVectors\";\r\nimport { BezierCurveBase } from \"../bspline/BezierCurveBase\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Vector2d } from \"./Point2dVector2d\";\r\n/**\r\n * * `GeometryHandler` defines the base abstract methods for double-dispatch geometry computation.\r\n * * User code that wants to handle one or all of the commonly known geometry types implements a handler class.\r\n * * User code that does not handle all types is most likely to start with `NullGeometryHandler`, which will provide no-action implementations for all types.\r\n * @public\r\n */\r\nexport abstract class GeometryHandler {\r\n  /** handle strongly typed LineSegment3d */\r\n  public abstract handleLineSegment3d(g: LineSegment3d): any;\r\n  /** handle strongly typed  LineString3d  */\r\n  public abstract handleLineString3d(g: LineString3d): any;\r\n  /** handle strongly typed  Arc3d  */\r\n  public abstract handleArc3d(g: Arc3d): any;\r\n  /** handle strongly typed  CurveCollection  */\r\n  public handleCurveCollection(_g: CurveCollection): any { }\r\n  /** handle strongly typed  BSplineCurve3d  */\r\n  public abstract handleBSplineCurve3d(g: BSplineCurve3d): any;\r\n  /** handle strongly typed  BSplineCurve3dH  */\r\n  public abstract handleBSplineCurve3dH(g: BSplineCurve3dH): any;\r\n  /** handle strongly typed  BSplineSurface3d  */\r\n  public abstract handleBSplineSurface3d(g: BSplineSurface3d): any;\r\n  /** handle strongly typed  CoordinateXYZ  */\r\n  public abstract handleCoordinateXYZ(g: CoordinateXYZ): any;\r\n  /** handle strongly typed  BSplineSurface3dH  */\r\n  public abstract handleBSplineSurface3dH(g: BSplineSurface3dH): any;\r\n  /** handle strongly typed  IndexedPolyface  */\r\n  public abstract handleIndexedPolyface(g: IndexedPolyface): any;\r\n  /** handle strongly typed TransitionSpiral3d\r\n   * @alpha\r\n   */\r\n  public abstract handleTransitionSpiral(g: TransitionSpiral3d): any;\r\n\r\n  /** handle strongly typed Path (base class method calls handleCurveCollection) */\r\n  public handlePath(g: Path): any { return this.handleCurveCollection(g); }\r\n  /** handle strongly typed  Loop (base class method calls handleCurveCollection) */\r\n  public handleLoop(g: Loop): any { return this.handleCurveCollection(g); }\r\n  /** handle strongly typed  ParityRegion (base class method calls handleCurveCollection) */\r\n  public handleParityRegion(g: ParityRegion): any { return this.handleCurveCollection(g); }\r\n  /** handle strongly typed  UnionRegion (base class method calls handleCurveCollection) */\r\n  public handleUnionRegion(g: UnionRegion): any { return this.handleCurveCollection(g); }\r\n  /** handle strongly typed  BagOfCurves (base class method calls handleCurveCollection) */\r\n  public handleBagOfCurves(g: BagOfCurves): any { return this.handleCurveCollection(g); }\r\n  /** handle strongly typed  Sphere */\r\n  public abstract handleSphere(g: Sphere): any;\r\n  /** handle strongly typed  Cone */\r\n  public abstract handleCone(g: Cone): any;\r\n  /** handle strongly typed  Box */\r\n  public abstract handleBox(g: Box): any;\r\n  /** handle strongly typed  TorusPipe */\r\n  public abstract handleTorusPipe(g: TorusPipe): any;\r\n  /** handle strongly typed  LinearSweep */\r\n  public abstract handleLinearSweep(g: LinearSweep): any;\r\n  /** handle strongly typed  RotationalSweep */\r\n  public abstract handleRotationalSweep(g: RotationalSweep): any;\r\n  /** handle strongly typed  RuledSweep */\r\n  public abstract handleRuledSweep(g: RuledSweep): any;\r\n  /** handle strongly typed  PointString3d */\r\n  public abstract handlePointString3d(g: PointString3d): any;\r\n  /** handle strongly typed  BezierCurve3d */\r\n  public abstract handleBezierCurve3d(g: BezierCurve3d): any;\r\n  /** handle strongly typed  BezierCurve3dH */\r\n  public abstract handleBezierCurve3dH(g: BezierCurve3dH): any;\r\n}\r\n/**\r\n * `NullGeometryHandler` is a base class for dispatching various geometry types to\r\n * application specific implementation of some service.\r\n *\r\n * To use:\r\n * * Derive a class from `NullGeometryHandler`\r\n * * Reimplement any or all of the specific `handleXXXX` methods\r\n * * Create a handler instance `myHandler`\r\n * * To send a `GeometryQuery` object `candidateGeometry` through the (fast) dispatch, invoke   `candidateGeometry.dispatchToHandler (myHandler)\r\n * * The appropriate method or methods will get called with a strongly typed `_g ` value.\r\n * @public\r\n */\r\nexport class NullGeometryHandler extends GeometryHandler {\r\n  /** no-action implementation */\r\n  public handleLineSegment3d(_g: LineSegment3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleLineString3d(_g: LineString3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleArc3d(_g: Arc3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleCurveCollection(_g: CurveCollection): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineCurve3d(_g: BSplineCurve3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineCurve3dH(_g: BSplineCurve3dH): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineSurface3d(_g: BSplineSurface3d): any { return undefined; }\r\n\r\n  /** no-action implementation */\r\n  public handleCoordinateXYZ(_g: CoordinateXYZ): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineSurface3dH(_g: BSplineSurface3dH): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleIndexedPolyface(_g: IndexedPolyface): any { return undefined; }\r\n  /** no-action implementation\r\n   * @alpha\r\n   */\r\n  public handleTransitionSpiral(_g: TransitionSpiral3d): any { return undefined; }\r\n\r\n  /** no-action implementation */\r\n  public handlePath(_g: Path): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleLoop(_g: Loop): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleParityRegion(_g: ParityRegion): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleUnionRegion(_g: UnionRegion): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBagOfCurves(_g: BagOfCurves): any { return undefined; }\r\n\r\n  /** no-action implementation */\r\n  public handleSphere(_g: Sphere): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleCone(_g: Cone): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBox(_g: Box): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleTorusPipe(_g: TorusPipe): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleLinearSweep(_g: LinearSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleRotationalSweep(_g: RotationalSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleRuledSweep(_g: RuledSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handlePointString3d(_g: PointString3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBezierCurve3d(_g: BezierCurve3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBezierCurve3dH(_g: BezierCurve3dH): any { return undefined; }\r\n}\r\n/**\r\n * Implement GeometryHandler methods, with all curve collection methods recursing to children.\r\n * @public\r\n */\r\nexport class RecurseToCurvesGeometryHandler extends GeometryHandler {\r\n  /** no-action implementation */\r\n  public handleLineSegment3d(_g: LineSegment3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleLineString3d(_g: LineString3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleArc3d(_g: Arc3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineCurve3d(_g: BSplineCurve3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineCurve3dH(_g: BSplineCurve3dH): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineSurface3d(_g: BSplineSurface3d): any { return undefined; }\r\n\r\n  /** no-action implementation */\r\n  public handleCoordinateXYZ(_g: CoordinateXYZ): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineSurface3dH(_g: BSplineSurface3dH): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleIndexedPolyface(_g: IndexedPolyface): any { return undefined; }\r\n  /** no-action implementation\r\n   * @alpha\r\n   */\r\n  public handleTransitionSpiral(_g: TransitionSpiral3d): any { return undefined; }\r\n  /** Invoke `child.dispatchToGeometryHandler(this)` for each child in the array returned by the query `g.children` */\r\n  public handleChildren(g: GeometryQuery): any {\r\n    const children = g.children;\r\n    if (children)\r\n      for (const child of children) {\r\n        child.dispatchToGeometryHandler(this);\r\n      }\r\n  }\r\n  /** Recurse to children */\r\n  public handleCurveCollection(g: CurveCollection): any { return this.handleChildren(g); }\r\n\r\n  /** Recurse to children */\r\n  public handlePath(g: Path): any { return this.handleChildren(g); }\r\n  /** Recurse to children */\r\n  public handleLoop(g: Loop): any { return this.handleChildren(g); }\r\n  /** Recurse to children */\r\n  public handleParityRegion(g: ParityRegion): any { return this.handleChildren(g); }\r\n  /** Recurse to children */\r\n  public handleUnionRegion(g: UnionRegion): any { return this.handleChildren(g); }\r\n  /** Recurse to children */\r\n  public handleBagOfCurves(g: BagOfCurves): any { return this.handleChildren(g); }\r\n\r\n  /** no-action implementation */\r\n  public handleSphere(_g: Sphere): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleCone(_g: Cone): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBox(_g: Box): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleTorusPipe(_g: TorusPipe): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleLinearSweep(_g: LinearSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleRotationalSweep(_g: RotationalSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleRuledSweep(_g: RuledSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handlePointString3d(_g: PointString3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBezierCurve3d(_g: BezierCurve3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBezierCurve3dH(_g: BezierCurve3dH): any { return undefined; }\r\n}\r\n\r\n/** IStrokeHandler is an interface with methods to receive data about curves being stroked.\r\n * CurvePrimitives emitStrokes () methods emit calls to a handler object with these methods.\r\n * The various CurvePrimitive types are free to announce either single points (announcePoint), linear fragments,\r\n * or fractional intervals of the parent curve.\r\n * * handler.startCurvePrimitive (cp) -- announce the curve primitive whose strokes will follow.\r\n * * announcePointTangent (xyz, fraction, tangent) -- announce a single point on the curve.\r\n * * announceIntervalForUniformStepStrokes (cp, numStrokes, fraction0, fraction1) -- announce a fraction\r\n * interval in which the curve can be evaluated (e.g. the handler can call cp->fractionToPointAndDerivative ())\r\n * * announceSegmentInterval (cp, point0, point1, numStrokes, fraction0, fraction1) -- announce\r\n *    that the fractional interval fraction0, fraction1 is a straight line which should be broken into\r\n *    numStrokes strokes.\r\n *   * A LineSegment would make a single call to this.\r\n *   * A LineString would make one call to this for each of its segments, with fractions indicating position\r\n * within the linestring.\r\n * * endCurvePrimitive (cp) -- announce the end of the curve primitive.\r\n * @public\r\n */\r\nexport interface IStrokeHandler {\r\n  /** announce a parent curve primitive\r\n   * * startParentCurvePrimitive() ...endParentCurvePrimitive() are wrapped around startCurvePrimitive and endCurvePrimitive when the interior primitive is a proxy.\r\n   */\r\n  startParentCurvePrimitive(cp: CurvePrimitive): void;\r\n  /** Announce the curve primitive that will be described in subsequent calls. */\r\n  startCurvePrimitive(cp: CurvePrimitive): void;\r\n  /**\r\n   * announce a single point with its fraction and tangent.\r\n   * * (IMPORTANT) the same Point3d and Vector3d will be reset and passed on multiple calls.\r\n   * * (THEREFORE) if the implementation is saving coordinates, it must copy the xyz data out into its own data structure rather than save the references.\r\n   */\r\n  announcePointTangent(xyz: Point3d, fraction: number, tangent: Vector3d): void;\r\n\r\n  /** Announce that curve primitive cp should be evaluated in the specified fraction interval. */\r\n  announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void;\r\n  /** Announce numPoints interpolated between point0 and point1, with associated fractions */\r\n  announceSegmentInterval(\r\n    cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void;\r\n  /** Announce that all data about `cp` has been announced. */\r\n  endCurvePrimitive(cp: CurvePrimitive): void;\r\n  /** Announce that all data about the parent primitive has been announced. */\r\n  endParentCurvePrimitive(cp: CurvePrimitive): void;\r\n  /**\r\n   * Announce a bezier curve fragment.\r\n   * * this is usually a section of BsplineCurve\r\n   * * If this function is missing, the same interval will be passed to announceIntervalForUniformSteps.\r\n   * @param bezier bezier fragment\r\n   * @param numStrokes suggested number of strokes (uniform in bezier interval 0..1)\r\n   * @param parent parent curve\r\n   * @param spanIndex spanIndex within parent\r\n   * @param fraction0 start fraction on parent curve\r\n   * @param fraction1 end fraction on parent curve\r\n   */\r\n  announceBezierCurve?(\r\n    bezier: BezierCurveBase,\r\n    numStrokes: number,\r\n    parent: CurvePrimitive,\r\n    spandex: number,\r\n    fraction0: number,\r\n    fraction1: number): void;\r\n}\r\n\r\n/**\r\n * Interface with methods for mapping (u,v) fractional coordinates to surface xyz and derivatives.\r\n * @public\r\n */\r\nexport interface UVSurface {\r\n  /**\r\n   * Convert fractional u and v coordinates to surface point\r\n   * @param uFraction fractional coordinate in u direction\r\n   * @param vFraction fractional coordinate in the v direction\r\n   * @param result optional pre-allocated point\r\n   */\r\n  uvFractionToPoint(uFraction: number, vFraction: number, result?: Point3d): Point3d;\r\n  /**\r\n   * Convert fractional u and v coordinates to surface point and in-surface tangent directions.\r\n   * * Remark: the vectors are expected to be non-zero tangents which can be crossed to get a normal.\r\n   * * Hence the are NOT precisely either (a) partial derivatives or (b) frenet vectors\r\n   * @param uFraction fractional coordinate in u direction\r\n   * @param vFraction fractional coordinate in the v direction\r\n   * @param result optional pre-allocated carrier for point and vectors\r\n   */\r\n  uvFractionToPointAndTangents(uFraction: number, vFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;\r\n}\r\n/**\r\n * Interface for queries of distance-along in u and v directions\r\n * @public\r\n */\r\nexport interface UVSurfaceIsoParametricDistance {\r\n  /**\r\n   * * Return a vector whose x and y parts are \"size\" of the surface in the u and v directions.\r\n   * * Sizes are use for applying scaling to mesh parameters\r\n   * * These sizes are (reasonable approximations of) the max curve length along u and v isoparameter lines.\r\n   *   * e.g. for a sphere, these are:\r\n   *      * u direction = distance around the equator\r\n   *      * v direction = distance from south pole to north pole.\r\n   */\r\n  maxIsoParametricDistance(): Vector2d;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { BlockComparisonFunction } from \"./GrowableFloat64Array\";\r\n/** @module ArraysAndInterfaces */\r\n\r\n/**\r\n * Array of contiguous doubles, indexed by block number and index within block.\r\n * * This is essentially a rectangular matrix (two dimensional array), with each block being a row of the matrix.\r\n * @public\r\n */\r\nexport class GrowableBlockedArray {\r\n  /** underlying contiguous, oversized buffer. */\r\n  protected _data: Float64Array;\r\n  /** Number of blocks (matrix rows) in use. */\r\n  protected _inUse: number;\r\n  /** number of numbers per block in the array.\r\n   * * If viewing the array as a two dimensional array, this is the row size.\r\n   */\r\n  protected _blockSize: number;  // positive integer !!!\r\n  public constructor(blockSize: number, initialBlocks: number = 8) {\r\n    /** array contents in blocked (row-major) order, possibly with extra capacity\r\n     * Total capacity is `this._data.length`\r\n     * Actual in-use count is `this._inUse * this._blockSize`\r\n     */\r\n    this._data = new Float64Array(initialBlocks * blockSize);\r\n    this._inUse = 0;\r\n    this._blockSize = blockSize;\r\n  }\r\n  /** computed property: length (in blocks, not doubles) */\r\n  public get numBlocks(): number { return this._inUse; }\r\n  /** property: number of data values per block */\r\n  public get numPerBlock(): number { return this._blockSize; }\r\n  /**\r\n   * Return a single value indexed within a block\r\n   * @param blockIndex index of block to read\r\n   * @param indexInBlock  offset within the block\r\n   */\r\n  public getWithinBlock(blockIndex: number, indexWithinBlock: number): number {\r\n    return this._data[blockIndex * this._blockSize + indexWithinBlock];\r\n  }\r\n  /** clear the block count to zero, but maintain the allocated memory */\r\n  public clear() { this._inUse = 0; }\r\n  /** Return the capacity in blocks (not doubles) */\r\n  public blockCapacity() {\r\n    return this._data.length / this._blockSize;\r\n  }\r\n  /** ensure capacity (in blocks, not doubles) */\r\n  public ensureBlockCapacity(blockCapacity: number) {\r\n    if (blockCapacity > this.blockCapacity()) {\r\n      const newData = new Float64Array(blockCapacity * this._blockSize);\r\n      for (let i = 0; i < this._data.length; i++) {\r\n        newData[i] = this._data[i];\r\n      }\r\n      this._data = newData;\r\n    }\r\n  }\r\n  /** Add a new block of data.\r\n   * * If newData has fewer than numPerBlock entries, the remaining part of the new block is zeros.\r\n   * * If newData has more entries, only the first numPerBlock are taken.\r\n   */\r\n  public addBlock(newData: number[]) {\r\n    const k0 = this.newBlockIndex();\r\n    let numValue = newData.length;\r\n    if (numValue > this._blockSize)\r\n      numValue = this._blockSize;\r\n    for (let i = 0; i < numValue; i++)\r\n      this._data[k0 + i] = newData[i];\r\n  }\r\n  /**\r\n   * Return the starting index of a block of (zero-initialized) doubles at the end.\r\n   *\r\n   * * this.data is reallocated if needed to include the new block.\r\n   * * The inUse count is incremented to include the new block.\r\n   * * The returned block is an index to the Float64Array (not a block index)\r\n   */\r\n  protected newBlockIndex(): number {\r\n    const index = this._blockSize * this._inUse;\r\n    if ((index + 1) > this._data.length)\r\n      this.ensureBlockCapacity(1 + 2 * this._inUse);\r\n    this._inUse++;\r\n    for (let i = index; i < index + this._blockSize; i++)\r\n      this._data[i] = 0.0;\r\n    return index;\r\n  }\r\n  /** reduce the block count by one. */\r\n  public popBlock() {\r\n    if (this._inUse > 0)\r\n      this._inUse--;\r\n  }\r\n  /** convert a block index to the simple index to the underlying Float64Array. */\r\n  protected blockIndexToDoubleIndex(blockIndex: number) { return this._blockSize * blockIndex; }\r\n  /** Access a single double at offset within a block, with index checking and return undefined if indexing is invalid. */\r\n  public checkedComponent(blockIndex: number, componentIndex: number): number | undefined {\r\n    if (blockIndex >= this._inUse || blockIndex < 0 || componentIndex < 0 || componentIndex >= this._blockSize)\r\n      return undefined;\r\n    return this._data[this._blockSize * blockIndex + componentIndex];\r\n  }\r\n  /** Access a single double at offset within a block.  This has no index checking. */\r\n  public component(blockIndex: number, componentIndex: number): number {\r\n    return this._data[this._blockSize * blockIndex + componentIndex];\r\n  }\r\n  /** compare two blocks in simple lexical order.\r\n   * @param data data array\r\n   * @param blockSize number of items to compare\r\n   * @param ia raw index (not block index) of first block\r\n   * @param ib raw index (not block index) of second block\r\n   */\r\n  public static compareLexicalBlock(data: Float64Array, blockSize: number, ia: number, ib: number): number {\r\n    let ax = 0;\r\n    let bx = 0;\r\n    for (let i = 0; i < blockSize; i++) {\r\n      ax = data[ia + i];\r\n      bx = data[ib + i];\r\n      if (ax > bx) return 1;\r\n      if (ax < bx) return -1;\r\n    }\r\n    return ia - ib; // so original order is maintained among duplicates !!!!\r\n  }\r\n  /** Return an array of block indices sorted per compareLexicalBlock function */\r\n  public sortIndicesLexical(compareBlocks: BlockComparisonFunction = GrowableBlockedArray.compareLexicalBlock): Uint32Array {\r\n    const n = this._inUse;\r\n    // let numCompare = 0;\r\n    const result = new Uint32Array(n);\r\n    const data = this._data;\r\n    const blockSize = this._blockSize;\r\n    for (let i = 0; i < n; i++)result[i] = i;\r\n    result.sort(\r\n      (blockIndexA: number, blockIndexB: number) => {\r\n        // numCompare++;\r\n        return compareBlocks(data, blockSize, blockIndexA * blockSize, blockIndexB * blockSize);\r\n      });\r\n    // console.log (n, numCompare);\r\n    return result;\r\n  }\r\n  /** Return the distance (hypotenuse=sqrt(summed squares)) between indicated blocks */\r\n  public distanceBetweenBlocks(blockIndexA: number, blockIndexB: number): number {\r\n    let dd = 0.0;\r\n    let iA = this.blockIndexToDoubleIndex(blockIndexA);\r\n    let iB = this.blockIndexToDoubleIndex(blockIndexB);\r\n    let a = 0;\r\n    const data = this._data;\r\n    for (let i = 0; i < this._blockSize; i++) {\r\n      a = data[iA++] - data[iB++];\r\n      dd += a * a;\r\n    }\r\n    return Math.sqrt(dd);\r\n  }\r\n\r\n  /** Return the distance (hypotenuse=sqrt(summed squares)) between block entries `iBegin <= i < iEnd` of indicated blocks */\r\n  public distanceBetweenSubBlocks(blockIndexA: number, blockIndexB: number, iBegin: number, iEnd: number): number {\r\n    let dd = 0.0;\r\n    const iA = this.blockIndexToDoubleIndex(blockIndexA);\r\n    const iB = this.blockIndexToDoubleIndex(blockIndexB);\r\n    let a = 0;\r\n    const data = this._data;\r\n    for (let i = iBegin; i < iEnd; i++) {\r\n      a = data[iA + i] - data[iB + i];\r\n      dd += a * a;\r\n    }\r\n    return Math.sqrt(dd);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\n/**\r\n * Type for a OptionalGrowableFloat64Array or undefined.\r\n * @public\r\n */\r\nexport type OptionalGrowableFloat64Array = GrowableFloat64Array | undefined;\r\n/**\r\n * Signature for a function which does lexical comparison of `blockSize` consecutive values as 2 starting indices.\r\n * @public\r\n */\r\nexport type BlockComparisonFunction = (data: Float64Array, blockSize: number, index0: number, index1: number) => number;\r\n/**\r\n * A `GrowableFloat64Array` is Float64Array accompanied by a count of how many of the array's entries are considered in use.\r\n * * In C++ terms, this is like an std::vector\r\n * * As entries are added to the array, the buffer is reallocated as needed to accommodate.\r\n * * The reallocations leave unused space to accept further additional entries without reallocation.\r\n * * The `length` property returns the number of entries in use.\r\n * * the `capacity` property returns the (usually larger) length of the (over-allocated) Float64Array.\r\n * @public\r\n */\r\nexport class GrowableFloat64Array {\r\n  private _data: Float64Array;\r\n  private _inUse: number;\r\n  constructor(initialCapacity: number = 8) {\r\n    this._data = new Float64Array(initialCapacity);\r\n    this._inUse = 0;\r\n  }\r\n  /**\r\n   * Create a GrowableFloat64Array with given contents.\r\n   * @param contents data to copy into the array\r\n   */\r\n  public static create(contents: Float64Array | number[]): GrowableFloat64Array {\r\n    const result = new GrowableFloat64Array(contents.length);\r\n    for (const a of contents) {\r\n      result.push(a);\r\n    }\r\n    return result;\r\n  }\r\n  /** sort-compatible comparison.\r\n   * * Returns `(a-b)` which is\r\n   *   * negative if `a<b`\r\n   *   * zero if `a === b` (with exact equality)\r\n   *   * positive if `a>b`\r\n   */\r\n  public static compare(a: any, b: any): number {\r\n    return a - b;\r\n  }\r\n  /** Return a new array with\r\n   * * All active entries copied from this instance\r\n   * * optionally trimmed capacity to the active length or replicate the capacity and unused space.\r\n   */\r\n  public clone(maintainExcessCapacity: boolean = false): GrowableFloat64Array {\r\n    const n = this._inUse;\r\n    const data = this._data;\r\n    const out = new GrowableFloat64Array(maintainExcessCapacity ? this.capacity() : n);\r\n    for (let i = 0; i < n; i++)\r\n      out.push(data[i]);\r\n    return out;\r\n  }\r\n  /**\r\n   * Returns the number of entries in use.\r\n   * * Note that this is typically smaller than the length of the length of the supporting `Float64Array`\r\n   */\r\n  public get length() {\r\n    return this._inUse;\r\n  }\r\n  /**\r\n   * Set the value at specified index.\r\n   * @param index index of entry to set\r\n   * @param value value to set\r\n   */\r\n  public setAtUncheckedIndex(index: number, value: number) {\r\n    this._data[index] = value;\r\n  }\r\n\r\n  /**\r\n   * Move the value at index i to index j.\r\n   * @param i source index\r\n   * @param j destination index.\r\n   */\r\n  public move(i: number, j: number) {\r\n    this._data[j] = this._data[i];\r\n  }\r\n  /**\r\n   * swap the values at indices i and j\r\n   * @param i first index\r\n   * @param j second index\r\n   */\r\n  public swap(i: number, j: number) {\r\n    const a = this._data[i];\r\n    this._data[i] = this._data[j];\r\n    this._data[j] = a;\r\n  }\r\n\r\n  /**\r\n   * append a single value to the array.\r\n   * @param toPush value to append to the active array.\r\n   */\r\n  public push(toPush: number) {\r\n    if (this._inUse + 1 <= this._data.length) {\r\n      this._data[this._inUse] = toPush;\r\n      this._inUse++;\r\n    } else {\r\n      // Make new array (double size), copy values, then push toPush\r\n      const newData = new Float64Array(4 + this._inUse * 2);\r\n      for (let i = 0; i < this._inUse; i++) {\r\n        newData[i] = this._data[i];\r\n      }\r\n      this._data = newData;\r\n      this._data[this._inUse] = toPush;\r\n      this._inUse++;\r\n    }\r\n  }\r\n  /** Push a `numToCopy` consecutive values starting at `copyFromIndex` to the end of the array. */\r\n  public pushBlockCopy(copyFromIndex: number, numToCopy: number) {\r\n    const newLength = this._inUse + numToCopy;\r\n    this.ensureCapacity(newLength);\r\n    const limit = copyFromIndex + numToCopy;\r\n    for (let i = copyFromIndex; i < limit; i++)\r\n      this._data[this._inUse++] = this._data[i];\r\n  }\r\n  /** Clear the array to 0 length.  The underlying memory remains allocated for reuse. */\r\n  public clear() {\r\n    while (this._inUse > 0)\r\n      this.pop();\r\n  }\r\n  /**\r\n   * Returns the number of entries in the supporting Float64Array buffer.\r\n   * * This number can be larger than the `length` property.\r\n   */\r\n  public capacity() {\r\n    return this._data.length;\r\n  }\r\n  /**\r\n   * * If the capacity (Float64Array length) is less than or equal to the requested newCapacity, do nothing\r\n   * * If the requested newCapacity is larger than the existing capacity, reallocate (and copy existing values) with the larger capacity.\r\n   * @param newCapacity\r\n   */\r\n  public ensureCapacity(newCapacity: number) {\r\n    if (newCapacity > this.capacity()) {\r\n      const oldInUse = this._inUse;\r\n      const newData = new Float64Array(newCapacity);\r\n      for (let i = 0; i < oldInUse; i++)\r\n        newData[i] = this._data[i];\r\n      this._data = newData;\r\n    }\r\n  }\r\n  /**\r\n   * * If newLength is less than current (active) length, just set (active) length.\r\n   * * If newLength is greater, ensureCapacity (newSize) and pad with padValue up to newSize;\r\n   * @param newLength new data count\r\n   * @param padValue value to use for padding if the length increases.\r\n   */\r\n  public resize(newLength: number, padValue: number = 0) {\r\n    // quick out for easy case ...\r\n    if (newLength <= this._inUse) {\r\n      this._inUse = newLength;\r\n      return;\r\n    }\r\n    const oldLength = this._inUse;\r\n    this.ensureCapacity(newLength);\r\n    for (let i = oldLength; i < newLength; i++)\r\n      this._data[i] = padValue;\r\n    this._inUse = newLength;\r\n  }\r\n  /**\r\n   * * Reduce the length by one.\r\n   * * Note that there is no method return value -- use `back` to get that value before `pop()`\r\n   * * (As with std::vector, separating the `pop` from the value access eliminates error testing from `pop` call)\r\n   */\r\n  public pop() {\r\n    // Could technically access outside of array, if filled and then reduced using pop (similar to C\r\n    // and accessing out of bounds), but with adjusted inUse counter, that data will eventually be overwritten\r\n    if (this._inUse > 0) {\r\n      this._inUse--;\r\n    }\r\n  }\r\n  /** Access by index, without bounds check */\r\n  public atUncheckedIndex(index: number): number {\r\n    return this._data[index];\r\n  }\r\n  /** Access the 0-index member, without bounds check */\r\n  public front() {\r\n    return this._data[0];\r\n  }\r\n  /** Access the final member, without bounds check */\r\n  public back() {\r\n    return this._data[this._inUse - 1];\r\n  }\r\n  /** set a value by index */\r\n  public reassign(index: number, value: number) {\r\n    this._data[index] = value;\r\n  }\r\n\r\n  /**\r\n   * * Sort the array entries.\r\n   * * Uses insertion sort -- fine for small arrays (less than 30), slow for larger arrays\r\n   * @param compareMethod comparison method\r\n   */\r\n  public sort(compareMethod: (a: any, b: any) => number = GrowableFloat64Array.compare) {\r\n    for (let i = 0; i < this._inUse; i++) {\r\n      for (let j = i + 1; j < this._inUse; j++) {\r\n        const tempI = this._data[i];\r\n        const tempJ = this._data[j];\r\n        if (compareMethod(tempI, tempJ) > 0) {\r\n          this._data[i] = tempJ;\r\n          this._data[j] = tempI;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * * compress out values not within the [a,b] interval.\r\n   * * Note that if a is greater than b all values are rejected.\r\n   * @param a low value for accepted interval\r\n   * @param b high value for accepted interval\r\n   */\r\n  public restrictToInterval(a: number, b: number) {\r\n    const data = this._data;\r\n    const n = data.length;\r\n    let numAccept = 0;\r\n    let q = 0;\r\n    for (let i = 0; i < n; i++) {\r\n      q = data[i];\r\n      if (q >= a && q <= b)\r\n        data[numAccept++] = q;\r\n    }\r\n    this._inUse = numAccept;\r\n  }\r\n\r\n  /**\r\n   * * compress out multiple copies of values.\r\n   * * this is done in the current order of the array.\r\n   */\r\n  public compressAdjacentDuplicates(tolerance: number = 0.0) {\r\n    const data = this._data;\r\n    const n = this._inUse;\r\n    if (n === 0)\r\n      return;\r\n\r\n    let numAccepted = 1;\r\n    let a = data[0];\r\n    let b;\r\n    for (let i = 1; i < n; i++) {\r\n      b = data[i];\r\n      if (Math.abs(b - a) > tolerance) {\r\n        data[numAccepted++] = b;\r\n        a = b;\r\n      }\r\n    }\r\n    this._inUse = numAccepted;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { XAndY, XYAndZ } from \"./XYZProps\";\r\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\r\nimport { Range2d } from \"./Range\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { IndexedXYCollection } from \"./IndexedXYCollection\";\r\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\r\nimport { Point3d } from \"./Point3dVector3d\";\r\nimport { MultiLineStringDataVariant } from \"../topology/Triangulation\";\r\nimport { PointStreamGrowableXYZArrayCollector, VariantPointDataStream } from \"./PointStreaming\";\r\n\r\n/** `GrowableXYArray` manages a (possibly growing) Float64Array to pack xy coordinates.\r\n * @public\r\n */\r\nexport class GrowableXYArray extends IndexedXYCollection {\r\n  /**\r\n   * array of packed xyz xyz xyz components\r\n   */\r\n  private _data: Float64Array;\r\n  /**\r\n   * Number of xyz triples (not floats) in the array\r\n   */\r\n  private _xyInUse: number;\r\n  /**\r\n   * capacity in xyz triples. (not floats)\r\n   */\r\n  private _xyzCapacity: number;\r\n  /** Construct a new GrowablePoint2d array.\r\n   * @param numPoints [in] initial capacity.\r\n   */\r\n  public constructor(numPoints: number = 8) {\r\n    super();\r\n    this._data = new Float64Array(numPoints * 2);   // 8 Points to start (2 values each)\r\n    this._xyInUse = 0;\r\n    this._xyzCapacity = numPoints;\r\n  }\r\n  /** Return the number of points in use. */\r\n  public get length() { return this._xyInUse; }\r\n\r\n  /** Set number of points.\r\n   * Pad zeros if length grows.\r\n   */\r\n  public set length(newLength: number) {\r\n    let oldLength = this.length;\r\n    if (newLength < oldLength) {\r\n      this._xyInUse = newLength;\r\n    } else if (newLength > oldLength) {\r\n      this.ensureCapacity(newLength);\r\n      while (oldLength++ < newLength)\r\n        this.pushXY(0, 0);\r\n    }\r\n  }\r\n\r\n  /** Return the number of float64 in use. */\r\n  public get float64Length() { return this._xyInUse * 2; }\r\n  /** Return the raw packed data.\r\n   * * Note that the length of the returned Float64Array is a count of doubles, and includes the excess capacity\r\n   */\r\n  public float64Data(): Float64Array { return this._data; }\r\n\r\n  /** If necessary, increase the capacity to a new pointCount.  Current coordinates and point count (length) are unchanged. */\r\n  public ensureCapacity(pointCapacity: number) {\r\n    if (pointCapacity > this._xyzCapacity) {\r\n      const newData = new Float64Array(pointCapacity * 2);\r\n      const numCopy = this.length * 2;\r\n      for (let i = 0; i < numCopy; i++) newData[i] = this._data[i];\r\n      this._data = newData;\r\n      this._xyzCapacity = pointCapacity;\r\n    }\r\n  }\r\n  /** Resize the actual point count, preserving excess capacity. */\r\n  public resize(pointCount: number) {\r\n    if (pointCount < this.length) {\r\n      this._xyInUse = pointCount >= 0 ? pointCount : 0;\r\n    } else if (pointCount > this._xyzCapacity) {\r\n      const newArray = new Float64Array(pointCount * 2);\r\n      // Copy contents\r\n      for (let i = 0; i < this._data.length; i += 2) {\r\n        newArray[i] = this._data[i];\r\n        newArray[i + 1] = this._data[i + 1];\r\n        newArray[i + 2] = this._data[i + 2];\r\n      }\r\n      this._data = newArray;\r\n      this._xyzCapacity = pointCount;\r\n      this._xyInUse = pointCount;\r\n    }\r\n  }\r\n  /**\r\n   * Make a copy of the (active) points in this array.\r\n   * (The clone does NOT get excess capacity)\r\n   */\r\n  public clone(): GrowableXYArray {\r\n    const newPoints = new GrowableXYArray(this.length);\r\n    const numValue = this.length * 2;\r\n    const newData = newPoints._data;\r\n    const data = this._data;\r\n    for (let i = 0; i < numValue; i++) newData[i] = data[i];\r\n    newPoints._xyInUse = this.length;\r\n    return newPoints;\r\n  }\r\n  /** Create an array populated from\r\n   * * An array of Point2d\r\n   * * An array of Point3d (hidden as XAndY)\r\n   * * An array of objects with keyed values, et `{x:1, y:1}`\r\n   * * A `GrowableXYZArray`\r\n   */\r\n  public static create(data: XAndY[] | GrowableXYZArray): GrowableXYArray {\r\n    const newPoints = new GrowableXYArray(data.length);\r\n    if (data instanceof GrowableXYZArray) {\r\n      newPoints.pushAllXYAndZ(data);\r\n    } else {\r\n      newPoints.pushAll(data);\r\n    }\r\n    return newPoints;\r\n  }\r\n\r\n  /** Restructure MultiLineStringDataVariant as array of GrowableXYZArray */\r\n  public static createArrayOfGrowableXYZArray(data: MultiLineStringDataVariant): GrowableXYZArray[] | undefined {\r\n    const collector = new PointStreamGrowableXYZArrayCollector();\r\n    VariantPointDataStream.streamXYZ(data, collector);\r\n    return collector.claimArrayOfGrowableXYZArray();\r\n  }\r\n  /** push a point to the end of the array */\r\n  public push(toPush: XAndY) {\r\n    this.pushXY(toPush.x, toPush.y);\r\n  }\r\n\r\n  /** push all points of an array */\r\n  public pushAll(points: XAndY[]) {\r\n    for (const p of points) this.push(p);\r\n  }\r\n  /** push all points of an array */\r\n  public pushAllXYAndZ(points: XYAndZ[] | GrowableXYZArray) {\r\n    if (points instanceof GrowableXYZArray) {\r\n      const xyzBuffer = points.float64Data();\r\n      const n = points.length * 3;\r\n      for (let i = 0; i + 2 < n; i += 3) {\r\n        this.pushXY(xyzBuffer[i], xyzBuffer[i + 1]);\r\n      }\r\n    } else {\r\n      for (const p of points) this.pushXY(p.x, p.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replicate numWrap xyz values from the front of the array as new values at the end.\r\n   * @param numWrap number of xyz values to replicate\r\n   */\r\n  public pushWrap(numWrap: number) {\r\n    if (this._xyInUse > 0) {\r\n      let k;\r\n      for (let i = 0; i < numWrap; i++) {\r\n        k = 2 * i;\r\n        this.pushXY(this._data[k], this._data[k + 1]);\r\n      }\r\n    }\r\n  }\r\n  /** push a point given by x,y coordinates */\r\n  public pushXY(x: number, y: number) {\r\n    const index = this._xyInUse * 2;\r\n    if (index >= this._data.length)\r\n      this.ensureCapacity(this.length === 0 ? 4 : this.length * 2);\r\n    this._data[index] = x;\r\n    this._data[index + 1] = y;\r\n    this._xyInUse++;\r\n  }\r\n\r\n  /** Remove one point from the back.\r\n   * * NOTE that (in the manner of std::vector native) this is \"just\" removing the point -- no point is NOT returned.\r\n   * * Use `back ()` to get the last x,y,z assembled into a `Point3d `\r\n   */\r\n  public pop() {\r\n    if (this._xyInUse > 0)\r\n      this._xyInUse--;\r\n  }\r\n  /**\r\n   * Test if index is valid for an xyz (point or vector) within this array\r\n   * @param index xyz index to test.\r\n   */\r\n  public isIndexValid(index: number): boolean {\r\n    if (index >= this._xyInUse || index < 0)\r\n      return false;\r\n    return true;\r\n  }\r\n  /**\r\n   * Clear all xyz data, but leave capacity unchanged.\r\n   */\r\n  public clear() {\r\n    this._xyInUse = 0;\r\n  }\r\n  /**\r\n   * Get a point by index, strongly typed as a Point2d.  This is unchecked.  Use atPoint2dIndex to have validity test.\r\n   * @param pointIndex index to access\r\n   * @param result optional result\r\n   */\r\n  public getPoint2dAtUncheckedPointIndex(pointIndex: number, result?: Point2d): Point2d {\r\n    const index = 2 * pointIndex;\r\n    return Point2d.create(this._data[index], this._data[index + 1], result);\r\n  }\r\n\r\n  /**\r\n   * Get x coordinate by point index, with no index checking\r\n   * @param pointIndex index to access\r\n   */\r\n  public getXAtUncheckedPointIndex(pointIndex: number): number {\r\n    return this._data[2 * pointIndex];\r\n  }\r\n\r\n  /**\r\n   * Get y coordinate by index, with no index checking\r\n   * @param pointIndex index to access\r\n   */\r\n  public getYAtUncheckedPointIndex(pointIndex: number): number {\r\n    return this._data[2 * pointIndex + 1];\r\n  }\r\n\r\n  /**\r\n   * Gather all points as a Point2d[]\r\n   */\r\n  public getPoint2dArray(): Point2d[] {\r\n    const n = 2 * this._xyInUse;\r\n    const result = [];\r\n    const data = this._data;\r\n    for (let i = 0; i < n; i += 2)\r\n      result.push(Point2d.create(data[i], data[i + 1]));\r\n    return result;\r\n  }\r\n\r\n  /** copy xyz into strongly typed Point2d */\r\n  public getPoint2dAtCheckedPointIndex(pointIndex: number, result?: Point2d): Point2d | undefined {\r\n    const index = 2 * pointIndex;\r\n    if (this.isIndexValid(pointIndex)) {\r\n      return Point2d.create(this._data[index], this._data[index + 1], result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** copy xyz into strongly typed Vector2d */\r\n  public getVector2dAtCheckedVectorIndex(vectorIndex: number, result?: Vector2d): Vector2d | undefined {\r\n    const index = 2 * vectorIndex;\r\n    if (this.isIndexValid(vectorIndex)) {\r\n      return Vector2d.create(this._data[index], this._data[index + 1], result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Read coordinates from source array, place them at index within this array.\r\n   * @param destIndex point index where coordinates are to be placed in this array\r\n   * @param source source array\r\n   * @param sourceIndex point index in source array\r\n   * @returns true if destIndex and sourceIndex are both valid.\r\n   */\r\n  public transferFromGrowableXYArray(destIndex: number, source: GrowableXYArray, sourceIndex: number): boolean {\r\n    if (this.isIndexValid(destIndex) && source.isIndexValid(sourceIndex)) {\r\n      const i = destIndex * 2;\r\n      const j = sourceIndex * 2;\r\n      this._data[i] = source._data[j];\r\n      this._data[i + 1] = source._data[j + 1];\r\n      this._data[i + 2] = source._data[j + 2];\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * push coordinates from the source array to the end of this array.\r\n   * @param source source array\r\n   * @param sourceIndex xyz index within the source.  If undefined, push entire contents of source\r\n   * @returns true if sourceIndex is valid.\r\n   */\r\n  public pushFromGrowableXYArray(source: GrowableXYArray, sourceIndex?: number): number {\r\n    if (sourceIndex === undefined) {\r\n      const numPresent = this.length;\r\n      const numPush = source.length;\r\n      this.ensureCapacity(numPresent + numPush);\r\n      const numFloatPresent = 2 * numPresent;\r\n      const numFloatAdd = 2 * numPush;\r\n      for (let i = 0; i < numFloatAdd; i++)\r\n        this._data[numFloatPresent + i] = source._data[i];\r\n      this._xyInUse += numPush;\r\n      return numPush;\r\n    }\r\n    if (source.isIndexValid(sourceIndex)) {\r\n      const j = sourceIndex * 2;\r\n      this.pushXY(source._data[j], source._data[j + 1]);\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * * Compute a point at fractional coordinate between points i and j of source\r\n   * * push onto this array.\r\n   */\r\n  public pushInterpolatedFromGrowableXYArray(source: GrowableXYArray, i: number, fraction: number, j: number) {\r\n    if (source.isIndexValid(i) && source.isIndexValid(j)) {\r\n      const data = source._data;\r\n      i = 3 * i;\r\n      j = 3 * j;\r\n      this.pushXY(Geometry.interpolate(data[i], fraction, data[j]),\r\n        Geometry.interpolate(data[i + 1], fraction, data[j + 1]));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * push coordinates from the source array to the end of this array.\r\n   * @param source source array\r\n   * @param transform optional transform to apply to points.\r\n   * @param dest optional result.\r\n   */\r\n  public static createFromGrowableXYZArray(source: GrowableXYZArray, transform?: Transform, dest?: GrowableXYArray) {\r\n    const packedXYZ = source.float64Data();\r\n    const numXYZ = source.length;    // this is in xyz points\r\n    const nDouble = 3 * numXYZ;\r\n    if (!dest)\r\n      dest = new GrowableXYArray(numXYZ);\r\n    dest.clear();\r\n    let x;\r\n    let y;\r\n    let z;\r\n    if (transform) {\r\n      for (let i = 0; i < nDouble; i += 3) {\r\n        x = packedXYZ[i];\r\n        y = packedXYZ[i + 1];\r\n        z = packedXYZ[i + 2];\r\n        dest.pushXY(transform.multiplyComponentXYZ(0, x, y, z), transform.multiplyComponentXYZ(1, x, y, z));\r\n      }\r\n    } else {\r\n      for (let i = 0; i < nDouble; i += 3) {\r\n        x = packedXYZ[i];\r\n        y = packedXYZ[i + 1];\r\n        dest.pushXY(x, y);\r\n      }\r\n    }\r\n    return dest;\r\n  }\r\n  /**\r\n   * Return the first point, or undefined if the array is empty.\r\n   */\r\n  public front(result?: Point2d): Point2d | undefined {\r\n    if (this._xyInUse === 0) return undefined;\r\n    return this.getPoint2dAtUncheckedPointIndex(0, result);\r\n  }\r\n  /**\r\n   * Return the last point, or undefined if the array is empty.\r\n   */\r\n  public back(result?: Point2d): Point2d | undefined {\r\n    if (this._xyInUse < 1) return undefined;\r\n    return this.getPoint2dAtUncheckedPointIndex(this._xyInUse - 1, result);\r\n  }\r\n  /**\r\n   * Set the coordinates of a single point.\r\n   * @param pointIndex index of point to set\r\n   * @param value coordinates to set\r\n   */\r\n  public setAtCheckedPointIndex(pointIndex: number, value: XAndY): boolean {\r\n    if (!this.isIndexValid(pointIndex))\r\n      return false;\r\n    const index = pointIndex * 2;\r\n    this._data[index] = value.x;\r\n    this._data[index + 1] = value.y;\r\n    return true;\r\n  }\r\n  /**\r\n   * Set the coordinates of a single point given as coordinates\r\n   * @param pointIndex index of point to set\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   */\r\n  public setXYZAtCheckedPointIndex(pointIndex: number, x: number, y: number): boolean {\r\n    if (!this.isIndexValid(pointIndex))\r\n      return false;\r\n    const index = pointIndex * 2;\r\n    this._data[index] = x;\r\n    this._data[index + 1] = y;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Copy all points into a simple array of Point3D with given z.\r\n   */\r\n  public getPoint3dArray(z: number = 0): Point3d[] {\r\n    const result = [];\r\n    const data = this._data;\r\n    const n = this.length;\r\n    for (let i = 0; i < n; i++) {\r\n      result.push(Point3d.create(data[i * 2], data[i * 2 + 1], z));\r\n    }\r\n    return result;\r\n  }\r\n  /** multiply each point by the transform, replace values. */\r\n  public multiplyTransformInPlace(transform: Transform) {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const coffs = transform.matrix.coffs;\r\n    const origin = transform.origin;\r\n    const x0 = origin.x;\r\n    const y0 = origin.y;\r\n    let x = 0;\r\n    let y = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 2) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      data[i] = coffs[0] * x + coffs[1] * y + x0;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y + y0;\r\n    }\r\n  }\r\n\r\n  /** multiply each xyz (as a vector) by matrix, replace values. */\r\n  public multiplyMatrix3dInPlace(matrix: Matrix3d) {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const coffs = matrix.coffs;\r\n    let x = 0;\r\n    let y = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 2) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      data[i] = coffs[0] * x + coffs[1] * y;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y;\r\n    }\r\n  }\r\n\r\n  /** multiply each point by the transform, replace values. */\r\n  public tryTransformInverseInPlace(transform: Transform): boolean {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const matrix = transform.matrix;\r\n    matrix.computeCachedInverse(true);\r\n    const coffs = matrix.inverseCoffs;\r\n    if (!coffs)\r\n      return false;\r\n    const origin = transform.origin;\r\n    const x0 = origin.x;\r\n    const y0 = origin.y;\r\n    let x = 0;\r\n    let y = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 2) {\r\n      x = data[i] - x0;\r\n      y = data[i + 1] - y0;\r\n      data[i] = coffs[0] * x + coffs[1] * y;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y;\r\n      data[i + 2] = coffs[6] * x + coffs[7] * y;\r\n    }\r\n    return true;\r\n  }\r\n  /** Extend a `Range2d`, optionally transforming the points. */\r\n  public extendRange(rangeToExtend: Range2d, transform?: Transform) {\r\n    const numDouble = this.float64Length;\r\n    const data = this._data;\r\n    if (transform) {\r\n      for (let i = 0; i + 2 <= numDouble; i += 2)\r\n        rangeToExtend.extendTransformedXY(transform, data[i], data[i + 1]);\r\n    } else {\r\n      for (let i = 0; i + 2 <= numDouble; i += 2)\r\n        rangeToExtend.extendXY(data[i], data[i + 1]);\r\n\r\n    }\r\n  }\r\n  /** sum the lengths of segments between points. */\r\n  public sumLengths(): number {\r\n    let sum = 0.0;\r\n    const n = 2 * (this._xyInUse - 1);  // Length already takes into account what specifically is in use\r\n    const data = this._data;\r\n    for (let i = 0; i < n; i += 2) sum += Geometry.hypotenuseXY(\r\n      data[i + 2] - data[i],\r\n      data[i + 3] - data[i + 1]);\r\n    return sum;\r\n  }\r\n  /**\r\n   * Multiply each x,y,z by the scale factor.\r\n   * @param factor\r\n   */\r\n  public scaleInPlace(factor: number) {\r\n    if (this._data) {\r\n      const numFloat = this.float64Length;\r\n      for (let i = 0; i < numFloat; i++)\r\n        this._data[i] = this._data[i] * factor;\r\n    }\r\n  }\r\n  /** Compute a point at fractional coordinate between points i and j */\r\n  public interpolate(i: number, fraction: number, j: number, result?: Point2d): Point2d | undefined {\r\n    if (this.isIndexValid(i) && this.isIndexValid(j)) {\r\n      const fraction0 = 1.0 - fraction;\r\n      const data = this._data;\r\n      i = 2 * i;\r\n      j = 2 * j;\r\n      return Point2d.create(\r\n        fraction0 * data[i] + fraction * data[j],\r\n        fraction0 * data[i + 1] + fraction * data[j + 1], result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Sum the signed areas of the projection to xy plane */\r\n  public areaXY(): number {\r\n    let area = 0.0;\r\n    const n = 2 * this._xyInUse;    // float count !!\r\n    if (n > 4) {\r\n      const x0 = this._data[n - 2];\r\n      const y0 = this._data[n - 1];\r\n      let dx1 = this._data[0] - x0;\r\n      let dy1 = this._data[1] - y0;\r\n      let dx2 = 0;\r\n      let dy2 = 0;\r\n      for (let i = 2; i < n; i += 2, dx1 = dx2, dy1 = dy2) {\r\n        dx2 = this._data[i] - x0;\r\n        dy2 = this._data[i + 1] - y0;\r\n        area += Geometry.crossProductXYXY(dx1, dy1, dx2, dy2);\r\n      }\r\n    }\r\n    return 0.5 * area;\r\n  }\r\n\r\n  /** Compute a vector from index origin i to indexed target j  */\r\n  public vectorIndexIndex(i: number, j: number, result?: Vector2d): Vector2d | undefined {\r\n    if (!this.isIndexValid(i) || !this.isIndexValid(j))\r\n      return undefined;\r\n    const data = this._data;\r\n    i = 2 * i;\r\n    j = 2 * j;\r\n    return Vector2d.create(data[j] - data[i], data[j + 1] - data[i + 1], result);\r\n  }\r\n\r\n  /** Compute a vector from origin to indexed target j */\r\n  public vectorXAndYIndex(origin: XAndY, j: number, result?: Vector2d): Vector2d | undefined {\r\n    if (this.isIndexValid(j)) {\r\n      const data = this._data;\r\n      j = 2 * j;\r\n      return Vector2d.create(\r\n        data[j] - origin.x,\r\n        data[j + 1] - origin.y, result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Compute the cross product of vectors from from indexed origin to indexed targets i and j */\r\n  public crossProductIndexIndexIndex(originIndex: number, targetAIndex: number, targetBIndex: number): number | undefined {\r\n    const i = originIndex * 2;\r\n    const j = targetAIndex * 2;\r\n    const k = targetBIndex * 2;\r\n    const data = this._data;\r\n    if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))\r\n      return Geometry.crossProductXYXY(\r\n        data[j] - data[i], data[j + 1] - data[i + 1],\r\n        data[k] - data[i], data[k + 1] - data[i + 1]);\r\n    return undefined;\r\n  }\r\n\r\n  /** Compute the cross product of vectors from from origin to indexed targets i and j */\r\n  public crossProductXAndYIndexIndex(origin: XAndY, targetAIndex: number, targetBIndex: number): number | undefined {\r\n    const j = targetAIndex * 2;\r\n    const k = targetBIndex * 2;\r\n    const data = this._data;\r\n    if (this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))\r\n      return Geometry.crossProductXYXY(\r\n        data[j] - origin.x, data[j + 1] - origin.y,\r\n        data[k] - origin.x, data[k + 1] - origin.y);\r\n    return undefined;\r\n  }\r\n\r\n  /** Return the distance between two points in the array. */\r\n  public distance(i: number, j: number): number | undefined {\r\n    if (this.isIndexValid(i) && this.isIndexValid(j)) {\r\n      const i0 = 2 * i;\r\n      const j0 = 2 * j;\r\n      return Geometry.hypotenuseXY(\r\n        this._data[j0] - this._data[i0],\r\n        this._data[j0 + 1] - this._data[i0 + 1]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return the distance between an array point and the input point. */\r\n  public distanceIndexToPoint(i: number, spacePoint: Point2d): number | undefined {\r\n    if (this.isIndexValid(i)) {\r\n      const i0 = 2 * i;\r\n      return Geometry.hypotenuseXY(\r\n        spacePoint.x - this._data[i0],\r\n        spacePoint.y - this._data[i0 + 1]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Test for nearly equal arrays. */\r\n  public static isAlmostEqual(dataA: GrowableXYArray | undefined, dataB: GrowableXYArray | undefined): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++)\r\n        if (!dataA.getPoint2dAtUncheckedPointIndex(i).isAlmostEqual(dataB.getPoint2dAtUncheckedPointIndex(i)))\r\n          return false;\r\n      return true;\r\n    }\r\n    // if both are null it is equal, otherwise unequal\r\n    return (!dataA && !dataB);\r\n  }\r\n\r\n  /** Return an array of block indices sorted per compareLexicalBlock function */\r\n  public sortIndicesLexical(): Uint32Array {\r\n    const n = this._xyInUse;\r\n    // let numCompare = 0;\r\n    const result = new Uint32Array(n);\r\n    for (let i = 0; i < n; i++)result[i] = i;\r\n    result.sort(\r\n      (blockIndexA: number, blockIndexB: number) => {\r\n        // numCompare++;\r\n        return this.compareLexicalBlock(blockIndexA, blockIndexB);\r\n      });\r\n    // console.log (n, numCompare);\r\n    return result;\r\n  }\r\n\r\n  /** compare two blocks in simple lexical order. */\r\n  public compareLexicalBlock(ia: number, ib: number): number {\r\n    let ax = 0;\r\n    let bx = 0;\r\n    for (let i = 0; i < 2; i++) {\r\n      ax = this._data[ia * 2 + i];\r\n      bx = this._data[ib * 2 + i];\r\n      if (ax > bx) return 1;\r\n      if (ax < bx) return -1;\r\n    }\r\n    return ia - ib; // so original order is maintained among duplicates !!!!\r\n  }\r\n\r\n  /** Access a single double at offset within a block.  This has no index checking. */\r\n  public component(pointIndex: number, componentIndex: number): number {\r\n    return this._data[2 * pointIndex + componentIndex];\r\n  }\r\n  /** Toleranced equality test */\r\n  public isAlmostEqual(other: GrowableXYArray, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    const numXY = this._xyInUse;\r\n    if (other._xyInUse !== numXY)\r\n      return false;\r\n    const dataA = this._data;\r\n    const dataB = other._data;\r\n    for (let i = 0; i < 2 * numXY; i++) {\r\n      if (Math.abs(dataA[i] - dataB[i]) > tolerance)\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\nimport { Geometry, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { XYAndZ } from \"./XYZProps\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Range3d, Range1d } from \"./Range\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { IndexedReadWriteXYZCollection, IndexedXYZCollection } from \"./IndexedXYZCollection\";\r\n\r\nimport { Plane3dByOriginAndUnitNormal } from \"./Plane3dByOriginAndUnitNormal\";\r\nimport { Point2d } from \"./Point2dVector2d\";\r\n\r\n/** `GrowableXYArray` manages a (possibly growing) Float64Array to pack xy coordinates.\r\n * @public\r\n */\r\nexport class GrowableXYZArray extends IndexedReadWriteXYZCollection {\r\n  /**\r\n   * array of packed xyz xyz xyz components\r\n   */\r\n  private _data: Float64Array;\r\n  /**\r\n   * Number of xyz triples (not floats) in the array\r\n   */\r\n  private _xyzInUse: number;\r\n  /**\r\n   * capacity in xyz triples. (not floats)\r\n   */\r\n  private _xyzCapacity: number;\r\n  /** Construct a new GrowablePoint3d array.\r\n   * @param numPoints [in] initial capacity.\r\n   */\r\n  public constructor(numPoints: number = 8) {\r\n    super();\r\n    this._data = new Float64Array(numPoints * 3);   // 8 Points to start (3 values each)\r\n    this._xyzInUse = 0;\r\n    this._xyzCapacity = numPoints;\r\n  }\r\n  /** Return the number of points in use. */\r\n  public get length() { return this._xyzInUse; }\r\n\r\n  /** Set number of points.\r\n   * Pad zeros if length grows.\r\n   */\r\n  public set length(newLength: number) {\r\n    let oldLength = this.length;\r\n    if (newLength < oldLength) {\r\n      this._xyzInUse = newLength;\r\n    } else if (newLength > oldLength) {\r\n      this.ensureCapacity(newLength);\r\n      while (oldLength++ < newLength)\r\n        this.pushXYZ(0, 0, 0);\r\n    }\r\n  }\r\n\r\n  /** Return the number of float64 in use. */\r\n  public get float64Length() { return this._xyzInUse * 3; }\r\n  /** Return the raw packed data.\r\n   * * Note that the length of the returned Float64Array is a count of doubles, and includes the excess capacity\r\n   */\r\n  public float64Data(): Float64Array { return this._data; }\r\n\r\n  /** If necessary, increase the capacity to a new pointCount.  Current coordinates and point count (length) are unchanged. */\r\n  public ensureCapacity(pointCapacity: number) {\r\n    if (pointCapacity > this._xyzCapacity) {\r\n      const newData = new Float64Array(pointCapacity * 3);\r\n      const numCopy = this.length * 3;\r\n      for (let i = 0; i < numCopy; i++) newData[i] = this._data[i];\r\n      this._data = newData;\r\n      this._xyzCapacity = pointCapacity;\r\n    }\r\n  }\r\n  /** Resize the actual point count, preserving excess capacity. */\r\n  public resize(pointCount: number) {\r\n    if (pointCount < this.length) {\r\n      this._xyzInUse = pointCount >= 0 ? pointCount : 0;\r\n    } else if (pointCount > this._xyzCapacity) {\r\n      const newArray = new Float64Array(pointCount * 3);\r\n      // Copy contents\r\n      for (let i = 0; i < this._data.length; i += 3) {\r\n        newArray[i] = this._data[i];\r\n        newArray[i + 1] = this._data[i + 1];\r\n        newArray[i + 2] = this._data[i + 2];\r\n      }\r\n      this._data = newArray;\r\n      this._xyzCapacity = pointCount;\r\n      this._xyzInUse = pointCount;\r\n    }\r\n  }\r\n  /**\r\n   * Make a copy of the (active) points in this array.\r\n   * (The clone does NOT get excess capacity)\r\n   */\r\n  public clone(result?: GrowableXYZArray): GrowableXYZArray {\r\n    const numValue = this.length * 3;\r\n    if (!result)\r\n      result = new GrowableXYZArray(this.length);\r\n    else {\r\n      result.clear();\r\n      result.ensureCapacity(this.length);\r\n    }\r\n    const newData = result._data;\r\n    const data = this._data;\r\n    for (let i = 0; i < numValue; i++) newData[i] = data[i];\r\n    result._xyzInUse = this.length;\r\n    return result;\r\n  }\r\n  /** Create an array from various point data formats.\r\n   * Valid inputs are:\r\n   * * Point2d\r\n   * * point3d\r\n   * * An array of 2 doubles\r\n   * * An array of 3 doubles\r\n   * * A GrowableXYZArray\r\n   * * Any json object satisfying Point3d.isXYAndZ\r\n   * * Any json object satisfying Point3d.isXAndY\r\n   * * A Float64Array of doubles, interpreted as xyzxyz\r\n   * * An array of any of the above\r\n   * @param data source points.\r\n   * @param result optional pre-allocated GrowableXYZArray to clear and fill.\r\n   */\r\n  public static create(data: any, result?: GrowableXYZArray): GrowableXYZArray {\r\n    if (result)\r\n      result.clear();\r\n    else\r\n      result = new GrowableXYZArray(data.length);\r\n    result.pushFrom(data);\r\n    return result;\r\n  }\r\n\r\n  /** push a point to the end of the array */\r\n  public push(toPush: XYAndZ) {\r\n    this.pushXYZ(toPush.x, toPush.y, toPush.z);\r\n  }\r\n\r\n  /** push all points of an array */\r\n  public pushAll(points: Point3d[]) {\r\n    for (const p of points) this.push(p);\r\n  }\r\n  /** Push points from variant sources.\r\n   * Valid inputs are:\r\n   * * Point2d\r\n   * * point3d\r\n   * * An array of 2 doubles\r\n   * * An array of 3 doubles\r\n   * * A GrowableXYZArray\r\n   * * Any json object satisfying Point3d.isXYAndZ\r\n   * * Any json object satisfying Point3d.isXAndY\r\n   * * A Float64Array of doubles, interpreted as xyzxyz\r\n   * * An array of any of the above\r\n   * @returns the number of points added.\r\n   */\r\n  public pushFrom(p: any) {\r\n    if (p instanceof Point3d)\r\n      this.pushXYZ(p.x, p.y, p.z);\r\n    else if (p instanceof GrowableXYZArray)\r\n      this.pushFromGrowableXYZArray(p);\r\n    else if (p instanceof Point2d)\r\n      this.pushXYZ(p.x, p.y, 0.0);\r\n    else if (Geometry.isNumberArray(p, 4)) {\r\n      const n = p.length;\r\n      for (let i = 0; i + 2 < n; i += 3)\r\n        this.pushXYZ(p[i], p[i + 1], p[i + 2]);\r\n    } else if (Geometry.isNumberArray(p, 3))\r\n      this.pushXYZ(p[0], p[1], p[2]);\r\n    else if (Geometry.isNumberArray(p, 2))\r\n      this.pushXYZ(p[0], p[1], 0.0);\r\n    else if (Array.isArray(p)) {\r\n      // direct recursion re-wraps p and goes infinite.  unroll here .\r\n      for (const q of p)\r\n        this.pushFrom(q);\r\n    } else if (Point3d.isXYAndZ(p))\r\n      this.pushXYZ(p.x, p.y, p.z);\r\n    else if (Point3d.isXAndY(p))\r\n      this.pushXYZ(p.x, p.y, 0.0);\r\n    else if (p instanceof Float64Array) {\r\n      const n = p.length;\r\n      for (let i = 0; i + 2 < n; i += 3)\r\n        this.pushXYZ(p[i], p[i + 1], p[i + 2]);\r\n    } else if (p instanceof IndexedXYZCollection) {\r\n      for (let i = 0; i < p.length; i++)\r\n        this.pushXYZ(p.getXAtUncheckedPointIndex(i), p.getYAtUncheckedPointIndex(i), p.getZAtUncheckedPointIndex(i));\r\n    }\r\n  }\r\n  /**\r\n   * Replicate numWrap xyz values from the front of the array as new values at the end.\r\n   * @param numWrap number of xyz values to replicate\r\n   */\r\n  public pushWrap(numWrap: number) {\r\n    if (this._xyzInUse > 0) {\r\n      let k;\r\n      for (let i = 0; i < numWrap; i++) {\r\n        k = 3 * i;\r\n        this.pushXYZ(this._data[k], this._data[k + 1], this._data[k + 2]);\r\n      }\r\n    }\r\n  }\r\n  /** append a new point with given x,y,z */\r\n  public pushXYZ(x: number, y: number, z: number) {\r\n    const index = this._xyzInUse * 3;\r\n    if (index >= this._data.length)\r\n      this.ensureCapacity(this.length === 0 ? 4 : this.length * 2);\r\n    this._data[index] = x;\r\n    this._data[index + 1] = y;\r\n    this._data[index + 2] = z;\r\n    this._xyzInUse++;\r\n  }\r\n\r\n  /** move the coordinates at fromIndex to toIndex.\r\n   * * No action if either index is invalid.\r\n   */\r\n  public moveIndexToIndex(fromIndex: number, toIndex: number) {\r\n    if (this.isIndexValid(fromIndex) && this.isIndexValid(toIndex)) {\r\n      let iA = fromIndex * 3;\r\n      let iB = toIndex * 3;\r\n      this._data[iB++] = this._data[iA++];\r\n      this._data[iB++] = this._data[iA++];\r\n      this._data[iB] = this._data[iA];\r\n    }\r\n  }\r\n  /** Remove one point from the back.\r\n   * * NOTE that (in the manner of std::vector native) this is \"just\" removing the point -- no point is NOT returned.\r\n   * * Use `back ()` to get the last x,y,z assembled into a `Point3d `\r\n   */\r\n  public pop() {\r\n    if (this._xyzInUse > 0)\r\n      this._xyzInUse--;\r\n  }\r\n  /**\r\n   * Test if index is valid for an xyz (point or vector) within this array\r\n   * @param index xyz index to test.\r\n   */\r\n  public isIndexValid(index: number): boolean {\r\n    if (index >= this._xyzInUse || index < 0)\r\n      return false;\r\n    return true;\r\n  }\r\n  /**\r\n   * Clear all xyz data, but leave capacity unchanged.\r\n   */\r\n  public clear() {\r\n    this._xyzInUse = 0;\r\n  }\r\n  /**\r\n   * Get a point by index, strongly typed as a Point3d.  This is unchecked.  Use getPoint3dAtCheckedPointIndex to have validity test.\r\n   * @param pointIndex index to access\r\n   * @param result optional result\r\n   */\r\n  public getPoint3dAtUncheckedPointIndex(pointIndex: number, result?: Point3d): Point3d {\r\n    const index = 3 * pointIndex;\r\n    return Point3d.create(this._data[index], this._data[index + 1], this._data[index + 2], result);\r\n  }\r\n\r\n  /**\r\n   * Get a point by index, strongly typed as a Point2d.  This is unchecked.  Use getPoint2dAtCheckedPointIndex to have validity test.\r\n   * @param pointIndex index to access\r\n   * @param result optional result\r\n   */\r\n  public getPoint2dAtUncheckedPointIndex(pointIndex: number, result?: Point2d): Point2d {\r\n    const index = 3 * pointIndex;\r\n    return Point2d.create(this._data[index], this._data[index + 1], result);\r\n  }\r\n\r\n  /** copy xyz into strongly typed Point3d */\r\n  public getPoint3dAtCheckedPointIndex(pointIndex: number, result?: Point3d): Point3d | undefined {\r\n    const index = 3 * pointIndex;\r\n    if (this.isIndexValid(pointIndex)) {\r\n      if (!result) result = Point3d.create();\r\n      result.x = this._data[index];\r\n      result.y = this._data[index + 1];\r\n      result.z = this._data[index + 2];\r\n      return result;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** access x of indexed point */\r\n  public getXAtUncheckedPointIndex(pointIndex: number): number {\r\n    const index = 3 * pointIndex;\r\n    return this._data[index];\r\n  }\r\n\r\n  /** access y of indexed point */\r\n  public getYAtUncheckedPointIndex(pointIndex: number): number {\r\n    const index = 3 * pointIndex;\r\n    return this._data[index + 1];\r\n  }\r\n\r\n  /** access y of indexed point */\r\n  public getZAtUncheckedPointIndex(pointIndex: number): number {\r\n    const index = 3 * pointIndex;\r\n    return this._data[index + 2];\r\n  }\r\n\r\n  /** copy xy into strongly typed Point2d */\r\n  public getPoint2dAtCheckedPointIndex(pointIndex: number, result?: Point2d): Point2d | undefined {\r\n    const index = 3 * pointIndex;\r\n    if (this.isIndexValid(pointIndex)) {\r\n      if (!result) result = Point2d.create();\r\n      result.x = this._data[index];\r\n      result.y = this._data[index + 1];\r\n      return result;\r\n    }\r\n    return undefined;\r\n  }\r\n  /** copy xyz into strongly typed Vector3d */\r\n  public getVector3dAtCheckedVectorIndex(vectorIndex: number, result?: Vector3d): Vector3d | undefined {\r\n    const index = 3 * vectorIndex;\r\n    if (vectorIndex >= 0 && vectorIndex < this._xyzInUse) {\r\n      if (!result) result = Vector3d.create();\r\n      result.x = this._data[index];\r\n      result.y = this._data[index + 1];\r\n      result.z = this._data[index + 2];\r\n      return result;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Read coordinates from source array, place them at index within this array.\r\n   * @param destIndex point index where coordinates are to be placed in this array\r\n   * @param source source array\r\n   * @param sourceIndex point index in source array\r\n   * @returns true if destIndex and sourceIndex are both valid.\r\n   */\r\n  public transferFromGrowableXYZArray(destIndex: number, source: GrowableXYZArray, sourceIndex: number): boolean {\r\n    if (this.isIndexValid(destIndex) && source.isIndexValid(sourceIndex)) {\r\n      const i = destIndex * 3;\r\n      const j = sourceIndex * 3;\r\n      this._data[i] = source._data[j];\r\n      this._data[i + 1] = source._data[j + 1];\r\n      this._data[i + 2] = source._data[j + 2];\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * push coordinates from the source array to the end of this array.\r\n   * @param source source array\r\n   * @param sourceIndex xyz index within the source.  If undefined, entire source is pushed.\r\n   * @returns number of points pushed.\r\n   */\r\n  public pushFromGrowableXYZArray(source: GrowableXYZArray, sourceIndex?: number): number {\r\n    // full array push  . . .\r\n    if (sourceIndex === undefined) {\r\n      const numXYZAdd = source.length;\r\n      this.ensureCapacity(this.length + numXYZAdd);\r\n      const nXAdd = source.length * 3;\r\n      const i0 = this._xyzInUse * 3;\r\n      for (let i = 0; i < nXAdd; i++)\r\n        this._data[i0 + i] = source._data[i];\r\n      this._xyzInUse += numXYZAdd;\r\n      return numXYZAdd;\r\n    }\r\n    // single point push . . .\r\n    if (source.isIndexValid(sourceIndex)) {\r\n      const j = sourceIndex * 3;\r\n      this.pushXYZ(source._data[j], source._data[j + 1], source._data[j + 2]);\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Return the first point, or undefined if the array is empty.\r\n   */\r\n  public front(result?: Point3d): Point3d | undefined {\r\n    if (this._xyzInUse === 0) return undefined;\r\n    return this.getPoint3dAtUncheckedPointIndex(0, result);\r\n  }\r\n  /**\r\n   * Return the last point, or undefined if the array is empty.\r\n   */\r\n  public back(result?: Point3d): Point3d | undefined {\r\n    if (this._xyzInUse < 1) return undefined;\r\n    return this.getPoint3dAtUncheckedPointIndex(this._xyzInUse - 1, result);\r\n  }\r\n  /**\r\n   * Set the coordinates of a single point.\r\n   * @param pointIndex index of point to set\r\n   * @param value coordinates to set\r\n   */\r\n  public setAtCheckedPointIndex(pointIndex: number, value: XYAndZ): boolean {\r\n    if (!this.isIndexValid(pointIndex))\r\n      return false;\r\n    let index = pointIndex * 3;\r\n    this._data[index++] = value.x;\r\n    this._data[index++] = value.y;\r\n    this._data[index] = value.z;\r\n    return true;\r\n  }\r\n  /**\r\n   * Set the coordinates of a single point given as coordinates\r\n   * @param pointIndex index of point to set\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   */\r\n  public setXYZAtCheckedPointIndex(pointIndex: number, x: number, y: number, z: number): boolean {\r\n    if (!this.isIndexValid(pointIndex))\r\n      return false;\r\n    let index = pointIndex * 3;\r\n    this._data[index++] = x;\r\n    this._data[index++] = y;\r\n    this._data[index] = z;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Copy all points into a simple array of Point3d\r\n   */\r\n  public getPoint3dArray(): Point3d[] {\r\n    const result = [];\r\n    const data = this._data;\r\n    const n = this.length;\r\n    for (let i = 0; i < n; i++) {\r\n      result.push(Point3d.create(data[i * 3], data[i * 3 + 1], data[i * 3 + 2]));\r\n    }\r\n    return result;\r\n  }\r\n  /** multiply each point by the transform, replace values. */\r\n  public multiplyTransformInPlace(transform: Transform) {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const coffs = transform.matrix.coffs;\r\n    const origin = transform.origin;\r\n    const x0 = origin.x;\r\n    const y0 = origin.y;\r\n    const z0 = origin.z;\r\n    let x = 0;\r\n    let y = 0;\r\n    let z = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 3) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      z = data[i + 2];\r\n      data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z + x0;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z + y0;\r\n      data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z + z0;\r\n    }\r\n  }\r\n\r\n  /** reverse the order of points. */\r\n  public reverseInPlace() {\r\n    const n = this.length;\r\n    let j0, j1;\r\n    let a;\r\n    const data = this._data;\r\n    for (let i0 = 0, i1 = n - 1; i0 < i1; i0++ , i1--) {\r\n      j0 = 3 * i0;\r\n      j1 = 3 * i1;\r\n      a = data[j0]; data[j0] = data[j1]; data[j1] = a;\r\n      j0++;\r\n      j1++;\r\n      a = data[j0]; data[j0] = data[j1]; data[j1] = a;\r\n      j0++;\r\n      j1++;\r\n      a = data[j0]; data[j0] = data[j1]; data[j1] = a;\r\n    }\r\n  }\r\n\r\n  /** multiply each xyz (as a vector) by matrix, replace values. */\r\n  public multiplyMatrix3dInPlace(matrix: Matrix3d) {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const coffs = matrix.coffs;\r\n    let x = 0;\r\n    let y = 0;\r\n    let z = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 3) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      z = data[i + 2];\r\n      data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z;\r\n      data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z;\r\n    }\r\n  }\r\n\r\n  /** multiply each xyz (as a vector) by matrix inverse transpose, renormalize the vector, replace values.\r\n   * * This is the way to apply a matrix (possibly with skew and scale) to a surface normal, and\r\n   *      have it end up perpendicular to the transformed in-surface vectors.\r\n   * * Return false if matrix is not invertible or if any normalization fails.\r\n   */\r\n  public multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(matrix: Matrix3d): boolean {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    if (!matrix.computeCachedInverse(true))\r\n      return false;\r\n    const coffs = matrix.inverseCoffs!;\r\n    const tol = 1.0e-15;\r\n    let x = 0;\r\n    let y = 0;\r\n    let z = 0;\r\n    let x1;\r\n    let y1;\r\n    let z1;\r\n    let q;\r\n    let a;\r\n    let numFail = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 3) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      z = data[i + 2];\r\n      x1 = coffs[0] * x + coffs[3] * y + coffs[6] * z;\r\n      y1 = coffs[1] * x + coffs[4] * y + coffs[7] * z;\r\n      z1 = coffs[2] * x + coffs[5] * y + coffs[8] * z;\r\n      a = x1 * x1 + y1 * y1 + z1 * z1;\r\n      if (a < tol) {\r\n        // put the originals back ..\r\n        x1 = x; y1 = y; z1 = z;\r\n        numFail++;\r\n      } else if (Math.abs(a - 1.0) > tol) {\r\n        q = 1.0 / Math.sqrt(a);\r\n        x1 *= q;\r\n        y1 *= q;\r\n        z1 *= q;\r\n      } // else -- q is near 1, no need to do the division !!\r\n      data[i] = x1;\r\n      data[i + 1] = y1;\r\n      data[i + 2] = z1;\r\n    }\r\n    return numFail === 0;\r\n  }\r\n\r\n  /** multiply each point by the transform, replace values. */\r\n  public tryTransformInverseInPlace(transform: Transform): boolean {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const matrix = transform.matrix;\r\n    matrix.computeCachedInverse(true);\r\n    const coffs = matrix.inverseCoffs;\r\n    if (!coffs)\r\n      return false;\r\n    const origin = transform.origin;\r\n    const x0 = origin.x;\r\n    const y0 = origin.y;\r\n    const z0 = origin.z;\r\n    let x = 0;\r\n    let y = 0;\r\n    let z = 0;\r\n    for (let i = 0; i + 3 <= nDouble; i += 3) {\r\n      x = data[i] - x0;\r\n      y = data[i + 1] - y0;\r\n      z = data[i + 2] - z0;\r\n      data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z;\r\n      data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z;\r\n    }\r\n    return true;\r\n  }\r\n  /** Extend `range` to extend by all points. */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform) {\r\n    const numDouble = this.float64Length;\r\n    const data = this._data;\r\n    if (transform) {\r\n      for (let i = 0; i + 3 <= numDouble; i += 3)\r\n        rangeToExtend.extendTransformedXYZ(transform, data[i], data[i + 1], data[i + 2]);\r\n    } else {\r\n      for (let i = 0; i + 3 <= numDouble; i += 3)\r\n        rangeToExtend.extendXYZ(data[i], data[i + 1], data[i + 2]);\r\n\r\n    }\r\n  }\r\n  /** get range of points. */\r\n  public getRange(transform?: Transform): Range3d {\r\n    const range = Range3d.createNull();\r\n    this.extendRange(range, transform);\r\n    return range;\r\n  }\r\n\r\n  /** Initialize `range` with coordinates in this array. */\r\n  public setRange(range: Range3d, transform?: Transform) {\r\n    range.setNull();\r\n    this.extendRange(range, transform);\r\n  }\r\n\r\n  /** Sum the lengths of segments between points. */\r\n  public sumLengths(): number {\r\n    let sum = 0.0;\r\n    const n = 3 * (this._xyzInUse - 1);  // Length already takes into account what specifically is in use\r\n    const data = this._data;\r\n    for (let i = 0; i < n; i += 3) sum += Geometry.hypotenuseXYZ(\r\n      data[i + 3] - data[i],\r\n      data[i + 4] - data[i + 1],\r\n      data[i + 5] - data[i + 2]);\r\n    return sum;\r\n  }\r\n  /**\r\n   * Multiply each x,y,z by the scale factor.\r\n   * @param factor\r\n   */\r\n  public scaleInPlace(factor: number) {\r\n    if (this._data) {\r\n      const numFloat = this.float64Length;\r\n      for (let i = 0; i < numFloat; i++)\r\n        this._data[i] = this._data[i] * factor;\r\n    }\r\n  }\r\n  /** test if all points are within tolerance of a plane. */\r\n  public isCloseToPlane(plane: Plane3dByOriginAndUnitNormal, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    const numCoordinate = 3 * this._xyzInUse;\r\n    const data = this._data;\r\n    for (let i = 0; i < numCoordinate; i += 3)\r\n      if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)\r\n        return false;\r\n    return true;\r\n  }\r\n  /** Compute a point at fractional coordinate between points i and j */\r\n  public interpolate(i: number, fraction: number, j: number, result?: Point3d): Point3d | undefined {\r\n    if (this.isIndexValid(i) && this.isIndexValid(j)) {\r\n      const fraction0 = 1.0 - fraction;\r\n      const data = this._data;\r\n      i = 3 * i;\r\n      j = 3 * j;\r\n      return Point3d.create(\r\n        fraction0 * data[i] + fraction * data[j],\r\n        fraction0 * data[i + 1] + fraction * data[j + 1],\r\n        fraction0 * data[i + 2] + fraction * data[j + 2], result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * * Compute a point at fractional coordinate between points i and j of source\r\n   * * push onto this array.\r\n   */\r\n  public pushInterpolatedFromGrowableXYZArray(source: GrowableXYZArray, i: number, fraction: number, j: number) {\r\n    if (source.isIndexValid(i) && source.isIndexValid(j)) {\r\n      const fraction0 = 1.0 - fraction;\r\n      const data = source._data;\r\n      i = 3 * i;\r\n      j = 3 * j;\r\n      this.pushXYZ(\r\n        fraction0 * data[i] + fraction * data[j],\r\n        fraction0 * data[i + 1] + fraction * data[j + 1],\r\n        fraction0 * data[i + 2] + fraction * data[j + 2]);\r\n    }\r\n  }\r\n\r\n  /** Sum the signed areas of the projection to xy plane */\r\n  public areaXY(): number {\r\n    let area = 0.0;\r\n    const n = 3 * this._xyzInUse;    // float count !!\r\n    if (n > 6) {\r\n      const x0 = this._data[n - 3];\r\n      const y0 = this._data[n - 2];\r\n      let dx1 = this._data[0] - x0;\r\n      let dy1 = this._data[1] - y0;\r\n      let dx2 = 0;\r\n      let dy2 = 0;\r\n      for (let i = 3; i < n; i += 3, dx1 = dx2, dy1 = dy2) {\r\n        dx2 = this._data[i] - x0;\r\n        dy2 = this._data[i + 1] - y0;\r\n        area += Geometry.crossProductXYXY(dx1, dy1, dx2, dy2);\r\n      }\r\n    }\r\n    return 0.5 * area;\r\n  }\r\n\r\n  /** Compute a vector from index origin i to indexed target j  */\r\n  public vectorIndexIndex(i: number, j: number, result?: Vector3d): Vector3d | undefined {\r\n    if (!this.isIndexValid(i) || !this.isIndexValid(j))\r\n      return undefined;\r\n    if (!result) result = Vector3d.create();\r\n    const data = this._data;\r\n    i = 3 * i;\r\n    j = 3 * j;\r\n    result.x = data[j] - data[i];\r\n    result.y = data[j + 1] - data[i + 1];\r\n    result.z = data[j + 2] - data[i + 2];\r\n    return result;\r\n  }\r\n\r\n  /** Compute a vector from origin to indexed target j */\r\n  public vectorXYAndZIndex(origin: XYAndZ, j: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isIndexValid(j)) {\r\n      const data = this._data;\r\n      j = 3 * j;\r\n      return Vector3d.create(\r\n        data[j] - origin.x,\r\n        data[j + 1] - origin.y,\r\n        data[j + 2] - origin.z, result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Compute the cross product of vectors from from indexed origin to indexed targets i and j */\r\n  public crossProductIndexIndexIndex(originIndex: number, targetAIndex: number, targetBIndex: number, result?: Vector3d): Vector3d | undefined {\r\n    const i = originIndex * 3;\r\n    const j = targetAIndex * 3;\r\n    const k = targetBIndex * 3;\r\n    const data = this._data;\r\n    if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))\r\n      return Geometry.crossProductXYZXYZ(\r\n        data[j] - data[i], data[j + 1] - data[i + 1], data[j + 2] - data[i + 2],\r\n        data[k] - data[i], data[k + 1] - data[i + 1], data[k + 2] - data[i + 2],\r\n        result);\r\n    return undefined;\r\n  }\r\n\r\n  /** Compute the dot product of pointIndex with [x,y,z] */\r\n  public evaluateUncheckedIndexDotProductXYZ(pointIndex: number, x: number, y: number, z: number): number {\r\n    const i = pointIndex * 3;\r\n    const data = this._data;\r\n    return data[i] * x + data[i + 1] * y + data[i + 2] * z;\r\n  }\r\n  /** Compute the dot product of pointIndex with [x,y,z] */\r\n  public evaluateUncheckedIndexPlaneAltitude(pointIndex: number, plane: PlaneAltitudeEvaluator): number {\r\n    const i = pointIndex * 3;\r\n    const data = this._data;\r\n    return plane.altitudeXYZ(data[i], data[i + 1], data[i + 2]);\r\n  }\r\n\r\n  /**\r\n   * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.\r\n   * * accumulate it to the result.\r\n   */\r\n  public accumulateCrossProductIndexIndexIndex(originIndex: number, targetAIndex: number, targetBIndex: number, result: Vector3d): void {\r\n    const i = originIndex * 3;\r\n    const j = targetAIndex * 3;\r\n    const k = targetBIndex * 3;\r\n    const data = this._data;\r\n    if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))\r\n      result.addCrossProductToTargetsInPlace(\r\n        data[i], data[i + 1], data[i + 2],\r\n        data[j], data[j + 1], data[j + 2],\r\n        data[k], data[k + 1], data[k + 2]);\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.\r\n   * * accumulate it to the result.\r\n   */\r\n  public accumulateScaledXYZ(index: number, scale: number, sum: Point3d): void {\r\n    const i = index * 3;\r\n    const data = this._data;\r\n    if (this.isIndexValid(index)) {\r\n      sum.x += scale * data[i];\r\n      sum.y += scale * data[i + 1];\r\n      sum.z += scale * data[i + 2];\r\n    }\r\n  }\r\n\r\n  /** Compute the cross product of vectors from from origin to indexed targets i and j */\r\n  public crossProductXYAndZIndexIndex(origin: XYAndZ, targetAIndex: number, targetBIndex: number, result?: Vector3d): Vector3d | undefined {\r\n    const j = targetAIndex * 3;\r\n    const k = targetBIndex * 3;\r\n    const data = this._data;\r\n    if (this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))\r\n      return Geometry.crossProductXYZXYZ(\r\n        data[j] - origin.x, data[j + 1] - origin.y, data[j + 2] - origin.z,\r\n        data[k] - origin.x, data[k + 1] - origin.y, data[k + 2] - origin.z,\r\n        result);\r\n    return undefined;\r\n  }\r\n\r\n  /** Return the distance between two points in the array.\r\n   * @deprecated use distanceIndexIndex\r\n   */\r\n  public distance(i: number, j: number): number | undefined {\r\n    if (i >= 0 && i < this._xyzInUse && j >= 0 && j <= this._xyzInUse) {\r\n      const i0 = 3 * i;\r\n      const j0 = 3 * j;\r\n      return Geometry.hypotenuseXYZ(\r\n        this._data[j0] - this._data[i0],\r\n        this._data[j0 + 1] - this._data[i0 + 1],\r\n        this._data[j0 + 2] - this._data[i0 + 2]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return the distance between an array point and the input point. */\r\n  public distanceIndexToPoint(i: number, spacePoint: XYAndZ): number | undefined {\r\n    if (i >= 0 && i < this._xyzInUse) {\r\n      const i0 = 3 * i;\r\n      return Geometry.hypotenuseXYZ(\r\n        spacePoint.x - this._data[i0],\r\n        spacePoint.y - this._data[i0 + 1],\r\n        spacePoint.z - this._data[i0 + 2]);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Return distance squared between indicated points.\r\n   * * Concrete classes may be able to implement this without creating a temporary.\r\n   * @param index0 first point index\r\n   * @param index1 second point index\r\n   * @param defaultDistanceSquared distance squared to return if either point index is invalid.\r\n   *\r\n   */\r\n  public distanceSquaredIndexIndex(i: number, j: number): number | undefined {\r\n    if (i >= 0 && i < this._xyzInUse && j >= 0 && j <= this._xyzInUse) {\r\n      const i0 = 3 * i;\r\n      const j0 = 3 * j;\r\n      return Geometry.hypotenuseSquaredXYZ(\r\n        this._data[j0] - this._data[i0],\r\n        this._data[j0 + 1] - this._data[i0 + 1],\r\n        this._data[j0 + 2] - this._data[i0 + 2]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return distance between indicated points.\r\n   * * Concrete classes may be able to implement this without creating a temporary.\r\n   * @param index0 first point index\r\n   * @param index1 second point index\r\n   * @param defaultDistanceSquared distance squared to return if either point index is invalid.\r\n   */\r\n  public distanceIndexIndex(i: number, j: number): number | undefined {\r\n    if (i >= 0 && i < this._xyzInUse && j >= 0 && j <= this._xyzInUse) {\r\n      const i0 = 3 * i;\r\n      const j0 = 3 * j;\r\n      return Geometry.hypotenuseXYZ(\r\n        this._data[j0] - this._data[i0],\r\n        this._data[j0 + 1] - this._data[i0 + 1],\r\n        this._data[j0 + 2] - this._data[i0 + 2]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return the distance between points in distinct arrays. */\r\n  public static distanceBetweenPointsIn2Arrays(arrayA: GrowableXYZArray, i: number, arrayB: GrowableXYZArray, j: number): number | undefined {\r\n\r\n    if (i >= 0 && i < arrayA._xyzInUse && j >= 0 && j <= arrayB._xyzInUse) {\r\n      const i0 = 3 * i;\r\n      const j0 = 3 * j;\r\n      return Geometry.hypotenuseXYZ(\r\n        arrayB._data[j0] - arrayA._data[i0],\r\n        arrayB._data[j0 + 1] - arrayA._data[i0 + 1],\r\n        arrayB._data[j0 + 2] - arrayA._data[i0 + 2]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** test for near equality between two `GrowableXYZArray`. */\r\n  public static isAlmostEqual(dataA: GrowableXYZArray | undefined, dataB: GrowableXYZArray | undefined): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++)\r\n        if (!dataA.getPoint3dAtUncheckedPointIndex(i).isAlmostEqual(dataB.getPoint3dAtUncheckedPointIndex(i)))\r\n          return false;\r\n      return true;\r\n    }\r\n    // if both are null it is equal, otherwise unequal\r\n    return (!dataA && !dataB);\r\n  }\r\n\r\n  /** Return an array of block indices sorted per compareLexicalBlock function */\r\n  public sortIndicesLexical(): Uint32Array {\r\n    const n = this._xyzInUse;\r\n    // let numCompare = 0;\r\n    const result = new Uint32Array(n);\r\n    for (let i = 0; i < n; i++)result[i] = i;\r\n    result.sort(\r\n      (blockIndexA: number, blockIndexB: number) => {\r\n        // numCompare++;\r\n        return this.compareLexicalBlock(blockIndexA, blockIndexB);\r\n      });\r\n    // console.log (n, numCompare);\r\n    return result;\r\n  }\r\n\r\n  /** compare two blocks in simple lexical order. */\r\n  public compareLexicalBlock(ia: number, ib: number): number {\r\n    let ax = 0;\r\n    let bx = 0;\r\n    for (let i = 0; i < 3; i++) {\r\n      ax = this._data[ia * 3 + i];\r\n      bx = this._data[ib * 3 + i];\r\n      if (ax > bx) return 1;\r\n      if (ax < bx) return -1;\r\n    }\r\n    return ia - ib; // so original order is maintained among duplicates !!!!\r\n  }\r\n\r\n  /** Access a single double at offset within a block.  This has no index checking. */\r\n  public component(pointIndex: number, componentIndex: number): number {\r\n    return this._data[3 * pointIndex + componentIndex];\r\n  }\r\n  /**\r\n   * add points at regular steps from `other`\r\n   * @param source\r\n   * @param pointIndex0\r\n   * @param step\r\n   * @param numAdd\r\n   */\r\n  public addSteppedPoints(other: GrowableXYZArray, pointIndex0: number, step: number, numAdd: number) {\r\n    const dataB = other._data;\r\n    let b0 = pointIndex0 * 3;\r\n    const nb = other.length * 3;\r\n    let numAdded = 0;\r\n    while (b0 >= 0 && b0 + 2 < nb && numAdded < numAdd) {\r\n      this.pushXYZ(dataB[b0], dataB[b0 + 1], dataB[b0 + 2]);\r\n      b0 += step * 3;\r\n      numAdded++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * find the min and max distance between corresponding indexed points.   Excess points are ignored.\r\n   * @param arrayA first array\r\n   * @param arrayB second array\r\n   */\r\n  public static distanceRangeBetweenCorrespondingPoints(arrayA: GrowableXYZArray, arrayB: GrowableXYZArray): Range1d {\r\n    const dataA = arrayA._data;\r\n    const dataB = arrayB._data;\r\n    const n = Math.min(arrayA.length, arrayB.length);\r\n    let i = 0;\r\n    let k0;\r\n    const range = Range1d.createNull();\r\n    while (i < n) {\r\n      k0 = 3 * i;\r\n      range.extendX(Geometry.hypotenuseXYZ(dataA[k0] - dataB[k0], dataA[k0 + 1] - dataB[k0 + 1], dataA[k0 + 2] - dataB[k0 + 2]));\r\n      i++;\r\n    }\r\n    return range;\r\n  }\r\n  /**\r\n   * * Triangle for (unchecked!) for three points identified by index\r\n   * * z direction of frame is 001.\r\n   * * Transform axes from origin to targetX and targetY\r\n   * * in local coordinates (u,v,w) the xy interior of the triangle is `u>=0, v>= 0, w>= 0, u+v+w<1`\r\n   * * Return undefined if transform is invertible (i.e. points are not in a vertical plane.)\r\n   */\r\n  public fillLocalXYTriangleFrame(originIndex: number, targetAIndex: number, targetBIndex: number, result?: Transform): Transform | undefined {\r\n    if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex)) {\r\n      let i0 = originIndex * 3;\r\n      const data = this._data;\r\n      const ax = data[i0++];\r\n      const ay = data[i0++];\r\n      const az = data[i0++];\r\n      i0 = targetAIndex * 3;\r\n      const ux = data[i0++] - ax;\r\n      const uy = data[i0++] - ay;\r\n      const uz = data[i0++] - az;\r\n      i0 = targetBIndex * 3;\r\n      const vx = data[i0++] - ax;\r\n      const vy = data[i0++] - ay;\r\n      const vz = data[i0++] - az;\r\n      result = Transform.createRowValues(\r\n        ux, vx, 0, ax,\r\n        uy, vy, 0, ay,\r\n        uz, vz, 1, az, result);\r\n      return result.computeCachedInverse() ? result : undefined;\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Pass the (x,y,z) of each point to a function which returns a replacement for of of the 3 components.\r\n   * @param componentIndex Index (0,1,2) of component to be replaced.\r\n   * @param func function to be called as `func(x,y,z)`, returning a replacement value for componentIndex\r\n   */\r\n  public mapComponent(componentIndex: 0 | 1 | 2, func: (x: number, y: number, z: number) => number) {\r\n    const n = this._data.length;\r\n    let q;\r\n    for (let i = 0; i + 2 < n; i += 3) {\r\n      q = func(this._data[i], this._data[i + 1], this._data[i + 2]);\r\n      this._data[i + componentIndex] = q;\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { IndexedXYZCollection } from \"./IndexedXYZCollection\";\r\n\r\n/** @module ArraysAndInterfaces */\r\ninterface CollectionWithLength {\r\n  length: number;\r\n}\r\n/**\r\n * Object describing a (contiguous) subset of indices to an IndexedXYZCollection\r\n * @public\r\n */\r\nexport class IndexedCollectionInterval<T extends CollectionWithLength> {\r\n  /** Any collection that has a .length member or property */\r\n  public points: T;\r\n  /** lower limit of index range */\r\n  public begin: number;\r\n  /** upper limit (beyond) index range. */\r\n  public end: number;\r\n  protected constructor(points: T, base: number, limit: number) {\r\n    this.points = points;\r\n    this.begin = base;\r\n    this.end = limit;\r\n  }\r\n  /** Create an interval which matches a complete indexed collection. */\r\n  public static createComplete<T extends CollectionWithLength>(points: T): IndexedCollectionInterval<T> {\r\n    return new this(points, 0, points.length);\r\n  }\r\n  /** Create an interval which matches a collection from `start <= i < end`. */\r\n  public static createBeginEnd<T extends CollectionWithLength>(points: T, begin: number, end: number): IndexedCollectionInterval<T> {\r\n    return new this(points, begin, end);\r\n  }\r\n\r\n  /** Create an interval which matches a collection from `start <= i < end`. */\r\n  public static createBeginLength<T extends CollectionWithLength>(points: T, begin: number, length: number): IndexedCollectionInterval<T> {\r\n    return new this(points, begin, begin + length);\r\n  }\r\n  /** Add one to this.begin.  Return true if the interval is still live. */\r\n  public advanceBegin(): boolean {\r\n    this.begin++;\r\n    return this.begin < this.end;\r\n  }\r\n  /** advance this.end (but do not go beyond this.points.length)   return true if the interval is still live. */\r\n  public advanceEnd(): boolean {\r\n    this.end++;\r\n    if (this.end > this.points.length)\r\n      this.end = this.points.length;\r\n    return this.begin < this.end;\r\n  }\r\n  /** Return (if possible) the parent index corresponding to `localIndex` */\r\n  public localIndexToParentIndex(localIndex: number): number | undefined {\r\n    if (localIndex >= 0) {\r\n      const parentIndex = this.begin + localIndex;\r\n      if (parentIndex < this.points.length)\r\n        return parentIndex;\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return true if\r\n   * * the interval is empty (the empty set is a subset of all sets!)\r\n   * * all indices in its range are valid.\r\n   */\r\n  public get isValidSubset(): boolean {\r\n    return this.length === 0\r\n      || (this.localIndexToParentIndex(0) !== undefined\r\n        && this.localIndexToParentIndex(this.length - 1) !== undefined);\r\n  }\r\n  /** restrict this.end to this.points.length */\r\n  public restrictEnd() {\r\n    if (this.end > this.points.length)\r\n      this.end = this.points.length;\r\n  }\r\n  /** Return true if length is 1 or more */\r\n  public get isNonEmpty(): boolean {\r\n    return this.begin < this.end;\r\n  }\r\n  /** Advance this.begin to (other.end-1), i.e. catch the last member of other. */\r\n  public advanceToTail(other: IndexedCollectionInterval<T>): boolean {\r\n    this.begin = other.end - 1;\r\n    return this.isNonEmpty;\r\n  }\r\n  /** Advance this.begin to (other.begin), i.e. catch the first member of other. */\r\n  public advanceToHead(other: IndexedCollectionInterval<T>): boolean {\r\n    this.begin = other.begin;\r\n    return this.isNonEmpty;\r\n  }\r\n\r\n  /** Set this interval from another, with conditional replacements:\r\n   * * Always reference the same points as other.\r\n   * * use optional begin and end arguments if present; if not take begin and and from other.\r\n   * * cap end at points.length.\r\n   */\r\n  public setFrom(other: IndexedCollectionInterval<T>, base?: number, limit?: number) {\r\n    this.points = other.points;\r\n    this.begin = base === undefined ? other.begin : base;\r\n    this.end = limit === undefined ? other.end : limit;\r\n    this.restrictEnd();\r\n  }\r\n  /** Return the number of steps possible with current begin and end */\r\n  public get length(): number {\r\n    return this.end > this.begin ? this.end - this.begin : 0;\r\n  }\r\n  /** Return true if the length is exactly 1 */\r\n  public get isSingleton(): boolean {\r\n    return this.begin + 1 === this.end;\r\n  }\r\n}\r\n\r\n/**\r\n * Reference to an interval of the indices of an IndexedXYZCollection.\r\n * @public\r\n */\r\nexport class IndexedXYZCollectionInterval extends IndexedCollectionInterval<IndexedXYZCollection> {\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { XAndY } from \"./XYZProps\";\r\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\r\n\r\n/**\r\n * abstract base class for access to XYZ data with indexed reference.\r\n * * This allows algorithms to work with Point2d[] or GrowableXYZ.\r\n * ** GrowableXYZArray implements these for its data.\r\n * ** Point2dArrayCarrier carries a (reference to) a Point2d[] and implements the methods with calls on that array reference.\r\n * * In addition to \"point by point\" accessors, there abstract members compute commonly useful vector data \"between points\".\r\n * * Methods that create vectors among multiple indices allow callers to avoid creating temporaries.\r\n * @public\r\n */\r\nexport abstract class IndexedXYCollection {\r\n  /**\r\n   * Get from `index` as a `Point2d`\r\n   * @param index index of point within the array\r\n   * @param result optional caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public abstract getPoint2dAtCheckedPointIndex(index: number, result?: Point2d): Point2d | undefined;\r\n  /**\r\n   * Get from `index` as a `Vector2d`\r\n   * @param index index of point within the array\r\n   * @param result optional caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public abstract getVector2dAtCheckedVectorIndex(index: number, result?: Vector2d): Vector2d | undefined;\r\n  /**\r\n   * Return a vector from the point at `indexA` to the point at `indexB`\r\n   * @param indexA index of point within the array\r\n   * @param indexB index of point within the array\r\n   * @param result optional caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public abstract vectorIndexIndex(indexA: number, indexB: number, result?: Vector2d): Vector2d | undefined;\r\n  /**\r\n   * Return a vector from given origin to the point at `indexB`\r\n   * @param origin origin for vector\r\n   * @param indexB index of point within the array\r\n   * @param result optional caller-allocated vector.\r\n   * @returns undefined if index is out of bounds\r\n   */\r\n  public abstract vectorXAndYIndex(origin: XAndY, indexB: number, result?: Vector2d): Vector2d | undefined;\r\n\r\n  /**\r\n   * Return the cross product of vectors from `origin` to points at `indexA` and `indexB`\r\n   * @param origin origin for vector\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result optional caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public abstract crossProductXAndYIndexIndex(origin: XAndY, indexA: number, indexB: number): number | undefined;\r\n  /**\r\n   * Return the cross product of vectors from origin point at `indexA` to target points at `indexB` and `indexC`\r\n   * @param origin index of origin\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result optional caller - allocated vector.\r\n   * @returns return true if indexA, indexB both valid\r\n   */\r\n    public abstract crossProductIndexIndexIndex(origin: number, indexA: number, indexB: number): number | undefined;\r\n\r\n    /**\r\n     * read-only property for number of XYZ in the collection.\r\n     */\r\n  public abstract get length(): number;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { XYAndZ } from \"./XYZProps\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Range3d } from \"./Range\";\r\n\r\nclass PointsIterator implements Iterator<Point3d>, Iterable<Point3d> {\r\n  private readonly _collection: IndexedXYZCollection;\r\n  private _curIndex = -1;\r\n\r\n  public constructor(collection: IndexedXYZCollection) {\r\n    this._collection = collection;\r\n  }\r\n\r\n  public next(): IteratorResult<Point3d> {\r\n    if (++this._curIndex >= this._collection.length) {\r\n      // The ECMAScript spec states that value=undefined is valid if done=true. The TypeScript interface violates the spec hence the cast to any and back below.\r\n      return { done: true } as any as IteratorResult<Point3d>;\r\n    }\r\n\r\n    return {\r\n      value: this._collection.getPoint3dAtUncheckedPointIndex(this._curIndex),\r\n      done: false,\r\n    };\r\n  }\r\n\r\n  public [Symbol.iterator](): Iterator<Point3d> { return this; }\r\n}\r\n/**\r\n * abstract base class for read-only access to XYZ data with indexed reference.\r\n * * This allows algorithms to work with Point3d[] or GrowableXYZ.\r\n * ** GrowableXYZArray implements these for its data.\r\n * ** Point3dArrayCarrier carries a (reference to) a Point3d[] and implements the methods with calls on that array reference.\r\n * * In addition to \"point by point\" accessors, there abstract members compute commonly useful vector data \"between points\".\r\n * * Methods that create vectors among multiple indices allow callers to avoid creating temporaries.\r\n * @public\r\n */\r\nexport abstract class IndexedXYZCollection {\r\n  /**\r\n   * Return the point at `index` as a strongly typed Point3d.\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public abstract getPoint3dAtCheckedPointIndex(index: number, result?: Point3d): Point3d | undefined;\r\n  /**\r\n   * Return the point at `index` as a strongly typed Point3d, without checking the point index validity.\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public abstract getPoint3dAtUncheckedPointIndex(index: number, result?: Point3d): Point3d;\r\n  /**\r\n   * Get from `index` as a strongly typed Vector3d.\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public abstract getVector3dAtCheckedVectorIndex(index: number, result?: Vector3d): Vector3d | undefined;\r\n  /**\r\n   * Return a vector from the point at `indexA` to the point at `indexB`\r\n   * @param indexA index of point within the array\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public abstract vectorIndexIndex(indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;\r\n  /**\r\n   * Return a vector from `origin` to the point at `indexB`\r\n   * @param origin origin for vector\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if index is out of bounds\r\n   */\r\n  public abstract vectorXYAndZIndex(origin: XYAndZ, indexB: number, result?: Vector3d): Vector3d | undefined;\r\n\r\n  /**\r\n   * Return the cross product of the vectors from `origin` to points at `indexA` and `indexB`\r\n   * @param origin origin for vector\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public abstract crossProductXYAndZIndexIndex(origin: XYAndZ, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;\r\n  /**\r\n   * Return the cross product of vectors from `origin` to points at `indexA` and `indexB`\r\n   * @param origin origin for vector\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result optional caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public abstract crossProductIndexIndexIndex(origin: number, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;\r\n  /**\r\n   * Return the cross product of vectors from origin point at `indexA` to target points at `indexB` and `indexC`\r\n   * @param origin index of origin\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns return true if indexA, indexB both valid\r\n   */\r\n  public abstract accumulateCrossProductIndexIndexIndex(origin: number, indexA: number, indexB: number, result: Vector3d): void;\r\n\r\n  /**\r\n   * read-only property for number of XYZ in the collection.\r\n   */\r\n  public abstract get length(): number;\r\n  /**\r\n   * Return distance squared between indicated points.\r\n   * @param index0 first point index\r\n   * @param index1 second point index\r\n   */\r\n  public abstract distanceSquaredIndexIndex(index0: number, index1: number): number | undefined;\r\n  /**\r\n   * Return distance between indicated points.\r\n   * @param index0 first point index\r\n   * @param index1 second point index\r\n   */\r\n  public abstract distanceIndexIndex(index0: number, index1: number): number | undefined;\r\n\r\n  /** Adjust index into range by modulo with the length. */\r\n  public cyclicIndex(i: number): number {\r\n    return (i % this.length);\r\n  }\r\n  /** Return the range of the points. */\r\n  public getRange(): Range3d {\r\n    const range = Range3d.createNull();\r\n    const n = this.length;\r\n    const point = Point3d.create();\r\n    for (let i = 0; i < n; i++) {\r\n      this.getPoint3dAtUncheckedPointIndex(i, point);\r\n      range.extendPoint(point);\r\n    }\r\n    return range;\r\n  }\r\n  /** Accumulate scale times the x,y,z values at index.\r\n   * * No action if index is out of bounds.\r\n   */\r\n  public abstract accumulateScaledXYZ(index: number, scale: number, sum: Point3d): void;\r\n\r\n  /** access x of indexed point */\r\n  public abstract getXAtUncheckedPointIndex(pointIndex: number): number;\r\n\r\n  /** access y of indexed point */\r\n  public abstract getYAtUncheckedPointIndex(pointIndex: number): number;\r\n\r\n  /** access z of indexed point */\r\n  public abstract getZAtUncheckedPointIndex(pointIndex: number): number;\r\n\r\n  /** Return iterator over the points in this collection. Usage:\r\n   * ```ts\r\n   *  for (const point: Point3d of collection.points) { ... }\r\n   * ```\r\n   */\r\n  public get points(): Iterable<Point3d> {\r\n    return new PointsIterator(this);\r\n  }\r\n}\r\n/**\r\n * abstract base class extends IndexedXYZCollection, adding methods to push, peek, and pop, and rewrite.\r\n * @public\r\n */\r\nexport abstract class IndexedReadWriteXYZCollection extends IndexedXYZCollection {\r\n  /** push a (clone of) point onto the collection\r\n   * * point itself is not pushed -- xyz data is extracted into the native form of the collection.\r\n   */\r\n  public abstract push(data: XYAndZ): void;\r\n  /**\r\n   * push a new point (given by coordinates) onto the collection\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   */\r\n  public abstract pushXYZ(x?: number, y?: number, z?: number): void;\r\n  /** extract the final point */\r\n  public abstract back(result?: Point3d): Point3d | undefined;\r\n  /** extract the first point */\r\n  public abstract front(result?: Point3d): Point3d | undefined;\r\n  /** remove the final point. */\r\n  public abstract pop(): void;\r\n  /**  clear all entries */\r\n  public abstract clear(): void;\r\n  /** reverse the points in place. */\r\n  public abstract reverseInPlace(): void;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Geometry, AxisOrder, AxisIndex, BeJSONFunctions, StandardViewIndex } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Point2d } from \"./Point2dVector2d\";\r\nimport { XYAndZ, XAndY, Matrix3dProps, WritableXYAndZ } from \"./XYZProps\";\r\nimport { XYZ, Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\n/** @module CartesianGeometry */\r\n/* tslint:disable:prefer-get */\r\n/**\r\n * PackedMatrix3dOps contains static methods for matrix operations where the matrix is a Float64Array.\r\n * * The Float64Array contains the matrix entries in row-major order\r\n */\r\nclass PackedMatrix3dOps {\r\n  /**\r\n   * Load 9 doubles into the packed format.\r\n   * @param dest destination, allocated by caller\r\n   * @param a00 row 0, column 0 entry\r\n   * @param a01 row 0, column 1 entry\r\n   * @param a02 row 0, column 2 entry\r\n   * @param a10 row 1, column 0 entry\r\n   * @param a11 row 1, column 1 entry\r\n   * @param a12 row 1, column 2 entry\r\n   * @param a20 row 2, column 0 entry\r\n   * @param a21 row 2, column 1 entry\r\n   * @param a22 row 2, column 2 entry\r\n   */\r\n  public static loadMatrix(dest: Float64Array,\r\n    a00: number, a01: number, a02: number,\r\n    a10: number, a11: number, a12: number,\r\n    a20: number, a21: number, a22: number) {\r\n    dest[0] = a00; dest[1] = a01; dest[2] = a02;\r\n    dest[3] = a10; dest[4] = a11; dest[5] = a12;\r\n    dest[6] = a20; dest[7] = a21; dest[8] = a22;\r\n  }\r\n\r\n  /**\r\n   * * multiply 3x3 matrix `a*b`, store in c.\r\n   * * All params assumed length 9, allocated by caller.\r\n   * * c may alias either input.\r\n   */\r\n  public static multiplyMatrixMatrix(a: Float64Array, b: Float64Array, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(9);\r\n    PackedMatrix3dOps.loadMatrix(result,\r\n      (a[0] * b[0] + a[1] * b[3] + a[2] * b[6]),\r\n      (a[0] * b[1] + a[1] * b[4] + a[2] * b[7]),\r\n      (a[0] * b[2] + a[1] * b[5] + a[2] * b[8]),\r\n      (a[3] * b[0] + a[4] * b[3] + a[5] * b[6]),\r\n      (a[3] * b[1] + a[4] * b[4] + a[5] * b[7]),\r\n      (a[3] * b[2] + a[4] * b[5] + a[5] * b[8]),\r\n      (a[6] * b[0] + a[7] * b[3] + a[8] * b[6]),\r\n      (a[6] * b[1] + a[7] * b[4] + a[8] * b[7]),\r\n      (a[6] * b[2] + a[7] * b[5] + a[8] * b[8]));\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * * multiply 3x3 matrix `a*bTranspose`, store in c.\r\n   * * All params assumed length 9, allocated by caller.\r\n   * * c may alias either input.\r\n   */\r\n  public static multiplyMatrixMatrixTranspose(a: Float64Array, b: Float64Array, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(9);\r\n    PackedMatrix3dOps.loadMatrix(result,\r\n      (a[0] * b[0] + a[1] * b[1] + a[2] * b[2]),\r\n      (a[0] * b[3] + a[1] * b[4] + a[2] * b[5]),\r\n      (a[0] * b[6] + a[1] * b[7] + a[2] * b[8]),\r\n      (a[3] * b[0] + a[4] * b[1] + a[5] * b[2]),\r\n      (a[3] * b[3] + a[4] * b[4] + a[5] * b[5]),\r\n      (a[3] * b[6] + a[4] * b[7] + a[5] * b[8]),\r\n      (a[6] * b[0] + a[7] * b[1] + a[8] * b[2]),\r\n      (a[6] * b[3] + a[7] * b[4] + a[8] * b[5]),\r\n      (a[6] * b[6] + a[7] * b[7] + a[8] * b[8]));\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * * multiply 3x3 matrix `a*bTranspose`, store in c.\r\n   * * All params assumed length 9, allocated by caller.\r\n   * * c may alias either input.\r\n   */\r\n  public static multiplyMatrixTransposeMatrix(a: Float64Array, b: Float64Array, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(9);\r\n    PackedMatrix3dOps.loadMatrix(result,\r\n      (a[0] * b[0] + a[3] * b[3] + a[6] * b[6]),\r\n      (a[0] * b[1] + a[3] * b[4] + a[6] * b[7]),\r\n      (a[0] * b[2] + a[3] * b[5] + a[6] * b[8]),\r\n      (a[1] * b[0] + a[4] * b[3] + a[7] * b[6]),\r\n      (a[1] * b[1] + a[4] * b[4] + a[7] * b[7]),\r\n      (a[1] * b[2] + a[4] * b[5] + a[7] * b[8]),\r\n      (a[2] * b[0] + a[5] * b[3] + a[8] * b[6]),\r\n      (a[2] * b[1] + a[5] * b[4] + a[8] * b[7]),\r\n      (a[2] * b[2] + a[5] * b[5] + a[8] * b[8]));\r\n    return result;\r\n  }\r\n  /** transpose 3x3 coefficients in place */\r\n  public static transposeInPlace(a: Float64Array) {\r\n    let q = a[1]; a[1] = a[3]; a[3] = q;\r\n    q = a[2]; a[2] = a[6]; a[6] = q;\r\n    q = a[5]; a[5] = a[7]; a[7] = q;\r\n  }\r\n  /** transpose 3x3 coefficients in place */\r\n  public static copyTransposed(a: Float64Array, dest?: Float64Array): Float64Array {\r\n    if (dest === a) {\r\n      PackedMatrix3dOps.transposeInPlace(a);\r\n    } else {\r\n      if (!dest)\r\n        dest = new Float64Array(9);\r\n      dest[0] = a[0]; dest[1] = a[3]; dest[2] = a[6];\r\n      dest[3] = a[1]; dest[4] = a[4]; dest[5] = a[7];\r\n      dest[6] = a[2]; dest[7] = a[5]; dest[8] = a[8];\r\n    }\r\n    return dest;\r\n  }\r\n\r\n}\r\n/** A Matrix3d is tagged indicating one of the following states:\r\n * * unknown: it is not know if the matrix is invertible.\r\n * * inverseStored: the matrix has its inverse stored\r\n * * singular: the matrix is known to be singular.\r\n * @public\r\n */\r\nexport enum InverseMatrixState {\r\n  /**\r\n   * * The invertibility of the  `coffs` array has not been determined.\r\n   * * Any `inverseCoffs` contents are random.\r\n   */\r\n  unknown,\r\n  /** An inverse was computed and stored as the `inverseCoffs` */\r\n  inverseStored,\r\n  /**\r\n   * * The `coffs` array is known to be singular.\r\n   * * Any `inverseCoffs` contents are random.\r\n   */\r\n  singular,\r\n}\r\n/** A Matrix3d is a 3x3 matrix.\r\n * * A very common use is to hold a rigid body rotation (which has no scaling or skew), but the 3x3 contents can\r\n * also hold scaling and skewing.\r\n * * The 9 entries are stored in row-major order in the coffs array.\r\n * * If the matrix inverse is known it is stored in the inverseCoffs array.\r\n * * The inverse status (unknown, inverseStored, singular) status is indicated by the inverseState property.\r\n * * constructions method that are able to determine the inverse store it immediately and\r\n *     note that in the inverseState.\r\n * * constructions (e.g. createRowValues) for which the inverse is not immediately known mark the\r\n *     inverseState as unknown.\r\n * * Later queries for the inverse trigger full computation if needed at that time.\r\n * * Most matrix queries are present with both \"column\" and \"row\" variants.\r\n * * Usage elsewhere in the library is typically \"column\" based.  For example, in a Transform\r\n *     that carries a coordinate frame the matrix columns are the unit vectors for the axes.\r\n * @public\r\n */\r\nexport class Matrix3d implements BeJSONFunctions {\r\n  /** Control flag for whether this class uses cached inverse of matrices. */\r\n  public static useCachedInverse = true;  // cached inverse can be suppressed for testing.\r\n  /** total number of times a cached inverse was used to avoid recompute */\r\n  public static numUseCache = 0;\r\n  /** total number of times a cached inverse was computed. */\r\n  public static numComputeCache = 0;\r\n  /** Matrix contents as a flat array of numbers in row-major order.\r\n   * * DO NOT directly modify this array.  It will destroy safety of the cached inverse state.\r\n   */\r\n  public coffs: Float64Array;\r\n  /** matrix inverse contents.\r\n   * * DO NOT directly modify this array.  It will destroy integrity of the cached inverse state.\r\n   *\r\n   */\r\n  public inverseCoffs: Float64Array | undefined;\r\n  /** indicates if inverse is unknown, available, or known singular */\r\n  public inverseState: InverseMatrixState;\r\n  private static _identity: Matrix3d;\r\n\r\n  /** The identity Matrix3d. Value is frozen and cannot be modified. */\r\n  public static get identity(): Matrix3d {\r\n    if (undefined === this._identity) {\r\n      this._identity = Matrix3d.createIdentity();\r\n      this._identity.freeze();\r\n    }\r\n\r\n    return this._identity;\r\n  }\r\n\r\n  /** Freeze this Matrix3d. */\r\n  public freeze() {\r\n    this.computeCachedInverse(true);\r\n    /* hm.. can't freeze the Float64Arrays . . .\r\n    Object.freeze(this.coffs);\r\n    if (this.inverseCoffs)\r\n      Object.freeze(this.inverseCoffs);\r\n    */\r\n    Object.freeze(this);\r\n  }\r\n  /**\r\n   *\r\n   * @param coffs optional coefficient array.  This is captured.\r\n   */\r\n  public constructor(coffs?: Float64Array) {\r\n    this.coffs = coffs ? coffs : new Float64Array(9);\r\n    this.inverseCoffs = undefined;\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n  /** Return a json object containing the 9 numeric entries as a single array in row major order,\r\n   * `[ [1, 2, 3],[ 4, 5, 6], [7, 8, 9] ]`\r\n   */\r\n  public toJSON(): Matrix3dProps {\r\n    return [[this.coffs[0], this.coffs[1], this.coffs[2]],\r\n    [this.coffs[3], this.coffs[4], this.coffs[5]],\r\n    [this.coffs[6], this.coffs[7], this.coffs[8]]];\r\n  }\r\n  /** copy data from various input forms to this matrix:\r\n   * * Another `Matrix3d`\r\n   * * An array of 3 arrays, each of which has the 3 numbers for a row of the matrix.\r\n   * * An array of 9 numbers in row major order.\r\n   */\r\n  public setFromJSON(json?: Matrix3dProps): void {\r\n    this.inverseCoffs = undefined;\r\n    if (!json) {\r\n      this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n      return;\r\n    }\r\n    if (!Array.isArray(json)) {\r\n      if (json instanceof Matrix3d)\r\n        this.setFrom(json);\r\n      return;\r\n    }\r\n\r\n    if (Geometry.isArrayOfNumberArray(json, 3, 3)) {\r\n      const data = json as number[][];\r\n      this.setRowValues(\r\n        data[0][0], data[0][1], data[0][2],\r\n        data[1][0], data[1][1], data[1][2],\r\n        data[2][0], data[2][1], data[2][2]);\r\n      return;\r\n    }\r\n\r\n    if (json.length === 9) {\r\n      const data = json as number[];\r\n      this.setRowValues(\r\n        data[0], data[1], data[2],\r\n        data[3], data[4], data[5],\r\n        data[6], data[7], data[8]);\r\n    } else if (json.length === 4) {\r\n      const data = json as number[];\r\n      this.setRowValues(\r\n        data[0], data[1], 0,\r\n        data[2], data[3], 0,\r\n        0, 0, 1);\r\n    }\r\n  }\r\n  /** Return a new Matrix3d constructed from contents of the json value. Se `setFromJSON` for layout rules */\r\n  public static fromJSON(json?: Matrix3dProps): Matrix3d { const result = Matrix3d.createIdentity(); result.setFromJSON(json); return result; }\r\n  /** Test if this Matrix3d and other are within tolerance in all numeric entries.\r\n   * @param tol optional tolerance for comparisons by Geometry.isDistanceWithinTol\r\n   */\r\n  public isAlmostEqual(other: Matrix3d, tol?: number): boolean {\r\n    if (tol)\r\n      return Geometry.isDistanceWithinTol(this.maxDiff(other), tol);\r\n    return Geometry.isSmallMetricDistance(this.maxDiff(other));\r\n  }\r\n  /** Test for exact (bitwise) equality with other. */\r\n  public isExactEqual(other: Matrix3d): boolean { return this.maxDiff(other) === 0.0; }\r\n  /** test if all entries in the z row and column are exact 001, i.e. the matrix only acts in 2d */\r\n  public get isXY(): boolean {\r\n    return this.coffs[2] === 0.0\r\n      && this.coffs[5] === 0.0\r\n      && this.coffs[6] === 0.0\r\n      && this.coffs[7] === 0.0\r\n      && this.coffs[8] === 1.0;\r\n  }\r\n  // !! does not clear supplied result !!\r\n  private static _create(result?: Matrix3d): Matrix3d { return result ? result : new Matrix3d(); }\r\n\r\n  /** Returns a Matrix3d populated by numeric values given in row-major order.\r\n   *  set all entries in the matrix from call parameters appearing in row - major order.\r\n   * @param axx Row x, column x(0, 0) entry\r\n   * @param axy Row x, column y(0, 1) entry\r\n   * @param axz Row x, column z(0, 2) entry\r\n   * @param ayx Row y, column x(1, 0) entry\r\n   * @param ayy Row y, column y(1, 1) entry\r\n   * @param ayz Row y, column z(1, 2) entry\r\n   * @param azx Row z, column x(2, 0) entry\r\n   * @param azy Row z, column y(2, 2) entry\r\n   * @param azz row z, column z(2, 3) entry\r\n   */\r\n  public static createRowValues(\r\n    axx: number, axy: number, axz: number,\r\n    ayx: number, ayy: number, ayz: number,\r\n    azx: number, azy: number, azz: number,\r\n    result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    result.inverseState = InverseMatrixState.unknown;\r\n    result.coffs[0] = axx; result.coffs[1] = axy; result.coffs[2] = axz;\r\n    result.coffs[3] = ayx; result.coffs[4] = ayy; result.coffs[5] = ayz;\r\n    result.coffs[6] = azx; result.coffs[7] = azy; result.coffs[8] = azz;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a Matrix3d with caller-supplied coefficients and optional inverse coefficients.\r\n   * * The inputs are captured into the new Matrix3d.\r\n   * * The caller is responsible for validity of the inverse coefficients.\r\n   * @param coffs (required) array of 9 coefficients.\r\n   * @param inverseCoffs (optional) array of 9 coefficients.\r\n   * @returns a Matrix3d populated by a coffs array.\r\n   */\r\n  public static createCapture(coffs: Float64Array, inverseCoffs?: Float64Array): Matrix3d {\r\n    const result = new Matrix3d(coffs);\r\n    if (inverseCoffs) {\r\n      result.inverseCoffs = inverseCoffs;\r\n      result.inverseState = InverseMatrixState.inverseStored;\r\n    } else {\r\n      result.inverseState = InverseMatrixState.unknown;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * create a matrix by distributing vectors to columns in one of 6 orders.\r\n   * @param axisOrder identifies where the columns are placed.\r\n   * @param columnA vector to place in the first column named by the axis order.\r\n   * @param columnB vector to place in the second column named by the axis order.\r\n   * @param columnC vector to place in the third column named by the axis order.\r\n   * @param result\r\n   */\r\n  public static createColumnsInAxisOrder(axisOrder: AxisOrder, columnA: Vector3d, columnB: Vector3d, columnC: Vector3d | undefined, result?: Matrix3d) {\r\n    if (!result) result = new Matrix3d();\r\n    if (axisOrder === AxisOrder.YZX) {\r\n      result.setColumns(columnC, columnA, columnB);\r\n    } else if (axisOrder === AxisOrder.ZXY) {\r\n      result.setColumns(columnB, columnC, columnA);\r\n    } else if (axisOrder === AxisOrder.XZY) {\r\n      result.setColumns(columnA, columnC, columnB);\r\n    } else if (axisOrder === AxisOrder.YXZ) {\r\n      result.setColumns(columnB, columnA, columnC);\r\n    } else if (axisOrder === AxisOrder.ZYX) {\r\n      result.setColumns(columnC, columnB, columnA);\r\n    } else {  // fallthrough should only happen for AxisOrder.XYZ\r\n      result.setColumns(columnA, columnB, columnC);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   *  set all entries in the matrix from call parameters appearing in row-major order.\r\n   * @param axx Row x, column x (0,0) entry\r\n   * @param axy Row x, column y (0,1) entry\r\n   * @param axz Row x, column z (0,2) entry\r\n   * @param ayx Row y, column x (1,0) entry\r\n   * @param ayy Row y, column y (1,1) entry\r\n   * @param ayz Row y, column z (1,2) entry\r\n   * @param azx Row z, column x (2,0) entry\r\n   * @param azy Row z, column y (2,2) entry\r\n   * @param azz row z, column z (2,3) entry\r\n   */\r\n  public setRowValues(\r\n    axx: number, axy: number, axz: number,\r\n    ayx: number, ayy: number, ayz: number,\r\n    azx: number, azy: number, azz: number): void {\r\n    this.coffs[0] = axx; this.coffs[1] = axy; this.coffs[2] = axz;\r\n    this.coffs[3] = ayx; this.coffs[4] = ayy; this.coffs[5] = ayz;\r\n    this.coffs[6] = azx; this.coffs[7] = azy; this.coffs[8] = azz;\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n  /** Set the matrix to an identity. */\r\n  public setIdentity() { this.setRowValues(1, 0, 0, 0, 1, 0, 0, 0, 1); this.setupInverseTranspose(); }\r\n  /** Set the matrix to all zeros. */\r\n  public setZero() { this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0); this.inverseState = InverseMatrixState.singular; }\r\n  /** copy contents from another matrix. */\r\n  public setFrom(other: Matrix3d) {\r\n    for (let i = 0; i < 9; i++)\r\n      this.coffs[i] = other.coffs[i];\r\n    this.inverseState = InverseMatrixState.unknown; // we don't trust the other .. . .\r\n  }\r\n\r\n  /** return a clone of this matrix.\r\n   * * coefficients are copied.\r\n   * * inverse coefficients are NOT copied.\r\n   * * inverse status is set to unknown\r\n   */\r\n  public clone(result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    result.setFrom(this);\r\n    return result;\r\n  }\r\n  /** create a matrix with all zeros.\r\n   * * Note that for geometry transformations \"all zeros\" is not a useful default state.\r\n   * * Hence almost always use `createIdentity` for graphics transformations.\r\n   * * \"all zeros\" is appropriate for summing moment data.\r\n   */\r\n  public static createZero(): Matrix3d {\r\n    const retVal = new Matrix3d();\r\n    retVal.inverseState = InverseMatrixState.singular;\r\n    return retVal;\r\n  }\r\n  /** create an identity matrix\r\n   * * all diagonal entries (xx,yy,zz) are one\r\n   * * all others are zero.\r\n   * * This (rather than all zeros) is the useful state for most graphics transformations.\r\n   */\r\n  public static createIdentity(result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    result.setIdentity();\r\n    return result;\r\n  }\r\n\r\n  /** Create a matrix with uniform scale factors */\r\n  public static createUniformScale(scaleFactor: number): Matrix3d {\r\n    return Matrix3d.createScale(scaleFactor, scaleFactor, scaleFactor);\r\n  }\r\n  /**\r\n   *\r\n   * *  use createHeadsUpPerpendicular to generate a vectorV perpendicular to vectorA\r\n   * *  construct a frame using createRigidFromColumns (vectorA, vectorB, axisOrder)\r\n   */\r\n  public static createRigidHeadsUp(vectorA: Vector3d, axisOrder: AxisOrder = AxisOrder.ZXY, result?: Matrix3d): Matrix3d {\r\n    const vectorB = Matrix3d.createPerpendicularVectorFavorXYPlane(vectorA);\r\n    const matrix = Matrix3d.createRigidFromColumns(vectorA, vectorB, axisOrder, result);\r\n    if (matrix) {\r\n      matrix.setupInverseTranspose();\r\n      return matrix;\r\n    }\r\n    return Matrix3d.createIdentity(result);\r\n  }\r\n  /**\r\n   *\r\n   * * return a vector that is perpendicular to the input direction.\r\n   * * Among the infinite number of perpendiculars possible, this method\r\n   * favors having one in the xy plane.\r\n   * * Hence, when vectorA is NOT close to the Z axis, the returned vector is Z cross vectorA.\r\n   * * But vectorA is close to the Z axis, the returned vector is unitY cross vectorA.\r\n   */\r\n  public static createPerpendicularVectorFavorXYPlane(vector: Vector3d, result?: Vector3d): Vector3d {\r\n    const a = vector.magnitude();\r\n    const b = a / 64.0;   // A constant from the dawn of time in the CAD industry.\r\n    if (Math.abs(vector.x) < b && Math.abs(vector.y) < b) {\r\n      return Vector3d.createCrossProduct(vector.x, vector.y, vector.z, 0, -1, 0, result);\r\n    }\r\n    return Vector3d.createCrossProduct(0, 0, 1, vector.x, vector.y, vector.z, result);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * * return a vector that is perpendicular to the input direction.\r\n   * * Among the infinite number of perpendiculars possible, this method\r\n   * favors having one near the Z.\r\n   * That is achieved by crossing \"this\" vector with the result of createHeadsUpPerpendicularFavorXYPlane.\r\n   */\r\n  public static createPerpendicularVectorFavorPlaneContainingZ(vector: Vector3d, result?: Vector3d): Vector3d {\r\n    result = Matrix3d.createPerpendicularVectorFavorXYPlane(vector, result);\r\n    return vector.crossProduct(result, result);\r\n  }\r\n\r\n  /** Create a matrix with distinct x,y,z diagonal (scale) entries */\r\n  public static createScale(scaleFactorX: number, scaleFactorY: number, scaleFactorZ: number, result?: Matrix3d): Matrix3d {\r\n    if (result)\r\n      result.setZero();\r\n    else\r\n      result = new Matrix3d();\r\n\r\n    result.coffs[0] = scaleFactorX;\r\n    result.coffs[4] = scaleFactorY;\r\n    result.coffs[8] = scaleFactorZ;\r\n    if (scaleFactorX === 0 || scaleFactorY === 0 || scaleFactorZ === 0) {\r\n      result.inverseState = InverseMatrixState.singular;\r\n    } else {\r\n      result.inverseState = InverseMatrixState.inverseStored;\r\n      result.inverseCoffs = Float64Array.from([1 / scaleFactorX, 0, 0,\r\n        0, 1 / scaleFactorY, 0,\r\n        0, 0, 1 / scaleFactorZ]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** return a rotation of specified angle around an axis */\r\n  public static createRotationAroundVector(axis: Vector3d, angle: Angle, result?: Matrix3d): Matrix3d | undefined {\r\n    const c = angle.cos();\r\n    const s = angle.sin();\r\n    const v = 1.0 - c;\r\n    const unit = axis.normalize();\r\n    if (unit) {\r\n      const retVal = Matrix3d.createRowValues(\r\n        unit.x * unit.x * v + c,\r\n        unit.x * unit.y * v - s * unit.z,\r\n        unit.x * unit.z * v + s * unit.y,\r\n        unit.y * unit.x * v + s * unit.z,\r\n        unit.y * unit.y * v + c,\r\n        unit.y * unit.z * v - s * unit.x,\r\n        unit.z * unit.x * v - s * unit.y,\r\n        unit.z * unit.y * v + s * unit.x,\r\n        unit.z * unit.z * v + c, result);\r\n      retVal.setupInverseTranspose();\r\n      return retVal;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Returns a rotation of specified angle around an axis\r\n   * @param axisIndex index of axis (AxisIndex.X, AxisIndex.Y, AxisIndex.Z) kept fixed by the rotation.\r\n   * @param angle angle of rotation\r\n   * @param result optional result matrix.\r\n   */\r\n  public static createRotationAroundAxisIndex(axisIndex: AxisIndex, angle: Angle, result?: Matrix3d): Matrix3d {\r\n    const c = angle.cos();\r\n    const s = angle.sin();\r\n    let myResult;\r\n    if (axisIndex === AxisIndex.X) {\r\n      myResult = Matrix3d.createRowValues(\r\n        1, 0, 0,\r\n        0, c, -s,\r\n        0, s, c,\r\n        result);\r\n    } else if (axisIndex === AxisIndex.Y) {\r\n      myResult = Matrix3d.createRowValues(\r\n        c, 0, s,\r\n        0, 1, 0,\r\n        -s, 0, c,\r\n        result);\r\n    } else {\r\n      myResult = Matrix3d.createRowValues(\r\n        c, -s, 0,\r\n        s, c, 0,\r\n        0, 0, 1,\r\n        result);\r\n    }\r\n    myResult.setupInverseTranspose();\r\n    return myResult;\r\n  }\r\n\r\n  /** Create a matrix with\r\n   * * ColumnX points in the rightVector direction\r\n   * * ColumnY points in in the upVectorDirection\r\n   * * ColumnZ is a unit cross product.\r\n   * Optionally rotate the standard cube by 45 to bring its left or right vertical edge to center\r\n   * * leftNoneRight = [-1,0,1] respectively for left edge, no rotation, or right edge\r\n   * * bottomNoneTop = [-1,0,1] respectively for isometric rotation to view the bottom, no isometric rotation, and isometric rotation to view the top\r\n   * This is expected to be used with various principal unit vectors that are perpendicular to each other.\r\n   *  * STANDARD TOP VIEW: (Vector3d.UnitX (), Vector3d.UnitY (), 0, 0)\r\n   *  * STANDARD FRONT VIEW: (Vector3d.UnitX (), Vector3d.UnitZ (), 0, 0)\r\n   *  * STANDARD BACK VIEW: (Vector3d.UnitX (-1), Vector3d.UnitZ (), 0, 0)\r\n   *  * STANDARD RIGHT VIEW: (Vector3d.UnitY (1), Vector3d.UnitZ (), 0, 0)\r\n   *  * STANDARD LEFT VIEW: (Vector3d.UnitY (-1), Vector3d.UnitZ (), 0, 0)\r\n   *  * STANDARD BOTTOM VIEW: (Vector3d.UnitX (1), Vector3d.UnitY (-1), 0, 0)\r\n   * @param leftNoneRight Normally one of {-1,0,1}, where (-1) indicates the left vertical is rotated to center and (1) for right.  Other numbers are used as multiplier for this 45 degree rotation\r\n   * @returns undefined if columnX, columnY are coplanar.\r\n   */\r\n  public static createViewedAxes(rightVector: Vector3d, upVector: Vector3d, leftNoneRight: number = 0, topNoneBottom: number = 0): Matrix3d | undefined {\r\n    const columnZ = rightVector.crossProduct(upVector);\r\n    if (columnZ.normalizeInPlace()) {\r\n      const geometry = Matrix3d.createColumns(rightVector, upVector, columnZ);\r\n      if (leftNoneRight !== 0.0) {\r\n        let c = Math.sqrt(0.5);\r\n        let s = leftNoneRight < 0.0 ? -c : c;\r\n        if (Math.abs(leftNoneRight) !== 1.0) {\r\n          const radians = Angle.degreesToRadians(45.0 * leftNoneRight);\r\n          c = Math.cos(radians);\r\n          s = Math.sin(radians);\r\n        }\r\n        geometry.applyGivensColumnOp(2, 0, c, s);   // rotate around Y\r\n      }\r\n      if (topNoneBottom !== 0.0) {\r\n        const theta = topNoneBottom * Math.atan(Math.sqrt(0.5));\r\n        const c = Math.cos(theta);\r\n        const s = Math.sin(theta);\r\n        geometry.applyGivensColumnOp(1, 2, c, -s); // rotate around X\r\n      }\r\n      return geometry;\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Create a rotation matrix for one of the 8 standard views.\r\n   * * With `invert === false` the return is such that `matrix.multiply(worldVector)` returns the vector as seen in the xy (projected) coordinates of the view.\r\n   * * With invert === true the matrix is transposed so that `matrix.multiply(viewVector` maps the \"in view\" vector to a world vector.\r\n   *\r\n   * @param index standard view index `StandardViewIndex.Top, Bottom, LEft, Right, Front, Back, Iso, LeftIso`\r\n   * @param invert if false (default), the returned Matrix3d \"projects\" world vectors into XY view vectors.  If true, it is inverted to map view vectors to world.\r\n   * @param result optional result.\r\n   */\r\n  public static createStandardWorldToView(index: StandardViewIndex, invert: boolean = false, result?: Matrix3d): Matrix3d {\r\n    switch (index) {\r\n\r\n      case StandardViewIndex.Bottom:\r\n        result = Matrix3d.createRowValues(\r\n          1, 0, 0,\r\n          0, -1, 0,\r\n          0, 0, -1);\r\n        break;\r\n      case StandardViewIndex.Left:\r\n        result = Matrix3d.createRowValues(\r\n          0, -1, 0,\r\n          0, 0, 1,\r\n          -1, 0, 0);\r\n        break;\r\n      case StandardViewIndex.Right:\r\n        result = Matrix3d.createRowValues(\r\n          0, 1, 0,\r\n          0, 0, 1,\r\n          1, 0, 0);\r\n        break;\r\n      case StandardViewIndex.Front: // 0-based 4\r\n        result = Matrix3d.createRowValues(\r\n          1, 0, 0,\r\n          0, 0, 1,\r\n          0, -1, 0);\r\n        break;\r\n      case StandardViewIndex.Back: // 0-based 5\r\n        result = Matrix3d.createRowValues(\r\n          -1, 0, 0,\r\n          0, 0, 1,\r\n          0, 1, 0);\r\n        break;\r\n      case StandardViewIndex.Iso:\r\n        result = Matrix3d.createRowValues(\r\n          0.707106781186548, -0.70710678118654757, 0.00000000000000000,\r\n          0.408248290463863, 0.40824829046386302, 0.81649658092772603,\r\n          -0.577350269189626, -0.57735026918962573, 0.57735026918962573);\r\n        break;\r\n      case StandardViewIndex.RightIso:\r\n        result = Matrix3d.createRowValues(\r\n          0.707106781186548, 0.70710678118654757, 0.00000000000000000,\r\n          -0.408248290463863, 0.40824829046386302, 0.81649658092772603,\r\n          0.577350269189626, -0.57735026918962573, 0.57735026918962573);\r\n        break;\r\n      case StandardViewIndex.Top:\r\n      default:\r\n        result = Matrix3d.createIdentity(result);\r\n    }\r\n    if (invert)\r\n      result.transposeInPlace();\r\n    return result;\r\n  }\r\n  /*\r\n  // this implementation has problems distinguishing failure (normalize) from small angle.\r\n  public getAxisAndAngleOfRotation(): { axis: Vector3d, angle: Angle, error: boolean } {\r\n\r\n    const result = { axis: Vector3d.unitZ(), angle: Angle.createRadians(0), error: true };\r\n    if (this.isIdentity) {\r\n      result.error = false;\r\n      return result;\r\n    }\r\n    if (!this.isRigid())\r\n      return result;\r\n    const QMinusI = this.clone();\r\n    QMinusI.coffs[0] -= 1.0;\r\n    QMinusI.coffs[4] -= 1.0;\r\n    QMinusI.coffs[8] -= 1.0;\r\n    // Each column of (Q - I) is the motion of the corresponding axis vector\r\n    // during the rotation.\r\n    // Only one of the three axes can really be close to the rotation axis.\r\n    const delta0 = QMinusI.columnX();\r\n    const delta1 = QMinusI.columnY();\r\n    const delta2 = QMinusI.columnZ();\r\n    const cross01 = delta0.crossProduct(delta1);\r\n    const cross12 = delta1.crossProduct(delta2);\r\n    const cross20 = delta2.crossProduct(delta0);\r\n\r\n    const aa01 = cross01.magnitudeSquared();\r\n    const aa12 = cross12.magnitudeSquared();\r\n    const aa20 = cross20.magnitudeSquared();\r\n\r\n    const cross = cross01.clone(); // This will end up as the biggest cross product\r\n    const v0 = delta0.clone();  // This will end up as one of the two largest delta vectors\r\n    let aaMax = aa01;\r\n    if (aa12 > aaMax) {\r\n      cross.setFrom(cross12);\r\n      aaMax = aa12;\r\n      v0.setFrom(delta1);\r\n    }\r\n    if (aa20 > aaMax) {\r\n      cross.setFrom(cross20);\r\n      aaMax = aa20;\r\n      v0.setFrom(delta2);\r\n    }\r\n\r\n    if (aaMax === 0.0) {\r\n      // The vectors did not move.  Just accept the zero rotation, with error flag set.\r\n      return result;\r\n    }\r\n\r\n    v0.normalizeInPlace();\r\n    // V0 is a unit vector perpendicular to the rotation axis.\r\n    // Rotate it.   Its image V1 is also a unit vector, and the angle from V0 to V1 is the quat angle.\r\n    // CrossProduct is axis vector times sine of angle.\r\n    // Dot Product is cosine of angle.\r\n    // V2 is zero in 180 degree case, so we use the Cross from the search as the axis\r\n    //   as direction, being careful to keep sine positive.\r\n    const v1 = this.multiplyVector(v0);\r\n    const v2 = v0.crossProduct(v1);\r\n    const sine = v2.magnitude();\r\n    if (v2.dotProduct(cross) < 0.0)\r\n      cross.scaleInPlace(-1.0);\r\n    const cosine = v0.dotProduct(v1);\r\n    result.angle.setRadians(Math.atan2(sine, cosine));\r\n    result.axis.setFrom(cross);\r\n    result.error = !result.axis.tryNormalizeInPlace();\r\n    return result\r\n  }\r\n*/\r\n  /**\r\n   * Compute the (unit vector) axis and angle of rotation.\r\n   * @returns Returns with result.ok === true when the conversion succeeded.\r\n   */\r\n  public getAxisAndAngleOfRotation(): { axis: Vector3d, angle: Angle, ok: boolean } {\r\n    const trace = this.coffs[0] + this.coffs[4] + this.coffs[8];\r\n    // trace = (xx + yy * zz) * (1-c) + 3 * c = 1 + 2c ==> c = (trace-1) / 2\r\n    const skewXY = this.coffs[3] - this.coffs[1];  // == 2sz\r\n    const skewYZ = this.coffs[7] - this.coffs[5]; // == 2sx\r\n    const skewZX = this.coffs[2] - this.coffs[6]; // == 2sy\r\n    const c = (trace - 1.0) / 2.0;\r\n    const s = Geometry.hypotenuseXYZ(skewXY, skewYZ, skewZX) / 2.0;\r\n    const e = c * c + s * s - 1.0;\r\n    if (Math.abs(e) > Geometry.smallAngleRadians) {\r\n      // the sine and cosine are not a unit circle point.   bad matrix . ..\r\n      return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: false };\r\n    }\r\n    if (Math.abs(s) < Geometry.smallAngleRadians) {\r\n      // There is no significant skew.\r\n      // The matrix is symmetric\r\n      // So it has simple eigenvalues -- either (1,1,1) or (1,-1,-1).\r\n      if (c > 0)  // no rotation\r\n        return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: true };\r\n      // 180 degree flip around some axis ?\r\n      // Look for the simple case of a principal rotation ...\r\n      // look for a pair of (-1) entries on the diagonal ...\r\n      const axx = this.coffs[0];\r\n      const ayy = this.coffs[4];\r\n      const azz = this.coffs[8];\r\n      const theta180 = Angle.createDegrees(180);\r\n      // Look for principal axis flips as a special case . ..\r\n      if (Geometry.isAlmostEqualNumber(-1.0, ayy) && Geometry.isAlmostEqualNumber(-1, azz)) {\r\n        // rotate around\r\n        return { axis: Vector3d.create(1, 0, 0), angle: theta180, ok: true };\r\n      } else if (Geometry.isAlmostEqualNumber(-1.0, axx) && Geometry.isAlmostEqualNumber(-1, azz)) {\r\n        return { axis: Vector3d.create(0, 1, 0), angle: theta180, ok: true };\r\n      } else if (Geometry.isAlmostEqualNumber(-1.0, axx) && Geometry.isAlmostEqualNumber(-1, ayy)) {\r\n        return { axis: Vector3d.create(0, 0, 1), angle: theta180, ok: true };\r\n      }\r\n\r\n      // 180 degree flip around some other axis ...\r\n      // eigenvalues will have 1.0 once, -1.0 twice.\r\n      // These cases look for each place (x,y,z) that the 1.0 might appear.\r\n      // But fastSymmetricEigenvalues reliably always seems to put the 1.0 as the x eigenvalue.\r\n      // so only the getColumn(0) return seems reachable in unit tests.\r\n      const eigenvectors = Matrix3d.createIdentity();\r\n      const eigenvalues = Vector3d.create(0, 0, 0);\r\n      if (this.fastSymmetricEigenvalues(eigenvectors, eigenvalues)) {\r\n        for (let axisIndex = 0; axisIndex < 2; axisIndex++) {\r\n          const lambda = eigenvalues.at(axisIndex);\r\n          if (Geometry.isAlmostEqualNumber(1, lambda))\r\n            return { axis: eigenvectors.getColumn(axisIndex), angle: theta180, ok: true };\r\n        }\r\n        // Don't know if this can be reached ....\r\n        return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: false };\r\n      }\r\n      return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: false };\r\n    }\r\n    const a = 1.0 / (2.0 * s);\r\n    const result = { axis: Vector3d.create(skewYZ * a, skewZX * a, skewXY * a), angle: Angle.createAtan2(s, c), ok: true };\r\n    return result;\r\n  }\r\n  /**\r\n   * Returns a matrix that rotates from vectorA to vectorB.\r\n   */\r\n  public static createRotationVectorToVector(vectorA: Vector3d, vectorB: Vector3d, result?: Matrix3d): Matrix3d | undefined {\r\n    return this.createPartialRotationVectorToVector(vectorA, 1.0, vectorB, result);\r\n  }\r\n  /**\r\n   * Return a matrix that rotates a fraction of the angular sweep from vectorA to vectorB.\r\n   * @param vectorA initial vector position\r\n   * @param fraction fractional rotation.  1.0 is \"all the way\"\r\n   * @param vectorB final vector position\r\n   * @param result optional result matrix.\r\n   */\r\n  public static createPartialRotationVectorToVector(vectorA: Vector3d, fraction: number, vectorB: Vector3d, result?: Matrix3d): Matrix3d | undefined {\r\n\r\n    let upVector = vectorA.unitCrossProduct(vectorB);\r\n    if (upVector) {  // the usual case --\r\n      return Matrix3d.createRotationAroundVector(upVector,\r\n        Angle.createRadians(fraction * vectorA.planarAngleTo(vectorB, upVector).radians));\r\n    }\r\n    // fail if either vector is zero ...\r\n    if (Geometry.isSmallMetricDistance(vectorA.magnitude())\r\n      || Geometry.isSmallMetricDistance(vectorB.magnitude()))\r\n      return undefined;\r\n    // nonzero but aligned vectors ...\r\n    if (vectorA.dotProduct(vectorB) > 0.0)\r\n      return Matrix3d.createIdentity(result);\r\n    // nonzero opposing vectors ..\r\n    upVector = Matrix3d.createPerpendicularVectorFavorPlaneContainingZ(vectorA, upVector);\r\n    return Matrix3d.createRotationAroundVector(upVector, Angle.createRadians(fraction * Math.PI));\r\n  }\r\n\r\n  /** Create a 90 degree rotation around a principal axis */\r\n  public static create90DegreeRotationAroundAxis(axisIndex: number): Matrix3d {\r\n    axisIndex = Geometry.cyclic3dAxis(axisIndex);\r\n    if (axisIndex === 0) {\r\n      const retVal = Matrix3d.createRowValues(\r\n        1, 0, 0,\r\n        0, 0, -1,\r\n        0, 1, 0);\r\n      retVal.setupInverseTranspose();\r\n      return retVal;\r\n    } else if (axisIndex === 1) {\r\n      const retVal = Matrix3d.createRowValues(\r\n        0, 0, 1,\r\n        0, 1, 0,\r\n        -1, 0, 0);\r\n      retVal.setupInverseTranspose();\r\n      return retVal;\r\n    } else {\r\n      const retVal = Matrix3d.createRowValues(\r\n        0, -1, 0,\r\n        1, 0, 0,\r\n        0, 0, 1);\r\n      retVal.setupInverseTranspose();\r\n      return retVal;\r\n    }\r\n  }\r\n\r\n  /** Return (a copy of) the X column */\r\n  public columnX(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[0], this.coffs[3], this.coffs[6], result); }\r\n  /** Return (a copy of)the Y column */\r\n  public columnY(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[1], this.coffs[4], this.coffs[7], result); }\r\n  /** Return (a copy of)the Z column */\r\n  public columnZ(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[2], this.coffs[5], this.coffs[8], result); }\r\n\r\n  /** Return the X column magnitude squared */\r\n  public columnXMagnitudeSquared(): number { return Geometry.hypotenuseSquaredXYZ(this.coffs[0], this.coffs[3], this.coffs[6]); }\r\n  /** Return the Y column magnitude squared */\r\n  public columnYMagnitudeSquared(): number { return Geometry.hypotenuseSquaredXYZ(this.coffs[1], this.coffs[4], this.coffs[7]); }\r\n  /** Return the Z column magnitude squared */\r\n  public columnZMagnitudeSquared(): number { return Geometry.hypotenuseSquaredXYZ(this.coffs[2], this.coffs[5], this.coffs[8]); }\r\n\r\n  /** Return the X column magnitude */\r\n  public columnXMagnitude(): number { return Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[3], this.coffs[6]); }\r\n  /** Return the Y column magnitude */\r\n  public columnYMagnitude(): number { return Geometry.hypotenuseXYZ(this.coffs[1], this.coffs[4], this.coffs[7]); }\r\n  /** Return the Z column magnitude */\r\n  public columnZMagnitude(): number { return Geometry.hypotenuseXYZ(this.coffs[2], this.coffs[5], this.coffs[8]); }\r\n\r\n  /** Return magnitude of columnX cross columnY. */\r\n  public columnXYCrossProductMagnitude(): number {\r\n    return Geometry.crossProductMagnitude(\r\n      this.coffs[0], this.coffs[3], this.coffs[6],\r\n      this.coffs[1], this.coffs[4], this.coffs[7]);\r\n  }\r\n\r\n  /** Return the X row magnitude d */\r\n  public rowXMagnitude(): number { return Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[1], this.coffs[2]); }\r\n  /** Return the Y row magnitude  */\r\n  public rowYMagnitude(): number { return Geometry.hypotenuseXYZ(this.coffs[3], this.coffs[4], this.coffs[5]); }\r\n  /** Return the Z row magnitude  */\r\n  public rowZMagnitude(): number { return Geometry.hypotenuseXYZ(this.coffs[6], this.coffs[7], this.coffs[8]); }\r\n  /** Return the dot product of column X with column Y */\r\n  /** Return the dot product of column X with column Y */\r\n  public columnXDotColumnY(): number {\r\n    return this.coffs[0] * this.coffs[1]\r\n      + this.coffs[3] * this.coffs[4]\r\n      + this.coffs[6] * this.coffs[7];\r\n  }\r\n  /** Return (a copy of) the X row */\r\n  public rowX(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[0], this.coffs[1], this.coffs[2], result); }\r\n  /** Return (a copy of) the Y row */\r\n  public rowY(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[3], this.coffs[4], this.coffs[5], result); }\r\n  /** Return (a copy of) the Z row */\r\n  public rowZ(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[6], this.coffs[7], this.coffs[8], result); }\r\n\r\n  /** Return the dot product of the vector parameter with the X column. */\r\n  public dotColumnX(vector: XYZ): number { return vector.x * this.coffs[0] + vector.y * this.coffs[3] + vector.z * this.coffs[6]; }\r\n  /** Return the dot product of the vector parameter with the Y column. */\r\n  public dotColumnY(vector: XYZ): number { return vector.x * this.coffs[1] + vector.y * this.coffs[4] + vector.z * this.coffs[7]; }\r\n  /** Return the dot product of the vector parameter with the Z column. */\r\n  public dotColumnZ(vector: XYZ): number { return vector.x * this.coffs[2] + vector.y * this.coffs[5] + vector.z * this.coffs[8]; }\r\n\r\n  /** Return the dot product of the vector parameter with the X row. */\r\n  public dotRowX(vector: XYZ): number { return vector.x * this.coffs[0] + vector.y * this.coffs[1] + vector.z * this.coffs[2]; }\r\n  /** Return the dot product of the vector parameter with the Y row. */\r\n  public dotRowY(vector: XYZ): number { return vector.x * this.coffs[3] + vector.y * this.coffs[4] + vector.z * this.coffs[5]; }\r\n  /** Return the dot product of the vector parameter with the Z row. */\r\n  public dotRowZ(vector: XYZ): number { return vector.x * this.coffs[6] + vector.y * this.coffs[7] + vector.z * this.coffs[8]; }\r\n\r\n  // cSpell:words XXYZ YXYZ ZXYZ XYZAs Eigen\r\n  /** Return the dot product of the x,y,z with the X row. */\r\n  public dotRowXXYZ(x: number, y: number, z: number): number { return x * this.coffs[0] + y * this.coffs[1] + z * this.coffs[2]; }\r\n  /** Return the dot product of the x,y,z with the Y row. */\r\n  public dotRowYXYZ(x: number, y: number, z: number): number { return x * this.coffs[3] + y * this.coffs[4] + z * this.coffs[5]; }\r\n  /** Return the dot product of the x,y,z with the Z row. */\r\n  public dotRowZXYZ(x: number, y: number, z: number): number { return x * this.coffs[6] + y * this.coffs[7] + z * this.coffs[8]; }\r\n\r\n  /** Return the (vector) cross product of the Z column with the vector parameter. */\r\n  public columnZCrossVector(vector: XYZ, result?: Vector3d): Vector3d {\r\n    return Geometry.crossProductXYZXYZ(this.coffs[2], this.coffs[5], this.coffs[8], vector.x, vector.y, vector.z, result);\r\n  }\r\n  /**\r\n   * Replace current rows Ui Uj with (c*Ui - s*Uj) and (c*Uj + s*Ui)\r\n   * @param i first row index.  must be 0,1,2 (unchecked)\r\n   * @param j second row index. must be 0,1,2 (unchecked)\r\n   * @param c fist coefficient\r\n   * @param s second coefficient\r\n   */\r\n  private applyGivensRowOp(i: number, j: number, c: number, s: number): void {\r\n    let ii = 3 * i;\r\n    let jj = 3 * j;\r\n    const limit = ii + 3;\r\n    for (; ii < limit; ii++ , jj++) {\r\n      const a = this.coffs[ii];\r\n      const b = this.coffs[jj];\r\n      this.coffs[ii] = a * c + b * s;\r\n      this.coffs[jj] = -a * s + b * c;\r\n    }\r\n  }\r\n  /**\r\n   * Replace current columns Ui Uj with (c*Ui - s*Uj) and (c*Uj + s*Ui)\r\n   * This is used in compute intensive inner loops -- there is no\r\n   * checking for i,j being 0,1,2\r\n   * @param i first row index.  must be 0,1,2 (unchecked)\r\n   * @param j second row index. must be 0,1,2 (unchecked)\r\n   * @param c fist coefficient\r\n   * @param s second coefficient\r\n   */\r\n  public applyGivensColumnOp(i: number, j: number, c: number, s: number): void {\r\n    const limit = i + 9;\r\n    for (; i < limit; i += 3, j += 3) {\r\n      const a = this.coffs[i];\r\n      const b = this.coffs[j];\r\n      this.coffs[i] = a * c + b * s;\r\n      this.coffs[j] = -a * s + b * c;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * create a rigid coordinate frame with:\r\n   * * column z points from origin to x,y,z\r\n   * * column x is perpendicular and in the xy plane\r\n   * * column y is perpendicular to both.  It is the \"up\" vector on the view plane.\r\n   * * Multiplying a world vector times the transpose of this matrix transforms into the view xy\r\n   * * Multiplying the matrix times the an in-view vector transforms the vector to world.\r\n   * @param x eye x coordinate\r\n   * @param y eye y coordinate\r\n   * @param z eye z coordinate\r\n   * @param result\r\n   */\r\n  public static createRigidViewAxesZTowardsEye(x: number, y: number, z: number, result?: Matrix3d): Matrix3d {\r\n    result = Matrix3d.createIdentity(result);\r\n    const rxy = Geometry.hypotenuseXY(x, y);\r\n    if (Geometry.isSmallMetricDistance(rxy)) {\r\n      // special case for top or bottom view.\r\n      if (z < 0.0)\r\n        result.scaleColumnsInPlace(1.0, -1, -1.0);\r\n    } else {\r\n      //      const d = Geometry.hypotenuseSquaredXYZ(x, y, z);\r\n      const c = x / rxy;\r\n      const s = y / rxy;\r\n      result.setRowValues(\r\n        -s, 0, c,\r\n        c, 0, s,\r\n        0, 1, 0);\r\n      if (z !== 0.0) {\r\n        const r = Geometry.hypotenuseXYZ(x, y, z);\r\n        const s1 = z / r;\r\n        const c1 = rxy / r;\r\n        result.applyGivensColumnOp(1, 2, c1, -s1);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Rotate so columns i and j become perpendicular */\r\n  private applyJacobiColumnRotation(i: number, j: number, matrixU: Matrix3d): number {\r\n    const uDotU = this.coffs[i] * this.coffs[i] + this.coffs[i + 3] * this.coffs[i + 3] + this.coffs[i + 6] * this.coffs[i + 6];\r\n    const vDotV = this.coffs[j] * this.coffs[j] + this.coffs[j + 3] * this.coffs[j + 3] + this.coffs[j + 6] * this.coffs[j + 6];\r\n    const uDotV = this.coffs[i] * this.coffs[j] + this.coffs[i + 3] * this.coffs[j + 3] + this.coffs[i + 6] * this.coffs[j + 6];\r\n    // const c2 = uDotU - vDotV;\r\n    // const s2 = 2.0 * uDotV;\r\n    const jacobi = Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);\r\n    // const h = Math.hypot(c2, s2);\r\n    // console.log(\" c2 s2\", c2 / h, s2 / h);\r\n    // console.log(\" C S \", Math.cos(2 * jacobi.radians), Math.sin(2 * jacobi.radians));\r\n    // console.log(\"i j uDotV\", i, j, uDotV);\r\n    if (Math.abs(jacobi.s) < 2.0e-15)\r\n      return 0.0;\r\n    this.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);\r\n    matrixU.applyGivensRowOp(i, j, jacobi.c, jacobi.s);\r\n    // const BTB = this.multiplyMatrixTransposeMatrix(this);\r\n    // console.log(\"BTB\", BTB.at(0, 0), BTB.at(1, 1), BTB.at(2, 2), \"       off\", BTB.at(0, 1), BTB.at(0, 2), BTB.at(1, 2), \"  at(i,j)\", BTB.at(i, j));\r\n    return Math.abs(uDotV);\r\n  }\r\n  /**\r\n   * Factor this as a product C * U where C has mutually perpendicular columns and\r\n   * U is orthogonal.\r\n   * @param matrixC (allocate by caller, computed here)\r\n   * @param factor  (allocate by caller, computed here)\r\n   */\r\n  public factorPerpendicularColumns(matrixC: Matrix3d, matrixU: Matrix3d): boolean {\r\n    matrixC.setFrom(this);\r\n    matrixU.setIdentity();\r\n    const ss = this.sumSquares();\r\n    const tolerance = 1.0e-12 * ss;\r\n    for (let iteration = 0; iteration < 7; iteration++) {\r\n      const sum = matrixC.applyJacobiColumnRotation(0, 1, matrixU)\r\n        + matrixC.applyJacobiColumnRotation(0, 2, matrixU)\r\n        + matrixC.applyJacobiColumnRotation(1, 2, matrixU);\r\n      // console.log (\"   sum\", sum);\r\n      if (sum < tolerance) {\r\n        // console.log(\"jacobi iterations\", iteration);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Apply a jacobi step to lambda which evolves towards diagonal. */\r\n  private applySymmetricJacobi(i: number, j: number, lambda: Matrix3d): number {\r\n    const uDotU = lambda.at(i, i);\r\n    const vDotV = lambda.at(j, j);\r\n    const uDotV = lambda.at(i, j);\r\n    if (Math.abs(uDotV) < 1.0e-15 * (uDotU + vDotV))\r\n      return 0.0;\r\n    // const c2 = uDotU - vDotV;\r\n    // const s2 = 2.0 * uDotV;\r\n    const jacobi = Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);\r\n    // const h = Math.hypot(c2, s2);\r\n    // console.log(\" c2 s2\", c2 / h, s2 / h);\r\n    // console.log(\" C S \", Math.cos(2 * jacobi.radians), Math.sin(2 * jacobi.radians));\r\n    // console.log(\"i j uDotV\", i, j, uDotV);\r\n    if (Math.abs(jacobi.s) < 2.0e-15)\r\n      return 0.0;\r\n    // Factored form is this *lambda * thisTranspose\r\n    // Let Q be the rotation matrix.  Q*QT is inserted, viz\r\n    //          this*Q * QT * lambda * Q*thisTranspose\r\n    this.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);\r\n\r\n    lambda.applyGivensRowOp(i, j, jacobi.c, jacobi.s);\r\n    lambda.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);\r\n    // const BTB = this.multiplyMatrixTransposeMatrix(this);\r\n    // console.log(\"BTB\", BTB.at(0, 0), BTB.at(1, 1), BTB.at(2, 2), \"       off\", BTB.at(0, 1), BTB.at(0, 2), BTB.at(1, 2), \"  at(i,j)\", BTB.at(i, j));\r\n    return Math.abs(uDotV);\r\n  }\r\n  /**\r\n   * Factor this (symmetrized) as a product U * lambda * UT where U is orthogonal, lambda is diagonal.\r\n   * The upper triangle is mirrored to lower triangle to enforce symmetry.\r\n   * @param matrixC (allocate by caller, computed here)\r\n   * @param factor  (allocate by caller, computed here)\r\n   */\r\n  public symmetricEigenvalues(leftEigenvectors: Matrix3d, lambda: Vector3d): boolean {\r\n    const matrix = this.clone();\r\n    leftEigenvectors.setIdentity();\r\n    matrix.coffs[3] = matrix.coffs[1];\r\n    matrix.coffs[6] = matrix.coffs[2];\r\n    matrix.coffs[7] = matrix.coffs[5];\r\n    const ss = this.sumSquares();\r\n    const tolerance = 1.0e-12 * ss;\r\n    for (let iteration = 0; iteration < 7; iteration++) {\r\n      const sum = leftEigenvectors.applySymmetricJacobi(0, 1, matrix)\r\n        + leftEigenvectors.applySymmetricJacobi(0, 2, matrix)\r\n        + leftEigenvectors.applySymmetricJacobi(1, 2, matrix);\r\n      // console.log(\"symmetric sum\", sum);\r\n      // console.log (\"   sum\", sum);\r\n      if (sum < tolerance) {\r\n        // console.log(\"symmetric iterations\", iteration);\r\n        lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Apply (in place a jacobi update that zeros out this.at(i,j).\r\n   *\r\n   */\r\n  private applyFastSymmetricJacobiUpdate(\r\n    i: number,  // row index of zeroed member\r\n    j: number,  // column index of zeroed member\r\n    k: number,  // other row/column index (different from i and j)\r\n    leftEigenVectors: Matrix3d): number {\r\n    const indexII = 4 * i;\r\n    const indexJJ = 4 * j;\r\n    const indexIJ = 3 * i + j;\r\n    const indexIK = 3 * i + k;\r\n    const indexJK = 3 * j + k;\r\n    const dotUU = this.coffs[indexII];\r\n    const dotVV = this.coffs[indexJJ];\r\n    const dotUV = this.coffs[indexIJ];\r\n    const jacobi = Angle.trigValuesToHalfAngleTrigValues(dotUU - dotVV, 2.0 * dotUV);\r\n    if (Math.abs(dotUV) < 1.0e-15 * (dotUU + dotVV))\r\n      return 0.0;\r\n    const c = jacobi.c;\r\n    const s = jacobi.s;\r\n    const cc = c * c;\r\n    const ss = s * s;\r\n    const sc2 = 2.0 * c * s;\r\n    this.coffs[indexII] = cc * dotUU + sc2 * dotUV + ss * dotVV;\r\n    this.coffs[indexJJ] = ss * dotUU - sc2 * dotUV + cc * dotVV;\r\n    this.coffs[indexIJ] = 0.0;\r\n    const a = this.coffs[indexIK];\r\n    const b = this.coffs[indexJK];\r\n    this.coffs[indexIK] = a * c + b * s;\r\n    this.coffs[indexJK] = -s * a + c * b;\r\n    this.coffs[3 * j + i] = 0.0;\r\n    this.coffs[3 * k + i] = this.coffs[indexIK];\r\n    this.coffs[3 * k + j] = this.coffs[indexJK];\r\n    leftEigenVectors.applyGivensColumnOp(i, j, c, s);\r\n    return Math.abs(dotUV);\r\n  }\r\n\r\n  /**\r\n   * Factor this (symmetrized) as a product U * lambda * UT where U is orthogonal, lambda is diagonal.\r\n   * The upper triangle is mirrored to lower triangle to enforce symmetry.\r\n   * @param matrixC (allocate by caller, computed here)\r\n   * @param factor  (allocate by caller, computed here)\r\n   */\r\n  public fastSymmetricEigenvalues(leftEigenvectors: Matrix3d, lambda: Vector3d): boolean {\r\n    const matrix = this.clone();\r\n    leftEigenvectors.setIdentity();\r\n    const ss = this.sumSquares();\r\n    const tolerance = 1.0e-12 * ss;\r\n    for (let iteration = 0; iteration < 7; iteration++) {\r\n      const sum = matrix.applyFastSymmetricJacobiUpdate(0, 1, 2, leftEigenvectors)\r\n        + matrix.applyFastSymmetricJacobiUpdate(0, 2, 1, leftEigenvectors)\r\n        + matrix.applyFastSymmetricJacobiUpdate(1, 2, 0, leftEigenvectors);\r\n      // console.log(\"symmetric sum\", sum);\r\n      // console.log (\"   sum\", sum);\r\n      if (sum < tolerance) {\r\n        // console.log(\"symmetric iterations\", iteration);\r\n        lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Create a matrix from column vectors. */\r\n  public static createColumns(vectorU: Vector3d, vectorV: Vector3d, vectorW: Vector3d, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        vectorU.x, vectorV.x, vectorW.x,\r\n        vectorU.y, vectorV.y, vectorW.y,\r\n        vectorU.z, vectorV.z, vectorW.z, result);\r\n  }\r\n\r\n  /** Create a matrix from column vectors.\r\n   * Each column gets x and y from given XAndY, and z from w.\r\n   */\r\n  public static createColumnsXYW(vectorU: XAndY, uz: number, vectorV: XAndY, vz: number, vectorW: XAndY, wz: number, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        vectorU.x, vectorV.x, vectorW.x,\r\n        vectorU.y, vectorV.y, vectorW.y,\r\n        uz, vz, wz, result);\r\n  }\r\n\r\n  /** Install data from xyz parts of Point4d  (w part of Point4d ignored) */\r\n  public setColumnsPoint4dXYZ(vectorU: Point4d, vectorV: Point4d, vectorW: Point4d) {\r\n    this.inverseState = InverseMatrixState.unknown;\r\n    this.setRowValues(\r\n      vectorU.x, vectorV.x, vectorW.x,\r\n      vectorU.y, vectorV.y, vectorW.y,\r\n      vectorU.z, vectorV.z, vectorW.z);\r\n  }\r\n  /**\r\n   * set entries in one column of the matrix.\r\n   * @param columnIndex column index. this is interpreted cyclically.\r\n   * @param value x,yz, values for column.  If undefined, zeros are installed.\r\n   */\r\n  public setColumn(columnIndex: number, value: Vector3d | undefined) {\r\n    const index = Geometry.cyclic3dAxis(columnIndex);\r\n    this.inverseState = InverseMatrixState.unknown;\r\n    if (value) {\r\n      this.coffs[index] = value.x;\r\n      this.coffs[index + 3] = value.y;\r\n      this.coffs[index + 6] = value.z;\r\n    } else {\r\n      this.coffs[index] = 0.0;\r\n      this.coffs[index + 3] = 0.0;\r\n      this.coffs[index + 6] = 0.0;\r\n    }\r\n  }\r\n  /** Set all columns of the matrix. Any undefined vector is zeros. */\r\n  public setColumns(vectorX: Vector3d | undefined, vectorY: Vector3d | undefined, vectorZ?: Vector3d | undefined) {\r\n    this.setColumn(0, vectorX);\r\n    this.setColumn(1, vectorY);\r\n    this.setColumn(2, vectorZ);\r\n  }\r\n  /**\r\n   * set entries in one row of the matrix.\r\n   * @param rowIndex row index. this is interpreted cyclically.\r\n   * @param value x,yz, values for row.  If undefined, zeros are installed.\r\n   */\r\n  public setRow(rowIndex: number, value: Vector3d) {\r\n    const index = 3 * Geometry.cyclic3dAxis(rowIndex);\r\n    this.coffs[index] = value.x;\r\n    this.coffs[index + 1] = value.y;\r\n    this.coffs[index + 2] = value.z;\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n  /** Return a (copy of) a column of the matrix.\r\n   * @param i column index.  This is corrected to 012 by Geometry.cyclic3dAxis.\r\n   */\r\n  public getColumn(columnIndex: number, result?: Vector3d): Vector3d {\r\n    const index = Geometry.cyclic3dAxis(columnIndex);\r\n    return Vector3d.create(\r\n      this.coffs[index],\r\n      this.coffs[index + 3],\r\n      this.coffs[index + 6], result);\r\n  }\r\n\r\n  /** Return a (copy of) a row of the matrix.\r\n   * @param i row index.  This is corrected to 012 by Geometry.cyclic3dAxis.\r\n   */\r\n  public getRow(columnIndex: number, result?: Vector3d): Vector3d {\r\n    const index = 3 * Geometry.cyclic3dAxis(columnIndex);\r\n    return Vector3d.create(\r\n      this.coffs[index],\r\n      this.coffs[index + 1],\r\n      this.coffs[index + 2], result);\r\n  }\r\n\r\n  /** Create a matrix from column vectors, shuffled into place per AxisTriple */\r\n  public static createShuffledColumns(vectorU: Vector3d, vectorV: Vector3d, vectorW: Vector3d, axisOrder: AxisOrder, result?: Matrix3d): Matrix3d {\r\n    const target = Matrix3d._create(result);\r\n    target.setColumn(Geometry.axisOrderToAxis(axisOrder, 0), vectorU);\r\n    target.setColumn(Geometry.axisOrderToAxis(axisOrder, 1), vectorV);\r\n    target.setColumn(Geometry.axisOrderToAxis(axisOrder, 2), vectorW);\r\n    return target;\r\n  }\r\n\r\n  /** Create a matrix from row vectors. */\r\n  public static createRows(vectorU: Vector3d, vectorV: Vector3d, vectorW: Vector3d, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        vectorU.x, vectorU.y, vectorU.z,\r\n        vectorV.x, vectorV.y, vectorV.z,\r\n        vectorW.x, vectorW.y, vectorW.z, result);\r\n  }\r\n\r\n  /** Create a matrix that scales along a specified direction. The scale factor can be negative. for instance scale of -1.0 (negative one) is a mirror. */\r\n  public static createDirectionalScale(direction: Vector3d, scale: number, result?: Matrix3d): Matrix3d {\r\n    const unit = direction.normalize();\r\n    if (unit) {\r\n      const x = unit.x;\r\n      const y = unit.y;\r\n      const z = unit.z;\r\n      const a = (scale - 1);\r\n      return Matrix3d.createRowValues\r\n        (\r\n          1 + a * x * x, a * x * y, a * x * z,\r\n          a * y * x, 1 + a * y * y, a * y * z,\r\n          a * z * x, a * z * y, 1 + a * z * z, result);\r\n    }\r\n    return Matrix3d.createUniformScale(scale);\r\n  }\r\n\r\n  /* Create a matrix with the indicated column in the (normalized) direction, and the other two columns perpendicular. All columns are normalized.\r\n   * * The direction vector is normalized and appears in column axisIndex\r\n   * * If the direction vector is not close to Z, the \"next\" column ((axisIndex + 1) mod 3) will be in the XY plane in the direction of (direction cross Z)\r\n   * * If the direction vector is close to Z, the \"next\" column ((axisIndex + 1) mode 3) will be in the direction of (direction cross Y)\r\n  */\r\n  // static create1Vector(direction: Vector3d, axisIndex: number): Matrix3d;\r\n  // static createFromXYVectors(vectorX: Vector3d, vectorY: Vector3d, axisIndex: number): Matrix3d;\r\n\r\n  /** Multiply the matrix * vector, i.e. the vector is a column vector on the right.\r\n   * @return the vector result\r\n   */\r\n  public multiplyVector(vector: Vector3d, result?: Vector3d): Vector3d {\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    const z = vector.z;\r\n    return Vector3d.create(\r\n      (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z),\r\n      (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z),\r\n      (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z),\r\n      result);\r\n  }\r\n\r\n  /** Multiply the matrix * vector, i.e. the vector is a column vector on the right.\r\n   * @return the vector result\r\n   */\r\n  public multiplyVectorArrayInPlace(data: XYZ[]): void {\r\n    for (const v of data) v.set(\r\n      (this.coffs[0] * v.x + this.coffs[1] * v.y + this.coffs[2] * v.z),\r\n      (this.coffs[3] * v.x + this.coffs[4] * v.y + this.coffs[5] * v.z),\r\n      (this.coffs[6] * v.x + this.coffs[7] * v.y + this.coffs[8] * v.z));\r\n  }\r\n\r\n  /** compute `origin - matrix * vector` */\r\n  public static xyzMinusMatrixTimesXYZ(origin: XYAndZ, matrix: Matrix3d, vector: XYAndZ, result?: Point3d): Point3d {\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    const z = vector.z;\r\n    return Point3d.create(\r\n      origin.x - (matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z),\r\n      origin.y - (matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z),\r\n      origin.z - (matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z),\r\n      result);\r\n  }\r\n\r\n  /** compute  `origin + matrix * vector`  using only the xy parts of the inputs. */\r\n  public static xyPlusMatrixTimesXY(origin: XAndY, matrix: Matrix3d, vector: XAndY, result?: Point2d): Point2d {\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    return Point2d.create(\r\n      origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y,\r\n      origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y,\r\n      result);\r\n  }\r\n\r\n  /** compute  `origin + matrix * vector`  using all xyz parts of the inputs. */\r\n  public static xyzPlusMatrixTimesXYZ(origin: XYZ, matrix: Matrix3d, vector: XYAndZ, result?: Point3d): Point3d {\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    const z = vector.z;\r\n    return Point3d.create(\r\n      origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z,\r\n      origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z,\r\n      origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z,\r\n      result);\r\n  }\r\n  /** compute  `origin + matrix * vector`  using all xyz parts of the inputs. */\r\n  public static xyzPlusMatrixTimesXYZInPlace(origin: XYZ, matrix: Matrix3d, vector: WritableXYAndZ) {\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    const z = vector.z;\r\n    vector.x = origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;\r\n    vector.y = origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;\r\n    vector.z = origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;\r\n  }\r\n  /** compute `origin + matrix * vector` where the final vector is given as direct x,y,z coordinates */\r\n  public static xyzPlusMatrixTimesCoordinates(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, result?: Point3d): Point3d {\r\n    return Point3d.create(\r\n      origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z,\r\n      origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z,\r\n      origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z,\r\n      result);\r\n  }\r\n\r\n  /**\r\n   * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.\r\n   * Multiply times point with coordinates `[x,y,z,w]`\r\n   * @param origin translation part (xyz in column 3)\r\n   * @param matrix matrix part (leading 3x3)\r\n   * @param x x part of multiplied point\r\n   * @param y y part of multiplied point\r\n   * @param z z part of multiplied point\r\n   * @param w w part of multiplied point\r\n   * @param result optional result.\r\n   */\r\n  public static xyzPlusMatrixTimesWeightedCoordinates(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, w: number, result?: Point4d): Point4d {\r\n    return Point4d.create(\r\n      w * origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z,\r\n      w * origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z,\r\n      w * origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z,\r\n      w,\r\n      result);\r\n  }\r\n  /**\r\n   * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.\r\n   * Multiply times point with coordinates `[x,y,z,w]`\r\n   * @param origin translation part (xyz in column 3)\r\n   * @param matrix matrix part (leading 3x3)\r\n   * @param x x part of multiplied point\r\n   * @param y y part of multiplied point\r\n   * @param z z part of multiplied point\r\n   * @param w w part of multiplied point\r\n   * @param result optional result.\r\n   */\r\n  public static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, w: number, result?: Float64Array): Float64Array {\r\n    if (!result)\r\n      result = new Float64Array(4);\r\n    result[0] = w * origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;\r\n    result[1] = w * origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;\r\n    result[2] = w * origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;\r\n    result[3] = w;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.\r\n   * Multiply times point with coordinates `[x,y,z,w]`\r\n   * @param origin translation part (xyz in column 3)\r\n   * @param matrix matrix part (leading 3x3)\r\n   * @param x x part of multiplied point\r\n   * @param y y part of multiplied point\r\n   * @param z z part of multiplied point\r\n   * @param w w part of multiplied point\r\n   * @param result optional result.\r\n   */\r\n  public static xyzPlusMatrixTimesCoordinatesToFloat64Array(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, result?: Float64Array): Float64Array {\r\n    if (!result)\r\n      result = new Float64Array(3);\r\n    result[0] = origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;\r\n    result[1] = origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;\r\n    result[2] = origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;\r\n    return result;\r\n  }\r\n  /** Multiply transpose of this matrix times a vector. */\r\n  public multiplyTransposeVector(vector: Vector3d, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    const z = vector.z;\r\n    result.x = (this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z);\r\n    result.y = (this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z);\r\n    result.z = (this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z);\r\n    return result;\r\n  }\r\n\r\n  /** Multiply the matrix * (x,y,z), i.e. the vector (x,y,z) is a column vector on the right.\r\n   * @return the vector result\r\n   */\r\n  public multiplyXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z);\r\n    result.y = (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z);\r\n    result.z = (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z);\r\n    return result;\r\n  }\r\n\r\n  /** Multiply the matrix * xyz, place result in (required) return value.\r\n   *   @param xyz right side\r\n   *   @param result result.\r\n   */\r\n  public multiplyXYZtoXYZ(xyz: XYZ, result: XYZ) {\r\n    const x = xyz.x;\r\n    const y = xyz.y;\r\n    const z = xyz.z;\r\n    result.x = (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z);\r\n    result.y = (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z);\r\n    result.z = (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z);\r\n    return result;\r\n  }\r\n\r\n  /** Multiply the matrix * (x,y,0), i.e. the vector (x,y,z) is a column vector on the right.\r\n   *   @return the vector result\r\n   */\r\n  public multiplyXY(x: number, y: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = (this.coffs[0] * x + this.coffs[1] * y);\r\n    result.y = (this.coffs[3] * x + this.coffs[4] * y);\r\n    result.z = (this.coffs[6] * x + this.coffs[7] * y);\r\n    return result;\r\n  }\r\n\r\n  /** compute `origin + this*[x,y,0]`  */\r\n  public originPlusMatrixTimesXY(origin: XYZ, x: number, y: number, result?: Point3d): Point3d {\r\n    return Point3d.create(\r\n      origin.x + this.coffs[0] * x + this.coffs[1] * y,\r\n      origin.y + this.coffs[3] * x + this.coffs[4] * y,\r\n      origin.z + this.coffs[6] * x + this.coffs[7] * y,\r\n      result);\r\n  }\r\n\r\n  /** Multiply matrix * (x, y, z) using any 3d object given containing those members */\r\n  public multiplyVectorInPlace(xyzData: XYZ): void {\r\n    const x = xyzData.x;\r\n    const y = xyzData.y;\r\n    const z = xyzData.z;\r\n    const coffs = this.coffs;\r\n    xyzData.x = (coffs[0] * x + coffs[1] * y + coffs[2] * z);\r\n    xyzData.y = (coffs[3] * x + coffs[4] * y + coffs[5] * z);\r\n    xyzData.z = (coffs[6] * x + coffs[7] * y + coffs[8] * z);\r\n  }\r\n\r\n  /** Multiply matrix * (x, y, z) using any 3d object given containing those members */\r\n  public multiplyTransposeVectorInPlace(xyzData: XYZ): void {\r\n    const x = xyzData.x;\r\n    const y = xyzData.y;\r\n    const z = xyzData.z;\r\n    const coffs = this.coffs;\r\n    xyzData.x = (coffs[0] * x + coffs[3] * y + coffs[6] * z);\r\n    xyzData.y = (coffs[1] * x + coffs[4] * y + coffs[7] * z);\r\n    xyzData.z = (coffs[2] * x + coffs[5] * y + coffs[8] * z);\r\n  }\r\n\r\n  /** Multiply the (x,y,z) * matrix, i.e. the vector (x,y,z) is a row vector on the left.\r\n   *   @return the vector result\r\n   */\r\n  public multiplyTransposeXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = (this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z);\r\n    result.y = (this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z);\r\n    result.z = (this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z);\r\n    return result;\r\n  }\r\n  /** Solve matrix * result = vector, i.e. multiply result = matrixInverse * rightHandSide  */\r\n  public multiplyInverse(vector: Vector3d, result?: Vector3d): Vector3d | undefined {\r\n    this.computeCachedInverse(true);\r\n    if (this.inverseCoffs) {\r\n      const x = vector.x;\r\n      const y = vector.y;\r\n      const z = vector.z;\r\n      return Vector3d.create(\r\n        (this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z),\r\n        (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z),\r\n        (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z),\r\n        result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Solve matrix * result = vector, i.e. multiply result = matrixInverse * rightHandSide  */\r\n  public multiplyInverseTranspose(vector: Vector3d, result?: Vector3d): Vector3d | undefined {\r\n    this.computeCachedInverse(true);\r\n    if (this.inverseCoffs) {\r\n      const x = vector.x;\r\n      const y = vector.y;\r\n      const z = vector.z;\r\n      return Vector3d.create(\r\n        (this.inverseCoffs[0] * x + this.inverseCoffs[3] * y + this.inverseCoffs[6] * z),\r\n        (this.inverseCoffs[1] * x + this.inverseCoffs[4] * y + this.inverseCoffs[7] * z),\r\n        (this.inverseCoffs[2] * x + this.inverseCoffs[5] * y + this.inverseCoffs[8] * z),\r\n        result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * *  multiply matrixInverse * [x,y,z]\r\n   * *  Equivalent to solving matrix * result = [x,y,z]\r\n   * *  return as a Vector3d.\r\n   */\r\n  public multiplyInverseXYZAsVector3d(x: number, y: number, z: number, result?: Vector3d): Vector3d | undefined {\r\n    this.computeCachedInverse(true);\r\n    if (this.inverseCoffs) {\r\n      return Vector3d.create(\r\n        (this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z),\r\n        (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z),\r\n        (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z),\r\n        result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * *  multiply matrixInverse * [x,y,z]\r\n   * *  Equivalent to solving matrix * result = [x,y,z]\r\n   * *  return as a Point3d.\r\n   */\r\n  public multiplyInverseXYZAsPoint3d(x: number, y: number, z: number, result?: Point3d): Point3d | undefined {\r\n    this.computeCachedInverse(true);\r\n    if (this.inverseCoffs) {\r\n      return Point3d.create(\r\n        (this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z),\r\n        (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z),\r\n        (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z),\r\n        result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Multiply two matrices.\r\n   *   @return the matrix result\r\n   */\r\n  public multiplyMatrixMatrix(other: Matrix3d, result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs, other.coffs, result.coffs);\r\n    return result;\r\n  }\r\n\r\n  /** Multiply this matrix times inverse of other\r\n   *   @return the matrix result\r\n   */\r\n  public multiplyMatrixMatrixInverse(other: Matrix3d, result?: Matrix3d): Matrix3d | undefined {\r\n    if (!other.computeCachedInverse(true))\r\n      return undefined;\r\n    result = result ? result : new Matrix3d();\r\n    PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs, other.inverseCoffs!, result.coffs);\r\n    return result;\r\n  }\r\n  /** Matrix multiplication `this * otherTranspose`\r\n   * @return the matrix result\r\n   */\r\n  public multiplyMatrixMatrixTranspose(other: Matrix3d, result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    PackedMatrix3dOps.multiplyMatrixMatrixTranspose(this.coffs, other.coffs, result.coffs);\r\n    return result;\r\n  }\r\n\r\n  /** Matrix multiplication `thisTranspose * other`\r\n   *   @return the matrix result\r\n   */\r\n  public multiplyMatrixTransposeMatrix(other: Matrix3d, result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    PackedMatrix3dOps.multiplyMatrixTransposeMatrix(this.coffs, other.coffs, result.coffs);\r\n    return result;\r\n  }\r\n  //   [Q 0][R A] = [QR QA]\r\n  //   [0 1][0 1]   [0  1]\r\n  /** multiply this Matrix3d (considered as a transform with 0 translation) times other Transform.\r\n   * @param other right hand Matrix3d for multiplication.\r\n   * @param result optional preallocated result to reuse.\r\n   */\r\n  public multiplyMatrixTransform(other: Transform, result?: Transform): Transform {\r\n    if (!result)\r\n      return Transform.createRefs(\r\n        this.multiplyXYZ(other.origin.x, other.origin.y, other.origin.z),\r\n        this.multiplyMatrixMatrix(other.matrix));\r\n    // be sure to do the point multiplication first before aliasing changes the matrix ..\r\n    this.multiplyXYZtoXYZ(other.origin, result.origin);\r\n    this.multiplyMatrixMatrix(other.matrix, result.matrix);\r\n    return result;\r\n  }\r\n\r\n  /** return the transposed matrix */\r\n  public transpose(result?: Matrix3d): Matrix3d {\r\n    if (!result) result = new Matrix3d();\r\n    PackedMatrix3dOps.copyTransposed(this.coffs, result.coffs);\r\n    if (this.inverseCoffs !== undefined) {\r\n      result.inverseState = InverseMatrixState.inverseStored;\r\n      result.inverseCoffs = PackedMatrix3dOps.copyTransposed(this.inverseCoffs, result.inverseCoffs);\r\n    } else {\r\n      result.inverseState = this.inverseState;  // singular or unknown.\r\n      result.inverseCoffs = undefined;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** return the transposed matrix */\r\n  public transposeInPlace() {\r\n    PackedMatrix3dOps.transposeInPlace(this.coffs);\r\n    if (this.inverseCoffs)\r\n      PackedMatrix3dOps.transposeInPlace(this.inverseCoffs);\r\n  }\r\n\r\n  /** return the inverse matrix.  The return is  null if the matrix is singular (has columns that are coplanar or colinear) */\r\n  public inverse(result?: Matrix3d): Matrix3d | undefined {\r\n    this.computeCachedInverse(true);\r\n    if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs)\r\n      return Matrix3d.createRowValues(this.inverseCoffs[0], this.inverseCoffs[1], this.inverseCoffs[2],\r\n        this.inverseCoffs[3], this.inverseCoffs[4], this.inverseCoffs[5],\r\n        this.inverseCoffs[6], this.inverseCoffs[7], this.inverseCoffs[8], result);\r\n    return undefined;\r\n  }\r\n\r\n  /** copy the transpose of the coffs to the inverseCoffs.\r\n   * * mark the matrix as inverseStored.\r\n   */\r\n  private setupInverseTranspose() {\r\n    const coffs = this.coffs;\r\n    this.inverseState = InverseMatrixState.inverseStored;\r\n    this.inverseCoffs = Float64Array.from([coffs[0], coffs[3], coffs[6],\r\n    coffs[1], coffs[4], coffs[7],\r\n    coffs[2], coffs[5], coffs[8]]);\r\n  }\r\n\r\n  /* Alternate implementation of computedCachedInverse - more direct addressing of arrays.\r\n     This is indeed 10% faster than using static work areas. */\r\n\r\n  // take the cross product of two rows of source.\r\n  // store as a column of dest.\r\n  private static indexedRowCrossProduct(source: Float64Array, rowStart0: number, rowStart1: number, dest: Float64Array, columnStart: number) {\r\n    dest[columnStart] = source[rowStart0 + 1] * source[rowStart1 + 2] - source[rowStart0 + 2] * source[rowStart1 + 1];\r\n    dest[columnStart + 3] = source[rowStart0 + 2] * source[rowStart1] - source[rowStart0] * source[rowStart1 + 2];\r\n    dest[columnStart + 6] = source[rowStart0] * source[rowStart1 + 1] - source[rowStart0 + 1] * source[rowStart1];\r\n  }\r\n\r\n  // take the cross product of two columns of source.\r\n  // store as third column in same Matrix3d.\r\n  // This is private because the columnStart values are unchecked raw indices into the coffs\r\n  private indexedColumnCrossProductInPlace(colStart0: number, colStart1: number, colStart2: number) {\r\n    const coffs = this.coffs;\r\n    coffs[colStart2] = coffs[colStart0 + 3] * coffs[colStart1 + 6] - coffs[colStart0 + 6] * coffs[colStart1 + 3];\r\n    coffs[colStart2 + 3] = coffs[colStart0 + 6] * coffs[colStart1] - coffs[colStart0] * coffs[colStart1 + 6];\r\n    coffs[colStart2 + 6] = coffs[colStart0] * coffs[colStart1 + 3] - coffs[colStart0 + 3] * coffs[colStart1];\r\n  }\r\n  /** Form cross products among axes in axisOrder.\r\n   * For axis order ABC,\r\n   * * form cross product of column A and B, store in C\r\n   * * form cross product of column C and A, store in B.\r\n   * This means that in the final matrix:\r\n   * * column A is strictly parallel to original column A\r\n   * * column B is linear combination of only original A and B\r\n   * * column C is perpendicular to A and B of both the original and final.\r\n   * * original column C does not participate in the result.\r\n   */\r\n  public axisOrderCrossProductsInPlace(axisOrder: AxisOrder) {\r\n    switch (axisOrder) {\r\n      case AxisOrder.XYZ: {\r\n        this.indexedColumnCrossProductInPlace(0, 1, 2);\r\n        this.indexedColumnCrossProductInPlace(2, 0, 1);\r\n        break;\r\n      }\r\n      case AxisOrder.YZX: {\r\n        this.indexedColumnCrossProductInPlace(1, 2, 0);\r\n        this.indexedColumnCrossProductInPlace(0, 1, 2);\r\n        break;\r\n      }\r\n      case AxisOrder.ZXY: {\r\n        this.indexedColumnCrossProductInPlace(2, 0, 1);\r\n        this.indexedColumnCrossProductInPlace(1, 2, 0);\r\n        break;\r\n      }\r\n      case AxisOrder.XZY: {\r\n        this.indexedColumnCrossProductInPlace(0, 2, 1);\r\n        this.indexedColumnCrossProductInPlace(1, 0, 2);\r\n        break;\r\n      }\r\n      case AxisOrder.YXZ: {\r\n        this.indexedColumnCrossProductInPlace(1, 0, 2);\r\n        this.indexedColumnCrossProductInPlace(2, 1, 0);\r\n        break;\r\n      }\r\n      case AxisOrder.ZYX: {\r\n        this.indexedColumnCrossProductInPlace(2, 1, 0);\r\n        this.indexedColumnCrossProductInPlace(0, 2, 1);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Normalize each column in place.\r\n   * * For false return the magnitudes are stored in the originalMagnitudes vector but no columns are altered.\r\n   * @returns Return true if all columns had nonzero lengths.\r\n   * @param originalMagnitudes optional vector to receive original column magnitudes.\r\n   */\r\n  public normalizeColumnsInPlace(originalMagnitudes?: Vector3d): boolean {\r\n    const ax = this.columnXMagnitude();\r\n    const ay = this.columnYMagnitude();\r\n    const az = this.columnZMagnitude();\r\n    if (originalMagnitudes)\r\n      originalMagnitudes.set(ax, ay, az);\r\n    if (Geometry.isSmallMetricDistance(ax) || Geometry.isSmallMetricDistance(ay) || Geometry.isSmallMetricDistance(az))\r\n      return false;\r\n    this.scaleColumns(1.0 / ax, 1.0 / ay, 1.0 / az, this);\r\n    return true;\r\n  }\r\n  /** Normalize each row in place */\r\n  public normalizeRowsInPlace(originalMagnitudes?: Vector3d): boolean {\r\n    const ax = this.rowXMagnitude();\r\n    const ay = this.rowYMagnitude();\r\n    const az = this.rowZMagnitude();\r\n    if (originalMagnitudes)\r\n      originalMagnitudes.set(ax, ay, az);\r\n    if (Geometry.isSmallMetricDistance(ax) || Geometry.isSmallMetricDistance(ay) || Geometry.isSmallMetricDistance(az))\r\n      return false;\r\n    this.scaleRows(1.0 / ax, 1.0 / ay, 1.0 / az, this);\r\n    return true;\r\n  }\r\n  // take the cross product of two rows of source.\r\n  // store as a column of dest.\r\n  private static rowColumnDot(coffA: Float64Array, rowStartA: number, coffB: Float64Array, columnStartB: number): number {\r\n    return coffA[rowStartA] * coffB[columnStartB] + coffA[rowStartA + 1] * coffB[columnStartB + 3] + coffA[rowStartA + 2] * coffB[columnStartB + 6];\r\n  }\r\n  /**\r\n   * Returns true if the matrix is singular (i.e. collapses data to a plane, line, or point)\r\n   */\r\n  public isSingular(): boolean {\r\n    return !this.computeCachedInverse(true);\r\n  }\r\n  /**\r\n   * Mark this matrix as singular.\r\n   */\r\n  public markSingular() {\r\n    this.inverseState = InverseMatrixState.singular;\r\n  }\r\n\r\n  /** compute the inverse of this Matrix3d. The inverse is stored for later use.\r\n   * @returns Return true if the inverse computed.  (False if the columns collapse to a point, line or plane.)\r\n   */\r\n  public computeCachedInverse(useCacheIfAvailable: boolean): boolean {\r\n    if (useCacheIfAvailable && Matrix3d.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {\r\n      Matrix3d.numUseCache++;\r\n      return this.inverseState === InverseMatrixState.inverseStored;\r\n    }\r\n    this.inverseState = InverseMatrixState.unknown;\r\n    if (this.inverseCoffs === undefined)\r\n      this.inverseCoffs = new Float64Array(9);\r\n    const coffs = this.coffs;\r\n    const inverseCoffs = this.inverseCoffs;\r\n    Matrix3d.indexedRowCrossProduct(coffs, 3, 6, inverseCoffs, 0);\r\n    Matrix3d.indexedRowCrossProduct(coffs, 6, 0, inverseCoffs, 1);\r\n    Matrix3d.indexedRowCrossProduct(coffs, 0, 3, inverseCoffs, 2);\r\n    Matrix3d.numComputeCache++;\r\n    const d = Matrix3d.rowColumnDot(coffs, 0, inverseCoffs, 0);\r\n    if (d === 0.0) {     // better test?\r\n      this.inverseState = InverseMatrixState.singular;\r\n      this.inverseCoffs = undefined;\r\n      return false;\r\n    }\r\n    const f = 1.0 / d;\r\n    for (let i = 0; i < 9; i++)inverseCoffs[i] *= f;\r\n    this.inverseState = InverseMatrixState.inverseStored;\r\n    // verify inverse\r\n    // const p = new Float64Array(9);\r\n    // for (let i = 0; i < 9; i += 3)\r\n    //   for (let j = 0; j < 3; j++)\r\n    //    p[i + j] = Matrix3d.rowColumnDot (coffs, i, inverseCoffs, j);\r\n    return true;\r\n  }\r\n\r\n  /* \"Classic\" inverse implementation with temporary vectors.\r\n    private static rowX: Vector3d = Vector3d.create();\r\n    private static rowY: Vector3d = Vector3d.create();\r\n    private static rowZ: Vector3d = Vector3d.create();\r\n    private static crossXY: Vector3d = Vector3d.create();\r\n    private static crossZX: Vector3d = Vector3d.create();\r\n    private static crossYZ: Vector3d = Vector3d.create();\r\n  private computeCachedInverse(useCacheIfAvailable: boolean) {\r\n      if (useCacheIfAvailable && Matrix3d.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {\r\n        Matrix3d.numUseCache++;\r\n        return this.inverseState === InverseMatrixState.inverseStored;\r\n      }\r\n      this.inverseState = InverseMatrixState.unknown;\r\n      Matrix3d.numComputeCache++;\r\n      const rowX = this.rowX(Matrix3d.rowX);\r\n      const rowY = this.rowY(Matrix3d.rowY);\r\n      const rowZ = this.rowZ(Matrix3d.rowZ);\r\n      const crossXY = rowX.crossProduct(rowY, Matrix3d.crossXY);\r\n      const crossYZ = rowY.crossProduct(rowZ, Matrix3d.crossYZ);\r\n      const crossZX = rowZ.crossProduct(rowX, Matrix3d.crossZX);\r\n      const d = rowX.dotProduct(crossYZ);  // that's the determinant\r\n      if (d === 0.0) {     // better test?\r\n        this.inverseState = InverseMatrixState.singular;\r\n        this.inverseCoffs = undefined;\r\n        return false;\r\n      }\r\n      const f = 1.0 / d;\r\n      this.inverseState = InverseMatrixState.inverseStored;   // Currently just lists that the inverse has been stored... singular case not handled\r\n      this.inverseCoffs = Float64Array.from([crossYZ.x * f, crossZX.x * f, crossXY.x * f,\r\n      crossYZ.y * f, crossZX.y * f, crossXY.y * f,\r\n      crossYZ.z * f, crossZX.z * f, crossXY.z * f]);\r\n      return true;\r\n    }\r\n  */\r\n  /** convert a (row,column) index pair to the single index within flattened array of 9 numbers in row-major-order  */\r\n  public static flatIndexOf(row: number, column: number): number {\r\n    return 3 * Geometry.cyclic3dAxis(row) + Geometry.cyclic3dAxis(column);\r\n  }\r\n\r\n  /** Get a column by index (0,1,2), packaged as a Point4d with given weight.   Out of range index is interpreted cyclically.  */\r\n  public indexedColumnWithWeight(index: number, weight: number, result?: Point4d): Point4d {\r\n    index = Geometry.cyclic3dAxis(index);\r\n    return Point4d.create(this.coffs[index], this.coffs[index + 3], this.coffs[index + 6], weight, result);\r\n  }\r\n\r\n  /** return the entry at specific row and column */\r\n  public at(row: number, column: number): number {\r\n    return this.coffs[Matrix3d.flatIndexOf(row, column)];\r\n  }\r\n\r\n  /** Set the entry at specific row and column */\r\n  public setAt(row: number, column: number, value: number): void {\r\n    this.coffs[Matrix3d.flatIndexOf(row, column)] = value;\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n\r\n  /** create a Matrix3d whose columns are scaled copies of this Matrix3d.\r\n   * @param scaleX scale factor for columns x\r\n   * @param scaleY scale factor for column y\r\n   * @param scaleZ scale factor for column z\r\n   * @param result optional result.\r\n   */\r\n  public scaleColumns(scaleX: number, scaleY: number, scaleZ: number, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        this.coffs[0] * scaleX, this.coffs[1] * scaleY, this.coffs[2] * scaleZ,\r\n        this.coffs[3] * scaleX, this.coffs[4] * scaleY, this.coffs[5] * scaleZ,\r\n        this.coffs[6] * scaleX, this.coffs[7] * scaleY, this.coffs[8] * scaleZ,\r\n        result);\r\n  }\r\n\r\n  /** create a Matrix3d whose columns are scaled copies of this Matrix3d.\r\n   * @param scaleX scale factor for columns x\r\n   * @param scaleY scale factor for column y\r\n   * @param scaleZ scale factor for column z\r\n   * @param result optional result.\r\n   */\r\n  public scaleColumnsInPlace(scaleX: number, scaleY: number, scaleZ: number) {\r\n\r\n    this.coffs[0] *= scaleX; this.coffs[1] *= scaleY; this.coffs[2] *= scaleZ;\r\n    this.coffs[3] *= scaleX; this.coffs[4] *= scaleY; this.coffs[5] *= scaleZ;\r\n    this.coffs[6] *= scaleX; this.coffs[7] *= scaleY; this.coffs[8] *= scaleZ;\r\n    if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs !== undefined) {\r\n      // apply reciprocal scales to the ROWS of the inverse .  . .\r\n      const divX = Geometry.conditionalDivideFraction(1.0, scaleX);\r\n      const divY = Geometry.conditionalDivideFraction(1.0, scaleY);\r\n      const divZ = Geometry.conditionalDivideFraction(1.0, scaleZ);\r\n      if (divX !== undefined && divY !== undefined && divZ !== undefined) {\r\n        this.inverseCoffs[0] *= divX; this.inverseCoffs[1] *= divX; this.inverseCoffs[2] *= divX;\r\n        this.inverseCoffs[3] *= divY; this.inverseCoffs[4] *= divY; this.inverseCoffs[5] *= divY;\r\n        this.inverseCoffs[6] *= divZ; this.inverseCoffs[7] *= divZ; this.inverseCoffs[8] *= divZ;\r\n      } else\r\n        this.inverseState = InverseMatrixState.singular;\r\n    }\r\n  }\r\n\r\n  /** create a Matrix3d whose rows are scaled copies of this Matrix3d.\r\n   * @param scaleX scale factor for row x\r\n   * @param scaleY scale factor for row y\r\n   * @param scaleZ scale factor for row z\r\n   * @param result optional result.\r\n   */\r\n  public scaleRows(scaleX: number, scaleY: number, scaleZ: number, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        this.coffs[0] * scaleX, this.coffs[1] * scaleX, this.coffs[2] * scaleX,\r\n        this.coffs[3] * scaleY, this.coffs[4] * scaleY, this.coffs[5] * scaleY,\r\n        this.coffs[6] * scaleZ, this.coffs[7] * scaleZ, this.coffs[8] * scaleZ,\r\n        result);\r\n  }\r\n  /**\r\n   * add scaled values from other Matrix3d to this Matrix3d\r\n   * @param other Matrix3d with values to be added\r\n   * @param scale scale factor to apply to th eadded values.\r\n   */\r\n  public addScaledInPlace(other: Matrix3d, scale: number): void {\r\n    for (let i = 0; i < 9; i++)\r\n      this.coffs[i] += scale * other.coffs[i];\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n  /**\r\n   * add scaled values from other Matrix3d to this Matrix3d\r\n   * @param other Matrix3d with values to be added\r\n   * @param scale scale factor to apply to th eadded values.\r\n   */\r\n  public addScaledOuterProductInPlace(vectorU: Vector3d, vectorV: Vector3d, scale: number): void {\r\n    this.coffs[0] += scale * vectorU.x * vectorV.x;\r\n    this.coffs[1] += scale * vectorU.x * vectorV.y;\r\n    this.coffs[2] += scale * vectorU.x * vectorV.z;\r\n\r\n    this.coffs[3] += scale * vectorU.y * vectorV.x;\r\n    this.coffs[4] += scale * vectorU.y * vectorV.y;\r\n    this.coffs[5] += scale * vectorU.y * vectorV.z;\r\n\r\n    this.coffs[6] += scale * vectorU.z * vectorV.x;\r\n    this.coffs[7] += scale * vectorU.z * vectorV.y;\r\n    this.coffs[8] += scale * vectorU.z * vectorV.z;\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n\r\n  /** create a Matrix3d whose values are uniformly scaled from this.\r\n   * @param scale scale factor to apply.\r\n   * @param result optional result.\r\n   * @returns Return the new or repopulated matrix\r\n   */\r\n  public scale(scale: number, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        this.coffs[0] * scale, this.coffs[1] * scale, this.coffs[2] * scale,\r\n        this.coffs[3] * scale, this.coffs[4] * scale, this.coffs[5] * scale,\r\n        this.coffs[6] * scale, this.coffs[7] * scale, this.coffs[8] * scale,\r\n        result);\r\n\r\n  }\r\n\r\n  /** Return the determinant of this matrix. */\r\n  public determinant(): number {\r\n    return this.coffs[0] * this.coffs[4] * this.coffs[8]\r\n      - this.coffs[0] * this.coffs[7] * this.coffs[5]\r\n      + this.coffs[3] * this.coffs[7] * this.coffs[2]\r\n      - this.coffs[3] * this.coffs[1] * this.coffs[8]\r\n      + this.coffs[6] * this.coffs[1] * this.coffs[5]\r\n      - this.coffs[6] * this.coffs[4] * this.coffs[2];\r\n  }\r\n\r\n  /** Return an estimate of how independent the columns are.  Near zero is bad. Near 1 is good\r\n   */\r\n  public conditionNumber(): number {\r\n    const determinant = this.determinant();\r\n    const columnMagnitudeProduct =\r\n      Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[3], this.coffs[6])\r\n      + Geometry.hypotenuseXYZ(this.coffs[1], this.coffs[4], this.coffs[7])\r\n      + Geometry.hypotenuseXYZ(this.coffs[2], this.coffs[5], this.coffs[8]);\r\n    return Geometry.safeDivideFraction(determinant, columnMagnitudeProduct, 0.0);\r\n  }\r\n  /** Return the sum of squares of all entries */\r\n  public sumSquares(): number {\r\n    let i = 0;\r\n    let a = 0;\r\n    for (i = 0; i < 9; i++)\r\n      a += this.coffs[i] * this.coffs[i];\r\n    return a;\r\n  }\r\n\r\n  /** Return the sum of squares of diagonal entries */\r\n  public sumDiagonalSquares(): number {\r\n    let i = 0;\r\n    let a = 0;\r\n    for (i = 0; i < 9; i += 4)\r\n      a += this.coffs[i] * this.coffs[i];\r\n    return a;\r\n  }\r\n\r\n  /** Return the sum of diagonal entries (also known as the trace) */\r\n  public sumDiagonal(): number {\r\n    return this.coffs[0] + this.coffs[4] + this.coffs[8];\r\n  }\r\n\r\n  /** Return the Maximum absolute value of any single entry */\r\n  public maxAbs(): number {\r\n    let i = 0;\r\n    let a = 0;\r\n    for (i = 0; i < 9; i++)\r\n      a = Math.max(a, Math.abs(this.coffs[i]));\r\n    return a;\r\n  }\r\n\r\n  /** Return the maximum absolute difference between corresponding entries */\r\n  public maxDiff(other: Matrix3d): number {\r\n    let i = 0;\r\n    let a = 0;\r\n    for (i = 0; i < 9; i++)\r\n      a = Math.max(a, Math.abs(this.coffs[i] - other.coffs[i]));\r\n    return a;\r\n  }\r\n\r\n  /** Test if the matrix is (very near to) an identity */\r\n  public get isIdentity(): boolean {\r\n    return this.maxDiff(Matrix3d.identity) < Geometry.smallAngleRadians;\r\n\r\n  }\r\n\r\n  /** Test if the off diagonal entries are all nearly zero */\r\n  public get isDiagonal(): boolean {\r\n    const sumAll = this.sumSquares();\r\n    const sumDiagonal = this.sumDiagonalSquares();\r\n    const sumOff = Math.abs(sumAll - sumDiagonal);\r\n    return Math.sqrt(sumOff) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));\r\n  }\r\n\r\n  /** Test if the below diagonal entries are all nearly zero */\r\n  public get isUpperTriangular(): boolean {\r\n    const sumAll = this.sumSquares();\r\n    const sumLow = Geometry.hypotenuseSquaredXYZ(this.coffs[3], this.coffs[6], this.coffs[7]);\r\n    return Math.sqrt(sumLow) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));\r\n  }\r\n\r\n  /** If the matrix is diagonal and all diagonals are within tolerance, return the first diagonal.  Otherwise return undefined.\r\n   */\r\n  public sameDiagonalScale(): number | undefined {\r\n    const sumAll = this.sumSquares();\r\n    const sumDiagonal = this.sumDiagonalSquares();\r\n    const sumOff = Math.abs(sumAll - sumDiagonal);\r\n    if (Math.sqrt(sumOff) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll))\r\n      && Geometry.isSameCoordinate(this.coffs[0], this.coffs[4]) && Geometry.isSameCoordinate(this.coffs[0], this.coffs[8]))\r\n      return this.coffs[0];\r\n    return undefined;\r\n  }\r\n\r\n  /** Sum of squared differences between symmetric pairs */\r\n  public sumSkewSquares(): number {\r\n    return Geometry.hypotenuseSquaredXYZ(\r\n      this.coffs[1] - this.coffs[3],\r\n      this.coffs[2] - this.coffs[6],\r\n      this.coffs[5] - this.coffs[7]);\r\n  }\r\n\r\n  /** Test if the matrix is a pure rotation. */\r\n  public isRigid(allowMirror: boolean = false): boolean {\r\n    return this.testPerpendicularUnitRowsAndColumns() && (allowMirror || this.determinant() > 0);\r\n  }\r\n  /** Test if all rows and columns are perpendicular to each other and have equal length.\r\n   * If so, the length (or its negative) is the scale factor from a set of rigid axes to these axes.\r\n   * * result.rigidAxes is the rigid axes (with the scale factor removed)\r\n   * * result.scale is the scale factor\r\n   */\r\n  public factorRigidWithSignedScale(): { rigidAxes: Matrix3d, scale: number } | undefined {\r\n    const product = this.multiplyMatrixMatrixTranspose(this);\r\n    const ss = product.sameDiagonalScale();\r\n    if (ss === undefined || ss <= 0.0) return undefined;\r\n    const s = this.determinant() > 0 ? Math.sqrt(ss) : -Math.sqrt(ss);\r\n    const divS = 1.0 / s;\r\n    const result = { rigidAxes: this.scaleColumns(divS, divS, divS), scale: s };\r\n    return result;\r\n  }\r\n\r\n  /** Test if the matrix is shuffles and negates columns. */\r\n  public get isSignedPermutation(): boolean {\r\n    let count = 0;\r\n    for (let row = 0; row < 3; row++)\r\n      for (let col = 0; col < 3; col++) {\r\n        const q = this.at(row, col);\r\n        if (q === 0) {// This comment makes the block non-empty\r\n        } else if (q === 1 || q === -1) {\r\n          // the rest of this row and column should be 0.\r\n          // \"at\" will apply cyclic indexing.\r\n          count++;\r\n          if (this.at(row + 1, col) !== 0)\r\n            return false;\r\n          if (this.at(row + 2, col) !== 0)\r\n            return false;\r\n          if (this.at(row, col + 1) !== 0)\r\n            return false;\r\n          if (this.at(row, col + 2) !== 0)\r\n            return false;\r\n        } else {// entry is not from 0,1,-1 . . .\r\n          return false;\r\n        }\r\n      }\r\n    return count === 3;\r\n  }\r\n\r\n  /** Test if all rows and columns are length 1 and are perpendicular to each other.  (I.e. the matrix is either a pure rotation with uniform scale factor of 1 or -1) */\r\n  public testPerpendicularUnitRowsAndColumns(): boolean {\r\n    const product = this.multiplyMatrixMatrixTranspose(this);\r\n    return product.isIdentity;\r\n  }\r\n  /** create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse)\r\n   * vectorA is placed in the first column of the axis order.\r\n   * vectorB is projected perpendicular to vectorA within their plane and placed in the second column.\r\n   */\r\n  public static createRigidFromColumns(\r\n    vectorA: Vector3d,\r\n    vectorB: Vector3d,\r\n    axisOrder: AxisOrder,\r\n    result?: Matrix3d): Matrix3d | undefined {\r\n    const vectorA1 = vectorA.normalize();\r\n    if (vectorA1) {\r\n      const vectorC1 = vectorA1.unitCrossProduct(vectorB);\r\n      if (vectorC1) {\r\n        const vectorB1 = vectorC1.unitCrossProduct(vectorA);\r\n        if (vectorB1) {\r\n          const retVal = Matrix3d.createShuffledColumns(vectorA1, vectorB1, vectorC1, axisOrder, result);\r\n          retVal.setupInverseTranspose();\r\n          return retVal;\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse)\r\n   * columns are taken from the source Matrix3d in order indicated by the axis order.\r\n   */\r\n  public static createRigidFromMatrix3d(\r\n    source: Matrix3d,\r\n    axisOrder: AxisOrder = AxisOrder.XYZ,\r\n    result?: Matrix3d): Matrix3d | undefined {\r\n    result = source.clone(result);\r\n    result.axisOrderCrossProductsInPlace(axisOrder);\r\n    if (result.normalizeColumnsInPlace())\r\n      return result;\r\n    return undefined;\r\n  }\r\n  private static computeQuatTerm(numerator: number, denomCoff: number, reciprocal: number, diagSum: number): number {\r\n    let coff: number;\r\n    const diagTol = 0.500;\r\n    if (diagSum > diagTol) {\r\n      coff = Math.sqrt(diagSum) * 0.5;\r\n      if (denomCoff * numerator < 0.0)\r\n        coff = - coff;\r\n    } else {\r\n      coff = numerator * reciprocal;\r\n    }\r\n    return coff;\r\n  }\r\n\r\n  /** create a matrix from a quaternion.\r\n   * WARNING: There is frequent confusion over whether a \"from quaternion\" matrix is organized by rows and columns.\r\n   * WARNING: If you find that the matrix seems to rotate by the opposite angle expect it, transpose it.\r\n   */\r\n  public static createFromQuaternion(quat: Point4d): Matrix3d {\r\n\r\n    const qqx = quat.x * quat.x;\r\n    const qqy = quat.y * quat.y;\r\n    const qqz = quat.z * quat.z;\r\n    const qqw = quat.w * quat.w;\r\n\r\n    const mag2 = qqx + qqy + qqz + qqw;\r\n\r\n    if (mag2 === 0.0) {\r\n      return Matrix3d.createIdentity();\r\n    } else {\r\n      const a = 1.0 / mag2;\r\n\r\n      const matrix = Matrix3d.createRowValues(\r\n        a * (qqw + qqx - qqy - qqz), 2.0 * a * (quat.w * quat.z + quat.x * quat.y), 2.0 * a * (quat.x * quat.z - quat.w * quat.y),\r\n        2.0 * a * (quat.x * quat.y - quat.w * quat.z), a * (qqw - qqx + qqy - qqz), 2.0 * a * (quat.w * quat.x + quat.y * quat.z),\r\n        2.0 * a * (quat.x * quat.z + quat.w * quat.y), 2.0 * a * (quat.y * quat.z - quat.w * quat.x), a * (qqw - qqx - qqy + qqz));\r\n      return matrix;\r\n    }\r\n  }\r\n  /** convert the matrix to a quaternion.\r\n   * @note This calculation requires the matrix to have unit length rows and columns.\r\n   * WARNING: There is frequent confusion over whether a \"from quaternion\" matrix is organized by rows and columns.\r\n   * WARNING: If you find that the matrix seems to rotate by the opposite angle expect it, transpose it.\r\n   */\r\n  public toQuaternion(): Point4d {\r\n    const result = Point4d.createZero();\r\n    const props = [[this.coffs[0], this.coffs[3], this.coffs[6]],\r\n    [this.coffs[1], this.coffs[4], this.coffs[7]],\r\n    [this.coffs[2], this.coffs[5], this.coffs[8]]];\r\n\r\n    const xx = props[0][0];\r\n    const yy = props[1][1];\r\n    const zz = props[2][2];\r\n    const dSum: number[] = [];\r\n    let denom: number, maxIndex: number, i: number;\r\n\r\n    dSum[0] = 1.0 + xx - yy - zz;\r\n    dSum[1] = 1.0 - xx + yy - zz;\r\n    dSum[2] = 1.0 - xx - yy + zz;\r\n    dSum[3] = 1.0 + xx + yy + zz;\r\n\r\n    maxIndex = 0;\r\n    for (i = 1; i < 4; i++) {\r\n      if (dSum[i] > dSum[maxIndex])\r\n        maxIndex = i;\r\n    }\r\n\r\n    if (maxIndex === 0) {\r\n      result.x = 0.5 * Math.sqrt(dSum[0]);\r\n      denom = 1.0 / (4.0 * result.x);\r\n      result.y = Matrix3d.computeQuatTerm(props[0][1] + props[1][0], result.x, denom, dSum[1]);\r\n      result.z = Matrix3d.computeQuatTerm(props[0][2] + props[2][0], result.x, denom, dSum[2]);\r\n      result.w = Matrix3d.computeQuatTerm(props[2][1] - props[1][2], result.x, denom, dSum[3]);\r\n    } else if (maxIndex === 1) {\r\n      result.y = 0.5 * Math.sqrt(dSum[1]);\r\n      denom = 1.0 / (4.0 * result.y);\r\n      result.x = Matrix3d.computeQuatTerm(props[0][1] + props[1][0], result.y, denom, dSum[0]);\r\n      result.z = Matrix3d.computeQuatTerm(props[1][2] + props[2][1], result.y, denom, dSum[2]);\r\n      result.w = Matrix3d.computeQuatTerm(props[0][2] - props[2][0], result.y, denom, dSum[3]);\r\n\r\n    } else if (maxIndex === 2) {\r\n      result.z = 0.5 * Math.sqrt(dSum[2]);\r\n      denom = 1.0 / (4.0 * result.z);\r\n      result.x = Matrix3d.computeQuatTerm(props[0][2] + props[2][0], result.z, denom, dSum[0]);\r\n      result.y = Matrix3d.computeQuatTerm(props[1][2] + props[2][1], result.z, denom, dSum[1]);\r\n      result.w = Matrix3d.computeQuatTerm(props[1][0] - props[0][1], result.z, denom, dSum[3]);\r\n\r\n    } else {\r\n      result.w = 0.5 * Math.sqrt(dSum[3]);\r\n      denom = 1.0 / (4.0 * result.w);\r\n      result.x = Matrix3d.computeQuatTerm(props[2][1] - props[1][2], result.w, denom, dSum[0]);\r\n      result.y = Matrix3d.computeQuatTerm(props[0][2] - props[2][0], result.w, denom, dSum[1]);\r\n      result.z = Matrix3d.computeQuatTerm(props[1][0] - props[0][1], result.w, denom, dSum[2]);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { AxisOrder } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\n\r\n/**\r\n * * OrderedRotationAngles represents a non-trivial rotation using three simple axis rotation angles, and an order in which to apply them.\r\n * * This class accommodates application-specific interpretation of \"Multiplying 3 rotation matrices\" with regard to\r\n *   * Whether a \"vector\" is a \"row\" or a \"column\"\r\n *   * The order in which the X,Y, Z rotations are applied.\r\n * * Within the imodel geometry library, the preferred rotation order is encapsulated in `YawPitchRollAngles`.\r\n * @alpha\r\n */\r\nexport class OrderedRotationAngles {\r\n  private _x: Angle;\r\n  private _y: Angle;\r\n  private _z: Angle;\r\n  private _order: AxisOrder;\r\n  private static _sTreatVectorsAsColumns: boolean = false;\r\n\r\n  private constructor(x: Angle, y: Angle, z: Angle, axisOrder: AxisOrder) {\r\n    this._x = x;\r\n    this._y = y;\r\n    this._z = z;\r\n    this._order = axisOrder;\r\n  }\r\n\r\n  /** (Property accessor) Return the `AxisOrder` controlling matrix multiplication order. */\r\n  public get order(): AxisOrder { return this._order; }\r\n  /** (Property accessor) Return the strongly typed angle of rotation around x. */\r\n  public get xAngle(): Angle { return this._x.clone(); }\r\n  /** (Property accessor) Return the strongly typed angle of rotation around y. */\r\n  public get yAngle(): Angle { return this._y.clone(); }\r\n  /** (Property accessor) Return the strongly typed angle of rotation around z. */\r\n  public get zAngle(): Angle { return this._z.clone(); }\r\n  /** (Property accessor) Return the angle of rotation around x, in degrees */\r\n  public get xDegrees(): number { return this._x.degrees; }\r\n  /** (Property accessor) Return the angle of rotation around y, in degrees */\r\n  public get xRadians(): number { return this._x.radians; }\r\n  /** (Property accessor) Return the angle of rotation around z, in degrees */\r\n  public get yDegrees(): number { return this._y.degrees; }\r\n  /** (Property accessor) Return the angle of rotation around x, in radians */\r\n  public get yRadians(): number { return this._y.radians; }\r\n  /** (Property accessor) Return the angle of rotation around y, in radians */\r\n  public get zDegrees(): number { return this._z.degrees; }\r\n  /** (Property accessor) Return the angle of rotation around z, in radians */\r\n  public get zRadians(): number { return this._z.radians; }\r\n  /** (Property accessor) flag controlling whether vectors are treated as rows or as columns */\r\n  public static get treatVectorsAsColumns(): boolean { return OrderedRotationAngles._sTreatVectorsAsColumns; }\r\n  /** (Property set) flag controlling whether vectors are treated as rows or as columns */\r\n  public static set treatVectorsAsColumns(value: boolean) { OrderedRotationAngles._sTreatVectorsAsColumns = value; }\r\n\r\n  /** Create an OrderedRotationAngles from three angles and an ordering in which to apply them when rotating.\r\n   * @param xRotation rotation around x\r\n   * @param yRotation rotation around y\r\n   * @param zRotation rotation around z\r\n   * @param axisOrder right to left order of axis names identifies the order that rotations are applied to xyz data.\r\n   */\r\n  public static createAngles(xRotation: Angle, yRotation: Angle, zRotation: Angle, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles {\r\n    if (result) {\r\n      result._x.setFrom(xRotation);\r\n      result._y.setFrom(yRotation);\r\n      result._z.setFrom(zRotation);\r\n      result._order = order;\r\n      return result;\r\n    }\r\n    return new OrderedRotationAngles(xRotation.clone(), yRotation.clone(), zRotation.clone(), order);\r\n  }\r\n\r\n  /** Create an OrderedRotationAngles from three angles (in radians) and an ordering in which to apply them when rotating. */\r\n  public static createRadians(xRadians: number, yRadians: number, zRadians: number, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles {\r\n    if (result) {\r\n      result._x.setRadians(xRadians);\r\n      result._y.setRadians(yRadians);\r\n      result._z.setRadians(zRadians);\r\n      result._order = order;\r\n      return result;\r\n    }\r\n    return new OrderedRotationAngles(Angle.createRadians(xRadians), Angle.createRadians(yRadians), Angle.createRadians(zRadians), order);\r\n  }\r\n\r\n  /** Create an OrderedRotationAngles from three angles (in degrees) and an ordering in which to apply them when rotating. */\r\n  public static createDegrees(xDegrees: number, yDegrees: number, zDegrees: number, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles {\r\n    if (result) {\r\n      result._x.setDegrees(xDegrees);\r\n      result._y.setDegrees(yDegrees);\r\n      result._z.setDegrees(zDegrees);\r\n      result._order = order;\r\n      return result;\r\n    }\r\n    return new OrderedRotationAngles(Angle.createDegrees(xDegrees), Angle.createDegrees(yDegrees), Angle.createDegrees(zDegrees), order);\r\n  }\r\n\r\n  /** Create an OrderedRotationAngles from a 3x3 rotational matrix, given the ordering of axis rotations that the matrix derives from. */\r\n  public static createFromMatrix3d(matrix: Matrix3d, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles {\r\n\r\n    let m11 = matrix.coffs[0], m12 = matrix.coffs[3], m13 = matrix.coffs[6];\r\n    let m21 = matrix.coffs[1], m22 = matrix.coffs[4], m23 = matrix.coffs[7];\r\n    let m31 = matrix.coffs[2], m32 = matrix.coffs[5], m33 = matrix.coffs[8];\r\n\r\n    if (OrderedRotationAngles.treatVectorsAsColumns) {\r\n      // the formulas are from row order .. flip the mIJ\r\n      m11 = matrix.coffs[0], m12 = matrix.coffs[1], m13 = matrix.coffs[2];\r\n      m21 = matrix.coffs[3], m22 = matrix.coffs[4], m23 = matrix.coffs[5];\r\n      m31 = matrix.coffs[6], m32 = matrix.coffs[7], m33 = matrix.coffs[8];\r\n\r\n    }\r\n\r\n    let xRad: number;\r\n    let yRad: number;\r\n    let zRad: number;\r\n\r\n    switch (order) {\r\n      case AxisOrder.XYZ: {\r\n        yRad = Math.asin(Math.max(-1, Math.min(1, m13)));\r\n\r\n        if (Math.abs(m13) < 0.99999) {\r\n          xRad = Math.atan2(- m23, m33);\r\n          zRad = Math.atan2(- m12, m11);\r\n        } else {\r\n          xRad = Math.atan2(m32, m22);\r\n          zRad = 0;\r\n        }\r\n        break;\r\n      } case AxisOrder.YXZ: {\r\n        xRad = Math.asin(-Math.max(-1, Math.min(1, m23)));\r\n\r\n        if (Math.abs(m23) < 0.99999) {\r\n          yRad = Math.atan2(m13, m33);\r\n          zRad = Math.atan2(m21, m22);\r\n        } else {\r\n          yRad = Math.atan2(-m31, m11);\r\n          zRad = 0;\r\n        }\r\n        break;\r\n      } case AxisOrder.ZXY: {\r\n        xRad = Math.asin(Math.max(-1, Math.min(1, m32)));\r\n\r\n        if (Math.abs(m32) < 0.99999) {\r\n          yRad = Math.atan2(-m31, m33);\r\n          zRad = Math.atan2(-m12, m22);\r\n        } else {\r\n          yRad = 0;\r\n          zRad = Math.atan2(m21, m11);\r\n        }\r\n        break;\r\n      } case AxisOrder.ZYX: {\r\n        yRad = -Math.asin(Math.max(-1, Math.min(1, m31)));\r\n\r\n        if (Math.abs(m31) < 0.99999) {\r\n          xRad = Math.atan2(m32, m33);\r\n          zRad = Math.atan2(m21, m11);\r\n        } else {\r\n          xRad = 0;\r\n          zRad = Math.atan2(-m12, m22);\r\n        }\r\n        break;\r\n      } case AxisOrder.YZX: {\r\n        zRad = Math.asin(Math.max(-1, Math.min(1, m21)));\r\n\r\n        if (Math.abs(m21) < 0.99999) {\r\n          xRad = Math.atan2(-m23, m22);\r\n          yRad = Math.atan2(-m31, m11);\r\n        } else {\r\n          xRad = 0;\r\n          yRad = Math.atan2(m13, m33);\r\n        }\r\n        break;\r\n      } case AxisOrder.XZY: {\r\n        zRad = -Math.asin(Math.max(-1, Math.min(1, m12)));\r\n\r\n        if (Math.abs(m12) < 0.99999) {\r\n          xRad = Math.atan2(m32, m22);\r\n          yRad = Math.atan2(m13, m11);\r\n        } else {\r\n          xRad = Math.atan2(-m23, m33);\r\n          yRad = 0;\r\n        }\r\n        break;\r\n      } default: {\r\n        xRad = yRad = zRad = 0;\r\n      }\r\n    }\r\n    if (OrderedRotationAngles.treatVectorsAsColumns)\r\n      return OrderedRotationAngles.createRadians(-xRad, -yRad, -zRad, order, result);\r\n\r\n    return OrderedRotationAngles.createRadians(xRad, yRad, zRad, order, result);\r\n  }\r\n\r\n  /** Create a 3x3 rotational matrix from this OrderedRotationAngles. */\r\n  public toMatrix3d(result?: Matrix3d): Matrix3d {\r\n    const rot = result !== undefined ? result : new Matrix3d();\r\n    const axisOrder = this.order;\r\n    const x = this.xAngle, y = this.yAngle, z = this.zAngle;\r\n    const a = x.cos(); let b = x.sin();\r\n    const c = y.cos(); let d = y.sin();\r\n    const e = z.cos(); let f = z.sin();\r\n    if (OrderedRotationAngles.treatVectorsAsColumns) {\r\n      b = -b;\r\n      d = -d;\r\n      f = -f;\r\n    }\r\n\r\n    if (axisOrder === AxisOrder.XYZ) {\r\n      const ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n      rot.setRowValues(\r\n        c * e, af + be * d, bf - ae * d,\r\n        -c * f, ae - bf * d, be + af * d,\r\n        d, -b * c, a * c,\r\n      );\r\n    } else if (axisOrder === AxisOrder.YXZ) {\r\n      const ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n      rot.setRowValues(\r\n        ce + df * b, a * f, cf * b - de,\r\n        de * b - cf, a * e, df + ce * b,\r\n        a * d, -b, a * c,\r\n      );\r\n    } else if (axisOrder === AxisOrder.ZXY) {\r\n      const ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n      rot.setRowValues(\r\n        ce - df * b, cf + de * b, -a * d,\r\n        -a * f, a * e, b,\r\n        de + cf * b, df - ce * b, a * c,\r\n      );\r\n    } else if (axisOrder === AxisOrder.ZYX) {\r\n      const ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n      rot.setRowValues(\r\n        c * e, c * f, -d,\r\n        be * d - af, bf * d + ae, b * c,\r\n        ae * d + bf, af * d - be, a * c,\r\n      );\r\n    } else if (axisOrder === AxisOrder.YZX) {\r\n      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n      rot.setRowValues(\r\n        c * e, f, -d * e,\r\n        bd - ac * f, a * e, ad * f + bc,\r\n        bc * f + ad, -b * e, ac - bd * f,\r\n      );\r\n    } else if (axisOrder === AxisOrder.XZY) {\r\n      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n      rot.setRowValues(\r\n        c * e, ac * f + bd, bc * f - ad,\r\n        -f, a * e, b * e,\r\n        d * e, ad * f - bc, bd * f + ac,\r\n      );\r\n    }\r\n    if (OrderedRotationAngles.treatVectorsAsColumns)\r\n      rot.transposeInPlace();\r\n\r\n    return rot;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { BeJSONFunctions, Geometry, AxisOrder, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Angle } from \"./Angle\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\n/**\r\n * A plane defined by\r\n *\r\n * * Any point on the plane.\r\n * * a unit normal.\r\n * @public\r\n */\r\nexport class Plane3dByOriginAndUnitNormal implements BeJSONFunctions, PlaneAltitudeEvaluator {\r\n  private _origin: Point3d;\r\n  private _normal: Vector3d;\r\n  // constructor captures references !!!\r\n  private constructor(origin: Point3d, normal: Vector3d) {\r\n    this._origin = origin;\r\n    this._normal = normal;\r\n  }\r\n  // This is private because it does not check validity of the unit vector.\r\n  private static _create(x: number, y: number, z: number, u: number, v: number, w: number) {\r\n    return new Plane3dByOriginAndUnitNormal(Point3d.create(x, y, z), Vector3d.create(u, v, w));\r\n  }\r\n  /**\r\n   * Create a plane parallel to the XY plane\r\n   * @param origin optional plane origin.  If omitted, the origin is placed at 000\r\n   */\r\n  public static createXYPlane(origin?: Point3d): Plane3dByOriginAndUnitNormal {\r\n    if (origin)\r\n      return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 0, 1);\r\n    return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 0, 1);\r\n  }\r\n  /**\r\n   * Create a plane parallel to the YZ plane\r\n   * @param origin optional plane origin.  If omitted, the origin is placed at 000\r\n   */\r\n  public static createYZPlane(origin?: Point3d): Plane3dByOriginAndUnitNormal {\r\n    if (origin)\r\n      return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 1, 0, 0);\r\n    return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 1, 0, 0);\r\n  }\r\n  /**\r\n   * Create a plane parallel to the ZX plane\r\n   * @param origin optional plane origin.  If omitted, the origin is placed at 000\r\n   */\r\n  public static createZXPlane(origin?: Point3d): Plane3dByOriginAndUnitNormal {\r\n    if (origin)\r\n      return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 1, 0);\r\n    return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 1, 0);\r\n  }\r\n  /** create a new  Plane3dByOriginAndUnitNormal with given origin and normal.\r\n   * * The inputs are NOT captured.\r\n   * * Returns undefined if the normal vector is all zeros.\r\n   */\r\n  public static create(origin: Point3d, normal: Vector3d, result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal | undefined {\r\n    const normalized = normal.normalize();\r\n    if (!normalized)\r\n      return undefined;\r\n    if (result) {\r\n      result.set(origin, normalized);\r\n      return result;\r\n    }\r\n    return new Plane3dByOriginAndUnitNormal(origin.clone(), normalized);\r\n  }\r\n  /** create a new  Plane3dByOriginAndUnitNormal with direct coordinates of origin and normal.\r\n   * * Returns undefined if the normal vector is all zeros.\r\n   * * If unable to normalize return undefined. (And if result is given it is left unchanged)\r\n   */\r\n  public static createXYZUVW(ax: number, ay: number, az: number, ux: number, uy: number, uz: number, result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal | undefined {\r\n    const magU = Geometry.hypotenuseXYZ(ux, uy, uz);\r\n    if (magU < Geometry.smallMetricDistance)\r\n      return undefined;\r\n    if (result) {\r\n      result._origin.set(ax, ay, az);\r\n      result._normal.set(ux / magU, uy / magU, uz / magU);\r\n      return result;\r\n    }\r\n    return new Plane3dByOriginAndUnitNormal(Point3d.create(ax, ay, az), Vector3d.create(ux / magU, uy / magU, uz / magU));\r\n  }\r\n\r\n  /** create a new  Plane3dByOriginAndUnitNormal with xy origin (at z=0) and normal angle in xy plane.\r\n   * * Returns undefined if the normal vector is all zeros.\r\n   */\r\n  public static createXYAngle(x: number, y: number, normalAngleFromX: Angle, result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal {\r\n    if (result) {\r\n      result._origin.set(x, y, 0.0);\r\n      result._normal.set(normalAngleFromX.cos(), normalAngleFromX.sin(), 0.0);\r\n      return result;\r\n    }\r\n    return new Plane3dByOriginAndUnitNormal(Point3d.create(x, y, 0), Vector3d.create(normalAngleFromX.cos(), normalAngleFromX.sin()));\r\n  }\r\n\r\n  /** Create a plane defined by two points and an in-plane vector.\r\n   * @param pointA any point in the plane\r\n   * @param pointB any other point in the plane\r\n   * @param vector any vector in the plane but not parallel to the vector from pointA to pointB\r\n   */\r\n  public static createPointPointVectorInPlane(pointA: Point3d, pointB: Point3d, vector: Vector3d): Plane3dByOriginAndUnitNormal | undefined {\r\n    const cross = vector.crossProductStartEnd(pointA, pointB);\r\n    if (cross.tryNormalizeInPlace())\r\n      return new Plane3dByOriginAndUnitNormal(pointA, cross);\r\n    return undefined;\r\n  }\r\n\r\n  /** test for (toleranced) equality with `other` */\r\n  public isAlmostEqual(other: Plane3dByOriginAndUnitNormal): boolean {\r\n    return this._origin.isAlmostEqual(other._origin) && this._normal.isAlmostEqual(other._normal);\r\n  }\r\n  /** Parse a json fragment `{origin: [x,y,z], normal: [ux,uy,uz]}`  */\r\n  public setFromJSON(json?: any) {\r\n    if (!json) {\r\n      this._origin.set(0, 0, 0);\r\n      this._normal.set(0, 0, 1);\r\n    } else {\r\n      this._origin.setFromJSON(json.origin);\r\n      this._normal.setFromJSON(json.normal);\r\n    }\r\n  }\r\n  /**\r\n   * Convert to a JSON object.\r\n   * @return {*} [origin,normal]\r\n   */\r\n  public toJSON(): any { return { origin: this._origin.toJSON(), normal: this._normal.toJSON() }; }\r\n  /**  create a new Plane3dByOriginAndUnitNormal from json fragment.\r\n   * * See `Plane3dByOriginAndUnitNormal.setFromJSON`\r\n   */\r\n  public static fromJSON(json?: any): Plane3dByOriginAndUnitNormal {\r\n    const result = Plane3dByOriginAndUnitNormal.createXYPlane();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Return a reference to the origin. */\r\n  public getOriginRef(): Point3d { return this._origin; }\r\n  /** Return a reference to the unit normal. */\r\n  public getNormalRef(): Vector3d { return this._normal; }\r\n\r\n  /** Return coordinate axes (as a transform) with\r\n   * * origin at plane origin\r\n   * * z axis in direction of plane normal.\r\n   * * x,y axes in plane.\r\n   */\r\n  public getLocalToWorld(): Transform {\r\n    const axes = Matrix3d.createRigidHeadsUp(this._normal, AxisOrder.ZXY);\r\n    return Transform.createRefs(this._origin.clone(), axes);\r\n  }\r\n  /** Return a (singular) transform which projects points to this plane.\r\n   */\r\n  public getProjectionToPlane(): Transform {\r\n    const axes = Matrix3d.createIdentity();\r\n    axes.addScaledOuterProductInPlace(this._normal, this._normal, -1.0);\r\n    axes.markSingular();\r\n    return Transform.createFixedPointAndMatrix(this._origin, axes);\r\n  }\r\n\r\n  /** Copy coordinates from the given origin and normal. */\r\n  public set(origin: Point3d, normal: Vector3d): void {\r\n    this._origin.setFrom(origin);\r\n    this._normal.setFrom(normal);\r\n  }\r\n  /** return a deep clone (point and normal cloned) */\r\n  public clone(result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal {\r\n    if (result) {\r\n      result.set(this._origin, this._normal);\r\n      return result;\r\n    }\r\n    return new Plane3dByOriginAndUnitNormal(this._origin.clone(), this._normal.clone());\r\n  }\r\n  /** Create a clone and return the transform of the clone. */\r\n  public cloneTransformed(transform: Transform): Plane3dByOriginAndUnitNormal | undefined {\r\n    const result = this.clone();\r\n    transform.multiplyPoint3d(result._origin, result._origin);\r\n    if (transform.matrix.multiplyInverseTranspose(result._normal, result._normal) !== undefined\r\n      && result._normal.normalizeInPlace())\r\n      return result;\r\n    return undefined;\r\n  }\r\n  /** Copy data from the given plane. */\r\n  public setFrom(source: Plane3dByOriginAndUnitNormal): void {\r\n    this.set(source._origin, source._normal);\r\n  }\r\n  /** Return the altitude of spacePoint above or below the plane.  (Below is negative) */\r\n  public altitude(spacePoint: Point3d): number { return this._normal.dotProductStartEnd(this._origin, spacePoint); }\r\n\r\n  /** Return the altitude of weighted spacePoint above or below the plane.  (Below is negative) */\r\n  public weightedAltitude(spacePoint: Point4d): number {\r\n    return this._normal.dotProductStart3dEnd4d(this._origin, spacePoint);\r\n  }\r\n\r\n  /** return a point at specified (signed) altitude */\r\n  public altitudeToPoint(altitude: number, result?: Point3d): Point3d {\r\n    return this._origin.plusScaled(this._normal, altitude, result);\r\n  }\r\n  /** Return the dot product of spaceVector with the plane's unit normal.  This tells the rate of change of altitude\r\n   * for a point moving at speed one along the spaceVector.\r\n   */\r\n  public velocityXYZ(x: number, y: number, z: number): number { return this._normal.dotProductXYZ(x, y, z); }\r\n  /** Return the dot product of spaceVector with the plane's unit normal.  This tells the rate of change of altitude\r\n   * for a point moving at speed one along the spaceVector.\r\n   */\r\n  public velocity(spaceVector: Vector3d): number { return this._normal.dotProduct(spaceVector); }\r\n  /** Return the altitude of a point given as separate x,y,z components. */\r\n  public altitudeXYZ(x: number, y: number, z: number): number {\r\n    return this._normal.dotProductStartEndXYZ(this._origin, x, y, z);\r\n  }\r\n  /** Return the altitude of a point given as separate x,y,z,w components. */\r\n  public altitudeXYZW(x: number, y: number, z: number, w: number): number {\r\n    return this._normal.dotProductStartEndXYZW(this._origin, x, y, z, w);\r\n  }\r\n  /** Return the projection of spacePoint onto the plane. */\r\n  public projectPointToPlane(spacePoint: Point3d, result?: Point3d): Point3d {\r\n    return spacePoint.plusScaled(this._normal, -this._normal.dotProductStartEnd(this._origin, spacePoint), result);\r\n  }\r\n  /** Returns true of spacePoint is within distance tolerance of the plane. */\r\n  public isPointInPlane(spacePoint: Point3d): boolean { return Geometry.isSmallMetricDistance(this.altitude(spacePoint)); }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { BeJSONFunctions, Geometry } from \"../Geometry\";\r\nimport { Transform } from \"./Transform\";\r\n/**\r\n * A Point3dVector3dVector3d is an origin and a pair of vectors.\r\n * This defines a plane with a (possibly skewed) uv coordinate grid\r\n * * The grid directions (`vectorU` and `vectorV`)\r\n *   * are NOT required to be unit vectors.\r\n *   * are NOT required to be perpendicular vectors.\r\n * @public\r\n */\r\nexport class Plane3dByOriginAndVectors implements BeJSONFunctions {\r\n  /** origin of plane grid */\r\n  public origin: Point3d;\r\n  /** u direction in plane grid */\r\n  public vectorU: Vector3d;\r\n  /** v direction in plane grid */\r\n  public vectorV: Vector3d;\r\n  private constructor(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d) {\r\n    this.origin = origin;\r\n    this.vectorU = vectorU;\r\n    this.vectorV = vectorV;\r\n  }\r\n  /** create a new plane from origin and vectors. */\r\n  public static createOriginAndVectors(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    if (result) {\r\n      result.origin.setFrom(origin);\r\n      result.vectorU.setFrom(vectorU);\r\n      result.vectorV.setFrom(vectorV);\r\n      return result;\r\n    }\r\n    return new Plane3dByOriginAndVectors(origin.clone(), vectorU.clone(), vectorV.clone());\r\n  }\r\n  /**\r\n   * Return a Plane3dByOriginAndVectors, with\r\n   * * origin is the translation (aka origin) from the Transform\r\n   * * vectorU is the X column of the transform\r\n   * * vectorV is the Y column of the transform.\r\n   * @param transform source transform\r\n   * @param xLength optional length to impose on vectorU.\r\n   * @param yLength optional length to impose on vectorV.\r\n   * @param result optional preexisting result\r\n   */\r\n  public static createFromTransformColumnsXYAndLengths(transform: Transform,\r\n    xLength: number | undefined, yLength: number | undefined,\r\n    result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    if (result) {\r\n      result.origin.setFrom(transform.getOrigin());\r\n      transform.matrix.columnX(result.vectorU);\r\n      transform.matrix.columnY(result.vectorV);\r\n    } else {\r\n      result = new Plane3dByOriginAndVectors(\r\n        transform.getOrigin(),\r\n        transform.matrix.columnX(),\r\n        transform.matrix.columnY());\r\n    }\r\n    if (xLength !== undefined)\r\n      result.vectorU.scaleToLength(xLength, result.vectorU);\r\n    if (yLength !== undefined)\r\n      result.vectorV.scaleToLength(yLength, result.vectorV);\r\n    return result;\r\n  }\r\n  /** Capture origin and directions in a new plane. */\r\n  public static createCapture(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    if (!result)\r\n      return new Plane3dByOriginAndVectors(origin, vectorU, vectorV);\r\n    result.origin = origin;\r\n    result.vectorU = vectorU;\r\n    result.vectorV = vectorV;\r\n    return result;\r\n  }\r\n\r\n  /** Set all origin and both vectors from direct numeric parameters */\r\n  public setOriginAndVectorsXYZ(x0: number, y0: number, z0: number, ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): Plane3dByOriginAndVectors {\r\n    this.origin.set(x0, y0, z0);\r\n    this.vectorU.set(ux, uy, uz);\r\n    this.vectorV.set(vx, vy, vz);\r\n    return this;\r\n  }\r\n  /** Set all origin and both vectors from coordinates in given origin and vectors.\r\n   * * Note that coordinates are copied out of the parameters -- the given parameters are NOT retained by reference.\r\n   */\r\n  public setOriginAndVectors(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d): Plane3dByOriginAndVectors {\r\n    this.origin.setFrom(origin);\r\n    this.vectorU.setFrom(vectorU);\r\n    this.vectorV.setFrom(vectorV);\r\n    return this;\r\n  }\r\n  /** Create a new plane from direct numeric parameters */\r\n  public static createOriginAndVectorsXYZ(x0: number, y0: number, z0: number, ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    if (result)\r\n      return result.setOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz);\r\n    return new Plane3dByOriginAndVectors(Point3d.create(x0, y0, z0), Vector3d.create(ux, uy, uz), Vector3d.create(vx, vy, vz));\r\n  }\r\n  /** Define a plane by three points in the plane.\r\n   * @param origin origin for the parameterization.\r\n   * @param targetU target point for the vectorU starting at the origin.\r\n   * @param targetV target point for the vectorV originating at the origin.\r\n   * @param result optional result.\r\n   */\r\n  public static createOriginAndTargets(origin: Point3d, targetU: Point3d, targetV: Point3d, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin.x, origin.y, origin.z, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, result);\r\n  }\r\n  /** Create a plane with origin at 000, unit vectorU in x direction, and unit vectorV in the y direction. */\r\n  public static createXYPlane(result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(0, 0, 0, 1, 0, 0, 0, 1, 0, result);\r\n  }\r\n  /** create a plane from data presented as Float64Arrays.\r\n   * @param origin x,y,z of origin.\r\n   * @param vectorU x,y,z of vectorU\r\n   * @param vectorV x,y,z of vectorV\r\n   */\r\n  public static createOriginAndVectorsArrays(origin: Float64Array, vectorU: Float64Array, vectorV: Float64Array, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin[0], origin[1], origin[2], vectorU[0], vectorU[1], vectorU[2], vectorV[0], vectorV[1], vectorV[2], result);\r\n  }\r\n  /** create a plane from data presented as Float64Array with weights\r\n   * @param origin x,y,z,w of origin.\r\n   * @param vectorU x,y,z,w of vectorU\r\n   * @param vectorV x,y,z,w of vectorV\r\n   */\r\n  public static createOriginAndVectorsWeightedArrays(originW: Float64Array, vectorUw: Float64Array, vectorVw: Float64Array, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const w = originW[3];\r\n    result = Plane3dByOriginAndVectors.createXYPlane(result);\r\n    if (Geometry.isSmallMetricDistance(w))\r\n      return result;\r\n    const dw = 1.0 / w;\r\n    const au = vectorUw[3] * dw * dw;\r\n    const av = vectorVw[3] * dw * dw;\r\n    // for homogeneous function X, with w its weight:\r\n    // (X/w) is the cartesian point.\r\n    // (X/w)' = (X' w - X w')/(w*w)\r\n    //        = X'/w  - (X/w)(w'/w)\r\n    //        = X'/w  - X w'/w^2)\r\n    // The w parts of the formal xyzw sums are identically 0.\r\n    // Here the X' and its w' are taken from each vectorUw and vectorVw\r\n    result.origin.set(originW[0] * dw, originW[1] * dw, originW[2] * dw);\r\n    Vector3d.createAdd2ScaledXYZ(vectorUw[0], vectorUw[1], vectorUw[2], dw, originW[0], originW[1], originW[2], -au, result.vectorU);\r\n    Vector3d.createAdd2ScaledXYZ(vectorVw[0], vectorVw[1], vectorVw[2], dw, originW[0], originW[1], originW[2], -av, result.vectorV);\r\n    return result;\r\n  }\r\n  /**\r\n   * Evaluate a point a grid coordinates on the plane.\r\n   * * The computed point is `origin + vectorU * u + vectorV * v`\r\n   * @param u coordinate along vectorU\r\n   * @param v coordinate along vectorV\r\n   * @param result optional result destination.\r\n   * @returns Return the computed coordinate.\r\n   */\r\n  public fractionToPoint(u: number, v: number, result?: Point3d): Point3d {\r\n    return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);\r\n  }\r\n  /** Return the vector from the plane origin to parametric coordinate (u.v) */\r\n  public fractionToVector(u: number, v: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.createAdd2Scaled(this.vectorU, u, this.vectorV, v, result);\r\n  }\r\n  /** Set coordinates from a json object such as `{origin: [1,2,3], vectorU:[4,5,6], vectorV[3,2,1]}` */\r\n  public setFromJSON(json?: any) {\r\n    if (!json || !json.origin || !json.vectorV) {\r\n      this.origin.set(0, 0, 0);\r\n      this.vectorU.set(1, 0, 0);\r\n      this.vectorV.set(0, 1, 0);\r\n    } else {\r\n      this.origin.setFromJSON(json.origin);\r\n      this.vectorU.setFromJSON(json.vectorU);\r\n      this.vectorV.setFromJSON(json.vectorV);\r\n    }\r\n  }\r\n  /**\r\n   * Convert an Angle to a JSON object.\r\n   * @return {*} [origin,normal]\r\n   */\r\n  public toJSON(): any {\r\n    return {\r\n      origin: this.origin.toJSON(),\r\n      vectorU: this.vectorU.toJSON(),\r\n      vectorV: this.vectorV.toJSON(),\r\n    };\r\n  }\r\n  /** create a new plane.   See `setFromJSON` for layout example. */\r\n  public static fromJSON(json?: any): Plane3dByOriginAndVectors {\r\n    const result = Plane3dByOriginAndVectors.createXYPlane();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Test origin and vectors for isAlmostEqual with `other` */\r\n  public isAlmostEqual(other: Plane3dByOriginAndVectors): boolean {\r\n    return this.origin.isAlmostEqual(other.origin)\r\n      && this.vectorU.isAlmostEqual(other.vectorU)\r\n      && this.vectorV.isAlmostEqual(other.vectorV);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module CartesianGeometry */\r\n\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { Point2d, Vector2d, XY } from \"./Point2dVector2d\";\r\nimport { XAndY } from \"./XYZProps\";\r\nimport { IndexedXYCollection } from \"./IndexedXYCollection\";\r\n\r\n/**\r\n * Helper object to access members of a Point2d[] in geometric calculations.\r\n * * The collection holds only a reference to the actual array.\r\n * * The actual array may be replaced by the user as needed.\r\n * * When replaced, there is no cached data to be updated.\r\n * @public\r\n*/\r\nexport class Point2dArrayCarrier extends IndexedXYCollection {\r\n  /** reference to array being queried. */\r\n  public data: Point2d[];\r\n  /** CAPTURE caller supplied array ... */\r\n  public constructor(data: Point2d[]) {\r\n    super();\r\n    this.data = data;\r\n  }\r\n  /** test if index is valid  */\r\n  public isValidIndex(index: number): boolean {\r\n    return index >= 0 && index < this.data.length;\r\n  }\r\n  /**\r\n   * Access by index, returning strongly typed Point2d\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public getPoint2dAtCheckedPointIndex(index: number, result?: Point2d): Point2d | undefined {\r\n    if (this.isValidIndex(index)) {\r\n      const source = this.data[index];\r\n      return Point2d.create(source.x, source.y, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Access by index, returning strongly typed Vector2d\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public getVector2dAtCheckedVectorIndex(index: number, result?: Vector2d): Vector2d | undefined {\r\n    if (this.isValidIndex(index)) {\r\n      const source = this.data[index];\r\n      return Vector2d.create(source.x, source.y, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a vector from the point at indexA to the point at indexB\r\n   * @param indexA index of point within the array\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public vectorIndexIndex(indexA: number, indexB: number, result?: Vector2d): Vector2d | undefined {\r\n    if (this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return Vector2d.createStartEnd(this.data[indexA], this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a vector from given origin to point at indexB\r\n   * @param origin origin for vector\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if index is out of bounds\r\n   */\r\n  public vectorXAndYIndex(origin: XAndY, indexB: number, result?: Vector2d): Vector2d | undefined {\r\n    if (this.isValidIndex(indexB))\r\n      return Vector2d.createStartEnd(origin, this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Return the cross product of vectors from origin to points at indexA and indexB\r\n   * @param origin origin for vector\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public crossProductXAndYIndexIndex(origin: XAndY, indexA: number, indexB: number): number | undefined {\r\n    if (this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return XY.crossProductToPoints(origin, this.data[indexA], this.data[indexB]);\r\n    return undefined;\r\n  }\r\n  /**\r\n * Return the cross product of vectors from point at originIndex to points at indexA and indexB\r\n * @param originIndex index of origin\r\n * @param indexA index of first target within the array\r\n * @param indexB index of second target within the array\r\n * @param result caller-allocated vector.\r\n * @returns return true if indexA, indexB both valid\r\n */\r\n  public crossProductIndexIndexIndex(originIndex: number, indexA: number, indexB: number): number | undefined {\r\n    if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return XY.crossProductToPoints(this.data[originIndex], this.data[indexA], this.data[indexB]);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * read-only property for number of XYZ in the collection.\r\n   */\r\n  public get length(): number {\r\n    return this.data.length;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n// cspell:word JSONXY\r\n// cspell:word CWXY\r\n\r\nimport { Geometry, BeJSONFunctions } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\nimport { XAndY, XYProps } from \"./XYZProps\";\r\n\r\n/** Minimal object containing x,y and operations that are meaningful without change in both point and vector.\r\n *  * `XY` is not instantiable.\r\n *  * The derived (instantiable) classes are\r\n *    * `Point2d`\r\n *    * `Vector2d`\r\n * @public\r\n */\r\nexport class XY implements XAndY {\r\n  /** x component */\r\n  public x: number;\r\n  /** y component */\r\n  public y: number;\r\n  /** Set both x and y. */\r\n  public set(x: number = 0, y: number = 0) { this.x = x; this.y = y; }\r\n  /** Set both x and y to zero */\r\n  public setZero() { this.x = 0; this.y = 0; }\r\n  protected constructor(x: number = 0, y: number = 0) { this.x = x; this.y = y; }\r\n  /** Set both x and y from other. */\r\n  public setFrom(other?: XAndY) {\r\n    if (other) {\r\n      this.x = other.x; this.y = other.y;\r\n    } else {\r\n      this.x = 0; this.y = 0;\r\n    }\r\n  }\r\n  /** Freeze this instance (and its deep content) so it can be considered read-only */\r\n  public freeze() { Object.freeze(this); }\r\n\r\n  /** Returns true if this and other have equal x,y parts within Geometry.smallMetricDistance. */\r\n  public isAlmostEqual(other: XAndY, tol?: number): boolean { return Geometry.isSameCoordinate(this.x, other.x, tol) && Geometry.isSameCoordinate(this.y, other.y, tol); }\r\n\r\n  /** Returns true if this and other have equal x,y parts within Geometry.smallMetricDistance. */\r\n  public isAlmostEqualXY(x: number, y: number, tol?: number): boolean { return Geometry.isSameCoordinate(this.x, x, tol) && Geometry.isSameCoordinate(this.y, y, tol); }\r\n\r\n  /** return a json array  `[x,y]`   */\r\n  public toJSON(): XYProps { return [this.x, this.y]; }\r\n  /** return a json object `{x: 1, y:2}`  */\r\n  public toJSONXY(): XYProps { return { x: this.x, y: this.y }; }\r\n  /** Set x and y from a JSON source such as `[1,2]` or `{x:1, y:2}` */\r\n  public setFromJSON(json?: XYProps): void {\r\n    if (Array.isArray(json)) {\r\n      this.set(json[0] || 0, json[1] || 0);\r\n      return;\r\n    }\r\n    if (json) {\r\n      this.set(json.x || 0, json.y || 0);\r\n      return;\r\n    }\r\n    this.set(0, 0);\r\n  }\r\n\r\n  /** Return the distance from this point to other */\r\n  public distance(other: XAndY): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    return (Math.sqrt(xDist * xDist + yDist * yDist));\r\n  }\r\n\r\n  /** Return squared distance from this point to other */\r\n  public distanceSquared(other: XAndY): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    return (xDist * xDist + yDist * yDist);\r\n  }\r\n\r\n  /** Return the largest absolute distance between corresponding components */\r\n  public maxDiff(other: XAndY): number {\r\n    return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y));\r\n  }\r\n  /** returns true if the x,y components are both small by metric metric tolerance */\r\n  public get isAlmostZero(): boolean {\r\n    return Geometry.isSmallMetricDistance(this.x) && Geometry.isSmallMetricDistance(this.y);\r\n  }\r\n\r\n  /** Return the largest absolute value of any component */\r\n  public maxAbs(): number { return Math.max(Math.abs(this.x), Math.abs(this.y)); }\r\n  /** Return the magnitude of the vector */\r\n  public magnitude(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }\r\n  /** Return the squared magnitude of the vector.  */\r\n  public magnitudeSquared(): number { return this.x * this.x + this.y * this.y; }\r\n\r\n  /** returns true if the x,y components are exactly equal. */\r\n  public isExactEqual(other: XAndY): boolean { return this.x === other.x && this.y === other.y; }\r\n  /** returns true if x,y match `other` within metric tolerance */\r\n  public isAlmostEqualMetric(other: XAndY): boolean { return this.maxDiff(other) <= Geometry.smallMetricDistance; }\r\n\r\n  /** Return a (full length) vector from this point to other */\r\n  public vectorTo(other: XAndY, result?: Vector2d): Vector2d {\r\n    return Vector2d.create(\r\n      other.x - this.x,\r\n      other.y - this.y,\r\n      result);\r\n  }\r\n  /** Return a unit vector from this point to other */\r\n  public unitVectorTo(target: XAndY, result?: Vector2d): Vector2d | undefined {\r\n    return this.vectorTo(target, result).normalize(result);\r\n  }\r\n  /** cross product of vectors from origin to targets */\r\n  public static crossProductToPoints(origin: XAndY, targetA: XAndY, targetB: XAndY): number {\r\n    return Geometry.crossProductXYXY(\r\n      targetA.x - origin.x, targetA.y - origin.y, targetB.x - origin.x, targetB.y - origin.y);\r\n  }\r\n}\r\n/** 2D point with `x`,`y` as properties\r\n * @public\r\n */\r\nexport class Point2d extends XY implements BeJSONFunctions {\r\n  /** Constructor for Point2d */\r\n  constructor(x: number = 0, y: number = 0) { super(x, y); }\r\n  /** return a new Point2d with x,y coordinates from this. */\r\n  public clone(): Point2d { return new Point2d(this.x, this.y); }\r\n\r\n  /**\r\n   * Return a point (newly created unless result provided) with given x,y coordinates\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param result optional result\r\n   */\r\n  public static create(x: number = 0, y: number = 0, result?: Point2d): Point2d {\r\n    if (result) {\r\n      result.x = x;\r\n      result.y = y;\r\n      return result;\r\n    }\r\n    return new Point2d(x, y);\r\n  }\r\n  /** Convert JSON `[1,2]` or `{x:1, y:2}` to a Point2d instance */\r\n  public static fromJSON(json?: XYProps): Point2d { const val = new Point2d(); val.setFromJSON(json); return val; }\r\n  /** Create (or optionally reuse) a Point2d from another object with fields x and y */\r\n  public static createFrom(xy: XAndY | undefined, result?: Point2d): Point2d {\r\n    if (xy)\r\n      return Point2d.create(xy.x, xy.y, result);\r\n    return Point2d.create(0, 0, result);\r\n  }\r\n  /** Create a Point2d with both coordinates zero. */\r\n  public static createZero(result?: Point2d): Point2d { return Point2d.create(0, 0, result); }\r\n  /** Starting at this point, move along vector by tangentFraction of the vector length, and to the left by leftFraction of\r\n   * the perpendicular vector length.\r\n   * @param tangentFraction distance to move along the vector, as a fraction of vector\r\n   * @param leftFraction distance to move perpendicular to the vector, as a fraction of the rotated vector\r\n   */\r\n  public addForwardLeft(tangentFraction: number, leftFraction: number, vector: Vector2d): Point2d {\r\n    const dx = vector.x;\r\n    const dy = vector.y;\r\n    return Point2d.create(this.x + tangentFraction * dx - leftFraction * dy,\r\n      this.y + tangentFraction * dy + leftFraction * dx);\r\n  }\r\n  /** Interpolate at tangentFraction between this instance and point.   Move by leftFraction along the xy perpendicular\r\n   * of the vector between the points.\r\n   */\r\n  public forwardLeftInterpolate(tangentFraction: number, leftFraction: number, point: XAndY): Point2d {\r\n    const dx = point.x - this.x;\r\n    const dy = point.y - this.y;\r\n    return Point2d.create(\r\n      this.x + tangentFraction * dx - leftFraction * dy,\r\n      this.y + tangentFraction * dy + leftFraction * dx);\r\n  }\r\n\r\n  /** Return a point interpolated between this point and the right param. */\r\n  public interpolate(fraction: number, other: XAndY, result?: Point2d): Point2d {\r\n    if (fraction <= 0.5)\r\n      return Point2d.create(\r\n        this.x + fraction * (other.x - this.x),\r\n        this.y + fraction * (other.y - this.y),\r\n        result);\r\n    const t: number = fraction - 1.0;\r\n    return Point2d.create(\r\n      other.x + t * (other.x - this.x),\r\n      other.y + t * (other.y - this.y),\r\n      result);\r\n  }\r\n\r\n  /** Return a point with independent x,y fractional interpolation. */\r\n  public interpolateXY(fractionX: number, fractionY: number, other: XAndY, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      Geometry.interpolate(this.x, fractionX, other.x),\r\n      Geometry.interpolate(this.y, fractionY, other.y),\r\n      result);\r\n  }\r\n\r\n  /** Return this point minus vector */\r\n  public minus(vector: XAndY, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x - vector.x,\r\n      this.y - vector.y,\r\n      result);\r\n  }\r\n\r\n  /** Return point plus vector */\r\n  public plus(vector: XAndY, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x + vector.x,\r\n      this.y + vector.y,\r\n      result);\r\n  }\r\n  /** Return point plus vector */\r\n  public plusXY(dx: number = 0, dy: number = 0, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x + dx,\r\n      this.y + dy, result);\r\n  }\r\n\r\n  /** Return point + vector * scalar */\r\n  public plusScaled(vector: XAndY, scaleFactor: number, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x + vector.x * scaleFactor,\r\n      this.y + vector.y * scaleFactor,\r\n      result);\r\n  }\r\n\r\n  /** Return point + vectorA * scalarA + vectorB * scalarB */\r\n  public plus2Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x + vectorA.x * scalarA + vectorB.x * scalarB,\r\n      this.y + vectorA.y * scalarA + vectorB.y * scalarB,\r\n      result);\r\n  }\r\n\r\n  /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */\r\n  public plus3Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, vectorC: XAndY, scalarC: number, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC,\r\n      this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC,\r\n      result);\r\n  }\r\n  /**\r\n   * Return the dot product of vector from this to targetA and vector from this to targetB\r\n   * @param targetA target of first vector\r\n   * @param targetB target of second vector\r\n   */\r\n  public dotVectorsToTargets(targetA: XAndY, targetB: XAndY): number {\r\n    return (targetA.x - this.x) * (targetB.x - this.x) +\r\n      (targetA.y - this.y) * (targetB.y - this.y);\r\n  }\r\n\r\n  /** Returns the (scalar) cross product of two points/vectors, computed from origin to target1 and target2 */\r\n  public crossProductToPoints(target1: XAndY, target2: XAndY): number {\r\n    const x1 = target1.x - this.x;\r\n    const y1 = target1.y - this.y;\r\n    const x2 = target2.x - this.x;\r\n    const y2 = target2.y - this.y;\r\n    return x1 * y2 - y1 * x2;\r\n  }\r\n  /** Return the fractional coordinate of the projection of this instance x,y onto the line from startPoint to endPoint.\r\n   * @param startPoint start point of line\r\n   * @param endPoint end point of line\r\n   * @param defaultFraction fraction to return if startPoint and endPoint are equal.\r\n   */\r\n  public fractionOfProjectionToLine(startPoint: Point2d, endPoint: Point2d, defaultFraction?: number): number {\r\n    const denominator = startPoint.distanceSquared(endPoint);\r\n    if (denominator < Geometry.smallMetricDistanceSquared)\r\n      return defaultFraction ? defaultFraction : 0;\r\n    return startPoint.dotVectorsToTargets(endPoint, this) / denominator;\r\n  }\r\n}\r\n/** 2D vector with `x`,`y` as properties\r\n * @public\r\n */\r\nexport class Vector2d extends XY implements BeJSONFunctions {\r\n  constructor(x: number = 0, y: number = 0) { super(x, y); }\r\n  /** Return a new Vector2d with the same x,y */\r\n  public clone(): Vector2d { return new Vector2d(this.x, this.y); }\r\n  /** Return a new Vector2d with given x and y */\r\n  public static create(x: number = 0, y: number = 0, result?: Vector2d): Vector2d {\r\n    if (result) {\r\n      result.x = x;\r\n      result.y = y;\r\n      return result;\r\n    }\r\n    return new Vector2d(x, y);\r\n  }\r\n\r\n  /** Return a (new) Vector2d with components 1,0 */\r\n  public static unitX(scale: number = 1): Vector2d { return new Vector2d(scale, 0); }\r\n\r\n  /** Return a (new) Vector2d with components 0,1 */\r\n  public static unitY(scale: number = 1): Vector2d { return new Vector2d(0, scale); }\r\n\r\n  /** Return a Vector2d with components 0,0 */\r\n  public static createZero(result?: Vector2d): Vector2d { return Vector2d.create(0, 0, result); }\r\n\r\n  /** copy contents from another Point3d, Point2d, Vector2d, or Vector3d, or leading entries of Float64Array */\r\n  public static createFrom(data: XAndY | Float64Array, result?: Vector2d): Vector2d {\r\n    if (data instanceof Float64Array) {\r\n      if (data.length >= 2)\r\n        return Vector2d.create(data[0], data[1]);\r\n      if (data.length >= 1)\r\n        return Vector2d.create(data[0], 0);\r\n      return Vector2d.create(0, 0);\r\n    }\r\n    return Vector2d.create(data.x, data.y, result);\r\n  }\r\n  /** Return a new Vector2d from json structured as `[1,2]` or `{x:1,y:2}` */\r\n  public static fromJSON(json?: XYProps): Vector2d { const val = new Vector2d(); val.setFromJSON(json); return val; }\r\n  /** Return a new Vector2d from polar coordinates for radius and Angle from x axis */\r\n  public static createPolar(r: number, theta: Angle): Vector2d {\r\n    return Vector2d.create(r * theta.cos(), r * theta.sin());\r\n  }\r\n  /** Return a new Vector2d extending from point0 to point1 */\r\n  public static createStartEnd(point0: XAndY, point1: XAndY, result?: Vector2d): Vector2d {\r\n    return Vector2d.create (point1.x - point0.x, point1.y - point0.y, result);\r\n  }\r\n  /**\r\n   * Return a vector that bisects the angle between two normals and extends to the intersection of two offset lines\r\n   * @param unitPerpA unit perpendicular to incoming direction\r\n   * @param unitPerpB  unit perpendicular to outgoing direction\r\n   * @param offset offset distance\r\n   */\r\n  public static createOffsetBisector(unitPerpA: Vector2d, unitPerpB: Vector2d, offset: number): Vector2d | undefined {\r\n    let bisector: Vector2d | undefined = unitPerpA.plus(unitPerpB);\r\n    bisector = bisector.normalize();\r\n    if (bisector) {\r\n      const c = offset * bisector.dotProduct(unitPerpA);\r\n      return bisector.safeDivideOrNull(c);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Return a (new or optionally reused) vector which is `this` divided by denominator\r\n   * * return undefined if denominator is zero.\r\n   */\r\n  public safeDivideOrNull(denominator: number, result?: Vector2d): Vector2d | undefined {\r\n    if (denominator !== 0.0) {\r\n      return this.scale(1.0 / denominator, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return a unit vector in direction of this instance (undefined if this instance has near zero length) */\r\n  public normalize(result?: Vector2d): Vector2d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.magnitude());\r\n    result = result ? result : new Vector2d();\r\n    return this.safeDivideOrNull(mag, result);\r\n  }\r\n\r\n  /** return the fractional projection of spaceVector onto this */\r\n  public fractionOfProjectionToVector(target: Vector2d, defaultFraction?: number): number {\r\n    const numerator = this.dotProduct(target);\r\n    const denominator = target.magnitudeSquared();\r\n    if (denominator < Geometry.smallMetricDistanceSquared)\r\n      return defaultFraction ? defaultFraction : 0;\r\n    return numerator / denominator;\r\n  }\r\n\r\n  /** Return a new vector with components negated from this instance. */\r\n  public negate(result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = -this.x;\r\n    result.y = -this.y;\r\n    return result;\r\n  }\r\n\r\n  /** Return a vector same length as this but rotated 90 degrees counter clockwise */\r\n  public rotate90CCWXY(result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    // save x,y to allow aliasing ..\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result.x = -yy;\r\n    result.y = xx;\r\n    return result;\r\n  }\r\n\r\n  /** Return a vector same length as this but rotated 90 degrees clockwise */\r\n  public rotate90CWXY(result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    // save x,y to allow aliasing ..\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result.x = yy;\r\n    result.y = -xx;\r\n    return result;\r\n  }\r\n  /** Return a unit vector perpendicular to this instance. */\r\n  public unitPerpendicularXY(result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result.x = -yy;\r\n    result.y = xx;\r\n    const d2: number = xx * xx + yy * yy;\r\n    if (d2 !== 0.0) {\r\n      const a = 1.0 / Math.sqrt(d2);\r\n      result.x *= a;\r\n      result.y *= a;\r\n    }\r\n    return result;\r\n  }\r\n  /** return a new Vector2d rotated CCW by given angle */\r\n  public rotateXY(angle: Angle, result?: Vector2d): Vector2d {\r\n    const s = angle.sin();\r\n    const c = angle.cos();\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result = result ? result : new Vector2d();\r\n    result.x = xx * c - yy * s;\r\n    result.y = xx * s + yy * c;\r\n    return result;\r\n  }\r\n\r\n  /** return the interpolation {this + fraction * (right - this)} */\r\n  public interpolate(fraction: number, right: Vector2d, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    /* For best last-bit behavior, if fraction is below 0.5, use this as base point.   If above 0.5, use right as base point.   */\r\n    if (fraction <= 0.5) {\r\n      result.x = this.x + fraction * (right.x - this.x);\r\n      result.y = this.y + fraction * (right.y - this.y);\r\n    } else {\r\n      const t: number = fraction - 1.0;\r\n      result.x = right.x + t * (right.x - this.x);\r\n      result.y = right.y + t * (right.y - this.y);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** return {this + vector}. */\r\n  public plus(vector: XAndY, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x + vector.x;\r\n    result.y = this.y + vector.y;\r\n    return result;\r\n  }\r\n  /** return {this - vector}. */\r\n  public minus(vector: XAndY, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x - vector.x;\r\n    result.y = this.y - vector.y;\r\n    return result;\r\n  }\r\n\r\n  /** Return {point + vector \\* scalar} */\r\n  public plusScaled(vector: XAndY, scaleFactor: number, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x + vector.x * scaleFactor;\r\n    result.y = this.y + vector.y * scaleFactor;\r\n    return result;\r\n  }\r\n\r\n  /** Return {point + vectorA \\* scalarA + vectorB \\* scalarB} */\r\n  public plus2Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;\r\n    result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;\r\n    return result;\r\n  }\r\n\r\n  /** Return {this + vectorA \\* scalarA + vectorB \\* scalarB + vectorC \\* scalarC} */\r\n  public plus3Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, vectorC: XAndY, scalarC: number, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;\r\n    result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;\r\n    return result;\r\n  }\r\n  /** Return {this * scale} */\r\n  public scale(scale: number, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x * scale;\r\n    result.y = this.y * scale;\r\n    return result;\r\n  }\r\n  /** return a vector parallel to this but with specified length */\r\n  public scaleToLength(length: number, result?: Vector2d): Vector2d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.magnitude());\r\n    if (mag === 0)\r\n      return undefined;\r\n    return this.scale(length / mag, result);\r\n  }\r\n  /** return the dot product of this with vectorB */\r\n  public dotProduct(vectorB: XAndY): number { return this.x * vectorB.x + this.y * vectorB.y; }\r\n\r\n  /** dot product with vector from pointA to pointB */\r\n  public dotProductStartEnd(pointA: XAndY, pointB: XAndY): number {\r\n    return this.x * (pointB.x - pointA.x)\r\n      + this.y * (pointB.y - pointA.y);\r\n  }\r\n\r\n  /** vector cross product {this CROSS vectorB} */\r\n  public crossProduct(vectorB: XAndY): number { return this.x * vectorB.y - this.y * vectorB.x; }\r\n  /** return the (signed) angle from this to vectorB.   This is positive if the shortest turn is counterclockwise, negative if clockwise. */\r\n  public angleTo(vectorB: XAndY): Angle {\r\n    return Angle.createAtan2(this.crossProduct(vectorB), this.dotProduct(vectorB));\r\n  }\r\n\r\n  /*  smallerUnorientedAngleTo(vectorB: Vector2d): Angle { }\r\n    signedAngleTo(vectorB: Vector2d, upVector: Vector2d): Angle { }\r\n    planarAngleTo(vectorB: Vector2d, planeNormal: Vector2d): Angle { }\r\n    // sectors\r\n    isInSmallerSector(vectorA: Vector2d, vectorB: Vector2d): boolean { }\r\n    isInCCWSector(vectorA: Vector2d, vectorB: Vector2d, upVector: Vector2d): boolean { }\r\n    */\r\n  /**\r\n   * Test if `this` and `other` area parallel, with angle tolerance `Geometry.smallAngleRadiansSquared`.\r\n   * @param other second vector for comparison.\r\n   * @param oppositeIsParallel if true, treat vectors 180 opposite as parallel.  If false, treat those as non-parallel.\r\n   */\r\n  public isParallelTo(other: Vector2d, oppositeIsParallel: boolean = false): boolean {\r\n    const a2 = this.magnitudeSquared();\r\n    const b2 = other.magnitudeSquared();\r\n    // we know both are 0 or positive -- no need for\r\n    if (a2 < Geometry.smallMetricDistanceSquared || b2 < Geometry.smallMetricDistanceSquared)\r\n      return false;\r\n\r\n    const dot = this.dotProduct(other);\r\n    if (dot < 0.0 && !oppositeIsParallel)\r\n      return false;\r\n\r\n    const cross = this.crossProduct(other);\r\n\r\n    /* a2,b2,cross2 are squared lengths of respective vectors */\r\n    /* cross2 = sin^2(theta) * a2 * b2 */\r\n    /* For small theta, sin^2(theta)~~theta^2 */\r\n    return cross * cross <= Geometry.smallAngleRadiansSquared * a2 * b2;\r\n  }\r\n  /**\r\n   * Returns `true` if `this` vector is perpendicular to `other`.\r\n   * @param other second vector.\r\n   */\r\n  public isPerpendicularTo(other: Vector2d): boolean {\r\n    return Angle.isPerpendicularDotSet(this.magnitudeSquared(), other.magnitudeSquared(), this.dotProduct(other));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { XYAndZ } from \"./XYZProps\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { IndexedReadWriteXYZCollection } from \"./IndexedXYZCollection\";\r\n/** @module ArraysAndInterfaces */\r\n/**\r\n * Helper object to access members of a Point3d[] in geometric calculations.\r\n * * The collection holds only a reference to the actual array.\r\n * * The actual array may be replaced by the user as needed.\r\n * * When replaced, there is no cached data to be updated.\r\n * @public\r\n */\r\nexport class Point3dArrayCarrier extends IndexedReadWriteXYZCollection {\r\n  /** reference to array being queried. */\r\n  public data: Point3d[];\r\n  /** CAPTURE caller supplied array ... */\r\n  public constructor(data: Point3d[]) {\r\n    super();\r\n    this.data = data;\r\n  }\r\n  /** test if `index` is a valid index into the array. */\r\n  public isValidIndex(index: number): boolean {\r\n    return index >= 0 && index < this.data.length;\r\n  }\r\n  /**\r\n   * Access by index, returning strongly typed Point3d\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public getPoint3dAtCheckedPointIndex(index: number, result?: Point3d): Point3d | undefined {\r\n    if (this.isValidIndex(index)) {\r\n      const source = this.data[index];\r\n      return Point3d.create(source.x, source.y, source.z, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Access by index, returning strongly typed Point3d\r\n   * * This returns the xyz value but NOT reference to the point in the \"carried\" array.\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public getPoint3dAtUncheckedPointIndex(index: number, result?: Point3d): Point3d {\r\n    const source = this.data[index];\r\n    return Point3d.create(source.x, source.y, source.z, result);\r\n  }\r\n  /**\r\n   * Access by index, returning strongly typed Vector3d\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public getVector3dAtCheckedVectorIndex(index: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isValidIndex(index)) {\r\n      const source = this.data[index];\r\n      return Vector3d.create(source.x, source.y, source.z, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** access x of indexed point */\r\n  public getXAtUncheckedPointIndex(pointIndex: number): number {\r\n    return this.data[pointIndex].x;\r\n  }\r\n\r\n  /** access y of indexed point */\r\n  public getYAtUncheckedPointIndex(pointIndex: number): number {\r\n    return this.data[pointIndex].y;\r\n  }\r\n\r\n  /** access z of indexed point */\r\n  public getZAtUncheckedPointIndex(pointIndex: number): number {\r\n    return this.data[pointIndex].z;\r\n  }\r\n  /**\r\n   * Return a vector from the point at indexA to the point at indexB\r\n   * @param indexA index of point within the array\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public vectorIndexIndex(indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return Vector3d.createStartEnd(this.data[indexA], this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a vector from given origin to point at indexB\r\n   * @param origin origin for vector\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if index is out of bounds\r\n   */\r\n  public vectorXYAndZIndex(origin: XYAndZ, indexB: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isValidIndex(indexB))\r\n      return Vector3d.createStartEnd(origin, this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return the cross product of vectors from origin to points at indexA and indexB\r\n   * @param origin origin for vector\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public crossProductXYAndZIndexIndex(origin: XYAndZ, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return Vector3d.createCrossProductToPoints(origin, this.data[indexA], this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return the cross product of vectors from point at originIndex to points at indexA and indexB\r\n   * @param originIndex index of origin\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns return true if indexA, indexB both valid\r\n   */\r\n  public crossProductIndexIndexIndex(originIndex: number, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return Vector3d.createCrossProductToPoints(this.data[originIndex], this.data[indexA], this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Compute the cross product of vectors from point at originIndex to points at indexA and indexB, and accumulate it to the result.\r\n   * @param origin index of origin\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns return true if indexA, indexB both valid\r\n   */\r\n  public accumulateCrossProductIndexIndexIndex(originIndex: number, indexA: number, indexB: number, result: Vector3d): void {\r\n    const data = this.data;\r\n    if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      result.addCrossProductToTargetsInPlace(data[originIndex].x, data[originIndex].y, data[originIndex].z, data[indexA].x, data[indexA].y, data[indexA].z, data[indexB].x, data[indexB].y, data[indexB].z);\r\n  }\r\n  /**\r\n   * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.\r\n   * * accumulate it to the result.\r\n   */\r\n  public accumulateScaledXYZ(index: number, scale: number, sum: Point3d): void {\r\n    if (this.isValidIndex(index)) {\r\n      const point = this.data[index];\r\n      sum.x += scale * point.x;\r\n      sum.y += scale * point.y;\r\n      sum.z += scale * point.z;\r\n    }\r\n  }\r\n  /**\r\n   * read-only property for number of XYZ in the collection.\r\n   */\r\n  public get length(): number {\r\n    return this.data.length;\r\n  }\r\n  /** push a (clone of) point onto the collection\r\n   * * point itself is not pushed -- xyz data is extracted into the native form of the collection.\r\n   */\r\n  public push(data: Point3d): void {\r\n    this.data.push(data.clone());\r\n  }\r\n  /**\r\n   * push a new point (given by coordinates) onto the collection\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   */\r\n  public pushXYZ(x?: number, y?: number, z?: number): void {\r\n    this.data.push(Point3d.create(x === undefined ? 0.0 : x, y === undefined ? 0.0 : y, z === undefined ? 0.0 : z));\r\n  }\r\n  /** extract (copy) the final point */\r\n  public back(result?: Point3d): Point3d | undefined {\r\n    if (this.data.length > 0) {\r\n      return this.data[this.data.length - 1].clone(result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** extract (copy) the first point */\r\n  public front(result?: Point3d): Point3d | undefined {\r\n    if (this.data.length > 0) {\r\n      return this.data[0].clone(result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** remove the final point. */\r\n  public pop(): void {\r\n    if (this.data.length > 0)\r\n      this.data.pop();\r\n  }\r\n  /** remove all points. */\r\n  public clear(): void {\r\n    this.data.length = 0;\r\n  }\r\n  /** Reverse the points in place */\r\n  public reverseInPlace(): void {\r\n    this.data.reverse();\r\n  }\r\n  /**\r\n   * Return distance squared between indicated points.\r\n   * * Concrete classes may be able to implement this without creating a temporary.\r\n   * @param index0 first point index\r\n   * @param index1 second point index\r\n   * @param defaultDistanceSquared distance squared to return if either point index is invalid.\r\n   *\r\n   */\r\n  public distanceSquaredIndexIndex(index0: number, index1: number): number | undefined {\r\n    const n = this.data.length;\r\n    if (index0 >= 0 && index0 < n && index1 >= 0 && index1 < n) {\r\n      return this.data[index0].distanceSquared(this.data[index1]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return distance between indicated points.\r\n   * * Concrete classes may be able to implement this without creating a temporary.\r\n   * @param index0 first point index\r\n   * @param index1 second point index\r\n   * @param defaultDistanceSquared distance squared to return if either point index is invalid.\r\n   */\r\n  public distanceIndexIndex(index0: number, index1: number): number | undefined {\r\n    const n = this.data.length;\r\n    if (index0 >= 0 && index0 < n && index1 >= 0 && index1 < n) {\r\n      return this.data[index0].distance(this.data[index1]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Adjust index into range by modulo with the length. */\r\n  public cyclicIndex(i: number): number {\r\n    return (i % this.length);\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\nimport { Ray3d } from \"./Ray3d\";\r\nimport { XYAndZ, XAndY, HasZ, XYZProps } from \"./XYZProps\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\n/** @module CartesianGeometry */\r\n\r\n/**\r\n *  * `XYZ` is a minimal object containing x,y,z and operations that are meaningful without change in both point and vector.\r\n *  * `XYZ` is not instantiable.\r\n *  * The derived (instantiable) classes are\r\n *    * `Point3d`\r\n *    * `Vector3d`\r\n * @public\r\n */\r\nexport class XYZ implements XYAndZ {\r\n  /** x coordinate */\r\n  public x: number;\r\n  /** y coordinate */\r\n  public y: number;\r\n  /** z coordinate */\r\n  public z: number;\r\n  /**\r\n   * Set the x,y,z  parts.\r\n   * @param x (optional) x part\r\n   * @param y (optional) y part\r\n   * @param z (optional) z part\r\n   */\r\n  public set(x: number = 0, y: number = 0, z: number = 0) { this.x = x; this.y = y; this.z = z; }\r\n\r\n  /** Set the x,y,z parts to zero. */\r\n  public setZero() { this.x = 0; this.y = 0; this.z = 0; }\r\n  protected constructor(x: number = 0, y: number = 0, z: number = 0) { this.x = x; this.y = y; this.z = z; }\r\n  /** Type guard for XAndY.\r\n   * @note this will return true for an XYAndZ. If you wish to distinguish between the two, call isXYAndZ first.\r\n   */\r\n  public static isXAndY(arg: any): arg is XAndY { return arg.x !== undefined && arg.y !== undefined; }\r\n  /** Type guard to determine whether an object has a member called \"z\" */\r\n  public static hasZ(arg: any): arg is HasZ { return arg.z !== undefined; }\r\n  /** Type guard for XYAndZ.  */\r\n  public static isXYAndZ(arg: any): arg is XYAndZ { return this.isXAndY(arg) && this.hasZ(arg); }\r\n  /** Test if arg is any of:\r\n   * * XAndY\r\n   * * XYAndZ\r\n   * * [number,number]\r\n   * * [number,number,number]\r\n   */\r\n  public static isAnyImmediatePointType(arg: any): boolean {\r\n    return Point3d.isXAndY(arg) || Geometry.isNumberArray(arg, 2);\r\n  }\r\n  /** Look for (in order) an x coordinate present as:\r\n   * * arg.x\r\n   * * arg[0]\r\n   */\r\n  public static accessX(arg: any, defaultValue?: number): number | undefined {\r\n    if (arg.x !== undefined)\r\n      return arg.x;\r\n    if (Array.isArray(arg) && arg.length > 0 && Number.isFinite(arg[0]))\r\n      return arg[0];\r\n    return defaultValue;\r\n  }\r\n  /** Look for (in order) an x coordinate present as:\r\n   * * arg.y\r\n   * * arg[1]\r\n   */\r\n  public static accessY(arg: any, defaultValue?: number): number | undefined {\r\n    if (arg.y !== undefined)\r\n      return arg.y;\r\n    if (Array.isArray(arg) && arg.length > 1 && Number.isFinite(arg[1]))\r\n      return arg[1];\r\n    return defaultValue;\r\n  }\r\n\r\n  /** Look for (in order) an x coordinate present as:\r\n   * * arg.z\r\n   * * arg[2]\r\n   */\r\n  public static accessZ(arg: any, defaultValue?: number): number | undefined {\r\n    if (arg.z !== undefined)\r\n      return arg.z;\r\n    if (Array.isArray(arg) && arg.length > 2 && Number.isFinite(arg[2]))\r\n      return arg[2];\r\n    return defaultValue;\r\n  }\r\n  /**\r\n   * Set the x,y,z parts from one of these input types\r\n   *\r\n   * * XYZ -- copy the x,y,z parts\r\n   * * Float64Array -- Copy from indices 0,1,2 to x,y,z\r\n   * * XY -- copy the x, y parts and set z=0\r\n   */\r\n  public setFrom(other: Float64Array | XAndY | XYAndZ | undefined) {\r\n    if (other === undefined) {\r\n      this.setZero();\r\n    } else if (XYZ.isXAndY(other)) {\r\n      this.x = other.x;\r\n      this.y = other.y;\r\n      this.z = XYZ.hasZ(other) ? other.z : 0;\r\n    } else {\r\n      this.x = other[0];\r\n      this.y = other[1];\r\n      this.z = other[2];\r\n    }\r\n  }\r\n  /**\r\n   * Set the x,y,z parts from a Point3d.\r\n   * This is the same effect as `setFrom(other)` with no pretesting of variant input type\r\n   * * Set to zeros if `other` is undefined.\r\n   */\r\n  public setFromPoint3d(other?: XYAndZ) {\r\n    if (other) {\r\n      this.x = other.x;\r\n      this.y = other.y;\r\n      this.z = other.z;\r\n    } else {\r\n      this.setZero();\r\n    }\r\n  }\r\n  /**\r\n   * Set the x,y,z parts from a Vector3d\r\n   * This is the same effect as `setFrom(other)` with no pretesting of variant input type\r\n   */\r\n  public setFromVector3d(other: Vector3d) {\r\n    if (other) {\r\n      this.x = other.x;\r\n      this.y = other.y;\r\n      this.z = other.z;\r\n    } else {\r\n      this.setZero();\r\n    }\r\n  }\r\n\r\n  /** Returns true if this and other have equal x,y,z parts within Geometry.smallMetricDistance.\r\n   * @param other The other XYAndZ to compare\r\n   * @param tol The tolerance for the comparison. If undefined, use [[Geometry.smallMetricDistance]]\r\n   */\r\n  public isAlmostEqual(other: XYAndZ, tol?: number): boolean {\r\n    return Geometry.isSameCoordinate(this.x, other.x, tol)\r\n      && Geometry.isSameCoordinate(this.y, other.y, tol)\r\n      && Geometry.isSameCoordinate(this.z, other.z, tol);\r\n  }\r\n  /** Return true if this and other have equal x,y,z parts within Geometry.smallMetricDistance. */\r\n  public isAlmostEqualXYZ(x: number, y: number, z: number, tol?: number): boolean {\r\n    return Geometry.isSameCoordinate(this.x, x, tol)\r\n      && Geometry.isSameCoordinate(this.y, y, tol)\r\n      && Geometry.isSameCoordinate(this.z, z, tol);\r\n  }\r\n  /** Return true if this and other have equal x,y parts within Geometry.smallMetricDistance. */\r\n  public isAlmostEqualXY(other: XAndY, tol?: number): boolean {\r\n    return Geometry.isSameCoordinate(this.x, other.x, tol)\r\n      && Geometry.isSameCoordinate(this.y, other.y, tol);\r\n  }\r\n  /** Return a JSON object as array `[x,y,z]` */\r\n  public toJSON(): XYZProps { return [this.x, this.y, this.z]; }\r\n  /** Return a JSON object as key value pairs `{x: value, y: value, z: value}` */\r\n  public toJSONXYZ(): XYZProps { return { x: this.x, y: this.y, z: this.z }; }\r\n  /** Pack the x,y,z values in a Float64Array. */\r\n  public toFloat64Array(): Float64Array { return Float64Array.of(this.x, this.y, this.z); }\r\n  /**\r\n   * Set the x,y,z properties from one of several json forms:\r\n   *\r\n   * *  array of numbers: [x,y,z]\r\n   * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}\r\n   */\r\n  public setFromJSON(json?: XYZProps): void {\r\n    if (Array.isArray(json)) {\r\n      this.set(json[0] || 0, json[1] || 0, json[2] || 0);\r\n      return;\r\n    }\r\n    if (json) {\r\n      this.set(json.x || 0, json.y || 0, json.z || 0);\r\n      return;\r\n    }\r\n    this.set(0, 0, 0);\r\n  }\r\n  /** Return the distance from this point to other */\r\n  public distance(other: XYAndZ): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    const zDist = other.z - this.z;\r\n    return (Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist));\r\n  }\r\n  /** Return squared distance from this point to other */\r\n  public distanceSquared(other: XYAndZ): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    const zDist = other.z - this.z;\r\n    return (xDist * xDist + yDist * yDist + zDist * zDist);\r\n  }\r\n  /** Return the XY distance from this point to other */\r\n  public distanceXY(other: XAndY): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    return (Math.sqrt(xDist * xDist + yDist * yDist));\r\n  }\r\n  /** Return squared XY distance from this point to other */\r\n  public distanceSquaredXY(other: XAndY): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    return (xDist * xDist + yDist * yDist);\r\n  }\r\n  /** Return the largest absolute distance between corresponding components */\r\n  public maxDiff(other: XYAndZ): number {\r\n    return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y), Math.abs(this.z - other.z));\r\n  }\r\n  /**\r\n   * Return the x,y, z component corresponding to 0,1,2.\r\n   */\r\n  public at(index: number): number {\r\n    if (index < 0.5)\r\n      return this.x;\r\n    if (index > 1.5)\r\n      return this.z;\r\n    return this.y;\r\n  }\r\n  /** Return the index (0,1,2) of the x,y,z component with largest absolute value */\r\n  public indexOfMaxAbs(): number {\r\n    let index = 0;\r\n    let a = Math.abs(this.x);\r\n    let b = Math.abs(this.y);\r\n    if (b > a) {\r\n      index = 1;\r\n      a = b;\r\n    }\r\n    b = Math.abs(this.z);\r\n    if (b > a) {\r\n      index = 2;\r\n      a = b;\r\n    }\r\n    return index;\r\n  }\r\n  /** Return true if the if x,y,z components are all nearly zero to tolerance Geometry.smallMetricDistance */\r\n  public get isAlmostZero(): boolean {\r\n    return Geometry.isSmallMetricDistance(this.x) && Geometry.isSmallMetricDistance(this.y) && Geometry.isSmallMetricDistance(this.z);\r\n  }\r\n  /** Return the largest absolute value of any component */\r\n  public maxAbs(): number { return Math.max(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z)); }\r\n  /** Return the sqrt of the sum of squared x,y,z parts */\r\n  public magnitude(): number { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z); }\r\n  /** Return the sum of squared x,y,z parts */\r\n  public magnitudeSquared(): number { return this.x * this.x + this.y * this.y + this.z * this.z; }\r\n  /** Return sqrt of the sum of squared x,y parts */\r\n  public magnitudeXY(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }\r\n  /** Return the sum of squared x,y parts */\r\n  public magnitudeSquaredXY(): number { return this.x * this.x + this.y * this.y; }\r\n  /** exact equality test. */\r\n  public isExactEqual(other: XYAndZ): boolean { return this.x === other.x && this.y === other.y && this.z === other.z; }\r\n  /** equality test with Geometry.smallMetricDistance tolerance */\r\n  public isAlmostEqualMetric(other: XYAndZ): boolean { return this.maxDiff(other) <= Geometry.smallMetricDistance; }\r\n  /** add x,y,z from other in place. */\r\n  public addInPlace(other: XYAndZ): void { this.x += other.x; this.y += other.y; this.z += other.z; }\r\n  /** add x,y,z from other in place. */\r\n  public subtractInPlace(other: XYAndZ): void { this.x -= other.x; this.y -= other.y; this.z -= other.z; }\r\n  /** add (in place) the scaled x,y,z of other */\r\n  public addScaledInPlace(other: XYAndZ, scale: number): void {\r\n    this.x += scale * other.x;\r\n    this.y += scale * other.y;\r\n    this.z += scale * other.z;\r\n  }\r\n  /** Multiply the x, y, z parts by scale. */\r\n  public scaleInPlace(scale: number) { this.x *= scale; this.y *= scale; this.z *= scale; }\r\n  /** add to x, y, z parts */\r\n  public addXYZInPlace(dx: number = 0.0, dy: number = 0.0, dz: number = 0.0) { this.x += dx; this.y += dy; this.z += dz; }\r\n  /** Clone strongly typed as Point3d */\r\n  public cloneAsPoint3d() { return Point3d.create(this.x, this.y, this.z); }\r\n  /** Return a (full length) vector from this point to other */\r\n  public vectorTo(other: XYAndZ, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(other.x - this.x, other.y - this.y, other.z - this.z, result);\r\n  }\r\n  /** Return a multiple of a the (full length) vector from this point to other */\r\n  public scaledVectorTo(other: XYAndZ, scale: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(scale * (other.x - this.x), scale * (other.y - this.y), scale * (other.z - this.z), result);\r\n  }\r\n  /** Return a unit vector from this vector to other. Return a 000 vector if the input is too small to normalize.\r\n   * @param other target of created vector.\r\n   * @param result optional result vector.\r\n   */\r\n  public unitVectorTo(target: XYAndZ, result?: Vector3d): Vector3d | undefined { return this.vectorTo(target, result).normalize(result); }\r\n  /** Freeze this XYZ */\r\n  public freeze() { Object.freeze(this); }\r\n}\r\n/** 3D point with `x`,`y`,`z` as properties\r\n * @public\r\n */\r\nexport class Point3d extends XYZ {\r\n  /** Constructor for Point3d */\r\n  constructor(x: number = 0, y: number = 0, z: number = 0) { super(x, y, z); }\r\n  /**\r\n   * Convert json to Point3d.  Accepted forms are:\r\n   * * `[1,2,3]` --- array of numbers\r\n   * *  array of numbers: [x,y,z]\r\n   * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}\r\n   * @param json json value.\r\n   */\r\n  public static fromJSON(json?: XYZProps): Point3d { const val = new Point3d(); val.setFromJSON(json); return val; }\r\n  /** Return a new Point3d with the same coordinates */\r\n  public clone(result?: Point3d): Point3d { return Point3d.create(this.x, this.y, this.z, result); }\r\n  /** Create a new Point3d with given coordinates\r\n   * @param x x part\r\n   * @param y y part\r\n   * @param z z part\r\n   */\r\n  public static create(x: number = 0, y: number = 0, z: number = 0, result?: Point3d): Point3d {\r\n    if (result) {\r\n      result.x = x;\r\n      result.y = y;\r\n      result.z = z;\r\n      return result;\r\n    }\r\n    return new Point3d(x, y, z);\r\n  }\r\n  /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */\r\n  public static createFrom(data: XYAndZ | XAndY | Float64Array, result?: Point3d): Point3d {\r\n    if (data instanceof Float64Array) {\r\n      let x = 0;\r\n      let y = 0;\r\n      let z = 0;\r\n      if (data.length > 0)\r\n        x = data[0];\r\n      if (data.length > 1)\r\n        y = data[1];\r\n      if (data.length > 2)\r\n        z = data[2];\r\n      return Point3d.create(x, y, z, result);\r\n    }\r\n    return Point3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0, result);\r\n  }\r\n  /**\r\n   * Copy x,y,z from\r\n   * @param xyzData flat array of xyzxyz for multiple points\r\n   * @param pointIndex index of point to extract.   This index is multiplied by 3 to obtain starting index in the array.\r\n   * @param result optional result point.\r\n   */\r\n  public static createFromPacked(xyzData: Float64Array, pointIndex: number, result?: Point3d): Point3d | undefined {\r\n    const indexX = pointIndex * 3;\r\n    if (indexX >= 0 && indexX + 2 < xyzData.length)\r\n      return Point3d.create(xyzData[indexX], xyzData[indexX + 1], xyzData[indexX + 2], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Copy and unweight xyzw.\r\n   * @param xyzData flat array of x,y,z,w,x,y,z,w for multiple points\r\n   * @param pointIndex index of point to extract.   This index is multiplied by 4 to obtain starting index in the array.\r\n   * @param result optional result point.\r\n   */\r\n  public static createFromPackedXYZW(xyzData: Float64Array, pointIndex: number, result?: Point3d): Point3d | undefined {\r\n    const indexX = pointIndex * 4;\r\n    if (indexX >= 0 && indexX + 3 < xyzData.length) {\r\n      const w = xyzData[indexX + 3];\r\n      if (!Geometry.isSmallMetricDistance(w)) {\r\n        const divW = 1.0 / w;\r\n        return Point3d.create(divW * xyzData[indexX], divW * xyzData[indexX + 1], divW * xyzData[indexX + 2], result);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Create a new point with 000 xyz */\r\n  public static createZero(result?: Point3d): Point3d { return Point3d.create(0, 0, 0, result); }\r\n  /** Return the cross product of the vectors from this to pointA and pointB\r\n   *\r\n   * *  the result is a vector\r\n   * *  the result is perpendicular to both vectors, with right hand orientation\r\n   * *  the magnitude of the vector is twice the area of the triangle.\r\n   */\r\n  public crossProductToPoints(pointA: Point3d, pointB: Point3d, result?: Vector3d): Vector3d {\r\n    return Vector3d.createCrossProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, result);\r\n  }\r\n  /** Return the magnitude of the cross product of the vectors from this to pointA and pointB\r\n   */\r\n  public crossProductToPointsMagnitude(pointA: Point3d, pointB: Point3d): number {\r\n    return Geometry.crossProductMagnitude(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z);\r\n  }\r\n\r\n  /** Return the triple product of the vectors from this to pointA, pointB, pointC\r\n   *\r\n   * * This is a scalar (number)\r\n   * *  This is 6 times the (signed) volume of the tetrahedron on the 4 points.\r\n   */\r\n  public tripleProductToPoints(pointA: Point3d, pointB: Point3d, pointC: Point3d): number {\r\n    return Geometry.tripleProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, pointC.x - this.x, pointC.y - this.y, pointC.z - this.z);\r\n  }\r\n  /** Return the cross product of the vectors from this to pointA and pointB\r\n   *\r\n   * *  the result is a scalar\r\n   * *  the magnitude of the vector is twice the signed area of the triangle.\r\n   * *  this is positive for counter-clockwise order of the points, negative for clockwise.\r\n   */\r\n  public crossProductToPointsXY(pointA: Point3d, pointB: Point3d): number {\r\n    return Geometry.crossProductXYXY(pointA.x - this.x, pointA.y - this.y, pointB.x - this.x, pointB.y - this.y);\r\n  }\r\n  /** Return a point interpolated between this point and the right param. */\r\n  public interpolate(fraction: number, other: XYAndZ, result?: Point3d): Point3d {\r\n    if (fraction <= 0.5)\r\n      return Point3d.create(this.x + fraction * (other.x - this.x), this.y + fraction * (other.y - this.y), this.z + fraction * (other.z - this.z), result);\r\n    const t: number = fraction - 1.0;\r\n    return Point3d.create(other.x + t * (other.x - this.x), other.y + t * (other.y - this.y), other.z + t * (other.z - this.z), result);\r\n  }\r\n  /**\r\n   * Return a ray whose ray.origin is interpolated, and ray.direction is the vector between points with a\r\n   * scale factor applied.\r\n   * @param fraction fractional position between points.\r\n   * @param other endpoint of interpolation\r\n   * @param tangentScale scale factor to apply to the startToEnd vector\r\n   * @param result  optional receiver.\r\n   */\r\n  public interpolatePointAndTangent(fraction: number, other: Point3d, tangentScale: number, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    const dx = other.x - this.x;\r\n    const dy = other.y - this.y;\r\n    const dz = other.z - this.z;\r\n    result.direction.set(tangentScale * dx, tangentScale * dy, tangentScale * dz);\r\n    if (fraction <= 0.5)\r\n      result.origin.set(this.x + fraction * dx, this.y + fraction * dy, this.z + fraction * dz);\r\n    else {\r\n      const t: number = fraction - 1.0;\r\n      result.origin.set(other.x + t * dx, other.y + t * dy, other.z + t * dz);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return a point with independent x,y,z fractional interpolation. */\r\n  public interpolateXYZ(fractionX: number, fractionY: number, fractionZ: number, other: Point3d, result?: Point3d): Point3d {\r\n    return Point3d.create(Geometry.interpolate(this.x, fractionX, other.x), Geometry.interpolate(this.y, fractionY, other.y), Geometry.interpolate(this.z, fractionZ, other.z), result);\r\n  }\r\n  /** Interpolate between points, then add a shift in the xy plane by a fraction of the XY projection perpendicular. */\r\n  public interpolatePerpendicularXY(fraction: number, pointB: Point3d, fractionXYPerp: number, result?: Point3d): Point3d {\r\n    result = result ? result : new Point3d();\r\n    const vector = pointB.minus(this);\r\n    this.interpolate(fraction, pointB, result);\r\n    result.x -= fractionXYPerp * vector.y;\r\n    result.y += fractionXYPerp * vector.x;\r\n    return result;\r\n  }\r\n  /** Return point minus vector */\r\n  public minus(vector: XYAndZ, result?: Point3d): Point3d {\r\n    return Point3d.create(this.x - vector.x, this.y - vector.y, this.z - vector.z, result);\r\n  }\r\n  /** Return point plus vector */\r\n  public plus(vector: XYAndZ, result?: Point3d): Point3d {\r\n    return Point3d.create(this.x + vector.x, this.y + vector.y, this.z + vector.z, result);\r\n  }\r\n  /** Return point plus vector */\r\n  public plusXYZ(dx: number = 0, dy: number = 0, dz: number = 0, result?: Point3d): Point3d {\r\n    return Point3d.create(this.x + dx, this.y + dy, this.z + dz, result);\r\n  }\r\n  /** Return point + vector * scalar */\r\n  public plusScaled(vector: XYAndZ, scaleFactor: number, result?: Point3d): Point3d {\r\n    return Point3d.create(this.x + vector.x * scaleFactor, this.y + vector.y * scaleFactor, this.z + vector.z * scaleFactor, result);\r\n  }\r\n  /** Return point + vectorA * scalarA + vectorB * scalarB */\r\n  public plus2Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYZ, scalarB: number, result?: Point3d): Point3d {\r\n    return Point3d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB, this.y + vectorA.y * scalarA + vectorB.y * scalarB, this.z + vectorA.z * scalarA + vectorB.z * scalarB, result);\r\n  }\r\n  /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */\r\n  public plus3Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYAndZ, scalarB: number, vectorC: XYAndZ, scalarC: number, result?: Point3d): Point3d {\r\n    return Point3d.create(\r\n      this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC,\r\n      this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC,\r\n      this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC, result);\r\n  }\r\n  /**\r\n   * Return a point that is scaled from the source point.\r\n   * @param source existing point\r\n   * @param scale scale factor to apply to its x,y,z parts\r\n   * @param result optional point to receive coordinates\r\n   */\r\n  public static createScale(source: XYAndZ, scale: number, result?: Point3d): Point3d {\r\n    return Point3d.create(source.x * scale, source.y * scale, source.z * scale, result);\r\n  }\r\n  /** create a point that is a linear combination (weighted sum) of 2 input points.\r\n   * @param pointA first input point\r\n   * @param scaleA scale factor for pointA\r\n   * @param pointB second input point\r\n   * @param scaleB scale factor for pointB\r\n   */\r\n  public static createAdd2Scaled(pointA: XYAndZ, scaleA: number, pointB: XYAndZ, scaleB: number, result?: Point3d): Point3d {\r\n    return Point3d.create(pointA.x * scaleA + pointB.x * scaleB, pointA.y * scaleA + pointB.y * scaleB, pointA.z * scaleA + pointB.z * scaleB, result);\r\n  }\r\n  /** Create a point that is a linear combination (weighted sum) of 3 input points.\r\n   * @param pointA first input point\r\n   * @param scaleA scale factor for pointA\r\n   * @param pointB second input point\r\n   * @param scaleB scale factor for pointB\r\n   * @param pointC third input point.\r\n   * @param scaleC scale factor for pointC\r\n   */\r\n  public static createAdd3Scaled(pointA: XYAndZ, scaleA: number, pointB: XYAndZ, scaleB: number, pointC: XYAndZ, scaleC: number, result?: Point3d): Point3d {\r\n    return Point3d.create(pointA.x * scaleA + pointB.x * scaleB + pointC.x * scaleC, pointA.y * scaleA + pointB.y * scaleB + pointC.y * scaleC, pointA.z * scaleA + pointB.z * scaleB + pointC.z * scaleC, result);\r\n  }\r\n  /**\r\n   * Return the dot product of vectors from this to pointA and this to pointB.\r\n   * @param targetA target point for first vector\r\n   * @param targetB target point for second vector\r\n   */\r\n  public dotVectorsToTargets(targetA: Point3d, targetB: Point3d): number {\r\n    return (targetA.x - this.x) * (targetB.x - this.x) +\r\n      (targetA.y - this.y) * (targetB.y - this.y) +\r\n      (targetA.z - this.z) * (targetB.z - this.z);\r\n  }\r\n  /** Return the fractional projection of this onto a line between points.\r\n   *\r\n   */\r\n  public fractionOfProjectionToLine(startPoint: Point3d, endPoint: Point3d, defaultFraction: number = 0): number {\r\n    const denominator = startPoint.distanceSquared(endPoint);\r\n    if (denominator < Geometry.smallMetricDistanceSquared)\r\n      return defaultFraction;\r\n    return startPoint.dotVectorsToTargets(endPoint, this) / denominator;\r\n  }\r\n}\r\n/** 3D vector with `x`,`y`,`z` as properties\r\n * @public\r\n */\r\nexport class Vector3d extends XYZ {\r\n  constructor(x: number = 0, y: number = 0, z: number = 0) { super(x, y, z); }\r\n  /**\r\n   * Copy xyz from this instance to a new (or optionally reused) Vector3d\r\n   * @param result optional instance to reuse.\r\n   */\r\n  public clone(result?: Vector3d): Vector3d { return Vector3d.create(this.x, this.y, this.z, result); }\r\n  /**\r\n   * return a Vector3d (new or reused from optional result)\r\n   * @param x x component\r\n   * @param y y component\r\n   * @param z z component\r\n   * @param result optional instance to reuse\r\n   */\r\n  public static create(x: number = 0, y: number = 0, z: number = 0, result?: Vector3d): Vector3d {\r\n    if (result) {\r\n      result.x = x;\r\n      result.y = y;\r\n      result.z = z;\r\n      return result;\r\n    }\r\n    return new Vector3d(x, y, z);\r\n  }\r\n  /**\r\n   * Create a vector which is cross product of two vectors supplied as separate arguments\r\n   * @param ux x coordinate of vector u\r\n   * @param uy y coordinate of vector u\r\n   * @param uz z coordinate of vector u\r\n   * @param vx x coordinate of vector v\r\n   * @param vy y coordinate of vector v\r\n   * @param vz z coordinate of vector v\r\n   * @param result optional result vector.\r\n   */\r\n  public static createCrossProduct(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx, result);\r\n  }\r\n  /**\r\n   * Accumulate a vector which is cross product vectors from origin (ax,ay,az) to targets (bx,by,bz) and (cx,cy,cz)\r\n   * @param ax x coordinate of origin\r\n   * @param ay y coordinate of origin\r\n   * @param az z coordinate of origin\r\n   * @param bx x coordinate of target point b\r\n   * @param by y coordinate of target point b\r\n   * @param bz z coordinate of target point b\r\n   * @param cx x coordinate of target point c\r\n   * @param cy y coordinate of target point c\r\n   * @param cz z coordinate of target point c\r\n   */\r\n  public addCrossProductToTargetsInPlace(ax: number, ay: number, az: number, bx: number, by: number, bz: number, cx: number, cy: number, cz: number) {\r\n    const ux = bx - ax;\r\n    const uy = by - ay;\r\n    const uz = bz - az;\r\n    const vx = cx - ax;\r\n    const vy = cy - ay;\r\n    const vz = cz - az;\r\n    this.x += uy * vz - uz * vy;\r\n    this.y += uz * vx - ux * vz;\r\n    this.z += ux * vy - uy * vx;\r\n  }\r\n  /**\r\n   * Return the cross product of the vectors from origin to pointA and pointB.\r\n   *\r\n   * * the result is a vector\r\n   * * the result is perpendicular to both vectors, with right hand orientation\r\n   * * the magnitude of the vector is twice the area of the triangle.\r\n   */\r\n  public static createCrossProductToPoints(origin: XYAndZ, pointA: XYAndZ, pointB: XYAndZ, result?: Vector3d): Vector3d {\r\n    return Vector3d.createCrossProduct(pointA.x - origin.x, pointA.y - origin.y, pointA.z - origin.z, pointB.x - origin.x, pointB.y - origin.y, pointB.z - origin.z, result);\r\n  }\r\n  /**\r\n   * Return a vector defined by polar coordinates distance and angle from x axis\r\n   * @param r distance measured from origin\r\n   * @param theta angle from x axis to the vector (in xy plane)\r\n   * @param z optional z coordinate\r\n   */\r\n  public static createPolar(r: number, theta: Angle, z?: number): Vector3d {\r\n    return Vector3d.create(r * theta.cos(), r * theta.sin(), z);\r\n  }\r\n  /**\r\n   * Return a vector defined in spherical coordinates.\r\n   * @param r sphere radius\r\n   * @param theta angle in xy plane\r\n   * @param phi angle from xy plane to the vector\r\n   */\r\n  public static createSpherical(r: number, theta: Angle, phi: Angle): Vector3d {\r\n    const cosPhi = phi.cos();\r\n    return Vector3d.create(cosPhi * r * theta.cos(), cosPhi * r * theta.sin(), phi.sin());\r\n  }\r\n  /**\r\n   * Convert json to Vector3d.  Accepted forms are:\r\n   * * `[1,2,3]` --- array of numbers\r\n   * *  array of numbers: [x,y,z]\r\n   * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}\r\n   * @param json json value.\r\n   */\r\n\r\n  public static fromJSON(json?: XYZProps): Vector3d { const val = new Vector3d(); val.setFromJSON(json); return val; }\r\n  /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */\r\n  public static createFrom(data: XYAndZ | XAndY | Float64Array, result?: Vector3d): Vector3d {\r\n    if (data instanceof Float64Array) {\r\n      let x = 0;\r\n      let y = 0;\r\n      let z = 0;\r\n      if (data.length > 0)\r\n        x = data[0];\r\n      if (data.length > 1)\r\n        y = data[1];\r\n      if (data.length > 2)\r\n        z = data[2];\r\n      return Vector3d.create(x, y, z, result);\r\n    }\r\n    return Vector3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0.0, result);\r\n  }\r\n  /**\r\n   * Return a vector defined by start and end points (end - start).\r\n   * @param start start point for vector\r\n   * @param end end point for vector\r\n   * @param result optional result\r\n   */\r\n  public static createStartEnd(start: XYAndZ, end: XYAndZ, result?: Vector3d): Vector3d {\r\n    if (result) {\r\n      result.set(end.x - start.x, end.y - start.y, end.z - start.z);\r\n      return result;\r\n    }\r\n    return new Vector3d(end.x - start.x, end.y - start.y, end.z - start.z);\r\n  }\r\n  /**\r\n   * Return a vector (optionally in preallocated result, otherwise newly created) from [x0,y0,z0] to [x1,y1,z1]\r\n   * @param x0 start point x coordinate\r\n   * @param y0 start point y coordinate\r\n   * @param z0 start point z coordinate\r\n   * @param x1 end point x coordinate\r\n   * @param y1 end point y coordinate\r\n   * @param z1 end point z coordinate\r\n   * @param result optional result vector\r\n   */\r\n  public static createStartEndXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, result?: Vector3d): Vector3d {\r\n    return this.create(x1 - x0, y1 - y0, z1 - z0, result);\r\n  }\r\n  /**\r\n   * Return a vector which is the input vector rotated around the axis vector.\r\n   * @param vector initial vector\r\n   * @param axis axis of rotation\r\n   * @param angle angle of rotation.  If undefined, 90 degrees is implied\r\n   * @param result optional result vector\r\n   * @returns undefined if axis has no length.\r\n   */\r\n  public static createRotateVectorAroundVector(vector: Vector3d, axis: Vector3d, angle?: Angle): Vector3d | undefined {\r\n    // Rodriguez formula, https://en.wikipedia.org/wiki/Rodrigues'_rotation_formula\r\n    const unitAxis = axis.normalize();\r\n    if (unitAxis) {\r\n      const xProduct = unitAxis.crossProduct(vector);\r\n      let c, s;\r\n      if (angle) {\r\n        c = angle.cos();\r\n        s = angle.sin();\r\n      } else {\r\n        c = 0.0;\r\n        s = 1.0;\r\n      }\r\n      return Vector3d.createAdd3Scaled(vector, c, xProduct, s, unitAxis, unitAxis.dotProduct(vector) * (1.0 - c));\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Set (replace) xzz components so they are a vector from point0 to point1\r\n   * @param point0 start point of computed vector\r\n   * @param point1 end point of computed vector.\r\n   */\r\n  public setStartEnd(point0: XYAndZ, point1: XYAndZ) {\r\n    this.x = point1.x - point0.x;\r\n    this.y = point1.y - point0.y;\r\n    this.z = point1.z - point0.z;\r\n  }\r\n  /** Return a vector with 000 xyz parts. */\r\n  public static createZero(result?: Vector3d): Vector3d { return Vector3d.create(0, 0, 0, result); }\r\n  /** Return a unit X vector optionally multiplied by a scale  */\r\n  public static unitX(scale: number = 1): Vector3d { return new Vector3d(scale, 0, 0); }\r\n  /** Return a unit Y vector  */\r\n  public static unitY(scale: number = 1): Vector3d { return new Vector3d(0, scale, 0); }\r\n  /** Return a unit Z vector  */\r\n  public static unitZ(scale: number = 1): Vector3d { return new Vector3d(0, 0, scale); }\r\n  /** Divide by denominator, but return undefined if denominator is zero. */\r\n  public safeDivideOrNull(denominator: number, result?: Vector3d): Vector3d | undefined {\r\n    if (denominator !== 0.0) {\r\n      return this.scale(1.0 / denominator, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a pair object containing (a) property `v` which is a unit vector in the direction\r\n   * of the input and (b) property mag which is the magnitude (length) of the input (instance) prior to normalization.\r\n   * If the instance (input) is a near zero length the `v` property of the output is undefined.\r\n   * @param result optional result.\r\n   */\r\n  public normalizeWithLength(result?: Vector3d): {\r\n    v: Vector3d | undefined;\r\n    mag: number;\r\n  } {\r\n    const magnitude = Geometry.correctSmallMetricDistance(this.magnitude());\r\n    result = result ? result : new Vector3d();\r\n    return { v: this.safeDivideOrNull(magnitude, result), mag: magnitude };\r\n  }\r\n  /**\r\n   * Return a unit vector parallel with this.  Return undefined if this.magnitude is near zero.\r\n   * @param result optional result.\r\n   */\r\n  public normalize(result?: Vector3d): Vector3d | undefined { return this.normalizeWithLength(result).v; }\r\n  /**\r\n   * If this vector has nonzero length, divide by the length to change to a unit vector.\r\n   * @returns true if normalization completed.\r\n   */\r\n  public normalizeInPlace(): boolean {\r\n    const a = Geometry.inverseMetricDistance(this.magnitude());\r\n    if (!a)\r\n      return false;\r\n    this.x *= a;\r\n    this.y *= a;\r\n    this.z *= a;\r\n    return true;\r\n  }\r\n  /** Return the fractional projection of spaceVector onto this */\r\n  public fractionOfProjectionToVector(target: Vector3d, defaultFraction: number = 0): number {\r\n    const numerator = this.dotProduct(target);\r\n    const denominator = target.magnitudeSquared();\r\n    if (denominator < Geometry.smallMetricDistanceSquared)\r\n      return defaultFraction;\r\n    return numerator / denominator;\r\n  }\r\n  /** Return a new vector with components negated from the calling instance.\r\n   * @param result optional result vector.\r\n   */\r\n  public negate(result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = -this.x;\r\n    result.y = -this.y;\r\n    result.z = -this.z;\r\n    return result;\r\n  }\r\n  /** Return a vector same length as this but rotate 90 degrees CCW */\r\n  public rotate90CCWXY(result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    // save x,y to allow aliasing ..\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result.x = -yy;\r\n    result.y = xx;\r\n    result.z = this.z;\r\n    return result;\r\n  }\r\n  /**\r\n   * Return a vector which is in the xy plane, perpendicular ot the xy part of this vector, and of unit length.\r\n   * * If the xy part is 00, the return is the rotated (but not normalized) xy parts of this vector.\r\n   * @param result optional preallocated result.\r\n   */\r\n  public unitPerpendicularXY(result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result.x = -yy;\r\n    result.y = xx;\r\n    result.z = 0.0;\r\n    const d2: number = xx * xx + yy * yy;\r\n    if (d2 !== 0.0) {\r\n      const a = 1.0 / Math.sqrt(d2);\r\n      result.x *= a;\r\n      result.y *= a;\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Rotate the xy parts of this vector around the z axis.\r\n   * * z is taken unchanged to the result.\r\n   * @param angle angle to rotate\r\n   * @param result optional preallocated result\r\n   */\r\n  public rotateXY(angle: Angle, result?: Vector3d): Vector3d {\r\n    const s = angle.sin();\r\n    const c = angle.cos();\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result = result ? result : new Vector3d();\r\n    result.x = xx * c - yy * s;\r\n    result.y = xx * s + yy * c;\r\n    result.z = this.z;\r\n    return result;\r\n  }\r\n  /**\r\n   * Return a (new or optionally preallocated) vector that is rotated 90 degrees in the plane of this vector and the target vector.\r\n   * @param target Second vector which defines the plane of rotation.\r\n   * @param result optional preallocated vector for result.\r\n   * @returns rotated vector, or undefined if the cross product of this and the the target cannot be normalized (i.e. if the target and this are colinear)\r\n   */\r\n  public rotate90Towards(target: Vector3d, result?: Vector3d): Vector3d | undefined {\r\n    const normal = this.crossProduct(target).normalize();\r\n    return normal ? normal.crossProduct(this, result) : undefined;\r\n  }\r\n  /** Rotate this vector 90 degrees around an axis vector.\r\n   * @returns the (new or optionally reused result) rotated vector, or undefined if the axis vector cannot be normalized.\r\n   */\r\n  public rotate90Around(axis: Vector3d, result?: Vector3d): Vector3d | undefined {\r\n    const unitNormal = axis.normalize();\r\n    return unitNormal ? unitNormal.crossProduct(this).plusScaled(unitNormal, unitNormal.dotProduct(this), result) : undefined;\r\n  }\r\n  /**\r\n   * Return a vector computed at fractional position between this vector and vectorB\r\n   * @param fraction fractional position.  0 is at `this`.  1 is at `vectorB`.  True fractions are \"between\", negatives are \"before this\", beyond 1 is \"beyond vectorB\".\r\n   * @param vectorB second vector\r\n   * @param result optional preallocated result.\r\n   */\r\n  public interpolate(fraction: number, vectorB: Vector3d, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    if (fraction <= 0.5) {\r\n      result.x = this.x + fraction * (vectorB.x - this.x);\r\n      result.y = this.y + fraction * (vectorB.y - this.y);\r\n      result.z = this.z + fraction * (vectorB.z - this.z);\r\n    } else {\r\n      const t: number = fraction - 1.0;\r\n      result.x = vectorB.x + t * (vectorB.x - this.x);\r\n      result.y = vectorB.y + t * (vectorB.y - this.y);\r\n      result.z = vectorB.z + t * (vectorB.z - this.z);\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the vector sum `this - vector`\r\n   * @param vector right side of addition.\r\n   * @param result optional preallocated result.\r\n   */\r\n  public plus(vector: XYAndZ, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x + vector.x;\r\n    result.y = this.y + vector.y;\r\n    result.z = this.z + vector.z;\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the vector difference `this - vector`\r\n   * @param vector right side of subtraction.\r\n   * @param result optional preallocated result.\r\n   */\r\n  public minus(vector: XYAndZ, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x - vector.x;\r\n    result.y = this.y - vector.y;\r\n    result.z = this.z - vector.z;\r\n    return result;\r\n  }\r\n  /** Return vector + vector * scalar */\r\n  public plusScaled(vector: XYAndZ, scaleFactor: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x + vector.x * scaleFactor;\r\n    result.y = this.y + vector.y * scaleFactor;\r\n    result.z = this.z + vector.z * scaleFactor;\r\n    return result;\r\n  }\r\n\r\n  /** Return the (strongly typed Vector3d) `this Vector3d + vectorA * scalarA + vectorB * scalarB` */\r\n  public plus2Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYAndZ, scalarB: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;\r\n    result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;\r\n    result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB;\r\n    return result;\r\n  }\r\n\r\n  /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */\r\n  public plus3Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYAndZ, scalarB: number, vectorC: XYAndZ, scalarC: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;\r\n    result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;\r\n    result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC;\r\n    return result;\r\n  }\r\n  /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB` */\r\n  public static createAdd2Scaled(vectorA: XYAndZ, scaleA: number, vectorB: XYAndZ, scaleB: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB, vectorA.y * scaleA + vectorB.y * scaleB, vectorA.z * scaleA + vectorB.z * scaleB, result);\r\n  }\r\n  /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB` with all components presented as numbers */\r\n  public static createAdd2ScaledXYZ(ax: number, ay: number, az: number, scaleA: number, bx: number, by: number, bz: number, scaleB: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(ax * scaleA + bx * scaleB, ay * scaleA + by * scaleB, az * scaleA + bz * scaleB, result);\r\n  }\r\n  /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scaleA + vectorB * scaleB + vectorC * scaleC` */\r\n  public static createAdd3Scaled(vectorA: XYAndZ, scaleA: number, vectorB: XYAndZ, scaleB: number, vectorC: XYAndZ, scaleC: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB + vectorC.x * scaleC, vectorA.y * scaleA + vectorB.y * scaleB + vectorC.y * scaleC, vectorA.z * scaleA + vectorB.z * scaleB + vectorC.z * scaleC, result);\r\n  }\r\n  /** Return vector * scalar */\r\n  public scale(scale: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x * scale;\r\n    result.y = this.y * scale;\r\n    result.z = this.z * scale;\r\n    return result;\r\n  }\r\n  /**\r\n   * Return a (optionally new or reused) vector in the direction of `this` but with specified length.\r\n   * @param length desired length of vector\r\n   * @param result optional preallocated result\r\n   */\r\n  public scaleToLength(length: number, result?: Vector3d): Vector3d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.magnitude());\r\n    if (mag === 0)\r\n      return undefined;\r\n    return this.scale(length / mag, result);\r\n  }\r\n  /** Compute the cross product of this vector with `vectorB`.   Immediately pass it to `normalize`.\r\n   * @param vectorB second vector for cross product.\r\n   * @returns see `Vector3d` method `normalize()` for error condition.\r\n   */\r\n  public unitCrossProduct(vectorB: Vector3d, result?: Vector3d): Vector3d | undefined {\r\n    return this.crossProduct(vectorB, result).normalize(result);\r\n  }\r\n  /**\r\n   * Compute the cross product of this vector with `vectorB`.   Normalize it, using given xyz as default if length is zero.\r\n   * @param vectorB second vector of cross product\r\n   * @param x x value for default result\r\n   * @param y y value for default result\r\n   * @param z z value for default result\r\n   * @param result optional pre-allocated result.\r\n   */\r\n  public unitCrossProductWithDefault(vectorB: Vector3d, x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    const unit = this.crossProduct(vectorB, result).normalize(result);\r\n    if (unit === undefined)\r\n      return Vector3d.create(x, y, z, result);\r\n    return unit;\r\n  }\r\n  /**\r\n   * Normalize this vector, using given xyz as default if length is zero.\r\n   * * if this instance and x,y,z are both 000, return unit x vector.\r\n   * @param x x value for default result\r\n   * @param y y value for default result\r\n   * @param z z value for default result\r\n   * @param result optional pre-allocated result.\r\n   */\r\n  public normalizeWithDefault(x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    const unit = this.normalize(result);\r\n    if (unit)\r\n      return unit;\r\n    // try back to x,y,z\r\n    result = Vector3d.create(x, y, z, result);\r\n    if (result.normalizeInPlace())\r\n      return result;\r\n\r\n    return Vector3d.create(1, 0, 0, result);\r\n  }\r\n  /**\r\n   * Try to normalize (divide by magnitude), storing the result in place.\r\n   * @param smallestMagnitude smallest magnitude allowed as divisor.\r\n   * @returns false if magnitude is too small.  In this case the vector is unchanged.\r\n   */\r\n  public tryNormalizeInPlace(smallestMagnitude: number = Geometry.smallMetricDistance): boolean {\r\n    const a = this.magnitude();\r\n    if (a < smallestMagnitude || a === 0.0)\r\n      return false;\r\n    this.scaleInPlace(1.0 / a);\r\n    return true;\r\n  }\r\n  /**\r\n   * Compute cross product with `vectorB`.\r\n   * @param vectorB second vector for cross product.\r\n   * @param productLength desired length of result vector.\r\n   * @param result optional preallocated vector\r\n   * @return undefined if the cross product is near zero length.\r\n   */\r\n  public sizedCrossProduct(vectorB: Vector3d, productLength: number, result?: Vector3d): Vector3d | undefined {\r\n    result = this.crossProduct(vectorB, result);\r\n    if (result.tryNormalizeInPlace()) {\r\n      result.scaleInPlace(productLength);\r\n      return result;\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Compute the squared magnitude of a cross product (without allocating a temporary vector object)\r\n   * @param vectorB second vector of cross product\r\n   * @returns the squared magnitude of the cross product of this instance with vectorB.\r\n   */\r\n  public crossProductMagnitudeSquared(vectorB: XYAndZ): number {\r\n    const xx = this.y * vectorB.z - this.z * vectorB.y;\r\n    const yy = this.z * vectorB.x - this.x * vectorB.z;\r\n    const zz = this.x * vectorB.y - this.y * vectorB.x;\r\n    return xx * xx + yy * yy + zz * zz;\r\n  }\r\n  /**\r\n   * Compute the  magnitude of a cross product (without allocating a temporary vector object)\r\n   * @param vectorB second vector of cross product\r\n   * @returns the  magnitude of the cross product of this instance with vectorB.\r\n   */\r\n  public crossProductMagnitude(vectorB: XYAndZ): number {\r\n    return Math.sqrt(this.crossProductMagnitudeSquared(vectorB));\r\n  }\r\n  /** Return the dot product of this vector with vectorB.\r\n   * @param vectorB second vector of cross product\r\n   * @returns the dot product of this instance with vectorB\r\n   */\r\n  public dotProduct(vectorB: XYAndZ): number {\r\n    return this.x * vectorB.x + this.y * vectorB.y + this.z * vectorB.z;\r\n  }\r\n  /**\r\n   * Returns the dot product of this vector with the with vector from pointA to pointB\r\n   * @param pointA start point of second vector of dot product\r\n   * @param pointB end point of second vector of dot product\r\n   */\r\n  public dotProductStartEnd(pointA: XYAndZ, pointB: XYAndZ): number {\r\n    return this.x * (pointB.x - pointA.x)\r\n      + this.y * (pointB.y - pointA.y)\r\n      + this.z * (pointB.z - pointA.z);\r\n  }\r\n\r\n  /**\r\n   * Returns the dot product with vector (pointB - pointA * pointB.w)\r\n   * * That is, pointA is weighted to weight of pointB.\r\n   * * If pointB.w is zero, the homogeneous pointB is a simple vector\r\n   * * If pointB.w is nonzero, the vector \"from A to B\" is not physical length.\r\n   */\r\n  public dotProductStart3dEnd4d(pointA: Point3d, pointB: Point4d): number {\r\n    const w = pointB.w;\r\n    return this.x * (pointB.x - pointA.x * w)\r\n      + this.y * (pointB.y - pointA.y * w)\r\n      + this.z * (pointB.z - pointA.z * w);\r\n  }\r\n\r\n  /** Cross product with vector from pointA to pointB */\r\n  public crossProductStartEnd(pointA: Point3d, pointB: Point3d, result?: Vector3d): Vector3d {\r\n    return Vector3d.createCrossProduct(this.x, this.y, this.z, pointB.x - pointA.x, pointB.y - pointA.y, pointB.z - pointA.z, result);\r\n  }\r\n  /** Cross product (xy parts only) with vector from pointA to pointB */\r\n  public crossProductStartEndXY(pointA: Point3d, pointB: Point3d): number {\r\n    return Geometry.crossProductXYXY(this.x, this.y, pointB.x - pointA.x, pointB.y - pointA.y);\r\n  }\r\n  /** Dot product with vector from pointA to pointB, with pointB given as x,y,z */\r\n  public dotProductStartEndXYZ(pointA: Point3d, x: number, y: number, z: number): number {\r\n    return this.x * (x - pointA.x)\r\n      + this.y * (y - pointA.y)\r\n      + this.z * (z - pointA.z);\r\n  }\r\n  /** Dot product with vector from pointA to pointB, with pointB given as (weighted) x,y,z,w\r\n   * * pointB is a homogeneous point that has to be unweighted\r\n   * * if the weight is near zero metric, the return is zero.\r\n   */\r\n  public dotProductStartEndXYZW(pointA: Point3d, x: number, y: number, z: number, w: number): number {\r\n    if (Geometry.isSmallMetricDistance(w))\r\n      return 0.0;\r\n    const dw = 1.0 / w;\r\n    return this.x * (dw * x - pointA.x)\r\n      + this.y * (dw * y - pointA.y)\r\n      + this.z * (dw * z - pointA.z);\r\n  }\r\n  /** Return the dot product of the instance and vectorB, using only the x and y parts. */\r\n  public dotProductXY(vectorB: Vector3d): number {\r\n    return this.x * vectorB.x + this.y * vectorB.y;\r\n  }\r\n  /**\r\n   * Dot product with vector (x,y,z)\r\n   * @param x x component for dot product\r\n   * @param y y component for dot product\r\n   * @param z z component for dot product\r\n   */\r\n  public dotProductXYZ(x: number, y: number, z: number = 0): number {\r\n    return this.x * x + this.y * y + this.z * z;\r\n  }\r\n  /** Return the triple product of the instance, vectorB, and vectorC  */\r\n  public tripleProduct(vectorB: Vector3d, vectorC: Vector3d): number {\r\n    return Geometry.tripleProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, vectorC.x, vectorC.y, vectorC.z);\r\n  }\r\n  /** Return the cross product of the instance and vectorB, using only the x and y parts. */\r\n  public crossProductXY(vectorB: Vector3d): number {\r\n    return this.x * vectorB.y - this.y * vectorB.x;\r\n  }\r\n  /**\r\n   * Return the cross product of this vector and vectorB.\r\n   * @param vectorB second vector of cross product\r\n   * @param result optional preallocated result.\r\n   */\r\n  public crossProduct(vectorB: Vector3d, result?: Vector3d): Vector3d {\r\n    return Vector3d.createCrossProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, result);\r\n  }\r\n  /**\r\n   * return cross product of `this` with the vector `(x, y, z)`\r\n   * @param x x component of second vector\r\n   * @param y y component of second vector\r\n   * @param z z component of second vector\r\n   * @param result computed cross product (new Vector3d).\r\n   */\r\n  public crossProductXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.createCrossProduct(this.x, this.y, this.z, x, y, z, result);\r\n  }\r\n\r\n  /**\r\n   * Return the (Strongly typed) angle from this vector to vectorB.\r\n   * * The returned angle is always positive and no larger than 180 degrees (PI radians)\r\n   * * The returned angle is \"in the plane containing the two vectors\"\r\n   * * Use `planarAngleTo`, `signedAngleTo`, `angleToXY` to take have angle measured in specific plane.\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public angleTo(vectorB: Vector3d): Angle {\r\n    return Angle.createAtan2(this.crossProductMagnitude(vectorB), this.dotProduct(vectorB));\r\n  }\r\n  /**\r\n   * Return the (Strongly typed) angle from this vector to the plane perpendicular to planeNormal.\r\n   * * The returned vector is signed\r\n   * * The returned vector is (as degrees) always less than or equal to 90 degrees.\r\n   * @param planeNormal a normal vector to the plane\r\n   */\r\n  public angleFromPerpendicular(vectorB: Vector3d): Angle {\r\n    return Angle.createAtan2(this.dotProduct(vectorB), this.crossProductMagnitude(vectorB));\r\n  }\r\n\r\n  /**\r\n   * Return the (Strongly typed) angle from this vector to vectorB,using only the xy parts.\r\n   * * The returned angle can range from negative 180 degrees (negative PI radians) to positive 180 degrees (positive PI radians), not closed on the negative side.\r\n   * * Use `planarAngleTo`, `signedAngleTo`, `angleToXY` to take have angle measured in other planes.\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public angleToXY(vectorB: Vector3d): Angle {\r\n    return Angle.createAtan2(this.crossProductXY(vectorB), this.dotProductXY(vectorB));\r\n  }\r\n  /**\r\n   * Return the (radians as a simple number, not strongly typed Angle) radians from this vector to vectorB.\r\n   * * The returned angle can be positive or negative, with magnitude no larger than PI radians\r\n   * * Use signedRadiansTo` to take have angle measured in other planes.\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public planarRadiansTo(vector: Vector3d, planeNormal: Vector3d): number {\r\n    const square = planeNormal.dotProduct(planeNormal);\r\n    if (square === 0.0)\r\n      return 0.0;\r\n    const factor = 1.0 / square;\r\n    const projection0: Vector3d = this.plusScaled(planeNormal, -this.dotProduct(planeNormal) * factor);\r\n    const projection1: Vector3d = vector.plusScaled(planeNormal, -vector.dotProduct(planeNormal) * factor);\r\n    return projection0.signedRadiansTo(projection1, planeNormal);\r\n  }\r\n  /**\r\n   * Return the (as strongly typed Angle) Angle from this vector to vectorB.\r\n   * * The returned angle can range from negative PI to positive PI (not closed on negative side)\r\n   * * Use signedRadiansTo` to take have angle measured in other planes.\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public planarAngleTo(vector: Vector3d, planeNormal: Vector3d): Angle {\r\n    return Angle.createRadians(this.planarRadiansTo(vector, planeNormal));\r\n  }\r\n\r\n  /**\r\n   * Return the (simple number of radians, not Strongly typed Angle) angle from this vector to vectorB, measured in the plane containing both, with vectorW indicating which side to view to control sign of the angle.\r\n   * * The returned angle can range from negative PI to positive PI (not closed on negative side)\r\n   * * The returned angle is \"in the plane containing the two vectors\"\r\n   * * `vectorW` distinguishes between the sides of the plane, but does not have to be perpendicular.\r\n   * * The returned angle has the same sign as vectorW dot product (thisVector cross vectorB)\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public signedRadiansTo(vector1: Vector3d, vectorW: Vector3d): number {\r\n    const p = this.crossProduct(vector1);\r\n    const theta = Math.atan2(p.magnitude(), this.dotProduct(vector1));\r\n    if (vectorW.dotProduct(p) < 0.0)\r\n      return -theta;\r\n    else\r\n      return theta;\r\n  }\r\n  /**\r\n   * Return the (strongly typed Angle) angle from this vector to vectorB, measured in the plane containing both, with vectorW indicating which side to view to control sign of the angle.\r\n   * * The returned angle can range from negative 180 degrees (negative PI radians) to positive 180 degrees (positive PI radians), not closed on the negative side.\r\n   * * The returned angle is \"in the plane containing the two vectors\"\r\n   * * `vectorW` distinguishes between the sides of the plane, but does not have to be perpendicular.\r\n   * * The returned angle has the same sign as vectorW dot product (thisVector cross vectorB)\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public signedAngleTo(vector1: Vector3d, vectorW: Vector3d): Angle { return Angle.createRadians(this.signedRadiansTo(vector1, vectorW)); }\r\n  /** Return the smallest (strongly typed) angle from the (bidirectional) line containing `this` to the (bidirectional) line containing `vectorB` */\r\n  public smallerUnorientedAngleTo(vectorB: Vector3d): Angle {\r\n    return Angle.createRadians(this.smallerUnorientedRadiansTo(vectorB));\r\n  }\r\n  /** Return the smallest angle (in radians) from the (bidirectional) line containing `this` to the (bidirectional) line containing `vectorB` */\r\n  public smallerUnorientedRadiansTo(vectorB: Vector3d): number {\r\n    const c = this.dotProduct(vectorB);\r\n    const s = this.crossProductMagnitude(vectorB);\r\n    return Math.atan2(Math.abs(s), Math.abs(c));\r\n  }\r\n\r\n  /*\r\n    signedAngleTo(vectorB: Vector3d, upVector: Vector3d): Angle { }\r\n    // sectors\r\n    isInSmallerSector(vectorA: Vector3d, vectorB: Vector3d): boolean { }\r\n    isInCCWSector(vectorA: Vector3d, vectorB: Vector3d, upVector: Vector3d): boolean { }\r\n    */\r\n  /**\r\n   * Test if this vector is parallel to other.\r\n   * @param other second vector in comparison\r\n   * @param oppositeIsParallel if the vectors are on the same line but in opposite directions, return this value.\r\n   * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.\r\n   */\r\n  public isParallelTo(other: Vector3d, oppositeIsParallel: boolean = false, returnValueIfAnInputIsZeroLength: boolean = false): boolean {\r\n    const a2 = this.magnitudeSquared();\r\n    const b2 = other.magnitudeSquared();\r\n    // we know both are 0 or positive -- no need for\r\n    if (a2 < Geometry.smallMetricDistanceSquared || b2 < Geometry.smallMetricDistanceSquared)\r\n      return returnValueIfAnInputIsZeroLength;\r\n    const dot = this.dotProduct(other);\r\n    if (dot < 0.0 && !oppositeIsParallel)\r\n      return returnValueIfAnInputIsZeroLength;\r\n    const cross2 = this.crossProductMagnitudeSquared(other);\r\n    /* a2,b2,cross2 are squared lengths of respective vectors */\r\n    /* cross2 = sin^2(theta) * a2 * b2 */\r\n    /* For small theta, sin^2(theta)~~theta^2 */\r\n    return cross2 <= Geometry.smallAngleRadiansSquared * a2 * b2;\r\n  }\r\n  /**\r\n   * Test if this vector is perpendicular to other.\r\n   * @param other second vector in comparison\r\n   * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.\r\n   */\r\n  public isPerpendicularTo(other: Vector3d, returnValueIfAnInputIsZeroLength: boolean = false): boolean {\r\n    const aa = this.magnitudeSquared();\r\n    if (aa < Geometry.smallMetricDistanceSquared)\r\n      return returnValueIfAnInputIsZeroLength;\r\n    const bb = other.magnitudeSquared();\r\n    if (bb < Geometry.smallMetricDistanceSquared)\r\n      return returnValueIfAnInputIsZeroLength;\r\n    const ab = this.dotProduct(other);\r\n    return ab * ab <= Geometry.smallAngleRadiansSquared * aa * bb;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point2d } from \"./Point2dVector2d\";\r\nimport { XYAndZ, XAndY } from \"./XYZProps\";\r\nimport { Point3d, Vector3d, XYZ } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { MultiLineStringDataVariant, LineStringDataVariant } from \"../topology/Triangulation\";\r\n\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"./Plane3dByOriginAndUnitNormal\";\r\nimport { IndexedXYZCollection } from \"./IndexedXYZCollection\";\r\nimport { VariantPointDataStream, PointStringDeepXYZArrayCollector } from \"./PointStreaming\";\r\nimport { Range3d } from \"./Range\";\r\n\r\n/**\r\n * The `NumberArray` class contains static methods that act on arrays of numbers.\r\n * @public\r\n */\r\nexport class NumberArray {\r\n  /** return the sum of values in an array,   The summation is done with correction terms which\r\n   * improves last-bit numeric accuracy.\r\n   */\r\n  public static preciseSum(data: number[]) {\r\n    const n = data.length;\r\n    if (n === 0)\r\n      return 0.0;\r\n    let sum = data[0];\r\n    let c = 0.0;\r\n    let y: number;\r\n    let t: number;\r\n    for (let i = 1; i < n; i++) {\r\n      y = data[i] - c;\r\n      t = sum + y;\r\n      c = (t - sum) - y;\r\n      sum = t;\r\n    }\r\n    return sum;\r\n  }\r\n  /** Return true if arrays have identical counts and equal entries (using `!==` comparison) */\r\n  public static isExactEqual(dataA: any[] | Float64Array | undefined, dataB: any[] | Float64Array | undefined) {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++)\r\n        if (dataA[i] !== dataB[i])\r\n          return false;\r\n      return true;\r\n    }\r\n    return (dataA === undefined && dataB === undefined);\r\n  }\r\n  /** Return true if arrays have identical counts and entries equal within tolerance */\r\n  public static isAlmostEqual(\r\n    dataA: number[] | Float64Array | undefined,\r\n    dataB: number[] | Float64Array | undefined,\r\n    tolerance: number) {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++)\r\n        if (Math.abs(dataA[i] - dataB[i]) >= tolerance) return false;\r\n      return true;\r\n    }\r\n    return (dataA === undefined && dataB === undefined);\r\n  }\r\n\r\n  /** return the sum of numbers in an array.  Note that \"PreciseSum\" may be more accurate. */\r\n  public static sum(data: number[] | Float64Array) {\r\n    let sum = 0;\r\n    for (const x of data) { sum += x; }\r\n    return sum;\r\n  }\r\n  /** test if coordinate x appears (to tolerance by `Geometry.isSameCoordinate`) in this array of numbers */\r\n  public static isCoordinateInArray(x: number, data: number[] | undefined): boolean {\r\n    if (data) {\r\n      for (const y of data) { if (Geometry.isSameCoordinate(x, y)) return true; }\r\n    }\r\n    return false;\r\n  }\r\n  /** Return the max absolute value in a array of numbers. */\r\n  public static maxAbsArray(values: number[]) {\r\n    const arrLen = values.length;\r\n    if (arrLen === 0) {\r\n      return 0.0;\r\n    }\r\n    let a = Math.abs(values[0]);\r\n    for (let i = 1; i < arrLen; i++) {\r\n      const b = Math.abs(values[i]);\r\n      if (a < b) {\r\n        a = b;\r\n      }\r\n    }\r\n    return a;\r\n  }\r\n  /** return the max absolute value of a pair of numbers */\r\n  public static maxAbsTwo(a1: number, a2: number) {\r\n    a1 = Math.abs(a1);\r\n    a2 = Math.abs(a2);\r\n    return (a1 > a2) ? a1 : a2;\r\n  }\r\n  /** Return the max absolute difference between corresponding entries in two arrays of numbers\r\n   * * If sizes are mismatched, only the smaller length is tested.\r\n   */\r\n  public static maxAbsDiff(dataA: number[] | Float64Array, dataB: number[] | Float64Array): number {\r\n    let a = 0.0;\r\n    const n = Math.min(dataA.length, dataB.length);\r\n    for (let i = 0; i < n; i++) { a = Math.max(a, Math.abs(dataA[i] - dataB[i])); }\r\n    return a;\r\n  }\r\n\r\n  /** Return the max absolute difference between corresponding entries in two Float64Array\r\n   * * If sizes are mismatched, only the smaller length is tested.\r\n   */\r\n  public static maxAbsDiffFloat64(dataA: Float64Array, dataB: Float64Array): number {\r\n    let a = 0.0;\r\n    const n = Math.min(dataA.length, dataB.length);\r\n    for (let i = 0; i < n; i++) { a = Math.max(a, Math.abs(dataA[i] - dataB[i])); }\r\n    return a;\r\n  }\r\n\r\n}\r\n/**\r\n * The `Point2dArray` class contains static methods that act on arrays of 2d points.\r\n * @public\r\n */\r\nexport class Point2dArray {\r\n  /** Return true if arrays have same length and matching coordinates. */\r\n  public static isAlmostEqual(dataA: undefined | Point2d[], dataB: undefined | Point2d[]): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++) {\r\n        if (!dataA[i].isAlmostEqual(dataB[i]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    return (dataA === undefined && dataB === undefined);\r\n  }\r\n  /**\r\n   * Return an array containing clones of the Point3d data[]\r\n   * @param data source data\r\n   */\r\n  public static clonePoint2dArray(data: Point2d[]): Point2d[] {\r\n    return data.map((p: Point2d) => p.clone());\r\n  }\r\n  /**\r\n   * Return the number of points when trailing points that match point 0 are excluded.\r\n   * @param data array of XAndY points.\r\n   */\r\n  public static pointCountExcludingTrailingWraparound(data: XAndY[]): number {\r\n    let n = data.length;\r\n    if (n < 2)\r\n      return n;\r\n    const x0 = data[0].x;\r\n    const y0 = data[0].y;\r\n    while (n > 1) {\r\n      if (!Geometry.isSameCoordinate(data[n - 1].x, x0) || !Geometry.isSameCoordinate(data[n - 1].y, y0))\r\n        return n;\r\n      n--;\r\n    }\r\n    return n;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * The `Vector3ddArray` class contains static methods that act on arrays of 2d vectors.\r\n * @public\r\n */\r\nexport class Vector3dArray {\r\n  /** Return true if arrays have same length and matching coordinates. */\r\n  public static isAlmostEqual(dataA: undefined | Vector3d[], dataB: undefined | Vector3d[]): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++)\r\n        if (!dataA[i].isAlmostEqual(dataB[i]))\r\n          return false;\r\n      return true;\r\n    }\r\n    return (dataA === undefined && dataB === undefined);\r\n  }\r\n  /**\r\n   * Return an array containing clones of the Vector3d data[]\r\n   * @param data source data\r\n   */\r\n  public static cloneVector3dArray(data: XYAndZ[]): Vector3d[] {\r\n    return data.map((p: XYAndZ) => Vector3d.create(p.x, p.y, p.z));\r\n  }\r\n}\r\n\r\n/**\r\n * The `Point4dArray` class contains static methods that act on arrays of 4d points.\r\n * @public\r\n */\r\nexport class Point4dArray {\r\n  /** pack each point and its corresponding weight into a buffer of xyzw xyzw ... */\r\n  public static packPointsAndWeightsToFloat64Array(points: Point3d[], weights: number[], result?: Float64Array): Float64Array {\r\n    result = result ? result : new Float64Array(4 * points.length);\r\n    let i = 0;\r\n    let k = 0;\r\n    for (k = 0; k < points.length; k++) {\r\n      result[i++] = points[k].x;\r\n      result[i++] = points[k].y;\r\n      result[i++] = points[k].z;\r\n      result[i++] = weights[k];\r\n    }\r\n    return result;\r\n  }\r\n  /** pack x,y,z,w in Float64Array. */\r\n  public static packToFloat64Array(data: Point4d[], result?: Float64Array): Float64Array {\r\n    result = result ? result : new Float64Array(4 * data.length);\r\n    let i = 0;\r\n    for (const p of data) {\r\n      result[i++] = p.x;\r\n      result[i++] = p.y;\r\n      result[i++] = p.z;\r\n      result[i++] = p.w;\r\n    }\r\n    return result;\r\n  }\r\n  /** unpack from  ... to array of Point4d */\r\n  public static unpackToPoint4dArray(data: Float64Array): Point4d[] {\r\n    const result = [];\r\n    for (let i = 0; i + 3 < data.length; i += 4) {\r\n      result.push(Point4d.create(data[i], data[i + 1], data[i + 2], data[i + 3]));\r\n    }\r\n    return result;\r\n  }\r\n  /** unpack from xyzw xyzw... array to array of Point3d and array of weight.\r\n   */\r\n  public static unpackFloat64ArrayToPointsAndWeights(data: Float64Array, points: Point3d[], weights: number[],\r\n    pointFormatter: (x: number, y: number, z: number) => any = Point3d.create) {\r\n    points.length = 0;\r\n    weights.length = 0;\r\n    for (let i = 0; i + 3 < data.length; i += 4) {\r\n      points.push(pointFormatter(data[i], data[i + 1], data[i + 2]));\r\n      weights.push(data[i + 3]);\r\n    }\r\n  }\r\n  private static _workPoint4d = Point4d.create();\r\n  /**\r\n   * Multiply (and replace) each block of 4 values as a Point4d.\r\n   * @param transform transform to apply\r\n   * @param xyzw array of x,y,z,w points.\r\n   */\r\n  public static multiplyInPlace(transform: Transform, xyzw: Float64Array): void {\r\n    const numXYZW = xyzw.length;\r\n    const xyzw1 = Point4dArray._workPoint4d;\r\n    for (let i = 0; i + 3 < numXYZW; i += 4) {\r\n      transform.multiplyXYZW(xyzw[i], xyzw[i + 1], xyzw[i + 2], xyzw[i + 3], xyzw1);\r\n      xyzw[i] = xyzw1.x;\r\n      xyzw[i + 1] = xyzw1.y;\r\n      xyzw[i + 2] = xyzw1.z;\r\n      xyzw[i + 3] = xyzw1.w;\r\n    }\r\n  }\r\n  /** test for near equality of all corresponding numeric values, treated as coordinates. */\r\n  public static isAlmostEqual(dataA: Point4d[] | Float64Array | undefined, dataB: Point4d[] | Float64Array | undefined): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      if (dataA instanceof Float64Array && dataB instanceof Float64Array) {\r\n        for (let i = 0; i < dataA.length; i++)\r\n          if (!Geometry.isSameCoordinate(dataA[i], dataB[i]))\r\n            return false;\r\n      } else if (Array.isArray(dataA) && Array.isArray(dataB)) {\r\n        for (let i = 0; i < dataA.length; i++)\r\n          if (!dataA[i].isAlmostEqual(dataB[i]))\r\n            return false;\r\n      }\r\n      return true;\r\n    }\r\n    // if both are null it is equal, otherwise unequal\r\n    return (dataA === undefined && dataB === undefined);\r\n  }\r\n  /** return true iff all xyzw points' altitudes are within tolerance of the plane.*/\r\n  public static isCloseToPlane(data: Point4d[] | Float64Array, plane: Plane3dByOriginAndUnitNormal, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    if (Array.isArray(data)) {\r\n      for (const xyzw of data) {\r\n        if (Math.abs(plane.altitudeXYZW(xyzw.x, xyzw.y, xyzw.z, xyzw.w)) > tolerance)\r\n          return false;\r\n      }\r\n    } else if (data instanceof Float64Array) {\r\n      const numXYZ = data.length;\r\n      for (let i = 0; i + 2 < numXYZ; i += 4) {\r\n        if (Math.abs(plane.altitudeXYZW(data[i], data[i + 1], data[i + 2], data[i + 3])) > tolerance)\r\n          return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n}\r\n/**\r\n * The `Point3dArray` class contains static methods that act on arrays of 3d points.\r\n * @public\r\n */\r\n\r\nexport class Point3dArray {\r\n  /** pack x,y,z to `Float64Array` */\r\n  public static packToFloat64Array(data: Point3d[]): Float64Array {\r\n    const result = new Float64Array(3 * data.length);\r\n    let i = 0;\r\n    for (const p of data) {\r\n      result[i++] = p.x;\r\n      result[i++] = p.y;\r\n      result[i++] = p.z;\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Compute the 8 weights of trilinear mapping\r\n   * By appropriate choice of weights, this can be used for both point and derivative mappings.\r\n   * @param weights preallocated array to receive weights.\r\n   * @param u0 low u weight\r\n   * @param u1 high u weight\r\n   * @param v0 low v weight\r\n   * @param v1 high v weight\r\n   * @param w0 low w weight\r\n   * @param w1 high w weight\r\n   */\r\n  public static evaluateTrilinearWeights(weights: Float64Array, u0: number, u1: number, v0: number, v1: number, w0: number, w1: number) {\r\n\r\n    weights[0] = u0 * v0 * w0;\r\n    weights[1] = u1 * v0 * w0;\r\n    weights[2] = u0 * v1 * w0;\r\n    weights[3] = u1 * v1 * w0;\r\n    weights[4] = u0 * v0 * w1;\r\n    weights[5] = u1 * v0 * w1;\r\n    weights[6] = u0 * v1 * w1;\r\n    weights[7] = u1 * v1 * w1;\r\n  }\r\n  /**\r\n   * sum the weighted x components from a point array.\r\n   * * weights.length is the number of summed terms\r\n   * * points must have at least that length\r\n   * @param weights\r\n   * @param points\r\n   */\r\n  public static sumWeightedX(weights: Float64Array, points: Point3d[]): number {\r\n    let sum = 0.0;\r\n    const n = weights.length;\r\n    for (let i = 0; i < n; i++)\r\n      sum += weights[i] * points[i].x;\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * sum the weighted x components from a point array.\r\n   * * weights.length is the number of summed terms\r\n   * * points must have at least that length\r\n   * @param weights\r\n   * @param points\r\n   */\r\n  public static sumWeightedY(weights: Float64Array, points: Point3d[]): number {\r\n    let sum = 0.0;\r\n    const n = weights.length;\r\n    for (let i = 0; i < n; i++)\r\n      sum += weights[i] * points[i].y;\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * sum the weighted x components from a point array.\r\n   * * weights.length is the number of summed terms\r\n   * * points must have at least that length\r\n   * @param weights\r\n   * @param points\r\n   */\r\n  public static sumWeightedZ(weights: Float64Array, points: Point3d[]): number {\r\n    let sum = 0.0;\r\n    const n = weights.length;\r\n    for (let i = 0; i < n; i++)\r\n      sum += weights[i] * points[i].z;\r\n    return sum;\r\n  }\r\n\r\n  private static _weightUVW = new Float64Array(8);\r\n  private static _weightDU = new Float64Array(8);\r\n  private static _weightDV = new Float64Array(8);\r\n  private static _weightDW = new Float64Array(8);\r\n  /**\r\n   * Compute a point by trilinear mapping.\r\n   * @param points array of 8 points at corners, with x index varying fastest.\r\n   * @param result optional result point\r\n   */\r\n  public static evaluateTrilinearPoint(points: Point3d[], u: number, v: number, w: number, result?: Point3d): Point3d {\r\n    if (!result) result = Point3d.create(0, 0, 0);\r\n    this.evaluateTrilinearWeights(this._weightUVW, 1 - u, u, 1 - v, v, 1 - w, w);\r\n    let a;\r\n    for (let i = 0; i < 8; i++) {\r\n      a = this._weightUVW[i];\r\n      result.x += a * points[i].x;\r\n      result.y += a * points[i].y;\r\n      result.z += a * points[i].z;\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Compute a point and derivatives wrt uvw by trilinear mapping.\r\n   * * evaluated point is the point part of the transform\r\n   * * u,v,w derivatives are the respective columns of the matrix part of the transform.\r\n   * @param points array of 8 points at corners, with x index varying fastest.\r\n   * @param result optional result transform\r\n   */\r\n  public static evaluateTrilinearDerivativeTransform(points: Point3d[], u: number, v: number, w: number, result?: Transform): Transform {\r\n    this.evaluateTrilinearWeights(this._weightUVW, 1 - u, u, 1 - v, v, 1 - w, w);\r\n    this.evaluateTrilinearWeights(this._weightDU, -1, 1, 1 - v, v, 1 - w, w);\r\n    this.evaluateTrilinearWeights(this._weightDV, 1 - u, u, -1, 1, 1 - w, w);\r\n    this.evaluateTrilinearWeights(this._weightDW, 1 - u, u, 1 - v, v, -1, 1);\r\n    return Transform.createRowValues(\r\n      this.sumWeightedX(this._weightDU, points), this.sumWeightedX(this._weightDV, points), this.sumWeightedX(this._weightDW, points), this.sumWeightedX(this._weightUVW, points),\r\n      this.sumWeightedY(this._weightDU, points), this.sumWeightedY(this._weightDV, points), this.sumWeightedY(this._weightDW, points), this.sumWeightedY(this._weightUVW, points),\r\n      this.sumWeightedZ(this._weightDU, points), this.sumWeightedZ(this._weightDV, points), this.sumWeightedZ(this._weightDW, points), this.sumWeightedZ(this._weightUVW, points),\r\n      result);\r\n  }\r\n  /** unpack from a number array or Float64Array to an array of `Point3d` */\r\n  public static unpackNumbersToPoint3dArray(data: Float64Array | number[]): Point3d[] {\r\n    const result = [];\r\n    for (let i = 0; i + 2 < data.length; i += 3) {\r\n      result.push(Point3d.create(data[i], data[i + 1], data[i + 2]));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * return an 2-dimensional array containing all the values of `data` in arrays of numPerBlock\r\n   * @param data simple array of numbers\r\n   * @param numPerBlock number of values in each block at first level down\r\n   */\r\n  public static unpackNumbersToNestedArrays(data: Float64Array, numPerBlock: number): any[] {\r\n    const result = [];\r\n    const n = data.length;\r\n    let i = 0;\r\n    let i1 = 0;\r\n    while (i < n) {\r\n      // there is at least one more value for a block\r\n      const row = [];\r\n      i1 = i + numPerBlock;\r\n      if (i1 > n)\r\n        i1 = n;\r\n      for (; i < i1; i++) {\r\n        row.push(data[i]);\r\n      }\r\n      result.push(row);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * return an 3-dimensional array containing all the values of `data` in arrays numPerRow blocks of numPerBlock\r\n   * @param data simple array of numbers\r\n   * @param numPerBlock number of values in each block at first level down\r\n   */\r\n  public static unpackNumbersToNestedArraysIJK(data: Float64Array, numPerBlock: number, numPerRow: number): any[] {\r\n    const result = [];\r\n    const n = data.length;\r\n    let i = 0;\r\n    let i1 = 0;\r\n    let i2;\r\n    while (i < n) {\r\n      const row = [];\r\n      i2 = i + numPerBlock * numPerRow;\r\n      while (i < i2) {\r\n        const block = [];\r\n        i1 = i + numPerBlock;\r\n        if (i1 > n)\r\n          i1 = n;\r\n        for (; i < i1; i++) {\r\n          block.push(data[i]);\r\n        }\r\n        row.push(block);\r\n      }\r\n      result.push(row);\r\n    }\r\n    return result;\r\n  }\r\n  /**  multiply a transform times each x,y,z triple and replace the x,y,z in the packed array */\r\n  public static multiplyInPlace(transform: Transform, xyz: Float64Array): void {\r\n    const xyz1 = Point3d.create();\r\n    const numXYZ = xyz.length;\r\n    for (let i = 0; i + 2 < numXYZ; i += 3) {\r\n      transform.multiplyXYZ(xyz[i], xyz[i + 1], xyz[i + 2], xyz1);\r\n      xyz[i] = xyz1.x;\r\n      xyz[i + 1] = xyz1.y;\r\n      xyz[i + 2] = xyz1.z;\r\n    }\r\n  }\r\n  /** Apply Geometry.isAlmostEqual to corresponding coordinates */\r\n  public static isAlmostEqual(dataA: Point3d[] | Float64Array | undefined, dataB: Point3d[] | Float64Array | undefined): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      if (dataA instanceof Float64Array && dataB instanceof Float64Array) {\r\n        for (let i = 0; i < dataA.length; i++)\r\n          if (!Geometry.isSameCoordinate(dataA[i], dataB[i]))\r\n            return false;\r\n      } else if (Array.isArray(dataA) && Array.isArray(dataB)) {\r\n        for (let i = 0; i < dataA.length; i++)\r\n          if (!dataA[i].isAlmostEqual(dataB[i]))\r\n            return false;\r\n      }\r\n      return true;\r\n    }\r\n    // if both are null it is equal, otherwise unequal\r\n    return (dataA === undefined && dataB === undefined);\r\n  }\r\n\r\n  /** return simple average of all coordinates.   (000 if empty array) */\r\n  public static centroid(points: IndexedXYZCollection, result?: Point3d): Point3d {\r\n    result = Point3d.create(0, 0, 0, result);\r\n    const p = Point3d.create();\r\n    if (points.length > 0) {\r\n      for (let i = 0; i < points.length; i++) {\r\n        points.getPoint3dAtCheckedPointIndex(i, p);\r\n        result.x += p.x; result.y += p.y; result.z += p.z;\r\n      }\r\n      result.scaleInPlace(1.0 / points.length);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Return the index of the point most distant from spacePoint */\r\n  public static indexOfMostDistantPoint(points: Point3d[], spacePoint: XYZ, farVector: Vector3d): number | undefined {\r\n    if (points.length === 0)\r\n      return undefined;\r\n    let dMax = -1;\r\n    let d;\r\n    let result = -1;\r\n    for (let i = 0; i < points.length; i++) {\r\n      d = spacePoint.distance(points[i]);\r\n      if (d > dMax) {\r\n        spacePoint.vectorTo(points[i], farVector);\r\n        dMax = d;\r\n        result = i;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** return the index of the point whose vector from space point has the largest magnitude of cross product with given vector. */\r\n  public static indexOfPointWithMaxCrossProductMagnitude(points: Point3d[], spacePoint: Point3d, vector: Vector3d, farVector: Vector3d): number | undefined {\r\n    if (points.length === 0)\r\n      return undefined;\r\n    let dMax = -1;\r\n    let d;\r\n    let result = -1;\r\n    let vectorAB; // to be reused in loop !!!\r\n    for (let i = 0; i < points.length; i++) {\r\n      vectorAB = spacePoint.vectorTo(points[i], vectorAB);\r\n      d = vectorAB.crossProductMagnitude(vector);\r\n      if (d > dMax) {\r\n        farVector.setFrom(vectorAB);\r\n        dMax = d;\r\n        result = i;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Return the index of the closest point in the array (full xyz) */\r\n  public static closestPointIndex(data: XYAndZ[], spacePoint: XYAndZ): number {\r\n    let index = -1;\r\n    let dMin = Number.MAX_VALUE;\r\n    let d;\r\n    const x0 = spacePoint.x;\r\n    const y0 = spacePoint.y;\r\n    const z0 = spacePoint.z;\r\n    for (let i = 0; i < data.length; i++) {\r\n      d = Geometry.distanceXYZXYZ(x0, y0, z0, data[i].x, data[i].y, data[i].z);\r\n      if (d < dMin) {\r\n        index = i;\r\n        dMin = d;\r\n      }\r\n    }\r\n    return index;\r\n  }\r\n  /** return true iff all points' altitudes are within tolerance of the plane.*/\r\n  public static isCloseToPlane(data: Point3d[] | Float64Array, plane: Plane3dByOriginAndUnitNormal, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    if (Array.isArray(data)) {\r\n      let xyz;\r\n      for (xyz of data) {\r\n        if (Math.abs(plane.altitude(xyz)) > tolerance)\r\n          return false;\r\n      }\r\n    } else if (data instanceof Float64Array) {\r\n      const numXYZ = data.length;\r\n      for (let i = 0; i + 2 < numXYZ; i += 3) {\r\n        if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)\r\n          return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Sum lengths of edges.\r\n   * @param data points.\r\n   */\r\n  public static sumEdgeLengths(data: Point3d[] | Float64Array, addClosureEdge: boolean = false): number {\r\n    let sum = 0.0;\r\n    if (Array.isArray(data)) {\r\n      const n = data.length - 1;\r\n      for (let i = 0; i < n; i++) sum += data[i].distance(data[i + 1]);\r\n      if (addClosureEdge && n > 0)\r\n        sum += data[0].distance(data[n]);\r\n\r\n    } else if (data instanceof Float64Array) {\r\n      const numXYZ = data.length;\r\n      let i = 0;\r\n      for (; i + 5 < numXYZ; i += 3) {  // final i points at final point x\r\n        sum += Geometry.hypotenuseXYZ(data[i + 3] - data[i],\r\n          data[i + 4] - data[i + 1],\r\n          data[i + 5] - data[i + 2]);\r\n      }\r\n      if (addClosureEdge && i >= 3) {\r\n        sum += Geometry.hypotenuseXYZ(data[0] - data[i],\r\n          data[1] - data[i + 1],\r\n          data[2] - data[i + 2]);\r\n      }\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Return an array containing clones of the Point3d data[]\r\n   * @param data source data\r\n   */\r\n  public static clonePoint3dArray(data: XYAndZ[]): Point3d[] {\r\n    return data.map((p: XYAndZ) => Point3d.create(p.x, p.y, p.z));\r\n  }\r\n\r\n  /**\r\n   * Return an array containing Point2d with xy parts of each Point3d\r\n   * @param data source data\r\n   */\r\n  public static clonePoint2dArray(data: XYAndZ[]): Point2d[] {\r\n    return data.map((p: XYAndZ) => Point2d.create(p.x, p.y));\r\n  }\r\n  /**\r\n   * clone points in the input array, inserting points within each edge to limit edge length.\r\n   * @param points array of points\r\n   * @param maxEdgeLength max length of an edge\r\n   */\r\n  public static cloneWithMaxEdgeLength(points: Point3d[], maxEdgeLength: number): Point3d[] {\r\n    if (points.length === 0)\r\n      return [];\r\n    const result = [points[0]];\r\n    for (let i = 1; i < points.length; i++) {\r\n      const a = points[i - 1].distance(points[i]);\r\n      const n = Geometry.stepCount(maxEdgeLength, a, 1);\r\n      for (let k = 1; k < n; k++)\r\n        result.push(points[i - 1].interpolate(k / n, points[i]));\r\n      result.push(points[i]);\r\n\r\n    }\r\n    return result;\r\n  }\r\n  /** Pack isolated x,y,z args as a json `[x,y,z]` */\r\n  private static xyzToArray(x: number, y: number, z: number): number[] { return [x, y, z]; }\r\n\r\n  /**\r\n   * return similarly-structured array, array of arrays, etc, with the lowest level point data specifically structured as arrays of 3 numbers `[1,2,3]`\r\n   * @param data point data with various leaf forms such as `[1,2,3]`, `{x:1,y:2,z:3}`, `Point3d`\r\n   */\r\n  public static cloneDeepJSONNumberArrays(data: MultiLineStringDataVariant): any[] {\r\n    const collector = new PointStringDeepXYZArrayCollector(this.xyzToArray);\r\n    VariantPointDataStream.streamXYZ(data, collector);\r\n    return collector.claimResult();\r\n  }\r\n  /**\r\n   * return similarly-structured array, array of arrays, etc, with the lowest level point data specifically structured as `Point3d`.\r\n   * @param data point data with various leaf forms such as `[1,2,3]`, `{x:1,y:2,z:3}`, `Point3d`\r\n   */\r\n  public static cloneDeepXYZPoint3dArrays(data: MultiLineStringDataVariant): any[] {\r\n    const collector = new PointStringDeepXYZArrayCollector(Point3d.create);\r\n    VariantPointDataStream.streamXYZ(data, collector);\r\n    return collector.claimResult();\r\n  }\r\n  /**\r\n   * `Point3dArray.createRange(data)` is deprecated.  Used `Range3d.createFromVariantData(data: MultiLineStringDataVariant): Range3d`\r\n   * @deprecated Use Range3d.createFromVariantData (data)\r\n   * @param data\r\n   */\r\n  public static createRange(data: MultiLineStringDataVariant): Range3d { return Range3d.createFromVariantData(data); }\r\n  private static _workPoint?: Point3d;\r\n  /**\r\n   * `Point3dArray.streamXYZ` is deprecated -- use `VariantPointStream.streamXYZ (handler)`\r\n   * @deprecated - use VariantPointStream.streamXYZ (handler)\r\n   * Invoke a callback with each x,y,z from an array of points in variant forms.\r\n   * @param startChainCallback called to announce the beginning of points (or recursion)\r\n   * @param pointCallback (index, x,y,z) = function to receive point coordinates one by one\r\n   * @param endChainCallback called to announce the end of handling of an array.\r\n   */\r\n  public static streamXYZ(data: MultiLineStringDataVariant,\r\n    startChainCallback: ((chainData: MultiLineStringDataVariant, isLeaf: boolean) => void) | undefined,\r\n    pointCallback: (x: number, y: number, z: number) => void,\r\n    endChainCallback: ((chainData: MultiLineStringDataVariant, isLeaf: boolean) => void) | undefined) {\r\n    let numPoint = 0;\r\n    if (Array.isArray(data)) {\r\n      // If the first entry is a point, expect the entire array to be points.\r\n      // otherwise recurse to each member of this array.\r\n      if (data.length > 0 && Point3d.isAnyImmediatePointType(data[0])) {\r\n        if (startChainCallback)\r\n          startChainCallback(data, true);\r\n        for (const p of data) {\r\n          const x = Point3d.accessX(p);\r\n          const y = Point3d.accessY(p);\r\n          const z = Point3d.accessZ(p, 0) as number;\r\n          if (x !== undefined && y !== undefined)\r\n            pointCallback(x, y, z);\r\n          numPoint++;\r\n        }\r\n        if (endChainCallback)\r\n          endChainCallback(data, true);\r\n      } else {\r\n        // This is an array that does not immediately have points.\r\n        if (startChainCallback)\r\n          startChainCallback(data, false);\r\n        for (const child of data) {\r\n          // tslint:disable-next-line: deprecation\r\n          numPoint += this.streamXYZ((child as unknown) as LineStringDataVariant, startChainCallback, pointCallback, endChainCallback);\r\n        }\r\n        if (endChainCallback)\r\n          endChainCallback(data, false);\r\n      }\r\n    } else if (data instanceof IndexedXYZCollection) {\r\n      if (startChainCallback)\r\n        startChainCallback(data, true);\r\n      const q = Point3dArray._workPoint = Point3d.create(0, 0, 0, Point3dArray._workPoint);\r\n      for (let i = 0; i < data.length; i++) {\r\n        data.getPoint3dAtCheckedPointIndex(i, q);\r\n        numPoint++;\r\n        pointCallback(q.x, q.y, q.z);\r\n      }\r\n      if (endChainCallback)\r\n        endChainCallback(data, true);\r\n    }\r\n    return numPoint;\r\n  }\r\n  /**\r\n     * `Point3dArray.streamXYZXYZ` is deprecated -- use `VariantPointStream.streamXYZXYZ (handler)`\r\n   * @deprecated - use VariantPointStream.streamXYZXYZ (handler)\r\n   * Invoke a callback with each x,y,z from an array of points in variant forms.\r\n   * @param startChainCallback callback of the form `startChainCallback (source, isLeaf)` to be called with the source array at each level.\r\n   * @param segmentCallback callback of the form `segmentCallback (index0, x0,y0,z0, index1, x1,y1,z1)`\r\n   * @param endChainCallback callback of the form `endChainCallback (source, isLeaf)` to be called with the source array at each level.\r\n  */\r\n  public static streamXYZXYZ(data: MultiLineStringDataVariant,\r\n    startChainCallback: ((chainData: MultiLineStringDataVariant, isLeaf: boolean) => void) | undefined,\r\n    segmentCallback: (x0: number, y0: number, z0: number, x1: number, y1: number, z1: number) => void,\r\n    endChainCallback: ((chainData: MultiLineStringDataVariant, isLeaf: boolean) => void) | undefined): number {\r\n    let x0 = 0, y0 = 0, z0 = 0, x1, y1, z1;\r\n    let point0Known = false;\r\n    let numSegment = 0;\r\n    if (Array.isArray(data)) {\r\n      if (data.length > 0 && Point3d.isAnyImmediatePointType(data[0])) {\r\n        if (startChainCallback)\r\n          startChainCallback(data, true);\r\n        for (const p of data) {\r\n          x1 = Point3d.accessX(p);\r\n          y1 = Point3d.accessY(p);\r\n          z1 = Point3d.accessZ(p, 0) as number;\r\n          if (x1 !== undefined && y1 !== undefined) {\r\n            if (point0Known) {\r\n              segmentCallback(x0, y0, z0, x1, y1, z1);\r\n              numSegment++;\r\n            }\r\n            point0Known = true; x0 = x1; y0 = y1; z0 = z1;\r\n          }\r\n        }\r\n        if (endChainCallback)\r\n          endChainCallback(data, true);\r\n      } else {\r\n        // This is an array that does not immediately have points.\r\n        if (startChainCallback)\r\n          startChainCallback(data, false);\r\n        for (const child of data) {\r\n          // tslint:disable-next-line: deprecation\r\n          numSegment += this.streamXYZXYZ((child as unknown) as LineStringDataVariant, startChainCallback, segmentCallback, endChainCallback);\r\n        }\r\n        if (endChainCallback)\r\n          endChainCallback(data, false);\r\n      }\r\n    } else if (data instanceof IndexedXYZCollection) {\r\n      if (startChainCallback)\r\n        startChainCallback(data, true);\r\n      const q = Point3dArray._workPoint = Point3d.create(0, 0, 0, Point3dArray._workPoint);\r\n      for (let i = 0; i < data.length; i++) {\r\n        data.getPoint3dAtCheckedPointIndex(i, q);\r\n        if (i > 0) {\r\n          numSegment++;\r\n          segmentCallback(x0, y0, z0, q.x, q.y, q.z);\r\n        }\r\n        x0 = q.x;\r\n        y0 = q.y;\r\n        z0 = q.z;\r\n      }\r\n      if (endChainCallback)\r\n        endChainCallback(data, true);\r\n    }\r\n    return numSegment;\r\n  }\r\n\r\n  /** Computes the hull of the XY projection of points.\r\n   * * Returns the hull as an array of Point3d\r\n   * * Optionally returns non-hull points in `insidePoints[]`\r\n   * * If both arrays empty if less than 3 points.\r\n   * *\r\n   */\r\n  public static computeConvexHullXY(points: Point3d[], hullPoints: Point3d[], insidePoints: Point3d[], addClosurePoint: boolean = false) {\r\n    hullPoints.length = 0;\r\n    insidePoints.length = 0;\r\n    let n = points.length;\r\n    // Get deep copy\r\n    const xy1: Point3d[] = points.slice(0, n);\r\n    xy1.sort(Geometry.lexicalXYLessThan);\r\n    if (n < 3) {\r\n      for (const p of xy1)\r\n        hullPoints.push(p);\r\n      if (addClosurePoint && xy1.length > 0)\r\n        hullPoints.push(xy1[0]);\r\n      return;\r\n    }\r\n    hullPoints.push(xy1[0]); // This is sure to stay\r\n    hullPoints.push(xy1[1]); // This one can be removed in loop.\r\n    let numInside = 0;\r\n    // First sweep creates upper hull\r\n    for (let i = 2; i < n; i++) {\r\n      const candidate = xy1[i];\r\n      let top = hullPoints.length - 1;\r\n      while (top >= 1 && hullPoints[top - 1].crossProductToPointsXY(hullPoints[top], candidate) <= 0.0) {\r\n        xy1[numInside++] = hullPoints[top];\r\n        top--;\r\n        hullPoints.pop();\r\n      }\r\n      hullPoints.push(candidate);\r\n    }\r\n    const i0 = hullPoints.length - 1;\r\n    xy1.length = numInside;\r\n    xy1.push(hullPoints[0]);    // force first point to be reconsidered as final hull point.\r\n    xy1.sort(Geometry.lexicalXYLessThan);\r\n    n = xy1.length;\r\n    // xy1.back () is already on stack.\r\n    hullPoints.push(xy1[n - 1]);\r\n    for (let i = n - 1; i-- > 0;) {\r\n      const candidate = xy1[i];\r\n      let top = hullPoints.length - 1;\r\n      while (top > i0 && hullPoints[top - 1].crossProductToPointsXY(hullPoints[top], candidate) <= 0.0) {\r\n        insidePoints.push(hullPoints[top]);\r\n        top--;\r\n        hullPoints.pop();\r\n      }\r\n      if (i > 0)    // don't replicate start !!!\r\n        hullPoints.push(candidate);\r\n    }\r\n    if (addClosurePoint)\r\n      hullPoints.push(hullPoints[0]);\r\n  }\r\n  /**\r\n   * Return (clones of) points in data[] with min and max x and y parts.\r\n   * @param data array to examine.\r\n   */\r\n  public static minMaxPoints(data: Point3d[]): { minXPoint: Point3d, maxXPoint: Point3d, minYPoint: Point3d, maxYPoint: Point3d } | undefined {\r\n    if (data.length === 0)\r\n      return undefined;\r\n    const result = { minXPoint: data[0].clone(), maxXPoint: data[0].clone(), minYPoint: data[0].clone(), maxYPoint: data[0].clone() };\r\n    let q;\r\n    for (let i = 1; i < data.length; i++) {\r\n      q = data[i];\r\n      if (q.x < result.minXPoint.x) result.minXPoint.setFromPoint3d(q);\r\n      if (q.x > result.maxXPoint.x) result.maxXPoint.setFromPoint3d(q);\r\n      if (q.y < result.minYPoint.y) result.minYPoint.setFromPoint3d(q);\r\n      if (q.y > result.maxYPoint.y) result.maxYPoint.setFromPoint3d(q);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { Point3d } from \"./Point3dVector3d\";\r\nimport { MultiLineStringDataVariant, LineStringDataVariant } from \"../topology/Triangulation\";\r\nimport { IndexedXYZCollection } from \"./IndexedXYZCollection\";\r\nimport { Range3d } from \"./Range\";\r\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\r\n//\r\n// remarks: point array variants . . .\r\n//  * [[x,y,z], ...]\r\n//  * [[Point3d, Point3d]\r\n//  * [GrowableXYZArray, ..]\r\n//\r\n/**\r\n * \"no-op\" base class for stream handlers\r\n * @internal\r\n */\r\nexport class PointStreamXYZHandlerBase {\r\n  public startChain(_chainData: MultiLineStringDataVariant, _isLeaf: boolean): void { }\r\n  public handleXYZ(_x: number, _y: number, _z: number): void { }\r\n  public endChain(_chainData: MultiLineStringDataVariant, _isLeaf: boolean): void { }\r\n}\r\n/** Base class for handling points in pairs.\r\n * * Callers implement handleXYZXYZ to receive point pairs.\r\n * * Callers may implement startChain and endChain.\r\n *   * Beware that if startChain is implemented it must call super.startChain () to reset internal x0, y0,z0 to undefined.\r\n *   * If that is not done, a point pair will appear from the end of previous chain to start of new chain.\r\n *   * This (intermediate base) class does NOT override startChain\r\n */\r\nexport class PointStreamXYZXYZHandlerBase extends PointStreamXYZHandlerBase {\r\n  private _x0?: number;\r\n  private _y0?: number;\r\n  private _z0?: number;\r\n  public handleXYZ(x: number, y: number, z: number): void {\r\n    if (this._x0 !== undefined)\r\n      this.handleXYZXYZ(this._x0!, this._y0!, this._z0!, x, y, z);\r\n    this._x0 = x;\r\n    this._y0 = y;\r\n    this._z0 = z;\r\n  }\r\n  public startChain(_chainData: MultiLineStringDataVariant, _isLeaf: boolean): void {\r\n    this._x0 = this._y0 = this._z0 = undefined;\r\n  }\r\n  /**\r\n   * Handler function called successively for each point0, point1 pair.  Concrete class should implement this.\r\n   * @param _x0 x coordinate at point 0\r\n   * @param _y0 y coordinate of point 0\r\n   * @param _z0 z coordinate of point 0\r\n   * @param _x1 x coordinate of point 1\r\n   * @param _y1 y coordinate of point 1\r\n   * @param _z1 z coordinate of point 1\r\n   */\r\n  public handleXYZXYZ(_x0: number, _y0: number, _z0: number, _x1: number, _y1: number, _z1: number): void { }\r\n}\r\n/**\r\n * Concrete class to handle startChain, handleXYZ and endChain calls and return a (one-level deep array of\r\n * GrowableXYZArray\r\n */\r\nexport class PointStreamGrowableXYZArrayCollector extends PointStreamXYZHandlerBase {\r\n  private _pointArrays?: GrowableXYZArray[];\r\n  private _currentData?: GrowableXYZArray;\r\n  public startChain(_chainData: MultiLineStringDataVariant, _isLeaf: boolean): void {\r\n    this._currentData = undefined;\r\n  }\r\n  public handleXYZ(x: number, y: number, z: number): void {\r\n    if (!this._currentData)\r\n      this._currentData = new GrowableXYZArray();\r\n    this._currentData.pushXYZ(x, y, z);\r\n  }\r\n  public endChain(_chainData: MultiLineStringDataVariant, _isLeaf: boolean): void {\r\n    if (this._currentData !== undefined) {\r\n      if (this._pointArrays === undefined)\r\n        this._pointArrays = [];\r\n      this._pointArrays.push(this._currentData);\r\n      this._currentData = undefined;\r\n    }\r\n  }\r\n  /** Return MultiLineStringDataVariant as an array of GrowableXYZArray */\r\n  public claimArrayOfGrowableXYZArray(): GrowableXYZArray[] | undefined {\r\n    const result = this._pointArrays;\r\n    this._pointArrays = undefined;\r\n    return result;\r\n  }\r\n}\r\n/**\r\n * PointStream handler to collect the range of points.\r\n */\r\nexport class PointStreamRangeCollector extends PointStreamXYZHandlerBase {\r\n  private _range?: Range3d = Range3d.createNull();\r\n  public handleXYZ(x: number, y: number, z: number): void {\r\n    if (!this._range)\r\n      this._range = Range3d.createNull();\r\n    this._range.extendXYZ(x, y, z);\r\n  }\r\n  public claimResult(): Range3d {\r\n    const range = this._range;\r\n    this._range = undefined;\r\n    if (!range)\r\n      return Range3d.createNull();\r\n    return range;\r\n  }\r\n}\r\n\r\nexport class PointStringDeepXYZArrayCollector {\r\n  // The 0 entry in this stack \"should\" always end up as a single array.\r\n  // Hypothetically some caller might have do start-end that put multiple things\r\n  // there.  Hence the 0 entry (not the array itself) is the collected result.\r\n  private _resultStack: any[];\r\n  private _xyzFunction: (x: number, y: number, z: number) => any;\r\n  /**\r\n   *\r\n   * @param xyzFunction function to map (x,y,z) to the leaf object type in the arrays.\r\n   */\r\n  public constructor(xyzFunction: (x: number, y: number, z: number) => any) {\r\n    this._xyzFunction = xyzFunction;\r\n    this._resultStack = [];\r\n    // create the [0] placeholder.\r\n    this._resultStack.push ([]);\r\n  }\r\n\r\n  public startChain(_chainData: MultiLineStringDataVariant, _isLeaf: boolean): void {\r\n    this._resultStack.push([]);\r\n  }\r\n\r\n  public handleXYZ(x: number, y: number, z: number): void {\r\n    this._resultStack[this._resultStack.length - 1].push(this._xyzFunction(x, y, z));\r\n  }\r\n  public endChain(_chainData: MultiLineStringDataVariant, _isLeaf: boolean): void {\r\n    const q = this._resultStack[this._resultStack.length - 1];\r\n    this._resultStack.pop();\r\n    this._resultStack[this._resultStack.length - 1].push(q);\r\n  }\r\n\r\n  public claimResult(): any[] {\r\n    const r = this._resultStack[0];\r\n    if (r.length === 1)\r\n      return r[0];\r\n    return r;\r\n  }\r\n}\r\n/**\r\n * class for converting variant point data into more specific forms.\r\n * @internal\r\n */\r\nexport class VariantPointDataStream {\r\n  private static _workPoint?: Point3d;\r\n  /** Invoke a callback with each x,y,z from an array of points in variant forms.\r\n   * @param startChainCallback called to announce the beginning of points (or recursion)\r\n   * @param pointCallback (index, x,y,z) = function to receive point coordinates one by one\r\n   * @param endChainCallback called to announce the end of handling of an array.\r\n   */\r\n  public static streamXYZ(data: MultiLineStringDataVariant, handler: PointStreamXYZHandlerBase) {\r\n    let numPoint = 0;\r\n    if (Array.isArray(data)) {\r\n      // If the first entry is a point, expect the entire array to be points.\r\n      // otherwise recurse to each member of this array.\r\n      if (data.length > 0 && Point3d.isAnyImmediatePointType(data[0])) {\r\n        handler.startChain(data, true);\r\n        for (const p of data) {\r\n          const x = Point3d.accessX(p);\r\n          const y = Point3d.accessY(p);\r\n          const z = Point3d.accessZ(p, 0) as number;\r\n          if (x !== undefined && y !== undefined)\r\n            handler.handleXYZ(x, y, z);\r\n          numPoint++;\r\n        }\r\n        handler.endChain(data, true);\r\n      } else {\r\n        // This is an array that does not immediately have points.\r\n        handler.startChain(data, false);\r\n        for (const child of data) {\r\n          numPoint += this.streamXYZ((child as unknown) as LineStringDataVariant, handler);\r\n        }\r\n        handler.endChain(data, false);\r\n      }\r\n    } else if (data instanceof IndexedXYZCollection) {\r\n      handler.startChain(data, true);\r\n      const q = VariantPointDataStream._workPoint = Point3d.create(0, 0, 0, VariantPointDataStream._workPoint);\r\n      for (let i = 0; i < data.length; i++) {\r\n        data.getPoint3dAtCheckedPointIndex(i, q);\r\n        numPoint++;\r\n        handler.handleXYZ(q.x, q.y, q.z);\r\n      }\r\n      handler.endChain(data, true);\r\n    }\r\n    return numPoint;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\nimport { Geometry, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\r\nimport { XAndY } from \"./XYZProps\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Ray3d } from \"./Ray3d\";\r\nimport { IndexedXYZCollection, IndexedReadWriteXYZCollection } from \"./IndexedXYZCollection\";\r\nimport { Point3dArrayCarrier } from \"./Point3dArrayCarrier\";\r\nimport { XYParitySearchContext } from \"../topology/XYParitySearchContext\";\r\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\r\nimport { Range3d, Range1d } from \"./Range\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\n\r\n/** Static class for operations that treat an array of points as a polygon (with area!) */\r\n/**\r\n * Various (static method) computations for arrays of points interpreted as a polygon.\r\n * @public\r\n */\r\nexport class PolygonOps {\r\n  /** Sum areas of triangles from points[0] to each far edge.\r\n   * * Consider triangles from points[0] to each edge.\r\n   * * Sum the areas(absolute, without regard to orientation) all these triangles.\r\n   * @returns sum of absolute triangle areas.\r\n   */\r\n  public static sumTriangleAreas(points: Point3d[] | GrowableXYZArray): number {\r\n    let s = 0;\r\n    const n = points.length;\r\n    if (Array.isArray(points)) {\r\n      if (n >= 3) {\r\n        const origin = points[0];\r\n        const vector0 = origin.vectorTo(points[1]);\r\n        let vector1 = Vector3d.create();\r\n        // This will work with or without closure edge.  If closure is given, the last vector is 000.\r\n        for (let i = 2; i < n; i++) {\r\n          vector1 = origin.vectorTo(points[i], vector1);\r\n          s += vector0.crossProductMagnitude(vector1);\r\n          vector0.setFrom(vector1);\r\n        }\r\n      }\r\n      return s * 0.5;\r\n    }\r\n    const crossVector = Vector3d.create();\r\n    for (let i = 2; i < n; i++) {\r\n      points.crossProductIndexIndexIndex(0, i - 1, i, crossVector);\r\n      s += crossVector.magnitude();\r\n    }\r\n    return s * 0.5;\r\n  }\r\n  /** Sum areas of triangles from points[0] to each far edge.\r\n   * * Consider triangles from points[0] to each edge.\r\n   * * Sum the areas(absolute, without regard to orientation) all these triangles.\r\n   * @returns sum of absolute triangle areas.\r\n   */\r\n  public static sumTriangleAreasXY(points: Point3d[]): number {\r\n    let s = 0.0;\r\n    const n = points.length;\r\n    if (n >= 3) {\r\n      const origin = points[0];\r\n      const vector0 = origin.vectorTo(points[1]);\r\n      let vector1 = Vector3d.create();\r\n      // This will work with or without closure edge.  If closure is given, the last vector is 000.\r\n      for (let i = 2; i < n; i++) {\r\n        vector1 = origin.vectorTo(points[i], vector1);\r\n        s += vector0.crossProductXY(vector1);\r\n        vector0.setFrom(vector1);\r\n      }\r\n    }\r\n    s *= 0.5;\r\n    // console.log (\"polygon area \", s, points);\r\n    return s;\r\n  }\r\n  /** These values are the integrated area moment products [xx,xy,xz, x]\r\n   * for a right triangle in the first quadrant at the origin -- (0,0),(1,0),(0,1)\r\n   */\r\n  private static readonly _triangleMomentWeights = Matrix4d.createRowValues(2.0 / 24.0, 1.0 / 24.0, 0, 4.0 / 24.0, 1.0 / 24.0, 2.0 / 24.0, 0, 4.0 / 24.0, 0, 0, 0, 0, 4.0 / 24.0, 4.0 / 24.0, 0, 12.0 / 24.0);\r\n  /** These values are the integrated volume moment products [xx,xy,xz, x, yx,yy,yz,y, zx,zy,zz,z,x,y,z,1]\r\n   * for a tetrahedron in the first quadrant at the origin -- (0,00),(1,0,0),(0,1,0),(0,0,1)\r\n   */\r\n  private static readonly _tetrahedralMomentWeights = Matrix4d.createRowValues(\r\n    1.0 / 60.0, 1.0 / 120, 1.0 / 120, 1.0 / 24.0,\r\n    1.0 / 120, 1.0 / 60.0, 1.0 / 120, 1.0 / 24.0,\r\n    1.0 / 120, 1.0 / 120, 1.0 / 60.0, 1.0 / 24.0,\r\n    1.0 / 24.0, 1.0 / 24.0, 1.0 / 24.0, 1.0 / 6.0);\r\n  // statics for shared reuse.\r\n  // many methods use these.\r\n  // only use them in \"leaf\" methods that are certain not to call other users . . .\r\n  private static _vector0 = Vector3d.create();\r\n  private static _vector1 = Vector3d.create();\r\n  private static _vector2 = Vector3d.create();\r\n  private static _vectorOrigin = Vector3d.create();\r\n  private static _normal = Vector3d.create();\r\n  private static _matrixA = Matrix4d.createIdentity();\r\n  private static _matrixB = Matrix4d.createIdentity();\r\n  private static _matrixC = Matrix4d.createIdentity();\r\n  /** return a vector which is perpendicular to the polygon and has magnitude equal to the polygon area. */\r\n  public static areaNormalGo(points: IndexedXYZCollection, result?: Vector3d): Vector3d | undefined {\r\n    if (!result)\r\n      result = new Vector3d();\r\n    const n = points.length;\r\n    if (n === 3) {\r\n      points.crossProductIndexIndexIndex(0, 1, 2, result);\r\n    } else if (n >= 3) {\r\n      result.setZero();\r\n      // This will work with or without closure edge.  If closure is given, the last vector is 000.\r\n      for (let i = 2; i < n; i++) {\r\n        points.accumulateCrossProductIndexIndexIndex(0, i - 1, i, result);\r\n      }\r\n    }\r\n    // ALL BRANCHES SUM FULL CROSS PRODUCTS AND EXPECT SCALE HERE\r\n    result.scaleInPlace(0.5);\r\n    return result;\r\n  }\r\n  /** return a vector which is perpendicular to the polygon and has magnitude equal to the polygon area. */\r\n  public static areaNormal(points: Point3d[], result?: Vector3d): Vector3d {\r\n    if (!result)\r\n      result = Vector3d.create();\r\n    PolygonOps.areaNormalGo(new Point3dArrayCarrier(points), result);\r\n    return result;\r\n  }\r\n  /** return the area of the polygon.\r\n   * * This assumes the polygon is planar\r\n   * * This does NOT assume the polygon is on the xy plane.\r\n   */\r\n  public static area(points: Point3d[]): number {\r\n    return PolygonOps.areaNormal(points).magnitude();\r\n  }\r\n  /** return the projected XY area of the polygon. */\r\n  public static areaXY(points: Point3d[] | IndexedXYZCollection): number {\r\n    let area = 0.0;\r\n    if (points instanceof IndexedXYZCollection) {\r\n      if (points.length > 2) {\r\n        const x0 = points.getXAtUncheckedPointIndex(0);\r\n        const y0 = points.getYAtUncheckedPointIndex(0);\r\n        let u1 = points.getXAtUncheckedPointIndex(1) - x0;\r\n        let v1 = points.getYAtUncheckedPointIndex(1) - y0;\r\n        let u2, v2;\r\n        for (let i = 1; i + 1 < points.length; i++ , u1 = u2, v1 = v2) {\r\n          u2 = points.getXAtUncheckedPointIndex(i) - x0;\r\n          v2 = points.getYAtUncheckedPointIndex(i) - y0;\r\n          area += Geometry.crossProductXYXY(u1, v1, u2, v2);\r\n        }\r\n      }\r\n    } else {\r\n      for (let i = 1; i + 1 < points.length; i++)\r\n        area += points[0].crossProductToPointsXY(points[i], points[i + 1]);\r\n    }\r\n    return 0.5 * area;\r\n  }\r\n  /**\r\n   * Return a Ray3d with (assuming the polygon is planar and not self-intersecting)\r\n   * * origin at the centroid of the (3D) polygon\r\n   * * normal is a unit vector perpendicular to the plane\r\n   * * 'a' member is the area.\r\n   * @param points\r\n   */\r\n  public static centroidAreaNormal(points: IndexedXYZCollection | Point3d[]): Ray3d | undefined {\r\n    if (Array.isArray(points)) {\r\n      const carrier = new Point3dArrayCarrier(points);\r\n      return this.centroidAreaNormal(carrier);\r\n    } else if (points instanceof IndexedXYZCollection) {\r\n      return this.centroidAreaNormalGo(points);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a Ray3d with (assuming the polygon is planar and not self-intersecting)\r\n   * * origin at the centroid of the (3D) polygon\r\n   * * normal is a unit vector perpendicular to the plane\r\n   * * 'a' member is the area.\r\n   * @param points\r\n   */\r\n  private static centroidAreaNormalGo(points: IndexedXYZCollection | Point3d[]): Ray3d | undefined {\r\n    if (Array.isArray(points)) {\r\n      const carrier = new Point3dArrayCarrier(points);\r\n      return this.centroidAreaNormal(carrier);\r\n    }\r\n    const n = points.length;\r\n    if (n === 3) {\r\n      const normal = points.crossProductIndexIndexIndex(0, 1, 2)!;\r\n      const a = 0.5 * normal.magnitude();\r\n      const centroid = points.getPoint3dAtCheckedPointIndex(0)!;\r\n      points.accumulateScaledXYZ(1, 1.0, centroid);\r\n      points.accumulateScaledXYZ(2, 1.0, centroid);\r\n      centroid.scaleInPlace(1.0 / 3.0);\r\n      const result = Ray3d.createCapture(centroid, normal);\r\n      if (result.tryNormalizeInPlaceWithAreaWeight(a))\r\n        return result;\r\n      return undefined;\r\n    }\r\n    if (n >= 3) {\r\n\r\n      const areaNormal = Vector3d.createZero();\r\n      // This will work with or without closure edge.  If closure is given, the last vector is 000.\r\n      for (let i = 2; i < n; i++) {\r\n        points.accumulateCrossProductIndexIndexIndex(0, i - 1, i, areaNormal);\r\n      }\r\n      areaNormal.normalizeInPlace();\r\n\r\n      const origin = points.getPoint3dAtCheckedPointIndex(0)!;\r\n      const vector0 = Vector3d.create();\r\n      const vector1 = Vector3d.create();\r\n      points.vectorXYAndZIndex(origin, 1, vector0);\r\n      let cross = Vector3d.create();\r\n      const centroidSum = Vector3d.createZero();\r\n      const normalSum = Vector3d.createZero();\r\n      let signedTriangleArea;\r\n      // This will work with or without closure edge.  If closure is given, the last vector is 000.\r\n      for (let i = 2; i < n; i++) {\r\n        points.vectorXYAndZIndex(origin, i, vector1);\r\n        cross = vector0.crossProduct(vector1, cross);\r\n        signedTriangleArea = areaNormal.dotProduct(cross);    // well, actually twice the area.\r\n        normalSum.addInPlace(cross); // this grows to twice the area\r\n        const b = signedTriangleArea / 6.0;\r\n        centroidSum.plus2Scaled(vector0, b, vector1, b, centroidSum);\r\n        vector0.setFrom(vector1);\r\n      }\r\n      const area = 0.5 * normalSum.magnitude();\r\n      const inverseArea = Geometry.conditionalDivideFraction(1, area);\r\n      if (inverseArea !== undefined) {\r\n        const result = Ray3d.createCapture(origin.plusScaled(centroidSum, inverseArea), normalSum);\r\n        result.tryNormalizeInPlaceWithAreaWeight(area);\r\n        return result;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  // Has the potential to be combined with centroidAreaNormal for point3d array and Ray3d return listed above...\r\n  // Returns undefined if given point array less than 3 or if not safe to divide at any point\r\n  /**\r\n   * * Return (in caller-allocated centroid) the centroid of the xy polygon.\r\n   * * Return (as function value)  the area\r\n   */\r\n  public static centroidAndAreaXY(points: Point2d[], centroid: Point2d): number | undefined {\r\n    let area = 0.0;\r\n    centroid.set(0, 0);\r\n    if (points.length < 3)\r\n      return undefined;\r\n    const origin = points[0];\r\n    let vectorSum = Vector2d.create(0, 0); // == sum ((U+V)/3) * (U CROSS V)/2 -- but leave out divisions\r\n    let areaSum = 0.0; // == sum (U CROSS V) / 2 -- but leave out divisions\r\n    for (let i = 1; i + 1 < points.length; i++) {\r\n      const vector0 = origin.vectorTo(points[i]);\r\n      const vector1 = origin.vectorTo(points[i + 1]);\r\n      const tempArea = vector0.crossProduct(vector1);\r\n      vectorSum = vectorSum.plus(vector0.plus(vector1).scale(tempArea));\r\n      areaSum += tempArea;\r\n    }\r\n    area = areaSum * 0.5;\r\n    const a = Geometry.conditionalDivideFraction(1.0, 6.0 * area);\r\n    if (a === undefined) {\r\n      centroid.setFrom(origin);\r\n      return undefined;\r\n    }\r\n    centroid.setFrom(origin.plusScaled(vectorSum, a));\r\n    return area;\r\n  }\r\n  /**\r\n   * Return a unit normal to the plane of the polygon.\r\n   * @param points array of points around the polygon.  This is assumed to NOT have closure edge.\r\n   * @param result caller-allocated result vector.\r\n   */\r\n  public static unitNormal(points: IndexedXYZCollection, result: Vector3d): boolean {\r\n    const n = points.length;\r\n    if (n === 3) {\r\n      points.crossProductIndexIndexIndex(0, 1, 2, result);\r\n      return result.normalizeInPlace();\r\n    }\r\n    if (n === 4) {\r\n      // cross product of diagonals is more stable than from single of the points . . .\r\n      points.vectorIndexIndex(0, 2, PolygonOps._vector0);\r\n      points.vectorIndexIndex(1, 3, PolygonOps._vector1);\r\n      PolygonOps._vector0.crossProduct(PolygonOps._vector1, result);\r\n      return result.normalizeInPlace();\r\n    }\r\n    // more than 4 points  ... no shortcuts ...\r\n    PolygonOps.areaNormalGo(points, result);\r\n    return result.normalizeInPlace();\r\n  }\r\n  /** Accumulate to the matrix of area products of a polygon with respect to an origin.\r\n   * The polygon is assumed to be planar and non-self-intersecting.\r\n   */\r\n  /** Accumulate to the matrix of area products of a polygon with respect to an origin.\r\n   * * The polygon is assumed to be planar and non-self-intersecting.\r\n   * * Accumulated values are integrals over triangles from point 0 of the polygon to other edges of the polygon.\r\n   * * Integral over each triangle is transformed to integrals from the given origin.\r\n   * @param points array of points around the polygon.   Final closure point is not needed.\r\n   * @param origin origin for global accumulation.\r\n   * @param moments 4x4 matrix where products are accumulated.\r\n   */\r\n  public static addSecondMomentAreaProducts(points: IndexedXYZCollection, origin: Point3d, moments: Matrix4d) {\r\n    this.addSecondMomentTransformedProducts(PolygonOps._triangleMomentWeights, points, origin, 2, moments);\r\n  }\r\n\r\n  /** Accumulate to the matrix of volume products of a polygon with respect to an origin.\r\n   * * The polygon is assumed to be planar and non-self-intersecting.\r\n   * * Accumulated values are integrals over tetrahedra from the origin to triangles on the polygon.\r\n   * @param points array of points around the polygon.   Final closure point is not needed.\r\n   * @param origin origin for tetrahedra\r\n   * @param moments 4x4 matrix where products are accumulated.\r\n   */\r\n  public static addSecondMomentVolumeProducts(points: IndexedXYZCollection, origin: Point3d, moments: Matrix4d) {\r\n    this.addSecondMomentTransformedProducts(PolygonOps._tetrahedralMomentWeights, points, origin, 3, moments);\r\n  }\r\n  /** Return the matrix of area products of a polygon with respect to an origin.\r\n   * The polygon is assumed to be planar and non-self-intersecting.\r\n   * * `frameType===2` has xy vectors in the plane of the polygon, plus a unit normal z. (Used for area integrals)\r\n   * * `frameType===3` has vectors from origin to 3 points in the triangle. (Used for volume integrals)\r\n   */\r\n  private static addSecondMomentTransformedProducts(firstQuadrantMoments: Matrix4d, points: IndexedXYZCollection, origin: Point3d,\r\n    frameType: 2 | 3,\r\n    moments: Matrix4d) {\r\n    const unitNormal = PolygonOps._normal;\r\n    if (PolygonOps.unitNormal(points, unitNormal)) {\r\n      // The direction of the normal makes the various detJ values positive or negative so that non-convex polygons\r\n      // sum correctly.\r\n      const vector01 = PolygonOps._vector0;\r\n      const vector02 = PolygonOps._vector1;\r\n      const vector03 = PolygonOps._vector2;\r\n      const placement = PolygonOps._matrixA;\r\n      const matrixAB = PolygonOps._matrixB;\r\n      const matrixABC = PolygonOps._matrixC;\r\n      const vectorOrigin = points.vectorXYAndZIndex(origin, 0, PolygonOps._vectorOrigin)!;\r\n      const numPoints = points.length;\r\n      let detJ = 0;\r\n      for (let i2 = 2; i2 < numPoints; i2++) {\r\n        if (frameType === 2) {\r\n          points.vectorIndexIndex(0, i2 - 1, vector01);\r\n          points.vectorIndexIndex(0, i2, vector02);\r\n          detJ = unitNormal.tripleProduct(vector01, vector02);\r\n          placement.setOriginAndVectors(vectorOrigin, vector01, vector02, unitNormal);\r\n          placement.multiplyMatrixMatrix(firstQuadrantMoments, matrixAB);\r\n          matrixAB.multiplyMatrixMatrixTranspose(placement, matrixABC);\r\n          moments.addScaledInPlace(matrixABC, detJ);\r\n        } else if (frameType === 3) {\r\n          points.vectorXYAndZIndex(origin, 0, vector01);\r\n          points.vectorXYAndZIndex(origin, i2 - 1, vector02);\r\n          points.vectorXYAndZIndex(origin, i2, vector03);\r\n          detJ = vector01.tripleProduct(vector02, vector03);\r\n          placement.setOriginAndVectors(origin, vector01, vector02, vector03);\r\n          placement.multiplyMatrixMatrix(firstQuadrantMoments, matrixAB);\r\n          matrixAB.multiplyMatrixMatrixTranspose(placement, matrixABC);\r\n          moments.addScaledInPlace(matrixABC, detJ);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Test the direction of turn at the vertices of the polygon, ignoring z-coordinates.\r\n   *\r\n   * *  For a polygon without self intersections, this is a convexity and orientation test: all positive is convex and counterclockwise,\r\n   * all negative is convex and clockwise\r\n   * *  Beware that a polygon which turns through more than a full turn can cross itself and close, but is not convex\r\n   * *  Returns 1 if all turns are to the left, -1 if all to the right, and 0 if there are any zero or reverse turns\r\n   */\r\n  public static testXYPolygonTurningDirections(pPointArray: Point2d[] | Point3d[]): number {\r\n    // Reduce count by trailing duplicates; leaves iLast at final index\r\n    let numPoint = pPointArray.length;\r\n    let iLast = numPoint - 1;\r\n    while (iLast > 1 && pPointArray[iLast].x === pPointArray[0].x && pPointArray[iLast].y === pPointArray[0].y) {\r\n      numPoint = iLast--;\r\n    }\r\n    if (numPoint > 2) {\r\n      let vector0 = Point2d.create(pPointArray[iLast].x - pPointArray[iLast - 1].x, pPointArray[iLast].y - pPointArray[iLast - 1].y);\r\n      const vector1 = Point2d.create(pPointArray[0].x - pPointArray[iLast].x, pPointArray[0].y - pPointArray[iLast].y);\r\n      const baseArea = vector0.x * vector1.y - vector0.y * vector1.x;\r\n      // In a convex polygon, all successive-vector cross products will\r\n      // have the same sign as the base area, hence all products will be\r\n      // positive.\r\n      for (let i1 = 1; i1 < numPoint; i1++) {\r\n        vector0 = vector1.clone();\r\n        Point2d.create(pPointArray[i1].x - pPointArray[i1 - 1].x, pPointArray[i1].y - pPointArray[i1 - 1].y, vector1);\r\n        const currArea = vector0.x * vector1.y - vector0.y * vector1.x;\r\n        if (currArea * baseArea <= 0.0)\r\n          return 0;\r\n      }\r\n      // Fall out with all signs same as base area\r\n      return baseArea > 0.0 ? 1 : -1;\r\n    }\r\n    return 0;\r\n  }\r\n  /**\r\n   * Test if point (x,y) is IN, OUT or ON a polygon.\r\n   * @return (1) for in, (-1) for OUT, (0) for ON\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param points array of xy coordinates.\r\n   */\r\n  public static classifyPointInPolygon(x: number, y: number, points: XAndY[]): number | undefined {\r\n    const context = new XYParitySearchContext(x, y);\r\n    let i0 = 0;\r\n    const n = points.length;\r\n    let i1;\r\n    let iLast = -1;\r\n    // walk to an acceptable start index ...\r\n    for (i0 = 0; i0 < n; i0 = i1) {\r\n      i1 = i0 + 1;\r\n      if (i1 >= n)\r\n        i1 = 0;\r\n      if (context.tryStartEdge(points[i0].x, points[i0].y, points[i1].x, points[i1].y)) {\r\n        iLast = i1;\r\n        break;\r\n      }\r\n    }\r\n    if (iLast < 0)\r\n      return undefined;\r\n    for (let i = 1; i <= n; i++) {\r\n      i1 = iLast + i;\r\n      if (i1 >= n)\r\n        i1 -= n;\r\n      if (!context.advance(points[i1].x, points[i1].y))\r\n        return context.classifyCounts();\r\n    }\r\n    return context.classifyCounts();\r\n  }\r\n  /**\r\n   * Test if point (x,y) is IN, OUT or ON a polygon.\r\n   * @return (1) for in, (-1) for OUT, (0) for ON\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param points array of xy coordinates.\r\n   */\r\n  public static classifyPointInPolygonXY(x: number, y: number, points: IndexedXYZCollection): number | undefined {\r\n    const context = new XYParitySearchContext(x, y);\r\n    let i0 = 0;\r\n    const n = points.length;\r\n    let i1;\r\n    let iLast = -1;\r\n    // walk to an acceptable start index ...\r\n    for (i0 = 0; i0 < n; i0 = i1) {\r\n      i1 = i0 + 1;\r\n      if (i1 >= n)\r\n        i1 = 0;\r\n      if (context.tryStartEdge(points.getXAtUncheckedPointIndex(i0), points.getYAtUncheckedPointIndex(i0), points.getXAtUncheckedPointIndex(i1), points.getYAtUncheckedPointIndex(i1))) {\r\n        iLast = i1;\r\n        break;\r\n      }\r\n    }\r\n    if (iLast < 0)\r\n      return undefined;\r\n    for (let i = 1; i <= n; i++) {\r\n      i1 = iLast + i;\r\n      if (i1 >= n)\r\n        i1 -= n;\r\n      if (!context.advance(points.getXAtUncheckedPointIndex(i1), points.getYAtUncheckedPointIndex(i1)))\r\n        return context.classifyCounts();\r\n    }\r\n    return context.classifyCounts();\r\n  }\r\n\r\n  /**\r\n   * Reverse loops as necessary to make them all have CCW orientation for given outward normal.\r\n   * @param loops\r\n   * @param outwardNormal\r\n   * @return the number of loops reversed.\r\n   */\r\n  public static orientLoopsCCWForOutwardNormalInPlace(loops: GrowableXYZArray | GrowableXYZArray[], outwardNormal: Vector3d): number {\r\n    if (loops instanceof IndexedXYZCollection)\r\n      return this.orientLoopsCCWForOutwardNormalInPlace([loops], outwardNormal);\r\n    const orientations: number[] = [];\r\n    const unitNormal = Vector3d.create();\r\n    // orient individually ... (no hole analysis)\r\n    let numReverse = 0;\r\n    for (const loop of loops) {\r\n      if (this.unitNormal(loop, unitNormal)) {\r\n        const q = unitNormal.dotProduct(outwardNormal);\r\n        orientations.push(q);\r\n        if (q <= 0.0)\r\n          loop.reverseInPlace();\r\n        numReverse++;\r\n      } else {\r\n        orientations.push(0.0);\r\n      }\r\n    }\r\n    return numReverse;\r\n  }\r\n  /**\r\n   * If reverse loops as necessary to make them all have CCW orientation for given outward normal.\r\n   * * Return an array of arrays which capture the input pointers.\r\n   * * In each first level array:\r\n   *    * The first loop is an outer loop.\r\n   *    * all subsequent loops are holes\r\n   *    * The outer loop is CCW\r\n   *    * The holes are CW.\r\n   * @param loops multiple loops to sort and reverse.\r\n   */\r\n  public static sortOuterAndHoleLoopsXY(loops: IndexedReadWriteXYZCollection[]): IndexedReadWriteXYZCollection[][] {\r\n    const loopAndArea: SortablePolygon[] = [];\r\n    for (const loop of loops) {\r\n      SortablePolygon.pushLoop(loopAndArea, loop);\r\n    }\r\n    return SortablePolygon.assignParentsAndDepth(loopAndArea);\r\n  }\r\n}\r\n/**\r\n *  `IndexedXYZCollectionPolygonOps` class contains _static_ methods for typical operations on polygons carried as `IndexedXyZCollection`\r\n * @public\r\n */\r\nexport class IndexedXYZCollectionPolygonOps {\r\n  private static _xyz0Work: Point3d = Point3d.create();\r\n  private static _xyz1Work: Point3d = Point3d.create();\r\n  private static _xyz2Work: Point3d = Point3d.create();\r\n  /**\r\n   * Split a (convex) polygon into 2 parts based on altitude evaluations.\r\n   * * POSITIVE ALTITUDE IS IN\r\n   * @param plane any `PlaneAltitudeEvaluator` object that can evaluate `plane.altitude(xyz)` for distance from the plane.\r\n   * @param xyz original polygon\r\n   * @param xyzPositive array to receive inside part (altitude > 0)\r\n   * @param xyzNegative array to receive outside part\r\n   * @param altitudeRange min and max altitudes encountered.\r\n   */\r\n  public static splitConvexPolygonInsideOutsidePlane(plane: PlaneAltitudeEvaluator,\r\n    xyz: IndexedReadWriteXYZCollection,\r\n    xyzPositive: IndexedReadWriteXYZCollection,\r\n    xyzNegative: IndexedReadWriteXYZCollection, altitudeRange: Range1d) {\r\n    const xyz0 = IndexedXYZCollectionPolygonOps._xyz0Work;\r\n    const xyz1 = IndexedXYZCollectionPolygonOps._xyz1Work;\r\n    const xyzInterpolated = IndexedXYZCollectionPolygonOps._xyz2Work;\r\n    const n = xyz.length;\r\n    xyzPositive.clear();\r\n    xyzNegative.clear();\r\n    // let numSplit = 0;\r\n    const fractionTol = 1.0e-8;\r\n    if (n > 2) {\r\n      xyz.back(xyz0);\r\n      altitudeRange.setNull();\r\n      let a0 = plane.altitude(xyz0);\r\n      altitudeRange.extendX(a0);\r\n      //    if (a0 >= 0.0)\r\n      //      work.push_back (xyz0);\r\n      for (let i1 = 0; i1 < n; i1++) {\r\n        xyz.getPoint3dAtUncheckedPointIndex(i1, xyz1);\r\n        const a1 = plane.altitude(xyz1);\r\n        altitudeRange.extendX(a1);\r\n        let nearZero = false;\r\n        if (a0 * a1 < 0.0) {\r\n          // simple crossing. . .\r\n          const f = - a0 / (a1 - a0);\r\n          if (f > 1.0 - fractionTol && a1 >= 0.0) {\r\n            // the endpoint will be saved -- avoid the duplicate\r\n            nearZero = true;\r\n          } else {\r\n            xyz0.interpolate(f, xyz1, xyzInterpolated);\r\n            xyzPositive.push(xyzInterpolated);\r\n            xyzNegative.push(xyzInterpolated);\r\n          }\r\n          // numSplit++;\r\n        }\r\n        if (a1 >= 0.0 || nearZero)\r\n          xyzPositive.push(xyz1);\r\n        if (a1 <= 0.0 || nearZero)\r\n          xyzNegative.push(xyz1);\r\n        xyz0.setFromPoint3d(xyz1);\r\n        a0 = a1;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Clip a polygon to one side of a plane.\r\n   * * Results with 2 or fewer points are ignored.\r\n   * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.\r\n   * * plane is passed as unrolled Point4d (ax,ay,az,aw) point (x,y,z) acts as homogeneous (x,y,z,1)\r\n   *   * `keepPositive === true` selects positive altitudes.\r\n   * @param plane any type that has `plane.altitude`\r\n   * @param xyz input points.\r\n   * @param work work buffer\r\n   * @param tolerance tolerance for \"on plane\" decision.\r\n   */\r\n  public static clipConvexPolygonInPlace(plane: PlaneAltitudeEvaluator, xyz: GrowableXYZArray, work: GrowableXYZArray, keepPositive: boolean = true, tolerance: number = Geometry.smallMetricDistance) {\r\n    work.clear();\r\n    const s = keepPositive ? 1.0 : -1.0;\r\n    const n = xyz.length;\r\n    let numNegative = 0;\r\n    const fractionTol = 1.0e-8;\r\n    const b = -tolerance;\r\n    if (xyz.length > 1) {\r\n      let a1;\r\n      let index0 = xyz.length - 1;\r\n      let a0 = s * xyz.evaluateUncheckedIndexPlaneAltitude(index0, plane);\r\n      //    if (a0 >= 0.0)\r\n      //      work.push_back (xyz0);\r\n      for (let index1 = 0; index1 < n; a0 = a1, index0 = index1++) {\r\n        a1 = s * xyz.evaluateUncheckedIndexPlaneAltitude(index1, plane);\r\n        if (a1 < 0)\r\n          numNegative++;\r\n        if (a0 * a1 < 0.0) {\r\n          // simple crossing . . .\r\n          const f = - a0 / (a1 - a0);\r\n          if (f > 1.0 - fractionTol && a1 >= 0.0) {\r\n            // the endpoint will be saved -- avoid the duplicate\r\n          } else {\r\n            work.pushInterpolatedFromGrowableXYZArray(xyz, index0, f, index1);\r\n          }\r\n        }\r\n        if (a1 >= b)\r\n          work.pushFromGrowableXYZArray(xyz, index1);\r\n        index0 = index1;\r\n        a0 = a1;\r\n      }\r\n    }\r\n\r\n    if (work.length <= 2) {\r\n      xyz.clear();\r\n    } else if (numNegative > 0) {\r\n      xyz.clear();\r\n      xyz.pushFromGrowableXYZArray(work);\r\n    }\r\n    work.clear();\r\n  }\r\n  /**\r\n   * Return the intersection of the plane with a range cube.\r\n   * @param range\r\n   * @param xyzOut intersection polygon.  This is convex.\r\n   * @return reference to xyz if the polygon still has points; undefined if all points are clipped away.\r\n   */\r\n  public static intersectRangeConvexPolygonInPlace(range: Range3d, xyz: GrowableXYZArray) {\r\n    if (range.isNull)\r\n      return undefined;\r\n    const work = new GrowableXYZArray();\r\n    const plane = Point4d.create();\r\n    plane.set(0, 0, -1, range.high.z);\r\n    this.clipConvexPolygonInPlace(plane, xyz, work, true);\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n\r\n    plane.set(0, 0, -1, -range.low.z);\r\n    this.clipConvexPolygonInPlace(plane, xyz, work, true);\r\n    if (xyz.length === 0)\r\n\r\n      plane.set(0, -1, 0, -range.high.y);\r\n    this.clipConvexPolygonInPlace(plane, xyz, work, true);\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n\r\n    plane.set(0, 1, 0, range.low.y);\r\n    this.clipConvexPolygonInPlace(plane, xyz, work, true);\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n\r\n    plane.set(-1, 0, 0, range.high.x);\r\n    this.clipConvexPolygonInPlace(plane, xyz, work, true);\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n\r\n    plane.set(1, 0, 0, -range.low.x);\r\n    this.clipConvexPolygonInPlace(plane, xyz, work, true);\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n\r\n    return xyz;\r\n  }\r\n}\r\n/**\r\n * `Point3dArrayPolygonOps` class contains _static_ methods for typical operations on polygons carried as `Point3d[]`\r\n * @public\r\n */\r\nexport class Point3dArrayPolygonOps {\r\n  private static _xyz0Work: Point3d = Point3d.create();\r\n  //  private static _xyz1Work: Point3d = Point3d.create();\r\n  //  private static _xyz2Work: Point3d = Point3d.create();\r\n  /**\r\n   * Split a (convex) polygon into 2 parts.\r\n   * @param xyz original polygon\r\n   * @param xyzIn array to receive inside part\r\n   * @param xyzOut array to receive outside part\r\n   * @param altitudeRange min and max altitudes encountered.\r\n   */\r\n  public static convexPolygonSplitInsideOutsidePlane(plane: PlaneAltitudeEvaluator, xyz: Point3d[], xyzIn: Point3d[], xyzOut: Point3d[], altitudeRange: Range1d) {\r\n    const xyzCarrier = new Point3dArrayCarrier(xyz);\r\n    const xyzInCarrier = new Point3dArrayCarrier(xyzIn);\r\n    const xyzOutCarrier = new Point3dArrayCarrier(xyzOut);\r\n    IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(plane, xyzCarrier, xyzInCarrier, xyzOutCarrier, altitudeRange);\r\n\r\n  }\r\n\r\n  /** Return an array containing\r\n   * * All points that are exactly on the plane.\r\n   * * Crossing points between adjacent points that are (strictly) on opposite sides.\r\n   */\r\n  public static polygonPlaneCrossings(plane: PlaneAltitudeEvaluator, xyz: Point3d[], crossings: Point3d[]) {\r\n    crossings.length = 0;\r\n    if (xyz.length >= 2) {\r\n      const xyz0 = this._xyz0Work;\r\n      xyz0.setFromPoint3d(xyz[xyz.length - 1]);\r\n      let a0 = plane.altitude(xyz0);\r\n      for (const xyz1 of xyz) {\r\n        const a1 = plane.altitude(xyz1);\r\n        if (a0 * a1 < 0.0) {\r\n          // simple crossing. . .\r\n          const f = - a0 / (a1 - a0);\r\n          crossings.push(xyz0.interpolate(f, xyz1));\r\n        }\r\n        if (a1 === 0.0) {        // IMPORTANT -- every point is directly tested here\r\n          crossings.push(xyz1.clone());\r\n        }\r\n        xyz0.setFromPoint3d(xyz1);\r\n        a0 = a1;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Clip a polygon, returning the clip result in the same object.\r\n   * @param xyz input/output polygon\r\n   * @param work scratch object\r\n   * @param tolerance tolerance for on-plane decision.\r\n   */\r\n  public static convexPolygonClipInPlace(plane: PlaneAltitudeEvaluator, xyz: Point3d[], work: Point3d[] | undefined, tolerance: number = Geometry.smallMetricDistance) {\r\n    if (work === undefined)\r\n      work = [];\r\n    work.length = 0;\r\n    let numNegative = 0;\r\n    const fractionTol = 1.0e-8;\r\n    const b = -tolerance;\r\n    if (xyz.length > 2) {\r\n      let xyz0 = xyz[xyz.length - 1];\r\n      let a0 = plane.altitude(xyz0);\r\n      //    if (a0 >= 0.0)\r\n      //      work.push_back (xyz0);\r\n      for (const xyz1 of xyz) {\r\n        const a1 = plane.altitude(xyz1);\r\n        if (a1 < 0)\r\n          numNegative++;\r\n        if (a0 * a1 < 0.0) {\r\n          // simple crossing . . .\r\n          const f = - a0 / (a1 - a0);\r\n          if (f > 1.0 - fractionTol && a1 >= 0.0) {\r\n            // the endpoint will be saved -- avoid the duplicate\r\n          } else {\r\n            work.push(xyz0.interpolate(f, xyz1));\r\n          }\r\n        }\r\n        if (a1 >= b)\r\n          work.push(xyz1);\r\n        xyz0 = Point3d.createFrom(xyz1);\r\n        a0 = a1;\r\n      }\r\n    }\r\n\r\n    if (work.length <= 2) {\r\n      xyz.length = 0;\r\n    } else if (numNegative > 0) {\r\n      xyz.length = 0;\r\n      for (const xyzI of work) {\r\n        xyz.push(xyzI);\r\n      }\r\n      work.length = 0;\r\n    }\r\n  }\r\n}\r\n/**\r\n * A `SortablePolygon` carries a (single) loop with data useful for sorting for inner-outer structure.\r\n * @internal\r\n */\r\nclass SortablePolygon {\r\n  public loop: IndexedReadWriteXYZCollection;\r\n  public sortKey: number;\r\n  public signedArea: number;\r\n  public range: Range3d;\r\n  public parentIndex?: number;\r\n  public isHole: boolean;\r\n  public outputSetIndex?: number;\r\n  /**\r\n   *\r\n   * @param loop Loop to capture.\r\n   */\r\n  public constructor(loop: IndexedReadWriteXYZCollection, range: Range3d, signedArea: number) {\r\n    this.loop = loop;\r\n    this.range = range;\r\n    this.signedArea = signedArea;\r\n    this.sortKey = Math.abs(this.signedArea);\r\n    this.isHole = false;\r\n  }\r\n  /** Push loop with sort data onto the array.\r\n   * * No action if no clear normal.\r\n   * * return true if pushed.\r\n   */\r\n  public static pushLoop(loops: SortablePolygon[], loop: IndexedReadWriteXYZCollection): boolean {\r\n    const areaXY = PolygonOps.areaXY(loop);\r\n    if (areaXY > 0.0) {\r\n      loops.push(new SortablePolygon(loop, Range3d.createFromVariantData(loop), areaXY));\r\n      return true;\r\n    }\r\n    return true;\r\n  }\r\n  /** Push loop with sort data onto the array.\r\n   * * No action if no clear normal.\r\n   * * return true if pushed.\r\n   */\r\n  public static assignParentsAndDepth(loops: SortablePolygon[]): IndexedReadWriteXYZCollection[][] {\r\n    const outputSets: IndexedReadWriteXYZCollection[][] = [];\r\n    // Sort largest to smallest ...\r\n    loops.sort((loopA: SortablePolygon, loopB: SortablePolygon) => (loopB.sortKey - loopA.sortKey));\r\n    outputSets.length = 0;\r\n    // starting with smallest loop, point each loop to smallest containing parent.\r\n    for (let i = loops.length; i-- > 0;) {\r\n      const searchX = loops[i].loop.getXAtUncheckedPointIndex(0);\r\n      const searchY = loops[i].loop.getYAtUncheckedPointIndex(0);\r\n      // find smallest containing parent (search forward only to hit)\r\n      loops[i].parentIndex = undefined;\r\n      loops[i].outputSetIndex = undefined;\r\n      for (let j = i; j-- > 0;) {\r\n        if (loops[j].range.containsXY(searchX, searchY)\r\n          && 1 === PolygonOps.classifyPointInPolygonXY(searchX, searchY, loops[j].loop)) {\r\n          loops[i].parentIndex = j;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    // In large-to-small order:\r\n    // If a loop has no parent or has a \"hole\" as parent it is outer.\r\n    // otherwise (i.e. it has a non-hole parent) it becomes a hole in the parent.\r\n    for (const loopData of loops) {\r\n      loopData.isHole = false;\r\n      const parentIndex = loopData.parentIndex;\r\n      if (parentIndex !== undefined)\r\n        loopData.isHole = !loops[parentIndex].isHole;\r\n      if (!loopData.isHole) {\r\n        loopData.reverseLoopForAreaSign(1.0);\r\n        loopData.outputSetIndex = outputSets.length;\r\n        outputSets.push([]);\r\n        outputSets[loopData.outputSetIndex].push(loopData.loop);\r\n      } else {\r\n        loopData.reverseLoopForAreaSign(-1.0);\r\n        const outputSetIndex = loops[parentIndex!].outputSetIndex!;\r\n        outputSets[outputSetIndex].push(loopData.loop);\r\n      }\r\n    }\r\n    return outputSets;\r\n  }\r\n  private reverseLoopForAreaSign(areaSign: number) {\r\n    if (areaSign * this.signedArea < 0.0) {\r\n      this.loop.reverseInPlace();\r\n      this.signedArea *= -1.0;\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { IndexedXYZCollection, IndexedReadWriteXYZCollection } from \"./IndexedXYZCollection\";\r\nimport { Point3dArrayCarrier } from \"./Point3dArrayCarrier\";\r\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\r\nimport { Geometry } from \"../Geometry\";\r\n// cspell:word Puecker\r\n/** context class for Puecker-Douglas polyline compression, viz https://en.wikipedia.org/wiki/RamerDouglasPeucker_algorithm\r\n * @internal\r\n */\r\nexport class PolylineCompressionContext {\r\n  /** Caller provides source and tolerance.\r\n   * * pointer to source is retained, but contents of source are never modified.\r\n   */\r\n  private constructor(source: IndexedXYZCollection, dest: IndexedReadWriteXYZCollection, tolerance: number) {\r\n    this._toleranceSquared = tolerance * tolerance;\r\n    this._source = source;\r\n    this._dest = dest;\r\n  }\r\n  private _source: IndexedXYZCollection;\r\n\r\n  private _dest: IndexedReadWriteXYZCollection;\r\n\r\n  /** Squared tolerance for equal point. */\r\n  private _toleranceSquared: number;\r\n  /** push (clone of) the point at index i from the source to the growing result.\r\n   * * index is adjusted cyclically to source index range by modulo.\r\n   */\r\n  private acceptPointByIndex(i: number) {\r\n    const point = this._source.getPoint3dAtCheckedPointIndex(this._source.cyclicIndex(i));\r\n    if (point)\r\n      this._dest.push(point);\r\n  }\r\n  /** work data used by find max deviation */\r\n  private static _vector01: Vector3d = Vector3d.create();\r\n  private static _vectorQ: Vector3d = Vector3d.create();\r\n  /**\r\n   * Return index of max magnitude of cross product of vectors (index to index+1) and (index to index+2)\r\n   * * Return undefined if unable to find a nonzero cross product.\r\n   * @param i0 first cross product central index.\r\n   * @param i1 last cross product central index.\r\n   */\r\n  private indexOfMaxCrossProduct(index0: number, index1: number): number | undefined {\r\n    let qMax = 0.0;\r\n    let q;\r\n    let indexMax: number | undefined;\r\n    for (let index = index0; index <= index1; index++) {\r\n      const iA = this._source.cyclicIndex(index);\r\n      const iB = this._source.cyclicIndex(index + 1);\r\n      const iC = this._source.cyclicIndex(index + 2);\r\n      this._source.crossProductIndexIndexIndex(iA, iB, iC, PolylineCompressionContext._vectorQ);\r\n      q = PolylineCompressionContext._vectorQ.magnitudeSquared();\r\n      if (q > qMax) {\r\n        qMax = q;\r\n        indexMax = index;\r\n      }\r\n    }\r\n    return indexMax;\r\n  }\r\n\r\n  /**\r\n   * Return interior index where max deviation in excess of tolerance occurs.\r\n   * @param i0 first index of interval\r\n   * @param i1 INCLUSIVE final index\r\n   */\r\n  private indexOfMaxDeviation(index0: number, index1: number): number | undefined {\r\n    const i0 = this._source.cyclicIndex(index0);\r\n    const i1 = this._source.cyclicIndex(index1);\r\n    let maxDeviation = this._toleranceSquared;\r\n    let maxDeviationIndex;\r\n    let numerator;\r\n    let distanceSquared;\r\n    let s;\r\n    let i;\r\n    this._source.vectorIndexIndex(i0, i1, PolylineCompressionContext._vector01)!;\r\n    const denominator = PolylineCompressionContext._vector01.magnitudeSquared();\r\n    for (let index = index0 + 1; index < index1; index++) {\r\n      i = this._source.cyclicIndex(index);\r\n      this._source.vectorIndexIndex(i0, i, PolylineCompressionContext._vectorQ);\r\n      numerator = PolylineCompressionContext._vector01.dotProduct(PolylineCompressionContext._vectorQ);\r\n      if (numerator <= 0) {\r\n        distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared();\r\n      } else if (numerator > denominator) {\r\n        this._source.vectorIndexIndex(i1, i, PolylineCompressionContext._vectorQ);\r\n        distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared();\r\n      } else {\r\n        s = numerator / denominator;\r\n        distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared() - denominator * s * s;\r\n      }\r\n      if (distanceSquared > maxDeviation) {\r\n        maxDeviation = distanceSquared;\r\n        maxDeviationIndex = index;\r\n      }\r\n    }\r\n    return maxDeviationIndex;\r\n  }\r\n  /**\r\n   *\r\n   * @param i0 first active point index\r\n   * @param i1 last active point index (INCLUSIVE -- not \"one beyond\")\r\n   * @param chordTolerance\r\n   * @param result\r\n   */\r\n  // ASSUME index i0 is already saved.\r\n  // ASSUME point i\r\n  private recursiveCompressByChordErrorGo(i0: number, i1: number) {\r\n    if (i1 === i0 + 1) {\r\n      this.acceptPointByIndex(i1);\r\n      return;\r\n    }\r\n    const distantPointIndex = this.indexOfMaxDeviation(i0, i1);\r\n    if (distantPointIndex === undefined) {\r\n      this.acceptPointByIndex(i1); // which compresses out some points.\r\n    } else {\r\n      this.recursiveCompressByChordErrorGo(i0, distantPointIndex);\r\n      this.recursiveCompressByChordErrorGo(distantPointIndex, i1);\r\n    }\r\n  }\r\n  // cspell:word Peucker\r\n  /**\r\n   * Return a point array with a subset of the input points.\r\n   * * This is a global analysis (Douglas-Peucker)\r\n   * @param source input points.\r\n   * @param chordTolerance Points less than this distance from a retained edge may be ignored.\r\n   */\r\n  public static compressPoint3dArrayByChordError(source: Point3d[], chordTolerance: number): Point3d[] {\r\n    const source1 = new Point3dArrayCarrier(source);\r\n    const dest1 = new Point3dArrayCarrier([]);\r\n    this.compressCollectionByChordError(source1, dest1, chordTolerance);\r\n    return dest1.data;\r\n  }\r\n  /**\r\n   * * Return a polyline with a subset of the input points.\r\n   * * This is a global analysis (Douglas-Peucker)\r\n   * * Global search for vertices that are close to edges between widely separated neighbors.\r\n   * * Recurses to smaller subsets.\r\n   * @param source input points\r\n   * @param dest output points.  Must be different from source.\r\n   * @param chordTolerance Points less than this distance from a retained edge may be ignored.\r\n   */\r\n  public static compressCollectionByChordError(source: IndexedXYZCollection, dest: IndexedReadWriteXYZCollection, chordTolerance: number) {\r\n    dest.clear();\r\n    const n = source.length;\r\n    if (n === 1) {\r\n      dest.push(source.getPoint3dAtCheckedPointIndex(0)!);\r\n      return;\r\n    }\r\n    const context = new PolylineCompressionContext(source, dest, chordTolerance);\r\n    // Do compression on inclusive interval from indexA to indexB, with indices interpreted cyclically if closed\r\n    let indexA = 0;\r\n    let indexB = n - 1;\r\n    if (n > 2 && source.distanceIndexIndex(0, n - 1)! <= chordTolerance) {\r\n      // cyclic data. It is possible that the wrap point itself has to be seen as an internal point.\r\n      // do the search from point index where there is a large triangle . ..\r\n      const maxCrossProductIndex = context.indexOfMaxCrossProduct(0, n - 1);\r\n      if (maxCrossProductIndex !== undefined) {\r\n        indexA = maxCrossProductIndex + 1;\r\n        indexB = indexA + n;\r\n      }\r\n    }\r\n    context.acceptPointByIndex(indexA);\r\n    context.recursiveCompressByChordErrorGo(indexA, indexB);\r\n  }\r\n  /** Copy points from source to dest, omitting those too close to predecessor.\r\n   * * First and last points are always preserved.\r\n   */\r\n  public static compressInPlaceByShortEdgeLength(data: GrowableXYZArray, edgeLength: number) {\r\n    const n = data.length;\r\n    if (n < 2)\r\n      return;\r\n    let lastAcceptedIndex = 0;\r\n    // back up from final point ..\r\n    let indexB = n - 1;\r\n    while (indexB > 0 && data.distanceIndexIndex(indexB - 1, n - 1)! < edgeLength)\r\n      indexB--;\r\n    if (indexB === 0) {\r\n      // Theres only one point there.\r\n      data.length = 1;\r\n      return;\r\n    }\r\n    // we want the exact bits of the final point even if others were nearby ..\r\n    if (indexB < n - 1)\r\n      data.moveIndexToIndex(n - 1, indexB);\r\n    let candidateIndex = lastAcceptedIndex + 1;\r\n    while (candidateIndex <= indexB) {\r\n      if (data.distanceIndexIndex(lastAcceptedIndex, candidateIndex)! >= edgeLength) {\r\n        data.moveIndexToIndex(candidateIndex, lastAcceptedIndex + 1);\r\n        lastAcceptedIndex++;\r\n      }\r\n      candidateIndex++;\r\n    }\r\n    data.length = lastAcceptedIndex + 1;\r\n  }\r\n\r\n  /** Copy points from source to dest, omitting those too close to predecessor.\r\n   * * First and last points are always preserved.\r\n   */\r\n  public static compressInPlaceBySmallTriangleArea(data: GrowableXYZArray, triangleArea: number) {\r\n    const n = data.length;\r\n    if (n < 3)\r\n      return;\r\n    let lastAcceptedIndex = 0;\r\n    const cross = Vector3d.create();\r\n    for (let i1 = 1; i1 + 1 < n; i1++) {\r\n      data.crossProductIndexIndexIndex(lastAcceptedIndex, i1, i1 + 1, cross);\r\n      if (0.5 * cross.magnitude() > triangleArea) {\r\n        data.moveIndexToIndex(i1, ++lastAcceptedIndex);\r\n      }\r\n    }\r\n    data.moveIndexToIndex(n - 1, ++lastAcceptedIndex);\r\n    data.length = lastAcceptedIndex + 1;\r\n  }\r\n\r\n  /** Copy points from source to dest, omitting those too close to edge between neighbors.\r\n   * * First and last points are always preserved.\r\n   */\r\n  public static compressInPlaceByPerpendicularDistance(data: GrowableXYZArray, perpendicularDistance: number, maxExtensionFraction = 1.0001) {\r\n    const n = data.length;\r\n    if (n < 3)\r\n      return;\r\n    let lastAcceptedIndex = 0;\r\n    const vector01 = PolylineCompressionContext._vector01;\r\n    const vectorQ = PolylineCompressionContext._vectorQ;\r\n    let distanceSquared;\r\n    const perpendicularDistanceSquared = perpendicularDistance * perpendicularDistance;\r\n    let denominator;\r\n    let i1 = 1;\r\n    for (; i1 + 1 < n; i1++) {\r\n      data.vectorIndexIndex(lastAcceptedIndex, i1 + 1, vector01);\r\n      data.vectorIndexIndex(lastAcceptedIndex, i1, vectorQ);\r\n      denominator = vector01.magnitudeSquared();\r\n      const s = Geometry.conditionalDivideFraction(vectorQ.dotProduct(vector01), denominator);\r\n      if (s !== undefined) {\r\n        if (s >= 0.0 && s <= maxExtensionFraction) {\r\n          distanceSquared = PolylineCompressionContext._vectorQ.magnitudeSquared() - denominator * s * s;\r\n          if (distanceSquared <= perpendicularDistanceSquared) {\r\n            // force accept of point i1+1 .\r\n            data.moveIndexToIndex(i1 + 1, ++lastAcceptedIndex);\r\n            i1 = i1 + 1;\r\n            continue;\r\n          }\r\n        }\r\n      }\r\n      data.moveIndexToIndex(i1, ++lastAcceptedIndex);\r\n    }\r\n    if (i1 < n)\r\n      data.moveIndexToIndex(i1, ++lastAcceptedIndex);\r\n    data.length = lastAcceptedIndex + 1;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Point3d } from \"./Point3dVector3d\";\r\nimport { Range1d } from \"./Range\";\r\nimport { PolylineCompressionContext } from \"./PolylineCompressionByEdgeOffset\";\r\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\r\n// cspell:word Puecker\r\n/** @module CartesianGeometry */\r\n/**\r\n * PolylineOps is a collection of static methods operating on polylines.\r\n * @public\r\n */\r\nexport class PolylineOps {\r\n  /**\r\n   * Return a Range1d with the shortest and longest edge lengths of the polyline.\r\n   * @param points points to examine.\r\n   */\r\n  public static edgeLengthRange(points: Point3d[]): Range1d {\r\n    const range = Range1d.createNull();\r\n    for (let i = 1; i < points.length; i++) {\r\n      range.extendX(points[i - 1].distance(points[i]));\r\n    }\r\n    return range;\r\n  }\r\n  /**\r\n   * Return a simplified subset of given points.\r\n   * * Points are removed by the Douglas-Puecker algorithm, viz https://en.wikipedia.org/wiki/RamerDouglasPeucker_algorithm\r\n   * * This is a global search, with multiple passes over the data.\r\n   * @param source\r\n   * @param chordTolerance\r\n   */\r\n  public static compressByChordError(source: Point3d[], chordTolerance: number): Point3d[] {\r\n    return PolylineCompressionContext.compressPoint3dArrayByChordError(source, chordTolerance);\r\n  }\r\n  /**\r\n   * Return a simplified subset of given points, omitting points if very close to their neighbors.\r\n   * * This is a local search, with a single pass over the data.\r\n   * @param source input points\r\n   * @param maxEdgeLength\r\n   */\r\n  public static compressShortEdges(source: Point3d[], maxEdgeLength: number): Point3d[] {\r\n    const dest = GrowableXYZArray.create(source);\r\n    PolylineCompressionContext.compressInPlaceByShortEdgeLength(dest, maxEdgeLength);\r\n    return dest.getPoint3dArray();\r\n  }\r\n  /**\r\n   * Return a simplified subset of given points, omitting points of the triangle with adjacent points is small.\r\n   * * This is a local search, with a single pass over the data.\r\n   * @param source input points\r\n   * @param maxEdgeLength\r\n   */\r\n  public static compressSmallTriangles(source: Point3d[], maxTriangleArea: number): Point3d[] {\r\n    const dest = GrowableXYZArray.create(source);\r\n    PolylineCompressionContext.compressInPlaceBySmallTriangleArea(dest, maxTriangleArea);\r\n    return dest.getPoint3dArray();\r\n  }\r\n\r\n  /**\r\n   * Return a simplified subset of given points, omitting points if close to the edge between neighboring points before and after\r\n   * * This is a local search, with a single pass over the data for each pass.\r\n   * @param source input points\r\n   * @param maxDistance omit points if this close to edge between points before and after\r\n   * @param numPass max number of times to run the filter.  numPass=2 is observed to behave well.\r\n   *\r\n   */\r\n  public static compressByPerpendicularDistance(source: Point3d[], maxDistance: number, numPass: number = 2): Point3d[] {\r\n    const dest = GrowableXYZArray.create(source);\r\n    let num0 = dest.length;\r\n    for (let pass = 0; pass < numPass; pass++) {\r\n      PolylineCompressionContext.compressInPlaceByPerpendicularDistance(dest, maxDistance);\r\n      const num1 = dest.length;\r\n      if (num1 === num0)\r\n        break;\r\n      num0 = num1;\r\n    }\r\n    return dest.getPoint3dArray();\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { BeJSONFunctions, Geometry } from \"../Geometry\";\r\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { LowAndHighXY, LowAndHighXYZ, Range1dProps, Range2dProps, Range3dProps, XAndY, XYAndZ } from \"./XYZProps\";\r\nimport { PointStreamRangeCollector, VariantPointDataStream } from \"./PointStreaming\";\r\nimport { MultiLineStringDataVariant } from \"../topology/Triangulation\";\r\n/**\r\n * Base class for Range1d, Range2d, Range3d.\r\n * @public\r\n */\r\nexport abstract class RangeBase {\r\n  /** Number considered impossibly large possibly for a coordinate in a range. */\r\n  protected static readonly _EXTREME_POSITIVE: number = 1.0e200;\r\n  /** Number considered to be impossibly negative for a coordinate in a range. */\r\n  protected static readonly _EXTREME_NEGATIVE: number = -1.0e200;\r\n  /** Return 0 if high<= low, otherwise `1/(high-low)` for use in fractionalizing */\r\n  protected static npcScaleFactor(low: number, high: number): number { return (high <= low) ? 0.0 : 1.0 / (high - low); }\r\n  /** Return true if x is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */\r\n  public static isExtremeValue(x: number): boolean { return Math.abs(x) >= RangeBase._EXTREME_POSITIVE; }\r\n  /** Return true if any x or y or z is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */\r\n  public static isExtremePoint3d(xyz: Point3d) { return RangeBase.isExtremeValue(xyz.x) || RangeBase.isExtremeValue(xyz.y) || RangeBase.isExtremeValue(xyz.z); }\r\n  /** Return true if either of x,y is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */\r\n  public static isExtremePoint2d(xy: Point2d) { return RangeBase.isExtremeValue(xy.x) || RangeBase.isExtremeValue(xy.y); }\r\n  /**\r\n   * Return the min absolute distance from any point of `[lowA,highA]' to any point of `[lowB,highB]'.\r\n   * * Both low,high pairs have order expectations:  The condition `high < low` means null interval.\r\n   * * If there is interval overlap, the distance is zero.\r\n   * @param lowA low of interval A\r\n   * @param highA high of interval A\r\n   * @param lowB low of interval B\r\n   * @param highB high of interval B\r\n   */\r\n  public static rangeToRangeAbsoluteDistance(lowA: number, highA: number, lowB: number, highB: number): number {\r\n    if (highA < lowA)\r\n      return RangeBase._EXTREME_POSITIVE;\r\n    if (highB < lowB)\r\n      return RangeBase._EXTREME_POSITIVE;\r\n    if (highB < lowA)\r\n      return lowA - highB;\r\n    if (highB <= highA)\r\n      return 0.0;\r\n    if (lowB <= highA)\r\n      return 0.0;\r\n    return lowB - highA;\r\n  }\r\n  /** Given a coordinate and pair of range limits, return the smallest distance to the range.\r\n   * * This is zero for any point inside the range\r\n   * * This is _EXTREME_POSITIVE if the range limits are inverted\r\n   * * Otherwise (i.e. x is outside a finite range) the distance to the near endpoint.\r\n   */\r\n  public static coordinateToRangeAbsoluteDistance(x: number, low: number, high: number): number {\r\n    if (high < low)\r\n      return RangeBase._EXTREME_POSITIVE;\r\n    if (x < low)\r\n      return low - x;\r\n    if (x > high)\r\n      return x - high;\r\n    return 0.0;\r\n  }\r\n}\r\n/**\r\n * Axis aligned range in 3D.\r\n * * member `low` contains minimum coordinate of range box\r\n * * member  `high` contains maximum coordinate of range box\r\n * * The range is considered null (empty) if any low member is larger than its high counterpart.\r\n * @public\r\n */\r\nexport class Range3d extends RangeBase implements LowAndHighXYZ, BeJSONFunctions {\r\n  // low and high are always non-null objects\r\n  // any direction of low.q > high.q is considered a null range.\r\n  // private ctor and setXYZXYZ_direct set the low and high explicitly (without further tests of low.q.<= high.q)\r\n  /** low point coordinates */\r\n  public low: Point3d;\r\n  /** high point coordinates */\r\n  public high: Point3d;\r\n  /** Set this transform to values that indicate it has no geometric contents. */\r\n  public setNull() {\r\n    this.low.x = RangeBase._EXTREME_POSITIVE;\r\n    this.low.y = RangeBase._EXTREME_POSITIVE;\r\n    this.low.z = RangeBase._EXTREME_POSITIVE;\r\n    this.high.x = RangeBase._EXTREME_NEGATIVE;\r\n    this.high.y = RangeBase._EXTREME_NEGATIVE;\r\n    this.high.z = RangeBase._EXTREME_NEGATIVE;\r\n  }\r\n\r\n  /** Freeze this instance (and its deep content) so it can be considered read-only */\r\n  public freeze() { Object.freeze(this); Object.freeze(this.low); Object.freeze(this.high); }\r\n  /** Flatten the low and high coordinates of any json object with low.x .. high.z into an array of 6 doubles */\r\n  public static toFloat64Array(val: LowAndHighXYZ): Float64Array { return Float64Array.of(val.low.x, val.low.y, val.low.z, val.high.x, val.high.y, val.high.z); }\r\n  /** Flatten the low and high coordinates of this into an array of 6 doubles */\r\n  public toFloat64Array(): Float64Array { return Range3d.toFloat64Array(this); }\r\n  /**\r\n   * Construct a Range3d from an array of double-precision values\r\n   * @param f64 the array, which should contain exactly 6 values in this order: lowX, lowY, lowZ, highX, highY, highZ\r\n   * @return a new Range3d object\r\n   */\r\n  public static fromFloat64Array<T extends Range3d>(f64: Float64Array): T {\r\n    if (f64.length !== 6)\r\n      throw new Error(\"invalid array\");\r\n    return new this(f64[0], f64[1], f64[2], f64[3], f64[4], f64[5]) as T;\r\n  }\r\n  /**\r\n   * Construct a Range3d from an un-typed array. This mostly useful when interpreting ECSQL query results of the 'blob' type, where you know that that result is a Range3d.\r\n   * @param buffer untyped array\r\n   * @return a new Range3d object\r\n   */\r\n  public static fromArrayBuffer<T extends Range3d>(buffer: ArrayBuffer): T { return this.fromFloat64Array(new Float64Array(buffer)); }\r\n\r\n  // explicit ctor - no enforcement of value relationships\r\n  public constructor(lowX: number = RangeBase._EXTREME_POSITIVE, lowY: number = RangeBase._EXTREME_POSITIVE, lowZ: number = RangeBase._EXTREME_POSITIVE,\r\n    highX: number = RangeBase._EXTREME_NEGATIVE, highY: number = RangeBase._EXTREME_NEGATIVE, highZ: number = RangeBase._EXTREME_NEGATIVE) {\r\n    super();\r\n    this.low = Point3d.create(lowX, lowY, lowZ);\r\n    this.high = Point3d.create(highX, highY, highZ);\r\n  }\r\n\r\n  /** Returns true if this and other have equal low and high parts, or both are null ranges. */\r\n  public isAlmostEqual(other: Range3d): boolean {\r\n    return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))\r\n      || (this.isNull && other.isNull);\r\n  }\r\n  /** copy low and high values from other. */\r\n  public setFrom(other: Range3d) { this.low.setFrom(other.low); this.high.setFrom(other.high); }\r\n  /** Return a new Range3d copied from a range or derived type */\r\n  public static createFrom<T extends Range3d>(other: Range3d, result?: T): T {\r\n    if (result) { result.setFrom(other); return result; }\r\n    return this.createXYZXYZOrCorrectToNull<T>(other.low.x, other.low.y, other.low.z,\r\n      other.high.x, other.high.y, other.high.z, result);\r\n  }\r\n  /** set this range (in place) from json such as\r\n   * * key-value pairs: `{low:[1,2,3], high:[4,5,6]}`\r\n   * * array of points: `[[1,2,3],[9,3,4],[-2,1,3] ...]`\r\n   * * Lowest level points can be `[1,2,3]` or `{x:1,y:2,z:3}`\r\n   */\r\n  public setFromJSON(json?: Range3dProps) {\r\n    if (!json)\r\n      return;\r\n    this.setNull();\r\n    if (Array.isArray(json)) {\r\n      const point = Point3d.create();\r\n      for (const value of json) {\r\n        point.setFromJSON(value);\r\n        this.extendPoint(point);\r\n      }\r\n      return;\r\n    }\r\n    const low = Point3d.fromJSON(json.low);\r\n    const high = Point3d.fromJSON(json.high);\r\n    if (!RangeBase.isExtremePoint3d(low) && !RangeBase.isExtremePoint3d(high)) {\r\n      this.extendPoint(low);\r\n      this.extendPoint(high);\r\n    }\r\n  }\r\n  /** Return a JSON object `{low: ... , high: ...}`\r\n   * with points formatted by `Point3d.toJSON()`\r\n   */\r\n  public toJSON(): Range3dProps { return { low: this.low.toJSON(), high: this.high.toJSON() }; }\r\n  /** Use `setFromJSON` to parse `json` into a new Range3d instance. */\r\n  public static fromJSON<T extends Range3d>(json?: Range3dProps): T {\r\n    const result = new this() as T;\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  // internal use only -- directly set all coordinates, test only if directed.\r\n  private setDirect(xA: number, yA: number, zA: number, xB: number, yB: number, zB: number, correctToNull: boolean) {\r\n    this.low.x = xA;\r\n    this.low.y = yA;\r\n    this.low.z = zA;\r\n\r\n    this.high.x = xB;\r\n    this.high.y = yB;\r\n    this.high.z = zB;\r\n    if (correctToNull) {\r\n      if (this.low.x > this.high.x\r\n        || this.low.y > this.high.y\r\n        || this.low.z > this.high.z)\r\n        this.setNull();\r\n    }\r\n  }\r\n  /** Return a copy */\r\n  public clone(result?: this): this {\r\n    result = result ? result : new (this.constructor as any)() as this;\r\n    result.setDirect(this.low.x, this.low.y, this.low.z, this.high.x, this.high.y, this.high.z, false);\r\n    return result;\r\n  }\r\n  /** Return a range initialized to have no content. */\r\n  public static createNull<T extends Range3d>(result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setNull();\r\n    return result;\r\n  }\r\n\r\n  /** Extend (modify in place) so that the range is large enough to include the supplied points. */\r\n  public extend(...point: Point3d[]) {\r\n    let p;\r\n    for (p of point)\r\n      this.extendPoint(p);\r\n  }\r\n  /** Return a range large enough to include the supplied points. If no points are given, the range is a null range */\r\n  public static create(...point: Point3d[]) {\r\n    const result = Range3d.createNull();\r\n    let p;\r\n    for (p of point)\r\n      result.extendPoint(p);\r\n    return result;\r\n  }\r\n  /** Create a range from freely structured MultiLineStringDataVariant. */\r\n  public static createFromVariantData(data: MultiLineStringDataVariant): Range3d {\r\n    const collector = new PointStreamRangeCollector();\r\n    VariantPointDataStream.streamXYZ(data, collector);\r\n    return collector.claimResult();\r\n  }\r\n  /** create a Range3d enclosing the transformed points. */\r\n  public static createTransformed<T extends Range3d>(transform: Transform, ...point: Point3d[]): T {\r\n    const result = this.createNull<T>();\r\n    let p;\r\n    for (p of point)\r\n      result.extendTransformedXYZ(transform, p.x, p.y, p.z);\r\n    return result;\r\n  }\r\n  /** create a Range3d enclosing the transformed points. */\r\n  public static createTransformedArray<T extends Range3d>(transform: Transform, points: Point3d[] | GrowableXYZArray): T {\r\n    const result = this.createNull<T>();\r\n    result.extendArray(points, transform);\r\n    return result;\r\n  }\r\n\r\n  /** create a Range3d enclosing the points after inverse transform. */\r\n  public static createInverseTransformedArray<T extends Range3d>(transform: Transform, points: Point3d[] | GrowableXYZArray): T {\r\n    const result = this.createNull<T>();\r\n    result.extendInverseTransformedArray(points, transform);\r\n    return result;\r\n  }\r\n  /** Set the range to be a single point supplied as x,y,z values */\r\n  public setXYZ(x: number, y: number, z: number) {\r\n    this.low.x = this.high.x = x;\r\n    this.low.y = this.high.y = y;\r\n    this.low.z = this.high.z = z;\r\n  }\r\n\r\n  /** Create a single point range */\r\n  public static createXYZ<T extends Range3d>(x: number, y: number, z: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(x, y, z, x, y, z, false);\r\n    return result;\r\n  }\r\n\r\n  /** Create a box with 2 pairs of xyz candidates. Theses are compared and shuffled as needed for the box. */\r\n  public static createXYZXYZ<T extends Range3d>(xA: number, yA: number, zA: number, xB: number, yB: number, zB: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB),\r\n      Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), false);\r\n    return result;\r\n  }\r\n\r\n  /** Create a box with 2 pairs of xyz candidates. If any direction has order flip, create null. */\r\n  public static createXYZXYZOrCorrectToNull<T extends Range3d>(xA: number, yA: number, zA: number, xB: number, yB: number, zB: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB),\r\n      Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), true);\r\n    return result;\r\n  }\r\n\r\n  /** Creates a 3d range from a 2d range's low and high members, setting the corresponding z values to the value given. */\r\n  public static createRange2d<T extends Range3d>(range: Range2d, z: number = 0, result?: T): T {\r\n    const retVal = result ? result : new this() as T;\r\n    retVal.setNull();\r\n\r\n    retVal.extendXYZ(range.low.x, range.low.y, z);\r\n    retVal.extendXYZ(range.high.x, range.high.y, z);\r\n    return retVal;\r\n  }\r\n\r\n  /** Create a range around an array of points. */\r\n  public static createArray<T extends Range3d>(points: Point3d[], result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setNull();\r\n    let point;\r\n    for (point of points)\r\n      result.extendPoint(point);\r\n    return result;\r\n  }\r\n\r\n  /** extend a range around an array of points (optionally transformed) */\r\n  public extendArray(points: Point3d[] | GrowableXYZArray, transform?: Transform) {\r\n    if (Array.isArray(points))\r\n      if (transform)\r\n        for (const point of points)\r\n          this.extendTransformedXYZ(transform, point.x, point.y, point.z);\r\n      else\r\n        for (const point of points)\r\n          this.extendXYZ(point.x, point.y, point.z);\r\n    else  // growable array -- this should be implemented without point extraction !!!\r\n      if (transform)\r\n        for (let i = 0; i < points.length; i++)\r\n          this.extendTransformedXYZ(transform, points.getXAtUncheckedPointIndex(i), points.getYAtUncheckedPointIndex(i), points.getZAtUncheckedPointIndex(i));\r\n      else\r\n        for (let i = 0; i < points.length; i++)\r\n          this.extendXYZ(points.getXAtUncheckedPointIndex(i), points.getYAtUncheckedPointIndex(i), points.getZAtUncheckedPointIndex(i));\r\n  }\r\n\r\n  /** extend a range around an array of points (optionally transformed) */\r\n  public extendInverseTransformedArray(points: Point3d[] | GrowableXYZArray, transform: Transform) {\r\n    if (Array.isArray(points))\r\n      for (const point of points)\r\n        this.extendInverseTransformedXYZ(transform, point.x, point.y, point.z);\r\n    else  // growable array -- this should be implemented without point extraction !!!\r\n      for (let i = 0; i < points.length; i++)\r\n        this.extendInverseTransformedXYZ(transform, points.getXAtUncheckedPointIndex(i), points.getYAtUncheckedPointIndex(i), points.getZAtUncheckedPointIndex(i));\r\n  }\r\n\r\n  /** multiply the point x,y,z by transform and use the coordinate to extend this range.\r\n   */\r\n  public extendTransformedXYZ(transform: Transform, x: number, y: number, z: number) {\r\n    const origin = transform.origin;\r\n    const coffs = transform.matrix.coffs;\r\n    this.extendXYZ(\r\n      origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z,\r\n      origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z,\r\n      origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);\r\n  }\r\n\r\n  /** multiply the point x,y,z,w by transform and use the coordinate to extend this range.\r\n   */\r\n  public extendTransformedXYZW(transform: Transform, x: number, y: number, z: number, w: number) {\r\n    const origin = transform.origin;\r\n    const coffs = transform.matrix.coffs;\r\n    this.extendXYZW(\r\n      origin.x * w + coffs[0] * x + coffs[1] * y + coffs[2] * z,\r\n      origin.y * w + coffs[3] * x + coffs[4] * y + coffs[5] * z,\r\n      origin.z * w + coffs[6] * x + coffs[7] * y + coffs[8] * z,\r\n      w);\r\n  }\r\n\r\n  /** multiply the point x,y,z by transform and use the coordinate to extend this range.\r\n   */\r\n  public extendInverseTransformedXYZ(transform: Transform, x: number, y: number, z: number): boolean {\r\n    const origin = transform.origin;\r\n    if (!transform.matrix.computeCachedInverse(true))\r\n      return false;\r\n    const coffs = transform.matrix.inverseCoffs!;\r\n    const xx = x - origin.x;\r\n    const yy = y - origin.y;\r\n    const zz = z - origin.z;\r\n    this.extendXYZ(\r\n      coffs[0] * xx + coffs[1] * yy + coffs[2] * zz,\r\n      coffs[3] * xx + coffs[4] * yy + coffs[5] * zz,\r\n      coffs[6] * xx + coffs[7] * yy + coffs[8] * zz);\r\n    return true;\r\n  }\r\n\r\n  /** Extend the range by the two transforms applied to xyz */\r\n  public extendTransformTransformedXYZ(transformA: Transform, transformB: Transform, x: number, y: number, z: number) {\r\n    const origin = transformB.origin;\r\n    const coffs = transformB.matrix.coffs;\r\n    this.extendTransformedXYZ(transformA,\r\n      origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z,\r\n      origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z,\r\n      origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);\r\n  }\r\n\r\n  /** Test if the box has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */\r\n  public get isNull(): boolean {\r\n    return this.high.x < this.low.x\r\n      || this.high.y < this.low.y\r\n      || this.high.z < this.low.z;\r\n  }\r\n\r\n  /** Test if  data has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */\r\n  public static isNull(data: LowAndHighXYZ): boolean {\r\n    return data.high.x < data.low.x\r\n      || data.high.y < data.low.y\r\n      || data.high.z < data.low.z;\r\n  }\r\n\r\n  /** Test of the range contains a single point. */\r\n  public get isSinglePoint(): boolean {\r\n    return this.high.x === this.low.x\r\n      && this.high.y === this.low.y\r\n      && this.high.z === this.low.z;\r\n  }\r\n\r\n  /** Return the midpoint of the diagonal.  No test for null range. */\r\n  public get center(): Point3d { return this.low.interpolate(.5, this.high); }\r\n  /** return the low x coordinate */\r\n  public get xLow(): number { return this.low.x; }\r\n  /** return the low y coordinate */\r\n  public get yLow(): number { return this.low.y; }\r\n  /** return the low z coordinate */\r\n  public get zLow(): number { return this.low.z; }\r\n  /** return the high x coordinate */\r\n  public get xHigh(): number { return this.high.x; }\r\n  /** return the high y coordinate */\r\n  public get yHigh(): number { return this.high.y; }\r\n  /** return the high z coordinate */\r\n  public get zHigh(): number { return this.high.z; }\r\n\r\n  /**  Return the length of the box in the x direction */\r\n  public xLength(): number { const a = this.high.x - this.low.x; return a > 0.0 ? a : 0.0; }\r\n\r\n  /**  Return the length of the box in the y direction */\r\n  public yLength(): number { const a = this.high.y - this.low.y; return a > 0.0 ? a : 0.0; }\r\n\r\n  /**  Return the length of the box in the z direction */\r\n  public zLength(): number { const a = this.high.z - this.low.z; return a > 0.0 ? a : 0.0; }\r\n\r\n  /**  Return the largest of the x,y, z lengths of the range. */\r\n  public maxLength(): number { return Math.max(this.xLength(), this.yLength(), this.zLength()); }\r\n  /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */\r\n  public diagonal(result?: Vector3d): Vector3d { return this.low.vectorTo(this.high, result); }\r\n\r\n  /**  Return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */\r\n  public diagonalFractionToPoint(fraction: number, result?: Point3d): Point3d { return this.low.interpolate(fraction, this.high, result); }\r\n\r\n  /**  Return a point given by fractional positions on the XYZ axes. This is done with no check for isNull !!! */\r\n  public fractionToPoint(fractionX: number, fractionY: number, fractionZ: number, result?: Point3d): Point3d {\r\n    return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);\r\n  }\r\n\r\n  /**  Return a point given by fractional positions on the XYZ axes.\r\n   *  Returns undefined if the range is null.\r\n   */\r\n  public localXYZToWorld(fractionX: number, fractionY: number, fractionZ: number, result?: Point3d): Point3d | undefined {\r\n    if (this.isNull) return undefined;\r\n    return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);\r\n  }\r\n\r\n  /** Return a point given by fractional positions on the XYZ axes.\r\n   * * Returns undefined if the range is null.\r\n   */\r\n  public localToWorld(xyz: XYAndZ, result?: Point3d): Point3d | undefined {\r\n    return this.localXYZToWorld(xyz.x, xyz.y, xyz.z, result);\r\n  }\r\n  /** Replace fractional coordinates by world coordinates.\r\n   * @returns false if null range.\r\n   */\r\n  public localToWorldArrayInPlace(points: Point3d[]): boolean {\r\n    if (this.isNull) return false;\r\n    for (const p of points)\r\n      this.low.interpolateXYZ(p.x, p.y, p.z, this.high, p);\r\n    return false;\r\n  }\r\n  /** Return fractional coordinates of point within the range.\r\n   * * returns undefined if the range is null.\r\n   * * returns undefined if any direction (x,y,z) has zero length\r\n   */\r\n  public worldToLocal(point: Point3d, result?: Point3d): Point3d | undefined {\r\n    const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);\r\n    const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);\r\n    const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);\r\n    if (ax === 0.0 || ay === 0.0 || az === 0.0)\r\n      return undefined;\r\n    return Point3d.create((point.x - this.low.x) * ax, (point.y - this.low.y) * ay, (point.z - this.low.z) * az, result);\r\n  }\r\n\r\n  /** Return fractional coordinates of point within the range.\r\n   * * returns undefined if the range is null.\r\n   * * returns undefined if any direction (x,y,z) has zero length\r\n   */\r\n  public worldToLocalArrayInPlace(point: Point3d[]): boolean {\r\n    const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);\r\n    const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);\r\n    const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);\r\n    if (ax === 0.0 || ay === 0.0 || az === 0.0)\r\n      return false;\r\n    for (const p of point)\r\n      Point3d.create((p.x - this.low.x) * ax, (p.y - this.low.y) * ay, (p.z - this.low.z) * az, p);\r\n    return true;\r\n  }\r\n\r\n  /** Return an array with the 8 corners on order wth \"x varies fastest, then y, then z\" */\r\n  public corners(): Point3d[] {\r\n    return [\r\n      Point3d.create(this.low.x, this.low.y, this.low.z),\r\n      Point3d.create(this.high.x, this.low.y, this.low.z),\r\n      Point3d.create(this.low.x, this.high.y, this.low.z),\r\n      Point3d.create(this.high.x, this.high.y, this.low.z),\r\n      Point3d.create(this.low.x, this.low.y, this.high.z),\r\n      Point3d.create(this.high.x, this.low.y, this.high.z),\r\n      Point3d.create(this.low.x, this.high.y, this.high.z),\r\n      Point3d.create(this.high.x, this.high.y, this.high.z)];\r\n  }\r\n\r\n  /** Return an array with indices of the corners of a face\r\n   * * face 0 has negative x normal\r\n   * * face 1 has positive x normal\r\n   * * face 2 has negative y normal\r\n   * * face 3 has positive y normal\r\n   * * face 4 has negative z normal\r\n   * * face 5 has positive z normal\r\n   * * Any other value returns face 5\r\n   * * faces are CCW as viewed from outside.\r\n   */\r\n  public static faceCornerIndices(index: number): number[] {\r\n    if (index === 0)\r\n      return [0, 4, 6, 2];\r\n    if (index === 1)\r\n      return [1, 3, 7, 5];\r\n    if (index === 2)\r\n      return [0, 1, 5, 4];\r\n    if (index === 3)\r\n      return [3, 2, 6, 7];\r\n    if (index === 4)\r\n      return [0, 2, 3, 1];\r\n    return [4, 5, 7, 6];\r\n  }\r\n\r\n  /** Return the largest absolute value among any coordinates in the box corners. */\r\n  public maxAbs(): number {\r\n    if (this.isNull)\r\n      return 0.0;\r\n    return Math.max(this.low.maxAbs(), this.high.maxAbs());\r\n  }\r\n\r\n  /** returns true if the x direction size is nearly zero */\r\n  public get isAlmostZeroX(): boolean { return Geometry.isSmallMetricDistance(this.xLength()); }\r\n  /** returns true if the y direction size is nearly zero */\r\n  public get isAlmostZeroY(): boolean { return Geometry.isSmallMetricDistance(this.yLength()); }\r\n  /** returns true if the z direction size is nearly zero */\r\n  public get isAlmostZeroZ(): boolean { return Geometry.isSmallMetricDistance(this.zLength()); }\r\n\r\n  /** Test if a point given as x,y,z is within the range. */\r\n  public containsXYZ(x: number, y: number, z: number): boolean {\r\n    return x >= this.low.x\r\n      && y >= this.low.y\r\n      && z >= this.low.z\r\n      && x <= this.high.x\r\n      && y <= this.high.y\r\n      && z <= this.high.z;\r\n  }\r\n\r\n  /** Test if a point given as x,y is within the range.  (Ignoring z of range) */\r\n  public containsXY(x: number, y: number): boolean {\r\n    return x >= this.low.x\r\n      && y >= this.low.y\r\n      && x <= this.high.x\r\n      && y <= this.high.y;\r\n  }\r\n  /** Test if a point is within the range. */\r\n  public containsPoint(point: Point3d): boolean { return this.containsXYZ(point.x, point.y, point.z); }\r\n\r\n  /** Test if the x,y coordinates of a point are within the range. */\r\n  public containsPointXY(point: Point3d): boolean {\r\n    return point.x >= this.low.x\r\n      && point.y >= this.low.y\r\n      && point.x <= this.high.x\r\n      && point.y <= this.high.y;\r\n  }\r\n\r\n  /** Test of other range is within this range */\r\n  public containsRange(other: Range3d): boolean {\r\n    return other.low.x >= this.low.x\r\n      && other.low.y >= this.low.y\r\n      && other.low.z >= this.low.z\r\n      && other.high.x <= this.high.x\r\n      && other.high.y <= this.high.y\r\n      && other.high.z <= this.high.z;\r\n  }\r\n\r\n  /** Test if there is any intersection with other range */\r\n  public intersectsRange(other: Range3d): boolean {\r\n    return !(this.low.x > other.high.x\r\n      || this.low.y > other.high.y\r\n      || this.low.z > other.high.z\r\n      || other.low.x > this.high.x\r\n      || other.low.y > this.high.y\r\n      || other.low.z > this.high.z);\r\n  }\r\n\r\n  /** Test if there is any intersection with other range */\r\n  public intersectsRangeXY(other: Range3d): boolean {\r\n    return !(this.low.x > other.high.x\r\n      || this.low.y > other.high.y\r\n      || other.low.x > this.high.x\r\n      || other.low.y > this.high.y);\r\n  }\r\n  /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */\r\n  public distanceToPoint(point: XYAndZ): number {\r\n    if (this.isNull)\r\n      return RangeBase._EXTREME_POSITIVE;\r\n    return Math.min(\r\n      Geometry.hypotenuseXYZ(\r\n        RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x),\r\n        RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y),\r\n        RangeBase.coordinateToRangeAbsoluteDistance(point.z, this.low.z, this.high.z)),\r\n      RangeBase._EXTREME_POSITIVE);\r\n  }\r\n\r\n  /** returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */\r\n  public distanceToRange(other: Range3d): number {\r\n    return Math.min(\r\n      Geometry.hypotenuseXYZ(\r\n        RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x),\r\n        RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y),\r\n        RangeBase.rangeToRangeAbsoluteDistance(this.low.z, this.high.z, other.low.z, other.high.z)),\r\n      RangeBase._EXTREME_POSITIVE);\r\n  }\r\n\r\n  /** Expand this range by distances a (possibly signed) in all directions */\r\n  public extendXYZ(x: number, y: number, z: number): void {\r\n    if (x < this.low.x) this.low.x = x;\r\n    if (x > this.high.x) this.high.x = x;\r\n\r\n    if (y < this.low.y) this.low.y = y;\r\n    if (y > this.high.y) this.high.y = y;\r\n\r\n    if (z < this.low.z) this.low.z = z;\r\n    if (z > this.high.z) this.high.z = z;\r\n  }\r\n\r\n  /** Expand this range by distances a (weighted and possibly signed) in all directions */\r\n  public extendXYZW(x: number, y: number, z: number, w: number): void {\r\n    if (!Geometry.isSmallMetricDistance(w))\r\n      this.extendXYZ(x / w, y / w, z / w);\r\n  }\r\n  /** Expand this range to include a point. */\r\n  public extendPoint(point: Point3d): void { this.extendXYZ(point.x, point.y, point.z); }\r\n\r\n  /** Expand this range to include a transformed point. */\r\n  public extendTransformedPoint(transform: Transform, point: Point3d): void {\r\n    this.extendTransformedXYZ(transform, point.x, point.y, point.z);\r\n  }\r\n\r\n  /** Expand this range to include a range. */\r\n  public extendRange(other: LowAndHighXYZ): void {\r\n    if (!Range3d.isNull(other)) {\r\n      this.extendXYZ(other.low.x, other.low.y, other.low.z);\r\n      this.extendXYZ(other.high.x, other.high.y, other.high.z);\r\n    }\r\n  }\r\n\r\n  /** Return the intersection of ranges. */\r\n  public intersect(other: Range3d, result?: Range3d): Range3d {\r\n    if (!this.intersectsRange(other))\r\n      return Range3d.createNull(result);\r\n    return Range3d.createXYZXYZOrCorrectToNull\r\n      (\r\n        Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y), Math.max(this.low.z, other.low.z),\r\n        Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y), Math.min(this.high.z, other.high.z),\r\n        result);\r\n\r\n  }\r\n\r\n  /** Return the union of ranges. */\r\n  public union(other: Range3d, result?: Range3d): Range3d {\r\n    if (this.isNull)\r\n      return other.clone(result);\r\n    if (other.isNull)\r\n      return this.clone(result as this);\r\n    // we trust null ranges have EXTREME values, so a null in either input leads to expected results.\r\n    return Range3d.createXYZXYZOrCorrectToNull\r\n      (\r\n        Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y), Math.min(this.low.z, other.low.z),\r\n        Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y), Math.max(this.high.z, other.high.z),\r\n        result);\r\n  }\r\n  /**\r\n   * move low and high points by scaleFactor around the center point.\r\n   * @param scaleFactor scale factor applied to low, high distance from center.\r\n   */\r\n  public scaleAboutCenterInPlace(scaleFactor: number) {\r\n    if (!this.isNull) {\r\n      scaleFactor = Math.abs(scaleFactor);\r\n      // do the scalar stuff to avoid making a temporary object ....\r\n      const xMid = 0.5 * (this.low.x + this.high.x);\r\n      const yMid = 0.5 * (this.low.y + this.high.y);\r\n      const zMid = 0.5 * (this.low.z + this.high.z);\r\n      this.high.x = Geometry.interpolate(xMid, scaleFactor, this.high.x);\r\n      this.high.y = Geometry.interpolate(yMid, scaleFactor, this.high.y);\r\n      this.high.z = Geometry.interpolate(zMid, scaleFactor, this.high.z);\r\n      this.low.x = Geometry.interpolate(xMid, scaleFactor, this.low.x);\r\n      this.low.y = Geometry.interpolate(yMid, scaleFactor, this.low.y);\r\n      this.low.z = Geometry.interpolate(zMid, scaleFactor, this.low.z);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * move all limits by a fixed amount.\r\n   * * positive delta expands the range size\r\n   * * negative delta reduces the range size\r\n   * * if any dimension reduces below zero size, the whole range becomes null\r\n   * @param delta shift to apply.\r\n   */\r\n  public expandInPlace(delta: number): void {\r\n    this.setDirect(\r\n      this.low.x - delta, this.low.y - delta, this.low.z - delta,\r\n      this.high.x + delta, this.high.y + delta, this.high.z + delta, true);\r\n  }\r\n\r\n  /** Create a local to world transform from this range. */\r\n  public getLocalToWorldTransform(result?: Transform): Transform {\r\n    return Transform.createOriginAndMatrix(Point3d.create(this.low.x, this.low.y, this.low.z), Matrix3d.createRowValues(\r\n      this.high.x - this.low.x, 0, 0,\r\n      0, this.high.y - this.low.y, 0,\r\n      0, 0, this.high.z - this.low.z,\r\n    ), result);\r\n  }\r\n\r\n  /**\r\n   * Creates an NPC to world transformation to go from 000...111 to the globally aligned cube with diagonally opposite corners that are the\r\n   * min and max of this range. The diagonal component for any degenerate direction is 1.\r\n   */\r\n  public getNpcToWorldRangeTransform(result?: Transform): Transform {\r\n    const transform = this.getLocalToWorldTransform(result);\r\n    const matrix = transform.matrix;\r\n    if (matrix.coffs[0] === 0)\r\n      matrix.coffs[0] = 1;\r\n    if (matrix.coffs[4] === 0)\r\n      matrix.coffs[4] = 1;\r\n    if (matrix.coffs[8] === 0)\r\n      matrix.coffs[8] = 1;\r\n    return transform;\r\n  }\r\n\r\n  /** Ensure that the length of each dimension of this AxisAlignedBox3d is at least a minimum size. If not, expand to minimum about the center.\r\n   * @param min The minimum length for each dimension.\r\n   */\r\n  public ensureMinLengths(min: number = .001) {\r\n    let size = (min - this.xLength()) / 2.0;\r\n    if (size > 0) {\r\n      this.low.x -= size;\r\n      this.high.x += size;\r\n    }\r\n    size = (min - this.yLength()) / 2.0;\r\n    if (size > 0) {\r\n      this.low.y -= size;\r\n      this.high.y += size;\r\n    }\r\n    size = (min - this.zLength()) / 2.0;\r\n    if (size > 0) {\r\n      this.low.z -= size;\r\n      this.high.z += size;\r\n    }\r\n  }\r\n}\r\n/**\r\n * Range on a 1d axis\r\n * * `low` and `high` members are always non-null objects\r\n * * having `low > high` indicates an empty range.\r\n * * the range contains x values for which `low <= x <= high`\r\n * @public\r\n */\r\nexport class Range1d extends RangeBase {\r\n  /** low point coordinates.  DO NOT MODIFY FROM OUTSIDE THIS CLASS */\r\n  public low: number;\r\n  /** high point coordinates.  DO NOT MODIFY FROM OUTSIDE THIS CLASS */\r\n  public high: number;\r\n  /** reset the low and high to null range state. */\r\n  public setNull() {\r\n    this.low = RangeBase._EXTREME_POSITIVE;\r\n    this.high = RangeBase._EXTREME_NEGATIVE;\r\n  }\r\n  // internal use only -- directly set all coordinates, test only if directed.\r\n  private setDirect(low: number, high: number, correctToNull: boolean = false) {\r\n    this.low = low;\r\n    this.high = high;\r\n    if (correctToNull && low > high)\r\n      this.setNull();\r\n  }\r\n  // explicit ctor - no enforcement of value relationships\r\n  private constructor(\r\n    low: number = RangeBase._EXTREME_POSITIVE,\r\n    high: number = RangeBase._EXTREME_NEGATIVE) {\r\n    super();\r\n    this.low = low; this.high = high; // duplicates set_direct, but compiler is not convinced they are set.\r\n    this.setDirect(low, high);\r\n  }\r\n  /** Returns true if this and other have equal low and high parts, or both are null ranges. */\r\n  public isAlmostEqual(other: Range1d): boolean {\r\n    return (Geometry.isSameCoordinate(this.low, other.low) && Geometry.isSameCoordinate(this.high, other.high))\r\n      || (this.isNull && other.isNull);\r\n  }\r\n  /** copy contents from other Range1d. */\r\n  public setFrom(other: Range1d) { this.low = other.low; this.high = other.high; }\r\n  /** Convert from a JSON object of one of these forms:\r\n   *\r\n   * *  Any array of numbers: `[value,value, value]`\r\n   * *  An object with low and high as properties: `{low:lowValue, high: highValue}`\r\n   */\r\n  public setFromJSON(json: Range1dProps): void {\r\n    this.setNull();\r\n    if (Array.isArray(json)) {\r\n      let value;\r\n      for (value of json) {\r\n        if (Number.isFinite(value))\r\n          this.extendX(value);\r\n      }\r\n    } else if (json.low !== undefined && Number.isFinite(json.low) && json.high !== undefined && Number.isFinite(json.high)) {\r\n      this.extendX(json.low);\r\n      this.extendX(json.high);\r\n    }\r\n  }\r\n  /** Use `setFromJSON` to parse `json` into a new Range1d instance. */\r\n  public static fromJSON<T extends Range1d>(json?: Range1dProps): T {\r\n    const result = new this() as T;\r\n    if (json)\r\n      result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Convert to a JSON object of form\r\n   * ```\r\n   *    [lowValue,highValue]\r\n   * ```\r\n   */\r\n  public toJSON(): Range1dProps { if (this.isNull) return new Array<number>(); else return [this.low, this.high]; }\r\n\r\n  /** return a new Range1d with contents of this.\r\n   * @param result optional result.\r\n   */\r\n  public clone(result?: this): this {\r\n    result = result ? result : new (this.constructor as any)() as this;\r\n    result.setDirect(this.low, this.high);\r\n    return result;\r\n  }\r\n\r\n  /** return a new Range1d with contents of this.\r\n   * @param result optional result.\r\n   */\r\n  public static createFrom<T extends Range1d>(other: T, result?: T) {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(other.low, other.high);\r\n    return result;\r\n  }\r\n\r\n  /** Create a range with no content.\r\n   * @param result optional result.\r\n   */\r\n  public static createNull<T extends Range1d>(result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setNull();\r\n    return result;\r\n  }\r\n\r\n  /** create a range with `delta` added to low and high\r\n   * * If `this` is a null range, return a null range.\r\n   */\r\n  public cloneTranslated(delta: number, result?: Range1d): Range1d {\r\n    result = result ? result : this.clone();\r\n    if (!result.isNull) {\r\n      result.low += delta;\r\n      result.high += delta;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Set this range to be a single value.\r\n   * @param x value to use as both low and high.\r\n   */\r\n  public setX(x: number) { this.low = this.high = x; }\r\n\r\n  /** Create a single point box */\r\n  public static createX<T extends Range1d>(x: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(x, x);\r\n    return result;\r\n  }\r\n\r\n  /** Create a box from two values. Values are reversed if needed\r\n   * @param xA first value\r\n   * @param xB second value\r\n   */\r\n  public static createXX<T extends Range1d>(xA: number, xB: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB),\r\n      Math.max(xA, xB));\r\n    return result;\r\n  }\r\n\r\n  /** Create a box from two values, but null range if the values are reversed\r\n   * @param xA first value\r\n   * @param xB second value\r\n   */\r\n  public static createXXOrCorrectToNull<T extends Range1d>(xA: number, xB: number, result?: T): T {\r\n    if (xB < xA)\r\n      return Range1d.createNull(result);\r\n\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB),\r\n      Math.max(xA, xB));\r\n    return result;\r\n  }\r\n\r\n  /** Create a range containing all the values in an array.\r\n   * @param values array of points to be contained in the range.\r\n   * @param result optional result.\r\n   */\r\n  public static createArray<T extends Range1d>(values: Float64Array | number[], result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    let x;\r\n    for (x of values)\r\n      result.extendX(x);\r\n    return result;\r\n  }\r\n  /** extend to include an array of values */\r\n  public extendArray(values: Float64Array | number[]) {\r\n    let x;\r\n    for (x of values)\r\n      this.extendX(x);\r\n  }\r\n\r\n  /** extend to include `values` at indices `beginIndex <= i < endIndex]`\r\n   * @param values array of values\r\n   * @param beginIndex first index to include\r\n   * @param numValue number of values to access\r\n   */\r\n  public extendArraySubset(values: Float64Array | number[], beginIndex: number, numValue: number) {\r\n    const endIndex = beginIndex + numValue;\r\n    for (let i = beginIndex; i < endIndex; i++)\r\n      this.extendX(values[i]);\r\n  }\r\n\r\n  /** Test if the box has high<low Note that a range around a single point is NOT null. */\r\n  public get isNull(): boolean {\r\n    return this.high < this.low;\r\n  }\r\n\r\n  /** Test of the range contains a single point. */\r\n  public get isSinglePoint(): boolean {\r\n    return this.high === this.low;\r\n  }\r\n\r\n  /** Return the length of the range in the x direction */\r\n  public length(): number { const a = this.high - this.low; return a > 0.0 ? a : 0.0; }\r\n\r\n  /** return a point given by fractional positions within the range. This is done with no check for isNull !!! */\r\n  public fractionToPoint(fraction: number): number {\r\n    return Geometry.interpolate(this.low, fraction, this.high);\r\n  }\r\n\r\n  /** Return the largest absolute value among the box limits. */\r\n  public maxAbs(): number {\r\n    if (this.isNull)\r\n      return 0.0;\r\n    return Math.max(Math.abs(this.low), Math.abs(this.high));\r\n  }\r\n\r\n  /** Test if the x direction size is nearly zero */\r\n  public get isAlmostZeroLength(): boolean { return Geometry.isSmallMetricDistance(this.length()); }\r\n\r\n  /** Test if a number is within the range. */\r\n  public containsX(x: number): boolean {\r\n    return x >= this.low\r\n      && x <= this.high;\r\n  }\r\n\r\n  /** Test of other range is within this range */\r\n  public containsRange(other: Range1d): boolean {\r\n    return other.low >= this.low\r\n      && other.high <= this.high;\r\n  }\r\n\r\n  /** Test if there is any intersection with other range */\r\n  public intersectsRange(other: Range1d): boolean {\r\n    return !(this.low > other.high || other.low > this.high);\r\n  }\r\n\r\n  /** returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */\r\n  public distanceToRange(other: Range1d): number {\r\n    return RangeBase.rangeToRangeAbsoluteDistance(this.low, this.high, other.low, other.high);\r\n  }\r\n\r\n  /** Return 0 if the point is within the range, otherwise the (unsigned) distance to the closest face or corner */\r\n  public distanceToX(x: number): number {\r\n    if (this.isNull)\r\n      return RangeBase._EXTREME_POSITIVE;\r\n    return RangeBase.coordinateToRangeAbsoluteDistance(x, this.low, this.high);\r\n  }\r\n\r\n  /** Expand this range by a single coordinate */\r\n  public extendX(x: number): void {\r\n    if (x < this.low) this.low = x;\r\n    if (x > this.high) this.high = x;\r\n  }\r\n\r\n  /** Expand this range to include a range. */\r\n  public extendRange(other: Range1d): void {\r\n    if (!other.isNull) {\r\n      this.extendX(other.low);\r\n      this.extendX(other.high);\r\n    }\r\n  }\r\n\r\n  /** Return the intersection of ranges. */\r\n  public intersect(other: Range1d, result?: Range1d): Range1d {\r\n    if (!this.intersectsRange(other))\r\n      return Range1d.createNull(result);\r\n\r\n    return Range1d.createXXOrCorrectToNull\r\n      (\r\n        Math.max(this.low, other.low),\r\n        Math.min(this.high, other.high),\r\n        result);\r\n\r\n  }\r\n\r\n  /** Return the union of ranges. */\r\n  /** Return the intersection of ranges. */\r\n  public union(other: Range1d, result?: Range1d): Range1d {\r\n    // we trust null ranges have EXTREME values, so a null in either input leads to expected results.\r\n    return Range1d.createXX\r\n      (\r\n        Math.min(this.low, other.low),\r\n        Math.max(this.high, other.high),\r\n        result);\r\n  }\r\n  /**\r\n   * move low and high points by scaleFactor around the center point.\r\n   * @param scaleFactor scale factor applied to low, high distance from center.\r\n   */\r\n  public scaleAboutCenterInPlace(scaleFactor: number) {\r\n    if (!this.isNull) {\r\n      scaleFactor = Math.abs(scaleFactor);\r\n      // do the scalar stuff to avoid making a temporary object ....\r\n      const xMid = 0.5 * (this.low + this.high);\r\n      this.high = Geometry.interpolate(xMid, scaleFactor, this.high);\r\n      this.low = Geometry.interpolate(xMid, scaleFactor, this.low);\r\n    }\r\n  }\r\n  /**\r\n   * move all limits by a fixed amount.\r\n   * * positive delta expands the range size\r\n   * * negative delta reduces the range size\r\n   * * if any dimension reduces below zero size, the whole range becomes null\r\n   * @param delta shift to apply.\r\n   */\r\n  public expandInPlace(delta: number): void {\r\n    this.setDirect(\r\n      this.low - delta,\r\n      this.high + delta, true);\r\n  }\r\n  /**\r\n   * clip this range to a linear half space condition\r\n   * * if `limitA > limitB` the limit space is empty\r\n   *   * make this range null\r\n   *   * return false;\r\n   * * otherwise (i.e `limitA <= limitB`)\r\n   *   * solve `a + u * f = limitA' and `a + u * f = limitA`\r\n   *   * if unable to solve (i.e. u near zero), `a` alone determines whether to (a) leave this interval unchanged or (b) reduce to nothing.\r\n   *   * the `f` values are an interval in the space of this `Range1d`\r\n   *   * restrict the range to that interval (i.e intersect existing (low,high) with the fraction interval.\r\n   *   * return true if the range is non-null after the clip.\r\n   * @param a constant of linear map\r\n   * @param u coefficient of linear map\r\n   * @param limitA crossing value, assumed in range relation with limitB\r\n   * @param limitB crossing value, assumed in range relation with limitB\r\n   * @param limitIsHigh true if the limit is an upper limit on mapped values.\r\n   *\r\n   */\r\n  public clipLinearMapToInterval(a: number, u: number, limitA: number, limitB: number): boolean {\r\n    // f = (limit - a) / u\r\n    if (limitB < limitA || this.high < this.low)\r\n      return false;\r\n    const fractionA = Geometry.conditionalDivideFraction(limitA - a, u);\r\n    const fractionB = Geometry.conditionalDivideFraction(limitB - a, u);\r\n    // single point case\r\n    if (fractionA === undefined || fractionB === undefined) {\r\n      if (limitA <= a && a <= limitB)\r\n        return true;\r\n      this.setNull();\r\n      return false;\r\n    }\r\n\r\n    if (fractionA < fractionB) {\r\n      if (fractionA > this.low)\r\n        this.low = fractionA;\r\n      if (fractionB < this.high)\r\n        this.high = fractionB;\r\n    } else {\r\n      if (fractionA < this.high)\r\n        this.high = fractionA;\r\n      if (fractionB > this.low)\r\n        this.low = fractionB;\r\n    }\r\n    if (this.high < this.low) {\r\n      this.setNull();\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n/**\r\n * Range box in xy plane\r\n * @public\r\n */\r\nexport class Range2d extends RangeBase implements LowAndHighXY {\r\n  // low and high are always non-null objects\r\n  // any direction of low.q > high.q is considered a null range.\r\n  /** low point coordinates.  DO NOT MODIFY FROM OUTSIDE THIS CLASS */\r\n  public low: Point2d;\r\n  /** low point coordinates.  DO NOT MODIFY FROM OUTSIDE THIS CLASS */\r\n  public high: Point2d;\r\n\r\n  /** reset the low and high to null range state. */\r\n  public setNull() {\r\n    this.low.x = RangeBase._EXTREME_POSITIVE;\r\n    this.low.y = RangeBase._EXTREME_POSITIVE;\r\n    this.high.x = RangeBase._EXTREME_NEGATIVE;\r\n    this.high.y = RangeBase._EXTREME_NEGATIVE;\r\n  }\r\n  /** Flatten the low and high coordinates of any json object with low.x .. high.y into an array of 4 doubles */\r\n  public static toFloat64Array(val: LowAndHighXY): Float64Array { return Float64Array.of(val.low.x, val.low.y, val.high.x, val.high.y); }\r\n  /** Flatten the low and high coordinates of this instance into an array of 4 doubles */\r\n  public toFloat64Array(): Float64Array { return Range2d.toFloat64Array(this); }\r\n  /**\r\n   * Construct a Range2d from an array of double-precision values\r\n   * @param f64 the array, which should contain exactly 4 values in this order: lowX, lowY, highX, highY\r\n   * @return a new Range2d object\r\n   */\r\n  public static fromFloat64Array<T extends Range2d>(f64: Float64Array): T {\r\n    if (f64.length !== 4)\r\n      throw new Error(\"invalid array\");\r\n    return new this(f64[0], f64[1], f64[2], f64[3]) as T;\r\n  }\r\n  /**\r\n   * Construct a Range2d from an un-typed array. This mostly useful when interpreting ECSQL query results of the 'blob' type, where you know that that result is a Range3d.\r\n   * @param buffer untyped array\r\n   * @return a new Range2d object\r\n   */\r\n  public static fromArrayBuffer<T extends Range2d>(buffer: ArrayBuffer): T { return this.fromFloat64Array(new Float64Array(buffer)); }\r\n\r\n  // explicit ctor - no enforcement of value relationships\r\n  public constructor(lowX = Range2d._EXTREME_POSITIVE, lowY = Range2d._EXTREME_POSITIVE, highX = Range2d._EXTREME_NEGATIVE, highY = Range2d._EXTREME_NEGATIVE) {\r\n    super();\r\n    this.low = Point2d.create(lowX, lowY);\r\n    this.high = Point2d.create(highX, highY);\r\n  }\r\n  /** Returns true if this and other have equal low and high parts, or both are null ranges. */\r\n  public isAlmostEqual(other: Range2d): boolean {\r\n    return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))\r\n      || (this.isNull && other.isNull);\r\n  }\r\n  /** copy all content from any `other` that has low and high xy data. */\r\n  public setFrom(other: LowAndHighXY) {\r\n    this.low.set(other.low.x, other.low.y);\r\n    this.high.set(other.high.x, other.high.y);\r\n  }\r\n  /** create a new Range2d from any `other` that has low and high xy data. */\r\n  public static createFrom<T extends Range2d>(other: LowAndHighXY, result?: T): T {\r\n    if (result) { result.setFrom(other); return result; }\r\n    return this.createXYXYOrCorrectToNull(other.low.x, other.low.y, other.high.x, other.high.y, result) as T;\r\n  }\r\n  /** treat any array of numbers as numbers to be inserted !!! */\r\n  public setFromJSON(json: Range2dProps): void {\r\n    this.setNull();\r\n    if (Array.isArray(json)) {\r\n      const point = Point2d.create();\r\n      for (const value of json) {\r\n        point.setFromJSON(value);\r\n        this.extendPoint(point);\r\n      }\r\n      return;\r\n    }\r\n    const low = Point2d.fromJSON(json.low);\r\n    const high = Point2d.fromJSON(json.high);\r\n    if (!RangeBase.isExtremePoint2d(low) && !RangeBase.isExtremePoint2d(high)) {\r\n      this.extendPoint(low);\r\n      this.extendPoint(high);\r\n    }\r\n  }\r\n  /** Freeze this instance (and its deep content) so it can be considered read-only */\r\n  public freeze() { Object.freeze(this.low); Object.freeze(this.high); }\r\n  /** return json array with two points as produced by `Point2d.toJSON` */\r\n  public toJSON(): Range2dProps { return this.isNull ? [] : [this.low.toJSON(), this.high.toJSON()]; }\r\n  /** Use `setFromJSON` to parse `json` into a new Range2d instance. */\r\n  public static fromJSON<T extends Range2d>(json?: Range2dProps): T {\r\n    const result = new this() as T;\r\n    if (json)\r\n      result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  // internal use only -- directly set all coordinates, without tests.\r\n  private setDirect(xA: number, yA: number, xB: number, yB: number, correctToNull: boolean) {\r\n    this.low.x = xA;\r\n    this.low.y = yA;\r\n\r\n    this.high.x = xB;\r\n    this.high.y = yB;\r\n    if (correctToNull) {\r\n      if (this.low.x > this.high.x || this.low.y > this.high.y)\r\n        this.setNull();\r\n    }\r\n  }\r\n  /** return a clone of this range (or copy to optional result) */\r\n  public clone(result?: this): this {\r\n    result = result ? result : new (this.constructor as any)() as this;\r\n    result.setDirect(this.low.x, this.low.y, this.high.x, this.high.y, false);\r\n    return result;\r\n  }\r\n  /** create a range with no content. */\r\n  public static createNull<T extends Range2d>(result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setNull();\r\n    return result;\r\n  }\r\n  /** Set low and hight to a single xy value. */\r\n  public setXY(x: number, y: number) {\r\n    this.low.x = this.high.x = x;\r\n    this.low.y = this.high.y = y;\r\n  }\r\n\r\n  /** Create a single point box */\r\n  public static createXY<T extends Range2d>(x: number, y: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(x, y, x, y, false);\r\n    return result;\r\n  }\r\n\r\n  /** Create a box with 2 pairs of xy candidates. Theses are compared and shuffled as needed for the box. */\r\n  public static createXYXY<T extends Range2d>(xA: number, yA: number, xB: number, yB: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB), Math.min(yA, yB),\r\n      Math.max(xA, xB), Math.max(yA, yB), false);\r\n    return result;\r\n  }\r\n  /** Create a box with 2 pairs of xy candidates. If any direction has order flip, create null. */\r\n  public static createXYXYOrCorrectToNull<T extends Range2d>(xA: number, yA: number, xB: number, yB: number, result?: T): T {\r\n    if (xA > xB || yA > yB)\r\n      return this.createNull(result);\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB), Math.min(yA, yB),\r\n      Math.max(xA, xB), Math.max(yA, yB), true);\r\n    return result;\r\n  }\r\n\r\n  /** Create a range around an array of points. */\r\n  public static createArray<T extends Range2d>(points: Point2d[], result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    let point;\r\n    for (point of points)\r\n      result.extendPoint(point);\r\n    return result;\r\n  }\r\n\r\n  /** Test if the box has high<low for any of x,y, condition. Note that a range around a single point is NOT null. */\r\n  public get isNull(): boolean {\r\n    return this.high.x < this.low.x\r\n      || this.high.y < this.low.y;\r\n  }\r\n\r\n  /** Test if the box has high strictly less than low for any of x,y, condition. Note that a range around a single point is NOT null. */\r\n  public static isNull(range: LowAndHighXY): boolean {\r\n    return range.high.x < range.low.x\r\n      || range.high.y < range.low.y;\r\n  }\r\n\r\n  /** Test of the range contains a single point. */\r\n  public get isSinglePoint(): boolean {\r\n    return this.high.x === this.low.x\r\n      && this.high.y === this.low.y;\r\n  }\r\n  /** Return the midpoint of the diagonal.  No test for null range. */\r\n  public get center(): Point2d { return this.low.interpolate(.5, this.high); }\r\n  /** return the low x coordinate */\r\n  public get xLow(): number { return this.low.x; }\r\n  /** return the low y coordinate */\r\n  public get yLow(): number { return this.low.y; }\r\n  /** return the high x coordinate */\r\n  public get xHigh(): number { return this.high.x; }\r\n  /** return the high y coordinate */\r\n  public get yHigh(): number { return this.high.y; }\r\n\r\n  /** Length of the box in the x direction */\r\n  public xLength(): number { const a = this.high.x - this.low.x; return a > 0.0 ? a : 0.0; }\r\n\r\n  /** Length of the box in the y direction */\r\n  public yLength(): number { const a = this.high.y - this.low.y; return a > 0.0 ? a : 0.0; }\r\n\r\n  /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */\r\n  public diagonal(result?: Vector2d): Vector2d { return this.low.vectorTo(this.high, result); }\r\n\r\n  /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */\r\n  public diagonalFractionToPoint(fraction: number, result?: Point2d): Point2d { return this.low.interpolate(fraction, this.high, result); }\r\n\r\n  /** return a point given by fractional positions on the XY axes. This is done with no check for isNull !!! */\r\n  public fractionToPoint(fractionX: number, fractionY: number, result?: Point2d): Point2d {\r\n    return this.low.interpolateXY(fractionX, fractionY, this.high, result);\r\n  }\r\n  /** Return an array with the 4 corners.\r\n   * * if asLoop is false, 4 corners are \"x varies fastest, then y\"\r\n   * * if asLoop is true, 5 corners are in CCW order WITH CLOSURE\r\n   */\r\n  public corners3d(asLoop: boolean = false, z: number = 0): Point3d[] {\r\n    if (asLoop)\r\n      return [\r\n        Point3d.create(this.low.x, this.low.y, z),\r\n        Point3d.create(this.high.x, this.low.y, z),\r\n        Point3d.create(this.high.x, this.high.y, z),\r\n        Point3d.create(this.low.x, this.high.y, z),\r\n        Point3d.create(this.low.x, this.low.y, z)];\r\n\r\n    return [\r\n      Point3d.create(this.low.x, this.low.y, z),\r\n      Point3d.create(this.high.x, this.low.y, z),\r\n      Point3d.create(this.low.x, this.high.y, z),\r\n      Point3d.create(this.high.x, this.high.y, z)];\r\n  }\r\n\r\n  /** Largest absolute value among any coordinates in the box corners. */\r\n  public maxAbs(): number {\r\n    if (this.isNull)\r\n      return 0.0;\r\n    return Math.max(this.low.maxAbs(), this.high.maxAbs());\r\n  }\r\n\r\n  /** Test if the x direction size is nearly zero */\r\n  public get isAlmostZeroX(): boolean { return Geometry.isSmallMetricDistance(this.xLength()); }\r\n  /** Test if the y direction size is nearly zero */\r\n  public get isAlmostZeroY(): boolean { return Geometry.isSmallMetricDistance(this.yLength()); }\r\n\r\n  /** Test if a point given as x,y is within the range. */\r\n  public containsXY(x: number, y: number): boolean {\r\n    return x >= this.low.x\r\n      && y >= this.low.y\r\n      && x <= this.high.x\r\n      && y <= this.high.y;\r\n  }\r\n\r\n  /** Test if a point is within the range. */\r\n  public containsPoint(point: XAndY): boolean { return this.containsXY(point.x, point.y); }\r\n\r\n  /** Test of other range is within this range */\r\n  public containsRange(other: LowAndHighXY): boolean {\r\n    return other.low.x >= this.low.x\r\n      && other.low.y >= this.low.y\r\n      && other.high.x <= this.high.x\r\n      && other.high.y <= this.high.y;\r\n  }\r\n\r\n  /** Test if there is any intersection with other range */\r\n  public intersectsRange(other: LowAndHighXY): boolean {\r\n    return !(this.low.x > other.high.x\r\n      || this.low.y > other.high.y\r\n      || other.low.x > this.high.x\r\n      || other.low.y > this.high.y);\r\n  }\r\n\r\n  /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */\r\n  public distanceToPoint(point: XAndY): number {\r\n    if (this.isNull)\r\n      return Range2d._EXTREME_POSITIVE;\r\n    return Math.min(\r\n      Geometry.hypotenuseXY(\r\n        RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x),\r\n        RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y)),\r\n      Range2d._EXTREME_POSITIVE);\r\n  }\r\n\r\n  /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */\r\n  public distanceToRange(other: LowAndHighXY): number {\r\n    return Math.min(\r\n      Geometry.hypotenuseXY(\r\n        RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x),\r\n        RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y)),\r\n      Range2d._EXTREME_POSITIVE);\r\n  }\r\n\r\n  /** Expand this range to include a point given by x,y */\r\n  public extendXY(x: number, y: number): void {\r\n    if (x < this.low.x) this.low.x = x;\r\n    if (x > this.high.x) this.high.x = x;\r\n\r\n    if (y < this.low.y) this.low.y = y;\r\n    if (y > this.high.y) this.high.y = y;\r\n  }\r\n\r\n  /** Expand this range to include a point given by x,y */\r\n  public extendTransformedXY(transform: Transform, x: number, y: number): void {\r\n    const x1 = transform.multiplyComponentXYZ(0, x, y, 0);\r\n    const y1 = transform.multiplyComponentXYZ(1, x, y, 0);\r\n    this.extendXY(x1, y1);\r\n  }\r\n  /** Expand this range to include a point. */\r\n  public extendPoint(point: XAndY): void { this.extendXY(point.x, point.y); }\r\n\r\n  /** Expand this range to include a range. */\r\n  public extendRange(other: LowAndHighXY): void {\r\n    if (!Range2d.isNull(other)) {\r\n      this.extendXY(other.low.x, other.low.y);\r\n      this.extendXY(other.high.x, other.high.y);\r\n    }\r\n  }\r\n\r\n  /** Return the intersection of ranges. */\r\n  public intersect(other: LowAndHighXY, result?: Range2d): Range2d {\r\n    if (!this.intersectsRange(other))\r\n      return Range2d.createNull(result);\r\n    return Range2d.createXYXY\r\n      (\r\n        Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y),\r\n        Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y),\r\n        result);\r\n\r\n  }\r\n\r\n  /** Return the union of ranges. */\r\n  public union(other: LowAndHighXY, result?: Range2d): Range2d {\r\n    if (this.isNull)\r\n      return Range2d.createFrom(other, result);\r\n    if (Range2d.isNull(other))\r\n      return this.clone(result as this);\r\n    // we trust null ranges have EXTREME values, so a null in either input leads to expected results.\r\n    return Range2d.createXYXY\r\n      (\r\n        Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y),\r\n        Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y),\r\n        result);\r\n  }\r\n\r\n  /**\r\n   * move low and high points by scaleFactor around the center point.\r\n   * @param scaleFactor scale factor applied to low, high distance from center.\r\n   */\r\n  public scaleAboutCenterInPlace(scaleFactor: number) {\r\n    if (!this.isNull) {\r\n      scaleFactor = Math.abs(scaleFactor);\r\n      // do the scalar stuff to avoid making a temporary object ....\r\n      const xMid = 0.5 * (this.low.x + this.high.x);\r\n      const yMid = 0.5 * (this.low.y + this.high.y);\r\n      this.high.x = Geometry.interpolate(xMid, scaleFactor, this.high.x);\r\n      this.high.y = Geometry.interpolate(yMid, scaleFactor, this.high.y);\r\n      this.low.x = Geometry.interpolate(xMid, scaleFactor, this.low.x);\r\n      this.low.y = Geometry.interpolate(yMid, scaleFactor, this.low.y);\r\n    }\r\n  }\r\n  /**\r\n   * move all limits by a fixed amount.\r\n   * * positive delta expands the range size\r\n   * * negative delta reduces the range size\r\n   * * if any dimension reduces below zero size, the whole range becomes null\r\n   * @param delta shift to apply.\r\n   */\r\n  public expandInPlace(delta: number): void {\r\n    this.setDirect(\r\n      this.low.x - delta, this.low.y - delta,\r\n      this.high.x + delta, this.high.y + delta, true);\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { AxisOrder, BeJSONFunctions, Geometry } from \"../Geometry\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"./Plane3dByOriginAndUnitNormal\";\r\nimport { XYAndZ } from \"./XYZProps\";\r\nimport { CurveLocationDetail, CurveLocationDetailPair, CurveCurveApproachType } from \"../curve/CurveLocationDetail\";\r\nimport { SmallSystem } from \"../numerics/Polynomials\";\r\nimport { Vector2d } from \"./Point2dVector2d\";\r\nimport { Range1d, Range3d } from \"./Range\";\r\n/** A Ray3d contains\r\n * * an origin point.\r\n * * a direction vector.  The vector is NOT required to be normalized.\r\n *  * an optional weight (number).\r\n * @public\r\n */\r\nexport class Ray3d implements BeJSONFunctions {\r\n  /** The ray origin */\r\n  public origin: Point3d;\r\n  /** The ray direction.  This is commonly (but not always) a unit vector. */\r\n  public direction: Vector3d;\r\n  /** Numeric annotation. */\r\n  public a?: number; // optional, e.g. weight.\r\n  // constructor captures references !!!\r\n  private constructor(origin: Point3d, direction: Vector3d) {\r\n    this.origin = origin;\r\n    this.direction = direction;\r\n    this.a = undefined;\r\n  }\r\n  private static _create(x: number, y: number, z: number, u: number, v: number, w: number) {\r\n    return new Ray3d(Point3d.create(x, y, z), Vector3d.create(u, v, w));\r\n  }\r\n  /** Create a ray on the x axis. */\r\n  public static createXAxis(): Ray3d { return Ray3d._create(0, 0, 0, 1, 0, 0); }\r\n  /** Create a ray on the y axis. */\r\n  public static createYAxis(): Ray3d { return Ray3d._create(0, 0, 0, 0, 1, 0); }\r\n  /** Create a ray on the z axis. */\r\n  public static createZAxis(): Ray3d { return Ray3d._create(0, 0, 0, 0, 0, 1); }\r\n  /** Create a ray with all zeros. */\r\n  public static createZero(result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.origin.setZero();\r\n      result.direction.setZero();\r\n      return result;\r\n    }\r\n    return new Ray3d(Point3d.createZero(), Vector3d.createZero());\r\n  }\r\n  /** Test for nearly equal rays. */\r\n  public isAlmostEqual(other: Ray3d): boolean {\r\n    return this.origin.isAlmostEqual(other.origin) && this.direction.isAlmostEqual(other.direction);\r\n  }\r\n  /** Create a ray from origin and direction. */\r\n  public static create(origin: Point3d, direction: Vector3d, result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.set(origin, direction);\r\n      return result;\r\n    }\r\n    return new Ray3d(origin.clone(), direction.clone());\r\n  }\r\n  /**\r\n   * Given a homogeneous point and its derivative components, construct a Ray3d with cartesian coordinates and derivatives.\r\n   * @param weightedPoint `[x,y,z,w]` parts of weighted point.\r\n   * @param weightedDerivative `[x,y,z,w]` derivatives\r\n   * @param result\r\n   */\r\n  public static createWeightedDerivative(weightedPoint: Float64Array, weightedDerivative: Float64Array, result?: Ray3d): Ray3d | undefined {\r\n    const w = weightedPoint[3];\r\n    const dw = weightedDerivative[3];\r\n    const x = weightedPoint[0];\r\n    const y = weightedPoint[1];\r\n    const z = weightedPoint[2];\r\n    const dx = weightedDerivative[0] * w - weightedPoint[0] * dw;\r\n    const dy = weightedDerivative[1] * w - weightedPoint[1] * dw;\r\n    const dz = weightedDerivative[2] * w - weightedPoint[2] * dw;\r\n    if (Geometry.isSmallMetricDistance(w))\r\n      return undefined;\r\n    const divW = 1.0 / w;\r\n    const divWW = divW * divW;\r\n    return Ray3d.createXYZUVW(x * divW, y * divW, z * divW, dx * divWW, dy * divWW, dz * divWW, result);\r\n  }\r\n  /** Create from coordinates of the origin and direction. */\r\n  public static createXYZUVW(originX: number, originY: number, originZ: number, directionX: number, directionY: number, directionZ: number, result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.getOriginRef().set(originX, originY, originZ);\r\n      result.getDirectionRef().set(directionX, directionY, directionZ);\r\n      return result;\r\n    }\r\n    return new Ray3d(Point3d.create(originX, originY, originZ), Vector3d.create(directionX, directionY, directionZ));\r\n  }\r\n  /** Capture origin and direction in a new Ray3d. */\r\n  public static createCapture(origin: Point3d, direction: Vector3d): Ray3d {\r\n    return new Ray3d(origin, direction);\r\n  }\r\n  /** Create from (clones of) origin, direction, and numeric weight. */\r\n  public static createPointVectorNumber(origin: Point3d, direction: Vector3d, a: number, result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.origin.setFrom(origin);\r\n      result.direction.setFrom(direction);\r\n      result.a = a;\r\n      return result;\r\n    }\r\n    result = new Ray3d(origin.clone(), direction.clone());\r\n    result.a = a;\r\n    return result;\r\n  }\r\n  /** Create from origin and target.  The direction vector is the full length (non-unit) vector from origin to target. */\r\n  public static createStartEnd(origin: Point3d, target: Point3d, result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.origin.setFrom(origin);\r\n      result.direction.setStartEnd(origin, target);\r\n      return result;\r\n    }\r\n    return new Ray3d(origin, Vector3d.createStartEnd(origin, target));\r\n  }\r\n  /** Return a reference to the ray's origin. */\r\n  public getOriginRef(): Point3d { return this.origin; }\r\n  /** Return a reference to the ray's direction vector. */\r\n  public getDirectionRef(): Vector3d { return this.direction; }\r\n  /** copy coordinates from origin and direction. */\r\n  public set(origin: Point3d, direction: Vector3d): void {\r\n    this.origin.setFrom(origin);\r\n    this.direction.setFrom(direction);\r\n  }\r\n  /** Clone the ray. */\r\n  public clone(result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.set(this.origin.clone(), this.direction.clone());\r\n      return result;\r\n    }\r\n    return new Ray3d(this.origin.clone(), this.direction.clone());\r\n  }\r\n  /** Create a clone and return the transform of the clone. */\r\n  public cloneTransformed(transform: Transform): Ray3d {\r\n    return new Ray3d(transform.multiplyPoint3d(this.origin), transform.multiplyVector(this.direction));\r\n  }\r\n  /** Apply a transform in place. */\r\n  public transformInPlace(transform: Transform) {\r\n    transform.multiplyPoint3d(this.origin, this.origin);\r\n    transform.multiplyVector(this.direction, this.direction);\r\n  }\r\n  /** Copy data from another ray. */\r\n  public setFrom(source: Ray3d): void { this.set(source.origin, source.direction); }\r\n  /** * fraction 0 is the ray origin.\r\n   * * fraction 1 is at the end of the direction vector when placed at the origin.\r\n   * @returns Return a point at fractional position along the ray.\r\n   */\r\n  public fractionToPoint(fraction: number): Point3d { return this.origin.plusScaled(this.direction, fraction); }\r\n  /** Return the dot product of the ray's direction vector with a vector from the ray origin to the space point. */\r\n  public dotProductToPoint(spacePoint: Point3d): number { return this.direction.dotProductStartEnd(this.origin, spacePoint); }\r\n  /**\r\n   * Return the fractional coordinate (along the direction vector) of the spacePoint projected to the ray.\r\n   */\r\n  public pointToFraction(spacePoint: Point3d): number {\r\n    return Geometry.safeDivideFraction(this.direction.dotProductStartEnd(this.origin, spacePoint), this.direction.magnitudeSquared(), 0);\r\n  }\r\n  /**\r\n   *\r\n   * Return the spacePoint projected onto the ray.\r\n   */\r\n  public projectPointToRay(spacePoint: Point3d): Point3d {\r\n    return this.origin.plusScaled(this.direction, this.pointToFraction(spacePoint));\r\n  }\r\n  /** Return a transform for rigid axes\r\n   * at ray origin with z in ray direction.  If the direction vector is zero, axes default to identity (from createHeadsUpTriad)\r\n   */\r\n  public toRigidZFrame(): Transform | undefined {\r\n    const axes = Matrix3d.createRigidHeadsUp(this.direction, AxisOrder.ZXY);\r\n    return Transform.createOriginAndMatrix(this.origin, axes);\r\n  }\r\n  /**\r\n   * Convert {origin:[x,y,z], direction:[u,v,w]} to a Ray3d.\r\n   */\r\n  public setFromJSON(json?: any) {\r\n    if (!json) {\r\n      this.origin.set(0, 0, 0);\r\n      this.direction.set(0, 0, 1);\r\n      return;\r\n    }\r\n    this.origin.setFromJSON(json.origin);\r\n    this.direction.setFromJSON(json.direction);\r\n  }\r\n  /**\r\n   * try to scale the direction vector to a given magnitude.\r\n   * @returns Returns false if ray direction is a zero vector.\r\n   */\r\n  public trySetDirectionMagnitudeInPlace(magnitude: number = 1.0): boolean {\r\n    if (this.direction.tryNormalizeInPlace()) {\r\n      this.direction.scaleInPlace(magnitude);\r\n      return true;\r\n    }\r\n    this.direction.setZero();\r\n    this.a = 0.0;\r\n    return false;\r\n  }\r\n  /**\r\n   * If parameter `a` is clearly nonzero and the direction vector can be normalized,\r\n   * * save the parameter `a` as the optional `a` member of the ray.\r\n   * * normalize the ray's direction vector\r\n   * If parameter `a` is nearly zero,\r\n   * * Set the `a` member to zero\r\n   * * Set the ray's direction vector to zero.\r\n   * @param a area to be saved.\r\n   */\r\n  // input a ray and \"a\" understood as an area.\r\n  // if a is clearly nonzero metric squared and the vector can be normalized, install those and return true.\r\n  // otherwise set ray.z to zero and zero the vector of the ray and return false.\r\n  public tryNormalizeInPlaceWithAreaWeight(a: number): boolean {\r\n    const tolerance = Geometry.smallMetricDistanceSquared;\r\n    this.a = a;\r\n    if (Math.abs(a) > tolerance && this.direction.tryNormalizeInPlace(tolerance))\r\n      return true;\r\n    this.direction.setZero();\r\n    this.a = 0.0;\r\n    return false;\r\n  }\r\n  /**\r\n   * Convert an Angle to a JSON object.\r\n   * @return {*} [origin,normal]\r\n   */\r\n  public toJSON(): any { return { origin: this.origin.toJSON(), direction: this.direction.toJSON() }; }\r\n  /** Create a new ray from json object.  See `setFromJSON` for json structure; */\r\n  public static fromJSON(json?: any) {\r\n    const result = Ray3d.createXAxis();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** return distance from the ray to point in space */\r\n  public distance(spacePoint: Point3d): number {\r\n    const uu = this.direction.magnitudeSquared();\r\n    const uv = this.dotProductToPoint(spacePoint);\r\n    const aa = Geometry.inverseMetricDistanceSquared(uu);\r\n    if (aa)\r\n      return Math.sqrt(this.origin.distanceSquared(spacePoint) - uv * uv * aa);\r\n    else\r\n      return Math.sqrt(this.origin.distanceSquared(spacePoint));\r\n  }\r\n  /**\r\n   * Return the intersection of the unbounded ray with a plane.\r\n   * Stores the point of intersection in the result point given as a parameter,\r\n   * and returns the parameter along the ray where the intersection occurs.\r\n   * Returns undefined if the ray and plane are parallel.\r\n   */\r\n  public intersectionWithPlane(plane: Plane3dByOriginAndUnitNormal, result?: Point3d): number | undefined {\r\n    const vectorA = Vector3d.createStartEnd(plane.getOriginRef(), this.origin);\r\n    const uDotN = this.direction.dotProduct(plane.getNormalRef());\r\n    const aDotN = vectorA.dotProduct(plane.getNormalRef());\r\n    const division = Geometry.conditionalDivideFraction(-aDotN, uDotN);\r\n    if (undefined === division)\r\n      return undefined;\r\n    if (result) {\r\n      this.origin.plusScaled(this.direction, division, result);\r\n    }\r\n    return division;\r\n  }\r\n\r\n  /**\r\n   * * Find intersection of the ray with a Range3d.\r\n   * * return the range of fractions (on the ray) which are \"inside\" the range.\r\n   * * Note that a range is always returned;  if there is no intersection it is indicated by the test `result.sNull`\r\n   */\r\n  public intersectionWithRange3d(range: Range3d, result?: Range1d): Range1d {\r\n    if (range.isNull)\r\n      return Range1d.createNull(result);\r\n    const interval = Range1d.createXX(-Geometry.largeCoordinateResult, Geometry.largeCoordinateResult, result);\r\n    if (interval.clipLinearMapToInterval(this.origin.x, this.direction.x, range.low.x, range.high.x)\r\n      && interval.clipLinearMapToInterval(this.origin.y, this.direction.y, range.low.y, range.high.y)\r\n      && interval.clipLinearMapToInterval(this.origin.z, this.direction.z, range.low.z, range.high.z))\r\n      return interval;\r\n    return interval;\r\n  }\r\n\r\n  /** Construct a vector from `ray.origin` to target point.\r\n   * * return the part of the vector that is perpendicular to `ray.direction`.\r\n   *  * i.e. return the shortest vector from the ray to the point.\r\n   */\r\n  public perpendicularPartOfVectorToTarget(targetPoint: XYAndZ, result?: Vector3d): Vector3d {\r\n    const vectorV = Vector3d.createStartEnd(this.origin, targetPoint);\r\n    const uu = this.direction.magnitudeSquared();\r\n    const uv = this.direction.dotProductStartEnd(this.origin, targetPoint);\r\n    const fraction = Geometry.safeDivideFraction(uv, uu, 0.0);\r\n    return vectorV.plusScaled(this.direction, -fraction, result);\r\n  }\r\n  /** Determine if two rays intersect, are fully overlapped, parallel but no coincident, or skew\r\n   * * Return a CurveLocationDetailPair which\r\n   * * contains fraction and point on each ray.\r\n   * * has (in the CurveLocationDetailPair structure, as member approachType) annotation indicating one of these relationships\r\n   *   * CurveCurveApproachType.Intersection -- the rays have a simple intersection, at fractions indicated in detailA and detailB\r\n   *   * CurveCurveApproachType.PerpendicularChord -- there is pair of where the rays have closest approach.  The rays are skew in space.\r\n   *   * CurveCurveApproachType.CoincidentGeometry -- the rays are the same unbounded line in space. The fractions and points are a representative single common point.\r\n   *   * CurveCurveApproachType.Parallel -- the rays are parallel (and not coincident).   The two points are at the minimum distance\r\n   */\r\n  public static closestApproachRay3dRay3d(rayA: Ray3d, rayB: Ray3d): CurveLocationDetailPair {\r\n    const intersectionFractions = Vector2d.create();\r\n    let fractionA, fractionB;\r\n    let pointA, pointB;\r\n    let pairType;\r\n    if (SmallSystem.ray3dXYZUVWClosestApproachUnbounded(\r\n      rayA.origin.x, rayA.origin.y, rayA.origin.z, rayA.direction.x, rayA.direction.y, rayA.direction.z,\r\n      rayB.origin.x, rayB.origin.y, rayB.origin.z, rayB.direction.x, rayB.direction.y, rayB.direction.z, intersectionFractions)) {\r\n      fractionA = intersectionFractions.x;\r\n      fractionB = intersectionFractions.y;\r\n      pointA = rayA.fractionToPoint(fractionA);\r\n      pointB = rayB.fractionToPoint(fractionB);\r\n      pairType = pointA.isAlmostEqualMetric(pointB) ? CurveCurveApproachType.Intersection : CurveCurveApproachType.PerpendicularChord;\r\n    } else {\r\n      fractionB = 0.0;\r\n      fractionA = rayA.pointToFraction(rayB.origin);\r\n      pointA = rayA.fractionToPoint(fractionA);\r\n      pointB = rayB.fractionToPoint(fractionB);\r\n      pairType = pointA.isAlmostEqualMetric(pointB) ? CurveCurveApproachType.CoincidentGeometry : CurveCurveApproachType.ParallelGeometry;\r\n    }\r\n    const pair = CurveLocationDetailPair.createCapture(\r\n      CurveLocationDetail.createRayFractionPoint(rayA, fractionA, rayA.fractionToPoint(fractionA)),\r\n      CurveLocationDetail.createRayFractionPoint(rayB, fractionB, rayB.fractionToPoint(fractionB)));\r\n    pair.approachType = pairType;\r\n    return pair;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\n/**\r\n * * A Segment1d is an interval of an axis named x.\r\n * * The interval is defined by two values x0 and x1.\r\n * * The x0 and x1 values can be in either order.\r\n *   * if `x0 < x1` fractional coordinates within the segment move from left to right.\r\n *   * if `x0 > x1` fractional coordinates within the segment move from right to left.\r\n * * This differs from a Range1d in that:\r\n * * For a Range1d the reversed ordering of its limit values means \"empty interval\".\r\n * * For a Segment1d the reversed ordering is a real interval but fractional positions move backwards.\r\n * * The segment is parameterized with a fraction\r\n * * * Fraction 0 is the start (`x0`)\r\n * * * Fraction 1 is the end (`x1`)\r\n * * * The fraction equation is `x = x0 + fraction * (x1-x0)` or (equivalently) `x = (1-fraction) * x0 + fraction * x1`\r\n * @public\r\n */\r\nexport class Segment1d {\r\n  /** start coordinate */\r\n  public x0: number;\r\n  /** end coordinate */\r\n  public x1: number;\r\n  private constructor(x0: number, x1: number) {\r\n    this.x0 = x0;\r\n    this.x1 = x1;\r\n  }\r\n  /**\r\n   * replace both end values.\r\n   * @param x0 new x0 value\r\n   * @param x1 new y0 value\r\n   */\r\n  public set(x0: number, x1: number) { this.x0 = x0, this.x1 = x1; }\r\n  /**\r\n   * shift (translate) the segment along its axis by adding `dx` to both `x0` and `x1`.\r\n   * @param dx value to add to both x0 and x1\r\n   */\r\n  public shift(dx: number) { this.x0 += dx, this.x1 += dx; }\r\n  /**\r\n   * create segment1d with given end values\r\n   * @param x0 start value\r\n   * @param x1 end value\r\n   * @param result optional pre-existing result to be reinitialized.\r\n   */\r\n  public static create(x0: number = 0, x1: number = 1, result?: Segment1d): Segment1d {\r\n    if (!result)\r\n      return new Segment1d(x0, x1);\r\n    result.set(x0, x1);\r\n    return result;\r\n  }\r\n  /**\r\n   * Copy both end values from other Segment1d\r\n   * @param other source Segment1d\r\n   */\r\n  public setFrom(other: Segment1d) { this.x0 = other.x0; this.x1 = other.x1; }\r\n  /**\r\n   * clone this Segment1d, return as a separate object.\r\n   */\r\n  public clone(): Segment1d { return new Segment1d(this.x0, this.x1); }\r\n  /**\r\n   * Returns true if both coordinates (`x0` and `x1`) are in the 0..1 range.\r\n   */\r\n  public get isIn01() {\r\n    return Geometry.isIn01(this.x0) && Geometry.isIn01(this.x1);\r\n\r\n  }\r\n  /**\r\n   * Evaluate the segment at fractional position\r\n   * @returns position within the segment\r\n   * @param fraction fractional position within this segment\r\n   */\r\n  public fractionToPoint(fraction: number): number { return Geometry.interpolate(this.x0, fraction, this.x1); }\r\n  /**\r\n   * Return the signed start-to-end shift (aka distance)\r\n   */\r\n  public signedDelta(): number { return this.x1 - this.x0; }\r\n  /**\r\n   * * swap the x0 and x1 member values.\r\n   * * This makes the fractionToPoint evaluates reverse direction.\r\n   */\r\n  public reverseInPlace(): void { const x = this.x0; this.x0 = this.x1; this.x1 = x; }\r\n  /**\r\n   * Near equality test, using Geometry.isSameCoordinate for tolerances.\r\n   */\r\n  public isAlmostEqual(other: Segment1d): boolean {\r\n    return Geometry.isSameCoordinate(this.x0, other.x0) && Geometry.isSameCoordinate(this.x1, other.x1);\r\n  }\r\n  /**\r\n   * Return true if the segment limits are (exactly) 0 and 1\r\n   */\r\n  public get isExact01(): boolean { return this.x0 === 0.0 && this.x1 === 1.0; }\r\n  /**\r\n   * Return true if the segment limits are (exactly) 1 and 0\r\n   */\r\n  public get isExact01Reversed(): boolean { return this.x0 === 1.0 && this.x1 === 0.0; }\r\n\r\n  /** On input, `this` is an interval of a line.  On output, the interval has been clipped to positive parts of a linear function\r\n   * * f0 and f1 are values at parameter values 0 and 1 (which are in general NOT x0 and x1)\r\n   * * From that determine where the segment crosses function value 0.\r\n   * * The segment contains some interval in the same parameter space.\r\n   * * Clip the segment to the positive part of the space.\r\n   * * Return true (and modify the segment) if any of the segment remains.\r\n   * * Return false (but without modifying the segment) if the active part is entirely out.\r\n   */\r\n  public clipBy01FunctionValuesPositive(f0: number, f1: number): boolean {\r\n    const df01 = f1 - f0;\r\n    const fA = f0 + this.x0 * df01;\r\n    const fB = f0 + this.x1 * df01;\r\n    const dfAB = fB - fA;\r\n    if (fA > 0) {\r\n      if (fB >= 0) return true; // inside at both ends\r\n      /** There is an inside to outside crossing. The division is safe ... (and value between 0 and 1) */\r\n      const u = -fA / dfAB;\r\n      this.x1 = this.x0 + u * (this.x1 - this.x0);\r\n      return true;\r\n    } else if (fA < 0) {\r\n      if (fB < 0) return false;   // outside at both ends.\r\n      /** There is an outside to inside crossing crossing. The division is safe ... (and value between 0 and 1) */\r\n      const u = -fA / dfAB;\r\n      this.x0 = this.x0 + u * (this.x1 - this.x0);\r\n      return true;\r\n    }\r\n    /** fA is on the cut.   fB determines the entire segment. */\r\n    return fB > 0;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { Geometry, AxisOrder, BeJSONFunctions } from \"../Geometry\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Range3d } from \"./Range\";\r\nimport { Point2d } from \"./Point2dVector2d\";\r\nimport { XAndY, XYAndZ, TransformProps } from \"./XYZProps\";\r\nimport { XYZ, Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\n\r\n/** A transform is an origin and a Matrix3d.\r\n *\r\n * * This describes a coordinate frame with\r\n * this origin, with the columns of the Matrix3d being the\r\n * local x,y,z axis directions.\r\n * *  Beware that for common transformations (e.g. scale about point,\r\n * rotate around line, mirror across a plane) the \"fixed point\" that is used\r\n * when describing the transform is NOT the \"origin\" stored in the transform.\r\n * Setup methods (e.g createFixedPointAndMatrix, createScaleAboutPoint)\r\n * take care of determining the appropriate origin coordinates.\r\n * @public\r\n */\r\nexport class Transform implements BeJSONFunctions {\r\n  // static (one per class) vars for temporaries in computation.\r\n  // ASSUME any user of these vars needs them only within its own scope\r\n  // ASSUME no calls to other methods that use the same scratch.\r\n  // When Transform was in the same file with Point3d, this was initialized right here.\r\n  // But when split, there is a load order issue, so it has to be initialized at point-of-use\r\n  private static _scratchPoint: Point3d;\r\n  private _origin: XYZ;\r\n  private _matrix: Matrix3d;\r\n  // Constructor accepts and uses POINTER to content .. no copy here.\r\n  private constructor(origin: XYZ, matrix: Matrix3d) { this._origin = origin; this._matrix = matrix; }\r\n\r\n  private static _identity?: Transform;\r\n  /** The identity Transform. Value is frozen and cannot be modified. */\r\n  public static get identity(): Transform {\r\n    if (undefined === this._identity) {\r\n      this._identity = Transform.createIdentity();\r\n      this._identity.freeze();\r\n    }\r\n\r\n    return this._identity;\r\n  }\r\n  /** Freeze this instance (and its deep content) so it can be considered read-only */\r\n  public freeze() { Object.freeze(this); Object.freeze(this._origin); this._matrix.freeze(); }\r\n  /**\r\n   * Copy contents from other Transform into this Transform\r\n   * @param other source transform\r\n   */\r\n  public setFrom(other: Transform) { this._origin.setFrom(other._origin), this._matrix.setFrom(other._matrix); }\r\n  /** Set this Transform to be an identity. */\r\n  public setIdentity() { this._origin.setZero(); this._matrix.setIdentity(); }\r\n  /** Set this Transform instance from flexible inputs:\r\n   * * Any object (such as another Transform) that has `origin` and `matrix` members accepted by Point3d.setFromJSON and Matrix3d.setFromJSON\r\n   * * An array of 3 number arrays, each with 4 entries which are rows in a 3x4 matrix.\r\n   * * An array of 12 numbers, each block of 4 entries as a row 3x4 matrix.\r\n   */\r\n  public setFromJSON(json?: TransformProps): void {\r\n    if (json) {\r\n      if (json instanceof Object && (json as any).origin && (json as any).matrix) {\r\n        this._origin.setFromJSON((json as any).origin);\r\n        this._matrix.setFromJSON((json as any).matrix);\r\n        return;\r\n      }\r\n      if (Geometry.isArrayOfNumberArray(json, 3, 4)) {\r\n        const data = json as number[][];\r\n        this._matrix.setRowValues(\r\n          data[0][0], data[0][1], data[0][2],\r\n          data[1][0], data[1][1], data[1][2],\r\n          data[2][0], data[2][1], data[2][2]);\r\n        this._origin.set(data[0][3], data[1][3], data[2][3]);\r\n        return;\r\n      }\r\n      if (Geometry.isNumberArray(json, 12)) {\r\n        const data = json as number[];\r\n        this._matrix.setRowValues(\r\n          data[0], data[1], data[2],\r\n          data[4], data[5], data[6],\r\n          data[8], data[9], data[10]);\r\n        this._origin.set(data[3], data[7], data[11]);\r\n        return;\r\n      }\r\n    }\r\n    this.setIdentity();\r\n  }\r\n  /**\r\n   * Test for near equality with other Transform.  Comparison uses the isAlmostEqual methods on\r\n   * the origin and matrix parts.\r\n   * @param other Transform to compare to.\r\n   */\r\n  public isAlmostEqual(other: Transform): boolean { return this._origin.isAlmostEqual(other._origin) && this._matrix.isAlmostEqual(other._matrix); }\r\n  /** Return a 3 by 4 matrix containing the rows of this Transform\r\n   * * This transform's origin is the [3] entry of the json arrays\r\n   */\r\n  public toJSON(): TransformProps {\r\n    // return { origin: this._origin.toJSON(), matrix: this._matrix.toJSON() };\r\n    return [\r\n      [this._matrix.coffs[0], this._matrix.coffs[1], this._matrix.coffs[2], this._origin.x],\r\n      [this._matrix.coffs[3], this._matrix.coffs[4], this._matrix.coffs[5], this._origin.y],\r\n      [this._matrix.coffs[6], this._matrix.coffs[7], this._matrix.coffs[8], this._origin.z],\r\n    ];\r\n  }\r\n  /** Return a new Transform initialized by `setFromJSON (json)` */\r\n  public static fromJSON(json?: TransformProps): Transform {\r\n    const result = Transform.createIdentity();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Copy the contents of this transform into a new Transform (or to the result, if specified). */\r\n  public clone(result?: Transform): Transform {\r\n    if (result) {\r\n      result._matrix.setFrom(this._matrix);\r\n      result._origin.setFrom(this._origin);\r\n      return result;\r\n    }\r\n    return new Transform(\r\n      Point3d.createFrom(this._origin),\r\n      this._matrix.clone());\r\n  }\r\n  /** Return a copy of this Transform, modified so that its axes are rigid\r\n   * * The first axis direction named in axisOrder is preserved\r\n   * * The plane of the first and second directions is preserved, and its vector in the rigid matrix has positive dot product with the corresponding vector if the instance\r\n   * * The third named column is the cross product of the first and second.\r\n   */\r\n  public cloneRigid(axisOrder: AxisOrder = AxisOrder.XYZ): Transform | undefined {\r\n    const axes0 = Matrix3d.createRigidFromMatrix3d(this.matrix, axisOrder);\r\n    if (!axes0)\r\n      return undefined;\r\n    return new Transform(this.origin.cloneAsPoint3d(), axes0);\r\n  }\r\n  /** Create a copy with the given origin and matrix captured as the Transform origin and Matrix3d. */\r\n  public static createRefs(origin: XYZ, matrix: Matrix3d, result?: Transform): Transform {\r\n    if (result) {\r\n      result._origin = origin;\r\n      result._matrix = matrix;\r\n      return result;\r\n    }\r\n    return new Transform(origin, matrix);\r\n  }\r\n  /** Create a transform with complete contents given */\r\n  public static createRowValues(\r\n    qxx: number, qxy: number, qxz: number, ax: number,\r\n    qyx: number, qyy: number, qyz: number, ay: number,\r\n    qzx: number, qzy: number, qzz: number, az: number,\r\n    result?: Transform): Transform {\r\n    if (result) {\r\n      result._origin.set(ax, ay, az);\r\n      result._matrix.setRowValues(qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz);\r\n      return result;\r\n    }\r\n    return new Transform(Point3d.create(ax, ay, az), Matrix3d.createRowValues(qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz));\r\n  }\r\n  /** Create a transform with all zeros.\r\n   */\r\n  public static createZero(result?: Transform): Transform {\r\n    return Transform.createRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, result);\r\n  }\r\n\r\n  /**\r\n   * create a Transform with translation provided by x,y,z parts.\r\n   * @param x x part of translation\r\n   * @param y y part of translation\r\n   * @param z z part of translation\r\n   * @param result optional result\r\n   * @returns new or updated transform.\r\n   */\r\n  public static createTranslationXYZ(x: number = 0, y: number = 0, z: number = 0, result?: Transform): Transform {\r\n    return Transform.createRefs(Vector3d.create(x, y, z), Matrix3d.createIdentity(), result);\r\n  }\r\n  /** Create a matrix with specified translation part.\r\n   * @param XYZ x,y,z parts of the translation.\r\n   * @returns new or updated transform.\r\n   */\r\n  public static createTranslation(translation: XYZ, result?: Transform): Transform {\r\n    return Transform.createRefs(translation, Matrix3d.createIdentity(), result);\r\n  }\r\n\r\n  /** Return a reference to the matrix within the transform.  (NOT a copy) */\r\n  public get matrix(): Matrix3d { return this._matrix; }\r\n  /** Return a reference to the origin within the transform.  (NOT a copy) */\r\n  public get origin(): XYZ { return this._origin; }\r\n\r\n  /** return a (clone of) the origin part of the transform, as a Point3d */\r\n  public getOrigin(): Point3d { return Point3d.createFrom(this._origin); }\r\n\r\n  /** return a (clone of) the origin part of the transform, as a Vector3d */\r\n  public getTranslation(): Vector3d { return Vector3d.createFrom(this._origin); }\r\n\r\n  /** test if the transform has 000 origin and identity Matrix3d */\r\n  public get isIdentity(): boolean {\r\n    return this._matrix.isIdentity && this._origin.isAlmostZero;\r\n  }\r\n  /** Return an identity transform, optionally filling existing transform.  */\r\n  public static createIdentity(result?: Transform): Transform {\r\n    if (result) {\r\n      result._origin.setZero();\r\n      result._matrix.setIdentity();\r\n      return result;\r\n    }\r\n    return Transform.createRefs(Point3d.createZero(), Matrix3d.createIdentity());\r\n  }\r\n  /** Create by directly installing origin and matrix\r\n   * this is a the appropriate construction when the columns of the matrix are coordinate axes of a local-to-global mapping\r\n   * Note there is a closely related createFixedPointAndMatrix whose point input is the fixed point of the global-to-global transformation.\r\n   */\r\n  public static createOriginAndMatrix(origin: XYZ | undefined, matrix: Matrix3d | undefined, result?: Transform): Transform {\r\n    return Transform.createRefs(\r\n      origin ? origin.cloneAsPoint3d() : Point3d.createZero(),\r\n      matrix === undefined ? Matrix3d.createIdentity() : matrix.clone(), result);\r\n  }\r\n  /** Create by directly installing origin and columns of the matrix\r\n   */\r\n  public static createOriginAndMatrixColumns(origin: XYZ, vectorX: Vector3d, vectorY: Vector3d, vectorZ: Vector3d, result?: Transform): Transform {\r\n    if (result)\r\n      result.setOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ);\r\n    else\r\n      result = Transform.createRefs(Vector3d.createFrom(origin), Matrix3d.createColumns(vectorX, vectorY, vectorZ));\r\n    return result;\r\n  }\r\n  /** Reinitialize by directly installing origin and columns of the matrix\r\n   */\r\n  public setOriginAndMatrixColumns(origin: XYZ | undefined, vectorX: Vector3d | undefined, vectorY: Vector3d | undefined, vectorZ: Vector3d | undefined) {\r\n    if (origin !== undefined)\r\n      this._origin.setFrom(origin);\r\n    this._matrix.setColumns(vectorX, vectorY, vectorZ);\r\n  }\r\n\r\n  /** Create a transform with the specified matrix. Compute an origin (different from the given fixedPoint)\r\n   * so that the fixedPoint maps back to itself.\r\n   */\r\n  public static createFixedPointAndMatrix(fixedPoint: XYAndZ, matrix: Matrix3d, result?: Transform): Transform {\r\n    const origin = Matrix3d.xyzMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);\r\n    return Transform.createRefs(origin, matrix.clone(), result);\r\n  }\r\n  /** Create a transform with the specified matrix, acting on any `pointX `via\r\n   * `pointY = matrix * (pointX - pointA) + pointB`\r\n   * so that the fixedPoint maps back to itself.\r\n   */\r\n  public static createMatrixPickupPutdown(matrix: Matrix3d, pointA: Point3d, pointB: Point3d, result?: Transform): Transform {\r\n    const origin = Matrix3d.xyzMinusMatrixTimesXYZ(pointB, matrix, pointA);\r\n    return Transform.createRefs(origin, matrix.clone(), result);\r\n  }\r\n\r\n  /** Create a Transform which leaves the fixedPoint unchanged and\r\n   * scales everything else around it by a single scale factor.\r\n   */\r\n  public static createScaleAboutPoint(fixedPoint: Point3d, scale: number, result?: Transform): Transform {\r\n    const matrix = Matrix3d.createScale(scale, scale, scale);\r\n    const origin = Matrix3d.xyzMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);\r\n    return Transform.createRefs(origin, matrix, result);\r\n  }\r\n\r\n  /** Transform the input 2d point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyPoint2d(source: XAndY, result?: Point2d): Point2d {\r\n    return Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, source, result);\r\n  }\r\n\r\n  /** Transform the input 3d point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyPoint3d(point: XYAndZ, result?: Point3d): Point3d {\r\n    return Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, point, result);\r\n  }\r\n\r\n  /** Transform the input object with x,y,z members */\r\n  public multiplyXYAndZInPlace(point: XYAndZ) {\r\n    return Matrix3d.xyzPlusMatrixTimesXYZInPlace(this._origin, this._matrix, point);\r\n  }\r\n\r\n  /** Transform the input point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyXYZ(x: number, y: number, z: number = 0, result?: Point3d): Point3d {\r\n    return Matrix3d.xyzPlusMatrixTimesCoordinates(this._origin, this._matrix, x, y, z, result);\r\n  }\r\n  /** Multiply a specific row of the transform times xyz. Return the (number). */\r\n  public multiplyComponentXYZ(componentIndex: number, x: number, y: number, z: number = 0): number {\r\n    const coffs = this._matrix.coffs;\r\n    const i0 = 3 * componentIndex;\r\n    return this.origin.at(componentIndex) + coffs[i0] * x + coffs[i0 + 1] * y + coffs[i0 + 2] * z;\r\n  }\r\n  /** Multiply a specific row of the transform times (weighted!) xyzw. Return the (number). */\r\n  public multiplyComponentXYZW(componentIndex: number, x: number, y: number, z: number, w: number): number {\r\n    const coffs = this._matrix.coffs;\r\n    const i0 = 3 * componentIndex;\r\n    return this.origin.at(componentIndex) * w +\r\n      coffs[i0] * x + coffs[i0 + 1] * y + coffs[i0 + 2] * z;\r\n  }\r\n\r\n  /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d {\r\n    return Matrix3d.xyzPlusMatrixTimesWeightedCoordinates(this._origin, this._matrix, x, y, z, w, result);\r\n  }\r\n  /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyXYZWToFloat64Array(x: number, y: number, z: number, w: number, result?: Float64Array): Float64Array {\r\n    return Matrix3d.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin, this._matrix, x, y, z, w, result);\r\n  }\r\n\r\n  /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyXYZToFloat64Array(x: number, y: number, z: number, result?: Float64Array): Float64Array {\r\n    return Matrix3d.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin, this._matrix, x, y, z, result);\r\n  }\r\n  /** Multiply the transposed transform (as 4x4 with 0001 row) by Point4d given as xyzw..  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyTransposeXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d {\r\n    const coffs = this._matrix.coffs;\r\n    const origin = this._origin;\r\n    return Point4d.create(\r\n      x * coffs[0] + y * coffs[3] + z * coffs[6],\r\n      x * coffs[1] + y * coffs[4] + z * coffs[7],\r\n      x * coffs[2] + y * coffs[5] + z * coffs[8],\r\n      x * origin.x + y * origin.y + z * origin.z + w,\r\n      result);\r\n  }\r\n\r\n  /** for each point:  replace point by Transform*point */\r\n  public multiplyPoint3dArrayInPlace(points: Point3d[]) {\r\n    let point;\r\n    for (point of points)\r\n      Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, point, point);\r\n  }\r\n\r\n  /** for each point:  replace point by Transform*point */\r\n  public multiplyPoint3dArrayArrayInPlace(chains: Point3d[][]) {\r\n    for (const chain of chains)\r\n      this.multiplyPoint3dArrayInPlace(chain);\r\n  }\r\n  /** Return product of the transform's inverse times a point. */\r\n  public multiplyInversePoint3d(point: XYAndZ, result?: Point3d): Point3d | undefined {\r\n    return this._matrix.multiplyInverseXYZAsPoint3d(\r\n      point.x - this._origin.x,\r\n      point.y - this._origin.y,\r\n      point.z - this._origin.z,\r\n      result);\r\n  }\r\n  /** Return product of the transform's inverse times a point (point given as x,y,z) */\r\n  public multiplyInverseXYZ(x: number, y: number, z: number, result?: Point3d): Point3d | undefined {\r\n    return this._matrix.multiplyInverseXYZAsPoint3d(\r\n      x - this._origin.x,\r\n      y - this._origin.y,\r\n      z - this._origin.z,\r\n      result);\r\n  }\r\n\r\n  /**\r\n   * *  for each point:   multiply    transform * point\r\n   * *  if result is given, resize to match source and replace each corresponding pi\r\n   * *  if result is not given, return a new array.\r\n   */\r\n  public multiplyInversePoint3dArray(source: Point3d[], result?: Point3d[]): Point3d[] | undefined {\r\n    if (!this._matrix.computeCachedInverse(true))\r\n      return undefined;\r\n    const originX = this.origin.x;\r\n    const originY = this.origin.y;\r\n    const originZ = this.origin.z;\r\n    if (result) {\r\n      const n = Transform.matchArrayLengths(source, result, Point3d.createZero);\r\n      for (let i = 0; i < n; i++)\r\n        this._matrix.multiplyInverseXYZAsPoint3d(\r\n          source[i].x - originX,\r\n          source[i].y - originY,\r\n          source[i].z - originZ,\r\n          result[i]);\r\n    }\r\n    result = [];\r\n    for (const p of source)\r\n      result.push(this._matrix.multiplyInverseXYZAsPoint3d(\r\n        p.x - originX,\r\n        p.y - originY,\r\n        p.z - originZ)!);\r\n\r\n    return result;\r\n  }\r\n  /**\r\n   * * for each point in source: multiply transformInverse * point in place in the point.\r\n   * * return false if not invertible.\r\n   */\r\n  public multiplyInversePoint3dArrayInPlace(source: Point3d[]): boolean {\r\n    if (!this._matrix.computeCachedInverse(true))\r\n      return false;\r\n    const originX = this.origin.x;\r\n    const originY = this.origin.y;\r\n    const originZ = this.origin.z;\r\n    const n = source.length;\r\n    for (let i = 0; i < n; i++)\r\n      this._matrix.multiplyInverseXYZAsPoint3d(\r\n        source[i].x - originX,\r\n        source[i].y - originY,\r\n        source[i].z - originZ,\r\n        source[i]);\r\n    return true;\r\n  }\r\n  /**\r\n   * * Compute (if needed) the inverse of the matrix part, thereby ensuring inverse operations can complete.\r\n   * * Return true if matrix inverse completes.\r\n   * @param useCached If true, accept prior cached inverse if available.\r\n   */\r\n  public computeCachedInverse(useCached: boolean = true): boolean {\r\n    return this._matrix.computeCachedInverse(useCached);\r\n  }\r\n  /**\r\n   * * If destination has more values than source, remove the extras.\r\n   * * If destination has fewer values, use the constructionFunction to create new ones.\r\n   * @param source array\r\n   * @param dest destination array, to  be modified to match source length\r\n   * @param constructionFunction function to call to create new entries.\r\n   */\r\n  // modify destination so it has non-null points for the same length as the source.\r\n  // (ASSUME existing elements of dest are non-null, and that parameters are given as either Point2d or Point3d arrays)\r\n  public static matchArrayLengths(source: any[], dest: any[], constructionFunction: () => any): number {\r\n    const numSource = source.length;\r\n    const numDest = dest.length;\r\n    if (numSource > numDest) {\r\n      for (let i = numDest; i < numSource; i++) {\r\n        dest.push(constructionFunction());\r\n      }\r\n    } else if (numDest > numSource) {\r\n      dest.length = numSource;\r\n    }\r\n    return numSource;\r\n  }\r\n\r\n  /**\r\n   * *  for each point:   multiply    transform * point\r\n   * *  if result is given, resize to match source and replace each corresponding pi\r\n   * *  if result is not given, return a new array.\r\n   */\r\n  public multiplyPoint2dArray(source: Point2d[], result?: Point2d[]): Point2d[] {\r\n    if (result) {\r\n      const n = Transform.matchArrayLengths(source, result, Point2d.createZero);\r\n      for (let i = 0; i < n; i++)\r\n        Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, source[i], result[i]);\r\n      return result;\r\n    }\r\n    result = [];\r\n    for (const p of source)\r\n      result.push(Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, p));\r\n\r\n    return result;\r\n  }\r\n  /**\r\n   * *  for each point:   multiply    transform * point\r\n   * *  if result is given, resize to match source and replace each corresponding pi\r\n   * *  if result is not given, return a new array.\r\n   */\r\n  public multiplyPoint3dArray(source: Point3d[], result?: Point3d[]): Point3d[] {\r\n    if (result) {\r\n      const n = Transform.matchArrayLengths(source, result, Point3d.createZero);\r\n      for (let i = 0; i < n; i++)\r\n        Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, source[i], result[i]);\r\n      return result;\r\n    }\r\n    result = [];\r\n    for (const p of source)\r\n      result.push(Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, p));\r\n\r\n    return result;\r\n  }\r\n\r\n  /** Multiply the vector by the Matrix3d part of the transform.\r\n   *\r\n   * *  The transform's origin is not used.\r\n   * *  Return as new or result by usual optional result convention\r\n   */\r\n  public multiplyVector(vector: Vector3d, result?: Vector3d): Vector3d {\r\n    return this._matrix.multiplyVector(vector, result);\r\n  }\r\n  /** Multiply the vector (x,y,z) by the Matrix3d part of the transform.\r\n   *\r\n   * *  The transform's origin is not used.\r\n   * *  Return as new or result by usual optional result convention\r\n   */\r\n  public multiplyVectorXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    return this._matrix.multiplyXYZ(x, y, z, result);\r\n  }\r\n  /** multiply this Transform times other Transform.\r\n   * @param other right hand transform for multiplication.\r\n   * @param result optional preallocated result to reuse.\r\n   */\r\n  public multiplyTransformTransform(other: Transform, result?: Transform) {\r\n    if (!result)\r\n      return Transform.createRefs(\r\n        Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, other._origin),\r\n        this._matrix.multiplyMatrixMatrix(other._matrix));\r\n    result.setMultiplyTransformTransform(this, other);\r\n    return result;\r\n  }\r\n  /**\r\n   * multiply transformA * transformB, store to calling instance.\r\n   * @param transformA left operand\r\n   * @param transformB right operand\r\n   */\r\n  public setMultiplyTransformTransform(transformA: Transform, transformB: Transform): void {\r\n    if (Transform._scratchPoint === undefined)\r\n      Transform._scratchPoint = Point3d.create();\r\n    Matrix3d.xyzPlusMatrixTimesXYZ(transformA._origin, transformA._matrix, transformB._origin, Transform._scratchPoint);\r\n    this._origin.setFrom(Transform._scratchPoint);\r\n    transformA._matrix.multiplyMatrixMatrix(transformB._matrix, this._matrix);\r\n  }\r\n  //   [Q A][R 0] = [QR A]\r\n  //   [0 1][0 1]   [0  1]\r\n  /** multiply this Transform times other Matrix3d, with other considered to be a Transform with 0 translation.\r\n   * @param other right hand Matrix3d for multiplication.\r\n   * @param result optional preallocated result to reuse.\r\n   */\r\n  public multiplyTransformMatrix3d(other: Matrix3d, result?: Transform): Transform {\r\n    if (!result)\r\n      return Transform.createRefs(\r\n        this._origin.cloneAsPoint3d(),\r\n        this._matrix.multiplyMatrixMatrix(other));\r\n    this._matrix.multiplyMatrixMatrix(other, result._matrix);\r\n    result._origin.setFrom(this._origin);\r\n    return result;\r\n  }\r\n\r\n  /** transform each of the 8 corners of a range. Return the range of the transformed corners */\r\n  public multiplyRange(range: Range3d, result?: Range3d): Range3d {\r\n    if (range.isNull)\r\n      return range.clone(result);\r\n\r\n    // snag current values to allow aliasing.\r\n    const lowX = range.low.x;\r\n    const lowY = range.low.y;\r\n    const lowZ = range.low.z;\r\n    const highX = range.high.x;\r\n    const highY = range.high.y;\r\n    const highZ = range.high.z;\r\n    result = Range3d.createNull(result);\r\n    result.extendTransformedXYZ(this, lowX, lowY, lowZ);\r\n    result.extendTransformedXYZ(this, highX, lowY, lowZ);\r\n    result.extendTransformedXYZ(this, lowX, highY, lowZ);\r\n    result.extendTransformedXYZ(this, highX, highY, lowZ);\r\n\r\n    result.extendTransformedXYZ(this, lowX, lowY, highZ);\r\n    result.extendTransformedXYZ(this, highX, lowY, highZ);\r\n    result.extendTransformedXYZ(this, lowX, highY, highZ);\r\n    result.extendTransformedXYZ(this, highX, highY, highZ);\r\n    return result;\r\n  }\r\n  /**\r\n   * * Return a Transform which is the inverse of this transform.\r\n   * * Return undefined if this Transform's matrix is singular.\r\n   */\r\n  public inverse(): Transform | undefined {\r\n    const matrixInverse = this._matrix.inverse();\r\n    if (!matrixInverse)\r\n      return undefined;\r\n    return Transform.createRefs(\r\n      matrixInverse.multiplyXYZ(-this._origin.x, -this._origin.y, -this._origin.z),\r\n      matrixInverse);\r\n  }\r\n  /** Initialize transforms that map each direction of a box (axis aligned) to `[0,1]`.\r\n   * @param min the \"000\" corner of the box\r\n   * @param max the \"111\" corner of the box\r\n   * @param npcToGlobal (object created by caller, re-initialized) transform that carries 01 coordinates into the min,max box.\r\n   * @param globalToNpc (object created by caller, re-initialized) transform that carries world coordinates into 01\r\n   */\r\n  public static initFromRange(min: Point3d, max: Point3d, npcToGlobal?: Transform, globalToNpc?: Transform) {\r\n    const diag = max.minus(min);\r\n    if (diag.x === 0.0) diag.x = 1.0;\r\n    if (diag.y === 0.0) diag.y = 1.0;\r\n    if (diag.z === 0.0) diag.z = 1.0;\r\n\r\n    const rMatrix = new Matrix3d();\r\n    if (npcToGlobal) {\r\n      Matrix3d.createScale(diag.x, diag.y, diag.z, rMatrix);\r\n      Transform.createOriginAndMatrix(min, rMatrix, npcToGlobal);\r\n    }\r\n\r\n    if (globalToNpc) {\r\n      const origin = new Point3d(- min.x / diag.x, - min.y / diag.y, - min.z / diag.z);\r\n      Matrix3d.createScale(1.0 / diag.x, 1.0 / diag.y, 1.0 / diag.z, rMatrix);\r\n      Transform.createOriginAndMatrix(origin, rMatrix, globalToNpc);\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { AngleProps, Geometry } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { Point3d } from \"./Point3dVector3d\";\r\n/** The properties that define [[YawPitchRollAngles]]. */\r\n/**\r\n * angle properties of a `YawPitchRoll` orientation\r\n * @public\r\n */\r\nexport interface YawPitchRollProps {\r\n  /** yaw field */\r\n  yaw?: AngleProps;\r\n  /** pitch field */\r\n  pitch?: AngleProps;\r\n  /** roll field */\r\n  roll?: AngleProps;\r\n}\r\n// cspell:word Tait\r\n/** Three angles that determine the orientation of an object in space. Sometimes referred to as [TaitBryan angles](https://en.wikipedia.org/wiki/Euler_angles).\r\n * * The matrix construction can be replicated by this logic:\r\n * * xyz coordinates have\r\n *   * x forward\r\n *   * y to left\r\n *   * z up\r\n *   * Note that this is a right handed coordinate system.\r\n *   * yaw is a rotation of x towards y, i.e. around positive z:\r\n *     * `yawMatrix = Matrix3d.createRotationAroundAxisIndex(2, Angle.createDegrees(yawDegrees));`\r\n *   * pitch is a rotation that raises x towards z, i.e. rotation around negative y:\r\n *     * `pitchMatrix = Matrix3d.createRotationAroundAxisIndex(1, Angle.createDegrees(-pitchDegrees));`\r\n *   * roll is rotation of y towards z, i.e. rotation around positive x:\r\n *     * `rollMatrix = Matrix3d.createRotationAroundAxisIndex(0, Angle.createDegrees(rollDegrees));`\r\n *   * The YPR matrix is the product\r\n *     * `result = yawMatrix.multiplyMatrixMatrix(pitchMatrix.multiplyMatrixMatrix(rollMatrix));`\r\n *   * Note that this is for \"column based\" matrix, with vectors appearing to the right\r\n *     * Hence a vector is first rotated by roll, then the pitch, finally yaw.\r\n * @public\r\n */\r\nexport class YawPitchRollAngles {\r\n  /** The yaw angle. */\r\n  public yaw: Angle;\r\n  /** The pitch angle. */\r\n  public pitch: Angle;\r\n  /** The roll angle. */\r\n  public roll: Angle;\r\n\r\n  constructor(yaw: Angle = Angle.zero(), pitch: Angle = Angle.zero(), roll: Angle = Angle.zero()) {\r\n    this.yaw = yaw;\r\n    this.pitch = pitch;\r\n    this.roll = roll;\r\n  }\r\n  /** Freeze this YawPitchRollAngles */\r\n  public freeze() { Object.freeze(this.yaw); Object.freeze(this.pitch); Object.freeze(this.roll); }\r\n  /** constructor for YawPitchRollAngles with angles in degrees. */\r\n  public static createDegrees(yawDegrees: number, pitchDegrees: number, rollDegrees: number): YawPitchRollAngles {\r\n    return new YawPitchRollAngles(Angle.createDegrees(yawDegrees), Angle.createDegrees(pitchDegrees), Angle.createDegrees(rollDegrees));\r\n  }\r\n  /** constructor for YawPitchRollAngles with angles in radians. */\r\n  public static createRadians(yawRadians: number, pitchRadians: number, rollRadians: number): YawPitchRollAngles {\r\n    return new YawPitchRollAngles(Angle.createRadians(yawRadians), Angle.createRadians(pitchRadians), Angle.createRadians(rollRadians));\r\n  }\r\n  /** construct a `YawPitchRoll` object from an object with 3 named angles */\r\n  public static fromJSON(json?: YawPitchRollProps): YawPitchRollAngles {\r\n    json = json ? json : {};\r\n    return new YawPitchRollAngles(Angle.fromJSON(json.yaw), Angle.fromJSON(json.pitch), Angle.fromJSON(json.roll));\r\n  }\r\n  /** populate yaw, pitch and roll fields using `Angle.fromJSON` */\r\n  public setFromJSON(json?: YawPitchRollProps): void {\r\n    json = json ? json : {};\r\n    this.yaw = Angle.fromJSON(json.yaw);\r\n    this.pitch = Angle.fromJSON(json.pitch);\r\n    this.roll = Angle.fromJSON(json.roll);\r\n  }\r\n  /** Convert to a JSON object of form { pitch: 20 , roll: 29.999999999999996 , yaw: 10 }. Any values that are exactly zero (with tolerance `Geometry.smallAngleRadians`) are omitted. */\r\n  public toJSON(): YawPitchRollProps {\r\n    const val: YawPitchRollProps = {};\r\n    if (!this.pitch.isAlmostZero)\r\n      val.pitch = this.pitch.toJSON();\r\n    if (!this.roll.isAlmostZero)\r\n      val.roll = this.roll.toJSON();\r\n    if (!this.yaw.isAlmostZero)\r\n      val.yaw = this.yaw.toJSON();\r\n    return val;\r\n  }\r\n  /**\r\n   * Install all rotations from `other` into `this`.\r\n   * @param other YawPitchRollAngles source\r\n   */\r\n  public setFrom(other: YawPitchRollAngles) {\r\n    this.yaw.setFrom(other.yaw);\r\n    this.pitch.setFrom(other.pitch);\r\n    this.roll.setFrom(other.roll);\r\n  }\r\n  /**\r\n   * * Compare angles between `this` and `other`.\r\n   * * Comparisons are via `isAlmostEqualAllowPeriodShift`.\r\n   * @param other YawPitchRollAngles source\r\n   */\r\n  public isAlmostEqual(other: YawPitchRollAngles) {\r\n    return this.yaw.isAlmostEqualAllowPeriodShift(other.yaw)\r\n      && this.pitch.isAlmostEqualAllowPeriodShift(other.pitch)\r\n      && this.roll.isAlmostEqualAllowPeriodShift(other.roll);\r\n  }\r\n  /**\r\n   * Make a copy of this YawPitchRollAngles.\r\n   */\r\n  public clone() { return new YawPitchRollAngles(this.yaw.clone(), this.pitch.clone(), this.roll.clone()); }\r\n  /**\r\n   * Expand the angles into a (rigid rotation) matrix.\r\n   *\r\n   * * The returned matrix is \"rigid\" -- unit length rows and columns, and its transpose is its inverse.\r\n   * * The \"rigid\" matrix is always a right handed coordinate system.\r\n   * @param result optional pre-allocated `Matrix3d`\r\n   */\r\n  public toMatrix3d(result?: Matrix3d) {\r\n    const c0 = Math.cos(this.yaw.radians);\r\n    const s0 = Math.sin(this.yaw.radians);\r\n    const c1 = Math.cos(this.pitch.radians);\r\n    const s1 = Math.sin(this.pitch.radians);\r\n    const c2 = Math.cos(this.roll.radians);\r\n    const s2 = Math.sin(this.roll.radians);\r\n    return Matrix3d.createRowValues(c0 * c1, -(s0 * c2 + c0 * s1 * s2), (s0 * s2 - c0 * s1 * c2), s0 * c1, (c0 * c2 - s0 * s1 * s2), -(c0 * s2 + s0 * s1 * c2), s1, c1 * s2, c1 * c2, result);\r\n  }\r\n  /** Return the largest angle in radians */\r\n  public maxAbsRadians(): number {\r\n    return Geometry.maxAbsXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);\r\n  }\r\n  /** Return the sum of the angles in squared radians */\r\n  public sumSquaredRadians(): number {\r\n    return Geometry.hypotenuseSquaredXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);\r\n  }\r\n  /** Returns true if this rotation does nothing.\r\n   * * If allowPeriodShift is false, any nonzero angle is considered a non-identity\r\n   * * If allowPeriodShift is true, all angles are individually allowed to be any multiple of 360 degrees.\r\n   */\r\n  public isIdentity(allowPeriodShift: boolean = true): boolean {\r\n    if (allowPeriodShift)\r\n      return Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.yaw.radians)\r\n        && Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.pitch.radians)\r\n        && Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.roll.radians);\r\n    else\r\n      return Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.yaw.radians)\r\n        && Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.pitch.radians)\r\n        && Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.roll.radians);\r\n  }\r\n  /** Return the largest difference of angles (in radians) between this and other */\r\n  public maxDiffRadians(other: YawPitchRollAngles): number {\r\n    return Math.max(this.yaw.radians - other.yaw.radians, this.pitch.radians - other.pitch.radians, this.roll.radians - other.roll.radians);\r\n  }\r\n  /** Return the largest angle in degrees. */\r\n  public maxAbsDegrees(): number { return Geometry.maxAbsXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees); }\r\n  /** Return the sum of squared angles in degrees. */\r\n  public sumSquaredDegrees(): number { return Geometry.hypotenuseSquaredXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees); }\r\n  /** Return an object from a Transform as an origin and YawPitchRollAngles. */\r\n  public static tryFromTransform(transform: Transform): {\r\n    origin: Point3d;\r\n    angles: YawPitchRollAngles | undefined;\r\n  } {\r\n    // bundle up the transform's origin with the angle data extracted from the transform\r\n    return {\r\n      angles: YawPitchRollAngles.createFromMatrix3d(transform.matrix),\r\n      origin: Point3d.createFrom(transform.origin),\r\n    };\r\n  }\r\n  /** Attempts to create a YawPitchRollAngles object from an Matrix3d\r\n   * * This conversion fails if the matrix is not rigid (unit rows and columns, transpose is inverse)\r\n   * * In the failure case the method's return value is `undefined`.\r\n   * * In the failure case, if the optional result was supplied, that result will nonetheless be filled with a set of angles.\r\n   */\r\n  public static createFromMatrix3d(matrix: Matrix3d, result?: YawPitchRollAngles): YawPitchRollAngles | undefined {\r\n    const s1 = matrix.at(2, 0);\r\n    const c1 = Math.sqrt(matrix.at(2, 1) * matrix.at(2, 1) + matrix.at(2, 2) * matrix.at(2, 2));\r\n    const pitchA = Angle.createAtan2(s1, c1); // with positive cosine\r\n    const pitchB = Angle.createAtan2(s1, -c1); // with negative cosine\r\n    const angles = result ? result : new YawPitchRollAngles(); // default undefined . . .\r\n    if (c1 < Geometry.smallAngleRadians) { // This is a radians test !!!\r\n      angles.yaw = Angle.createAtan2(-matrix.at(0, 1), matrix.at(1, 1));\r\n      angles.pitch = pitchA;\r\n      angles.roll = Angle.createRadians(0.0);\r\n    } else {\r\n      const yawA = Angle.createAtan2(matrix.at(1, 0), matrix.at(0, 0));\r\n      const rollA = Angle.createAtan2(matrix.at(2, 1), matrix.at(2, 2));\r\n      const yawB = Angle.createAtan2(-matrix.at(1, 0), -matrix.at(0, 0));\r\n      const rollB = Angle.createAtan2(-matrix.at(2, 1), -matrix.at(2, 2));\r\n      const yprA = new YawPitchRollAngles(yawA, pitchA, rollA);\r\n      const yprB = new YawPitchRollAngles(yawB, pitchB, rollB);\r\n      const absFactor = 0.95;\r\n      const radiansA = yprA.maxAbsRadians();\r\n      const radiansB = yprB.maxAbsRadians();\r\n      if (radiansA < absFactor * radiansB) {\r\n        angles.setFrom(yprA);\r\n      } else if (radiansB < absFactor * radiansA) {\r\n        angles.setFrom(yprB);\r\n      } else {\r\n        const sumA = yprA.sumSquaredRadians();\r\n        const sumB = yprB.sumSquaredRadians();\r\n        if (sumA <= sumB) {\r\n          angles.setFrom(yprA);\r\n        } else {\r\n          angles.setFrom(yprB);\r\n        }\r\n      }\r\n    }\r\n    const matrix1 = angles.toMatrix3d();\r\n    return matrix.maxDiff(matrix1) < Geometry.smallAngleRadians ? angles : undefined;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { BeJSONFunctions } from \"../Geometry\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Matrix4d } from \"./Matrix4d\";\r\n/** @module Numerics */\r\n\r\n/** Map4 carries two Matrix4d which are inverses of each other.\r\n * @public\r\n */\r\nexport class Map4d implements BeJSONFunctions {\r\n  private _matrix0: Matrix4d;\r\n  private _matrix1: Matrix4d;\r\n  private constructor(matrix0: Matrix4d, matrix1: Matrix4d) {\r\n    this._matrix0 = matrix0;\r\n    this._matrix1 = matrix1;\r\n  }\r\n  /** Return a reference to (not copy of) the \"forward\" Matrix4d */\r\n  public get transform0(): Matrix4d { return this._matrix0; }\r\n  /** Return a reference to (not copy of) the \"reverse\" Matrix4d */\r\n  public get transform1(): Matrix4d { return this._matrix1; }\r\n  /** Create a Map4d, capturing the references to the two matrices. */\r\n  public static createRefs(matrix0: Matrix4d, matrix1: Matrix4d) {\r\n    return new Map4d(matrix0, matrix1);\r\n  }\r\n  /** Create an identity map. */\r\n  public static createIdentity(): Map4d { return new Map4d(Matrix4d.createIdentity(), Matrix4d.createIdentity()); }\r\n  /** Create a Map4d with given transform pair.\r\n   * @returns undefined if the transforms are not inverses of each other.\r\n   */\r\n  public static createTransform(transform0: Transform, transform1?: Transform): Map4d | undefined {\r\n    if (transform1 === undefined) {\r\n      transform1 = transform0.inverse();\r\n      if (transform1 === undefined)\r\n        return undefined;\r\n    } else {\r\n      const product = transform0.multiplyTransformTransform(transform1);\r\n      if (!product.isIdentity)\r\n        return undefined;\r\n    }\r\n    return new Map4d(Matrix4d.createTransform(transform0), Matrix4d.createTransform(transform1));\r\n  }\r\n  /**\r\n   * Create a mapping the scales and translates (no rotation) between boxes.\r\n   * @param lowA low point of box A\r\n   * @param highA high point of box A\r\n   * @param lowB low point of box B\r\n   * @param highB high point of box B\r\n   */\r\n  public static createBoxMap(lowA: Point3d, highA: Point3d, lowB: Point3d, highB: Point3d, result?: Map4d): Map4d | undefined {\r\n    const t0 = Matrix4d.createBoxToBox(lowA, highA, lowB, highB, result ? result.transform0 : undefined);\r\n    const t1 = Matrix4d.createBoxToBox(lowB, highB, lowA, highA, result ? result.transform1 : undefined);\r\n    if (t0 && t1) {\r\n      if (result)\r\n        return result;\r\n      return new Map4d(t0, t1);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Copy contents from another Map4d */\r\n  public setFrom(other: Map4d) { this._matrix0.setFrom(other._matrix0), this._matrix1.setFrom(other._matrix1); }\r\n  /** Return a clone of this Map4d */\r\n  public clone(): Map4d { return new Map4d(this._matrix0.clone(), this._matrix1.clone()); }\r\n  /** Reinitialize this Map4d as an identity. */\r\n  public setIdentity() { this._matrix0.setIdentity(); this._matrix1.setIdentity(); }\r\n  /** Set this map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */\r\n  public setFromJSON(json: any): void {\r\n    if (json.matrix0 && json.matrix1) {\r\n      this._matrix0.setFromJSON(json.matrix0);\r\n      this._matrix1.setFromJSON(json.matrix1);\r\n    } else\r\n      this.setIdentity();\r\n  }\r\n  /** Create a map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */\r\n  public static fromJSON(json?: any): Map4d {\r\n    const result = new Map4d(Matrix4d.createIdentity(), Matrix4d.createIdentity());\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Return a json object `{matrix0: value0, matrix1: value1}` */\r\n  public toJSON(): any { return { matrix0: this._matrix0.toJSON(), matrix1: this._matrix1.toJSON() }; }\r\n  /** Test if both matrices are almost equal to those */\r\n  public isAlmostEqual(other: Map4d) {\r\n    return this._matrix0.isAlmostEqual(other._matrix0) && this._matrix1.isAlmostEqual(other._matrix1);\r\n  }\r\n  /** Create a map between a frustum and world coordinates.\r\n   * @param origin lower left of frustum\r\n   * @param uVector Vector from lower left rear to lower right rear\r\n   * @param vVector Vector from lower left rear to upper left rear\r\n   * @param wVector Vector from lower left rear to lower left front, i.e. lower left rear towards eye.\r\n   * @param fraction front size divided by rear size.\r\n   */\r\n  public static createVectorFrustum(origin: Point3d, uVector: Vector3d, vVector: Vector3d, wVector: Vector3d, fraction: number): Map4d | undefined {\r\n    fraction = Math.max(fraction, 1.0e-8);\r\n    const slabToWorld = Transform.createOriginAndMatrix(origin, Matrix3d.createColumns(uVector, vVector, wVector));\r\n    const worldToSlab = slabToWorld.inverse();\r\n    if (!worldToSlab)\r\n      return undefined;\r\n    const worldToSlabMap = new Map4d(Matrix4d.createTransform(worldToSlab), Matrix4d.createTransform(slabToWorld));\r\n    const slabToNPCMap = new Map4d(Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, fraction, 0, 0, 0, fraction - 1.0, 1), Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1.0 / fraction, 0, 0, 0, (1.0 - fraction) / fraction, 1));\r\n    const result = slabToNPCMap.multiplyMapMap(worldToSlabMap);\r\n    /*\r\n    let numIdentity = 0;\r\n    const productA = worldToSlabMap.matrix0.multiplyMatrixMatrix(worldToSlabMap.matrix1);\r\n    if (productA.isIdentity())\r\n      numIdentity++;\r\n    const productB = slabToNPCMap.matrix0.multiplyMatrixMatrix(slabToNPCMap.matrix1);\r\n    if (productB.isIdentity())\r\n      numIdentity++;\r\n    const product = result.matrix0.multiplyMatrixMatrix(result.matrix1);\r\n    if (product.isIdentity())\r\n      numIdentity++;\r\n    if (numIdentity === 3)\r\n        return result;\r\n      */\r\n    return result;\r\n  }\r\n  /** multiply this*other. The output matrices are\r\n   * * output matrix0 = `this.matrix0 * other.matrix0`\r\n   * * output matrix1 = 'other.matrix1 * this.matrix1`\r\n   */\r\n  public multiplyMapMap(other: Map4d): Map4d {\r\n    return new Map4d(this._matrix0.multiplyMatrixMatrix(other._matrix0), other._matrix1.multiplyMatrixMatrix(this._matrix1));\r\n  }\r\n  /** Exchange the two matrices of the map. */\r\n  public reverseInPlace() {\r\n    const temp = this._matrix0;\r\n    this._matrix0 = this._matrix1;\r\n    this._matrix1 = temp;\r\n  }\r\n  /** return a Map4d whose transform0 is\r\n   * other.transform0 * this.transform0 * other.transform1\r\n   */\r\n  public sandwich0This1(other: Map4d): Map4d {\r\n    return new Map4d(other._matrix0.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(other._matrix1)), other._matrix0.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(other._matrix1)));\r\n  }\r\n  /** return a Map4d whose transform0 is\r\n   * other.transform1 * this.transform0 * other.transform0\r\n   */\r\n  public sandwich1This0(other: Map4d): Map4d {\r\n    return new Map4d(other._matrix1.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(other._matrix0)), other._matrix1.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(other._matrix0)));\r\n  }\r\n} // Map4d\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\nimport { Geometry, BeJSONFunctions } from \"../Geometry\";\r\nimport { XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d, XYZ } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Point4d, Point4dProps } from \"./Point4d\";\r\n/**\r\n * Coordinate data with `Point4d` numeric data as an array `[x,y,z,w]`\r\n * @public\r\n */\r\nexport type Matrix4dProps = Point4dProps[];\r\n\r\n/**\r\n * * A Matrix4d is a matrix with 4 rows and 4 columns.\r\n * * The 4 rows may be described as the x,y,z,w rows.\r\n * * The 4 columns may be described as the x,y,z,w columns.\r\n * * The matrix is physically stored as a Float64Array with 16 numbers.\r\n * * The layout in the Float64Array is \"by row\"\r\n *   * indices 0,1,2,3 are the \"x row\".   They may be called the xx,xy,xz,xw entries\r\n *   * indices 4,5,6,7 are the \"y row\"    They may be called the yx,yy,yz,yw entries\r\n *   * indices 8,9,10,11 are the \"z row\"  They may be called the zx,zy,zz,zw entries\r\n *   * indices 12,13,14,15 are the \"w row\".  They may be called the wx,wy,wz,ww entries\r\n * * If \"w row\" contains numeric values 0,0,0,1, the Matrix4d is equivalent to a Transform with\r\n *  * The upper right 3x3 matrix (entries 0,1,2,4,5,6,8,9,10) are the 3x3 matrix part of the transform\r\n *  * The far right column entries xw,yw,zw are the \"origin\" (sometimes called \"translation\") part of the transform.\r\n * @public\r\n */\r\nexport class Matrix4d implements BeJSONFunctions {\r\n  private _coffs: Float64Array;\r\n  private constructor() { this._coffs = new Float64Array(16); }\r\n  /** Copy matrix entries from `other` */\r\n  public setFrom(other: Matrix4d): void {\r\n    for (let i = 0; i < 16; i++)\r\n      this._coffs[i] = other._coffs[i];\r\n  }\r\n  /** Return a deep clone. */\r\n  public clone(result?: Matrix4d): Matrix4d {\r\n    if (result === this)\r\n      return this;\r\n    if (result === undefined)\r\n      result = new Matrix4d();\r\n    for (let i = 0; i < 16; i++)\r\n      result._coffs[i] = this._coffs[i];\r\n    return result;\r\n  }\r\n  /** zero this matrix4d in place. */\r\n  public setZero(): void {\r\n    for (let i = 0; i < 16; i++)\r\n      this._coffs[i] = 0;\r\n  }\r\n  /** set to identity. */\r\n  public setIdentity(): void {\r\n    for (let i = 0; i < 16; i++)\r\n      this._coffs[i] = 0;\r\n    this._coffs[0] = this._coffs[5] = this._coffs[10] = this._coffs[15] = 1.0;\r\n  }\r\n  private static is1000(a: number, b: number, c: number, d: number, tol: number): boolean {\r\n    return Math.abs(a - 1.0) <= tol\r\n      && Math.abs(b) <= tol\r\n      && Math.abs(c) <= tol\r\n      && Math.abs(d) <= tol;\r\n  }\r\n  /** set to identity. */\r\n  public isIdentity(tol: number = 1.0e-10): boolean {\r\n    return Matrix4d.is1000(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3], tol)\r\n      && Matrix4d.is1000(this._coffs[5], this._coffs[6], this._coffs[7], this._coffs[4], tol)\r\n      && Matrix4d.is1000(this._coffs[10], this._coffs[11], this._coffs[8], this._coffs[9], tol)\r\n      && Matrix4d.is1000(this._coffs[15], this._coffs[12], this._coffs[13], this._coffs[14], tol);\r\n  }\r\n  /** create a Matrix4d filled with zeros. */\r\n  public static createZero(result?: Matrix4d): Matrix4d {\r\n    if (result) {\r\n      result.setZero();\r\n      return result;\r\n    }\r\n    return new Matrix4d(); // this is zero.\r\n  }\r\n  /** create a Matrix4d with values supplied \"across the rows\" */\r\n  public static createRowValues(cxx: number, cxy: number, cxz: number, cxw: number, cyx: number, cyy: number, cyz: number, cyw: number, czx: number, czy: number, czz: number, czw: number, cwx: number, cwy: number, cwz: number, cww: number, result?: Matrix4d): Matrix4d {\r\n    result = result ? result : new Matrix4d();\r\n    result._coffs[0] = cxx;\r\n    result._coffs[1] = cxy;\r\n    result._coffs[2] = cxz;\r\n    result._coffs[3] = cxw;\r\n    result._coffs[4] = cyx;\r\n    result._coffs[5] = cyy;\r\n    result._coffs[6] = cyz;\r\n    result._coffs[7] = cyw;\r\n    result._coffs[8] = czx;\r\n    result._coffs[9] = czy;\r\n    result._coffs[10] = czz;\r\n    result._coffs[11] = czw;\r\n    result._coffs[12] = cwx;\r\n    result._coffs[13] = cwy;\r\n    result._coffs[14] = cwz;\r\n    result._coffs[15] = cww;\r\n    return result;\r\n  }\r\n  /** Create a `Matrix4d` from 16 values appearing as `Point4d` for each row. */\r\n  public static createRows(rowX: Point4d, rowY: Point4d, rowZ: Point4d, rowW: Point4d, result?: Matrix4d): Matrix4d {\r\n    return this.createRowValues(\r\n      rowX.x, rowX.y, rowX.z, rowX.w,\r\n      rowY.x, rowY.y, rowY.z, rowY.w,\r\n      rowZ.x, rowZ.y, rowZ.z, rowZ.w,\r\n      rowW.x, rowW.y, rowW.z, rowW.w, result);\r\n  }\r\n  /** directly set columns from typical 3d data:\r\n   *\r\n   * * vectorX, vectorY, vectorZ as columns 0,1,2, with weight0.\r\n   * * origin as column3, with weight 1\r\n   */\r\n  public setOriginAndVectors(origin: XYZ, vectorX: Vector3d, vectorY: Vector3d, vectorZ: Vector3d) {\r\n    this._coffs[0] = vectorX.x;\r\n    this._coffs[1] = vectorY.x;\r\n    this._coffs[2] = vectorZ.x;\r\n    this._coffs[3] = origin.x;\r\n    this._coffs[4] = vectorX.y;\r\n    this._coffs[5] = vectorY.y;\r\n    this._coffs[6] = vectorZ.y;\r\n    this._coffs[7] = origin.y;\r\n    this._coffs[8] = vectorX.z;\r\n    this._coffs[9] = vectorY.z;\r\n    this._coffs[10] = vectorZ.z;\r\n    this._coffs[11] = origin.z;\r\n    this._coffs[12] = 0.0;\r\n    this._coffs[13] = 0.0;\r\n    this._coffs[14] = 0.0;\r\n    this._coffs[15] = 1.0;\r\n  }\r\n  /** promote a transform to full Matrix4d (with 0001 in final row) */\r\n  public static createTransform(source: Transform, result?: Matrix4d): Matrix4d {\r\n    const matrix = source.matrix;\r\n    const point = source.origin;\r\n    return Matrix4d.createRowValues(matrix.coffs[0], matrix.coffs[1], matrix.coffs[2], point.x, matrix.coffs[3], matrix.coffs[4], matrix.coffs[5], point.y, matrix.coffs[6], matrix.coffs[7], matrix.coffs[8], point.z, 0, 0, 0, 1, result);\r\n  }\r\n  /** return an identity matrix. */\r\n  public static createIdentity(result?: Matrix4d): Matrix4d {\r\n    result = Matrix4d.createZero(result);\r\n    result._coffs[0] = 1.0;\r\n    result._coffs[5] = 1.0;\r\n    result._coffs[10] = 1.0;\r\n    result._coffs[15] = 1.0;\r\n    return result;\r\n  }\r\n  /** return matrix with translation directly inserted (along with 1 on diagonal) */\r\n  public static createTranslationXYZ(x: number, y: number, z: number, result?: Matrix4d): Matrix4d {\r\n    result = Matrix4d.createZero(result);\r\n    result._coffs[0] = 1.0;\r\n    result._coffs[5] = 1.0;\r\n    result._coffs[10] = 1.0;\r\n    result._coffs[15] = 1.0;\r\n    result._coffs[3] = x;\r\n    result._coffs[7] = y;\r\n    result._coffs[11] = z;\r\n    return result;\r\n  }\r\n\r\n  /** return this matrix plus scale times matrixB. */\r\n  public plusScaled(matrixB: Matrix4d, scale: number, result?: Matrix4d): Matrix4d {\r\n    // If result is undefined, a real clone is created.\r\n    // If result is \"this\" we get the pointer to this right back.\r\n    // If result is other, \"this\" coffs are copied.\r\n    // Then we can add matrixB.  (Which we assume is different from this?)\r\n    result = this.clone(result);\r\n    for (let i = 0; i < 16; i++)\r\n      result._coffs[i] += scale * matrixB._coffs[i];\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a Matrix4d with translation and scaling values directly inserted (along with 1 as final diagonal entry)\r\n   * @param tx x entry for translation column\r\n   * @param ty y entry for translation column\r\n   * @param tz z entry for translation column\r\n   * @param scaleX x diagonal entry\r\n   * @param scaleY y diagonal entry\r\n   * @param scaleZ z diagonal entry\r\n   * @param result optional result.\r\n   */\r\n  public static createTranslationAndScaleXYZ(tx: number, ty: number, tz: number, scaleX: number, scaleY: number, scaleZ: number, result?: Matrix4d): Matrix4d {\r\n    return Matrix4d.createRowValues(scaleX, 0, 0, tx, 0, scaleY, 0, ty, 0, 0, scaleZ, tz, 0, 0, 0, 1, result);\r\n  }\r\n  /**\r\n   * Create a mapping the scales and translates (no rotation) from box A to boxB\r\n   * @param lowA low point of box A\r\n   * @param highA high point of box A\r\n   * @param lowB low point of box B\r\n   * @param highB high point of box B\r\n   */\r\n  public static createBoxToBox(lowA: Point3d, highA: Point3d, lowB: Point3d, highB: Point3d, result?: Matrix4d): Matrix4d | undefined {\r\n    const ax = highA.x - lowA.x;\r\n    const ay = highA.y - lowA.y;\r\n    const az = highA.z - lowA.z;\r\n    const bx = highB.x - lowB.x;\r\n    const by = highB.y - lowB.y;\r\n    const bz = highB.z - lowB.z;\r\n    const abx = Geometry.conditionalDivideFraction(bx, ax);\r\n    const aby = Geometry.conditionalDivideFraction(by, ay);\r\n    const abz = Geometry.conditionalDivideFraction(bz, az);\r\n    if (abx !== undefined && aby !== undefined && abz !== undefined) {\r\n      return Matrix4d.createTranslationAndScaleXYZ(lowB.x - abx * lowA.x, lowB.y - aby * lowA.y, lowB.z - abz * lowA.z, abx, aby, abz, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Set from nested array json e.g. `[[1,2,3,4],[0,1,2,4],[0,2,5,1],[0,0,1,2]]` */\r\n  public setFromJSON(json?: Matrix4dProps) {\r\n    if (Geometry.isArrayOfNumberArray(json, 4, 4))\r\n      for (let i = 0; i < 4; ++i) {\r\n        for (let j = 0; j < 4; ++j)\r\n          this._coffs[i * 4 + j] = json![i][j];\r\n      }\r\n    else\r\n      this.setZero();\r\n  }\r\n  /**\r\n   * Return the largest (absolute) difference between this and other Matrix4d.\r\n   * @param other matrix to compare to\r\n   */\r\n  public maxDiff(other: Matrix4d): number {\r\n    let a = 0.0;\r\n    for (let i = 0; i < 16; i++)\r\n      a = Math.max(a, Math.abs(this._coffs[i] - other._coffs[i]));\r\n    return a;\r\n  }\r\n  /**\r\n   * Return the largest absolute value in the Matrix4d\r\n   */\r\n  public maxAbs(): number {\r\n    let a = 0.0;\r\n    for (let i = 0; i < 16; i++)\r\n      a = Math.max(a, Math.abs(this._coffs[i]));\r\n    return a;\r\n  }\r\n  /** Test for near-equality with `other` */\r\n  public isAlmostEqual(other: Matrix4d): boolean {\r\n    return Geometry.isSmallMetricDistance(this.maxDiff(other));\r\n  }\r\n  /**\r\n   * Convert an Matrix4d to a Matrix4dProps.\r\n   */\r\n  public toJSON(): Matrix4dProps {\r\n    const value = [];\r\n    for (let i = 0; i < 4; ++i) {\r\n      const row = i * 4;\r\n      value.push([this._coffs[row], this._coffs[row + 1], this._coffs[row + 2], this._coffs[row + 3]]);\r\n    }\r\n    return value;\r\n  }\r\n  /** Create from nested array json e.g. `[[1,2,3,4],[0,1,2,4],[0,2,5,1],[0,0,1,2]]` */\r\n  public static fromJSON(json?: Matrix4dProps) {\r\n    const result = new Matrix4d();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return a point with entries from positions [i0, i0+step, i0+2*step, i0+3*step].\r\n   * * There are no tests for index going out of the 0..15 range.\r\n   * * Usual uses are:\r\n   * * * i0 at left of row (0,4,8,12), step = 1 to extract a row.\r\n   * * * i0 at top of row (0,1,2,3), step = 4 to extract a column\r\n   * * * i0 = 0, step = 5 to extract the diagonal\r\n   * @returns a Point4d with 4 entries taken from positions at steps in the flat 16-member array.\r\n   * @param i0 start index (for 16 member array)\r\n   * @param step step between members\r\n   * @param result optional preallocated point.\r\n   */\r\n  public getSteppedPoint(i0: number, step: number, result?: Point4d): Point4d {\r\n    return Point4d.create(this._coffs[i0], this._coffs[i0 + step], this._coffs[i0 + 2 * step], this._coffs[i0 + 3 * step], result);\r\n  }\r\n  /** Return column 0 as Point4d. */\r\n  public columnX(): Point4d { return this.getSteppedPoint(0, 4); }\r\n  /** Return column 1 as Point4d. */\r\n  public columnY(): Point4d { return this.getSteppedPoint(1, 4); }\r\n  /** Return column 2 as Point4d. */\r\n  public columnZ(): Point4d { return this.getSteppedPoint(2, 4); }\r\n  /** Return column 3 as Point4d. */\r\n  public columnW(): Point4d { return this.getSteppedPoint(3, 4); }\r\n  /** Return row 0 as Point4d. */\r\n  public rowX(): Point4d { return this.getSteppedPoint(0, 1); }\r\n  /** Return row 1 as Point4d. */\r\n  public rowY(): Point4d { return this.getSteppedPoint(4, 1); }\r\n  /** Return row 2 as Point4d. */\r\n  public rowZ(): Point4d { return this.getSteppedPoint(8, 1); }\r\n  /** Return row 3 as Point4d. */\r\n  public rowW(): Point4d { return this.getSteppedPoint(12, 1); }\r\n  /**\r\n   * Returns true if the w row has content other than [0,0,0,1]\r\n   */\r\n  public get hasPerspective(): boolean {\r\n    return this._coffs[12] !== 0.0\r\n      || this._coffs[13] !== 0.0\r\n      || this._coffs[14] !== 0.0\r\n      || this._coffs[15] !== 1.0;\r\n  }\r\n  /**\r\n   * Return a Point4d with the diagonal entries of the matrix\r\n   */\r\n  public diagonal(): Point4d { return this.getSteppedPoint(0, 5); }\r\n  /** return the weight component of this matrix */\r\n  public weight(): number { return this._coffs[15]; }\r\n  /** return the leading 3x3 matrix part of this matrix */\r\n  public matrixPart(): Matrix3d {\r\n    return Matrix3d.createRowValues(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[8], this._coffs[9], this._coffs[10]);\r\n  }\r\n  /**\r\n   * Return the (affine, non-perspective) Transform with the upper 3 rows of this matrix\r\n   * @return undefined if this Matrix4d has perspective effects in the w row.\r\n   */\r\n  public get asTransform(): Transform | undefined {\r\n    if (this.hasPerspective)\r\n      return undefined;\r\n    return Transform.createRowValues(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3], this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[7], this._coffs[8], this._coffs[9], this._coffs[10], this._coffs[11]);\r\n  }\r\n  /** multiply this * other. */\r\n  public multiplyMatrixMatrix(other: Matrix4d, result?: Matrix4d): Matrix4d {\r\n    result = (result && result !== this && result !== other) ? result : new Matrix4d();\r\n    for (let i0 = 0; i0 < 16; i0 += 4) {\r\n      for (let k = 0; k < 4; k++)\r\n        result._coffs[i0 + k] =\r\n          this._coffs[i0] * other._coffs[k] +\r\n          this._coffs[i0 + 1] * other._coffs[k + 4] +\r\n          this._coffs[i0 + 2] * other._coffs[k + 8] +\r\n          this._coffs[i0 + 3] * other._coffs[k + 12];\r\n    }\r\n    return result;\r\n  }\r\n  /** multiply this * transpose(other). */\r\n  public multiplyMatrixMatrixTranspose(other: Matrix4d, result?: Matrix4d): Matrix4d {\r\n    result = (result && result !== this && result !== other) ? result : new Matrix4d();\r\n    let j = 0;\r\n    for (let i0 = 0; i0 < 16; i0 += 4) {\r\n      for (let k = 0; k < 16; k += 4)\r\n        result._coffs[j++] =\r\n          this._coffs[i0] * other._coffs[k] +\r\n          this._coffs[i0 + 1] * other._coffs[k + 1] +\r\n          this._coffs[i0 + 2] * other._coffs[k + 2] +\r\n          this._coffs[i0 + 3] * other._coffs[k + 3];\r\n    }\r\n    return result;\r\n  }\r\n  /** multiply transpose (this) * other. */\r\n  public multiplyMatrixTransposeMatrix(other: Matrix4d, result?: Matrix4d): Matrix4d {\r\n    result = (result && result !== this && result !== other) ? result : new Matrix4d();\r\n    let j = 0;\r\n    for (let i0 = 0; i0 < 4; i0 += 1) {\r\n      for (let k0 = 0; k0 < 4; k0 += 1)\r\n        result._coffs[j++] =\r\n          this._coffs[i0] * other._coffs[k0] +\r\n          this._coffs[i0 + 4] * other._coffs[k0 + 4] +\r\n          this._coffs[i0 + 8] * other._coffs[k0 + 8] +\r\n          this._coffs[i0 + 12] * other._coffs[k0 + 12];\r\n    }\r\n    return result;\r\n  }\r\n  /** Return a transposed matrix. */\r\n  public cloneTransposed(result?: Matrix4d): Matrix4d {\r\n    return Matrix4d.createRowValues(this._coffs[0], this._coffs[4], this._coffs[8], this._coffs[12], this._coffs[1], this._coffs[5], this._coffs[9], this._coffs[13], this._coffs[2], this._coffs[6], this._coffs[10], this._coffs[14], this._coffs[3], this._coffs[7], this._coffs[11], this._coffs[15], result);\r\n  }\r\n  /** multiply matrix times column [x,y,z,w].  return as Point4d.   (And the returned value is NOT normalized down to unit w) */\r\n  public multiplyXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d {\r\n    result = result ? result : Point4d.createZero();\r\n    return result.set(this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w, this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w, this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w, this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w);\r\n  }\r\n  /** multiply matrix times column vectors [x,y,z,w] where [x,y,z,w] appear in blocks in an array.\r\n   * replace the xyzw in the block\r\n   */\r\n  public multiplyBlockedFloat64ArrayInPlace(data: Float64Array) {\r\n    const n = data.length;\r\n    let x, y, z, w;\r\n    for (let i = 0; i + 3 < n; i += 4) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      z = data[i + 2];\r\n      w = data[i + 3];\r\n      data[i] = this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w;\r\n      data[i + 1] = this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w;\r\n      data[i + 2] = this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w;\r\n      data[i + 3] = this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w;\r\n    }\r\n  }\r\n  /** multiply matrix times XYAndZ  and w. return as Point4d  (And the returned value is NOT normalized down to unit w) */\r\n  public multiplyPoint3d(pt: XYAndZ, w: number, result?: Point4d): Point4d {\r\n    return this.multiplyXYZW(pt.x, pt.y, pt.z, w, result);\r\n  }\r\n  /** multiply matrix times and array  of XYAndZ. return as array of Point4d  (And the returned value is NOT normalized down to unit w) */\r\n  public multiplyPoint3dArray(pts: XYAndZ[], results: Point4d[], w: number = 1.0): void {\r\n    pts.forEach((pt, i) => { results[i] = this.multiplyXYZW(pt.x, pt.y, pt.z, w, results[i]); });\r\n  }\r\n  /** multiply [x,y,z,w] times matrix.  return as Point4d.   (And the returned value is NOT normalized down to unit w) */\r\n  public multiplyTransposeXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d {\r\n    result = result ? result : Point4d.createZero();\r\n    return result.set(this._coffs[0] * x + this._coffs[4] * y + this._coffs[8] * z + this._coffs[12] * w, this._coffs[1] * x + this._coffs[5] * y + this._coffs[9] * z + this._coffs[13] * w, this._coffs[2] * x + this._coffs[6] * y + this._coffs[10] * z + this._coffs[14] * w, this._coffs[3] * x + this._coffs[7] * y + this._coffs[11] * z + this._coffs[15] * w);\r\n  }\r\n  /** Returns dot product of row rowIndex of this with column columnIndex of other.\r\n   */\r\n  public rowDotColumn(rowIndex: number, other: Matrix4d, columnIndex: number): number {\r\n    const i = rowIndex * 4;\r\n    const j = columnIndex;\r\n    return this._coffs[i] * other._coffs[j]\r\n      + this._coffs[i + 1] * other._coffs[j + 4]\r\n      + this._coffs[i + 2] * other._coffs[j + 8]\r\n      + this._coffs[i + 3] * other._coffs[j + 12];\r\n  }\r\n  /** Returns dot product of row rowIndexThis of this with row rowIndexOther of other.\r\n   */\r\n  public rowDotRow(rowIndexThis: number, other: Matrix4d, rowIndexOther: number): number {\r\n    const i = rowIndexThis * 4;\r\n    const j = rowIndexOther * 4;\r\n    return this._coffs[i] * other._coffs[j]\r\n      + this._coffs[i + 1] * other._coffs[j + 1]\r\n      + this._coffs[i + 2] * other._coffs[j + 2]\r\n      + this._coffs[i + 3] * other._coffs[j + 3];\r\n  }\r\n  /** Returns dot product of row rowIndexThis of this with row rowIndexOther of other.\r\n   */\r\n  public columnDotColumn(columnIndexThis: number, other: Matrix4d, columnIndexOther: number): number {\r\n    const i = columnIndexThis;\r\n    const j = columnIndexOther;\r\n    return this._coffs[i] * other._coffs[j]\r\n      + this._coffs[i + 4] * other._coffs[j + 4]\r\n      + this._coffs[i + 8] * other._coffs[j + 8]\r\n      + this._coffs[i + 12] * other._coffs[j + 12];\r\n  }\r\n  /** Returns dot product of column columnIndexThis of this with row rowIndexOther other.\r\n   */\r\n  public columnDotRow(columnIndexThis: number, other: Matrix4d, rowIndexOther: number): number {\r\n    const i = columnIndexThis;\r\n    const j = 4 * rowIndexOther;\r\n    return this._coffs[i] * other._coffs[j]\r\n      + this._coffs[i + 4] * other._coffs[j + 1]\r\n      + this._coffs[i + 8] * other._coffs[j + 2]\r\n      + this._coffs[i + 12] * other._coffs[j + 3];\r\n  }\r\n  /** Return a matrix entry by row and column index.\r\n   */\r\n  public atIJ(rowIndex: number, columnIndex: number): number {\r\n    return this._coffs[rowIndex * 4 + columnIndex];\r\n  }\r\n\r\n  /** Set a matrix entry by row and column index.\r\n   */\r\n  public setAtIJ(rowIndex: number, columnIndex: number, value: number) {\r\n    this._coffs[rowIndex * 4 + columnIndex] = value;\r\n  }\r\n  /** multiply matrix * [x,y,z,w]. immediately renormalize to return in a Point3d.\r\n   * If zero weight appears in the result (i.e. input is on eyeplane) leave the mapped xyz untouched.\r\n   */\r\n  public multiplyXYZWQuietRenormalize(x: number, y: number, z: number, w: number, result?: Point3d): Point3d {\r\n    result = result ? result : Point3d.createZero();\r\n    result.set(this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w, this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w, this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w);\r\n    const w1 = this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w;\r\n    const qx = Geometry.conditionalDivideCoordinate(result.x, w1);\r\n    const qy = Geometry.conditionalDivideCoordinate(result.y, w1);\r\n    const qz = Geometry.conditionalDivideCoordinate(result.z, w1);\r\n    if (qx !== undefined && qy !== undefined && qz !== undefined) {\r\n      result.x = qx;\r\n      result.y = qy;\r\n      result.z = qz;\r\n    }\r\n    return result;\r\n  }\r\n  /** multiply matrix * an array of Point4d. immediately renormalize to return in an array of Point3d. */\r\n  public multiplyPoint4dArrayQuietRenormalize(pts: Point4d[], results: Point3d[]): void {\r\n    pts.forEach((pt, i) => { results[i] = this.multiplyXYZWQuietRenormalize(pt.x, pt.y, pt.z, pt.w, results[i]); });\r\n  }\r\n  /** multiply a Point4d, return with the optional result convention. */\r\n  public multiplyPoint4d(point: Point4d, result?: Point4d): Point4d {\r\n    return this.multiplyXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);\r\n  }\r\n  /** multiply a Point4d, return with the optional result convention. */\r\n  public multiplyTransposePoint4d(point: Point4d, result?: Point4d): Point4d {\r\n    return this.multiplyTransposeXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);\r\n  }\r\n  /** multiply matrix * point. This produces a weighted xyzw.\r\n   * Immediately renormalize back to xyz and return (with optional result convention).\r\n   * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.\r\n   */\r\n  public multiplyPoint3dQuietNormalize(point: XYAndZ, result?: Point3d): Point3d {\r\n    return this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, result);\r\n  }\r\n  /** multiply each matrix * points[i].   This produces a weighted xyzw.\r\n   * Immediately renormalize back to xyz and replace the original point.\r\n   * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.\r\n   */\r\n  public multiplyPoint3dArrayQuietNormalize(points: Point3d[]) {\r\n    points.forEach((point) => this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, point));\r\n  }\r\n  /**\r\n   * Add the product terms [xx,xy,xz,xw, yx, yy, yz, yw, zx, zy, zz, zs, wx, wy, wz, ww] to respective entries in the matrix\r\n   * @param x x component for products\r\n   * @param y y component for products\r\n   * @param z z component for products\r\n   * @param w w component for products\r\n   */\r\n  public addMomentsInPlace(x: number, y: number, z: number, w: number) {\r\n    this._coffs[0] += x * x;\r\n    this._coffs[1] += x * y;\r\n    this._coffs[2] += x * z;\r\n    this._coffs[3] += x * w;\r\n    this._coffs[4] += y * x;\r\n    this._coffs[5] += y * y;\r\n    this._coffs[6] += y * z;\r\n    this._coffs[7] += y * w;\r\n    this._coffs[8] += z * x;\r\n    this._coffs[9] += z * y;\r\n    this._coffs[10] += z * z;\r\n    this._coffs[11] += z * w;\r\n    this._coffs[12] += w * x;\r\n    this._coffs[13] += w * y;\r\n    this._coffs[14] += w * z;\r\n    this._coffs[15] += w * w;\r\n  }\r\n  /** accumulate all coefficients of other to this. */\r\n  public addScaledInPlace(other: Matrix4d, scale: number = 1.0) {\r\n    for (let i = 0; i < 16; i++)\r\n      this._coffs[i] += scale * other._coffs[i];\r\n  }\r\n  /**\r\n   * Add scale times rowA to rowB.\r\n   * @param rowIndexA row that is not modified\r\n   * @param rowIndexB row that is modified.\r\n   * @param firstColumnIndex first column modified.  All from there to the right are updated\r\n   * @param scale scale\r\n   */\r\n  public rowOperation(rowIndexA: number, rowIndexB: number, firstColumnIndex: number, scale: number) {\r\n    if (scale === 0.0)\r\n      return;\r\n    let iA = rowIndexA * 4 + firstColumnIndex;\r\n    let iB = rowIndexB * 4 + firstColumnIndex;\r\n    for (let i = firstColumnIndex; i < 4; i++ , iA++ , iB++)\r\n      this._coffs[iB] += scale * this._coffs[iA];\r\n  }\r\n  /** Return the determinant of the matrix. */\r\n  public determinant(): number {\r\n    const c = this._coffs;\r\n    return Geometry.determinant4x4(\r\n      c[0], c[1], c[2], c[3],\r\n      c[4], c[5], c[6], c[7],\r\n      c[8], c[9], c[10], c[11],\r\n      c[12], c[13], c[14], c[15]);\r\n  }\r\n  /** Compute an inverse matrix.\r\n   * * This uses direct formulas with various determinants.\r\n   * * If result is given, it is ALWAYS filled with values \"prior to dividing by the determinant\".\r\n   * *\r\n   * @returns undefined if dividing by the determinant looks unsafe.\r\n   */\r\n  public createInverse(result?: Matrix4d): Matrix4d | undefined {\r\n    const maxAbs0 = this.maxAbs();\r\n    if (maxAbs0 === 0.0)\r\n      return undefined;\r\n    const divMaxAbs = 1.0 / maxAbs0;\r\n    const columnA = this.columnX();\r\n    const columnB = this.columnY();\r\n    const columnC = this.columnZ();\r\n    const columnD = this.columnW();\r\n    columnA.scale(divMaxAbs, columnA);\r\n    columnB.scale(divMaxAbs, columnB);\r\n    columnC.scale(divMaxAbs, columnC);\r\n    columnD.scale(divMaxAbs, columnD);\r\n    const rowBCD = Point4d.perpendicularPoint4dPlane(columnB, columnC, columnD);\r\n    const rowCDA = Point4d.perpendicularPoint4dPlane(columnA, columnD, columnC);  // order for negation !\r\n    const rowDAB = Point4d.perpendicularPoint4dPlane(columnD, columnA, columnB);\r\n    const rowABC = Point4d.perpendicularPoint4dPlane(columnC, columnB, columnA); // order for negation !\r\n    // The matrix is singular if the determinant is zero.\r\n    // But what is the proper tolerance for zero?\r\n    // The row values are generally cubes of entries. And the typical perspective matrix\r\n    //    has very different magnitudes in various parts.  So a typical cube size is really hard.\r\n    // Compute 4 different determinants.  They should match.\r\n    // If they are near zero, maybe a sign change is a red flag for singular case.\r\n    // (And there's a lot less work to do that than was done to make the rows)\r\n    result = Matrix4d.createRows(rowBCD, rowCDA, rowDAB, rowABC, result);\r\n    const determinantA = rowBCD.dotProduct(columnA);\r\n    const determinantB = rowCDA.dotProduct(columnB);\r\n    const determinantC = rowDAB.dotProduct(columnC);\r\n    const determinantD = rowABC.dotProduct(columnD);\r\n    const maxAbs1 = result.maxAbs();\r\n    if (determinantA * determinantB > 0.0\r\n      && determinantA * determinantC > 0.0\r\n      && determinantA * determinantD > 0.0) {\r\n      const divisionTest = Geometry.conditionalDivideCoordinate(maxAbs1, determinantA);\r\n      if (divisionTest !== undefined) {\r\n        const b = divMaxAbs / determinantA;\r\n        result.scaleRowsInPlace(b, b, b, b);\r\n        return result;\r\n      }\r\n    } else {\r\n      return undefined; // this is a useful spot to break to see if the 4 determinant test is effective.\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Returns an array-of-arrays of the matrix rows, optionally passing each value through a function.\r\n   * @param f optional function to provide alternate values for each entry (e.g. force fuzz to zero.)\r\n   */\r\n  public rowArrays(f?: (value: number) => any): any {\r\n    if (f)\r\n      return [\r\n        [f(this._coffs[0]), f(this._coffs[1]), f(this._coffs[2]), f(this._coffs[3])],\r\n        [f(this._coffs[4]), f(this._coffs[5]), f(this._coffs[6]), f(this._coffs[7])],\r\n        [f(this._coffs[8]), f(this._coffs[9]), f(this._coffs[10]), f(this._coffs[11])],\r\n        [f(this._coffs[12]), f(this._coffs[13]), f(this._coffs[14]), f(this._coffs[15])]];\r\n    else\r\n      return [\r\n        [this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3]],\r\n        [this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[7]],\r\n        [this._coffs[8], this._coffs[9], this._coffs[10], this._coffs[11]],\r\n        [this._coffs[12], this._coffs[13], this._coffs[14], this._coffs[15]]];\r\n  }\r\n  /**\r\n   * Scale each row by respective scale factors.\r\n   * @param ax scale factor for row 0\r\n   * @param ay scale factor for row 1\r\n   * @param az scale factor for row 2\r\n   * @param aw scale factor for row 3\r\n   */\r\n  public scaleRowsInPlace(ax: number, ay: number, az: number, aw: number) {\r\n    for (let i = 0; i < 4; i++)\r\n      this._coffs[i] *= ax;\r\n    for (let i = 4; i < 8; i++)\r\n      this._coffs[i] *= ay;\r\n    for (let i = 8; i < 12; i++)\r\n      this._coffs[i] *= az;\r\n    for (let i = 12; i < 16; i++)\r\n      this._coffs[i] *= aw;\r\n  }\r\n  /**\r\n   * add an outer product (single column times single row times scale factor) to this matrix.\r\n   * @param vectorU column vector\r\n   * @param vectorV row vector\r\n   * @param scale scale factor\r\n   */\r\n  public addScaledOuterProductInPlace(vectorU: Point4d, vectorV: Point4d, scale: number) {\r\n    let a = vectorU.x * scale;\r\n    this._coffs[0] += a * vectorV.x;\r\n    this._coffs[1] += a * vectorV.y;\r\n    this._coffs[2] += a * vectorV.z;\r\n    this._coffs[3] += a * vectorV.w;\r\n\r\n    a = vectorU.y * scale;\r\n    this._coffs[4] += a * vectorV.x;\r\n    this._coffs[5] += a * vectorV.y;\r\n    this._coffs[6] += a * vectorV.z;\r\n    this._coffs[7] += a * vectorV.w;\r\n\r\n    a = vectorU.z * scale;\r\n    this._coffs[8] += a * vectorV.x;\r\n    this._coffs[9] += a * vectorV.y;\r\n    this._coffs[10] += a * vectorV.z;\r\n    this._coffs[11] += a * vectorV.w;\r\n\r\n    a = vectorU.w * scale;\r\n    this._coffs[12] += a * vectorV.x;\r\n    this._coffs[13] += a * vectorV.y;\r\n    this._coffs[14] += a * vectorV.z;\r\n    this._coffs[15] += a * vectorV.w;\r\n  }\r\n  /**\r\n   * ADD (n place) scale*A*B*AT where\r\n   * * A is a pure translation with final column [x,y,z,1]\r\n   * * B is the given `matrixB`\r\n   * * AT is the transpose of A.\r\n   * * scale is a multiplier.\r\n   * @param matrixB the middle matrix.\r\n   * @param ax x part of translation\r\n   * @param ay y part of translation\r\n   * @param az z part of translation\r\n   * @param scale scale factor for entire product\r\n   */\r\n  public addTranslationSandwichInPlace(matrixB: Matrix4d, ax: number, ay: number, az: number, scale: number) {\r\n    const bx = matrixB._coffs[3];\r\n    const by = matrixB._coffs[7];\r\n    const bz = matrixB._coffs[11];\r\n    // matrixB can be non-symmetric!!\r\n    const cx = matrixB._coffs[12];\r\n    const cy = matrixB._coffs[13];\r\n    const cz = matrixB._coffs[14];\r\n\r\n    const beta = matrixB._coffs[15];\r\n    const axBeta = ax * beta;\r\n    const ayBeta = ay * beta;\r\n    const azBeta = az * beta;\r\n    this._coffs[0] += scale * (matrixB._coffs[0] + ax * bx + cx * ax + ax * axBeta);\r\n    this._coffs[1] += scale * (matrixB._coffs[1] + ay * bx + cy * ax + ax * ayBeta);\r\n    this._coffs[2] += scale * (matrixB._coffs[2] + az * bx + cz * ax + ax * azBeta);\r\n    this._coffs[3] += scale * (bx + axBeta);\r\n\r\n    this._coffs[4] += scale * (matrixB._coffs[4] + ax * by + cx * ay + ay * axBeta);\r\n    this._coffs[5] += scale * (matrixB._coffs[5] + ay * by + cy * ay + ay * ayBeta);\r\n    this._coffs[6] += scale * (matrixB._coffs[6] + az * by + cz * ay + ay * azBeta);\r\n    this._coffs[7] += scale * (by + ayBeta);\r\n\r\n    this._coffs[8] += scale * (matrixB._coffs[8] + ax * bz + cx * az + az * axBeta);\r\n    this._coffs[9] += scale * (matrixB._coffs[9] + ay * bz + cy * az + az * ayBeta);\r\n    this._coffs[10] += scale * (matrixB._coffs[10] + az * bz + cz * az + az * azBeta);\r\n    this._coffs[11] += scale * (bz + azBeta);\r\n\r\n    this._coffs[12] += scale * (cx + axBeta);\r\n    this._coffs[13] += scale * (cy + ayBeta);\r\n    this._coffs[14] += scale * (cz + azBeta);\r\n    this._coffs[15] += scale * beta;\r\n  }\r\n  /**\r\n   * Multiply and replace contents of this matrix by A*this*AT where\r\n   * * A is a pure translation with final column [x,y,z,1]\r\n   * * this is this matrix.\r\n   * * AT is the transpose of A.\r\n   * * scale is a multiplier.\r\n   * @param matrixB the middle matrix.\r\n   * @param ax x part of translation\r\n   * @param ay y part of translation\r\n   * @param az z part of translation\r\n   * @param scale scale factor for entire product\r\n   */\r\n  public multiplyTranslationSandwichInPlace(ax: number, ay: number, az: number) {\r\n    const bx = this._coffs[3];\r\n    const by = this._coffs[7];\r\n    const bz = this._coffs[11];\r\n    // matrixB can be non-symmetric!!\r\n    const cx = this._coffs[12];\r\n    const cy = this._coffs[13];\r\n    const cz = this._coffs[14];\r\n\r\n    const beta = this._coffs[15];\r\n    const axBeta = ax * beta;\r\n    const ayBeta = ay * beta;\r\n    const azBeta = az * beta;\r\n    this._coffs[0] += (ax * bx + cx * ax + ax * axBeta);\r\n    this._coffs[1] += (ay * bx + cy * ax + ax * ayBeta);\r\n    this._coffs[2] += (az * bx + cz * ax + ax * azBeta);\r\n    this._coffs[3] += axBeta;\r\n\r\n    this._coffs[4] += (ax * by + cx * ay + ay * axBeta);\r\n    this._coffs[5] += (ay * by + cy * ay + ay * ayBeta);\r\n    this._coffs[6] += (az * by + cz * ay + ay * azBeta);\r\n    this._coffs[7] += ayBeta;\r\n\r\n    this._coffs[8] += (ax * bz + cx * az + az * axBeta);\r\n    this._coffs[9] += (ay * bz + cy * az + az * ayBeta);\r\n    this._coffs[10] += (az * bz + cz * az + az * azBeta);\r\n    this._coffs[11] += azBeta;\r\n\r\n    this._coffs[12] += axBeta;\r\n    this._coffs[13] += ayBeta;\r\n    this._coffs[14] += azBeta;\r\n    // coffs[15] is unchanged !!!\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\n\r\nimport { XYZ, Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Matrix4d } from \"./Matrix4d\";\r\nimport { Point4d } from \"./Point4d\";\r\nimport { XAndY, XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n/**\r\n * A MomentData structure carries data used in calculation of moments of inertia.\r\n * * origin = local origin used as moments are summed.\r\n * * sums = array of summed moments.\r\n *   * The [i,j] entry of the sums is a summed or integrated moment for product of axis i and j.\r\n *      * axes 0,1,2 are x,y,z\r\n *         * e.g. entry [0,1] is summed product xy\r\n *      * axis 3 is \"w\", which is 1 in sums.\r\n *         * e.g. entry 03 is summed x\r\n * @public\r\n */\r\nexport class MomentData {\r\n  /** Origin used for sums. */\r\n  public origin: Point3d;\r\n  /** flag to request deferred origin setup. */\r\n  public needOrigin: boolean;\r\n  /** Moment sums.\r\n   * * Set to zero at initialization and if requested later.\r\n   * * Accumulated during data entry phase.\r\n   */\r\n  public sums: Matrix4d;\r\n  /** the mapping between principal and world system.\r\n   * * This set up with its inverse already constructed.\r\n   */\r\n  public localToWorldMap: Transform;\r\n  /** Return the lower-right (3,3) entry in the sums.\r\n   * * This is the quantity (i.e. length, area, or volume) summed\r\n   */\r\n  public get quantitySum(): number { return this.sums.atIJ(3, 3); }\r\n  /** Return a scale factor to make these sums match the target orientation sign.\r\n   * * 1.0 if `this.quantitySum` has the same sign as `targetSign`.\r\n   * * -1.0 if `this.quantitySum` has the opposite sign from `targetSign`\r\n   */\r\n  public signFactor(targetSign: number): number {\r\n    return targetSign * this.quantitySum > 0 ? 1.0 : -1.0;\r\n  }\r\n\r\n  /**\r\n   *  If `this.needOrigin` flag is set, copy `origin` to `this.origin` and clear the flag.\r\n   *\r\n   */\r\n  public setOriginIfNeeded(origin: Point3d) {\r\n    if (this.needOrigin) {\r\n      this.origin.setFromPoint3d(origin);\r\n      this.needOrigin = false;\r\n    }\r\n  }\r\n  /**\r\n   *  If `this.needOrigin` flag is set, copy `origin` to `this.origin` and clear the flag.\r\n   *\r\n   */\r\n  public setOriginFromGrowableXYZArrayIfNeeded(points: GrowableXYZArray) {\r\n    if (this.needOrigin && points.length > 0) {\r\n      points.getPoint3dAtCheckedPointIndex(0, this.origin);\r\n      this.needOrigin = false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   *  If `this.needOrigin` flag is set, copy `origin` to `this.origin` and clear the flag.\r\n   *\r\n   */\r\n  public setOriginXYZIfNeeded(x: number, y: number, z: number) {\r\n    if (this.needOrigin) {\r\n      this.origin.set(x, y, z);\r\n      this.needOrigin = false;\r\n    }\r\n  }\r\n\r\n  /** radii of gyration (square roots of principal second moments)\r\n   */\r\n  public radiusOfGyration: Vector3d;\r\n  private constructor() {\r\n    this.origin = Point3d.createZero();\r\n    this.sums = Matrix4d.createZero();\r\n    this.localToWorldMap = Transform.createIdentity();\r\n    this.radiusOfGyration = Vector3d.create();\r\n    this.needOrigin = false;\r\n  }\r\n  /** Create moments with optional origin.\r\n   * * origin and needOrigin are quirky.\r\n   *   * (undefined, true) sets up to use first incoming point as origin.\r\n   *   * (origin) sets up to use that durable origin, set needsOrigin flag false\r\n   *   * (origin, true) the \"true\" is meaningless\r\n   *   * (undefined, false) makes 000 the durable origin\r\n  */\r\n  public static create(origin?: Point3d | undefined, needOrigin: boolean = false): MomentData {\r\n    const data = new MomentData();\r\n    data.needOrigin = needOrigin;\r\n    if (origin) {\r\n      data.origin.setFromPoint3d(origin);\r\n      data.needOrigin = false;\r\n    }\r\n    return data;\r\n  }\r\n  /**\r\n   * Return the formal tensor of integrated values `[yy+zz,xy,xz][yx,xx+zz,yz][zx,xy,xx+yy]`\r\n   * @param products matrix of (integrated) `[xx,xy,xz][yx,yy,yz][zx,xy,zz]`\r\n   */\r\n  public static momentTensorFromInertiaProducts(products: Matrix3d): Matrix3d {\r\n    const rr = products.sumDiagonal();\r\n    const result = Matrix3d.createScale(rr, rr, rr);\r\n    result.addScaledInPlace(products, -1.0);\r\n    return result;\r\n  }\r\n  /** Sort the columns of the matrix for increasing moments. */\r\n  public static sortColumnsForIncreasingMoments(axes: Matrix3d, moments: Vector3d) {\r\n    const points = [\r\n      axes.indexedColumnWithWeight(0, moments.x),\r\n      axes.indexedColumnWithWeight(1, moments.y),\r\n      axes.indexedColumnWithWeight(2, moments.z)].sort(\r\n        (dataA: Point4d, dataB: Point4d): number => {\r\n          if (dataA.w < dataB.w) return -1;\r\n          if (dataA.w > dataB.w) return 1;\r\n          return 0;\r\n        });\r\n    axes.setColumnsPoint4dXYZ(points[0], points[1], points[2]);\r\n    if (axes.determinant() < 0)\r\n      axes.scaleColumnsInPlace(-1.0, -1.0, -1.0);\r\n    // prefer x and z positive -- y falls wherever . ..\r\n    if (axes.at(0, 0) < 0.0)\r\n      axes.scaleColumnsInPlace(-1.0, -1.0, 1.0);\r\n    if (axes.at(2, 2) < 0.0)\r\n      axes.scaleColumnsInPlace(1.0, -1.0, -1.0);\r\n    moments.set(points[0].w, points[1].w, points[2].w);\r\n  }\r\n\r\n  /**\r\n   * Return the principal moment data for an array of points.\r\n   * @param points array of points\r\n   */\r\n  public static pointsToPrincipalAxes(points: Point3d[]): MomentData | undefined {\r\n    const moments = new MomentData();\r\n    if (points.length === 0)\r\n      return moments;\r\n    moments.clearSums(points[0]);\r\n    moments.accumulatePointMomentsFromOrigin(points);\r\n    return this.inertiaProductsToPrincipalAxes(moments.origin, moments.sums);\r\n  }\r\n  /**\r\n   * Compute principal axes from inertial products\r\n   * * The radii of gyration are sorted smallest to largest\r\n   * * Hence x axis is long direction\r\n   * * Hence planar data generates large moment as Z\r\n   * @param origin The origin used for the inertia products.\r\n   * @param inertiaProducts The inertia products -- sums or integrals of [xx,xy,xz,xw; yx,yy, yz,yw; zx,zy,zz,zw; wx,wy,wz,w]\r\n   */\r\n  public static inertiaProductsToPrincipalAxes(origin: XYZ, inertiaProducts: Matrix4d): MomentData | undefined {\r\n    const moments = new MomentData();\r\n    moments.sums.setFrom(inertiaProducts);\r\n    moments.origin.setFrom(origin);\r\n    if (!moments.shiftOriginAndSumsToCentroidOfSums())\r\n      return undefined;\r\n    const products = moments.sums.matrixPart();\r\n    const tensor = MomentData.momentTensorFromInertiaProducts(products);\r\n    const moment2 = Vector3d.create();\r\n    const axisVectors = Matrix3d.createZero();\r\n    tensor.fastSymmetricEigenvalues(axisVectors, moment2);\r\n    MomentData.sortColumnsForIncreasingMoments(axisVectors, moment2);\r\n    moments.localToWorldMap = Transform.createOriginAndMatrix(moments.origin, axisVectors);\r\n    moments.radiusOfGyration.set(\r\n      Math.sqrt(moment2.x), Math.sqrt(moment2.y), Math.sqrt(moment2.z));\r\n    moments.radiusOfGyration.scaleInPlace(1.0 / Math.sqrt(moments.sums.weight()));\r\n    return moments;\r\n  }\r\n  /**\r\n   * Test for match among selected members as they exist after `inertiaProductsToPrincipalAxes`\r\n   * * The members considered are\r\n   *   * origin of local to world map (i.e. centroid)\r\n   *   * radius of gyration\r\n   *   * axes of localToWorldMap.\r\n   * * Axis direction tests allow these quirks:\r\n   *   * opposite orientation is considered matched.\r\n   * * Full xyz symmetry: If x,y,z radii are matched, axes are not tested.\r\n   * * Symmetry in xy plane: If x and y radii are matched, the x and y axes area allowed to spin freely.  Only Z direction is tested.\r\n   * * If either or both are undefined, returns false.\r\n   * @param dataA first set of moments\r\n   * @param dataB second set of moments\r\n   */\r\n  public static areEquivalentPrincipalAxes(dataA: MomentData | undefined, dataB: MomentData | undefined): boolean {\r\n    if (dataA && dataB\r\n      && Geometry.isSameCoordinate(dataA.quantitySum, dataB.quantitySum))  {  // um.. need different tolerance for area, volume?)\r\n      if (dataA.localToWorldMap.getOrigin().isAlmostEqual(dataB.localToWorldMap.getOrigin())\r\n        && dataA.radiusOfGyration.isAlmostEqual(dataB.radiusOfGyration)) {\r\n        if (Geometry.isSameCoordinate(dataA.radiusOfGyration.x, dataA.radiusOfGyration.y)) {\r\n          // We have at least xy symmetry ....\r\n          if (Geometry.isSameCoordinate(dataA.radiusOfGyration.x, dataA.radiusOfGyration.z))\r\n            return true;\r\n          // just xy.\r\n          // allow opposite z directions.\r\n          // If the z's are aligned, x an dy can spin freely.\r\n          const zA = dataA.localToWorldMap.matrix.columnZ();\r\n          const zB = dataB.localToWorldMap.matrix.columnZ();\r\n          if (zA.isParallelTo(zB, true))\r\n            return true;\r\n          return false;\r\n        }\r\n        // no symmetry.  Test all three axes.\r\n        const vectorA = Vector3d.create();\r\n        const vectorB = Vector3d.create();\r\n        for (let i = 0; i < 3; i++) {\r\n          dataA.localToWorldMap.matrix.getColumn(i, vectorA);\r\n          dataB.localToWorldMap.matrix.getColumn(i, vectorB);\r\n          if (!vectorA.isParallelTo(vectorB, true))\r\n            return false;\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Clear the MomentData sums to zero, and establish a new origin. */\r\n  public clearSums(origin?: Point3d) {\r\n    this.sums.setZero();\r\n    if (origin)\r\n      this.origin.setFrom(origin);\r\n    else\r\n      this.origin.setZero();\r\n  }\r\n  /** Accumulate products-of-components for given points. */\r\n  public accumulatePointMomentsFromOrigin(points: Point3d[]) {\r\n    for (const p of points) {\r\n      this.sums.addMomentsInPlace(\r\n        p.x - this.origin.x,\r\n        p.y - this.origin.y,\r\n        p.z - this.origin.z,\r\n        1.0);\r\n    }\r\n  }\r\n  /** revise the accumulated sums to be \"around the centroid\" */\r\n  public shiftOriginAndSumsToCentroidOfSums(): boolean {\r\n    const xyz = this.sums.columnW().realPoint();\r\n    if (xyz) {\r\n      this.shiftOriginAndSumsByXYZ(xyz.x, xyz.y, xyz.z);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** revise the accumulated sums\r\n   * * add ax,ay,ax to the origin coordinates.\r\n   * * apply the negative translation to the sums.\r\n  */\r\n  public shiftOriginAndSumsByXYZ(ax: number, ay: number, az: number) {\r\n    this.origin.addXYZInPlace(ax, ay, az);\r\n    this.sums.multiplyTranslationSandwichInPlace(-ax, -ay, -az);\r\n  }\r\n  /** revise the accumulated sums so they are based at a specified origin. */\r\n  public shiftOriginAndSumsToNewOrigin(newOrigin: XYAndZ) {\r\n    this.shiftOriginAndSumsByXYZ(newOrigin.x - this.origin.x, newOrigin.y - this.origin.y, newOrigin.z - this.origin.z);\r\n  }\r\n  private static _vectorA?: Point4d;\r\n  private static _vectorB?: Point4d;\r\n  private static _vectorC?: Point4d;\r\n\r\n  /** compute moments of a triangle from the origin to the given line.\r\n   * Accumulate them to this.sums.\r\n   * * If `pointA` is undefined, use `this.origin` as pointA.\r\n   * * If `this.needOrigin` is set, pointB is used\r\n  */\r\n  public accumulateTriangleMomentsXY(pointA: XAndY | undefined, pointB: XAndY, pointC: XAndY) {\r\n    this.setOriginXYZIfNeeded(pointB.x, pointB.y, 0.0);\r\n    const x0 = this.origin.x;\r\n    const y0 = this.origin.y;\r\n    const vectorA = MomentData._vectorA =\r\n      pointA !== undefined ? Point4d.create(pointA.x - x0, pointA.y - y0, 0.0, 1.0, MomentData._vectorA)\r\n        : Point4d.create(this.origin.x, this.origin.y, 0.0, 1.0, MomentData._vectorA);\r\n    const vectorB = MomentData._vectorB = Point4d.create(pointB.x - x0, pointB.y - y0, 0.0, 1.0, MomentData._vectorB);\r\n    const vectorC = MomentData._vectorC = Point4d.create(pointC.x - x0, pointC.y - y0, 0.0, 1.0, MomentData._vectorC);\r\n\r\n    // accumulate Return product integrals I(0<=u<=1) I (0<=v<= u)  (w*W + u *U + v * V)(w*W + u *U + v * V)^  du dv\r\n    //  where w = 1-u-v\r\n    //  W = column vector (point00.x, point00.y, point00.z, 1.0) etc.\r\n    const detJ = Geometry.crossProductXYXY(vectorB.x - vectorA.x, vectorB.y - vectorA.y, vectorC.x - vectorA.x, vectorC.y - vectorA.y);\r\n    if (detJ !== 0.0) {\r\n      const r1_12 = detJ / 12.0;\r\n      const r1_24 = detJ / 24.0;\r\n\r\n      this.sums.addScaledOuterProductInPlace(vectorA, vectorA, r1_12);\r\n      this.sums.addScaledOuterProductInPlace(vectorA, vectorB, r1_24);\r\n      this.sums.addScaledOuterProductInPlace(vectorA, vectorC, r1_24);\r\n\r\n      this.sums.addScaledOuterProductInPlace(vectorB, vectorA, r1_24);\r\n      this.sums.addScaledOuterProductInPlace(vectorB, vectorB, r1_12);\r\n      this.sums.addScaledOuterProductInPlace(vectorB, vectorC, r1_24);\r\n\r\n      this.sums.addScaledOuterProductInPlace(vectorC, vectorA, r1_24);\r\n      this.sums.addScaledOuterProductInPlace(vectorC, vectorB, r1_24);\r\n      this.sums.addScaledOuterProductInPlace(vectorC, vectorC, r1_12);\r\n    }\r\n  }\r\n  /** add scaled outer product of (4d, unit weight) point to this.sums */\r\n  public accumulateScaledOuterProduct(point: XYAndZ, scaleFactor: number) {\r\n    this.setOriginXYZIfNeeded(point.x, point.y, 0.0);\r\n    const vectorA = MomentData._vectorA = Point4d.create(point.x - this.origin.x, point.y - this.origin.y, point.z - this.origin.z, 1.0, MomentData._vectorA);\r\n    this.sums.addScaledOuterProductInPlace(vectorA, vectorA, scaleFactor);\r\n  }\r\n  /** Accumulate wire moment integral from pointA to pointB */\r\n  public accumulateLineMomentsXYZ(pointA: Point3d, pointB: Point3d) {\r\n    this.setOriginXYZIfNeeded(pointA.x, pointA.y, pointA.z);\r\n    const x0 = this.origin.x;\r\n    const y0 = this.origin.y;\r\n    const z0 = this.origin.z;\r\n    const vectorA = MomentData._vectorA = Point4d.create(pointA.x - x0, pointA.y - y0, pointA.z - z0, 1.0, MomentData._vectorA);\r\n    const vectorB = MomentData._vectorB = Point4d.create(pointB.x - x0, pointB.y - y0, pointB.z - z0, 1.0, MomentData._vectorB);\r\n    const detJ = pointA.distance(pointB);\r\n    const r1_3 = detJ / 3.0;\r\n    const r1_6 = detJ / 6.0;\r\n    this.sums.addScaledOuterProductInPlace(vectorA, vectorA, r1_3);\r\n    this.sums.addScaledOuterProductInPlace(vectorA, vectorB, r1_6);\r\n    this.sums.addScaledOuterProductInPlace(vectorB, vectorA, r1_6);\r\n    this.sums.addScaledOuterProductInPlace(vectorB, vectorB, r1_3);\r\n\r\n  }\r\n\r\n  private _point0 = Point3d.create();\r\n  private _point1 = Point3d.create();\r\n  /** compute moments of triangles from a base point to the given linestring.\r\n   * Accumulate them to this.sums.\r\n   * * If `pointA` is undefined, use `this.origin` as pointA.\r\n   * * If `this.needOrigin` is set, the first point of the array is captured as local origin for subsequent sums.\r\n   *\r\n   */\r\n  public accumulateTriangleToLineStringMomentsXY(sweepBase: XAndY | undefined, points: GrowableXYZArray) {\r\n    const n = points.length;\r\n    if (n > 1) {\r\n      points.getPoint3dAtUncheckedPointIndex(0, this._point0);\r\n      for (let i = 1; i < n; i++) {\r\n        points.getPoint3dAtUncheckedPointIndex(i, this._point1);\r\n        this.accumulateTriangleMomentsXY(sweepBase, this._point0, this._point1);\r\n        this._point0.setFromPoint3d(this._point1);\r\n      }\r\n    }\r\n  }\r\n  // cspell:word ABAT\r\n  /**\r\n   * * Assemble XX, YY, XY products into a full matrix form [xx,xy,0,0; xy,yy,0,0;0,0,0,0;0,0,0,1].\r\n   * * Sandwich this between transforms with columns [vectorU, vectorV, 0000, origin].  (Column weights 0001) (only xy parts of vectors)\r\n   * * scale by detJ for the xy-only determinant of the vectors.\r\n   * @param productXX\r\n   * @param productXY\r\n   * @param productYY\r\n   * @param area Area in caller's system\r\n   * @param origin Caller's origin\r\n   * @param vectorU Caller's U axis (not necessarily unit)\r\n   * @param vectorV Caller's V axis (not necessarily unit)\r\n   */\r\n  public accumulateXYProductsInCentroidalFrame(productXX: number, productXY: number, productYY: number, area: number,\r\n    origin: XAndY, vectorU: XAndY, vectorV: XAndY) {\r\n    const centroidalProducts = Matrix4d.createRowValues(\r\n      productXX, productXY, 0, 0,\r\n      productXY, productYY, 0, 0,\r\n      0, 0, 0, 0,\r\n      0, 0, 0, area);\r\n    const detJ = Geometry.crossProductXYXY(vectorU.x, vectorV.x, vectorU.y, vectorV.y);\r\n    const placement = Matrix4d.createRowValues(\r\n      vectorU.x, vectorV.x, 0, origin.x - this.origin.x,\r\n      vectorU.y, vectorV.y, 0, origin.y - this.origin.y,\r\n      0, 0, 0, 0,\r\n      0, 0, 0, 1);\r\n    const AB = placement.multiplyMatrixMatrix(centroidalProducts);\r\n    const ABAT = AB.multiplyMatrixMatrixTranspose(placement);\r\n    this.sums.addScaledInPlace(ABAT, detJ);\r\n  }\r\n  /**\r\n   * Accumulate sums from other moments.\r\n   * * scale by given scaleFactor (e.g. sign to correct orientation)\r\n   * * pull the origin from `other` if `this` needs an origin.\r\n   * *\r\n   */\r\n  public accumulateProducts(other: MomentData, scale: number) {\r\n    this.setOriginIfNeeded(other.origin);\r\n    this.sums.addTranslationSandwichInPlace(other.sums, this.origin.x - other.origin.x, this.origin.y - other.origin.y, this.origin.z - other.origin.z, scale);\r\n  }\r\n\r\n  /**\r\n * Accumulate sums from Matrix4d and origin.\r\n * * scale by given scaleFactor (e.g. sign to correct orientation)\r\n * * trap the origin if `this` needs an origin.\r\n * *\r\n */\r\n  public accumulateProductsFromOrigin(origin: Point3d, products: Matrix4d, scale: number) {\r\n    this.setOriginIfNeeded(origin);\r\n    this.sums.addTranslationSandwichInPlace(products, this.origin.x - origin.x, this.origin.y - origin.y, this.origin.z - origin.z, scale);\r\n  }\r\n  /**\r\n   * Convert to a json data object with:\r\n   */\r\n  public toJSON(): any {\r\n    return {\r\n      origin: this.origin,\r\n      sums: this.sums.toJSON(),\r\n      radiusOfGyration: this.radiusOfGyration.toJSON(),\r\n      localToWorld: this.localToWorldMap.toJSON(),\r\n    };\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Point4d } from \"./Point4d\";\r\n/**\r\n * A Plane4dByOriginAndVectors is a 4d origin and pair of 4d \"vectors\" defining a 4d plane.\r\n * * The parameterization of the plane is    `X = origin + vectorU*u + vectorV * v`\r\n * * With particular weight values `origin.w === 1, vectorU.w === 0, vectorV.w === 0` this is like `Plane3dByOriginAndVectors`\r\n * * With other weights, the deweighted xyz coordinates of points on the 4d plane still form a 3d plane.\r\n * @public\r\n */\r\nexport class PlaneByOriginAndVectors4d {\r\n  /** homogeneous origin */\r\n  public origin: Point4d;\r\n  /** homogeneous u-direction vector */\r\n  public vectorU: Point4d;\r\n  /** homogeneous v-direction vector */\r\n  public vectorV: Point4d;\r\n  private constructor(origin: Point4d, vectorU: Point4d, vectorV: Point4d) {\r\n    this.origin = origin;\r\n    this.vectorU = vectorU;\r\n    this.vectorV = vectorV;\r\n  }\r\n  /** Return a clone of this plane */\r\n  public clone(result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d {\r\n    if (result) {\r\n      result.setFrom(this);\r\n      return result;\r\n    }\r\n    return new PlaneByOriginAndVectors4d(this.origin.clone(), this.vectorU.clone(), this.vectorV.clone());\r\n  }\r\n  /** copy all content from other plane */\r\n  public setFrom(other: PlaneByOriginAndVectors4d): void {\r\n    this.origin.setFrom(other.origin);\r\n    this.vectorU.setFrom(other.vectorU);\r\n    this.vectorV.setFrom(other.vectorV);\r\n  }\r\n  /** Return true if origin, vectorU, and vectorV pass isAlmostEqual. */\r\n  public isAlmostEqual(other: PlaneByOriginAndVectors4d): boolean {\r\n    return this.origin.isAlmostEqual(other.origin)\r\n      && this.vectorU.isAlmostEqual(other.vectorU)\r\n      && this.vectorV.isAlmostEqual(other.vectorV);\r\n  }\r\n  /** Create a plane with (copies of) origin, vectorU, vectorV parameters, all given as full 4d points.\r\n   */\r\n  public static createOriginAndVectors(origin: Point4d, vectorU: Point4d, vectorV: Point4d, result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d {\r\n    if (result) {\r\n      result.setOriginAndVectors(origin, vectorU, vectorV);\r\n      return result;\r\n    }\r\n    return new PlaneByOriginAndVectors4d(origin.clone(), vectorU.clone(), vectorV.clone());\r\n  }\r\n  /** Set all numeric data from complete list of (x,y,z,w) in origin, vectorU, and vectorV */\r\n  public setOriginAndVectorsXYZW(x0: number, y0: number, z0: number, w0: number, ux: number, uy: number, uz: number, uw: number, vx: number, vy: number, vz: number, vw: number): PlaneByOriginAndVectors4d {\r\n    this.origin.set(x0, y0, z0, w0);\r\n    this.vectorU.set(ux, uy, uz, uw);\r\n    this.vectorV.set(vx, vy, vz, vw);\r\n    return this;\r\n  }\r\n  /** Copy the contents of origin, vectorU, vectorV parameters to respective member variables */\r\n  public setOriginAndVectors(origin: Point4d, vectorU: Point4d, vectorV: Point4d): PlaneByOriginAndVectors4d {\r\n    this.origin.setFrom(origin);\r\n    this.vectorU.setFrom(vectorU);\r\n    this.vectorV.setFrom(vectorV);\r\n    return this;\r\n  }\r\n  /** Create from complete list of (x,y,z,w) in origin, vectorU, and vectorV */\r\n  public static createOriginAndVectorsXYZW(x0: number, y0: number, z0: number, w0: number, ux: number, uy: number, uz: number, uw: number, vx: number, vy: number, vz: number, vw: number, result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d {\r\n    if (result)\r\n      return result.setOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw);\r\n    return new PlaneByOriginAndVectors4d(Point4d.create(x0, y0, z0, w0), Point4d.create(ux, uy, uz, uw), Point4d.create(vx, vy, vz, uw));\r\n  }\r\n  /** create from origin point, (u=1,v=0) point, and (u=0,v=1) point. */\r\n  public static createOriginAndTargets3d(origin: Point3d, targetU: Point3d, targetV: Point3d, result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d {\r\n    return PlaneByOriginAndVectors4d.createOriginAndVectorsXYZW(origin.x, origin.y, origin.z, 1.0, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, 0.0, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, 0.0, result);\r\n  }\r\n  /** evaluate plane point (full 3d) at given (u,v) coordinate. */\r\n  public fractionToPoint(u: number, v: number, result?: Point4d): Point4d {\r\n    return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);\r\n  }\r\n/** create a new plane which maps to the cartesian xy plane. */\r\n  public static createXYPlane(result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d {\r\n    return PlaneByOriginAndVectors4d.createOriginAndVectorsXYZW(0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, result);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\nimport { Geometry, BeJSONFunctions } from \"../Geometry\";\r\nimport { XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\n\r\n/**\r\n * 4d point packed in an array of 4 numbers.\r\n * @public\r\n */\r\nexport type Point4dProps = number[];\r\n/**\r\n *\r\n * @param ddg numerator second derivative\r\n * @param dh denominator derivative\r\n * @param ddh denominator second derivative\r\n * @param f primary function (g/h)\r\n * @param df derivative of (g/h)\r\n * @param divH = (1/h)\r\n * @internal\r\n */\r\nfunction quotientDerivative2(ddg: number, dh: number, ddh: number,\r\n  f: number, df: number, divH: number): number {\r\n  return divH * (ddg - 2.0 * df * dh - f * ddh);\r\n}\r\n\r\n/** 4 Dimensional point (x,y,z,w) used in perspective calculations.\r\n * * the coordinates are stored in a Float64Array of length 4.\r\n * * properties `x`, `y`, `z`, `w` access array members.\r\n * *\r\n * * The coordinates are physically stored as a single Float64Array with 4 entries. (w last)\r\n * *\r\n * @public\r\n */\r\nexport class Point4d implements BeJSONFunctions {\r\n  /** x,y,z,w are packed into a Float64Array */\r\n  public xyzw: Float64Array;\r\n  /** Set x,y,z,w of this point.  */\r\n  public set(x: number = 0, y: number = 0, z: number = 0, w: number = 0): Point4d {\r\n    this.xyzw[0] = x;\r\n    this.xyzw[1] = y;\r\n    this.xyzw[2] = z;\r\n    this.xyzw[3] = w;\r\n    return this;\r\n  }\r\n  /** Set a component by index.\r\n   * * No change if index is out of range.\r\n   */\r\n  public setComponent(index: number, value: number) {\r\n    if (index >= 0 && index < 4) {\r\n      this.xyzw[index] = value;\r\n    }\r\n  }\r\n  /** Return the x component. */\r\n  public get x() { return this.xyzw[0]; }\r\n  /** Set the x component. */\r\n  public set x(val: number) { this.xyzw[0] = val; }\r\n  /** Return the y component. */\r\n  public get y() { return this.xyzw[1]; }\r\n  /** Set the y component. */\r\n  public set y(val: number) { this.xyzw[1] = val; }\r\n  /** Return the z component. */\r\n  public get z() { return this.xyzw[2]; }\r\n  /** Set the z component. */\r\n  public set z(val: number) { this.xyzw[2] = val; }\r\n  /** Return the w component of this point. */\r\n  public get w() { return this.xyzw[3]; }\r\n  /** Set the w component. */\r\n  public set w(val: number) { this.xyzw[3] = val; }\r\n  /** Construct from coordinates. */\r\n  protected constructor(x: number = 0, y: number = 0, z: number = 0, w: number = 0) {\r\n    this.xyzw = new Float64Array(4);\r\n    this.xyzw[0] = x;\r\n    this.xyzw[1] = y;\r\n    this.xyzw[2] = z;\r\n    this.xyzw[3] = w;\r\n  }\r\n  /** Return a Point4d with specified x,y,z,w */\r\n  public static create(x: number = 0, y: number = 0, z: number = 0, w: number = 0, result?: Point4d): Point4d {\r\n    return result ? result.set(x, y, z, w) : new Point4d(x, y, z, w);\r\n  }\r\n  /** Copy coordinates from `other`. */\r\n  public setFrom(other: Point4d): Point4d {\r\n    this.xyzw[0] = other.xyzw[0];\r\n    this.xyzw[1] = other.xyzw[1];\r\n    this.xyzw[2] = other.xyzw[2];\r\n    this.xyzw[3] = other.xyzw[3];\r\n    return this;\r\n  }\r\n  /** Clone this point */\r\n  public clone(result?: Point4d): Point4d {\r\n    return result ? result.setFrom(this) : new Point4d(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);\r\n  }\r\n  /** Set this point's xyzw from a json array `[x,y,z,w]` */\r\n  public setFromJSON(json?: Point4dProps) {\r\n    if (Geometry.isNumberArray(json, 4))\r\n      this.set(json![0], json![1], json![2], json![3]);\r\n    else\r\n      this.set(0, 0, 0, 0);\r\n  }\r\n\r\n  /** Create a new point with coordinates from a json array `[x,y,z,w]` */\r\n  public static fromJSON(json?: Point4dProps): Point4d {\r\n    const result = new Point4d();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Near-equality test, using `Geometry.isSameCoordinate` on all 4 x,y,z,w */\r\n  public isAlmostEqual(other: Point4d): boolean {\r\n    return Geometry.isSameCoordinate(this.x, other.x)\r\n      && Geometry.isSameCoordinate(this.y, other.y)\r\n      && Geometry.isSameCoordinate(this.z, other.z)\r\n      && Geometry.isSameCoordinate(this.w, other.w);\r\n  }\r\n  /**\r\n   * Test for same coordinate by direct x,y,z,w args\r\n   * @param x x to test\r\n   * @param y y to test\r\n   * @param z z to test\r\n   * @param w w to test\r\n   */\r\n  public isAlmostEqualXYZW(x: number, y: number, z: number, w: number): boolean {\r\n    return Geometry.isSameCoordinate(this.x, x)\r\n      && Geometry.isSameCoordinate(this.y, y)\r\n      && Geometry.isSameCoordinate(this.z, z)\r\n      && Geometry.isSameCoordinate(this.w, w);\r\n  }\r\n\r\n  /**\r\n   * Convert an Angle to a JSON object.\r\n   * @return {*} [x,y,z,w]\r\n   */\r\n  public toJSON(): Point4dProps {\r\n    return [this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]];\r\n  }\r\n  /** Return the 4d distance from this point to other, with all 4 components squared into the hypotenuse.\r\n   * * x,y,z,w all participate without normalization.\r\n   */\r\n  public distanceXYZW(other: Point4d): number {\r\n    return Geometry.hypotenuseXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);\r\n  }\r\n  /** Return the squared 4d distance from this point to other, with all 4 components squared into the hypotenuse.\r\n   * * x,y,z,w all participate without normalization.\r\n   */\r\n  public distanceSquaredXYZW(other: Point4d): number {\r\n    return Geometry.hypotenuseSquaredXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);\r\n  }\r\n  /** Return the distance between the instance and other after normalizing by weights\r\n   */\r\n  public realDistanceXY(other: Point4d): number | undefined {\r\n    const wA = this.w;\r\n    const wB = other.w;\r\n    if (Geometry.isSmallMetricDistance(wA) || Geometry.isSmallMetricDistance(wB))\r\n      return undefined;\r\n    return Geometry.hypotenuseXY(other.xyzw[0] / wB - this.xyzw[0] / wA, other.xyzw[1] / wB - this.xyzw[1] / wA);\r\n  }\r\n  /** Return the largest absolute distance between corresponding components\r\n   * * x,y,z,w all participate without normalization.\r\n   */\r\n  public maxDiff(other: Point4d): number {\r\n    return Math.max(Math.abs(other.xyzw[0] - this.xyzw[0]), Math.abs(other.xyzw[1] - this.xyzw[1]), Math.abs(other.xyzw[2] - this.xyzw[2]), Math.abs(other.xyzw[3] - this.xyzw[3]));\r\n  }\r\n  /** Return the largest absolute entry of all 4 components x,y,z,w */\r\n  public maxAbs(): number {\r\n    return Math.max(Math.abs(this.xyzw[0]), Math.abs(this.xyzw[1]), Math.abs(this.xyzw[2]), Math.abs(this.xyzw[3]));\r\n  }\r\n  /** Returns the magnitude including all 4 components x,y,z,w */\r\n  public magnitudeXYZW(): number {\r\n    return Geometry.hypotenuseXYZW(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);\r\n  }\r\n  /** Returns the magnitude of the leading xyz components.  w is ignored.  (i.e. the leading xyz are NOT divided by w.) */\r\n  public magnitudeSquaredXYZ(): number {\r\n    return Geometry.hypotenuseSquaredXYZ(this.xyzw[0], this.xyzw[1], this.xyzw[2]);\r\n  }\r\n\r\n  /** Return the difference (this-other) using all 4 components x,y,z,w */\r\n  public minus(other: Point4d, result?: Point4d): Point4d {\r\n    return Point4d.create(this.xyzw[0] - other.xyzw[0], this.xyzw[1] - other.xyzw[1], this.xyzw[2] - other.xyzw[2], this.xyzw[3] - other.xyzw[3], result);\r\n  }\r\n  /** Return `((other.w * this) -  (this.w * other))` */\r\n  public crossWeightedMinus(other: Point4d, result?: Vector3d): Vector3d {\r\n    const wa = this.xyzw[3];\r\n    const wb = other.xyzw[3];\r\n    return Vector3d.create(wb * this.xyzw[0] - wa * other.xyzw[0], wb * this.xyzw[1] - wa * other.xyzw[1], wb * this.xyzw[2] - wa * other.xyzw[2], result);\r\n  }\r\n  /** Return the sum of this and other, using all 4 components x,y,z,w */\r\n  public plus(other: Point4d, result?: Point4d): Point4d {\r\n    return Point4d.create(this.xyzw[0] + other.xyzw[0], this.xyzw[1] + other.xyzw[1], this.xyzw[2] + other.xyzw[2], this.xyzw[3] + other.xyzw[3], result);\r\n  }\r\n  /** Test if all components are nearly zero. */\r\n  public get isAlmostZero(): boolean {\r\n    return Geometry.isSmallMetricDistance(this.maxAbs());\r\n  }\r\n  /** Create a point with zero in all coordinates. */\r\n  public static createZero(): Point4d { return new Point4d(0, 0, 0, 0); }\r\n  /**\r\n   * Create plane coefficients for the plane containing pointA, pointB, and 0010.\r\n   * @param pointA first point\r\n   * @param pointB second point\r\n   */\r\n  public static createPlanePointPointZ(pointA: Point4d, pointB: Point4d, result?: Point4d) {\r\n    return Point4d.create(pointA.y * pointB.w - pointA.w * pointB.y, pointA.w * pointB.x - pointA.x * pointB.w, 0.0, pointA.x * pointB.y - pointA.y * pointB.x, result);\r\n  }\r\n  /**\r\n   * extract 4 consecutive numbers from a Float64Array into a Point4d.\r\n   * @param data buffer of numbers\r\n   * @param xIndex first index for x,y,z,w sequence\r\n   */\r\n  public static createFromPackedXYZW(data: Float64Array, xIndex: number = 0, result?: Point4d): Point4d {\r\n    return Point4d.create(data[xIndex], data[xIndex + 1], data[xIndex + 2], data[xIndex + 3], result);\r\n  }\r\n  /** Create a `Point4d` with x,y,z from an `XYAndZ` input, and w from a separate number. */\r\n  public static createFromPointAndWeight(xyz: XYAndZ, w: number): Point4d {\r\n    return new Point4d(xyz.x, xyz.y, xyz.z, w);\r\n  }\r\n  /** Return `point + vector * scalar` */\r\n  public plusScaled(vector: Point4d, scaleFactor: number, result?: Point4d): Point4d {\r\n    return Point4d.create(this.xyzw[0] + vector.xyzw[0] * scaleFactor, this.xyzw[1] + vector.xyzw[1] * scaleFactor, this.xyzw[2] + vector.xyzw[2] * scaleFactor, this.xyzw[3] + vector.xyzw[3] * scaleFactor, result);\r\n  }\r\n  /** Return interpolation between instance and pointB at fraction\r\n   */\r\n  public interpolate(fraction: number, pointB: Point4d, result?: Point4d): Point4d {\r\n    const v = 1.0 - fraction;\r\n    return Point4d.create(this.xyzw[0] * v + pointB.xyzw[0] * fraction, this.xyzw[1] * v + pointB.xyzw[1] * fraction, this.xyzw[2] * v + pointB.xyzw[2] * fraction, this.xyzw[3] * v + pointB.xyzw[3] * fraction, result);\r\n  }\r\n  /** Return `point + vectorA * scalarA + vectorB * scalarB` */\r\n  public plus2Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, result?: Point4d): Point4d {\r\n    return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);\r\n  }\r\n  /** Return `point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */\r\n  public plus3Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, vectorC: Point4d, scalarC: number, result?: Point4d): Point4d {\r\n    return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);\r\n  }\r\n  /** Return `point + vectorA * scalarA + vectorB * scalarB` */\r\n  public static createAdd2Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, result?: Point4d): Point4d {\r\n    return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);\r\n  }\r\n  /** Return `point + vectorA \\ scalarA + vectorB * scalarB + vectorC * scalarC` */\r\n  public static createAdd3Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, vectorC: Point4d, scalarC: number, result?: Point4d): Point4d {\r\n    return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);\r\n  }\r\n  /** Return dot product of (4d) vectors from the instance to targetA and targetB */\r\n  public dotVectorsToTargets(targetA: Point4d, targetB: Point4d): number {\r\n    return (targetA.xyzw[0] - this.xyzw[0]) * (targetB.xyzw[0] - this.xyzw[0]) +\r\n      (targetA.xyzw[1] - this.xyzw[1]) * (targetB.xyzw[1] - this.xyzw[1]) +\r\n      (targetA.xyzw[2] - this.xyzw[2]) * (targetB.xyzw[2] - this.xyzw[2]) +\r\n      (targetA.xyzw[3] - this.xyzw[3]) * (targetB.xyzw[3] - this.xyzw[3]);\r\n  }\r\n  /** return (4d) dot product of the instance and other point. */\r\n  public dotProduct(other: Point4d): number {\r\n    return this.xyzw[0] * other.xyzw[0] + this.xyzw[1] * other.xyzw[1] + this.xyzw[2] * other.xyzw[2] + this.xyzw[3] * other.xyzw[3];\r\n  }\r\n  /** return (4d) dot product of the instance with xyzw */\r\n  public dotProductXYZW(x: number, y: number, z: number, w: number): number {\r\n    return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z + this.xyzw[3] * w;\r\n  }\r\n  /** dotProduct with (point.x, point.y, point.z, 1) Used in PlaneAltitudeEvaluator interface */\r\n  public altitude(point: Point3d): number {\r\n    return this.xyzw[0] * point.x + this.xyzw[1] * point.y + this.xyzw[2] * point.z + this.xyzw[3];\r\n  }\r\n  /** dotProduct with (x, y, z, 1) Used in PlaneAltitudeEvaluator interface */\r\n  public altitudeXYZ(x: number, y: number, z: number): number {\r\n    return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z + this.xyzw[3];\r\n  }\r\n  /** dotProduct with (point.x, point.y, point.z, point.w) Used in PlaneAltitudeEvaluator interface */\r\n  public weightedAltitude(point: Point4d): number {\r\n    return this.xyzw[0] * point.x + this.xyzw[1] * point.y + this.xyzw[2] * point.z + this.xyzw[3] * point.w;\r\n  }\r\n  /** dotProduct with (vector.x, vector.y, vector.z, 0).  Used in PlaneAltitudeEvaluator interface */\r\n  public velocity(vector: Vector3d): number {\r\n    return this.xyzw[0] * vector.x + this.xyzw[1] * vector.y + this.xyzw[2] * vector.z;\r\n  }\r\n  /** dotProduct with (x,y,z, 0).  Used in PlaneAltitudeEvaluator interface */\r\n  public velocityXYZ(x: number, y: number, z: number): number {\r\n    return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z;\r\n  }\r\n  /** unit X vector */\r\n  public static unitX(): Point4d { return new Point4d(1, 0, 0, 0); }\r\n  /** unit Y vector */\r\n  public static unitY(): Point4d { return new Point4d(0, 1, 0, 0); }\r\n  /** unit Z vector */\r\n  public static unitZ(): Point4d { return new Point4d(0, 0, 1, 0); }\r\n  /** unit W vector */\r\n  public static unitW(): Point4d { return new Point4d(0, 0, 0, 1); }\r\n  /** Divide by denominator, but return undefined if denominator is zero. */\r\n  public safeDivideOrNull(denominator: number, result?: Point4d): Point4d | undefined {\r\n    if (denominator !== 0.0) {\r\n      return this.scale(1.0 / denominator, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** scale all components (including w!!) */\r\n  public scale(scale: number, result?: Point4d): Point4d {\r\n    result = result ? result : new Point4d();\r\n    result.xyzw[0] = this.xyzw[0] * scale;\r\n    result.xyzw[1] = this.xyzw[1] * scale;\r\n    result.xyzw[2] = this.xyzw[2] * scale;\r\n    result.xyzw[3] = this.xyzw[3] * scale;\r\n    return result;\r\n  }\r\n  /** Negate components (including w!!) */\r\n  public negate(result?: Point4d): Point4d {\r\n    result = result ? result : new Point4d();\r\n    result.xyzw[0] = -this.xyzw[0];\r\n    result.xyzw[1] = -this.xyzw[1];\r\n    result.xyzw[2] = -this.xyzw[2];\r\n    result.xyzw[3] = -this.xyzw[3];\r\n    return result;\r\n  }\r\n  /**\r\n   * If `this.w` is nonzero, return a 4d point `(x/w,y/w,z/w, 1)`\r\n   * If `this.w` is zero, return undefined.\r\n   * @param result optional result\r\n   */\r\n  public normalizeWeight(result?: Point4d): Point4d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.xyzw[3]);\r\n    result = result ? result : new Point4d();\r\n    return this.safeDivideOrNull(mag, result);\r\n  }\r\n  /**\r\n   * If `this.w` is nonzero, return a 3d point `(x/w,y/w,z/w)`\r\n   * If `this.w` is zero, return undefined.\r\n   * @param result optional result\r\n   */\r\n  public realPoint(result?: Point3d): Point3d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.xyzw[3]);\r\n    if (mag === 0.0)\r\n      return undefined;\r\n    const a = 1.0 / mag; // in zero case everything multiplies right back to true zero.\r\n    return Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);\r\n  }\r\n  /**\r\n   * * If w is nonzero, return Point3d with x/w,y/w,z/w.\r\n   * * If w is zero, return 000\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   * @param w w coordinate\r\n   * @param result optional result\r\n   */\r\n  public static createRealPoint3dDefault000(x: number, y: number, z: number, w: number, result?: Point3d): Point3d {\r\n    const mag = Geometry.correctSmallMetricDistance(w);\r\n    const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.\r\n    return Point3d.create(x * a, y * a, z * a, result);\r\n  }\r\n  /**\r\n   * * If w is nonzero, return Vector3d which is the derivative of the projected xyz with given w and 4d derivatives.\r\n   * * If w is zero, return 000\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   * @param w w coordinate\r\n   * @param dx x coordinate of derivative\r\n   * @param dy y coordinate of derivative\r\n   * @param dz z coordinate of derivative\r\n   * @param dw w coordinate of derivative\r\n   * @param result optional result\r\n   */\r\n  public static createRealDerivativeRay3dDefault000(x: number, y: number, z: number, w: number, dx: number, dy: number, dz: number, dw: number, result?: Ray3d): Ray3d {\r\n    const mag = Geometry.correctSmallMetricDistance(w);\r\n    // real point is X/w.\r\n    // real derivative is (X' * w - X *w) / ww, and weight is always 0 by cross products.\r\n    const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.\r\n    const aa = a * a;\r\n    return Ray3d.createXYZUVW(x * a, y * a, z * a, (dx * w - dw * x) * aa, (dy * w - dw * y) * aa, (dz * w - dw * z) * aa, result);\r\n  }\r\n  /**\r\n   * * If w is nonzero, return Vector3d which is the derivative of the projected xyz with given w and 4d derivatives.\r\n   * * If w is zero, return 000\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   * @param w w coordinate\r\n   * @param dx x coordinate of derivative\r\n   * @param dy y coordinate of derivative\r\n   * @param dz z coordinate of derivative\r\n   * @param dw w coordinate of derivative\r\n   * @param result optional result\r\n   */\r\n  public static createRealDerivativePlane3dByOriginAndVectorsDefault000(x: number, y: number, z: number, w: number, dx: number, dy: number, dz: number, dw: number, ddx: number, ddy: number, ddz: number, ddw: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const mag = Geometry.correctSmallMetricDistance(w);\r\n    // real point is X/w.\r\n    // real derivative is (X' * w - X *w) / ww, and weight is always 0 by cross products.\r\n    const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.\r\n    const aa = a * a;\r\n    const fx = x * a;\r\n    const fy = y * a;\r\n    const fz = z * a;\r\n    const dfx = (dx * w - dw * x) * aa;\r\n    const dfy = (dy * w - dw * y) * aa;\r\n    const dfz = (dz * w - dw * z) * aa;\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(fx, fy, fz, dfx, dfy, dfz, quotientDerivative2(ddx, dw, ddw, fx, dfx, a), quotientDerivative2(ddy, dw, ddw, fy, dfy, a), quotientDerivative2(ddz, dw, ddw, fz, dfz, a), result);\r\n  }\r\n  /**\r\n   * * If this.w is nonzero, return Point3d with x/w,y/w,z/w.\r\n   * * If this.w is zero, return 000\r\n   */\r\n  public realPointDefault000(result?: Point3d): Point3d {\r\n    const mag = Geometry.correctSmallMetricDistance(this.xyzw[3]);\r\n    if (mag === 0.0)\r\n      return Point3d.create(0, 0, 0, result);\r\n    result = result ? result : new Point3d();\r\n    const a = 1.0 / mag;\r\n    return Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);\r\n  }\r\n  /** divide all components (x,y,z,w) by the 4d magnitude.\r\n   *\r\n   * * This is appropriate for normalizing a quaternion\r\n   * * Use normalizeWeight to divide by the w component.\r\n   */\r\n  public normalizeXYZW(result?: Point4d): Point4d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.magnitudeXYZW());\r\n    result = result ? result : new Point4d();\r\n    return this.safeDivideOrNull(mag, result);\r\n  }\r\n\r\n  /**\r\n   * Return the determinant of the 3x3 matrix using components i,j,k of the 3 inputs.\r\n   */\r\n  public static determinantIndexed3X3(pointA: Point4d, pointB: Point4d, pointC: Point4d, i: number, j: number, k: number) {\r\n    return Geometry.tripleProduct(\r\n      pointA.xyzw[i], pointA.xyzw[j], pointA.xyzw[k],\r\n      pointB.xyzw[i], pointB.xyzw[j], pointB.xyzw[k],\r\n      pointC.xyzw[i], pointC.xyzw[j], pointC.xyzw[k]);\r\n  }\r\n  /**\r\n   * Return a Point4d perpendicular to all 3 inputs. (A higher level cross product concept)\r\n   * @param pointA first point\r\n   * @param pointB second point\r\n   * @param pointC third point\r\n   */\r\n  public static perpendicularPoint4dPlane(pointA: Point4d, pointB: Point4d, pointC: Point4d): Point4d {\r\n    return Point4d.create(\r\n      Point4d.determinantIndexed3X3(pointA, pointB, pointC, 1, 2, 3),\r\n      -Point4d.determinantIndexed3X3(pointA, pointB, pointC, 2, 3, 0),\r\n      Point4d.determinantIndexed3X3(pointA, pointB, pointC, 3, 0, 1),\r\n      -Point4d.determinantIndexed3X3(pointA, pointB, pointC, 0, 1, 2));\r\n  }\r\n  /** Treating this Point4d as plane coefficients, convert to origin and normal form. */\r\n  public toPlane3dByOriginAndUnitNormal(result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal | undefined {\r\n    const aa = this.magnitudeSquaredXYZ();\r\n    const direction = Vector3d.create(this.x, this.y, this.z);\r\n    const w = this.w;\r\n    const divW = Geometry.conditionalDivideFraction(1.0, w);\r\n    if (divW !== undefined) {\r\n      const b = -w / aa;\r\n      direction.scaleInPlace(1.0 / Math.sqrt(aa));\r\n      return Plane3dByOriginAndUnitNormal.create(Point3d.create(this.x * b, this.y * b, this.z * b), direction, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Normalize so sum of squares of all 4 coordinates is 1. */\r\n  public normalizeQuaternion() {\r\n    const magnitude = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\r\n\r\n    if (magnitude > 0.0) {\r\n      const f = 1.0 / magnitude;\r\n      this.x *= f;\r\n      this.y *= f;\r\n      this.z *= f;\r\n      this.w *= f;\r\n    }\r\n    return magnitude;\r\n  }\r\n  /** Return a (normalized) quaternion interpolated between two quaternions. */\r\n  public static interpolateQuaternions(quaternion0: Point4d, fractionParameter: number, quaternion1: Point4d, result?: Point4d): Point4d {\r\n    if (!result)\r\n      result = new Point4d();\r\n    const maxSafeCosine = 0.9995;\r\n\r\n    // return exact quaternions for special values\r\n    if (0.0 === fractionParameter) {\r\n      result = quaternion0;\r\n      return result;\r\n    }\r\n    if (1.0 === fractionParameter) {\r\n      result = quaternion1;\r\n      return result;\r\n    }\r\n    if (0.5 === fractionParameter) {\r\n      quaternion0.plus(quaternion1, result);\r\n      result.normalizeQuaternion();\r\n      return result;\r\n    }\r\n\r\n    const q0 = quaternion0.clone();\r\n    const q1 = quaternion1.clone();\r\n    let dot = quaternion0.dotProduct(quaternion1);\r\n\r\n    // prevent interpolation through the longer great arc\r\n    if (dot < 0.0) {\r\n      q1.negate(q1);\r\n      dot = -dot;\r\n    }\r\n\r\n    // if nearly parallel, use interpolate and renormalize .\r\n    if (dot > maxSafeCosine) {\r\n      q0.interpolate(fractionParameter, q1, result);\r\n      result.normalizeQuaternion();\r\n      return result;\r\n    }\r\n\r\n    // safety check\r\n    if (dot < -1.0)\r\n      dot = -1.0;\r\n    else if (dot > 1.0)\r\n      dot = 1.0;\r\n\r\n    // create orthonormal basis {q0, q2}\r\n    const q2 = new Point4d();\r\n    q1.plusScaled(q0, -dot, q2);  //  bsiDPoint4d_addScaledDPoint4d(& q2, & q1, & q0, -dot);\r\n    q2.normalizeQuaternion();\r\n\r\n    const angle = Math.acos(dot);\r\n    const angleOfInterpolation = angle * fractionParameter;\r\n    result = Point4d.createAdd2Scaled(q0, Math.cos(angleOfInterpolation), q2, Math.sin(angleOfInterpolation));\r\n    return result;\r\n  }\r\n  /** Measure the \"angle\" between two points, using all 4 components in the dot product that\r\n   * gives the cosine of the angle.\r\n   */\r\n  public radiansToPoint4dXYZW(other: Point4d): number | undefined {\r\n    const magA = this.magnitudeXYZW();\r\n    const magB = other.magnitudeXYZW();\r\n    const dot = this.dotProduct(other);  // == cos (theta) * magA * magB\r\n    const cos = Geometry.conditionalDivideFraction(dot, magA * magB);\r\n    if (cos === undefined)\r\n      return undefined;\r\n    return Math.acos(cos);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\n// import { Angle, AngleSweep, Geometry } from \"../Geometry\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { PascalCoefficients } from \"./PascalCoefficients\";\r\nimport { Degree2PowerPolynomial, Degree3PowerPolynomial, Degree4PowerPolynomial, AnalyticRoots } from \"./Polynomials\";\r\n/* tslint:disable:variable-name*/\r\n/**\r\n * * BezierCoffs is an abstract base class for one-dimensional (u to f(u)) Bezier polynomials.\r\n * * The base class carries a Float64Array with coefficients.\r\n * * The Float64Array is NOT Growable unless derived classes add logic to do so.  Its length is the Bezier polynomial order.\r\n * * The family of derived classes is starts with low order (at least linear through cubic) with highly optimized calculations.\r\n * * The general degree Bezier class also uses this as its base class.\r\n * * The length of the coefficient array is NOT always the bezier order.   Use the `order` property to access the order.\r\n * @internal\r\n */\r\nexport abstract class BezierCoffs {\r\n  /** Array of coefficients.\r\n   * * The number of coefficients is the order of the Bezier polynomial.\r\n   */\r\n  public coffs: Float64Array;\r\n  /**\r\n   * * If `data` is a number, an array of that size is created with zeros.\r\n   * * If `data` is a Float64Array, it is cloned (NOT CAPTURED)\r\n   * * If `data` is a number array, its values are copied.\r\n   */\r\n  constructor(data: number | Float64Array | number[]) {\r\n    if (data instanceof Float64Array) {\r\n      this.coffs = data.slice();\r\n    } else if (Array.isArray(data)) {\r\n      this.coffs = new Float64Array(data.length);\r\n      let i = 0;\r\n      for (const a of data) this.coffs[i++] = a;\r\n    } else {\r\n      this.coffs = new Float64Array(data);\r\n    }\r\n  }\r\n  /**\r\n   * * Ensure the coefficient array size matches order.  (Reallocate as needed)\r\n   * * fill with zeros.\r\n   * @param order required order\r\n   */\r\n  protected allocateToOrder(order: number) {\r\n    if (this.coffs.length !== order) {\r\n      this.coffs = new Float64Array(order);\r\n    } else {\r\n      this.coffs.fill(0);\r\n    }\r\n  }\r\n  /** evaluate the basis functions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param buffer optional destination for values.   ASSUMED large enough for order.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public abstract basisFunctions(u: number, result?: Float64Array): Float64Array;\r\n\r\n  /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public abstract sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;\r\n\r\n  /** evaluate the basis functions derivatives at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public abstract sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;\r\n\r\n  /** Return a deep clone of this bezier. */\r\n  public abstract clone(): BezierCoffs;\r\n  /**\r\n   * create an object of same order with zero coefficients.\r\n   * The base implementation makes a generic Bezier of the same order.\r\n   */\r\n  public createPeer(): BezierCoffs {\r\n    const peer = new UnivariateBezier(this.order);\r\n    return peer;\r\n  }\r\n  /** Evaluate the polynomial at u.\r\n   * @param u bezier parameter for evaluation.\r\n   */\r\n  public abstract evaluate(u: number): number;\r\n  /** The order (number of coefficients) as a readable property  */\r\n  public get order(): number { return this.coffs.length; }\r\n  /** Copy coefficients from other Bezier. Note that the coefficient count (order) of \"this\" can change. */\r\n  public copyFrom(other: BezierCoffs): void {\r\n    if (this.order === other.order)\r\n      for (let i = 0; i < this.coffs.length; i++) { this.coffs[i] = other.coffs[i]; }\r\n    else this.coffs = other.coffs.slice();\r\n  }\r\n  /**\r\n   * Apply a scale factor to all coefficients.\r\n   * @param scale scale factor to apply to all coefficients.\r\n   */\r\n  public scaleInPlace(scale: number): void {\r\n    for (let i = 0; i < this.coffs.length; i++)\r\n      this.coffs[i] *= scale;\r\n  }\r\n  /** add a constant to each coefficient.\r\n   * @param a constant to add.\r\n   */\r\n  public addInPlace(a: number): void {\r\n    for (let i = 0; i < this.coffs.length; i++)\r\n      this.coffs[i] += a;\r\n  }\r\n  /** Compute parameter values where the bezier value matches _targetValue.\r\n   * * The base class finds roots only in 01.  (i.e. ignores _restrictTo01)\r\n   * * Order-specific implementations apply special case  analytic logic, e.g. for degree 1,2,3,4.\r\n   */\r\n  public roots(targetValue: number, _restrictTo01: boolean): number[] | undefined {\r\n    const bezier = UnivariateBezier.create(this);\r\n    bezier.addInPlace(- targetValue);\r\n    return UnivariateBezier.deflateRoots01(bezier);\r\n  }\r\n  /** Given an array of numbers, optionally remove those not in the 0..1 interval.\r\n   * @param roots candidate values\r\n   * @param restrictTo01 If false, no filtering occurs and the pointer to the original array is unchanged.\r\n   *     If true, filtering is done and values are returned, possibly in a new array and possibly in the original.\r\n   */\r\n  public filter01(roots: number[] | undefined, restrictTo01 = false): number[] | undefined {\r\n    if (!roots || !restrictTo01)\r\n      return roots;\r\n    let anyFound = false;\r\n    for (const r of roots) {\r\n      if (Geometry.isIn01(r)) { anyFound = true; break; }\r\n    }\r\n    if (anyFound) {\r\n      const roots01: number[] = [];\r\n      for (const r of roots) { if (Geometry.isIn01(r)) roots01.push(r); }\r\n      return roots01;\r\n    }\r\n    return undefined;\r\n  }\r\n  /** zero out all coefficients. */\r\n  public zero(): void { this.coffs.fill(0); }\r\n  /** Subdivide -- write results into caller-supplied bezier coffs (which must be of the same order) */\r\n  public subdivide(u: number, left: BezierCoffs, right: BezierCoffs): boolean {\r\n    const order = this.order;\r\n    if (left.order !== order || right.order !== order)\r\n      return false;\r\n    const v = 1.0 - u;\r\n    right.copyFrom(this);\r\n    // each left will be filled in directly, so there is no need to initialize it.\r\n    let n1 = order - 1; // number of interpolations in inner loop.\r\n    for (let i0 = 0; i0 < order; i0++) {\r\n      left.coffs[i0] = right.coffs[0];\r\n      for (let i = 0; i < n1; i++)\r\n        right.coffs[i] = v * right.coffs[i] + u * right.coffs[i + 1];\r\n      n1--;\r\n    }\r\n    return true;\r\n  }\r\n  /** Return the maximum absolute difference between coefficients of two sets of BezierCoffs */\r\n  public static maxAbsDiff(dataA: BezierCoffs, dataB: BezierCoffs): number | undefined {\r\n    const order = dataA.order;\r\n    if (dataB.order !== order)\r\n      return undefined;\r\n    let d = 0.0;\r\n    let d1;\r\n    for (let i = 0; i < order; i++) {\r\n      d1 = Math.abs(dataA.coffs[i] - dataB.coffs[i]);\r\n      if (d1 > d)\r\n        d = d1;\r\n    }\r\n    return d;\r\n  }\r\n}\r\n/**\r\n * Static methods to operate on univariate bezier polynomials, with coefficients in simple Float64Array or as components of blocked arrays.\r\n * @internal\r\n */\r\nexport class BezierPolynomialAlgebra {\r\n  /**\r\n   * * Univariate bezierA has its coefficients at offset indexA in each block within the array of blocks.\r\n   * * Symbolically:   `product(s) += scale * (constA - polynomialA(s)) *polynomialB(s)`\r\n   * * Where coefficients of polynomialA(s) are in column indexA and coefficients of polynomialB(s) are differences within column indexB.\r\n   * * Treating data as 2-dimensional array:   `product = sum (iA) sum (iB)    (constA - basisFunction[iA} data[indexA][iA]) * basisFunction[iB] * (dataOrder-1)(data[iB + 1][indexB] - data[iB][indexB])`\r\n   * * Take no action if product length is other than `dataOrder + dataOrder - 2`\r\n   */\r\n  public static accumulateScaledShiftedComponentTimesComponentDelta(\r\n    product: Float64Array,\r\n    data: Float64Array,\r\n    dataBlockSize: number,\r\n    dataOrder: number,\r\n    scale: number,\r\n    indexA: number,\r\n    constA: number,\r\n    indexB: number) {\r\n    const orderB = dataOrder - 1;  // coefficients of the first difference are implicitly present as differences of adjacent entries.\r\n    const orderA = dataOrder;\r\n    const orderC = dataOrder + orderB - 1;\r\n    if (product.length !== orderC) return;\r\n    const coffA = PascalCoefficients.getRow(orderA - 1);\r\n    const coffB = PascalCoefficients.getRow(orderB - 1);\r\n    const coffC = PascalCoefficients.getRow(orderC - 1);\r\n    let qA;\r\n    for (let a = 0; a < orderA; a++) {\r\n      qA = scale * (constA + data[indexA + a * dataBlockSize]) * coffA[a];\r\n      for (let b = 0, k = indexB; b < orderB; b++ , k += dataBlockSize) {\r\n        product[a + b] += qA * coffB[b] * (data[k + dataBlockSize] - data[k]) / coffC[a + b];\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * * Univariate bezierA has its coefficients at offset indexA in each block within the array of blocks.\r\n   * * Univariate bezierB has its coefficients at offset indexB in each block within the array of blocks.\r\n   * * return the sum coefficients for `constA * polynomialA + constB * polynomialB`\r\n   * * Symbolically:   `product(s) = (constA * polynomialA(s) + constB * polynomialB(s)`\r\n   * * The two polynomials are the same order, so this just direct sum of scaled coefficients.\r\n   *\r\n   * * Take no action if product length is other than `dataOrder + dataOrder - 2`\r\n   */\r\n  public static scaledComponentSum(sum: Float64Array, data: Float64Array, dataBlockSize: number, dataOrder: number, indexA: number, constA: number, indexB: number, constB: number) {\r\n    const orderA = dataOrder;\r\n    if (sum.length !== orderA) return;\r\n    for (let a = 0, rowBase = 0; a < orderA; a++ , rowBase += dataBlockSize) {\r\n      sum[a] = constA * data[rowBase + indexA] + constB * data[rowBase + indexB];\r\n    }\r\n  }\r\n  /**\r\n   * * Univariate bezier has its coefficients at offset index in each block within the array of blocks.\r\n   * * return the (dataOrder - 1) differences,\r\n   *\r\n   * * Take no action if difference length is other than `dataOrder - 1`\r\n   */\r\n  public static componentDifference(difference: Float64Array, data: Float64Array, dataBlockSize: number, dataOrder: number, index: number) {\r\n    const orderA = dataOrder;\r\n    const orderDiff = orderA - 1;\r\n    if (difference.length !== orderDiff) return;\r\n    for (let i = 0, k = index; i < orderDiff; k += dataBlockSize, i++)\r\n      difference[i] = data[k + dataBlockSize] - data[k];\r\n  }\r\n\r\n  /**\r\n   * * Univariate bezierA has its coefficients in dataA[i]\r\n   * * Univariate bezierB has its coefficients in dataB[i]\r\n   * * return the product coefficients for polynomialA(s) * polynomialB(s) * scale\r\n   * * Take no action if product length is other than `orderA + orderB - 1`\r\n   */\r\n  public static accumulateProduct(product: Float64Array, dataA: Float64Array, dataB: Float64Array, scale: number = 1.0) {\r\n    const orderA = dataA.length;\r\n    const orderB = dataB.length;\r\n    const orderC = orderA + orderB - 1;\r\n    if (product.length !== orderC) return;\r\n    let a: number;\r\n    let b: number;\r\n    let qA: number;\r\n    const coffA = PascalCoefficients.getRow(orderA - 1);\r\n    const coffB = PascalCoefficients.getRow(orderB - 1);\r\n    const coffC = PascalCoefficients.getRow(orderC - 1);\r\n    for (a = 0; a < orderA; a++) {\r\n      qA = scale * coffA[a] * dataA[a];\r\n      for (b = 0; b < orderB; b++) {\r\n        product[a + b] += qA * coffB[b] * dataB[b] / coffC[a + b];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * * Univariate bezierA has its coefficients in dataA[i]\r\n   * * Univariate bezierB has its coefficients in dataB[i]\r\n   * * return the product coefficients for polynomialADifferences(s) * polynomialB(s) * scale\r\n   * * Take no action if product length is other than `orderA + orderB - 2`\r\n   */\r\n  public static accumulateProductWithDifferences(product: Float64Array, dataA: Float64Array, dataB: Float64Array, scale: number = 1.0) {\r\n    const orderA = dataA.length - 1;  // We deal with its differences, which are lower order !!!\r\n    const orderB = dataB.length;\r\n    const orderC = orderA + orderB - 1;\r\n    if (product.length !== orderC) return;\r\n    let a: number;\r\n    let b: number;\r\n    let qA: number;\r\n    const coffA = PascalCoefficients.getRow(orderA - 1);\r\n    const coffB = PascalCoefficients.getRow(orderB - 1);\r\n    const coffC = PascalCoefficients.getRow(orderC - 1);\r\n    for (a = 0; a < orderA; a++) {\r\n      qA = scale * coffA[a] * (dataA[a + 1] - dataA[a]);\r\n      for (b = 0; b < orderB; b++) {\r\n        product[a + b] += qA * coffB[b] * dataB[b] / coffC[a + b];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * * Univariate bezier has its coefficients in data[i]\r\n   * * return the difference data[i+1]-data[i] in difference.\r\n   * * Take no action if product length is other than `orderA + orderB - 1`\r\n   */\r\n  public static univariateDifference(data: Float64Array, difference: Float64Array) {\r\n    const differenceOrder = difference.length;\r\n    if (difference.length + 1 !== differenceOrder)\r\n      for (let i = 0; i < differenceOrder; i++) {\r\n        difference[i] = data[i + 1] - data[i];\r\n      }\r\n  }\r\n  /**\r\n   * * Univariate bezierA has its coefficients in dataA[i]\r\n   * * Univariate bezierB has its coefficients in resultB[i]\r\n   * * add (with no scaling) bezierA to bezierB\r\n   * * Take no action if resultB.length is other than dataA.length.\r\n   */\r\n  public static accumulate(dataA: Float64Array, orderA: number, resultB: Float64Array) {\r\n    if (resultB.length !== orderA) return;\r\n    for (let i = 0; i < orderA; i++) {\r\n      resultB[i] += dataA[i];\r\n    }\r\n  }\r\n\r\n}\r\n/**\r\n * * The UnivariateBezier class is a univariate bezier polynomial with no particular order.\r\n * * More specific classes -- Order2Bezier, Order3Bezier, Order4Bezier -- can be used when a fixed order is known and the more specialized implementations are appropriate.\r\n * * When working with xy and xyz curves whose order is the common 2,3,4, various queries (e.g. project point to curve)\r\n *     generate higher order one-dimensional bezier polynomials with order that is a small multiple of the\r\n *     curve order.   Hence those polynomials commonly reach degree 8 to 12.\r\n * * Higher order bezier polynomials are possible, but performance and accuracy issues become significant.\r\n * * Some machine-level constraints apply for curves of extremely high order, e.g. 70.   For instance, at that level use of\r\n *     Pascal triangle coefficients becomes inaccurate because IEEE doubles cannot represent integers that\r\n *     large.\r\n * @internal\r\n */\r\nexport class UnivariateBezier extends BezierCoffs {\r\n  private _order: number;\r\n  /** Query the order of this bezier. */\r\n  public get order() { return this._order; }\r\n  public constructor(data: number | Float64Array | number[]) {\r\n    super(data);\r\n    this._order = super.order;\r\n  }\r\n\r\n  /** (Re) initialize with given order (and all coffs zero) */\r\n  public allocateOrder(order: number) {\r\n    if (this._order !== order) {\r\n      super.allocateToOrder(order);\r\n      this._order = order;\r\n    }\r\n    this.coffs.fill(0);\r\n  }\r\n  /** Return a copy, optionally with coffs array length reduced to actual order. */\r\n  public clone(compressToMinimalAllocation: boolean = false): UnivariateBezier {\r\n    if (compressToMinimalAllocation) {\r\n      const result1 = new UnivariateBezier(this.order);\r\n      result1.coffs = this.coffs.slice(0, this.order);\r\n      return result1;\r\n    }\r\n    const result = new UnivariateBezier(this.coffs.length);\r\n    result._order = this._order;\r\n    result.coffs = this.coffs.slice();\r\n    return result;\r\n  }\r\n  /** Create a new bezier which is a copy of other.\r\n   * * Note that `other` may be a more specialized class such as `Order2Bezier`, but the result is general `Bezier`\r\n   * @param other coefficients to copy.\r\n   */\r\n  public static create(other: BezierCoffs): UnivariateBezier {\r\n    const result = new UnivariateBezier(other.order);\r\n    result.coffs = other.coffs.slice();\r\n    return result;\r\n  }\r\n  /**\r\n   * copy coefficients into a new bezier.\r\n   * @param coffs coefficients for bezier\r\n   */\r\n  public static createCoffs(data: number | number[] | Float64Array): UnivariateBezier {\r\n    return new UnivariateBezier(data);\r\n  }\r\n  /**\r\n   * copy coefficients into a new bezier.\r\n   * * if result is omitted, a new UnivariateBezier is allocated and returned.\r\n   * * if result is present but has other order, its coefficients are reallocated\r\n   * * if result is present and has matching order, the values are replace.\r\n   * @param coffs coefficients for bezier\r\n   * @param index0 first index to access\r\n   * @param order number of coefficients, i.e. order for the result\r\n   * @param result optional result.\r\n   *\r\n   */\r\n  public static createArraySubset(coffs: number[] | Float64Array, index0: number, order: number, result?: UnivariateBezier): UnivariateBezier {\r\n    if (!result)\r\n      result = new UnivariateBezier(order);\r\n    else if (result.order !== order)\r\n      result.allocateToOrder(order);\r\n    for (let i = 0; i < order; i++)result.coffs[i] = coffs[index0 + i];\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a product of 2 bezier polynomials.\r\n   * @param bezierA\r\n   * @param bezierB\r\n   */\r\n  public static createProduct(bezierA: BezierCoffs, bezierB: BezierCoffs): UnivariateBezier {\r\n    const result = new UnivariateBezier(bezierA.order + bezierB.order - 1);\r\n    const pascalA = PascalCoefficients.getRow(bezierA.order - 1);\r\n    const pascalB = PascalCoefficients.getRow(bezierB.order - 1);\r\n    const pascalC = PascalCoefficients.getRow(bezierA.order + bezierB.order - 2);\r\n    for (let iA = 0; iA < bezierA.order; iA++) {\r\n      const a = bezierA.coffs[iA] * pascalA[iA];\r\n      for (let iB = 0; iB < bezierB.order; iB++) {\r\n        const b = bezierB.coffs[iB] * pascalB[iB];\r\n        const iC = iA + iB;\r\n        const c = pascalC[iC];\r\n        result.coffs[iC] += a * b / c;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Add a squared bezier polynomial (given as simple coffs)\r\n   * @param coffA coefficients of bezier to square\r\n   * @param scale scale factor\r\n   * @return false if order mismatch -- must have `2 * bezierA.length  === this.order + 1`\r\n   */\r\n  public addSquaredSquaredBezier(coffA: Float64Array, scale: number): boolean {\r\n    const orderA = coffA.length;\r\n    const orderC = this.order;\r\n    if (orderA * 2 !== orderC + 1) return false;\r\n    const pascalA = PascalCoefficients.getRow(orderA - 1);\r\n    const pascalC = PascalCoefficients.getRow(orderC - 1);\r\n    const coffC = this.coffs;\r\n    for (let iA = 0; iA < orderA; iA++) {\r\n      const a = coffA[iA] * pascalA[iA] * scale;\r\n      for (let iB = 0; iB < orderA; iB++) {\r\n        const b = coffA[iB] * pascalA[iB];\r\n        const iC = iA + iB;\r\n        const c = pascalC[iC];\r\n        coffC[iC] += a * b / c;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  /** Add a constant to each coefficient */\r\n  public addConstant(a: number) {\r\n    for (let i = 0; i < this.coffs.length; i++) {\r\n      this.coffs[i] += a;\r\n    }\r\n  }\r\n  private _basisValues?: Float64Array;\r\n  /** evaluate the basis functions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public basisFunctions(u: number, result?: Float64Array): Float64Array {\r\n    this._basisValues = PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);\r\n    if (!result || result.length !== this.order) result = new Float64Array(this.order);\r\n    let i = 0;\r\n    for (const a of this._basisValues) result[i++] = a;\r\n    return result;\r\n  }\r\n  /**\r\n   * Sum weights[i] * data[...] in blocks of numPerBlock.\r\n   * This is for low level use -- counts are not checked.\r\n   * @param weights\r\n   * @param data\r\n   * @param numPerBlock\r\n   */\r\n  private static sumWeightedBlocks(weights: Float64Array, numWeights: number, data: Float64Array, numPerBlock: number, result: Float64Array) {\r\n    for (let k0 = 0; k0 < numPerBlock; k0++) {\r\n      result[k0] = 0;\r\n    }\r\n    let k = 0;\r\n    let i;\r\n    for (let iWeight = 0; iWeight < numWeights; iWeight++) {\r\n      const w = weights[iWeight];\r\n      for (i = 0; i < numPerBlock; i++) {\r\n        result[i] += w * data[k++];\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Given (multidimensional) control points, sum the control points weighted by the basis function values at parameter u.\r\n   * @param u bezier parameter\r\n   * @param polygon Array with coefficients in blocks.\r\n   * @param blockSize size of blocks\r\n   * @param result `blockSize` summed values.\r\n   */\r\n  public sumBasisFunctions(u: number, polygon: Float64Array, blockSize: number, result?: Float64Array): Float64Array {\r\n    const order = this._order;\r\n    if (!result) result = new Float64Array(order);\r\n    this._basisValues = PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);\r\n    UnivariateBezier.sumWeightedBlocks(this._basisValues, order, polygon, blockSize, result);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Given (multidimensional) control points, sum the control points weighted by the basis function derivative values at parameter u.\r\n   * @param u bezier parameter\r\n   * @param polygon Array with coefficients in blocks.\r\n   * @param blockSize size of blocks\r\n   * @param result `blockSize` summed values.\r\n   */\r\n  public sumBasisFunctionDerivatives(u: number, polygon: Float64Array, blockSize: number, result?: Float64Array): Float64Array {\r\n    const order = this._order;\r\n    if (!result) result = new Float64Array(blockSize);\r\n    this._basisValues = PascalCoefficients.getBezierBasisDerivatives(this.order, u, this._basisValues);\r\n    UnivariateBezier.sumWeightedBlocks(this._basisValues, order, polygon, blockSize, result);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(u: number): number {\r\n    this._basisValues = PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);\r\n    let sum = 0;\r\n    for (let i = 0; i < this.order; i++)\r\n      sum += this._basisValues[i] * this.coffs[i];\r\n    return sum;\r\n  }\r\n  /**\r\n   * Apply deflation from the left to a bezier.\r\n   * * This assumes that the left coefficient is zero.\r\n   */\r\n  public deflateLeft() {\r\n    // coefficient 0 is zero (caller promises.)\r\n    // get bezier coffs for both orders ...\r\n    const order1 = this.order;\r\n    const order0 = order1 - 1;\r\n    const coff0 = PascalCoefficients.getRow(order0 - 1);\r\n    const coff1 = PascalCoefficients.getRow(order1 - 1);\r\n    let a;\r\n    for (let i = 0; i < order0; i++) {\r\n      a = this.coffs[i + 1];\r\n      this.coffs[i] = a * coff1[i + 1] / coff0[i];\r\n    }\r\n    this._order--;\r\n  }\r\n\r\n  /**\r\n   * Apply deflation from the right to a frame.\r\n   * * This assumes that the right coefficient is zero.\r\n   * @param frame frame description\r\n   */\r\n  public deflateRight() {\r\n    // final coefficient is zero (caller promises.)\r\n    // get bezier coffs for both orders ...\r\n    const order1 = this.order;\r\n    const order0 = order1 - 1;\r\n    const coff0 = PascalCoefficients.getRow(order0 - 1);\r\n    const coff1 = PascalCoefficients.getRow(order1 - 1);\r\n    let a, b;\r\n    for (let i = 0; i < order0; i++) {\r\n      a = this.coffs[i];\r\n      b = a * coff1[i] / coff0[i];\r\n      this.coffs[i] = b;\r\n    }\r\n    this._order--;\r\n  }\r\n  /**\r\n   * * divide the polynomial by `(x-root)`.\r\n   * * return the remainder\r\n   * * If `root` truly is a root, the return is zero.\r\n   * @param root root to remove\r\n   */\r\n  public deflateRoot(root: number): number {\r\n    const orderA = this.order;\r\n    const orderC = orderA - 1;  // the order of the deflated bezier.\r\n    if (orderA === 1) {\r\n      this._order = 0;\r\n      return this.coffs[0];\r\n    }\r\n    if (orderA < 1) {\r\n      this._order = 0;\r\n      return 0.0;\r\n    }\r\n    const pascalA = PascalCoefficients.getRow(orderA - 1);\r\n    const pascalC = PascalCoefficients.getRow(orderC - 1);\r\n    const b0 = -root;\r\n    const b1 = 1.0 - root;\r\n    let remainder = 0;\r\n    if (root > 0.5) {\r\n      let c0 = this.coffs[0] / b0;\r\n      let c1;\r\n      this.coffs[0] = c0;\r\n      let a1 = this.coffs[1];\r\n      for (let i = 1; i < orderC; i++) {\r\n        a1 = this.coffs[i] * pascalA[i];\r\n        c1 = (a1 - c0 * b1) / b0;\r\n        this.coffs[i] = c1 / pascalC[i];\r\n        c0 = c1;\r\n      }\r\n      remainder = this.coffs[orderA - 1] - c0 * b1;\r\n    } else {\r\n      // work backwards (to get division by larger of b0, b1)\r\n      // replace coefficients of a starting with orderA -1 --\r\n      // at end move them all forward.\r\n      let c1 = this.coffs[orderA - 1] / b1;\r\n      let c0;\r\n      this.coffs[orderA - 1] = c1;\r\n      let a1;\r\n      for (let i = orderA - 2; i > 0; i--) {\r\n        a1 = this.coffs[i] * pascalA[i];\r\n        c0 = (a1 - c1 * b0) / b1;\r\n        this.coffs[i] = c0 / pascalC[i - 1];  // pascalC index is from destination, which is not shifted.\r\n        c1 = c0;\r\n      }\r\n      remainder = (this.coffs[0] - c1 * b0);\r\n      for (let i = 0; i < orderC; i++)\r\n        this.coffs[i] = this.coffs[i + 1];\r\n    }\r\n    this._order = orderC;\r\n    // This should be zero !!!! (If not, `root` was not really a root!!)\r\n    return remainder;\r\n  }\r\n  private static _basisBuffer?: Float64Array;\r\n  private static _basisBuffer1?: Float64Array;\r\n  /**\r\n   * Run a Newton iteration from startFraction.\r\n   * @param startFraction [in] fraction for first iteration\r\n   * @param tolerance [in] convergence tolerance.   The iteration is considered converged on the\r\n   * second time the tolerance is satisfied.   For a typical iteration (not double root), the extra pass\r\n   * will double the number of digits.  Hence this tolerance is normally set to 10 to 12 digits, trusting\r\n   * that the final iteration will clean it up to nearly machine precision.\r\n   * @returns final fraction of iteration if converged.  undefined if iteration failed to converge.\r\n   */\r\n  public runNewton(startFraction: number, tolerance: number = 1.0e-11): number | undefined {\r\n    const derivativeFactor = this.order - 1;\r\n    let numConverged = 0;\r\n    let u = startFraction;\r\n    let f, df;\r\n    const bigStep = 10.0;\r\n    const order = this.order;\r\n    const coffs = this.coffs;\r\n    const orderD = order - 1;\r\n    for (let iterations = 0; iterations++ < 10;) {\r\n      UnivariateBezier._basisBuffer = PascalCoefficients.getBezierBasisValues(order, u, UnivariateBezier._basisBuffer);\r\n      f = 0; for (let i = 0; i < order; i++) f += coffs[i] * UnivariateBezier._basisBuffer[i];\r\n      UnivariateBezier._basisBuffer1 = PascalCoefficients.getBezierBasisValues(orderD, u, UnivariateBezier._basisBuffer1);\r\n      df = 0; for (let i = 0; i < orderD; i++) df += (coffs[i + 1] - coffs[i]) * UnivariateBezier._basisBuffer1[i];\r\n      df *= derivativeFactor;\r\n      if (Math.abs(f) > bigStep * Math.abs(df))\r\n        return undefined;\r\n      const du = f / df;\r\n      if (Math.abs(du) < tolerance) {\r\n        numConverged++;\r\n        if (numConverged >= 2)\r\n          return u - du;\r\n      } else {\r\n        numConverged = 0;\r\n      }\r\n      u -= du;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // Deflation table.  b0, b1 are coefficients of term being divided out\r\n  // Pascal coffs for b0,b1 are just 1.\r\n  // Each ai is a coefficient of the (known) input, with its Pascal coefficient blended in.\r\n  // each ci is a coefficient of the (unknown) result, with its coefficient blended in.\r\n  // note b0, b1 are both nonzero, so the divisions are safe.\r\n  // within the products, each c[i]*b0 pairs with c[i-1]*b1 (above and right diagonally) to make a[i]\r\n  // first and last c0*b0 and c[orderC-1]*b1 make a0 and a[orderA-1]\r\n  // |    |  b0    | b1      |   equivalence               | solve moving down\r\n  // | c0 | c0* b0 | c0 * b1 |    a0 = c0 * b0             | c0 = a0 / b0\r\n  // | c1 | c1* b0 | c1 * b1 |    a1 = c1 * b0 + c0 * b1   | c1 = (a1 - c0 * b1) / b0\r\n  // | c2 | c2* b0 | c2 * b1\r\n  // Each internal ci = (ai - c[i-1] * b1) /b0\r\n  // first c0*b0 = a0\r\n  // last c[orderC-1]*b1 = a[orderA-1]\r\n  /** Find roots of a bezier polynomial\r\n   * * Only look for roots in 0..1\r\n   * * As roots are found, deflate the polynomial.\r\n   * * bezier coffs are changed (and order reduced) at each step.\r\n   */\r\n  public static deflateRoots01(bezier: UnivariateBezier): number[] | undefined {\r\n    const roots = [];\r\n    const coffs = bezier.coffs;\r\n    let a0, a1, segmentFraction, globalStartFraction, newtonFraction;\r\n    while (bezier.order > 1) {\r\n      const order = bezier.order;\r\n      // Find any crossing\r\n      if (coffs[0] === 0.0) {\r\n        bezier.deflateLeft();\r\n        roots.push(0.0);\r\n        continue;\r\n      }\r\n      let numCrossing = 0;\r\n      let numNewtonOK = 0;\r\n      for (let i = 1; i < order; i++) {\r\n        a0 = coffs[i - 1];\r\n        a1 = coffs[i];\r\n        if (a0 * a1 <= 0.0) {\r\n          numCrossing++;\r\n          segmentFraction = -a0 / (a1 - a0);\r\n          globalStartFraction = (i - 1 + segmentFraction) / (order - 1);\r\n          newtonFraction = bezier.runNewton(globalStartFraction, 1.0e-10);\r\n          if (newtonFraction !== undefined) {\r\n            roots.push(newtonFraction);\r\n            bezier.deflateRoot(newtonFraction);\r\n            numNewtonOK++;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      if (numNewtonOK)\r\n        continue;\r\n      // if any crossing was found and led to a good newton, the \"continue\" jumped past this.\r\n      // if no crossings found, there are no roots to be had -- accept\r\n      if (numCrossing === 0)\r\n        return roots;\r\n      // reach here if there were crossings but not roots.\r\n      // is this just a local min?  or maybe a big problem?   Whatever, accept it\r\n      return roots;\r\n    }\r\n    return roots;\r\n  }\r\n}\r\n/** Bezier polynomial specialized to order 2 (2 coefficients, straight line function)\\\r\n * @internal\r\n */\r\nexport class Order2Bezier extends BezierCoffs {\r\n  constructor(f0: number = 0.0, f1: number = 0.0) {\r\n    super(2);\r\n    this.coffs[0] = f0;\r\n    this.coffs[1] = f1;\r\n  }\r\n  /** return an Order2Bezier (linear) with the two coefficients from this Order2Bezier */\r\n  public clone(): Order2Bezier {\r\n    return new Order2Bezier(this.coffs[0], this.coffs[1]);\r\n  }\r\n\r\n  /** normally, return fractional coordinate where bezier (a0,a1) has a root.\r\n   * but if the fraction would exceed Geometry.largeFractionResult, return undefined.\r\n   */\r\n  public static solveCoffs(a0: number, a1: number): number | undefined {\r\n    return Geometry.conditionalDivideFraction(-a0, (a1 - a0));\r\n  }\r\n  /** evaluate the basis functions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public basisFunctions(u: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(2);\r\n    result[0] = 1.0 - u;\r\n    result[1] = u;\r\n    return result;\r\n  }\r\n  /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1.0 - u;\r\n    for (let i = 0; i < n; i++) {\r\n      result[i] = v * polygon[i] + u * polygon[i + n];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** evaluate the blocked derivative at u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctionDerivatives(_u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    for (let i = 0; i < n; i++) {\r\n      result[i] = polygon[i + n] - polygon[i];\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(u: number): number {\r\n    return (1.0 - u) * this.coffs[0] + u * this.coffs[1];\r\n  }\r\n  /** Same as `roots` method but returns single numeric value instead of array. */\r\n  public solve(rightHandSide: number): number | undefined {\r\n    const df = this.coffs[1] - this.coffs[0];\r\n    return Geometry.conditionalDivideFraction(rightHandSide - this.coffs[0], df);\r\n  }\r\n  /**\r\n   * Concrete implementation of the abstract roots method\r\n   * @param targetValue target function value.\r\n   * @param restrictTo01 flag for optional second step to eliminate root outside 0..1.\r\n   * @returns If no roots, return undefined.  If single root, return an array with the root.\r\n   */\r\n  public roots(targetValue: number, restrictTo01: boolean): number[] | undefined {\r\n    const x = this.solve(targetValue);\r\n    if (x === undefined)\r\n      return undefined;\r\n    if (!restrictTo01 || Geometry.isIn01(x))\r\n      return [x];\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/** Bezier polynomial specialized to order 3 (3 coefficients, parabola  function)\r\n * @internal\r\n */\r\nexport class Order3Bezier extends BezierCoffs {\r\n  public constructor(f0: number = 0, f1: number = 0, f2: number = 0) {\r\n    super(3);\r\n    this.coffs[0] = f0;\r\n    this.coffs[1] = f1;\r\n    this.coffs[2] = f2;\r\n  }\r\n  /** Return a deep copy. */\r\n  public clone(): Order3Bezier {\r\n    return new Order3Bezier(this.coffs[0], this.coffs[1], this.coffs[2]);\r\n  }\r\n\r\n  /** evaluate the basis functions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public basisFunctions(u: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(3);\r\n    const v = 1.0 - u;\r\n    result[0] = v * v;\r\n    result[1] = 2.0 * u * v;\r\n    result[2] = u * u;\r\n    return result;\r\n  }\r\n  /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1 - u;\r\n    const b0 = v * v;\r\n    const b1 = 2 * u * v;\r\n    const b2 = u * u;\r\n    for (let i = 0; i < n; i++) {\r\n      result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** evaluate the blocked derivative at u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const f0 = 2 * (1 - u);\r\n    const f1 = 2 * u;\r\n    const n2 = 2 * n;\r\n    for (let i = 0; i < n; i++) {\r\n      const q = polygon[i + n];\r\n      result[i] = f0 * (q - polygon[i]) + f1 * (polygon[i + n2] - q);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Add the square of a linear bezier.\r\n   * @param f0 linear factor value at u=0.\r\n   * @param f1 linear factor value at u=1.\r\n   * @param a  scale factor.\r\n   */\r\n  public addSquareLinear(f0: number, f1: number, a: number) {\r\n    this.coffs[0] += a * f0 * f0;\r\n    this.coffs[1] += a * f0 * f1;\r\n    this.coffs[2] += a * f1 * f1;\r\n  }\r\n  /**\r\n   * Concrete implementation of the abstract roots method\r\n   * @param targetValue target function value.\r\n   * @param restrictTo01 flag for optional second step to eliminate root outside 0..1.\r\n   * @returns If no roots, return undefined.  If roots exist, return as numeric array.\r\n   */\r\n  public roots(targetValue: number, restrictTo01: boolean): number[] | undefined {\r\n    const a0 = this.coffs[0] - targetValue;\r\n    const a1 = this.coffs[1] - targetValue;\r\n    const a2 = this.coffs[2] - targetValue;\r\n    const a01 = a1 - a0;\r\n    const a12 = a2 - a1;\r\n    const a012 = a12 - a01;\r\n    const roots = Degree2PowerPolynomial.solveQuadratic(a012, 2.0 * a01, a0);\r\n    return super.filter01(roots, restrictTo01);\r\n  }\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(u: number): number {\r\n    const v = 1.0 - u;\r\n    return this.coffs[0] * v * v + u * (2.0 * this.coffs[1] * v + this.coffs[2] * u);\r\n  }\r\n}\r\n\r\n/** Bezier polynomial specialized to order 4 (4 coefficients, cubic  function)\r\n * @internal\r\n */\r\nexport class Order4Bezier extends BezierCoffs {\r\n  public constructor(f0: number = 0, f1: number = 0, f2: number = 0, f3: number = 0) {\r\n    super(4);\r\n    this.coffs[0] = f0;\r\n    this.coffs[1] = f1;\r\n    this.coffs[2] = f2;\r\n    this.coffs[3] = f3;\r\n  }\r\n  /** return a deep copy */\r\n  public clone(): Order4Bezier {\r\n    return new Order4Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3]);\r\n  }\r\n  /** Create a product of a quadratic and a cubic. */\r\n  public static createProductOrder3Order2(factorA: Order3Bezier, factorB: Order2Bezier): Order4Bezier {\r\n    return new Order4Bezier(\r\n      factorA.coffs[0] * factorB.coffs[0],\r\n      (factorA.coffs[0] * factorB.coffs[1] + 2.0 * factorA.coffs[1] * factorB.coffs[0]) / 3.0,\r\n      (2.0 * factorA.coffs[1] * factorB.coffs[1] + factorA.coffs[2] * factorB.coffs[0]) / 3.0,\r\n      factorA.coffs[2] * factorB.coffs[1]);\r\n  }\r\n  /** evaluate the basis functions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public basisFunctions(u: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(4);\r\n    const v = 1.0 - u;\r\n    const uu = u * u;\r\n    const vv = v * v;\r\n    result[0] = vv * v;\r\n    result[1] = 3.0 * vv * u;\r\n    result[2] = 3.0 * v * uu;\r\n    result[3] = u * uu;\r\n    return result;\r\n  }\r\n  /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1 - u;\r\n    const uu = u * u;\r\n    const vv = v * v;\r\n    const b0 = v * vv;\r\n    const b1 = 3 * u * vv;\r\n    const b2 = 3 * uu * v;\r\n    const b3 = u * uu;\r\n    for (let i = 0; i < n; i++) {\r\n      result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n] + b3 * polygon[i + 3 * n];\r\n    }\r\n    return result;\r\n  }\r\n  /** evaluate the blocked derivative at u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1 - u;\r\n    // QUADRATIC basis functions applied to differences ... (with factor 3 for derivative)\r\n    const f0 = 3 * (v * v);\r\n    const f1 = 6 * u * v;\r\n    const f2 = 3 * u * u;\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      const q0 = polygon[i];\r\n      const q1 = polygon[i + n];\r\n      const q2 = polygon[i + 2 * n];\r\n      const q3 = polygon[i + 3 * n];\r\n      result[i] = f0 * (q1 - q0) + f1 * (q2 - q1) + f2 * (q3 - q2);\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(u: number): number {\r\n    const v1 = 1.0 - u;\r\n    const v2 = v1 * v1;\r\n    const v3 = v2 * v1;\r\n    return this.coffs[0] * v3\r\n      + u * (3.0 * this.coffs[1] * v2\r\n        + u * (3.0 * this.coffs[2] * v1\r\n          + u * this.coffs[3]));\r\n  }\r\n  /**\r\n   * convert a power polynomial to bezier\r\n   */\r\n  public static createFromDegree3PowerPolynomial(source: Degree3PowerPolynomial): Order4Bezier {\r\n    const f0 = source.evaluate(0.0);\r\n    const d0 = source.evaluateDerivative(0.0);\r\n    const d1 = source.evaluateDerivative(1.0);\r\n    const f1 = source.evaluate(1.0);\r\n    const a = 3.0;\r\n\r\n    return new Order4Bezier(f0, f0 + d0 / a, f1 - d1 / a, f1);\r\n  }\r\n  /** Find real roots, return in caller-allocated array. */\r\n  public realRoots(e: number, restrictTo01: boolean, roots: GrowableFloat64Array) {\r\n    // Get direct solutions in standard basis\r\n    roots.clear();\r\n    const cc = new Float64Array(4);\r\n    const y0 = this.coffs[0];\r\n    const y1 = this.coffs[1];\r\n    const y2 = this.coffs[2];\r\n    const y3 = this.coffs[3];\r\n    const yMax = Math.max(y0, y1, y2, y3);\r\n    const yMin = Math.min(y0, y1, y2, y3);\r\n    const smallValue = Geometry.smallMetricDistance;\r\n    if (yMin > smallValue)\r\n      return undefined;\r\n    if (yMax < -smallValue)\r\n      return undefined;\r\n\r\n    if (yMin >= -smallValue && yMax < smallValue) {\r\n      // all 4 are near zero . ..\r\n      roots.push(0);\r\n      roots.push(1.0 / 3.0);\r\n      roots.push(2.0 / 3.0);\r\n      roots.push(1.0);\r\n      return;  // p(x) == 0 has infinite roots .... return 4, which is a red flag for cubic\r\n    }\r\n    cc[0] = (y0 - e);\r\n    cc[1] = 3.0 * (y1 - y0);\r\n    cc[2] = 3.0 * (y0 - 2.0 * y1 + y2);\r\n    cc[3] = - y0 + 3.0 * y1 - 3.0 * y2 + y3;\r\n    AnalyticRoots.appendCubicRoots(cc, roots);  // can't have zero solutions after passing min/max conditions . . .\r\n    if (restrictTo01)\r\n      roots.reassign(0, 1);\r\n    return;\r\n  }\r\n\r\n}\r\n/** Bezier polynomial specialized to order 5 (5 coefficients, quartic  function)\r\n * @internal\r\n */\r\nexport class Order5Bezier extends BezierCoffs {\r\n  constructor(f0: number = 0, f1: number = 0, f2: number = 0, f3: number = 0, f4: number = 0) {\r\n    super(5);\r\n    this.coffs[0] = f0;\r\n    this.coffs[1] = f1;\r\n    this.coffs[2] = f2;\r\n    this.coffs[3] = f3;\r\n    this.coffs[4] = f4;\r\n  }\r\n  /** Return a deep copy */\r\n  public clone(): Order5Bezier {\r\n    return new Order5Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3], this.coffs[4]);\r\n  }\r\n  /**\r\n   * convert a power polynomial to bezier\r\n   */\r\n  public static createFromDegree4PowerPolynomial(source: Degree4PowerPolynomial): Order5Bezier {\r\n    const f0 = source.evaluate(0.0);\r\n    const d0 = source.evaluateDerivative(0.0);\r\n    const d4 = source.evaluateDerivative(1.0);\r\n    const f4 = source.evaluate(1.0);\r\n    const a = 0.25;\r\n    const d0a = a * d0;\r\n    const fa = f0 + d0a;\r\n    const fm = 2.0 * fa - f0 + source.coffs[2] / 6.0;\r\n    return new Order5Bezier(f0, fa, fm, f4 - d4 * a, f4);\r\n  }\r\n\r\n  /** evaluate the basis functions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public basisFunctions(u: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(5);\r\n    const v = 1.0 - u;\r\n    const uu = u * u;\r\n    const uuu = uu * u;\r\n    const vv = v * v;\r\n    const vvv = vv * v;\r\n    result[0] = vv * vv;\r\n    result[1] = 4.0 * vvv * u;\r\n    result[2] = 6.0 * vv * uu;\r\n    result[3] = 4.0 * v * uuu;\r\n    result[4] = uu * uu;\r\n    return result;\r\n  }\r\n  /** evaluate the basis functions at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1.0 - u;\r\n    const uu = u * u;\r\n    const uuu = uu * u;\r\n    const vv = v * v;\r\n    const vvv = vv * v;\r\n    const b0 = vv * vv;\r\n    const b1 = 4.0 * vvv * u;\r\n    const b2 = 6.0 * vv * uu;\r\n    const b3 = 4.0 * v * uuu;\r\n    const b4 = uu * uu;\r\n    for (let i = 0; i < n; i++) {\r\n      result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n] + b3 * polygon[i + 3 * n] + b4 * polygon[i + 4 * n];\r\n    }\r\n    return result;\r\n  }\r\n  /** evaluate the blocked derivative at u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1 - u;\r\n    // CUBIC basis functions applied to differences ...\r\n    const uu = u * u;\r\n    const vv = v * v;\r\n    const f0 = 4 * v * vv;\r\n    const f1 = 12 * u * vv;\r\n    const f2 = 12 * uu * v;\r\n    const f3 = 4 * u * uu;\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      const q0 = polygon[i];\r\n      const q1 = polygon[i + n];\r\n      const q2 = polygon[i + 2 * n];\r\n      const q3 = polygon[i + 3 * n];\r\n      const q4 = polygon[i + 4 * n];\r\n      result[i] = f0 * (q1 - q0) + f1 * (q2 - q1) + f2 * (q3 - q2) + f3 * (q4 - q3);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(u: number): number {\r\n    const v1 = 1.0 - u;\r\n    const v2 = v1 * v1;\r\n    const v3 = v2 * v1;\r\n    const v4 = v2 * v2;\r\n    return this.coffs[0] * v4\r\n      + u * (4.0 * this.coffs[1] * v3\r\n        + u * (6.0 * this.coffs[2] * v2\r\n          + u * (4.0 * this.coffs[3] * v1\r\n            + u * this.coffs[4])));\r\n  }\r\n  /** Add the product of a pair of Order3Bezier to this one. */\r\n  public addProductOrder3BezierOrder3Bezier(f: Order3Bezier, g: Order3Bezier, a: number) {\r\n    this.coffs[0] += a * f.coffs[0] * g.coffs[0];\r\n    this.coffs[1] += a * (f.coffs[0] * g.coffs[1] + f.coffs[1] * g.coffs[0]) * 0.5;\r\n    this.coffs[2] += a * (f.coffs[0] * g.coffs[2] + 4.0 * f.coffs[1] * g.coffs[1] + f.coffs[2] * g.coffs[0]) / 6.0;\r\n    this.coffs[3] += a * (f.coffs[1] * g.coffs[2] + f.coffs[2] * g.coffs[1]) * 0.5;\r\n    this.coffs[4] += a * f.coffs[2] * g.coffs[2];\r\n  }\r\n  /** Add a constant to all coefficients (thereby adding the constant to the evaluated bezier) */\r\n  public addConstant(a: number): void {\r\n    for (let i = 0; i < 5; i++) this.coffs[i] += a;\r\n  }\r\n  /** Find real roots, return in caller-allocated array. */\r\n  public realRoots(e: number, restrictTo01: boolean, roots: GrowableFloat64Array): void {\r\n    roots.clear();\r\n    const y0 = this.coffs[0] - e;\r\n    const y1 = this.coffs[1] - e;\r\n    const y2 = this.coffs[2] - e;\r\n    const y3 = this.coffs[3] - e;\r\n    const y4 = this.coffs[4] - e;\r\n    // Get direct solutions in standard basis\r\n    const yMax = Math.max(y0, y1, y2, y3, y4);\r\n    const yMin = Math.min(y0, y1, y2, y3, y4);\r\n    const smallValue = Geometry.smallMetricDistance;\r\n    if (yMin > smallValue)\r\n      return undefined;\r\n    if (yMax < -smallValue)\r\n      return undefined;\r\n\r\n    if (yMin >= -smallValue && yMax < smallValue) {\r\n      // all 4 are near zero . ..\r\n      roots.push(0);\r\n      roots.push(0.25);\r\n      roots.push(0.5);\r\n      roots.push(0.75);\r\n      roots.push(1.0);\r\n      return; // p(x) == 0 has infinite roots .... return 5, which is a red flag for cubic ...\r\n    }\r\n\r\n    const cc = new Float64Array(5);\r\n\r\n    cc[0] = (y0 - e);\r\n    cc[1] = 4.0 * (-y0 + y1);\r\n    cc[2] = 6.0 * (y0 - 2.0 * y1 + y2);\r\n    cc[3] = 4.0 * (-y0 + 3.0 * y1 - 3.0 * y2 + y3);\r\n    cc[4] = (y0 - 4.0 * y1 + 6.0 * y2 - 4.0 * y3 + y4);\r\n\r\n    AnalyticRoots.appendQuarticRoots(cc, roots);\r\n    if (restrictTo01)\r\n      roots.reassign(0, 1);\r\n    return;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { GrowableBlockedArray } from \"../geometry3d/GrowableBlockedArray\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n/**\r\n * Blocked array with operations to sort and cluster with a tolerance.\r\n * * Primary sorting is along an \"arbitrary\" sort vector.\r\n * @internal\r\n */\r\nexport class ClusterableArray extends GrowableBlockedArray {\r\n  //  (This is pretty strange)\r\n  // The sort vector is (1,c, c*c, ...)\r\n  // Settint c = 1 makes it 1,1,1 which may be useful for visual scans during debug.\r\n  // c wuith some inobvious digits makes it unlikley tha there will be multiple points on a perpendicular to the sort vector.\r\n  private static readonly _vectorFactor = 0.8732;  // use 1.0 to rig easy tests.\r\n  /** Return a component of the sort vector. */\r\n  public static sortVectorComponent(index: number): number {\r\n    let c = 1.0;\r\n    for (let i = 1; i < index; i++) c *= ClusterableArray._vectorFactor;\r\n    return c;\r\n  }\r\n  private _numCoordinatePerPoint: number;\r\n  private _numExtraDataPerPoint: number;\r\n  /**\r\n   * @param numCoordinatePerPoint number of coordinates per point\r\n   * @param  numExtraDataPerPoint of extra data values per point.\r\n   * @param initialBlockCapacity predicted number of points.  (This does not have to be accurate)\r\n   */\r\n  public constructor(numCoordinatePerPoint: number, numExtraDataPerPoint: number, initialBlockCapacity: number) {\r\n    super(1 + numCoordinatePerPoint + numExtraDataPerPoint, initialBlockCapacity);\r\n    this._numExtraDataPerPoint = numExtraDataPerPoint;\r\n    this._numCoordinatePerPoint = numCoordinatePerPoint;\r\n  }\r\n  /** load a block, placing data[i] at block[i+1] to allow sort coordinate first.\r\n   * @param data array of numDataPerBlock values.\r\n   */\r\n  public addBlock(data: number[]) {\r\n    const i0 = this.newBlockIndex() + 1;\r\n    const n = Math.min(this.numPerBlock - 1, data.length);\r\n    for (let i = 0; i < n; i++)\r\n      this._data[i0 + i] = data[i];\r\n  }\r\n  /** add a block with directly 2 to 5 listed content parameters.\r\n   * This assumes numDataPerPoint is sufficient for the parameters provided.\r\n   */\r\n  public addDirect(x0: number, x1: number, x2?: number, x3?: number, x4?: number) {\r\n    const i0 = this.newBlockIndex();\r\n    this._data[i0 + 1] = x0;\r\n    this._data[i0 + 2] = x1;\r\n    if (x2 !== undefined) this._data[i0 + 3] = x2;\r\n    if (x3 !== undefined) this._data[i0 + 4] = x3;\r\n    if (x4 !== undefined) this._data[i0 + 5] = x4;\r\n  }\r\n\r\n  /** add a block directly from a Point2d with 0 to 3 extras\r\n   * This assumes numDataPerPoint is sufficient for the parameters provided.\r\n   */\r\n  public addPoint2d(xy: Point2d, a?: number, b?: number, c?: number) {\r\n    const i0 = this.newBlockIndex();\r\n    this._data[i0 + 1] = xy.x;\r\n    this._data[i0 + 2] = xy.y;\r\n    if (a !== undefined)\r\n      this._data[i0 + 3] = a;\r\n    if (b !== undefined)\r\n      this._data[i0 + 4] = b;\r\n    if (c !== undefined)\r\n      this._data[i0 + 5] = c;\r\n  }\r\n\r\n  /** add a block with directly from a Point2d with 0 to 3 extras\r\n   * This assumes numDataPerPoint is sufficient for the parameters provided.\r\n   */\r\n  public addPoint3d(xyz: Point3d, a?: number, b?: number, c?: number) {\r\n    const i0 = this.newBlockIndex();\r\n    this._data[i0 + 1] = xyz.x;\r\n    this._data[i0 + 2] = xyz.y;\r\n    this._data[i0 + 3] = xyz.z;\r\n    if (a !== undefined)\r\n      this._data[i0 + 4] = a;\r\n    if (b !== undefined)\r\n      this._data[i0 + 5] = b;\r\n    if (c !== undefined)\r\n      this._data[i0 + 6] = c;\r\n  }\r\n  /** Get the xy coordinates by point index. */\r\n  public getPoint2d(blockIndex: number, result?: Point2d): Point2d {\r\n    const i0 = this.blockIndexToDoubleIndex(blockIndex);\r\n    return Point2d.create(this._data[i0 + 1], this._data[i0 + 2], result);\r\n  }\r\n  /** Get the xyZ coordinates by point index. */\r\n  public getPoint3d(blockIndex: number, result?: Point3d): Point3d {\r\n    const i0 = this.blockIndexToDoubleIndex(blockIndex);\r\n    return Point3d.create(this._data[i0 + 1], this._data[i0 + 2], this._data[i0 + 3], result);\r\n  }\r\n  /** Return a single extra data value */\r\n  public getExtraData(blockIndex: number, i: number): number {\r\n    const i0 = this.blockIndexToDoubleIndex(blockIndex);\r\n    return this._data[i0 + 1 + this._numCoordinatePerPoint + i];\r\n  }\r\n  /** Return a single data value */\r\n  public getData(blockIndex: number, i: number): number {\r\n    const i0 = this.blockIndexToDoubleIndex(blockIndex);\r\n    return this._data[i0 + i];\r\n  }\r\n\r\n  /** Set a single extra data value */\r\n  public setExtraData(blockIndex: number, i: number, value: number): void {\r\n    const i0 = this.blockIndexToDoubleIndex(blockIndex);\r\n    this._data[i0 + 1 + this._numCoordinatePerPoint + i] = value;\r\n  }\r\n\r\n  /** this value is used as cluster terminator in the Uint232rray of indcies. */\r\n  public static readonly clusterTerminator = 0xFFffFFff;\r\n  /** Test if `x` is the cluster terminator value. */\r\n  public static isClusterTerminator(x: number): boolean { return x === ClusterableArray.clusterTerminator; }\r\n  /** Return an array giving clusters of blocks with similar coordinates.\r\n   *\r\n   * * The contents of each block is assumed to be set up so the primary sort coordinate is first.\r\n   *\r\n   * ** simple coordinate blocks (x,y) or (x,y,z) would work fine but have occasional performance problems because points with same x would generate big blocks of\r\n   * candidates for clusters.\r\n   * ** The usual solution is to u value which is a dot product along some skew direction and have the blocks contain (u,x,y) or (u,x,y,z) for 2d versus 3d.\r\n   * ** apply setupPrimaryClusterSort to prepare that!!!\r\n   * * After a simple lexical sort, consecutive blocks that are within tolerance in the 0 component\r\n   * are inspected.  Within that candidate set, all blocks that are within tolerance for ALL components are clustered.\r\n   * * In the output cluster array, clusters are terminated a invalid index. Test for the invalid index with GrowableBlockArray.isClusterTerminator (x)\r\n   */\r\n  public clusterIndicesLexical(clusterTolerance: number = Geometry.smallMetricDistance): Uint32Array {\r\n    // install primary sort key\r\n    this.setupPrimaryClusterSort();\r\n    // presort by all coordinates ....\r\n    const firstSort = this.sortIndicesLexical();\r\n    const clusterIndices = new Uint32Array(2 * firstSort.length);  // worst case: no duplicates, each index goes in followed by terminator.\r\n    let m = 0;  // number of cluster indices\r\n    const n = this.numBlocks; // and this must match firstSort.length !!\r\n    let clusterStartBlockIndex = 0;\r\n    let candidateBlockIndex = 0;\r\n    let barrierU = 0.0;\r\n    let i = 0;\r\n    let j = 0;\r\n\r\n    const k0 = 1;   // beginning of active column for distance\r\n    const k1 = 1 + this._numCoordinatePerPoint;\r\n    for (i = 0; i < n; i++) {\r\n      clusterStartBlockIndex = firstSort[i];\r\n      if (!ClusterableArray.isClusterTerminator(clusterStartBlockIndex)) {\r\n        // unused block, so it becomes a cluster...\r\n        clusterIndices[m++] = clusterStartBlockIndex;\r\n        barrierU = this.component(clusterStartBlockIndex, 0) + clusterTolerance;\r\n        firstSort[i] = ClusterableArray.clusterTerminator;\r\n        for (j = i + 1; j < n; j++) {\r\n          candidateBlockIndex = firstSort[j];\r\n          if (candidateBlockIndex === ClusterableArray.clusterTerminator) continue; // nearby in sort direction but already in a cluster.\r\n          if (this.component(candidateBlockIndex, 0) >= barrierU) break;\r\n          if (this.distanceBetweenSubBlocks(clusterStartBlockIndex, candidateBlockIndex, k0, k1) < clusterTolerance) {\r\n            clusterIndices[m++] = candidateBlockIndex;            // The candidate is in the block\r\n            firstSort[j] = ClusterableArray.clusterTerminator;  // and it will not be reused as future block base\r\n          }\r\n        }\r\n        clusterIndices[m++] = ClusterableArray.clusterTerminator;\r\n      }\r\n    }\r\n    // Alas, the clusterIndices array has fluff at the end.  So it has to be copied.\r\n    return clusterIndices.slice(0, m);\r\n  }\r\n  /** setup (overwrite!!) the \"0\" component with the dot product of numClusterCoordinate later components with a non-axis aligned vector.\r\n   * This is normally called before clusterIndicesLexical.\r\n   */\r\n  public setupPrimaryClusterSort() {\r\n    const nb = this.numBlocks;\r\n    const nc = this._numCoordinatePerPoint;\r\n    const vector = new Float64Array(nc);\r\n    vector[0] = 1.0;\r\n    for (let c = 1; c < nc; c++) vector[c] = vector[c - 1] * ClusterableArray._vectorFactor;\r\n    let k = 0;\r\n    let dot = 0.0;\r\n    const data = this._data;\r\n    for (let b = 0; b < nb; b++) {\r\n      k = this.blockIndexToDoubleIndex(b);\r\n      dot = 0.0;\r\n      for (let c = 0; c < nc; c++) { dot += vector[c] * data[k + 1 + c]; }\r\n      data[k] = dot;\r\n    }\r\n  }\r\n  /** Convert the cluster data to an array of tuples with point i in the form\r\n   * `[i, primarySortCoordinate, [x,y,..], [extraData0, extraData1, ...]]`\r\n   */\r\n  public toJSON(): any[] {\r\n    const result: any[] = [];\r\n    for (let b = 0; b < this.numBlocks; b++) {\r\n      let i = this.blockIndexToDoubleIndex(b);\r\n      const chunk: any[] = [b, this._data[i++]];\r\n      const coordinates = [];\r\n      for (let c = 0; c < this._numCoordinatePerPoint; c++)coordinates.push(this._data[i++]);\r\n      chunk.push(coordinates);\r\n      for (let c = 0; c < this._numExtraDataPerPoint; c++)\r\n        chunk.push(this._data[i++]);\r\n      result.push(chunk);\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Return an array of indices from block index to cluster index.\r\n   * @param clusteredBlocks clusters of block indices followed by separators.\r\n   */\r\n  public createIndexBlockToClusterIndex(clusteredBlocks: Uint32Array): Uint32Array {\r\n    const numBlocks = this.numBlocks;\r\n    const blockToCluster = new Uint32Array(numBlocks);\r\n    blockToCluster.fill(ClusterableArray.clusterTerminator);\r\n    let numCluster = 0;\r\n    for (const b of clusteredBlocks) {\r\n      if (b >= numBlocks) {\r\n        numCluster++;\r\n      } else {\r\n        blockToCluster[b] = numCluster;\r\n      }\r\n    }\r\n    return blockToCluster;\r\n  }\r\n  /**\r\n   * Return an array of indices from block index to index of its cluster's start in the cluster index array.\r\n   * @param clusteredBlocks clusters of block indices followed by separators.\r\n   */\r\n  public createIndexBlockToClusterStart(clusteredBlocks: Uint32Array): Uint32Array {\r\n    const n = clusteredBlocks.length;\r\n    const numBlocks = this.numBlocks;\r\n    const blockToClusterStart = new Uint32Array(numBlocks);\r\n    const terminator = ClusterableArray.clusterTerminator;\r\n    blockToClusterStart.fill(terminator);\r\n    let clusterStart = 0;\r\n    for (let i = 0; i < n; i++) {\r\n      const k = clusteredBlocks[i];\r\n      if (k > numBlocks) {\r\n        clusterStart = i + 1;\r\n      } else {\r\n        blockToClusterStart[k] = clusterStart;\r\n      }\r\n    }\r\n    return blockToClusterStart;\r\n  }\r\n  /** count the clusters in the clusteredBlocks array. */\r\n  public countClusters(clusteredBlocks: Uint32Array): number {\r\n    let numClusters = 0;\r\n    const terminator = ClusterableArray.clusterTerminator;\r\n    for (const b of clusteredBlocks) {\r\n      if (b === terminator)\r\n        numClusters++;\r\n    }\r\n    return numClusters;\r\n  }\r\n  /** create a reverse index: given a cluster index k, clusterToClusterStart[k] is the place\r\n   * the cluster's block indices appear in clusterBlocks\r\n   */\r\n  public createIndexClusterToClusterStart(clusteredBlocks: Uint32Array): Uint32Array {\r\n    let numCluster = this.countClusters(clusteredBlocks);\r\n    const clusterToClusterStart = new Uint32Array(numCluster);\r\n    const terminator = ClusterableArray.clusterTerminator;\r\n    clusterToClusterStart.fill(terminator);\r\n    const n = clusteredBlocks.length;\r\n    let clusterStart = 0;\r\n    for (let i = 0; i < n; i++) {\r\n      const k = clusteredBlocks[i];\r\n      if (k === terminator) {\r\n        clusterStart = i + 1;\r\n      } else if (i === clusterStart) {\r\n        clusterToClusterStart[numCluster++] = clusterStart;\r\n      }\r\n    }\r\n    return clusterToClusterStart;\r\n  }\r\n\r\n  /**\r\n   * Sort terminator-delimited subsets of an array of indices into the table, using a single extraData index as sort key.\r\n   * @param blockedIndices [in] indices, organized as blocks of good indices terminated by the clusterTerminator.\r\n   * @param extraDataIndex index of the extra data key.\r\n   */\r\n  public sortSubsetsBySingleKey(blockedIndices: Uint32Array, dataIndex: number) {\r\n    const dataOffset = 1 + dataIndex;\r\n    let kBegin = 0;\r\n    let swap;\r\n    let key0, key1;\r\n    const numK = blockedIndices.length;\r\n    for (let kEnd = 0; kEnd < numK; kEnd++) {\r\n      if (blockedIndices[kEnd] === ClusterableArray.clusterTerminator) {\r\n        // sort blockedIndices[kBegin ,= k < kEnd].\r\n        //  (search for minimum remaining, swap  . . )\r\n        for (let k0 = kBegin; k0 + 1 < kEnd; k0++) {\r\n          key0 = this.getWithinBlock(blockedIndices[k0], dataOffset);\r\n          for (let k1 = k0 + 1; k1 < kEnd; k1++) {\r\n            key1 = this.getWithinBlock(blockedIndices[k1], dataOffset);\r\n            if (key1 < key0) {\r\n              swap = blockedIndices[k0];\r\n              blockedIndices[k0] = blockedIndices[k1];\r\n              blockedIndices[k1] = swap;\r\n              key0 = key1;\r\n            }\r\n          }\r\n        }\r\n        kBegin = kEnd + 1;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Returns packed points with indices mapping old to new.\r\n   * @param data points to cluster.\r\n   */\r\n  public static clusterPoint3dArray(data: Point3d[], tolerance: number = Geometry.smallMetricDistance):\r\n    PackedPointsWithIndex {\r\n    const clusterArray = new ClusterableArray(3, 0, data.length);\r\n    data.forEach((p: Point3d) => {\r\n      clusterArray.addDirect(p.x, p.y, p.z);\r\n    });\r\n    const order = clusterArray.clusterIndicesLexical(tolerance);\r\n    const result = new PackedPointsWithIndex(data.length);\r\n    let currentClusterIndex = 0;\r\n    let numThisCluster = 0;\r\n    order.forEach((k: number) => {\r\n      if (ClusterableArray.isClusterTerminator(k)) {\r\n        currentClusterIndex++;\r\n        numThisCluster = 0;\r\n      } else {\r\n        if (numThisCluster === 0)\r\n          result.packedPoints.push(data[k].clone());\r\n        result.oldToNew[k] = currentClusterIndex;\r\n        numThisCluster++;\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns packed points with indices mapping old to new.\r\n   * @param data points to cluster.\r\n   */\r\n  public static clusterGrowablePoint3dArray(source: GrowableXYZArray, tolerance: number = Geometry.smallMetricDistance):\r\n    PackedPointsWithIndex {\r\n    const clusterArray = new ClusterableArray(3, 0, source.length);\r\n    const p = Point3d.create();\r\n    const numSourcePoint = source.length;\r\n    for (let i = 0; i < numSourcePoint; i++) {\r\n      source.getPoint3dAtUncheckedPointIndex(i, p);\r\n      clusterArray.addDirect(p.x, p.y, p.z);\r\n    }\r\n    const order = clusterArray.clusterIndicesLexical(tolerance);\r\n    const result = new PackedPointsWithIndex(source.length);\r\n    const numPackedPoints = clusterArray.countClusters(order);\r\n    result.growablePackedPoints = new GrowableXYZArray(numPackedPoints);\r\n    let currentClusterIndex = 0;\r\n    let numThisCluster = 0;\r\n    order.forEach((k: number) => {\r\n      if (ClusterableArray.isClusterTerminator(k)) {\r\n        currentClusterIndex++;\r\n        numThisCluster = 0;\r\n      } else {\r\n        if (numThisCluster === 0) // This is the first encounter with a new cluster\r\n          result.growablePackedPoints!.pushFromGrowableXYZArray(source, k);\r\n        result.oldToNew[k] = currentClusterIndex;\r\n        numThisCluster++;\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n}\r\n/**\r\n * Data carrier class for\r\n * * packedPoints = an array of Point3d\r\n * * oldToNew = array of indices from some prior Point3d[] to the packed points.\r\n * @internal\r\n */\r\nclass PackedPointsWithIndex {\r\n  /** Array of Point3d */\r\n  public packedPoints: Point3d[];\r\n  /** array of coordinates packed in GrowableXYZArray  */\r\n  public growablePackedPoints: GrowableXYZArray | undefined;\r\n  /** mapping from old point index to new ponit index. */\r\n  public oldToNew: Uint32Array;\r\n  /** integer value for unknown index. */\r\n  public static readonly invalidIndex = 0xFFFFffff;\r\n\r\n  /** construct a PackedPoints object with\r\n   * * empty packedPoints array\r\n   * * oldToNew indices all initialized to PackedPoints.invalidIndex\r\n   */\r\n  constructor(numOldIndexEntry: number) {\r\n    this.packedPoints = [];\r\n    this.oldToNew = new Uint32Array(numOldIndexEntry);\r\n    for (let i = 0; i < numOldIndexEntry; i++) {\r\n      this.oldToNew[i] = PackedPointsWithIndex.invalidIndex;\r\n    }\r\n  }\r\n  /**\r\n   * Use the oldToNew array to update an array of \"old\" indices.\r\n   * @param indices array of indices into prepacked array.\r\n   * @returns true if all input indices were valid for the oldToNew array.\r\n   */\r\n  public updateIndices(indices: number[]): boolean {\r\n    let numErrors = 0;\r\n    indices.forEach((value: number, i: number, data: number[]) => {\r\n      if (value < this.oldToNew.length) {\r\n        data[i] = this.oldToNew[value];\r\n      } else numErrors++;\r\n    });\r\n    return numErrors === 0;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Numerics */\r\nimport { BeJSONFunctions, Geometry } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\n/**\r\n * OPerations on a \"complex number\" class with real part `x` and complex part `y`\r\n * @internal\r\n */\r\nexport class Complex implements BeJSONFunctions {\r\n  private _x: number;\r\n  /** (propety set) Real part */\r\n  set x(value: number) { this._x = value; }\r\n  /** (propety get) Real part */\r\n  get x(): number { return this._x; }\r\n\r\n  private _y: number;\r\n  /** (propety set) Imaginary part */\r\n  set y(value: number) { this._y = value; }\r\n  /** (propety get) Imaginary part */\r\n  get y(): number { return this._y; }\r\n\r\n  public constructor(x: number = 0, y: number = 0) { this._x = x; this._y = y; }\r\n  /** set x and y parts from args. */\r\n  public set(x: number = 0, y: number = 0): void { this.x = x; this.y = y; }\r\n  /** set `this.x` and `this.y` from `other.x` and `other.y` */\r\n  public setFrom(other: Complex) { this.x = other.x; this.y = other.y; }\r\n  /** clone the complex x,y */\r\n  public clone(): Complex { return new Complex(this.x, this.y); }\r\n  /** test for near equality using coordinate tolerances */\r\n  public isAlmostEqual(other: Complex): boolean { return Geometry.isAlmostEqualNumber(this.x, other.x) && Geometry.isAlmostEqualNumber(this.x, other.x); }\r\n  /** Create a new Complex instance from given x and y. */\r\n  public static create(x: number = 0, y: number = 0, result?: Complex): Complex {\r\n    if (result) {\r\n      result.x = x;\r\n      result.y = y;\r\n      return result;\r\n    }\r\n    return new Complex(x, y);\r\n  }\r\n  /** Return the complex sum `this+other` */\r\n  public plus(other: Complex, result?: Complex): Complex { return Complex.create(this.x + other.x, this.y + other.y, result); }\r\n  /** Return the complex difference  `this-other` */\r\n  public minus(other: Complex, result?: Complex): Complex { return Complex.create(this.x - other.x, this.y - other.y, result); }\r\n  /** Return the complex product  `this * other` */\r\n  public times(other: Complex, result?: Complex): Complex {\r\n    return Complex.create(\r\n      this.x * other.x - this.y * other.y,\r\n      this.x * other.y + this.y * other.x,\r\n      result);\r\n  }\r\n  /** Return the complex product `this * x+i*y`. That is, the second Complex value exists via the args without being formally created as an instance. */\r\n  public timesXY(x: number, y: number, result?: Complex): Complex {\r\n    return Complex.create(\r\n      this.x * x - this.y * y,\r\n      this.x * y + this.y * x,\r\n      result);\r\n  }\r\n  /** Return the mangitude of the complex number */\r\n  public magnitude(): number { return Geometry.hypotenuseXY(this.x, this.y); }\r\n  /** Return the angle from x axis to the vector (x,y) */\r\n  public angle(): Angle { return Angle.createAtan2(this.y, this.x); }\r\n  /** Return the xy plane distance between this and other */\r\n  public distance(other: Complex) {\r\n    return Geometry.hypotenuseXY(this.x - other.x, this.y - other.y);\r\n  }\r\n  /** Return the squared xy plane distance between this and other. */\r\n  public magnitudeSquared(): number { return this.x * this.x + this.y * this.y; }\r\n  /** Return the complex division `this / other` */\r\n  public divide(other: Complex, result?: Complex): Complex | undefined {\r\n    const bb = other.magnitudeSquared();\r\n    if (bb === 0.0)\r\n      return undefined;\r\n    const divbb = 1.0 / bb;\r\n    return Complex.create(\r\n      (this.x * other.x + this.y * other.y) * divbb,\r\n      (this.y * other.x - this.x * other.y) * divbb,\r\n      result);\r\n  }\r\n  /** Return the complex square root of this. */\r\n  public sqrt(result?: Complex): Complex {\r\n    if ((this.x === 0.0) && (this.y === 0.0))\r\n      return Complex.create(0, 0, result);\r\n\r\n    const x = Math.abs(this.x);\r\n    const y = Math.abs(this.y);\r\n    let r = 0;\r\n    let w = 0;\r\n    if (x >= y) {\r\n      r = y / x;\r\n      w = Math.sqrt(x) * Math.sqrt(0.5 * (1.0 + Math.sqrt(1.0 + r * r)));\r\n    } else {\r\n      r = x / y;\r\n      w = Math.sqrt(y) * Math.sqrt(0.5 * (r + Math.sqrt(1.0 + r * r)));\r\n    }\r\n\r\n    if (this.x >= 0.0) {\r\n      return Complex.create(w, this.y / (2.0 * w), result);\r\n    } else {\r\n      const y1 = (this.y >= 0) ? w : -w;\r\n      return Complex.create(this.y / (2.0 * y1), y1, result);\r\n    }\r\n  }\r\n  /** set the complex x,y from a json object of the form like\r\n   * * x,y key value pairs:   `{x:1,y:2}`\r\n   * * array of numbers:  `[1,2]`\r\n   */\r\n  public setFromJSON(json?: any): void {\r\n    if (Array.isArray(json) && json.length > 1) {\r\n      this.set(json[0], json[1]);\r\n    } else if (json && json.x && json.y) {\r\n      this.set(json.x, json.y);\r\n    } else {\r\n      this.set(0, 0);\r\n    }\r\n  }\r\n  /** Create a `Complex` instance from a json object. */\r\n  public static fromJSON(json?: any): Complex { const result = new Complex(); result.setFromJSON(json); return result; }\r\n\r\n  /**\r\n   * Convert an Complex to a JSON object.\r\n   * @return {*} [x,y]\r\n   */\r\n  public toJSON(): any { return [this.x, this.y]; }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Range1d } from \"../geometry3d/Range\";\r\nimport { Geometry } from \"../Geometry\";\r\n/**\r\n * Ray with xy origin and direction\r\n * @internal\r\n */\r\nexport class Ray2d {\r\n  private _origin: Point2d;\r\n  private _direction: Vector2d;\r\n\r\n  private constructor(origin: Point2d, direction: Vector2d) {\r\n    this._origin = origin;\r\n    this._direction = direction;\r\n  }\r\n  /** Create from 2d `origin` and `target`.\r\n   * * `target - origin` is the direction vector.\r\n   */\r\n  public static createOriginAndTarget(origin: Point2d, target: Point2d): Ray2d {\r\n    return new Ray2d(origin.clone(), origin.vectorTo(target));\r\n  }\r\n  /** Create from (clones of) `origin` point and `direction` vector */\r\n  public static createOriginAndDirection(origin: Point2d, direction: Vector2d): Ray2d {\r\n    return new Ray2d(origin.clone(), direction.clone());\r\n  }\r\n  /** Capture `origin` and `direction` as ray member variables. */\r\n  public static createOriginAndDirectionCapture(origin: Point2d, direction: Vector2d): Ray2d {\r\n    return new Ray2d(origin, direction);\r\n  }\r\n  /** Get the (REFERENCE TO) the ray origin. */\r\n  public get origin() { return this._origin; }\r\n  /** Get the (REFERENCE TO) the ray direction. */\r\n  public get direction() { return this._direction; }\r\n\r\n  /**\r\n   *  Return a ray that is parallel at distance to the left, specified as fraction of the ray's direction vector.\r\n   */\r\n  public parallelRay(leftFraction: number): Ray2d {\r\n    return new Ray2d(this._origin.addForwardLeft(0.0, leftFraction, this._direction), this._direction);\r\n  }\r\n  /** Return a ray with same origin, direction rotated 90 degrees counterclockwise */\r\n  public ccwPerpendicularRay(): Ray2d {\r\n    return new Ray2d(this._origin, this._direction.rotate90CCWXY());\r\n  }\r\n\r\n  /** Return a ray with same origin, direction rotated 90 degrees clockwise */\r\n  public cwPerpendicularRay(): Ray2d {\r\n    return new Ray2d(this._origin, this._direction.rotate90CWXY());\r\n  }\r\n  /** Normalize the direction vector in place. */\r\n  public normalizeDirectionInPlace(): boolean {\r\n    if (this._direction.normalize(this._direction)) {\r\n      return true;\r\n    } else {\r\n      this._direction.x = 1.0;\r\n      this._direction.y = 0.0;\r\n      // magnitude = 0.0;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Intersect this ray (ASSUMED NORMALIZED) with unbounded line defined by points.\r\n   *  (The normalization assumption affects test for parallel vectors.)\r\n   *  Fraction and dHds passed as number[] to use by reference... Sticking to return of true and false in the case fraction is zero after\r\n   *  a true safe divide\r\n   */\r\n  public intersectUnboundedLine(linePointA: Point2d, linePointB: Point2d, fraction: number[], dHds: number[]): boolean {\r\n    const lineDirection = linePointA.vectorTo(linePointB);\r\n    const vector0 = linePointA.vectorTo(this._origin);\r\n    const h0 = vector0.crossProduct(lineDirection);\r\n    dHds[0] = this._direction.crossProduct(lineDirection);\r\n    // h = h0 + s * dh\r\n    const ff = Geometry.conditionalDivideFraction(-h0, dHds[0]);\r\n    if (ff !== undefined) {\r\n      fraction[0] = ff;\r\n      return true;\r\n    } else {\r\n      fraction[0] = 0.0;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /** return the ray fraction where point projects to the ray */\r\n  public projectionFraction(point: Point2d): number {\r\n    return this._origin.vectorTo(point).fractionOfProjectionToVector(this._direction);\r\n  }\r\n\r\n  /** return the fraction of projection to the perpendicular ray */\r\n  public perpendicularProjectionFraction(point: Point2d): number {\r\n    const uv = this._direction.crossProduct(this._origin.vectorTo(point));\r\n    const uu = this._direction.magnitudeSquared();\r\n    // Want zero returned if failure case, not undefined\r\n    return Geometry.safeDivideFraction(uv, uu, 0.0);\r\n  }\r\n\r\n  /** Return point from origin plus a scaled vector */\r\n  public fractionToPoint(f: number): Point2d {\r\n    return this._origin.plusScaled(this._direction, f);\r\n  }\r\n}\r\n/**\r\n * Convex hull of points in 2d.\r\n * @internal\r\n */\r\nexport class ConvexPolygon2d {\r\n  // hull points in CCW order, WITHOUT final duplicate...\r\n  private _hullPoints: Point2d[];\r\n\r\n  constructor(points: Point2d[]) {\r\n    this._hullPoints = [];\r\n    // Deep copy of points array given\r\n    for (const point of points) {\r\n      this._hullPoints.push(point);\r\n    }\r\n  }\r\n\r\n  /** Create the hull */\r\n  public static createHull(points: Point2d[]): ConvexPolygon2d {\r\n    return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));\r\n  }\r\n\r\n  /** Create the hull. First try to use the points as given. */\r\n  public static createHullIsValidCheck(points: Point2d[]) {\r\n    if (ConvexPolygon2d.isValidConvexHull(points))\r\n      return new ConvexPolygon2d(points);\r\n    else\r\n      return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));\r\n  }\r\n\r\n  /** Return a reference of the hull points. */\r\n  public get points(): Point2d[] {\r\n    return this._hullPoints;\r\n  }\r\n\r\n  /** Test if hull points are a convex, CCW polygon */\r\n  public static isValidConvexHull(points: Point2d[]) {\r\n    if (points.length < 3)\r\n      return false;\r\n    const n = points.length;\r\n    for (let i = 0; i < n; i++) {\r\n      const i1 = (i + 1) % n;\r\n      const i2 = (i + 2) % n;\r\n      if (points[i].crossProductToPoints(points[i1], points[i2]) < 0.0)\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Return true if the convex hull (to the left of the edges) contains the test point */\r\n  public containsPoint(point: Point2d): boolean {\r\n    let xy0 = this._hullPoints[this._hullPoints.length - 1];\r\n    // double tol = -1.0e-20;  negative tol!!\r\n    for (const i of this._hullPoints) {\r\n      const xy1 = i;\r\n      const c = xy0.crossProductToPoints(xy1, point);\r\n      if (c < 0.0)\r\n        return false;\r\n      xy0 = i;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Return the largest outside. (return 0 if in or on) */\r\n  public distanceOutside(xy: Point2d): number {\r\n    let maxDistance = 0.0;\r\n    const n = this._hullPoints.length;\r\n    let xy0 = this._hullPoints[n - 1];\r\n    // double tol = -1.0e-20;  // negative tol!!\r\n    for (let i = 0; i < n; i++) {\r\n      const xy1 = this._hullPoints[i];\r\n      const c = xy0.crossProductToPoints(xy1, xy);\r\n      if (c < 0.0) {\r\n        const ray = Ray2d.createOriginAndTarget(xy0, xy1);\r\n        const s = ray.projectionFraction(xy);\r\n        let d = 0.0;\r\n        if (s < 0.0)\r\n          d = xy0.distance(xy);\r\n        else if (s > 1.0)\r\n          d = xy1.distance(xy);\r\n        else\r\n          d = xy.distance(ray.fractionToPoint(s));\r\n\r\n        if (d > maxDistance)\r\n          maxDistance = d;\r\n      }\r\n      xy0 = this._hullPoints[i];\r\n    }\r\n    return maxDistance;\r\n  }\r\n\r\n  /** Offset the entire hull (in place) by distance.\r\n   * Returns false if an undefined occurred from normalizing (could occur after changing some hull points already)\r\n   */\r\n  public offsetInPlace(distance: number): boolean {\r\n    const n = this._hullPoints.length;\r\n    if (n >= 3) {\r\n      const hullPoint0 = this._hullPoints[0];\r\n      let edgeA: Vector2d | undefined = this._hullPoints[n - 1].vectorTo(hullPoint0);\r\n      edgeA = edgeA.normalize();\r\n      if (edgeA === undefined) { return false; }\r\n\r\n      let perpA = edgeA.rotate90CWXY();\r\n      let edgeB: Vector2d | undefined;\r\n      let perpB: Vector2d;\r\n      for (let i = 0; i < n; i++) {\r\n        const j = i + 1;\r\n        edgeB = this._hullPoints[i].vectorTo(j < n ? this._hullPoints[j] : hullPoint0);\r\n        edgeB = edgeB.normalize();\r\n        if (edgeB === undefined) { return false; }\r\n\r\n        perpB = edgeB.rotate90CWXY();\r\n        const offsetBisector = Vector2d.createOffsetBisector(perpA, perpB, distance);\r\n        if (offsetBisector === undefined) { return false; }\r\n\r\n        this._hullPoints[i] = this._hullPoints[i].plus(offsetBisector);\r\n        // PerpA takes up reference to perpB, as perpB will die in new iteration\r\n        perpA = perpB;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Return 2 distances bounding the intersection of the ray with a convex hull.\r\n   * ASSUME (for tolerance) the ray has normalized direction vector.\r\n   * Both negative and positive distances along the ray are possible.\r\n   * Returns range with extremities if less than 3 points, distanceA > distanceB, or if cross product < 0\r\n   */\r\n  public clipRay(ray: Ray2d): Range1d {\r\n    let distanceA = - Number.MAX_VALUE;\r\n    let distanceB = Number.MAX_VALUE;\r\n\r\n    const n = this._hullPoints.length;\r\n\r\n    if (n < 3)\r\n      return Range1d.createNull();\r\n\r\n    let xy0 = this._hullPoints[n - 1];\r\n    for (const xy1 of this._hullPoints) {\r\n      const distance: number[] = [];\r\n      const dHds: number[] = [];\r\n      if (ray.intersectUnboundedLine(xy0, xy1, distance, dHds)) {\r\n        if (dHds[0] > 0.0) {\r\n          if (distance[0] < distanceB)\r\n            distanceB = distance[0];\r\n        } else {\r\n          if (distance[0] > distanceA)\r\n            distanceA = distance[0];\r\n        }\r\n        if (distanceA > distanceB)\r\n          return Range1d.createNull();\r\n      } else {\r\n        // ray is parallel to the edge.\r\n        // Any single point out classifies it all . ..\r\n        if (xy0.crossProductToPoints(xy1, ray.origin) < 0.0)\r\n          return Range1d.createNull();\r\n      }\r\n\r\n      // xy1 is reassigned with each new loop\r\n      xy0 = xy1;\r\n    }\r\n    const range = Range1d.createNull();\r\n    range.extendX(distanceA);\r\n    range.extendX(distanceB);\r\n    return range;\r\n  }\r\n\r\n  /** Return the range of (fractional) ray positions for projections of all points from the arrays. */\r\n  public rangeAlongRay(ray: Ray2d): Range1d {\r\n    const range = Range1d.createNull();\r\n    for (const xy1 of this._hullPoints)\r\n      range.extendX(ray.projectionFraction(xy1));\r\n    return range;\r\n  }\r\n\r\n  /** Return the range of (fractional) ray positions for projections of all points from the arrays. */\r\n  public rangePerpendicularToRay(ray: Ray2d): Range1d {\r\n    const range = Range1d.createNull();\r\n    for (const xy1 of this._hullPoints)\r\n      range.extendX(ray.perpendicularProjectionFraction(xy1));\r\n    return range;\r\n  }\r\n\r\n  /** Computes the hull of a convex polygon from points given. Returns the hull as a new Point2d array.\r\n   *  Returns an empty hull if less than 3 points are given.\r\n   */\r\n  public static computeConvexHull(points: Point2d[]): Point2d[] {\r\n    const hull: Point2d[] = [];\r\n    const n = points.length;\r\n    if (n < 3)\r\n      return hull;\r\n    // Get deep copy\r\n    const xy1: Point2d[] = points.slice(0, n);\r\n    xy1.sort(Geometry.lexicalXYLessThan);\r\n    hull.push(xy1[0]); // This is sure to stay\r\n    hull.push(xy1[1]); // This one can be removed in loop.\r\n\r\n    // First sweep creates upper hull\r\n    for (let i = 2; i < n; i++) {\r\n      const candidate = xy1[i];\r\n      let top = hull.length - 1;\r\n      while (top > 0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {\r\n        top--;\r\n        hull.pop();\r\n      }\r\n      hull.push(candidate);\r\n    }\r\n\r\n    // Second sweep creates lower hull right to left\r\n    const i0 = hull.length - 1;\r\n    // xy1.back () is already on stack.\r\n    hull.push(xy1[n - 2]);\r\n    for (let i = n - 2; i-- > 0;) {\r\n      const candidate = xy1[i];\r\n      let top = hull.length - 1;\r\n      while (top > i0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {\r\n        top--;\r\n        hull.pop();\r\n      }\r\n      if (i > 0) // don't replicate start point!!!\r\n        hull.push(candidate);\r\n    }\r\n\r\n    return hull;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { SmallSystem } from \"./Polynomials\";\r\n/** base class for Newton iterations in various dimensions.\r\n * Dimension-specific classes carry all dimension-related data and answer generalized queries\r\n * from this base class.\r\n * @internal\r\n */\r\nexport abstract class AbstractNewtonIterator {\r\n  /** Compute a step.  The current x and function values must be retained for use in later method calls */\r\n  public abstract computeStep(): boolean;\r\n  /** return the current step size, scaled for use in tolerance tests.\r\n   * * This is a single number, typically the max of various per-dimension `dx / (1+x)` for the x and dx of that dimension.\r\n   */\r\n  public abstract currentStepSize(): number;\r\n  /**\r\n   * Apply the current step (in all dimensions)\r\n   * @param isFinalStep true if this is a final step.\r\n   */\r\n  public abstract applyCurrentStep(isFinalStep: boolean): boolean;\r\n  /**\r\n   * @param stepSizeTarget tolerance to consider a single step converged.\r\n   * This number should be \"moderately\" strict.   Because 2 successive convergences are required,\r\n   * it is expected that a first \"accept\" for (say) 10 to 14 digit step will be followed by another\r\n   * iteration.   A well behaved newton would then hypothetically double the number of digits to\r\n   * 20 to 28.  Since the IEEE double only carries 16 digits, this second-convergence step will\r\n   * typically achieve full precision.\r\n   * @param successiveConvergenceTarget number of successive convergences required for acceptance.\r\n   * @param maxIterations max number of iterations.   A typical newton step converges in 3 to 6 iterations.\r\n   *     Allow 15 to 20 to catch difficult cases.\r\n   */\r\n  protected constructor(\r\n    stepSizeTolerance: number = 1.0e-11,\r\n    successiveConvergenceTarget: number = 2,\r\n    maxIterations: number = 15) {\r\n    this._stepSizeTolerance = stepSizeTolerance;\r\n    this._successiveConvergenceTarget = successiveConvergenceTarget;\r\n    this._maxIterations = maxIterations;\r\n  }\r\n  /** Number of consecutive steps which passed convergence condition */\r\n  protected _numAccepted: number = 0;\r\n  /** Target number of successive convergences */\r\n  protected _successiveConvergenceTarget: number;\r\n  /** convergence target (the implementation-specific currentStepSize is compared to this) */\r\n  protected _stepSizeTolerance: number;\r\n  /** Max iterations allowed */\r\n  protected _maxIterations: number;\r\n  /** number of iterations (incremented at each step) */\r\n  public numIterations: number = 0;\r\n  /**\r\n   * Test if a step is converged.\r\n   * * Convergence is accepted with enough (_successiveConvergenceTarget) small steps (according to _stepSizeTolerance) occur in succession.\r\n   * @param delta step size as reported by currentStepSize\r\n   */\r\n  public testConvergence(delta: number): boolean {\r\n    if (Math.abs(delta) < this._stepSizeTolerance) {\r\n      this._numAccepted++;\r\n      return this._numAccepted >= this._successiveConvergenceTarget;\r\n    }\r\n    this._numAccepted = 0;\r\n    return false;\r\n  }\r\n  /**\r\n   * Run iterations, calling various methods from base and derived classes:\r\n   * * computeStep -- typically evaluate derivatives and solve lineary system.\r\n   * * currentStepSize -- return numeric measure of the step just computed by computeStep\r\n   * * testConvergence -- test if the step from currentStepSize (along with recent steps) is converged.\r\n   * * applyCurrentStep -- apply the step to the independent variables\r\n   */\r\n  public runIterations(): boolean {\r\n    this._numAccepted = 0;\r\n    this.numIterations = 0;\r\n    while (this.numIterations++ < this._maxIterations && this.computeStep()) {\r\n      if (this.testConvergence(this.currentStepSize())\r\n        && this.applyCurrentStep(true)) {\r\n        return true;\r\n      }\r\n      this.applyCurrentStep(false);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n/** object to evaluate a newton function.  The object must retain most-recent function and derivative\r\n * values for immediate query.\r\n * @internal\r\n */\r\nexport abstract class NewtonEvaluatorRtoRD {\r\n/** evaluate the function and its derivative at x. */\r\n  public abstract evaluate(x: number): boolean;\r\n  /** most recent function value */\r\n  public currentF!: number;\r\n  /** most recent evaluated derivative */\r\n  public currentdFdX!: number;\r\n}\r\n/**\r\n * Newton iterator for use when both function and derivative can be evaluated.\r\n * @internal\r\n */\r\nexport class Newton1dUnbounded extends AbstractNewtonIterator {\r\n  private _func: NewtonEvaluatorRtoRD;\r\n  private _currentStep!: number;\r\n  private _currentX!: number;\r\n  private _target!: number;\r\n  /**\r\n   * Constructor for 1D newton iteration with approximate derivatives.\r\n   * @param func function that returns both function and derivative.\r\n   */\r\n  public constructor(func: NewtonEvaluatorRtoRD) {\r\n    super();\r\n    this._func = func;\r\n    this.setTarget(0);\r\n  }\r\n  /** Set the independent variable */\r\n  public setX(x: number): boolean { this._currentX = x; return true; }\r\n  /** Get the independent variable */\r\n  public getX(): number { return this._currentX; }\r\n  /** Set the target function value */\r\n  public setTarget(y: number) { this._target = y; }\r\n  /** move the current X by the just-computed step */\r\n  public applyCurrentStep(): boolean { return this.setX(this._currentX - this._currentStep); }\r\n  /** Compute the univariate newton step. */\r\n  public computeStep(): boolean {\r\n    if (this._func.evaluate(this._currentX)) {\r\n      const dx = Geometry.conditionalDivideFraction(this._func.currentF - this._target, this._func.currentdFdX);\r\n      if (dx !== undefined) {\r\n        this._currentStep = dx;\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Return the current step size as a relative number. */\r\n  public currentStepSize(): number {\r\n    return Math.abs(this._currentStep / (1.0 + Math.abs(this._currentX)));\r\n  }\r\n}\r\n\r\n/** object to evaluate a newton function (without derivative).  The object must retain most-recent function value.\r\n * @internal\r\n */\r\nexport abstract class NewtonEvaluatorRtoR {\r\n/** Evalute function value into member currentF */\r\n  public abstract evaluate(x: number): boolean;\r\n  /** Most recent function evaluation. */\r\n  public currentF!: number;\r\n}\r\n\r\n/** Newton iteration for a univariate function, using approximate derivatives.\r\n * @internal\r\n */\r\nexport class Newton1dUnboundedApproximateDerivative extends AbstractNewtonIterator {\r\n  private _func: NewtonEvaluatorRtoR;\r\n  private _currentStep!: number;\r\n  private _currentX!: number;\r\n  /** Step size for iteration.\r\n   * * Initialized to 1e-8, which is appropriate for iteration in fraction space.\r\n   * * Shoulde larger for iteration with real distance as x.\r\n   */\r\n  public derivativeH: number; // step size for approximate derivative\r\n\r\n  /**\r\n   * Constructor for 1D newton iteration with approximate derivatives.\r\n   * @param func function that returns both function and derivative.\r\n   */\r\n  public constructor(func: NewtonEvaluatorRtoR) {\r\n    super();\r\n    this._func = func;\r\n    this.derivativeH = 1.0e-8;\r\n  }\r\n  /** Set the x (independent, iterated) value */\r\n  public setX(x: number): boolean { this._currentX = x; return true; }\r\n  /** Get the independent variable */\r\n  public getX(): number { return this._currentX; }\r\n  /** move the current X by the just-computed step */\r\n  public applyCurrentStep(): boolean { return this.setX(this._currentX - this._currentStep); }\r\n  /** Univariate newton step computed with APPROXIMATE derivative. */\r\n  public computeStep(): boolean {\r\n    if (this._func.evaluate(this._currentX)) {\r\n      const fA = this._func.currentF;\r\n      if (this._func.evaluate(this._currentX + this.derivativeH)) {\r\n        const fB = this._func.currentF;\r\n        const dx = Geometry.conditionalDivideFraction(fA, (fB - fA) / this.derivativeH);\r\n        if (dx !== undefined) {\r\n          this._currentStep = dx;\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Return the current step size as a relative number. */\r\n  public currentStepSize(): number {\r\n    return Math.abs(this._currentStep / (1.0 + Math.abs(this._currentX)));\r\n  }\r\n}\r\n\r\n/** object to evaluate a 2-parameter newton function (with derivatives!!).\r\n * @internal\r\n */\r\nexport abstract class NewtonEvaluatorRRtoRRD {\r\n  /** Iteration controller calls this to ask for evaluation of the function and its two partial derivatives.\r\n   * * The implemention returns true, it must set the currentF object.\r\n   */\r\n  public abstract evaluate(x: number, y: number): boolean;\r\n  /** most recent function evaluation as xy parts of the plane */\r\n  public currentF!: Plane3dByOriginAndVectors;\r\n  /**\r\n   * constructor.\r\n   * * This creates a crrentF object to (repeatedly) receive function and derivatives.\r\n   */\r\n  public constructor() {\r\n    this.currentF = Plane3dByOriginAndVectors.createXYPlane();\r\n  }\r\n}\r\n\r\n/**\r\n * Implement evaluation steps for newton iteration in 2 dimensions, using caller supplied NewtonEvaluatorRRtoRRD object.\r\n * @internal\r\n */\r\nexport class Newton2dUnboundedWithDerivative extends AbstractNewtonIterator {\r\n  private _func: NewtonEvaluatorRRtoRRD;\r\n  private _currentStep: Vector2d;\r\n  private _currentUV: Point2d;\r\n\r\n  public constructor(func: NewtonEvaluatorRRtoRRD) {\r\n    super();\r\n    this._func = func;\r\n    this._currentStep = Vector2d.createZero();\r\n    this._currentUV = Point2d.createZero();\r\n  }\r\n  /** Set the current uv coordinates for current iteration */\r\n  public setUV(x: number, y: number): boolean { this._currentUV.set(x, y); return true; }\r\n  /** Get the current u coordinate */\r\n  public getU(): number { return this._currentUV.x; }\r\n  /** Get the current v coordinate */\r\n  public getV(): number { return this._currentUV.y; }\r\n  /** Move the currentUV coordiante by currentStep. */\r\n  public applyCurrentStep(): boolean { return this.setUV(this._currentUV.x - this._currentStep.x, this._currentUV.y - this._currentStep.y); }\r\n  /** Evaluate the functions and derivatives at this._currentUV\r\n   * Invert the jacobian and compute the this._currentStep.\r\n   */\r\n  public computeStep(): boolean {\r\n    if (this._func.evaluate(this._currentUV.x, this._currentUV.y)) {\r\n      const fA = this._func.currentF;\r\n      if (SmallSystem.linearSystem2d(\r\n        fA.vectorU.x, fA.vectorV.x,\r\n        fA.vectorU.y, fA.vectorV.y,\r\n        fA.origin.x, fA.origin.y, this._currentStep))\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * Return the largest relative step of the x,y, components of the current step.\r\n   */\r\n  public currentStepSize(): number {\r\n    return Geometry.maxAbsXY(\r\n      this._currentStep.x / (1.0 + Math.abs(this._currentUV.x)),\r\n      this._currentStep.y / (1.0 + Math.abs(this._currentUV.y)));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/**\r\n * PascalCoeffients class has static methods which return rows of the PascalTriangle.\r\n * @internal\r\n */\r\nexport class PascalCoefficients {\r\n  private static _allRows: Float64Array[] = [];\r\n  /**\r\n   * * return a row of the pascal table.\r\n   * * The contents must not be altered by the user !!!\r\n   * * Hypothetically the request row can be any integer.\r\n   * * BUT in practice, values 60 create integer entries that are too big for IEEE double.\r\n   */\r\n  public static getRow(row: number): Float64Array {\r\n    const allRows = PascalCoefficients._allRows;\r\n    if (allRows.length === 0) {\r\n      // seed the table . . .\r\n      allRows.push(new Float64Array([1]));\r\n      allRows.push(new Float64Array([1, 1]));\r\n      allRows.push(new Float64Array([1, 2, 1]));\r\n      allRows.push(new Float64Array([1, 3, 3, 1]));\r\n      allRows.push(new Float64Array([1, 4, 6, 4, 1]));\r\n      allRows.push(new Float64Array([1, 5, 10, 10, 5, 1]));\r\n      allRows.push(new Float64Array([1, 6, 15, 20, 15, 6, 1]));\r\n      allRows.push(new Float64Array([1, 7, 21, 35, 35, 21, 7, 1]));\r\n    }\r\n\r\n    while (allRows.length <= row) {\r\n      const k = allRows.length;\r\n      const oldRow = allRows[k - 1];\r\n      const newRow = new Float64Array(k + 1);\r\n      newRow[0] = 1.0;\r\n      for (let i = 1; i < k; i++)\r\n        newRow[i] = oldRow[i - 1] + oldRow[i];\r\n      newRow[k] = 1.0;\r\n      allRows.push(newRow);\r\n    }\r\n    return allRows[row];\r\n  }\r\n  /** Return an array with Bezier weighted pascal coefficients\r\n   * @param row row index in the pascal triangle.  (`row+1` entries)\r\n   * @param u parameter value\r\n   * @param result optional destination array.\r\n   * @note if the destination array is undefined or too small, a new Float64Array is allocated.\r\n   * @note if the destination array is larger than needed, its leading `row+1` values are filled,\r\n   *     and the array is returned.\r\n   */\r\n  public static getBezierBasisValues(order: number, u: number, result?: Float64Array): Float64Array {\r\n    const row = order - 1;\r\n    const pascalRow = PascalCoefficients.getRow(row);\r\n    if (result === undefined || result.length < order)\r\n      result = new Float64Array(order);\r\n    for (let i = 0; i < order; i++)\r\n      result[i] = pascalRow[i];\r\n    // multiply by increasing powers of u ...\r\n    let p = u;\r\n    for (let i = 1; i < order; i++ , p *= u) {\r\n      result[i] *= p;\r\n    }\r\n    // multiply by powers of (1-u), working from right\r\n    const v = 1.0 - u;\r\n    p = v;\r\n    for (let i = order - 2; i >= 0; i-- , p *= v) {\r\n      result[i] *= p;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Return an array with derivatives of Bezier weighted pascal coefficients\r\n   * @param row row index in the pascal triangle.  (`row+1` entries)\r\n   * @param u parameter value\r\n   * @param result optional destination array.\r\n   * @note if the destination array is undefined or too small, a new Float64Array is allocated.\r\n   * @note if the destination array is larger than needed, its leading `row+1` values are filled,\r\n   *     and the array is returned.\r\n   */\r\n  public static getBezierBasisDerivatives(order: number, u: number, result?: Float64Array): Float64Array {\r\n    result = this.getBezierBasisValues(order - 1, u, result);\r\n    // derivative is df/du = (order-1 ) * sum ( q[i+1] - q[i])   summed on 0 <= i < order - 1.\\\r\n    // evaluate lower order basis, overwrite in place from right to left\r\n    const f = order - 1;\r\n    result[order - 1] = f * result[order - 2];\r\n    for (let k = order - 2; k > 0; k--) {\r\n      result[k] = f * (result[k - 1] - result[k]);\r\n    }\r\n    result[0] = - f * result[0];\r\n    return result;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\n// import { Angle, AngleSweep, Geometry } from \"../Geometry\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { OptionalGrowableFloat64Array, GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { XAndY } from \"../geometry3d/XYZProps\";\r\n// import { Arc3d } from \"../curve/Arc3d\";\r\n// cspell:word Cardano\r\n// cspell:word CCminusSS\r\n/* tslint:disable:variable-name*/\r\n/**\r\n * degree 2 (quadratic) polynomial in for y = c0 + c1*x + c2*x^2\r\n * @internal\r\n */\r\nexport class Degree2PowerPolynomial {\r\n  /** The three coefficients for the quartic */\r\n  public coffs: number[];\r\n\r\n  constructor(c0: number = 0, c1: number = 0, c2: number = 0) {\r\n    this.coffs = [c0, c1, c2];\r\n  }\r\n\r\n  /**\r\n   * * Return 2 duplicate roots in double root case.\r\n   * @returns 0, 1, or 2 solutions of the usual quadratic (a*x*x + b * x + c = 0)\r\n   */\r\n  public static solveQuadratic(a: number, b: number, c: number): number[] | undefined {\r\n    const b1 = Geometry.conditionalDivideFraction(b, a);\r\n    const c1 = Geometry.conditionalDivideFraction(c, a);\r\n    if (b1 !== undefined && c1 !== undefined) {\r\n      // now solving xx + b1*x + c1 = 0 -- i.e. implied \"a\" coefficient is 1 . .\r\n      const q = b1 * b1 - 4 * c1;\r\n      if (q > 0) {\r\n        const e = Math.sqrt(q);\r\n        // e is positive, so this sorts algebraically\r\n        return [0.5 * (-b1 - e), 0.5 * (-b1 + e)];\r\n      }\r\n      if (q < 0)\r\n        return undefined;\r\n      const root = -0.5 * b1;\r\n      return [root, root];\r\n    }\r\n    // \"divide by a\" failed.  solve bx + c = 0\r\n    const x = Geometry.conditionalDivideFraction(-c, b);\r\n    if (x !== undefined)\r\n      return [x];\r\n    return undefined;\r\n  }\r\n  /** Add `a` to the constant term. */\r\n  public addConstant(a: number) {\r\n    this.coffs[0] += a;\r\n  }\r\n\r\n  /** Add  `s * (a + b*x)^2` to the quadratic coefficients */\r\n  public addSquaredLinearTerm(a: number, b: number, s: number = 1): void {\r\n    this.coffs[0] += s * (a * a);\r\n    this.coffs[1] += s * (2.0 * a * b);\r\n    this.coffs[2] += s * (b * b);\r\n  }\r\n  /** Return the real roots of this polynomial */\r\n  public realRoots(): number[] | undefined {\r\n    const ss = Degree2PowerPolynomial.solveQuadratic(this.coffs[2], this.coffs[1], this.coffs[0]);\r\n    if (ss && ss.length > 1) {\r\n      if (ss[0] > ss[1]) {\r\n        const temp = ss[0];\r\n        ss[0] = ss[1];\r\n        ss[1] = temp;\r\n      }\r\n    }\r\n    return ss;\r\n  }\r\n\r\n  /** Evaluate the quadratic at x. */\r\n  public evaluate(x: number): number {\r\n    return this.coffs[0] + x * (this.coffs[1] + x * this.coffs[2]);\r\n  }\r\n\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. sum the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluateDerivative(x: number): number {\r\n    return this.coffs[1] + 2 * x * this.coffs[2];\r\n  }\r\n\r\n  /** Factor the polynomial in to the form `y0 + c * (x-x0)^2)`, i.e. complete the square. */\r\n  public tryGetVertexFactorization(): { x0: number, y0: number, c: number } | undefined {\r\n    const x = Geometry.conditionalDivideFraction(-this.coffs[1], 2.0 * this.coffs[2]);\r\n    if (x !== undefined) {\r\n      const y = this.evaluate(x);\r\n      return { c: this.coffs[2], x0: x, y0: y };\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Construct a quadratic from input form `c2 * (x-root0) * (x-root1)` */\r\n  public static fromRootsAndC2(root0: number, root1: number, c2: number = 1): Degree2PowerPolynomial {\r\n    return new Degree2PowerPolynomial(\r\n      c2 * root0 * root1,\r\n      - c2 * (root0 + root1),\r\n      c2);\r\n  }\r\n\r\n}\r\n/**\r\n * degree 3 (cubic) polynomial in for y = c0 + c1*x + c2*x^2 + c3*x^3\r\n * @internal\r\n */\r\nexport class Degree3PowerPolynomial {\r\n  /** polynomial coefficients, index corresponds to power */\r\n  public coffs: number[];\r\n\r\n  constructor(c0: number = 0, c1: number = 0, c2: number = 0, c3: number = 1) {\r\n    this.coffs = [c0, c1, c2, c3];\r\n  }\r\n  /** Add `a` to the constant term. */\r\n  public addConstant(a: number) {\r\n    this.coffs[0] += a;\r\n  }\r\n\r\n  /** Add `s * (a + b*x)^2` to the cubic */\r\n  public addSquaredLinearTerm(a: number, b: number, s: number = 1): void {\r\n    this.coffs[0] += s * (a * a);\r\n    this.coffs[1] += s * (2.0 * a * b);\r\n    this.coffs[2] += s * (b * b);\r\n  }\r\n\r\n  /**\r\n   * Evaluate the polynomial at x\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(x: number): number {\r\n    return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * this.coffs[3]));\r\n  }\r\n\r\n  /**\r\n   * Evaluate the polynomial derivative\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluateDerivative(x: number): number {\r\n    return this.coffs[1] + x * (2.0 * this.coffs[2] + x * 3.0 * this.coffs[3]);\r\n  }\r\n  /** Construct a cubic from the form `c3 * (x-root0) * (x - root1) * (x- root2)` */\r\n  public static fromRootsAndC3(root0: number, root1: number, root2: number, c3: number = 1.0): Degree3PowerPolynomial {\r\n    return new Degree3PowerPolynomial(\r\n      -c3 * root0 * root1 * root2,\r\n      c3 * (root0 * root1 + root1 * root2 + root0 * root2),\r\n      - c3 * (root0 + root1 + root2),\r\n      c3);\r\n  }\r\n}\r\n/**\r\n * degree 4 (quartic) polynomial in for y = c0 + c1*x + c2*x^2 + c4*x^4\r\n * @internal\r\n */\r\nexport class Degree4PowerPolynomial {\r\n  /** polynomial coefficients, index corresponds to power */\r\n  public coffs: number[];\r\n\r\n  constructor(c0: number = 0, c1: number = 0, c2: number = 0, c3: number = 0, c4: number = 0) {\r\n    this.coffs = [c0, c1, c2, c3, c4];\r\n  }\r\n  /** Add `a` to the constant term. */\r\n  public addConstant(a: number) {\r\n    this.coffs[0] += a;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the polynomial\r\n   * @param x x coordinate for evaluation\r\n   */\r\n  public evaluate(x: number): number {\r\n    return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * (this.coffs[3] + x * this.coffs[4])));\r\n  }\r\n\r\n  /**\r\n   * Evaluate the derivative\r\n   * @param x x coordinate for evaluation\r\n   */\r\n  public evaluateDerivative(x: number): number {\r\n    return (this.coffs[1] + x * (2.0 * this.coffs[2] + x * (3.0 * this.coffs[3] + x * 4.0 * this.coffs[4])));\r\n  }\r\n\r\n  /** Construct a quartic from the form `c3 * (x-root0) * (x - root1) * (x- root2) * (x-root3)` */\r\n  public static fromRootsAndC4(root0: number, root1: number, root2: number, root3: number, c4: number = 1): Degree4PowerPolynomial {\r\n    return new Degree4PowerPolynomial(\r\n      c4 * (root0 * root1 * root2 * root3),\r\n      -c4 * (root0 * root1 * root2 + root0 * root1 * root3 + root0 * root2 * root3 + root1 * root2 * root3),\r\n      c4 * (root0 * root1 + root0 * root2 + root0 * root3 + root1 * root2 + root1 * root3 + root2 * root3),\r\n      -c4 * (root0 + root1 + root2 + root3),\r\n      c4);\r\n  }\r\n\r\n}\r\n/**\r\n * polynomial services for an implicit torus with\r\n * * z axis is \"through the donut hole\"\r\n * * `majorRadius` is the radius of the circle \"around the z axis\"\r\n * * `minorRadius` is the radius of circles around the major circle\r\n * * for simple xyz the implicit form is\r\n *   * `(x^2+y^2+z^2+(R^2-r^2))^2 = 4 R^2(x^2+y^2)`\r\n * * In weighted form\r\n *   * `(x^2+y^2+z^2+(R^2-r^2)w^2)^2 = 4 R^2 w^2 (x^2+y^2)`\r\n * @internal\r\n */\r\nexport class TorusImplicit {\r\n  /** major (xy plane) radius */\r\n  public majorRadius: number;\r\n  /** hoop (perpendicular to major circle) radius */\r\n  public minorRadius: number;\r\n\r\n  constructor(majorRadius: number, minorRadius: number) {\r\n    this.majorRadius = majorRadius;\r\n    this.minorRadius = minorRadius;\r\n  }\r\n\r\n  /** Return sum of (absolute) major and minor radii, which is (half) the box size in x and y directions */\r\n  public boxSize() {\r\n    return (Math.abs(this.majorRadius) + Math.abs(this.minorRadius));\r\n  }\r\n  /** Return scale factor appropriate to control the magnitude of the implicit function. */\r\n  public implicitFunctionScale(): number {\r\n    const a = this.boxSize();\r\n    if (a === 0.0)\r\n      return 1.0;\r\n    return 1.0 / (a * a * a * a);\r\n  }\r\n\r\n  /**\r\n   * At space point (x,y,z) evaluate the implicit form of the torus (See `ImplicitTorus`)\r\n   */\r\n  public evaluateImplicitFunctionXYZ(x: number, y: number, z: number): number {\r\n    const rho2 = x * x + y * y;\r\n    const z2 = z * z;\r\n    const R2 = this.majorRadius * this.majorRadius;\r\n    const r2 = this.minorRadius * this.minorRadius;\r\n    const f = rho2 + z2 + (R2 - r2);\r\n    const g = 4.0 * R2 * rho2;\r\n    return (f * f - g) * this.implicitFunctionScale();\r\n  }\r\n  /** Evaluate the implicit function at a point. */\r\n  public evaluateImplicitFunctionPoint(xyz: Point3d): number {\r\n    return this.evaluateImplicitFunctionXYZ(xyz.x, xyz.y, xyz.z);\r\n  }\r\n  /** Evaluate the implicit function at homogeneous coordinates */\r\n  public evaluateImplicitFunctionXYZW(x: number, y: number, z: number, w: number) {\r\n    const rho2 = x * x + y * y;\r\n    const z2 = z * z;\r\n    const w2 = w * w;\r\n    const R2 = this.majorRadius * this.majorRadius;\r\n    const r2 = this.minorRadius * this.minorRadius;\r\n    const f = rho2 + z2 + w2 * (R2 - r2);\r\n    const g = w2 * 4.0 * R2 * rho2;\r\n    return (f * f - g) * this.implicitFunctionScale();\r\n  }\r\n\r\n  /** Evaluate the surface point at angles (in radians) on the major and minor circles. */\r\n  public evaluateThetaPhi(thetaRadians: number, phiRadians: number): Point3d {\r\n    const c = Math.cos(thetaRadians);\r\n    const s = Math.sin(thetaRadians);\r\n    // theta=0 point\r\n    const x0 = this.majorRadius + this.minorRadius * Math.cos(phiRadians);\r\n    const z0 = this.minorRadius * Math.sin(phiRadians);\r\n    return Point3d.create(c * x0, s * x0, z0);\r\n  }\r\n\r\n  /** Evaluate partial derivatives at angles (int radians) on major and minor circles. */\r\n  public evaluateDerivativesThetaPhi(thetaRadians: number, phiRadians: number, dxdTheta: Vector3d, dxdPhi: Vector3d) {\r\n    const cTheta = Math.cos(thetaRadians);\r\n    const sTheta = Math.sin(thetaRadians);\r\n    const bx = this.minorRadius * Math.cos(phiRadians);\r\n    const bz = this.minorRadius * Math.sin(phiRadians);\r\n    const x0 = this.majorRadius + bx;\r\n    Vector3d.create(-x0 * sTheta, x0 * cTheta, 0.0, dxdTheta);\r\n    Vector3d.create(-cTheta * bz, -sTheta * bz, bx, dxdPhi);\r\n  }\r\n\r\n  /** Evaluate space point at major and minor angles (in radians) and distance from major hoop. */\r\n  public evaluateThetaPhiDistance(thetaRadians: number, phiRadians: number, distance: number): Point3d {\r\n    const c = Math.cos(thetaRadians);\r\n    const s = Math.sin(thetaRadians);\r\n    // theta=0 point\r\n    const x0 = this.majorRadius + distance * Math.cos(phiRadians);\r\n    const z0 = distance * Math.sin(phiRadians);\r\n    return Point3d.create(c * x0, s * x0, z0);\r\n  }\r\n  /** Given an xyz coordinate in the local system of the toroid, compute the torus parametrization\r\n   * * theta = angular coordinate in xy plane\r\n   * * phi = angular coordinate in minor circle.\r\n   * * distance = distance from major circle\r\n   * * rho = distance from origin to xy part of the input.\r\n   * @param xyz space point in local coordinates.\r\n   * @return object with properties theta, phi, distance, rho\r\n   */\r\n  public xyzToThetaPhiDistance(xyz: Point3d): { theta: number, phi: number, distance: number, rho: number, safePhi: boolean } {\r\n    const rho = xyz.magnitudeXY();\r\n    const majorRadiusFactor = Geometry.conditionalDivideFraction(this.majorRadius, rho);\r\n    let safeMajor;\r\n    let majorCirclePoint;\r\n    if (majorRadiusFactor) {\r\n      safeMajor = true;\r\n      majorCirclePoint = Point3d.create(majorRadiusFactor * xyz.x, majorRadiusFactor * xyz.y, 0.0);\r\n    } else {\r\n      safeMajor = false;\r\n      majorCirclePoint = Point3d.create(xyz.x, xyz.y, 0.0);\r\n    }\r\n    const theta = safeMajor ? Math.atan2(xyz.y, xyz.x) : 0.0;\r\n    const vectorFromMajorCircle = Vector3d.createStartEnd(majorCirclePoint, xyz);\r\n    const distance = vectorFromMajorCircle.magnitude();\r\n    const dRho = rho - this.majorRadius;\r\n    let safePhi;\r\n    let phi;\r\n    if (xyz.z === 0.0 && dRho === 0.0) {\r\n      phi = 0.0;\r\n      safePhi = false;\r\n    } else {\r\n      phi = Math.atan2(xyz.z, dRho);\r\n      safePhi = true;\r\n    }\r\n    return { theta: (theta), phi: (phi), distance: (distance), rho: (rho), safePhi: safeMajor && safePhi };\r\n  }\r\n  /*\r\n    public minorCircle(theta: Angle): Arc3d {\r\n      const c = Math.cos(theta.radians);\r\n      const s = Math.sin(theta.radians);\r\n      return Arc3d.create(\r\n        Point3d.create(c * this.majorRadius, s * this.majorRadius, 0.0),\r\n        Vector3d.create(c * this.minorRadius, s * this.minorRadius, 0.0),\r\n        Vector3d.create(0.0, 0.0, this.minorRadius),\r\n        AngleSweep.create360()) as Arc3d;\r\n    }\r\n\r\n    public majorCircle(phi: Angle): Arc3d {\r\n      const c = Math.cos(phi.radians);\r\n      const s = Math.sin(phi.radians);\r\n      const a = this.majorRadius + c * this.minorRadius;\r\n      return Arc3d.create(\r\n        Point3d.create(0.0, 0.0, this.minorRadius * s),\r\n        Vector3d.create(a, 0.0, 0.0),\r\n        Vector3d.create(0.0, a, 0.0),\r\n        AngleSweep.create360()) as Arc3d;\r\n    }\r\n  */\r\n}\r\n/**\r\n * evaluation methods for an implicit sphere\r\n * * xyz function `x*x + y*y + z*z - r*r = 0`.\r\n * * xyzw function `x*x + y*y + z*z - r*r*w*w = 0`.\r\n * @internal\r\n */\r\nexport class SphereImplicit {\r\n  /** Radius of sphere. */\r\n  public radius: number;\r\n  constructor(r: number) { this.radius = r; }\r\n\r\n  /** Evaluate the implicit function at coordinates x,y,z */\r\n  public evaluateImplicitFunction(x: number, y: number, z: number): number {\r\n    return x * x + y * y + z * z - this.radius * this.radius;\r\n  }\r\n\r\n  /** Evaluate the implicit function at homogeneous coordinates x,y,z,w */\r\n  public evaluateImplicitFunctionXYZW(wx: number, wy: number, wz: number, w: number): number {\r\n    return (wx * wx + wy * wy + wz * wz) - this.radius * this.radius * w * w;\r\n  }\r\n\r\n  /** Given an xyz coordinate in the local system of the toroid, compute the sphere parametrization\r\n   * * theta = angular coordinate in xy plane\r\n   * * phi = rotation from xy plane towards z axis.\r\n   * @param xyz space point in local coordinates.\r\n   * @return object with properties thetaRadians, phi, r\r\n   */\r\n  public xyzToThetaPhiR(xyz: Point3d): { thetaRadians: number, phiRadians: number, r: number, valid: boolean } {\r\n    const rhoSquared = xyz.x * xyz.x + xyz.y * xyz.y;\r\n    const rho = Math.sqrt(rhoSquared);\r\n    const r = Math.sqrt(rhoSquared + xyz.z * xyz.z);\r\n    let theta;\r\n    let phi;\r\n    let valid;\r\n    if (r === 0.0) {\r\n      theta = phi = 0.0;\r\n      valid = false;\r\n    } else {\r\n      phi = Math.atan2(xyz.z, rho); // At least one of these is nonzero\r\n      if (rhoSquared !== 0.0) {\r\n        theta = Math.atan2(xyz.y, xyz.x);\r\n        valid = true;\r\n      } else {\r\n        theta = 0.0;\r\n        valid = false;\r\n      }\r\n    }\r\n    return { thetaRadians: (theta), phiRadians: (phi), r: (r), valid: (valid) };\r\n  }\r\n\r\n  // public intersectRay(ray: Ray3d, maxHit: number): {rayFractions: number, points: Point3d} {\r\n  //   const q = new Degree2PowerPolynomial();\r\n  //   // Ray is (origin.x + s * direction.x, etc)\r\n  //   // squared distance from origin is (origin.x + s*direction.x)^2 + etc\r\n  //   // sphere radius in local system is 1.\r\n  //   q.addSquaredLinearTerm(ray.origin.x, ray.direction.x);\r\n  //   q.addSquaredLinearTerm(ray.origin.y, ray.direction.y);\r\n  //   q.addSquaredLinearTerm(ray.origin.z, ray.direction.z);\r\n  //   q.addConstant(-this.radius * this.radius);\r\n  //   let ss = [];\r\n  //   let n = q.realRoots(ss);\r\n  //   if (n > maxHit)\r\n  //     n = maxHit;\r\n  //   let rayFractions;\r\n  //   let points;\r\n  //   for (let i = 0; i < n; i++) {\r\n  //     rayFractions[i] = ss[i];\r\n  //     points[i] = Point3d. // What is the equivalent of FromSumOf in TS?\r\n  //   }\r\n  /** Compute the point on a sphere at angular coordinates.\r\n   * @param thetaRadians latitude angle\r\n   * @param phiRadians longitude angle\r\n   */\r\n  public evaluateThetaPhi(thetaRadians: number, phiRadians: number): Point3d {\r\n    const rc = this.radius * Math.cos(thetaRadians);\r\n    const rs = this.radius * Math.sin(thetaRadians);\r\n    const cosPhi = Math.cos(phiRadians);\r\n    const sinPhi = Math.sin(phiRadians);\r\n    return Point3d.create(rc * cosPhi, rs * cosPhi, this.radius * sinPhi);\r\n  }\r\n\r\n  /** Compute the derivatives with respect to spherical angles.\r\n   * @param thetaRadians latitude angle\r\n   * @param phiRadians longitude angle\r\n   */\r\n  public evaluateDerivativesThetaPhi(thetaRadians: number, phiRadians: number, dxdTheta: Vector3d, dxdPhi: Vector3d) {\r\n    const rc = this.radius * Math.cos(thetaRadians);\r\n    const rs = this.radius * Math.sin(thetaRadians);\r\n    const cosPhi = Math.cos(phiRadians);\r\n    const sinPhi = Math.sin(phiRadians);\r\n    Vector3d.create(-rs * cosPhi, rc * cosPhi, 0.0, dxdTheta);\r\n    Vector3d.create(-rc * sinPhi, -rs * sinPhi, this.radius * cosPhi, dxdPhi);\r\n  }\r\n  /*\r\n    public meridianCircle(theta: number): Arc3d {\r\n      const rc = this.radius * Math.cos(theta);\r\n      const rs = this.radius * Math.sin(theta);\r\n      return Arc3d.create(\r\n        Point3d.create(0.0, 0.0, 0.0),\r\n        Vector3d.create(rc, rs, 0),\r\n        Vector3d.create(0, 0, this.radius),\r\n        AngleSweep.create360()) as Arc3d;\r\n    }\r\n\r\n    public parallelCircle(phi: number): Arc3d {\r\n      const cr = this.radius * Math.cos(phi);\r\n      const sr = this.radius * Math.sin(phi);\r\n      return Arc3d.create(\r\n        Point3d.create(0, 0, sr),\r\n        Vector3d.create(cr, 0, 0),\r\n        Vector3d.create(0, cr, 0),\r\n        AngleSweep.create360()) as Arc3d;\r\n    }\r\n    */\r\n}\r\n/** AnalyticRoots has static methods for solving quadratic, cubic, and quartic equations.\r\n * @internal\r\n *\r\n */\r\nexport class AnalyticRoots {\r\n  private static readonly _EQN_EPS = 1.0e-9;\r\n  private static readonly _safeDivideFactor = 1.0e-14;\r\n  /** Absolute zero test with a tolerance that has worked well for the analytic root use case . . . */\r\n  private static isZero(x: number): boolean {\r\n    return Math.abs(x) < this._EQN_EPS;\r\n  }\r\n  /** Without actually doing a division, test if (x/y) is small.\r\n   * @param x numerator\r\n   * @param y denominator\r\n   * @param absTol absolute tolerance\r\n   * @param relTol relative tolerance\r\n   */\r\n  private static isSmallRatio(x: number, y: number, absTol: number = 1.0e-9, relTol: number = 8.0e-16) {\r\n    return Math.abs(x) <= absTol || Math.abs(x) < relTol * Math.abs(y);\r\n  }\r\n  /** Return the (real, signed) principal cube root of x */\r\n  public static cbrt(x: number): number {\r\n    return ((x) > 0.0\r\n      ? Math.pow((x), 1.0 / 3.0)\r\n      : ((x) < 0.0\r\n        ? -Math.pow(-(x), 1.0 / 3.0)\r\n        : 0.0));\r\n  }\r\n  /**\r\n   * Try to divide `numerator/denominator` and place the result (or defaultValue) in `values[offset]`\r\n   * @param values array of values.  `values[offset]` will be replaced.\r\n   * @param numerator numerator for division.\r\n   * @param denominator denominator for division.\r\n   * @param defaultValue value to save if denominator is too small to divide.\r\n   * @param offset index of value to replace.\r\n   */\r\n  private static safeDivide(values: Float64Array, numerator: number, denominator: number, defaultValue: number = 0.0, offset: number): boolean {\r\n    if (Math.abs(denominator) > (this._safeDivideFactor * Math.abs(numerator))) {\r\n      values[offset] = numerator / denominator;\r\n      return true;\r\n    }\r\n    values[offset] = defaultValue;\r\n    return false;\r\n  }\r\n  // Used in NewtonMethod for testing if a root has been adjusted past its bounding region\r\n  private static checkRootProximity(roots: GrowableFloat64Array, i: number): boolean {\r\n    if (i === 0) { // Case 1: Beginning Root (check root following it)\r\n      return roots.atUncheckedIndex(i) < roots.atUncheckedIndex(i + 1);\r\n    } else if (i > 0 && i + 1 < roots.length) { // Case 2: Middle Root (check roots before and after)\r\n      return (roots.atUncheckedIndex(i) > roots.atUncheckedIndex(i - 1)) && (roots.atUncheckedIndex(i) < roots.atUncheckedIndex(i + 1));\r\n    } else { // Case 3: End root (check preceding root)\r\n      return (roots.atUncheckedIndex(i) > roots.atUncheckedIndex(i - 1));\r\n    }\r\n  }\r\n  private static newtonMethodAdjustment(coffs: Float64Array | number[], root: number, degree: number): number | undefined {\r\n    let p = coffs[degree];\r\n    let q = 0.0;\r\n    for (let i = degree - 1; i >= 0; i--) {\r\n      q = p + root * q;\r\n      p = coffs[i] + root * p;\r\n    }\r\n    if (Math.abs(q) >= 1.0e-14 * (1.0 + Math.abs(root))) {\r\n      return p / q;\r\n    }\r\n    return undefined;\r\n  }\r\n  private static improveRoots(coffs: Float64Array | number[], degree: number, roots: GrowableFloat64Array, restrictOrderChanges: boolean) {\r\n    const relTol = 1.0e-10;\r\n\r\n    // Loop through each root\r\n    for (let i = 0; i < roots.length; i++) {\r\n      let dx = this.newtonMethodAdjustment(coffs, roots.atUncheckedIndex(i), degree);\r\n      if (dx === undefined || dx === 0.0) continue;  // skip if newton step had divide by zero.\r\n      const originalValue = roots.atUncheckedIndex(i);\r\n      let counter = 0;\r\n      let convergenceCounter = 0;\r\n\r\n      // Loop through applying changes to found root until dx is diminished or counter is hit\r\n      while (dx !== undefined && dx !== 0.0 && (counter < 10)) {\r\n        // consider it converged if two successive iterations satisfy the (not too demanding) tolerance.\r\n        if (Math.abs(dx) < relTol * (1.0 + Math.abs(roots.atUncheckedIndex(i)))) {\r\n          if (++convergenceCounter > 1)\r\n            break;\r\n        } else {\r\n          convergenceCounter = 0;\r\n        }\r\n\r\n        const rootDX = roots.atUncheckedIndex(i) - dx;\r\n        roots.reassign(i, rootDX);\r\n\r\n        // If root is thrown past one of its neighboring roots, unstable condition is assumed.. revert\r\n        // to originally found root\r\n        if (restrictOrderChanges && !this.checkRootProximity(roots, i)) {\r\n          roots.reassign(i, originalValue);\r\n          break;\r\n        }\r\n\r\n        dx = this.newtonMethodAdjustment(coffs, roots.atUncheckedIndex(i), degree);\r\n        counter++;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Append (if defined) value to results.\r\n   * @param value optional value to append\r\n   * @param results growing array\r\n   */\r\n  private static appendSolution(value: number | undefined, results: GrowableFloat64Array) {\r\n    if (value !== undefined) {\r\n      results.push(value);\r\n    }\r\n  }\r\n  /**\r\n   * Append 2 solutions -- note that both are required args, no option of omitting as in single solution case\r\n   * @param value1\r\n   * @param value2\r\n   * @param results\r\n   */\r\n  private static append2Solutions(valueA: number, valueB: number, results: GrowableFloat64Array) {\r\n    results.push(valueA);\r\n    results.push(valueB);\r\n  }\r\n\r\n  /**\r\n   * If `co/c1` is a safe division, append it to the values array.\r\n   * @param c0 numerator\r\n   * @param c1 denominator\r\n   * @param values array to expand\r\n   */\r\n  public static appendLinearRoot(c0: number, c1: number, values: GrowableFloat64Array) {\r\n    AnalyticRoots.appendSolution(Geometry.conditionalDivideFraction(-c0, c1), values);\r\n  }\r\n  /**\r\n   * * Compute the mean of all the entries in `data`\r\n   * * Return the data value that is farthest away\r\n   */\r\n  public static mostDistantFromMean(data: GrowableFloat64Array | undefined): number {\r\n    if (!data || data.length === 0) return 0;\r\n    let a = 0.0;  // to become the sum and finally the average.\r\n    for (let i = 0; i < data.length; i++) a += data.atUncheckedIndex(i);\r\n    a /= data.length;\r\n    let dMax = 0.0;\r\n    let result = data.atUncheckedIndex(0);\r\n    for (let i = 0; i < data.length; i++) {\r\n      const d = Math.abs(data.atUncheckedIndex(i) - a);\r\n      if (d > dMax) {\r\n        dMax = d;\r\n        result = data.atUncheckedIndex(i);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Append 0, 1, or 2 solutions of a quadratic to the values array.\r\n   * @param c array of coefficients for quadratic `c[0] + c[1] * x + c[2] * x*x`\r\n   * @param values array to be expanded.\r\n   */\r\n  public static appendQuadraticRoots(c: Float64Array | number[], values: GrowableFloat64Array) {\r\n    // Normal form: x^2 + 2px + q = 0\r\n\r\n    const divFactor = Geometry.conditionalDivideFraction(1.0, c[2]);\r\n    if (!divFactor) {\r\n      this.appendLinearRoot(c[0], c[1], values);\r\n      return;\r\n    }\r\n\r\n    const p = 0.5 * c[1] * divFactor;\r\n    const q = c[0] * divFactor;\r\n\r\n    const D = p * p - q;\r\n\r\n    if (this.isZero(D)) {\r\n      this.appendSolution(-p, values);\r\n      return;\r\n    } else if (D < 0) {\r\n      return;\r\n    } else if (D > 0) {\r\n      const sqrt_D = Math.sqrt(D);\r\n      this.append2Solutions(sqrt_D - p, - sqrt_D - p, values);\r\n      return;\r\n    }\r\n    return;\r\n  }\r\n  /** Add `a` to the constant term. */\r\n  private static addConstant(value: number, data: GrowableFloat64Array) {\r\n    for (let i = 0; i < data.length; i++) data.reassign(i, data.atUncheckedIndex(i) + value);\r\n  }\r\n  /** return roots of a cubic c0 + c1 *x + c2 * x^2 + c2 * x3.\r\n   * In the usual case where c0 is non-zero, there are either 1 or 3 roots.\r\n   * But if c0 is zero the (0, 1, or 2) roots of the lower order equation\r\n   */\r\n  private static appendCubicRootsUnsorted(c: Float64Array | number[], results: GrowableFloat64Array) {\r\n    let A: number;\r\n    let B: number;\r\n    let C: number;\r\n    let sq_A: number;\r\n    let p: number;\r\n    let q: number;\r\n    let cb_p: number;\r\n    let D: number;\r\n\r\n    // normal form: x^3 + Ax^2 + Bx + C = 0\r\n\r\n    const scaleFactor = Geometry.conditionalDivideFraction(1.0, c[3]);\r\n    if (!scaleFactor) {\r\n      this.appendQuadraticRoots(c, results);\r\n      return;\r\n    }\r\n\r\n    // It is a real cubic.  There MUST be at least one real solution . . .\r\n    A = c[2] * scaleFactor;\r\n    B = c[1] * scaleFactor;\r\n    C = c[0] * scaleFactor;\r\n\r\n    /*  substitute x = y - A/3 to eliminate quadric term:\r\n        f = y^3 +3py + 2q = 0\r\n        f' = 3y^2 + p\r\n            local min/max at Y = +-sqrt (-p)\r\n            f(+Y) = -p sqrt(-p) + 3p sqrt (-p) + 2q = 2 p sqrt (-p) + 2q\r\n    */\r\n    sq_A = A * A;\r\n    p = (3.0 * B - sq_A) / 9.0;\r\n    q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);\r\n\r\n    // Use Cardano formula\r\n    cb_p = p * p * p;\r\n    D = q * q + cb_p;\r\n    const origin = A / (-3.0);\r\n    if (D >= 0.0 && this.isZero(D)) {\r\n      if (this.isZero(q)) {\r\n        // One triple solution\r\n        results.push(origin);\r\n        results.push(origin);\r\n        results.push(origin);\r\n        return;\r\n      } else {\r\n        // One single and one double solution\r\n        const u = this.cbrt(-q);\r\n        if (u < 0) {\r\n          results.push(origin + 2 * u);\r\n          results.push(origin - u);\r\n          results.push(origin - u);\r\n          return;\r\n        } else {\r\n          results.push(origin - u);\r\n          results.push(origin - u);\r\n          results.push(origin + 2 * u);\r\n          return;\r\n        }\r\n      }\r\n    } else if (D <= 0) {      // three real solutions\r\n      const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));\r\n      const t = 2 * Math.sqrt(-p);\r\n      results.push(origin + t * Math.cos(phi));\r\n      results.push(origin - t * Math.cos(phi + Math.PI / 3));\r\n      results.push(origin - t * Math.cos(phi - Math.PI / 3));\r\n      this.improveRoots(c, 3, results, false);\r\n\r\n      return;\r\n    } else {    // One real solution\r\n      const sqrt_D = Math.sqrt(D);\r\n      const u = this.cbrt(sqrt_D - q);\r\n      const v = -(this.cbrt(sqrt_D + q));\r\n      results.push(origin + u + v);\r\n      this.improveRoots(c, 3, results, false);\r\n      return;\r\n    }\r\n  }\r\n  /** Compute roots of cubic 'c[0] + c[1] * x + c[2] * x^2 + c[3] * x^3 */\r\n  public static appendCubicRoots(c: Float64Array | number[], results: GrowableFloat64Array) {\r\n    this.appendCubicRootsUnsorted(c, results);\r\n    results.sort();\r\n  }\r\n\r\n  /** Compute roots of quartic 'c[0] + c[1] * x + c[2] * x^2 + c[3] * x^3 + c[4] * x^4 */\r\n  public static appendQuarticRoots(c: Float64Array | number[], results: GrowableFloat64Array) {\r\n    const coffs = new Float64Array(4); // at various times .. coefficients of quadratic an cubic intermediates.\r\n    let u: number;\r\n    let v: number;\r\n    let A: number;\r\n    let B: number;\r\n    let C: number;\r\n    let D: number;\r\n    let sq_A: number;\r\n    let p: number;\r\n    let q: number;\r\n    let r: number;\r\n\r\n    // normal form: x^4 + Ax^3 + Bx^2 + Cx + D = 0\r\n\r\n    const coffScale = new Float64Array(1);\r\n    if (!this.safeDivide(coffScale, 1.0, c[4], 0.0, 0)) {\r\n      this.appendCubicRoots(c, results);\r\n      return;\r\n    }\r\n    A = c[3] * coffScale[0];\r\n    B = c[2] * coffScale[0];\r\n    C = c[1] * coffScale[0];\r\n    D = c[0] * coffScale[0];\r\n    const origin = -0.25 * A;\r\n    /*  substitute x = y - A/4 to eliminate cubic term:\r\n        x^4 + px^2 + qx + r = 0 */\r\n    sq_A = A * A;\r\n    p = -3.0 / 8 * sq_A + B;\r\n    q = 0.125 * sq_A * A - 0.5 * A * B + C;\r\n    r = -3.0 / 256 * sq_A * sq_A + 1.0 / 16 * sq_A * B - 1.0 / 4 * A * C + D;\r\n\r\n    const tempStack = new GrowableFloat64Array();\r\n\r\n    if (this.isZero(r)) {\r\n\r\n      // no absolute term: y(y^3 + py + q) = 0\r\n      coffs[0] = q;\r\n      coffs[1] = p;\r\n      coffs[2] = 0;\r\n      coffs[3] = 1;\r\n      this.appendCubicRootsUnsorted(coffs, results);\r\n      results.push(0); // APPLY ORIGIN ....\r\n      this.addConstant(origin, results);\r\n      return;\r\n    } else {\r\n\r\n      // Solve the resolvent cubic\r\n      coffs[0] = 1.0 / 2 * r * p - 1.0 / 8 * q * q;\r\n      coffs[1] = - r;\r\n      coffs[2] = - 1.0 / 2 * p;\r\n      coffs[3] = 1;\r\n\r\n      this.appendCubicRootsUnsorted(coffs, tempStack);\r\n      const z = this.mostDistantFromMean(tempStack);\r\n\r\n      // ... to build two quadric equations\r\n      u = z * z - r;\r\n      v = 2 * z - p;\r\n\r\n      if (this.isSmallRatio(u, r)) {\r\n        u = 0;\r\n      } else if (u > 0) {\r\n        u = Math.sqrt(u);\r\n      } else {\r\n        return;\r\n      }\r\n\r\n      if (this.isSmallRatio(v, p)) {\r\n        v = 0;\r\n      } else if (v > 0) {\r\n        v = Math.sqrt(v);\r\n      } else {\r\n        for (let i = 0; i < tempStack.length; i++) {\r\n          results.push(tempStack.atUncheckedIndex(i));\r\n        }\r\n        return;\r\n      }\r\n\r\n      coffs[0] = z - u;\r\n      coffs[1] = ((q < 0) ? (-v) : (v));\r\n      coffs[2] = 1;\r\n\r\n      this.appendQuadraticRoots(coffs, results);\r\n\r\n      coffs[0] = z + u;\r\n      coffs[1] = ((q < 0) ? (v) : (-v));\r\n      coffs[2] = 1;\r\n\r\n      this.appendQuadraticRoots(coffs, results);\r\n    }\r\n\r\n    // substitute\r\n    this.addConstant(origin, results);\r\n\r\n    results.sort();\r\n    this.improveRoots(c, 4, results, true);\r\n\r\n    return;\r\n  }\r\n\r\n  private static appendCosSinRadians(c: number, s: number, cosValues: OptionalGrowableFloat64Array, sinValues: OptionalGrowableFloat64Array,\r\n    radiansValues: OptionalGrowableFloat64Array) {\r\n    if (cosValues) cosValues.push(c);\r\n    if (sinValues) sinValues.push(s);\r\n    if (radiansValues) radiansValues.push(Math.atan2(s, c));\r\n  }\r\n\r\n  /**\r\n   * * Solve the simultaneous equations in variables`c` and`s`:\r\n   *   * A line: `alpha + beta*c + gamma*s = 0`\r\n   *   * The unit circle 'c*c + s*s = 1`\r\n   * * Solution values are returned as 0, 1, or 2(c, s) pairs\r\n   * * Return value indicates one of these solution states:\r\n   *   * -2 -- all coefficients identically 0.   The entire c, s plane-- and therefore the entire unit circle-- is a solution.\r\n   *   * -1 -- beta, gamma are zero, alpha is not.There is no line defined.There are no solutions.\r\n   *   * 0 -- the line is well defined, but passes completely outside the unit circle.\r\n   *     * In this case, (c1, s1) is the circle point closest to the line and(c2, s2) is the line point closest to the circle.\r\n   * * 1 -- the line is tangent to the unit circle.\r\n   *   * Tangency is determined by tolerances, which calls a \"close approach\" point a tangency.\r\n   *    * (c1, s1) is the closest circle point\r\n   *    * (c2, s2) is the line point.\r\n   * * 2 -- two simple intersections.\r\n   * @param alpha constant coefficient on line\r\n   * @param beta x cosine coefficient on line\r\n   * @param gamma y sine coefficient on line\r\n   * @param relTol relative tolerance for tangencies\r\n   * @param cosValues (caller allocated) array to receive solution `c` values\r\n   * @param sinValues (caller allocated) array to receive solution `s` values\r\n   * @param radiansValues (caller allocated) array to receive solution radians values.\r\n   */\r\n  public static appendImplicitLineUnitCircleIntersections(alpha: number, beta: number, gamma: number,\r\n    cosValues: OptionalGrowableFloat64Array, sinValues: OptionalGrowableFloat64Array, radiansValues: OptionalGrowableFloat64Array,\r\n    relTol: number = 1.0e-14): number {\r\n\r\n    let twoTol: number;\r\n    const delta2 = beta * beta + gamma * gamma;\r\n    const alpha2 = alpha * alpha;\r\n    let solutionType = 0;\r\n\r\n    if (relTol < 0.0) {\r\n      twoTol = 0.0;\r\n    } else {\r\n      twoTol = 2.0 * relTol;\r\n    }\r\n\r\n    if (delta2 <= 0.0) {\r\n      solutionType = (alpha === 0) ? -2 : -1;\r\n    } else {\r\n      const lambda = - alpha / delta2;\r\n      const a2 = alpha2 / delta2;\r\n      const D2 = 1.0 - a2;\r\n      if (D2 < -twoTol) {\r\n        const delta = Math.sqrt(delta2);\r\n        const iota = (alpha < 0) ? (1.0 / delta) : (-1.0 / delta);\r\n        this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);\r\n        this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);\r\n        solutionType = 0;\r\n      } else if (D2 < twoTol) {\r\n        const delta = Math.sqrt(delta2);\r\n        const iota = (alpha < 0) ? (1.0 / delta) : (- 1.0 / delta);\r\n        this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);\r\n        this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);\r\n        solutionType = 1;\r\n      } else {\r\n        const mu = Math.sqrt(D2 / delta2);\r\n        /* c0,s0 = closest approach of line to origin */\r\n        const c0 = lambda * beta;\r\n        const s0 = lambda * gamma;\r\n        this.appendCosSinRadians(c0 - mu * gamma, s0 + mu * beta, cosValues, sinValues, radiansValues);\r\n        this.appendCosSinRadians(c0 + mu * gamma, s0 - mu * beta, cosValues, sinValues, radiansValues);\r\n        solutionType = 2;\r\n      }\r\n    }\r\n    return solutionType;\r\n  }\r\n}\r\n/**\r\n * manipulations of polynomials with where `coff[i]` multiplies x^i\r\n * @internal\r\n */\r\n\r\nexport class PowerPolynomial {\r\n\r\n  /** Evaluate a standard basis polynomial at `x`, with `degree` possibly less than `coff.length` */\r\n  public static degreeKnownEvaluate(coff: Float64Array, degree: number, x: number): number {\r\n    if (degree < 0) {\r\n      return 0.0;\r\n    }\r\n    let p = coff[degree];\r\n    for (let i = degree - 1; i >= 0; i--)\r\n      p = x * p + coff[i];\r\n    return p;\r\n  }\r\n  /** Evaluate the standard basis polynomial of degree `coff.length` at `x` */\r\n  public static evaluate(coff: Float64Array, x: number): number {\r\n    const degree = coff.length - 1;\r\n    return this.degreeKnownEvaluate(coff, degree, x);\r\n  }\r\n  /**\r\n   * * Accumulate Q*scale into P.Both are treated as full degree.\r\n   * * (Expect Address exceptions if P is smaller than Q)\r\n   * * Returns degree of result as determined by comparing trailing coefficients to zero\r\n   */\r\n  public static accumulate(coffP: Float64Array, coffQ: Float64Array, scaleQ: number): number {\r\n    let degreeP = coffP.length - 1;\r\n    const degreeQ = coffQ.length - 1;\r\n\r\n    for (let i = 0; i <= degreeQ; i++) {\r\n      coffP[i] += scaleQ * coffQ[i];\r\n    }\r\n\r\n    while (degreeP >= 0 && coffP[degreeP] === 0.0) {\r\n      degreeP--;\r\n    }\r\n    return degreeP;\r\n  }\r\n  /** Zero all coefficients */\r\n  public static zero(coff: Float64Array) {\r\n    for (let i = 0; i < coff.length; i++) {\r\n      coff[i] = 0.0;\r\n    }\r\n  }\r\n}\r\n/**\r\n * manipulation of polynomials with powers of sine and cosine\r\n * @internal\r\n */\r\nexport class TrigPolynomial {\r\n  // tolerance for small angle decision.\r\n  private static readonly _smallAngle: number = 1.0e-11;\r\n\r\n  /** Standard Basis coefficients for rational sine numerator. */\r\n  public static readonly S = Float64Array.from([0.0, 2.0, -2.0]);\r\n  /** Standard Basis coefficients for rational cosine numerator. */\r\n  public static readonly C = Float64Array.from([1.0, -2.0]);\r\n  /** Standard Basis coefficients for rational denominator. */\r\n  public static readonly W = Float64Array.from([1.0, -2.0, 2.0]);\r\n  /** Standard Basis coefficients for cosine*weight numerator */\r\n  public static readonly CW = Float64Array.from([1.0, -4.0, 6.0, -4.0]);\r\n  /** Standard Basis coefficients for sine*weight numerator */\r\n  public static readonly SW = Float64Array.from([0.0, 2.0, -6.0, 8.0, -4.0]);\r\n  /** Standard Basis coefficients for sine*cosine numerator */\r\n  public static readonly SC = Float64Array.from([0.0, 2.0, -6.0, 4.0]);\r\n  /** Standard Basis coefficients for sine^2 numerator */\r\n  public static readonly SS = Float64Array.from([0.0, 0.0, 4.0, -8.0, 4.0]);\r\n  /** Standard Basis coefficients for cosine^2 numerator */\r\n  public static readonly CC = Float64Array.from([1.0, -4.0, 4.0]);\r\n  /** Standard Basis coefficients for weight^2 */\r\n  public static readonly WW = Float64Array.from([1.0, -4.0, 8.0, -8.0, 4.0]);\r\n  /** Standard Basis coefficients for (Math.Cos^2 - sine^2) numerator */\r\n  public static readonly CCminusSS = Float64Array.from([1.0, -4.0, 0.0, 8.0, -4.0]);\r\n\r\n  /**\r\n   *  Solve a polynomial created from trigonometric condition using\r\n   * Trig.S, Trig.C, Trig.W.  Solution logic includes inferring angular roots\r\n   * corresponding zero leading coefficients (roots at infinity)\r\n   * @param coff Coefficients\r\n   * @param nominalDegree degree of the polynomial under most complex\r\n   *     root case.  If there are any zero coefficients up to this degree, a single root\r\n   *     \"at infinity\" is recorded as its corresponding angular parameter at negative pi/2\r\n   * @param referenceCoefficient A number which represents the size of coefficients\r\n   *     at various stages of computation.  A small fraction of this will be used as a zero\r\n   *     tolerance\r\n   * @param angles Roots are placed here. Assumed preallocated with adequate size.\r\n   * @param numRoots Number of roots  .  Zero roots is possible. (Passed as array of size\r\n   * one to pass-by-reference)\r\n   * Returns false if equation is all zeros.   This usually means any angle is a solution.\r\n   */\r\n  public static solveAngles(coff: Float64Array, nominalDegree: number, referenceCoefficient: number,\r\n    radians: number[]): boolean {\r\n    let maxCoff = Math.abs(referenceCoefficient);\r\n    let a;\r\n    radians.length = 0;\r\n    const relTol = this._smallAngle;\r\n\r\n    for (let i = 0; i <= nominalDegree; i++) {\r\n      a = Math.abs(coff[i]);\r\n      if (a > maxCoff) {\r\n        maxCoff = a;\r\n      }\r\n    }\r\n    const coffTol = relTol * maxCoff;\r\n    let degree = nominalDegree;\r\n    while (degree > 0 && (Math.abs(coff[degree]) <= coffTol)) {\r\n      degree--;\r\n    }\r\n    // let status = false;\r\n    const roots = new GrowableFloat64Array();\r\n    if (degree === -1) {\r\n      // Umm.   Dunno.   Nothing there.\r\n      // status = false;\r\n    } else {\r\n      // status = true;\r\n      if (degree === 0) {\r\n        // p(t) is a nonzero constant\r\n        // No roots, but not degenerate.\r\n        // status = true;\r\n      } else if (degree === 1) {\r\n        // p(t) = coff[1] * t + coff[0]...\r\n        roots.push(- coff[0] / coff[1]);\r\n      } else if (degree === 2) {\r\n        AnalyticRoots.appendQuadraticRoots(coff, roots);\r\n      } else if (degree === 3) {\r\n        AnalyticRoots.appendCubicRoots(coff, roots);\r\n      } else if (degree === 4) {\r\n        AnalyticRoots.appendQuarticRoots(coff, roots);\r\n      } else {\r\n        // TODO: WILL WORK WITH BEZIER SOLVER\r\n        // status = false;\r\n      }\r\n      if (roots.length > 0) {\r\n        // Each solution t represents an angle with\r\n        //  Math.Cos(theta)=C(t)/W(t),  ,sin(theta)=S(t)/W(t)\r\n        // Division by W has no effect on Atan2 calculations, so we just compute S(t),C(t)\r\n        for (let i = 0; i < roots.length; i++) {\r\n          const ss = PowerPolynomial.evaluate(this.S, roots.atUncheckedIndex(i));\r\n          const cc = PowerPolynomial.evaluate(this.C, roots.atUncheckedIndex(i));\r\n          radians.push(Math.atan2(ss, cc));\r\n        }\r\n\r\n        // Each leading zero at the front of the coefficients corresponds to a root at -PI/2.\r\n        // Only make one entry....\r\n        // for (int i = degree; i < nominalDegree; i++)\r\n        if (degree < nominalDegree) {\r\n          radians.push(-0.5 * Math.PI);\r\n        }\r\n      }\r\n    }\r\n    return radians.length > 0;\r\n  }\r\n  private static readonly _coefficientRelTol = 1.0e-12;\r\n  /**\r\n   * Compute intersections of unit circle `x ^ 2 + y 2 = 1` with general quadric\r\n   * `axx * x ^ 2 + axy * x * y + ayy * y ^ 2 + ax * x + ay * y + a1 = 0`\r\n   * Solutions are returned as angles.Sine and Cosine of the angles are the x, y results.\r\n   * @param axx  Coefficient of x ^ 2\r\n   * @param axy  Coefficient of xy\r\n   * @param ayy  Coefficient of y ^ 2\r\n   * @param ax  Coefficient of x\r\n   * @param ay  Coefficient of y\r\n   * @param a1  Constant coefficient\r\n   * @param angles  solution angles\r\n   * @param numAngle  number of solution angles(Passed as array to make changes to reference)\r\n   */\r\n  public static solveUnitCircleImplicitQuadricIntersection(axx: number, axy: number, ayy: number,\r\n    ax: number, ay: number, a1: number, radians: number[]): boolean {\r\n    const Coffs = new Float64Array(5);\r\n    PowerPolynomial.zero(Coffs);\r\n    let degree = 2;\r\n    if (Geometry.hypotenuseXYZ(axx, axy, ayy) > TrigPolynomial._coefficientRelTol * Geometry.hypotenuseXYZ(ax, ay, a1)) {\r\n      PowerPolynomial.accumulate(Coffs, this.CW, ax);\r\n      PowerPolynomial.accumulate(Coffs, this.SW, ay);\r\n      PowerPolynomial.accumulate(Coffs, this.WW, a1);\r\n      PowerPolynomial.accumulate(Coffs, this.SS, ayy);\r\n      PowerPolynomial.accumulate(Coffs, this.CC, axx);\r\n      PowerPolynomial.accumulate(Coffs, this.SC, axy);\r\n      degree = 4;\r\n    } else {\r\n      PowerPolynomial.accumulate(Coffs, this.C, ax);\r\n      PowerPolynomial.accumulate(Coffs, this.S, ay);\r\n      PowerPolynomial.accumulate(Coffs, this.W, a1);\r\n      degree = 2;\r\n    }\r\n\r\n    let maxCoff = 0.0;\r\n    maxCoff = Math.max(maxCoff,\r\n      Math.abs(axx),\r\n      Math.abs(ayy),\r\n      Math.abs(axy),\r\n      Math.abs(ax),\r\n      Math.abs(ay),\r\n      Math.abs(a1));\r\n\r\n    const b = this.solveAngles(Coffs, degree, maxCoff, radians);\r\n    /*\r\n    for (const theta of angles) {\r\n      const c = theta.cos();\r\n      const s = theta.sin();\r\n      console.log({\r\n        angle: theta, co: c, si: s,\r\n        f: axx * c * c + axy * c * s + ayy * s * s + ax * c + ay * s + a1});\r\n  } */\r\n\r\n    return b;\r\n  }\r\n  /**\r\n   * Compute intersections of unit circle x^2 + y 2 = 1 with the ellipse\r\n   *         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)\r\n   * Solutions are returned as angles in the ellipse space.\r\n   * @param cx center x\r\n   * @param cy center y\r\n   * @param ux 0 degree vector x\r\n   * @param uy 0 degree vector y\r\n   * @param vx 90 degree vector x\r\n   * @param vy 90 degree vector y\r\n   * @param ellipseRadians solution angles in ellipse parameter space\r\n   * @param circleRadians solution angles in circle parameter space\r\n   */\r\n  public static solveUnitCircleEllipseIntersection(cx: number, cy: number, ux: number, uy: number,\r\n    vx: number, vy: number, ellipseRadians: number[], circleRadians: number[]): boolean {\r\n    circleRadians.length = 0;\r\n    const acc = ux * ux + uy * uy;\r\n    const acs = 2.0 * (ux * vx + uy * vy);\r\n    const ass = vx * vx + vy * vy;\r\n    const ac = 2.0 * (ux * cx + uy * cy);\r\n    const asi = 2.0 * (vx * cx + vy * cy);\r\n    const a = cx * cx + cy * cy - 1.0;\r\n    const status = this.solveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);\r\n    for (const radians of ellipseRadians) {\r\n      const cc = Math.cos(radians);\r\n      const ss = Math.sin(radians);\r\n      const x = cx + ux * cc + vx * ss;\r\n      const y = cy + uy * cc + vy * ss;\r\n      circleRadians.push(Math.atan2(y, x));\r\n    }\r\n    return status;\r\n  }\r\n  /**\r\n   * Compute intersections of unit circle x^2 + y 2 = w^2 with the ellipse\r\n   *         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)/ (cw + uw Math.Cos + vw * Math.Sin)\r\n   * Solutions are returned as angles in the ellipse space.\r\n   * @param cx center x\r\n   * @param cy center y\r\n   * @param cw center w\r\n   * @param ux 0 degree vector x\r\n   * @param uy 0 degree vector y\r\n   * @param uw 0 degree vector w\r\n   * @param vx 90 degree vector x\r\n   * @param vy 90 degree vector y\r\n   * @param vw 90 degree vector w\r\n   * @param ellipseRadians solution angles in ellipse parameter space\r\n   * @param circleRadians solution angles in circle parameter space\r\n   */\r\n  public static solveUnitCircleHomogeneousEllipseIntersection(cx: number, cy: number, cw: number,\r\n    ux: number, uy: number, uw: number,\r\n    vx: number, vy: number, vw: number,\r\n    ellipseRadians: number[], circleRadians: number[]): boolean {\r\n    circleRadians.length = 0;\r\n    const acc = ux * ux + uy * uy - uw * uw;\r\n    const acs = 2.0 * (ux * vx + uy * vy - uw * vw);\r\n    const ass = vx * vx + vy * vy - vw * vw;\r\n    const ac = 2.0 * (ux * cx + uy * cy - uw * cw);\r\n    const asi = 2.0 * (vx * cx + vy * cy - vw * cw);\r\n    const a = cx * cx + cy * cy - cw * cw;\r\n    const status = this.solveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);\r\n    for (const radians of ellipseRadians) {\r\n      const cc = Math.cos(radians);\r\n      const ss = Math.sin(radians);\r\n      const x = cx + ux * cc + vx * ss;\r\n      const y = cy + uy * cc + vy * ss;\r\n      circleRadians.push(Math.atan2(y, x));\r\n    }\r\n    return status;\r\n  }\r\n}\r\n/**\r\n * static methods for commonly appearing sets of equations in 2 or 3 variables\r\n * @public\r\n */\r\nexport class SmallSystem {\r\n  /**\r\n   * Return true if lines (a0,a1) to (b0, b1) have a simple intersection.\r\n   * Return the fractional (not xy) coordinates in result.x, result.y\r\n   * @param a0 start point of line a\r\n   * @param a1  end point of line a\r\n   * @param b0  start point of line b\r\n   * @param b1 end point of line b\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static lineSegment2dXYTransverseIntersectionUnbounded(a0: Point2d, a1: Point2d, b0: Point2d, b1: Point2d,\r\n    result: Vector2d): boolean {\r\n    const ux = a1.x - a0.x;\r\n    const uy = a1.y - a0.y;\r\n\r\n    const vx = b1.x - b0.x;\r\n    const vy = b1.y - b0.y;\r\n\r\n    const cx = b0.x - a0.x;\r\n    const cy = b0.y - a0.y;\r\n\r\n    const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\r\n    const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\r\n    const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\r\n    const s = Geometry.conditionalDivideFraction(cv, uv);\r\n    const t = Geometry.conditionalDivideFraction(cu, uv);\r\n    if (s !== undefined && t !== undefined) {\r\n      result.set(s, -t);\r\n      return true;\r\n    }\r\n    result.set(0, 0);\r\n    return false;\r\n  }\r\n  /**\r\n   * * (ax0,ay0) to (ax0+ux,ay0+uy) are line A.\r\n   * * (bx0,by0) to (bx0+vx,by0+vy) are lineB.\r\n   * * Return true if the lines have a simple intersection.\r\n   * * Return the fractional (not xy) coordinates in result.x, result.y\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static lineSegmentXYUVTransverseIntersectionUnbounded(\r\n    ax0: number, ay0: number, ux: number, uy: number,\r\n    bx0: number, by0: number, vx: number, vy: number,\r\n    result: Vector2d): boolean {\r\n\r\n    const cx = bx0 - ax0;\r\n    const cy = by0 - ay0;\r\n\r\n    const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\r\n    const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\r\n    const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\r\n    const s = Geometry.conditionalDivideFraction(cv, uv);\r\n    const t = Geometry.conditionalDivideFraction(cu, uv);\r\n    if (s !== undefined && t !== undefined) {\r\n      result.set(s, -t);\r\n      return true;\r\n    }\r\n    result.set(0, 0);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts\r\n   * Return the fractional (not xy) coordinates in result.x, result.y\r\n   * @param a0 start point of line a\r\n   * @param a1  end point of line a\r\n   * @param b0  start point of line b\r\n   * @param b1 end point of line b\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static lineSegment3dXYTransverseIntersectionUnbounded(a0: Point3d, a1: Point3d, b0: Point3d, b1: Point3d,\r\n    result: Vector2d): boolean {\r\n    const ux = a1.x - a0.x;\r\n    const uy = a1.y - a0.y;\r\n\r\n    const vx = b1.x - b0.x;\r\n    const vy = b1.y - b0.y;\r\n\r\n    const cx = b0.x - a0.x;\r\n    const cy = b0.y - a0.y;\r\n\r\n    const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\r\n    const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\r\n    const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\r\n    const s = Geometry.conditionalDivideFraction(cv, uv);\r\n    const t = Geometry.conditionalDivideFraction(cu, uv);\r\n    if (s !== undefined && t !== undefined) {\r\n      result.set(s, -t);\r\n      return true;\r\n    }\r\n    result.set(0, 0);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts of WEIGHTED 4D Points\r\n   * Return the fractional (not xy) coordinates in result.x, result.y\r\n   * @param hA0 homogeneous start point of line a\r\n   * @param hA1 homogeneous end point of line a\r\n   * @param hB0 homogeneous start point of line b\r\n   * @param hB1 homogeneous end point of line b\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static lineSegment3dHXYTransverseIntersectionUnbounded(hA0: Point4d, hA1: Point4d, hB0: Point4d, hB1: Point4d, result?: Vector2d): Vector2d | undefined {\r\n    // Considering only x,y,w parts....\r\n    // Point Q along B is (in full homogeneous)  `(1-lambda) B0 + lambda 1`\r\n    // PointQ is colinear with A0,A1 when the determinant det (A0,A1,Q) is zero.  (Each column takes xyw parts)\r\n    const alpha0 = Geometry.tripleProduct(\r\n      hA0.x, hA1.x, hB0.x,\r\n      hA0.y, hA1.y, hB0.y,\r\n      hA0.w, hA1.w, hB0.w);\r\n    const alpha1 = Geometry.tripleProduct(\r\n      hA0.x, hA1.x, hB1.x,\r\n      hA0.y, hA1.y, hB1.y,\r\n      hA0.w, hA1.w, hB1.w);\r\n    const fractionB = Geometry.conditionalDivideFraction(-alpha0, alpha1 - alpha0);\r\n    if (fractionB !== undefined) {\r\n      const beta0 = Geometry.tripleProduct(\r\n        hB0.x, hB1.x, hA0.x,\r\n        hB0.y, hB1.y, hA0.y,\r\n        hB0.w, hB1.w, hA0.w);\r\n      const beta1 = Geometry.tripleProduct(\r\n        hB0.x, hB1.x, hA1.x,\r\n        hB0.y, hB1.y, hA1.y,\r\n        hB0.w, hB1.w, hA1.w);\r\n      const fractionA = Geometry.conditionalDivideFraction(-beta0, beta1 - beta0);\r\n      if (fractionA !== undefined)\r\n        return Vector2d.create(fractionA, fractionB, result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Return the line fraction at which the (homogeneous) line is closest to a space point as viewed in xy only.\r\n   * @param hA0 homogeneous start point of line a\r\n   * @param hA1 homogeneous end point of line a\r\n   * @param spacePoint homogeneous point in space\r\n   */\r\n  public static lineSegment3dHXYClosestPointUnbounded(hA0: Point4d, hA1: Point4d, spacePoint: Point4d): number | undefined {\r\n    // Considering only x,y,w parts....\r\n    // weighted difference of (A1 w0 - A0 w1) is (cartesian) tangent vector along the line as viewed.\r\n    // The perpendicular (pure vector) W = (-y,x) flip is the direction of projection\r\n    // Point Q along A is (in full homogeneous)  `(1-lambda) A0 + lambda 1 A1`\r\n    // PointQ is colinear with spacePoint and and W when the xyw homogeneous determinant | Q W spacePoint | is zero.\r\n    const tx = hA1.x * hA0.w - hA0.x * hA1.w;\r\n    const ty = hA1.y * hA0.w - hA0.y * hA1.w;\r\n    const det0 = Geometry.tripleProduct(\r\n      hA0.x, -ty, spacePoint.x,\r\n      hA0.y, tx, spacePoint.y,\r\n      hA0.w, 0, spacePoint.w);\r\n    const det1 = Geometry.tripleProduct(\r\n      hA1.x, -ty, spacePoint.x,\r\n      hA1.y, tx, spacePoint.y,\r\n      hA1.w, 0, spacePoint.w);\r\n    return Geometry.conditionalDivideFraction(-det0, det1 - det0);\r\n  }\r\n\r\n  /**\r\n   * Return the line fraction at which the line is closest to a space point as viewed in xy only.\r\n   * @param pointA0 start point\r\n   * @param pointA1 end point\r\n   * @param spacePoint homogeneous point in space\r\n   */\r\n  public static lineSegment3dXYClosestPointUnbounded(pointA0: XAndY, pointA1: XAndY, spacePoint: XAndY): number | undefined {\r\n    // Considering only x,y parts....\r\n    const ux = pointA1.x - pointA0.x;\r\n    const uy = pointA1.y - pointA0.y;\r\n    const uu = ux * ux + uy * uy;\r\n    const vx = spacePoint.x - pointA0.x;\r\n    const vy = spacePoint.y - pointA0.y;\r\n    const uv = ux * vx + uy * vy;\r\n    return Geometry.conditionalDivideFraction(uv, uu);\r\n  }\r\n\r\n  /**\r\n   * Return the line fraction at which the line is closest to a space point\r\n   * @param pointA0 start point\r\n   * @param pointA1 end point\r\n   * @param spacePoint homogeneous point in space\r\n   */\r\n  public static lineSegment3dClosestPointUnbounded(pointA0: Point3d, pointA1: Point3d, spacePoint: Point3d): number | undefined {\r\n    // Considering only x,y parts....\r\n    const ux = pointA1.x - pointA0.x;\r\n    const uy = pointA1.y - pointA0.y;\r\n    const uz = pointA1.z - pointA0.z;\r\n    const uu = ux * ux + uy * uy + uz * uz;\r\n    const vx = spacePoint.x - pointA0.x;\r\n    const vy = spacePoint.y - pointA0.y;\r\n    const vz = spacePoint.z - pointA0.z;\r\n    const uv = ux * vx + uy * vy + uz * vz;\r\n    return Geometry.conditionalDivideFraction(uv, uu);\r\n  }\r\n\r\n  /**\r\n   * Return true if lines (a0,a1) to (b0, b1) have closest approach (go by each other) in 3d\r\n   * Return the fractional (not xy) coordinates in result.x, result.y\r\n   * @param a0 start point of line a\r\n   * @param a1  end point of line a\r\n   * @param b0  start point of line b\r\n   * @param b1 end point of line b\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static lineSegment3dClosestApproachUnbounded(a0: Point3d, a1: Point3d, b0: Point3d, b1: Point3d,\r\n    result: Vector2d): boolean {\r\n    return this.ray3dXYZUVWClosestApproachUnbounded(\r\n      a0.x, a0.y, a0.z,\r\n      a1.x - a0.x, a1.y - a0.y, a1.z - a0.z,\r\n      b0.x, b0.y, b0.z,\r\n      b1.x - b0.x, b1.y - b0.y, b1.z - b0.z,\r\n      result);\r\n  }\r\n  /**\r\n   * Return true if lines (a0,a1) to (b0, b1) have closest approach (go by each other) in 3d\r\n   * Return the fractional (not xy) coordinates as x and y parts of a Point2d.\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static ray3dXYZUVWClosestApproachUnbounded(\r\n    ax: number, ay: number, az: number, au: number, av: number, aw: number,\r\n    bx: number, by: number, bz: number, bu: number, bv: number, bw: number,\r\n    result: Vector2d): boolean {\r\n\r\n    const cx = bx - ax;\r\n    const cy = by - ay;\r\n    const cz = bz - az;\r\n\r\n    const uu = Geometry.hypotenuseSquaredXYZ(au, av, aw);\r\n    const vv = Geometry.hypotenuseSquaredXYZ(bu, bv, bw);\r\n    const uv = Geometry.dotProductXYZXYZ(au, av, aw, bu, bv, bw);\r\n    const cu = Geometry.dotProductXYZXYZ(cx, cy, cz, au, av, aw);\r\n    const cv = Geometry.dotProductXYZXYZ(cx, cy, cz, bu, bv, bw);\r\n    return SmallSystem.linearSystem2d(uu, -uv, uv, -vv, cu, cv, result);\r\n  }\r\n  /**\r\n   * Solve the pair of linear equations\r\n   * * `ux * x + vx + y = cx`\r\n   * * `uy * x + vy * y = cy`\r\n   * @param ux xx coefficient\r\n   * @param vx xy coefficient\r\n   * @param uy yx coefficient\r\n   * @param vy yy coefficient\r\n   * @param cx x right hand side\r\n   * @param cy y right hand side\r\n   * @param result (x,y) solution.  (MUST be preallocated by caller)\r\n   */\r\n  public static linearSystem2d(\r\n    ux: number, vx: number, // first row of matrix\r\n    uy: number, vy: number, // second row of matrix\r\n    cx: number, cy: number, // right side\r\n    result: Vector2d): boolean {\r\n    const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\r\n    const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\r\n    const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\r\n    const s = Geometry.conditionalDivideFraction(cv, uv);\r\n    const t = Geometry.conditionalDivideFraction(cu, uv);\r\n    if (s !== undefined && t !== undefined) {\r\n      result.set(s, t);\r\n      return true;\r\n    }\r\n    result.set(0, 0);\r\n    return false;\r\n  }\r\n  /**\r\n   * Solve a linear system\r\n   * * x equation: `ux *u * vx * v + wx * w = cx`\r\n   * * y equation: `uy *u * vy * v + wy * w = cy`\r\n   * * z equation: `uz *u * vz * v + wz * w = cz`\r\n   * @param axx row 0, column 0 coefficient\r\n   * @param axy row 0, column 1 coefficient\r\n   * @param axz row 0, column 1 coefficient\r\n   * @param ayx row 1, column 0 coefficient\r\n   * @param ayy row 1, column 1 coefficient\r\n   * @param ayz row 1, column 2 coefficient\r\n   * @param azx row 2, column 0 coefficient\r\n   * @param azy row 2, column 1 coefficient\r\n   * @param azz row 2, column 2 coefficient\r\n   * @param cx right hand side row 0 coefficient\r\n   * @param cy right hand side row 1 coefficient\r\n   * @param cz right hand side row 2 coefficient\r\n   * @param result optional result.\r\n   */\r\n  public static linearSystem3d(\r\n    axx: number, axy: number, axz: number, // first row of matrix\r\n    ayx: number, ayy: number, ayz: number, // second row of matrix\r\n    azx: number, azy: number, azz: number, // second row of matrix\r\n    cx: number, cy: number, cz: number, // right side\r\n    result?: Vector3d): Vector3d | undefined {\r\n    // determinants of various combinations of columns ...\r\n    const detXYZ = Geometry.tripleProduct(axx, ayx, azx, axy, ayy, azy, axz, ayz, azz);\r\n    const detCYZ = Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, axz, ayz, azz);\r\n    const detXCZ = Geometry.tripleProduct(axx, ayx, azx, cx, cy, cz, axz, ayz, azz);\r\n    const detXYC = Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, cx, cy, cz);\r\n    const s = Geometry.conditionalDivideFraction(detCYZ, detXYZ);\r\n    const t = Geometry.conditionalDivideFraction(detXCZ, detXYZ);\r\n    const u = Geometry.conditionalDivideFraction(detXYC, detXYZ);\r\n    if (s !== undefined && t !== undefined && t !== undefined) {\r\n      return Vector3d.create(s, t, u, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * * in rowB, replace `rowB[j] += a * rowB[pivot] * rowA[j] / rowA[pivot]` for `j>pivot`\r\n   * @param rowA row that does not change\r\n   * @param pivotIndex index of pivot (divisor) in rowA.\r\n   * @param rowB row where elimination occurs.\r\n   */\r\n  public static eliminateFromPivot(rowA: Float64Array, pivotIndex: number, rowB: Float64Array, a: number): boolean {\r\n    const n = rowA.length;\r\n    let q = Geometry.conditionalDivideFraction(rowB[pivotIndex], rowA[pivotIndex]);\r\n    if (q === undefined) return false;\r\n    q *= a;\r\n    for (let j = pivotIndex + 1; j < n; j++)\r\n      rowB[j] += q * rowA[j];\r\n    return true;\r\n  }\r\n  /**\r\n   * Solve a pair of bilinear equations\r\n   * * First equation: `a0 + b0 * u + c0 * v + d0 * u * v = 0`\r\n   * * Second equation: `a0 + b0 * u + c0 * v + d0 * u * v = 0`\r\n   */\r\n  public static solveBilinearPair(a0: number, b0: number, c0: number, d0: number,\r\n    a1: number, b1: number, c1: number, d1: number): Point2d[] | undefined {\r\n    // constant linear, and quadratic coefficients for c0 + c1 * u + c2 * u*u = 0\r\n    const e0 = Geometry.crossProductXYXY(a0, a1, c0, c1);\r\n    const e1 = Geometry.crossProductXYXY(b0, b1, c0, c1) + Geometry.crossProductXYXY(a0, a1, d0, d1);\r\n    const e2 = Geometry.crossProductXYXY(b0, b1, d0, d1);\r\n    const uRoots = Degree2PowerPolynomial.solveQuadratic(e2, e1, e0);\r\n    if (uRoots === undefined)\r\n      return undefined;\r\n    const uv = [];\r\n    for (const u of uRoots) {\r\n      const v0 = Geometry.conditionalDivideFraction(-(a0 + b0 * u), c0 + d0 * u);\r\n      const v1 = Geometry.conditionalDivideFraction(-(a1 + b1 * u), c1 + d1 * u);\r\n      if (v0 !== undefined)\r\n        uv.push(Point2d.create(u, v0));\r\n      else if (v1 !== undefined)\r\n        uv.push(Point2d.create(u, v1));\r\n    }\r\n    return uv;\r\n  }\r\n}\r\n/**\r\n * * bilinear expression\r\n * * `f(u,v) = a + b * u * c * v + d * u * v`\r\n * @internal\r\n */\r\nexport class BilinearPolynomial {\r\n  /** constant coefficient */\r\n  public a: number;\r\n  /** u coefficient */\r\n  public b: number;\r\n  /** v coefficient */\r\n  public c: number;\r\n  /** uv coefficient */\r\n  public d: number;\r\n  /**\r\n   *\r\n   * @param a constant coefficient\r\n   * @param b `u` coefficient\r\n   * @param c `v` coefficient\r\n   * @param d `u*v` coefficient\r\n   */\r\n  public constructor(a: number, b: number, c: number, d: number) {\r\n    this.a = a;\r\n    this.b = b;\r\n    this.c = c;\r\n    this.d = d;\r\n  }\r\n  /**\r\n   * Evaluate the bilinear expression at u,v\r\n   */\r\n  public evaluate(u: number, v: number): number {\r\n    return this.a + this.b * u + v * (this.c + this.d * u);\r\n  }\r\n  /** Create a bilinear polynomial z=f(u,v) given z values at 00, 10, 01, 11.\r\n   */\r\n  public static createUnitSquareValues(f00: number, f10: number, f01: number, f11: number): BilinearPolynomial {\r\n    return new BilinearPolynomial(f00, f10, f10, f11 - f10 - f01);\r\n  }\r\n  /**\r\n   * Solve the simultaneous equations\r\n   * * `p(u,v) = pValue`\r\n   * * `q(u,v) = qValue`\r\n   * @param p\r\n   * @param pValue\r\n   * @param q\r\n   * @param qValue\r\n   */\r\n  public static solvePair(p: BilinearPolynomial, pValue: number, q: BilinearPolynomial, qValue: number): Point2d[] | undefined {\r\n    return SmallSystem.solveBilinearPair(p.a - pValue, p.b, p.c, p.d,\r\n      q.a - qValue, q.b, q.c, q.d);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\n/** Support class for quadrature -- approximate integrals by summing weighted function values.\r\n * These are filled with x and weight for quadrature between xA and xB\r\n *\r\n * Since quadrature is done in side tight loops, these methods are structured for minimum object\r\n * allocation.\r\n * For methods names setupGauss<N> (where N is a smallish integer), the CALLER creates arrays xMapped and wMapped\r\n * The method installs particular x and weight values.\r\n * @internal\r\n */\r\nexport class Quadrature {\r\n  /** x value for 1 point gauss rule in 0..1 interval */\r\n  public static readonly gaussX1Interval01 = new Float64Array([0.5]);\r\n  /** weight for 1 point gauss rule in 0..1 interval */\r\n  public static readonly gaussW1Interval01 = new Float64Array([1.0]);\r\n\r\n  /** x value for 2 point gauss rule in 0..1 interval */\r\n  public static readonly gaussX2Interval01 = new Float64Array([0.21132486540518708, 0.7886751345948129]);\r\n  /** weight for 2 point gauss rule in 0..1 interval */\r\n  public static readonly gaussW2Interval01 = new Float64Array([0.5, 0.5]);\r\n\r\n  /** x value for 3 point gauss rule in 0..1 interval */\r\n  public static readonly gaussX3Interval01 = new Float64Array([0.1127016653792583, 0.5, 0.8872983346207417]);\r\n  /** weight for 3 point gauss rule in 0..1 interval */\r\n  public static readonly gaussW3Interval01 = new Float64Array([0.2777777777777778, 0.4444444444444444, 0.2777777777777778]);\r\n\r\n  /** x value for 4 point gauss rule in 0..1 interval */\r\n  public static readonly gaussX4Interval01 = new Float64Array([0.06943184420297371, 0.33000947820757187, 0.6699905217924281, 0.9305681557970262]);\r\n  /** weight for 4 point gauss rule in 0..1 interval */\r\n  public static readonly gaussW4Interval01 = new Float64Array([0.17392742256872692, 0.3260725774312731, 0.3260725774312731, 0.17392742256872692]);\r\n\r\n  /** x value for 5 point gauss rule in 0..1 interval */\r\n  public static readonly gaussX5Interval01 = new Float64Array([0.04691007703066802, 0.23076534494715845, 0.5, 0.7692346550528415, 0.9530899229693319]);\r\n  /** weight for 5 point gauss rule in 0..1 interval */\r\n  public static readonly gaussW5Interval01 = new Float64Array([0.11846344252809454, 0.23931433524968324, 0.28444444444444444, 0.23931433524968324, 0.11846344252809454]);\r\n\r\n  /**\r\n   * Given points and weights in a reference interval (usually 0 to 1):\r\n   *\r\n   * * map each xRef[i] to xA + h * xRef[i];\r\n   * * scale each weight wRef[i] to h * wRef[i]\r\n   * * all arrays are assumed to have xRef.length entries.\r\n   * * the return value is xRef.length\r\n   * @param xA beginning of target interval\r\n   * @param h length of target interval\r\n   * @param xRef x coordinates in reference interval\r\n   * @param wRef weights for integration in the reference interval\r\n   * @param xMapped x coordinates to evaluate integrands\r\n   * @param wMapped weights for evaluated integrands\r\n   */\r\n  public static mapWeights(xA: number, h: number, xRef: Float64Array, wRef: Float64Array, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    const n = xRef.length;\r\n    for (let i = 0; i < n; i++) {\r\n      xMapped[i] = xA + h * xRef[i];\r\n      wMapped[i] = h * wRef[i];\r\n    }\r\n    return n;\r\n  }\r\n\r\n  /** Install 1 (ONE) x and weight values for quadrature from xA to xB. */\r\n  public static setupGauss1(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX1Interval01, Quadrature.gaussW1Interval01, xMapped, wMapped);\r\n  }\r\n\r\n  /** Install 2 (TWO) x and weight values for quadrature from xA to xB. */\r\n  public static setupGauss2(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX2Interval01, Quadrature.gaussW2Interval01, xMapped, wMapped);\r\n    /*  // exact formulas for interval xA..xB:\r\n        const x0 = 0.5 * (xA + xB);\r\n            const h = 0.5 * (xB - xA);\r\n            const dx = h / Math.sqrt(3);\r\n            xMapped[0] = x0 - dx; xMapped[1] = x0 + dx;\r\n            wMapped[0] = wMapped[1] = h;\r\n            */\r\n  }\r\n  /** Install 3 (THREE) x and weight values for quadrature from xA to xB. */\r\n  public static setupGauss3(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX3Interval01, Quadrature.gaussW3Interval01, xMapped, wMapped);\r\n    /*  // exact formulas for interval xA..xB:\r\n    const x0 = 0.5 * (xA + xB);\r\n    const h = 0.5 * (xB - xA);\r\n    const a = Math.sqrt(0.6);\r\n    const b = h * 5.0 / 9.0;\r\n    const dx = a * h;\r\n    xMapped[0] = x0 - dx; xMapped[1] = x0; xMapped[2] = x0 + dx;\r\n    wMapped[0] = wMapped[2] = b;\r\n    wMapped[1] = h * 8.0 / 9.0;\r\n    return 3;\r\n    */\r\n  }\r\n\r\n  /** Install 5 (FIVE) x and weight values for quadrature from xA to xB. */\r\n  public static setupGauss5(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX5Interval01, Quadrature.gaussW5Interval01, xMapped, wMapped);\r\n    /*  // exact formulas for interval xA..xB:\r\n    const x0 = 0.5 * (xA + xB);\r\n    const h = 0.5 * (xB - xA);\r\n    const q = 2.0 * Math.sqrt(10.0 / 7.0);\r\n    const b = 13.0 * Math.sqrt(70.0);\r\n    const a1 = h * Math.sqrt(5.0 - q) / 3.0;\r\n    const a2 = h * Math.sqrt(5.0 + q) / 3.0;\r\n    const w1 = h * (322.0 + b) / 900.0;\r\n    const w2 = h * (322.0 - b) / 900;\r\n    const w0 = h * 128.0 / 225.0;\r\n    xMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0; xMapped[3] = x0 + a1; xMapped[4] = x0 + a2;\r\n    wMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w0; wMapped[3] = w1; wMapped[4] = w2;\r\n    return 5;\r\n    */\r\n  }\r\n\r\n  /** Install 4 (FOUR) x and weight values for quadrature from xA to xB. */\r\n  public static setupGauss4(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX4Interval01, Quadrature.gaussW4Interval01, xMapped, wMapped);\r\n    /*  // exact formulas for interval xA..xB:\r\nconst x0 = 0.5 * (xA + xB);\r\nconst h = 0.5 * (xB - xA);\r\nconst q = 2.0 * Math.sqrt(6.0 / 5.0);\r\nconst r = Math.sqrt(30.0);\r\nconst a1 = h * Math.sqrt((3 - q) / 7.0);\r\nconst w1 = h * (18.0 + r) / 36.0;\r\nconst a2 = h * Math.sqrt((3 + q) / 7.0);\r\nconst w2 = h * (18.0 - r) / 36.0;\r\nxMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0 + a1; xMapped[3] = x0 + a2;\r\nwMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w1; wMapped[3] = w2;\r\nreturn 4;\r\n*/\r\n  }\r\n  /** Sum function values with given weights and x values. */\r\n  public static sum1(\r\n    xx: Float64Array,\r\n    ww: Float64Array,\r\n    n: number,\r\n    f: (x: number) => number): number {\r\n    let sum = 0;\r\n    for (let i = 0; i < n; i++)sum += ww[i] * f(xx[i]);\r\n    return sum;\r\n  }\r\n\r\n}\r\n/**\r\n * This class carries public members as needed for users to have gauss points that are used\r\n * in the callers loops.\r\n * @internal\r\n */\r\nexport class GaussMapper {\r\n  /** x values for integration */\r\n  public gaussX: Float64Array;\r\n  /** weights for integration */\r\n  public gaussW: Float64Array;\r\n  /** function to be called (at each interval) to map integration values */\r\n  public mapXAndWFunction: (xA: number, xB: number, xx: Float64Array, ww: Float64Array) => number;\r\n  /** Execute the mapXAndWFunction to set up arrays for integration from xA to xB */\r\n  public mapXAndW(xA: number, xB: number): number {\r\n    return this.mapXAndWFunction(xA, xB, this.gaussX, this.gaussW);\r\n  }\r\n  /** setup gauss arrays.\r\n   * * Number of gauss points must be 1 to 5 (inclusive)\r\n   * @param numGauss requested number of gauss points.\r\n   */\r\n  public constructor(numGaussPoints: number) {\r\n    const maxGauss = 7;  // (As of Nov 2 2018, 7 is a fluffy over-allocation-- the quadrature class only handles up to 5.)\r\n    this.gaussX = new Float64Array(maxGauss);\r\n    this.gaussW = new Float64Array(maxGauss);\r\n    // This sets the number of gauss points.  This integrates exactly for polynomials of (degree 2*numGauss - 1).\r\n    if (numGaussPoints > 5 || numGaussPoints < 1)\r\n      numGaussPoints = 5;\r\n    switch (numGaussPoints) {\r\n      case 1: this.mapXAndWFunction = Quadrature.setupGauss1; break;\r\n      case 2: this.mapXAndWFunction = Quadrature.setupGauss2; break;\r\n      case 3: this.mapXAndWFunction = Quadrature.setupGauss3; break;\r\n      case 4: this.mapXAndWFunction = Quadrature.setupGauss4; break;\r\n      default: this.mapXAndWFunction = Quadrature.setupGauss5; break;\r\n    }\r\n\r\n  }\r\n}\r\n// someday .... http://www.holoborodko.com/pavel/numerical-methods/numerical-integration/overlapped-newton-cotes-quadratures/\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Range1d } from \"../geometry3d/Range\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { Geometry } from \"../Geometry\";\r\n/**\r\n * A Range1d array is a set of intervals, such as occur when a line is clipped to a (nonconvex) polygon\r\n * @internal\r\n */\r\nexport class Range1dArray {\r\n  /** Internal step: Caller supplies rangeA = interval from left operand of set difference {A - B}\r\n   *  ib = lowest possible index of overlapping interval of {B}\r\n   *  Output live parts of rangeA, advancing B over intervals that do not extend beyond {rangeA}\r\n   *  iB is advanced to the first interval whose high is to the right of {rangeA.high}\r\n   */\r\n  private static advanceIntervalDifference(rangeA: Range1d, dataB: Range1d[], iB: number, retVal: Range1d[]) {\r\n    const nB = dataB.length;\r\n    let low = rangeA.low;\r\n    let high = rangeA.high;\r\n    while (iB < nB) {\r\n      const rangeB = dataB[iB];\r\n      if (rangeB.high < low) {\r\n        iB++;\r\n      } else if (rangeB.high <= high) {\r\n        if (rangeB.low > low)\r\n          retVal.push(Range1d.createXX(low, rangeB.low));\r\n        low = rangeB.high;\r\n        iB++;\r\n      } else {\r\n        // B ends beyond rangeA...\r\n        if (rangeB.low < high)\r\n          high = rangeB.low;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (low < high)\r\n      retVal.push(Range1d.createXX(low, high));\r\n\r\n    return retVal;\r\n  }\r\n\r\n  /** Intersect intervals in two pre-sorted sets. Output may NOT be the same as either input. */\r\n  public static differenceSorted(dataA: Range1d[], dataB: Range1d[]): Range1d[] {\r\n    const nA = dataA.length;\r\n    const iB = 0;\r\n    const retVal: Range1d[] = [];\r\n    for (let iA = 0; iA < nA; iA++) {\r\n      Range1dArray.advanceIntervalDifference(dataA[iA], dataB, iB, retVal);\r\n    }\r\n\r\n    return retVal;\r\n  }\r\n\r\n  /** Internal step: Caller ensures rangeA is the \"lower\" interval.\r\n   *  Look rangeB to decide (a) what output interval to create and (b) which read index to advance.\r\n   *  Returns true or false to indicate whether the value associated with rangeA or rangeB should be incremented after this function returns\r\n   */\r\n  private static advanceIntervalIntersection(rangeA: Range1d, rangeB: Range1d, retVal: Range1d[]): boolean {\r\n    if (rangeB.low > rangeA.high) {\r\n      return true;\r\n    } else if (rangeB.high >= rangeA.high) {\r\n      retVal.push(Range1d.createXX(rangeB.low, rangeA.high));\r\n      return true;\r\n    } else {\r\n      retVal.push(Range1d.createXX(rangeB.low, rangeB.high));\r\n      return false;\r\n    }\r\n  }\r\n  /** Boolean intersection among the (presorted) input ranges */\r\n  public static intersectSorted(dataA: Range1d[], dataB: Range1d[]): Range1d[] {\r\n    let iA = 0;\r\n    let iB = 0;\r\n    const nA = dataA.length;\r\n    const nB = dataB.length;\r\n    const retVal: Range1d[] = [];\r\n    while (iA < nA && iB < nB) {\r\n      const rangeA = dataA[iA];\r\n      const rangeB = dataB[iB];\r\n      if (rangeA.low <= rangeB.low) {\r\n        if (Range1dArray.advanceIntervalIntersection(rangeA, rangeB, retVal))\r\n          iA++;\r\n        else\r\n          iB++;\r\n      } else {\r\n        if (Range1dArray.advanceIntervalIntersection(rangeB, rangeA, retVal))\r\n          iB++;\r\n        else\r\n          iA++;\r\n      }\r\n    }\r\n\r\n    return retVal;\r\n  }\r\n\r\n  /** Internal step: Read an interval from the array.\r\n   *  If it overlaps the work interval, advance the work interval, and return true to notify caller to increment read index.\r\n   */\r\n  private static advanceIntervalUnion(workRange: Range1d, source: Range1d[], readIndex: number): boolean {\r\n    if (readIndex >= source.length)\r\n      return false;\r\n    const candidate = source[readIndex];\r\n    if (candidate.low > workRange.high)\r\n      return false;\r\n    if (candidate.high > workRange.high)\r\n      workRange.high = candidate.high;\r\n    return true;\r\n  }\r\n\r\n  /** Boolean union among the (presorted) input ranges */\r\n  public static unionSorted(dataA: Range1d[], dataB: Range1d[]): Range1d[] {\r\n    const nA = dataA.length;\r\n    const nB = dataB.length;\r\n    let iA = 0;\r\n    let iB = 0;\r\n    const retVal: Range1d[] = [];\r\n    while (iA < nA && iB < nB) {\r\n      const rangeA = dataA[iA];\r\n      const rangeB = dataB[iB];\r\n      let workRange: Range1d;\r\n      // Pull from the lower of rangeA and rangeB. This always advances exactly one of the indices -- progress towards getting out.\r\n      if (rangeA.low <= rangeB.low) {\r\n        workRange = rangeA.clone();\r\n        iA++;\r\n      } else {\r\n        workRange = rangeB.clone();\r\n        iB++;\r\n      }\r\n\r\n      let toLoop = true;\r\n      do {\r\n        const resultA = Range1dArray.advanceIntervalUnion(workRange, dataA, iA);\r\n        const resultB = Range1dArray.advanceIntervalUnion(workRange, dataB, iB);\r\n        if (resultA)\r\n          iA++;\r\n        if (resultB)\r\n          iB++;\r\n        if (!(resultA || resultB))\r\n          toLoop = false;\r\n      } while (toLoop);\r\n\r\n      retVal.push(workRange);\r\n    }\r\n\r\n    while (iA < nA)\r\n      retVal.push(dataA[iA++]);\r\n    while (iB < nB)\r\n      retVal.push(dataB[iB++]);\r\n\r\n    return retVal;\r\n  }\r\n\r\n  /** Boolean parity among the (presorted) input ranges */\r\n  public static paritySorted(dataA: Range1d[], dataB: Range1d[]): Range1d[] {\r\n    // Combine the two arrays, and then perform a simplification using simplifySortParity function\r\n    const retVal: Range1d[] = [];\r\n    for (const range of dataA)\r\n      retVal.push(range.clone());\r\n    for (const range of dataB)\r\n      retVal.push(range.clone());\r\n\r\n    // Sort the array\r\n    retVal.sort(compareRange1dLexicalLowHigh);\r\n\r\n    Range1dArray.simplifySortParity(retVal, true);\r\n    return retVal;\r\n  }\r\n\r\n  /** Uses the Range1d specific compare function `compareRange1dLexicalLowHigh` for sorting the array of ranges */\r\n  public static sort(data: Range1d[]) {\r\n    data.sort(compareRange1dLexicalLowHigh);\r\n  }\r\n\r\n  /** Cleans up the array, compressing any overlapping ranges. If removeZeroLengthRanges is set to true, will also remove any Ranges in the form (x, x) */\r\n  public static simplifySortUnion(data: Range1d[], removeZeroLengthRanges: boolean = false) {\r\n    if (data.length < 2)\r\n      return;\r\n\r\n    data.sort(compareRange1dLexicalLowHigh);\r\n\r\n    let currIdx = 0;\r\n    let toInsert = false;\r\n    for (let i = 0; i < data.length; i++) {\r\n      if (i === data.length - 1) {\r\n        if (toInsert) {\r\n          if (!removeZeroLengthRanges || data[i].low !== data[i].high)\r\n            data[currIdx++] = data[i];\r\n        }\r\n        break;\r\n      }\r\n\r\n      if (data[i + 1].low > data[i].high) {\r\n        if (!removeZeroLengthRanges || data[i].low !== data[i].high)\r\n          data[currIdx++] = data[i];\r\n        continue;\r\n      } else {\r\n        data[i + 1].low = data[i].low;\r\n        data[i + 1].high = Math.max(data[i].high, data[i + 1].high);\r\n        toInsert = true;\r\n      }\r\n    }\r\n\r\n    data.length = currIdx;\r\n  }\r\n\r\n  /** Apply parity logic among ranges which are not pre-sorted. */\r\n  public static simplifySortParity(data: Range1d[], removeZeroLengthRanges: boolean = false) {\r\n    const numData: number[] = [];\r\n    for (const range of data) {\r\n      if (range.low !== range.high) {\r\n        numData.push(range.low);\r\n        numData.push(range.high);\r\n      }\r\n    }\r\n    const n = numData.length;\r\n    numData.sort((a: number, b: number): number => {\r\n      if (a < b) return -1;\r\n      if (a > b) return 1;\r\n      return 0;\r\n    });\r\n\r\n    let currIdx = 0;\r\n    let x0;\r\n    let x1;\r\n    for (let i = 0; i < n; i += 2) {\r\n      x0 = numData[i];\r\n      x1 = numData[i + 1];\r\n      if (!removeZeroLengthRanges) {\r\n        Range1d.createXX(x0, x1, data[currIdx++]);\r\n      } else {\r\n        // coalesce intervals that share end and start:\r\n        while (i + 2 < n && numData[i + 2] === x1) {\r\n          i += 2;\r\n          x1 = numData[i + 1];\r\n        }\r\n        if (x1 > x0)\r\n          Range1d.createXX(x0, x1, data[currIdx++]);\r\n      }\r\n    }\r\n\r\n    data.length = currIdx;\r\n  }\r\n\r\n  /** test if value is \"in\" by union rules.\r\n   * * This considers all intervals-- i.e. does not expect or take advantage of sorting.\r\n   */\r\n  public static testUnion(data: Range1d[], value: number): boolean {\r\n    return this.countContainingRanges(data, value) > 0;\r\n  }\r\n  /** test if value is \"in\" by parity rules.\r\n   * * This considers all intervals-- i.e. does not expect or take advantage of sorting.\r\n   */\r\n  public static testParity(data: Range1d[], value: number): boolean {\r\n    let inside = false;\r\n    for (const range of data) {\r\n      if (range.containsX(value))\r\n        inside = !inside;\r\n    }\r\n    return inside;\r\n  }\r\n\r\n  /** linear search to count number of intervals which contain `value`.\r\n   */\r\n  public static countContainingRanges(data: Range1d[], value: number): number {\r\n    let n = 0;\r\n    for (const range of data) {\r\n      if (range.containsX(value))\r\n        n++;\r\n    }\r\n    return n;\r\n  }\r\n\r\n  /** return an array with all the low and high values of all the ranges.\r\n   * @param data array of ranges.\r\n   * @param sort optionally request immediate sort.\r\n   * @param compress optionally request removal of duplicates.\r\n   */\r\n  public static getBreaks(data: Range1d[], result?: GrowableFloat64Array, sort: boolean = false, compress: boolean = false, clear: boolean = true): GrowableFloat64Array {\r\n    if (!result) result = new GrowableFloat64Array(2 * data.length);\r\n    if (clear) result.clear();\r\n    for (const range of data) {\r\n      result.push(range.low);\r\n      result.push(range.high);\r\n    }\r\n    if (sort)\r\n      result.sort();\r\n    if (compress)\r\n      result.compressAdjacentDuplicates();\r\n\r\n    return result;\r\n  }\r\n\r\n  /**  evaluate a point at an array of given fraction values\r\n   * @param data array of ranges.\r\n   * @param initialRangeFraction fraction coordinate applied only to first range. (typically negative)\r\n   * @param rangeFraction fraction within each range.\r\n   * @param includeDegenerateRange if false, skip rangeFraction for 0-length ranges.\r\n   * @param gapFraction fraction within interval from each range high to successor low\r\n   * @param includeDegenerateGap if false, skip rangeFraction for 0-length gaps.\r\n   * @param finalRangeFraction fraction coordinate applied only to last range (typically an extrapolation above)\r\n   * @param result array to receive values\r\n   */\r\n  public static appendFractionalPoints(data: Range1d[], initialRangeFraction: number | undefined, rangeFraction: number | undefined, includeDegenerateRange: boolean,\r\n    gapFraction: number | undefined, includeDegenerateGap: boolean,\r\n    finalRangeFraction: number | undefined, result: GrowableFloat64Array | number[]): GrowableFloat64Array | number[] {\r\n    const numRange = data.length;\r\n    if (numRange > 0) {\r\n      if (undefined !== initialRangeFraction)\r\n        result.push(data[0].fractionToPoint(initialRangeFraction));\r\n      for (let i = 0; i < numRange; i++) {\r\n        if (rangeFraction !== undefined && (includeDegenerateRange || data[i].low !== data[i].high))\r\n          result.push(data[i].fractionToPoint(rangeFraction));\r\n        if (i > 1 && gapFraction !== undefined && (includeDegenerateGap || data[i].low !== data[i].high))\r\n          result.push(Geometry.interpolate(data[i - 1].high, gapFraction, data[i].low));\r\n      }\r\n      if (undefined !== finalRangeFraction)\r\n        result.push(data[numRange - 1].fractionToPoint(finalRangeFraction));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Return a single range constructed with the low of range 0 and high of final range in the set.  */\r\n  public static firstLowToLastHigh(data: Range1d[]): Range1d {\r\n    if (data.length === 0)\r\n      return Range1d.createNull();\r\n    return Range1d.createXX(data[0].low, data[data.length - 1].high);\r\n  }\r\n  /** sum the lengths of all ranges */\r\n  public static sumLengths(data: Range1d[]): number {\r\n    let sum = 0.0;\r\n    for (const range of data) {\r\n      sum += range.length();\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Test if the low,high values are sorted with no overlap.\r\n   * @param data array of ranges.\r\n   * @param strict if true, consider exact high-to-low match as overlap.\r\n   */\r\n  public static isSorted(data: Range1d[], strict: boolean = true): boolean {\r\n    const n = data.length;\r\n    if (strict) {\r\n      for (let i = 0; i + 1 < n; i++) {\r\n        if (data[i].high >= data[i + 1].low)\r\n          return false;\r\n      }\r\n    } else {\r\n      for (let i = 0; i + 1 < n; i++) {\r\n        if (data[i].high > data[i + 1].low)\r\n          return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n/** Checks low's first, then high's\r\n * @internal\r\n */\r\nexport function compareRange1dLexicalLowHigh(a: Range1d, b: Range1d): number {\r\n  if (a.low < b.low) return -1;\r\n  if (a.low > b.low) return 1;\r\n  if (a.high < b.high) return -1;\r\n  if (a.high > b.high) return 1;\r\n  return 0;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\n\r\n// Enumerated type lies outside of TriDiagonalSystem, as TSLint prevented declaration within class\r\nenum DataState {\r\n  RawMatrix,\r\n  FactorOK,\r\n  FactorFailed,\r\n}\r\n/**\r\n * Linear system operations on a matrix with data only on the diagonal and its immediate left and right neighbors\r\n * @internal\r\n */\r\nexport class TriDiagonalSystem {\r\n\r\n  // Lower diagonal, indexed by rows\r\n  private _aLeft: Float64Array;\r\n  // Upper diagonal, indexed by rows\r\n  private _aRight: Float64Array;\r\n  // Main diagonal, indexed by rows\r\n  private _aDiag: Float64Array;\r\n  // Right sude vector\r\n  private _b: Float64Array;\r\n  // Solution vector\r\n  private _x: Float64Array;\r\n\r\n  private _dataState!: DataState;\r\n\r\n  constructor(n: number) {\r\n    this._aLeft = new Float64Array(n);\r\n    this._aDiag = new Float64Array(n);\r\n    this._aRight = new Float64Array(n);\r\n    this._b = new Float64Array(n);\r\n    this._x = new Float64Array(n);\r\n    this.reset();\r\n  }\r\n\r\n  /** Reset to RawMatrix state with all coefficients zero */\r\n  public reset() {\r\n    this._dataState = DataState.RawMatrix;\r\n    const n = this._aDiag.length;\r\n    for (let i = 0; i < n; i++) {\r\n      this._aLeft[i] = this._aRight[i] = this._aDiag[i] = this._b[i] = this._x[i] = 0.0;\r\n    }\r\n  }\r\n  /** Install data in a row of the matrix */\r\n  public setRow(row: number, left: number, diag: number, right: number) {\r\n    this._aLeft[row] = left;\r\n    this._aDiag[row] = diag;\r\n    this._aRight[row] = right;\r\n  }\r\n  /** Add to row of matrix */\r\n  public addToRow(row: number, left: number, diag: number, right: number) {\r\n    this._aLeft[row] += left;\r\n    this._aDiag[row] += diag;\r\n    this._aRight[row] += right;\r\n  }\r\n  /** Install data in the right side (B) vector */\r\n  public setB(row: number, bb: number) {\r\n    this._b[row] = bb;\r\n  }\r\n  /** Add to an entry in the right side (B) vector */\r\n  public addToB(row: number, bb: number) {\r\n    this._b[row] += bb;\r\n  }\r\n  /** Access data from the right side (B) vector */\r\n  public getB(row: number): number {\r\n    return this._b[row];\r\n  }\r\n  /** Install data in the solution (X) vector */\r\n  public setX(row: number, xx: number) {\r\n    this._x[row] = xx;\r\n  }\r\n  /** Access data frin the solution (X) vector */\r\n  public getX(row: number): number {\r\n    return this._x[row];\r\n  }\r\n  /** Get method for matrix and vector order */\r\n  public order(): number {\r\n    return this._aDiag.length;\r\n  }\r\n  /** Compute product of AX and save as B */\r\n  public multiplyAX(): boolean {\r\n    if (this._dataState === DataState.FactorFailed) {\r\n      return false;\r\n    } else if (this._dataState === DataState.FactorOK) {\r\n      const n = this._aDiag.length;\r\n      const nm1 = n - 1;\r\n      for (let i = 0; i < nm1; i++) {\r\n        this._b[i] = this._aDiag[i] * this._x[i] + this._aRight[i] * this._x[i + 1];\r\n      }\r\n      this._b[nm1] = this._aDiag[nm1] * this._x[nm1];\r\n\r\n      for (let i = nm1; i > 0; i--) {\r\n        this._b[i] += this._aLeft[i] * this._b[i - 1];\r\n      }\r\n\r\n      return true;\r\n    } else {\r\n      const n = this._aDiag.length;\r\n      const nm1 = n - 1;\r\n      this._b[0] = this._aDiag[0] * this._x[0] + this._aRight[0] * this._x[1];\r\n      let i;\r\n      for (i = 1; i < nm1; i++) {\r\n        this._b[i] = this._aLeft[i] * this._x[i - 1] + this._aDiag[i] * this._x[i] + this._aRight[i] * this._x[i + 1];\r\n      }\r\n      this._b[nm1] = this._aLeft[nm1] * this._x[n - 2] + this._aDiag[i] * this._x[nm1];\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /** Compute product of AX and save as B */\r\n  public multiplyAXPoints(pointX: Point3d[], pointB: Point3d[]): boolean {\r\n    pointB.length = 0;\r\n    while (pointB.length < pointX.length)\r\n      pointB.push(Point3d.create());\r\n    pointB.length = pointX.length;\r\n\r\n    if (this._dataState === DataState.FactorFailed) {\r\n      return false;\r\n    } else if (this._dataState === DataState.FactorOK) {\r\n\r\n      const n = this._aDiag.length;\r\n      const nm1 = n - 1;\r\n      for (let i = 0; i < nm1; i++) {\r\n        Point3d.createAdd2Scaled(pointX[i], this._aDiag[i], pointX[i + 1], this._aRight[i], pointB[i]);\r\n      }\r\n      Point3d.createScale(pointX[nm1], this._aDiag[nm1], pointB[nm1]);\r\n\r\n      for (let i = nm1; i > 0; i--) {\r\n        pointB[i].plusScaled(pointB[i - 1], this._aLeft[i], pointB[i]);\r\n      }\r\n\r\n      return true;\r\n    } else {\r\n      const n = this._aDiag.length;\r\n      const nm1 = n - 1;\r\n      Point3d.createAdd2Scaled(pointX[0], this._aDiag[0], pointX[1], this._aRight[0], pointB[0]);\r\n      let i;\r\n      for (i = 1; i < nm1; i++) {\r\n        Point3d.createAdd3Scaled(\r\n          pointX[i - 1], this._aLeft[i], pointX[i], this._aDiag[i],\r\n          pointX[i + 1], this._aRight[i],\r\n          pointB[i]);\r\n      }\r\n      Point3d.createAdd2Scaled(pointX[n - 2], this._aLeft[nm1], pointX[nm1], this._aDiag[nm1], pointB[nm1]);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /** Multiply the stored factors together to return to plain matrix form */\r\n  public defactor(): boolean {\r\n    if (this._dataState === DataState.RawMatrix) {\r\n      return true;\r\n    }\r\n    if (this._dataState === DataState.FactorFailed) {\r\n      return false;\r\n    }\r\n    const n = this._aDiag.length;\r\n    const nm1 = n - 1;\r\n\r\n    for (let i = nm1; i > 0; i--) {\r\n      this._aDiag[i] += this._aLeft[i] * this._aRight[i - 1];\r\n      this._aLeft[i] *= this._aDiag[i - 1];\r\n    }\r\n    this._dataState = DataState.RawMatrix;\r\n    return true;\r\n  }\r\n  /** Factor the tridiagonal matrix to LU parts. b, x, not altered */\r\n  public factor(): boolean {\r\n    if (this._dataState === DataState.FactorOK) {\r\n      return true;\r\n    }\r\n    if (this._dataState !== DataState.RawMatrix) {\r\n      return false;\r\n    }\r\n    this._dataState = DataState.FactorFailed;\r\n\r\n    const n1 = this._aDiag.length - 1;    // Last pivot index\r\n    // Eliminate in subdiagonal.\r\n    for (let i = 0; i < n1; i++) {\r\n      const r = Geometry.conditionalDivideFraction(this._aLeft[i + 1], this._aDiag[i]);\r\n      if (!r)\r\n        return false;\r\n      this._aLeft[i + 1] = r;\r\n      this._aDiag[i + 1] -= r * this._aRight[i];\r\n    }\r\n    this._dataState = DataState.FactorOK;\r\n    return true;\r\n  }\r\n  /** Solve AX=B. A is left in factored state. B unchanged. */\r\n  public factorAndBackSubstitute(): boolean {\r\n    const n = this._aDiag.length;\r\n    const n1 = n - 1;\r\n    if (!this.factor())\r\n      return false;\r\n\r\n    // Apply Linv to B, same sequence as was done to A:\r\n    for (let i = 0; i < n; i++) {\r\n      this._x[i] = this._b[i];\r\n    }\r\n    for (let i = 1; i < n; i++) {\r\n      this._x[i] -= this._aLeft[i] * this._x[i - 1];\r\n    }\r\n\r\n    // Print (\"LU  LinvB B\");\r\n    // overwrite X with solution of U * X = Linv B, where RHS is already in X...\r\n    // All diagonals are known to be nonzero. Really.  Really???\r\n    this._x[n1] /= this._aDiag[n1];\r\n\r\n    for (let i = n1 - 1; i >= 0; i--) {\r\n      this._x[i] = (this._x[i] - this._aRight[i] * this._x[i + 1]) / this._aDiag[i];\r\n    }\r\n\r\n    return true;\r\n  }\r\n  /** Solve AX=B. A is left in factored state. B unchanged. vectorB and vectorX may be the same array */\r\n  public factorAndBackSubstitutePointArrays(vectorB: Point3d[], vectorX: Point3d[]): boolean {\r\n    const n = this._aDiag.length;\r\n    if (vectorB.length < n)\r\n      return false;\r\n\r\n    while (vectorX.length < n)\r\n      vectorX.push(Point3d.create(0, 0, 0));\r\n    vectorX.length = n;\r\n    const n1 = n - 1;\r\n    if (!this.factor())\r\n      return false;\r\n\r\n    // Apply Linv to B, same sequence as was done to A:\r\n    if (vectorB !== vectorX) {\r\n      for (let i = 0; i < n; i++) {\r\n        vectorX[i].setFrom(vectorB[i]);\r\n      }\r\n    }\r\n\r\n    let a: number;\r\n    let b: number;\r\n    for (let i = 1; i < n; i++) {\r\n      a = this._aLeft[i];\r\n      vectorX[i].x -= a * vectorX[i - 1].x;\r\n      vectorX[i].y -= a * vectorX[i - 1].y;\r\n      vectorX[i].z -= a * vectorX[i - 1].z;\r\n    }\r\n\r\n    // Print (\"LU  LinvB B\");\r\n    // overwrite X with solution of U * X = Linv B, where RHS is already in X...\r\n    // All diagonals are known to be nonzero. Really.  Really???\r\n    b = 1.0 / this._aDiag[n1];\r\n    vectorX[n1].x *= b;\r\n    vectorX[n1].y *= b;\r\n    vectorX[n1].z *= b;\r\n\r\n    for (let i = n1 - 1; i >= 0; i--) {\r\n      a = this._aRight[i];\r\n      b = 1.0 / this._aDiag[i];\r\n      vectorX[i].x = (vectorX[i].x - a * vectorX[i + 1].x) * b;\r\n      vectorX[i].y = (vectorX[i].y - a * vectorX[i + 1].y) * b;\r\n      vectorX[i].z = (vectorX[i].z - a * vectorX[i + 1].z) * b;\r\n    }\r\n\r\n    return true;\r\n  }\r\n  /** Allocate a complete copy */\r\n  public copy(): TriDiagonalSystem {\r\n    const n = this._aDiag.length;\r\n    const B = new TriDiagonalSystem(n);\r\n    for (let i = 0; i < n; i++) {\r\n      B._aLeft[i] = this._aLeft[i];\r\n      B._aDiag[i] = this._aDiag[i];\r\n      B._aRight[i] = this._aRight[i];\r\n      B._x[i] = this._x[i];\r\n      B._b[i] = this._b[i];\r\n    }\r\n    B._dataState = this._dataState;\r\n    return B;\r\n  }\r\n\r\n  /** return an array form that may be useful for display ... */\r\n  public flatten(): any {\r\n    const n = this._aDiag.length;\r\n    const data = [];\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      data.push(\r\n        [i, [this._aLeft[i], this._aDiag[i], this._aRight[i]], this._x[i], this._b[i]]);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  /** return an array form that may be useful for display ... */\r\n  public flattenWithPoints(xyzB: Point3d[]): any {\r\n    const n = this._aDiag.length;\r\n    const data = [];\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      data.push(\r\n        [i, [this._aLeft[i], this._aDiag[i], this._aRight[i]], this._x[i], xyzB[i].toJSON()]);\r\n    }\r\n    return data;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/**\r\n * Implement the classic UnionFind algorithm, viz https://en.wikipedia.org/wiki/Disjoint-set_data_structure\r\n * * Each of the entities being merged exists as an entry in an array.\r\n * * The index in the array is the (only!) identification of the entity.\r\n * * The array entry is the index of a parent in the merge process.\r\n * * New entries are created as singletons pointing to themselves.\r\n * * Merge (i,j) merges the collections containing entries (i) and (j) into a single collection.\r\n * * The merge process updates the indices \"above\" (i) and (j)\r\n * * The whole process is extraordinarily efficient regardless of the order that the (i,j) merges are announced.\r\n * @internal\r\n */\r\nexport class UnionFindContext {\r\n  private _parentArray: number[];\r\n  /** Create a set initialized with numLeaf singleton subsets */\r\n  public constructor(numLeaf: number = 0) {\r\n    this._parentArray = [];\r\n    for (let i = 0; i < numLeaf; i++)\r\n      this._parentArray.push(i);\r\n  }\r\n  /** Return the number of leaves. */\r\n  public get length(): number { return this._parentArray.length; }\r\n  /** test if index is within the valid index range. */\r\n  public isValidIndex(index: number): boolean {\r\n    return 0 <= index && index < this._parentArray.length;\r\n  }\r\n  /** Return the index of a new singleton set */\r\n  public addLeaf(): number {\r\n    const index = this._parentArray.length;\r\n    this._parentArray.push(index);\r\n    return index;\r\n  }\r\n  /**\r\n   * * follow links to parent\r\n   * * after finding the parent, repeat the search and reset parents along the way.\r\n   * * If index is invalid, return index unchanged.\r\n   * @param index start of search\r\n   */\r\n  public findRoot(index: number): number {\r\n    if (!this.isValidIndex(index))\r\n      return index;\r\n    let currentIndex = index;\r\n    let nextIndex = this._parentArray[index];\r\n    while (nextIndex !== currentIndex) {\r\n      currentIndex = nextIndex;\r\n      nextIndex = this._parentArray[currentIndex];\r\n    }\r\n    const rootIndex = currentIndex;\r\n    // sweep up again and shorten the paths.\r\n    currentIndex = index;\r\n    while (currentIndex !== rootIndex) {\r\n      nextIndex = this._parentArray[currentIndex];\r\n      this._parentArray[currentIndex] = rootIndex;\r\n      currentIndex = nextIndex;\r\n    }\r\n    return rootIndex;\r\n  }\r\n\r\n  /** Merge the subsets containing index (i) and (j)\r\n   * * Look up the root of each.\r\n   * * Fix up the path to the root so it points to the root.\r\n   * * Return the root index of the merged set.\r\n   * * If either index is invalid return index i with no changes.\r\n   */\r\n  public mergeSubsets(i: number, j: number): number {\r\n    if (!this.isValidIndex(i) || !this.isValidIndex(j))\r\n      return i;\r\n    const rootIndexI = this.findRoot(i);\r\n    const rootIndexJ = this.findRoot(j);\r\n    if (rootIndexI !== rootIndexJ)\r\n      this._parentArray[rootIndexI] = rootIndexJ;\r\n    // cleanup a little more ...\r\n    return this.findRoot(i);\r\n  }\r\n  /** Return the immediate parent of index (i), with no fixups\r\n   * * If index is invalid, return it.\r\n   */\r\n  public askParent(index: number): number {\r\n    if (!this.isValidIndex(index))\r\n      return index;\r\n    return this._parentArray[index];\r\n  }\r\n  /** Return the number of entries which are their own parent. */\r\n  public countRoots(): number {\r\n    let numRoot = 0;\r\n    const numLeaf = this._parentArray.length;\r\n    for (let i = 0; i < numLeaf; i++)\r\n      if (this._parentArray[i] === i)\r\n        numRoot++;\r\n    return numRoot;\r\n  }\r\n  /** Return the number of entries whose parent is not a root. */\r\n  public countNonTrivialPaths(): number {\r\n    let numLong = 0;\r\n    const numLeaf = this._parentArray.length;\r\n    for (let i = 0; i < numLeaf; i++) {\r\n      const j = this._parentArray[i];\r\n      if (j !== i && this._parentArray[j] !== j)\r\n        numLong++;\r\n    }\r\n    return numLong;\r\n  }\r\n  /** Return an array of all root indices.\r\n   * * This array is sorted.\r\n   */\r\n  public collectRootIndices(): number[] {\r\n    const roots = [];\r\n    const numLeaf = this._parentArray.length;\r\n    for (let i = 0; i < numLeaf; i++) {\r\n      if (this._parentArray[i] === i)\r\n        roots.push(i);\r\n    }\r\n    return roots;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { Range1d } from \"../geometry3d/Range\";\r\nimport { Geometry } from \"../Geometry\";\r\n\r\n/**\r\n * Accumulator for computing average and standard deviations.\r\n * * Usual usage pattern:\r\n *   * create with `sums = new UsageSums ()`\r\n *   * announce data values with any combination of\r\n *      * `sums.accumulate (x: number)`\r\n *      * `sums.accumulateArray (data: numberArray)`\r\n *   * query properties at any time:\r\n *      * `sums.mean`\r\n *      * `sums.count`\r\n *      * `sums.meanSquare`\r\n *      * `sums.standardDeviation`\r\n *      * `sums.minMax`\r\n * * Optional `origin`\r\n *   * if `origin` is nonzero:\r\n *      * when a value `x` is announced to the `accumulate(x)` method, the value used for sums is `(x-origin)`\r\n *   * All queries (mean, minMax, meanSquare, standardDeviation) return values relative to the origin.\r\n *   * The origin can be reset in two different ways:\r\n *     * `setOrigin(a)` sets the saved origin value to `a`, but leaves sums unchanged.\r\n *       * This affects subsequence how sums are changed by `announce(x)`\r\n *     * `shiftOriginAndSums` sets the origin (like `sums.setOrigin (a))` and also corrects all sums and minMax so they appear that the new origin had been in effect during all prior `accumulate(x)` calls.\r\n * @internal\r\n */\r\nexport class UsageSums {\r\n  /** number of values accumulated. */\r\n  private _count: number;\r\n  /** Sum of values sent to `accumulate` (with origin subtracted away) */\r\n  private _sumX: number;\r\n  private _sumXX: number;\r\n  private _minMax: Range1d;\r\n  /** working origin.\r\n   * * All other values -- sum0, sum1, sum2, min,max -- are \"from this origin\"\r\n   */\r\n  private _origin: number;\r\n\r\n  /** Constructor:\r\n   * * All sums 0\r\n   * * min and max set to extreme values.\r\n   * * origin assigned.\r\n   */\r\n  public constructor(origin: number = 0) {\r\n    this._minMax = Range1d.createNull();\r\n    this._count = this._sumX = this._sumXX = 0;\r\n    this._origin = origin;\r\n  }\r\n  /** Return the number of samples seen */\r\n  public get count(): number { return this._count; }\r\n  /** return the mean of all samples.\r\n   * * Return 0 if no samples\r\n   */\r\n  public get mean(): number { return this._count > 0 ? this._sumX / this._count : 0.0; }\r\n  /** Return the mean of  squared samples.\r\n   * * Return 0 if no samples.\r\n   */\r\n  public get meanSquare(): number { return this._count > 0 ? this._sumXX / this._count : 0.0; }\r\n  public get minMax(): Range1d { return this._minMax.clone(); }\r\n\r\n  /**\r\n   * Return the \"biased standard deviation\" (https://en.wikipedia.org/wiki/Standard_deviation)\r\n   * * This is zero if count is zero.\r\n   */\r\n  public get standardDeviation(): number {\r\n    if (this._count < 1)\r\n      return 0.0;\r\n    const xBar = this.mean;\r\n    const sumXX = this._sumXX;\r\n    const sumX = this._sumX;\r\n    return Math.sqrt((sumXX - 2 * xBar * sumX + this._count * xBar * xBar) / this._count);\r\n  }\r\n  /** Reinitialize all sums.\r\n   * * origin is unchanged\r\n   */\r\n  public clearSums() {\r\n    this._count = this._sumX = this._sumXX = 0;\r\n    this._minMax.setNull();\r\n  }\r\n  /**\r\n   * return the origin being used in the `accumulate(x)` method.\r\n   */\r\n  public get origin(): number { return this._origin; }\r\n  /**\r\n   * Reset the origin.\r\n   * * Former sums are unchanged !!\r\n   * @param origin new origin\r\n   */\r\n  public setOrigin(origin: number) {\r\n    this._origin = origin;\r\n  }\r\n  /**\r\n   * * reset the origin\r\n   * * adjust all sums to what they would be if the new origin had been in effect.\r\n   */\r\n  public shiftOriginAndSums(origin: number) {\r\n    const delta = origin - this._origin;\r\n    this._origin = origin;\r\n    // adjust sumXX first to get old sumX value before it is modified.\r\n    this._sumXX = this._sumXX - 2 * delta * this._sumX + this._count * delta * delta;\r\n    this._sumX = this._sumX - this._count * delta;\r\n    this._minMax.cloneTranslated(-delta, this._minMax);\r\n  }\r\n  /** Accumulate a single value */\r\n  public accumulate(x: number) {\r\n    x = x - this._origin;\r\n    this._count += 1;\r\n    this._sumX += x;\r\n    this._sumXX += x * x;\r\n    this._minMax.extendX(x);\r\n  }\r\n  /** Accumulate a single value */\r\n  public accumulateArray(xArray: number[]) {\r\n    for (const x of xArray)\r\n      this.accumulate(x);\r\n  }\r\n  /** Clone all content (origin, count, sums, minMax) */\r\n  public clone(result?: UsageSums): UsageSums {\r\n    if (!result)\r\n      result = new UsageSums();\r\n    this._minMax.clone(result._minMax);\r\n    result._count = this._count;\r\n    result._origin = this._origin;\r\n    result._sumX = this._sumX;\r\n    result._sumXX = this._sumXX;\r\n    return result;\r\n  }\r\n  /** Compare all content. */\r\n  public isAlmostEqual(other: UsageSums): boolean {\r\n    return Geometry.isAlmostEqualNumber(this._sumX, other._sumX)\r\n      && Geometry.isAlmostEqualNumber(this._sumXX, other._sumXX)\r\n      && Geometry.isAlmostEqualNumber(this._origin, other._origin)\r\n      && this._count === other._count\r\n      && this._minMax.isAlmostEqual(other._minMax);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty*/\r\n// import { Geometry } from \"./Geometry\";\r\nimport { Range1d } from \"../geometry3d/Range\";\r\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\r\n\r\n/** The data types of [[AuxChannel]].  The scalar types are used to produce thematic  vertex colors.\r\n * @public\r\n*/\r\nexport enum AuxChannelDataType {\r\n  /** General scalar type - no scaling is applied if associated [[Polyface]] is transformed. */\r\n  Scalar = 0,\r\n  /** Distance (scalar) scaling is applied if associated [[Polyface]] is scaled. 3 Data values (x,y.z) per entry. */\r\n  Distance = 1,\r\n  /** Displacement added to  vertex position.  Transformed and scaled with associated [[Polyface]]. 3 Data values (x,y.z) per entry.,*/\r\n  Vector = 2,\r\n  /** Normal -- replaces vertex normal.  Rotated with associated [[Polyface]] transformation. 3 Data values (x,y.z) per entry. */\r\n  Normal = 3,\r\n}\r\n/**  Represents the [[AuxChannel]] data at a single input value.\r\n * @public\r\n*/\r\nexport class AuxChannelData {\r\n  /** The input value for this data. */\r\n  public input: number;\r\n  /** The vertex values for this data.  A single value per vertex for scalar types and 3 values (x,y,z) for normal or vector channels. */\r\n  public values: number[];\r\n  /** Construct a new [[AuxChannelData]] from input value and vertex values. */\r\n  constructor(input: number, values: number[]) {\r\n    this.input = input;\r\n    this.values = values;\r\n  }\r\n  /** Copy blocks of size `blockSize` from (blocked index) `thisIndex` in this AuxChannelData to (blockIndex) `otherIndex` of `other` */\r\n  public copyValues(other: AuxChannelData, thisIndex: number, otherIndex: number, blockSize: number) {\r\n    for (let i = 0; i < blockSize; i++)\r\n      this.values[thisIndex * blockSize + i] = other.values[otherIndex * blockSize + i];\r\n  }\r\n  /** return a deep copy */\r\n  public clone() {\r\n    return new AuxChannelData(this.input, this.values.slice());\r\n  }\r\n  /** toleranced comparison of the `input` and `value` fields.\r\n   * * Default tolernace is 1.0e-8\r\n   */\r\n  public isAlmostEqual(other: AuxChannelData, tol?: number) {\r\n    const tolerance = tol ? tol : 1.0E-8;\r\n    return Math.abs(this.input - other.input) < tolerance && NumberArray.isAlmostEqual(this.values, other.values, tolerance);\r\n  }\r\n}\r\n/**  Represents a single [[PolyfaceAuxData]] channel. A channel  may represent a single scalar value such as stress or temperature or may represent displacements from vertex position or replacements for normals.\r\n * @public\r\n*/\r\nexport class AuxChannel {\r\n  /** An array of [[AuxChannelData]] that represents the vertex data at one or more input values. */\r\n  public data: AuxChannelData[];\r\n  /** type indicator for this channel.  Setting this causes later transformations to be applied to point, vector, and surface normal data in appropriate ways. */\r\n  public dataType: AuxChannelDataType;\r\n  /** The channel name. This is used to present the [[AuxChannel]] to the user and also to select the [[AuxChannel]] for display from AnalysisStyle */\r\n  public name?: string;\r\n  /** The input name. */\r\n  public inputName?: string;\r\n  /** create a [[AuxChannel]] */\r\n  public constructor(data: AuxChannelData[], dataType: AuxChannelDataType, name?: string, inputName?: string) {\r\n    this.data = data;\r\n    this.dataType = dataType;\r\n    this.name = name;\r\n    this.inputName = inputName;\r\n  }\r\n  /** Return a deep clone */\r\n  public clone() {\r\n    const clonedData = [];\r\n    for (const data of this.data) clonedData.push(data.clone());\r\n    return new AuxChannel(clonedData, this.dataType, this.name, this.inputName);\r\n  }\r\n  /** toleranced comparison of contents. */\r\n  public isAlmostEqual(other: AuxChannel, tol?: number) {\r\n    if (this.dataType !== other.dataType ||\r\n      this.name !== other.name ||\r\n      this.inputName !== other.inputName ||\r\n      this.data.length !== other.data.length)\r\n      return false;\r\n\r\n    for (let i = 0; i < this.data.length; i++)\r\n      if (!this.data[i].isAlmostEqual(other.data[i], tol))\r\n        return false;\r\n\r\n    return true;\r\n  }\r\n  /** return true if the data for this channel is of scalar type (single data entry per value) */\r\n  get isScalar(): boolean { return this.dataType === AuxChannelDataType.Distance || this.dataType === AuxChannelDataType.Scalar; }\r\n  /** return the number of data values per entry (1 for scalar, 3 for point or vector */\r\n  get entriesPerValue(): number { return this.isScalar ? 1 : 3; }\r\n  /** return value count */\r\n  get valueCount(): number { return 0 === this.data.length ? 0 : this.data[0].values.length / this.entriesPerValue; }\r\n  /** return the range of the scalar data. (undefined if not scalar) */\r\n  get scalarRange(): Range1d | undefined {\r\n    if (!this.isScalar) return undefined;\r\n    const range = Range1d.createNull();\r\n    for (const data of this.data) {\r\n      range.extendArray(data.values);\r\n    }\r\n    return range;\r\n  }\r\n}\r\n/**  The `PolyfaceAuxData` structure contains one or more analytical data channels for each vertex of a `Polyface`.\r\n * Typically a `Polyface` will contain only vertex data required for its basic display,the vertex position, normal\r\n * and possibly texture parameter.  The `PolyfaceAuxData` structure contains supplemental data that is generally computed\r\n *  in an analysis program or other external data source.  This can be scalar data used to either overide the vertex colors through *Thematic Colorization* or\r\n *  XYZ data used to deform the mesh by adjusting the vertex postions or normals.\r\n * @public\r\n */\r\nexport class PolyfaceAuxData {\r\n  /** Array with one or more channels of auxilliary data for the associated polyface. */\r\n   public channels: AuxChannel[];\r\n  /** indices The indices (shared by all data in all channels) mapping the data to the mesh facets. */\r\n  public indices: number[];\r\n\r\n  public constructor(channels: AuxChannel[], indices: number[]) {\r\n    this.channels = channels;\r\n    this.indices = indices;\r\n  }\r\n  /** return a deep clone */\r\n  public clone() {\r\n    const clonedChannels = [];\r\n    for (const channel of this.channels) clonedChannels.push(channel.clone());\r\n    return new PolyfaceAuxData(clonedChannels, this.indices.slice());\r\n  }\r\n  /** deep test for equality.\r\n   * * Exact equality for discrete number arrays.\r\n   * * approximate test for coordinate data.\r\n   */\r\n  public isAlmostEqual(other: PolyfaceAuxData, tol?: number): boolean {\r\n    if (!NumberArray.isExactEqual(this.indices, other.indices) || this.channels.length !== other.channels.length)\r\n      return false;\r\n\r\n    for (let i = 0; i < this.channels.length; i++)\r\n      if (!this.channels[i].isAlmostEqual(other.channels[i], tol))\r\n        return false;\r\n\r\n    return true;\r\n  }\r\n  /**\r\n   * class level almostEqual test, allowing either or both to be undefined at point of call.\r\n   * @param left\r\n   * @param right\r\n   * @param tol\r\n   */\r\n  public static isAlmostEqual(left: PolyfaceAuxData | undefined, right: PolyfaceAuxData | undefined, tol?: number): boolean {\r\n    if (left === right) // This catches double undefined !!!\r\n      return true;\r\n    if (left && right)\r\n      return left.isAlmostEqual(right, tol);\r\n    return false;\r\n  }\r\n  /** Create a PolyfaceAuxData for use by a facet iterator  */\r\n  public createForVisitor() {\r\n    const visitorChannels: AuxChannel[] = [];\r\n\r\n    for (const parentChannel of this.channels) {\r\n      const visitorChannelData: AuxChannelData[] = [];\r\n      for (const parentChannelData of parentChannel.data) {\r\n        visitorChannelData.push(new AuxChannelData(parentChannelData.input, []));\r\n      }\r\n      visitorChannels.push(new AuxChannel(visitorChannelData, parentChannel.dataType, parentChannel.name, parentChannel.inputName));\r\n    }\r\n\r\n    return new PolyfaceAuxData(visitorChannels, []);\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\n//\r\n//      2------------------3\r\n//      | \\     F4       / |\r\n//      |   6----------7   |\r\n//      |   |          |   |   (BOTTOM = F0)\r\n//      |F5 |   F1     |F3 |\r\n//      |   |          |   |\r\n//      |   4----------5   |\r\n//      | /     F2       \\ |\r\n//      0------------------1\r\n//\r\n/**\r\n * methods for gathering points and indices of a box (8 corners, 6 faces, 12 edges)\r\n * @internal\r\n */\r\nexport class BoxTopology {\r\n  /**\r\n   * static readonly array with the coordinates of the 8 unit cube corners in standard order, which is:\r\n   * x varies fastest\r\n   * * The point indices for the x edges are (0 to 1), (2 to 3), (4 to 5), (6 to 7)\r\n   * * The point indices for the y edges are (0 to 2), (1 to 3), (4 to 6), (5 to 7)\r\n   * * The point indices for the z edges are (0 to 4), (1 to 5), (2 to 6), (3 to 7)\r\n   * * These indices are tabulated in the `axisEdgeVertex[axis][edge][vertex]` array\r\n   */\r\n  public static readonly points = [\r\n    Point3d.create(0, 0, 0),\r\n    Point3d.create(1, 0, 0),\r\n    Point3d.create(0, 1, 0),\r\n    Point3d.create(1, 1, 0),\r\n    Point3d.create(0, 0, 1),\r\n    Point3d.create(1, 0, 1),\r\n    Point3d.create(0, 1, 1),\r\n    Point3d.create(1, 1, 1),\r\n  ];\r\n  /** IN faceId pair, the first component for bottom and top caps is `primaryCapId` */\r\n  public static readonly primaryCapId = -1;\r\n  /** Indices of vertices around faces, in CCW from the outside. */\r\n  public static readonly cornerIndexCCW =\r\n    [\r\n      [1, 0, 2, 3],\r\n      [4, 5, 7, 6],\r\n      [0, 1, 5, 4],\r\n      [1, 3, 7, 5],\r\n      [3, 2, 6, 7],\r\n      [2, 0, 4, 6]];\r\n  /**  // [partnerFace[faceIndex][k] = index of k'th adjacent face  */\r\n  public static readonly partnerFace =\r\n    [\r\n      [5, 4, 3, 2],\r\n      [2, 3, 4, 5],\r\n      [0, 3, 1, 5],\r\n      [0, 4, 1, 2],\r\n      [0, 5, 1, 3],\r\n      [0, 2, 1, 4],\r\n    ];\r\n  /** face id as used in SolidPrimitive methods */\r\n  public static readonly faceId = [\r\n    [BoxTopology.primaryCapId, 0],\r\n    [BoxTopology.primaryCapId, 1],\r\n    [0, 0],\r\n    [0, 1],\r\n    [0, 2],\r\n    [0, 3]];\r\n  /**\r\n   * Table to look up axis indices of edges and normals in box faces.\r\n   * faceDirections[faceIndex] =[[edge0AxisIndex, edge1AxisIndex, normalAxisIndex],[direction sign for along the axis]\r\n   */\r\n  public static readonly faceDirections =\r\n    [\r\n      [[0, 1, 2], [-1, 1, -1]],\r\n      [[0, 1, 2], [1, 1, 1]],\r\n      [[0, 2, 1], [1, -1, 1]],\r\n      [[1, 2, 0], [1, 1, 1]],\r\n      [[0, 2, 1], [-1, 1, 1]],\r\n      [[1, 2, 0], [-1, 1, -1]]];\r\n  /** There are 4 edges in each axis direction.\r\n   *  * axisEdgeVertex[axisIndex][edgeIndex 0..3][*] = vertex index at end of edge in axisIndex direction.\r\n   */\r\n  public static readonly axisEdgeVertex =\r\n    [\r\n      [[0, 1], [2, 3], [4, 5], [6, 7]],\r\n      [[0, 2], [1, 3], [4, 6], [5, 7]],\r\n      [[0, 4], [1, 5], [2, 6], [3, 7]]];\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range2d } from \"../geometry3d/Range\";\r\nimport { IndexedPolyface, IndexedPolyfaceVisitor } from \"./Polyface\";\r\n/** module Polyface */\r\n/**\r\n * Data for a face in a polyface containing facets.\r\n * This is built up cooperatively by the PolyfaceBuilder and its\r\n * callers, and stored as a FaceData array in PolyfaceData.\r\n * @public\r\n */\r\nexport class FacetFaceData {\r\n  private _paramDistanceRange: Range2d;\r\n  private _paramRange: Range2d;\r\n  /** (property accessor) Return a reference to the distance-scaled parameter range. */\r\n  public get paramDistanceRange(): Range2d { return this._paramDistanceRange; }\r\n  /** (property accessor) Return a reference to the parameter range. */\r\n  public get paramRange(): Range2d { return this._paramRange; }\r\n  private constructor(distanceRange: Range2d, paramRange: Range2d) {\r\n    this._paramDistanceRange = distanceRange;\r\n    this._paramRange = paramRange;\r\n  }\r\n  /** Create a FacetFaceData with null ranges. */\r\n  public static createNull(): FacetFaceData {\r\n    return new FacetFaceData(Range2d.createNull(), Range2d.createNull());\r\n  }\r\n  /** Create a deep copy of this FacetFaceData object. */\r\n  public clone(result?: FacetFaceData): FacetFaceData {\r\n    if (result) {\r\n      this._paramDistanceRange.clone(result._paramDistanceRange);\r\n      this._paramRange.clone(result._paramRange);\r\n      return result;\r\n    }\r\n    return new FacetFaceData(this._paramDistanceRange.clone(), this._paramRange.clone());\r\n  }\r\n  /** Restore this FacetFaceData to its null constructor state. */\r\n  public setNull() {\r\n    this._paramDistanceRange.setNull();\r\n    this._paramRange.setNull();\r\n  }\r\n  /** Return distance-based parameter from stored parameter value. */\r\n  public convertParamXYToDistance(x: number, y: number, result?: Point2d): Point2d {\r\n    result = result ? result : Point2d.create();\r\n    const paramDelta = this._paramRange.high.minus(this._paramRange.low);\r\n    result.x = (0 === paramDelta.x) ? x : (this._paramDistanceRange.low.x + (x - this._paramRange.low.x)\r\n      * (this._paramDistanceRange.high.x - this._paramDistanceRange.low.x) / paramDelta.x);\r\n    result.y = (0.0 === paramDelta.y) ? y : (this.paramDistanceRange.low.y + (y - this._paramRange.low.y)\r\n      * (this._paramDistanceRange.high.y - this._paramDistanceRange.low.y) / paramDelta.y);\r\n    return result;\r\n  }\r\n  /** Return normalized (0-1) parameter from stored parameter value. */\r\n  public convertParamXYToNormalized(x: number, y: number, result?: Point2d): Point2d {\r\n    result = result ? result : Point2d.create();\r\n    const paramDelta = this._paramRange.high.minus(this._paramRange.low);\r\n    result.x = (0.0 === paramDelta.x) ? x : ((x - this._paramRange.low.x) / paramDelta.x);\r\n    result.y = (0.0 === paramDelta.y) ? y : ((y - this._paramRange.low.y) / paramDelta.y);\r\n    return result;\r\n  }\r\n  /** Return distance-based parameter from stored parameter value. */\r\n  public convertParamToDistance(param: Point2d, result?: Point2d): Point2d {\r\n    return this.convertParamXYToDistance(param.x, param.y, result);\r\n  }\r\n  /** Return normalized (0-1) parameter from stored parameter value. */\r\n  public convertParamToNormalized(param: Point2d, result?: Point2d): Point2d {\r\n    return this.convertParamXYToNormalized(param.x, param.y, result);\r\n  }\r\n  /** Scale distance parameters. */\r\n  public scaleDistances(distanceScale: number) {\r\n    this._paramDistanceRange.low.x *= distanceScale;\r\n    this._paramDistanceRange.low.y *= distanceScale;\r\n    this._paramDistanceRange.high.x *= distanceScale;\r\n    this._paramDistanceRange.high.y *= distanceScale;\r\n  }\r\n  /**\r\n   * Sets the param and paramDistance range of this FacetFaceData based on the newly terminated facets that make it up.\r\n   * Takes the polyface itself, the first and last indexes of the facets to be included in the face.\r\n   * Returns true on success, false otherwise.\r\n   */\r\n  public setParamDistanceRangeFromNewFaceData(polyface: IndexedPolyface, facetStart: number, facetEnd: number): boolean {\r\n    const dSTotal = Point2d.create();\r\n    const dSSquaredTotal = Point2d.create();\r\n    this.setNull();\r\n    let aveTotal = 0;\r\n    const visitor = IndexedPolyfaceVisitor.create(polyface, 0);\r\n    if (!visitor.moveToReadIndex(facetStart) || facetEnd <= facetStart)\r\n      return false;\r\n    do {\r\n      const numPointsInFacet = visitor.numEdgesThisFacet;\r\n      const visitorPoints = visitor.point;\r\n      const trianglePointIndexes: number[] = [];\r\n      const visitorParams = visitor.param;\r\n      const triangleParamIndexes: number[] = [];\r\n      if (!visitorParams)\r\n        return false;\r\n      visitorParams.extendRange(this._paramRange);\r\n      const dUV0 = Vector2d.create();\r\n      const dUV1 = Vector2d.create();\r\n      for (let k = 0; k < numPointsInFacet; k++) {\r\n        trianglePointIndexes[2] = k;\r\n        triangleParamIndexes[2] = k;\r\n        if (k > 1) {\r\n          visitorParams.vectorIndexIndex(triangleParamIndexes[1], triangleParamIndexes[0], dUV0);\r\n          visitorParams.vectorIndexIndex(triangleParamIndexes[1], triangleParamIndexes[2], dUV1);\r\n          const delta0 = visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[0]).minus(visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[1]));\r\n          const delta1 = visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[1]).minus(visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[2]));\r\n          const uvCross = Math.abs(dUV0.x * dUV1.y - dUV1.x * dUV0.y);\r\n          if (uvCross) {\r\n            const dwDu = Point3d.createFrom(delta0);\r\n            dwDu.scaleInPlace(dUV1.y);\r\n            dwDu.addScaledInPlace(delta1, -dUV0.y);\r\n            const dwDv = Point3d.createFrom(delta1);\r\n            dwDv.scaleInPlace(dUV0.x);\r\n            dwDv.addScaledInPlace(delta0, -dUV1.x);\r\n            const dS = Point2d.create(dwDu.magnitude() / uvCross, dwDv.magnitude() / uvCross);\r\n            dSTotal.x += dS.x;\r\n            dSTotal.y += dS.y;\r\n            dSSquaredTotal.x += dS.x * dS.x;\r\n            dSSquaredTotal.y += dS.y * dS.y;\r\n            aveTotal++;\r\n          }\r\n        }\r\n        triangleParamIndexes[0] = triangleParamIndexes[1];\r\n        triangleParamIndexes[1] = triangleParamIndexes[2];\r\n        trianglePointIndexes[0] = trianglePointIndexes[1];\r\n        trianglePointIndexes[1] = trianglePointIndexes[2];\r\n      }\r\n    } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < facetEnd);\r\n    if (aveTotal !== 0) {\r\n      const dS = Point2d.create(dSTotal.x / aveTotal, dSTotal.y / aveTotal);\r\n      const standardDeviation = Point2d.create(Math.sqrt(Math.abs((dSSquaredTotal.x / aveTotal) - dS.x * dS.x)), Math.sqrt(Math.abs((dSSquaredTotal.y / aveTotal) - dS.y * dS.y)));\r\n      // TR# 268980 - Add standard deviation to match QV....\r\n      this._paramDistanceRange.low.set(0, 0);\r\n      this._paramDistanceRange.high.set((dS.x + standardDeviation.x) * (this._paramRange.high.x - this._paramRange.low.x), (dS.y + standardDeviation.y) * (this._paramRange.high.y - this._paramRange.low.y));\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { TriangleCandidate } from \"./TriangleCandidate\";\r\nimport { BarycentricTriangle } from \"../geometry3d/BarycentricTriangle\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { IndexedXYZCollectionInterval } from \"../geometry3d/IndexedCollectionInterval\";\r\n\r\n/** @module Polyface */\r\n/**\r\n * * Context for constructing triangulations between linestrings with dis-similar point counts and distribution.\r\n * @internal\r\n */\r\nexport class GreedyTriangulationBetweenLineStrings {\r\n\r\n  private _vector1: Vector3d;\r\n  private constructor(turnRadians: number) {\r\n    this._turnRadians = turnRadians;\r\n    this._xyzA = Point3d.create();\r\n    this._xyzB = Point3d.create();\r\n    this._forwardA = Vector3d.create();\r\n    this._forwardB = Vector3d.create();\r\n    this._vector1 = Vector3d.create();\r\n    this._crossA = Vector3d.create();\r\n    this._crossB = Vector3d.create();\r\n  }\r\n\r\n  private _turnRadians: number;\r\n\r\n  private isForwardVector(\r\n    candidate: Vector3d,\r\n    forward: Vector3d,\r\n    perp: Vector3d): boolean {\r\n    if (candidate.dotProduct(forward) <= 0.0)\r\n      return false;\r\n    const theta = candidate.angleFromPerpendicular(perp);\r\n    if (Math.abs(theta.radians) > this._turnRadians)\r\n      return false;\r\n    return true;\r\n  }\r\n  private isPlanarBase(\r\n    pointsA: IndexedXYZCollection,\r\n    baseA: number,\r\n    pointsB: IndexedXYZCollection,\r\n    baseB: number,\r\n    xyzA: Point3d,\r\n    crossA: Vector3d,\r\n    forwardA: Vector3d,\r\n    xyzB: Point3d,\r\n    crossB: Vector3d,\r\n    forwardB: Vector3d): boolean {\r\n    if (baseA + 1 < pointsA.length && baseB + 1 < pointsB.length) {\r\n      pointsA.getPoint3dAtUncheckedPointIndex(baseA, xyzA);\r\n      pointsB.getPoint3dAtUncheckedPointIndex(baseB, xyzB);\r\n      pointsA.vectorXYAndZIndex(xyzA, baseA + 1, forwardA);\r\n      pointsB.vectorXYAndZIndex(xyzB, baseB + 1, forwardB);\r\n      Vector3d.createStartEnd(xyzA, xyzB, this._vector1);\r\n      this._vector1.crossProduct(forwardA, crossA);\r\n      this._vector1.crossProduct(forwardB, crossB);\r\n      if (!xyzA.isAlmostEqual(xyzB) && crossA.angleTo(crossB).radians < this._turnRadians)\r\n        return true;\r\n    }\r\n    return false;\r\n\r\n  }\r\n  /**\r\n   * Starting at start in source, examine points to see how long they are close to being \"in plane\"\r\n   * * child interval begins at parent.begin\r\n   * * child interval end initializes at trialEnd and grows.\r\n   * * child must be predefined by caller\r\n   * * Return the accepted interval\r\n   */\r\n  private advanceToPlanarLimit(\r\n    parent: IndexedXYZCollectionInterval,\r\n    child: IndexedXYZCollectionInterval,\r\n    trialEnd: number,\r\n    xyzA: Point3d,\r\n    perpA: Vector3d,\r\n    forwardA: Vector3d,\r\n    perpB: Vector3d,\r\n    forwardB: Vector3d) {\r\n    child.setFrom(parent, parent.begin, trialEnd);  // initialize as empty interval.\r\n    while (child.end < parent.end) {\r\n      child.points.vectorXYAndZIndex(xyzA, child.end, this._vector1);\r\n      if (!this.isForwardVector(this._vector1, forwardA, perpA))\r\n        break;\r\n      if (!this.isForwardVector(this._vector1, forwardB, perpB))\r\n        break;\r\n      if (child.end > 0) {\r\n        child.points.vectorIndexIndex(child.end - 1, child.end, this._vector1);\r\n        if (!this.isForwardVector(this._vector1, forwardA, perpA))\r\n          break;\r\n      }\r\n      child.end++;\r\n    }\r\n  }\r\n\r\n  private _triangleA1?: TriangleCandidate;\r\n  private _triangleB1?: TriangleCandidate;\r\n\r\n  private _triangleA2?: TriangleCandidate;\r\n  private _triangleB2?: TriangleCandidate;\r\n\r\n  private _triangleA3?: TriangleCandidate;\r\n  private _triangleB3?: TriangleCandidate;\r\n  private _bestTriangle?: TriangleCandidate;\r\n  private _workTriangle?: TriangleCandidate;\r\n  /** evaluate aspect ratios to select heuristically best triangles with given index intervals.\r\n   * (ASSUME NO DUPLICATES, as in caller.)\r\n   */\r\n  private addGreedy(\r\n    intervalA: IndexedXYZCollectionInterval,\r\n    intervalB: IndexedXYZCollectionInterval,\r\n    handler: (triangle: BarycentricTriangle) => void,\r\n    addOnly1: boolean = false) {\r\n    intervalA.restrictEnd();\r\n    intervalB.restrictEnd();\r\n\r\n    while (intervalA.length > 1 && intervalB.length > 1) {\r\n\r\n      // triangles A1 and B1 are always valid.\r\n      this._triangleA1 = TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin, intervalA.points, intervalA.begin + 1, intervalB.points, intervalB.begin, 1, this._triangleA1);\r\n      this._triangleA2 = TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin + 1, intervalA.points, intervalA.begin + 2, intervalB.points, intervalB.begin, 2, this._triangleA2);\r\n      this._triangleA3 = TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin, intervalA.points, intervalA.begin + 1, intervalB.points, intervalB.begin + 1, 3, this._triangleA3);\r\n\r\n      this._triangleB1 = TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 1, intervalB.points, intervalB.begin, intervalA.points, intervalA.begin, -1, this._triangleB1);\r\n      this._triangleB2 = TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 2, intervalB.points, intervalB.begin + 1, intervalA.points, intervalA.begin, -2, this._triangleB2);\r\n      this._triangleB3 = TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 1, intervalB.points, intervalB.begin, intervalA.points, intervalA.begin + 1, -3, this._triangleB3);\r\n      // Look at pairs of 2 triangles.\r\n      // (each pair begins with 1 or -1)\r\n      // For each pair find the smallest aspect ratio of its two triangles.  (Small is bad)\r\n      // Choose the pair where that (smaller aspect ratio of two) is largest.\r\n      // Advance in that direction.\r\n      this._bestTriangle = TriangleCandidate.copyWithLowerQuality(this._triangleA1, this._triangleB3, this._bestTriangle);\r\n      this._workTriangle = TriangleCandidate.copyWithLowerQuality(this._triangleB1, this._triangleA3, this._workTriangle);\r\n      TriangleCandidate.updateIfOtherHasHigherQuality(this._bestTriangle, this._workTriangle);\r\n      // TestTriangle::UpdateIfOtherHasLargerAspectRatio (bestTriangle, TestTriangle::MergeAspectRatio (triangleB1, triangleB2));\r\n      // TestTriangle::UpdateIfOtherHasLargerAspectRatio (bestTriangle, TestTriangle::MergeAspectRatio (triangleA1, triangleA2));\r\n\r\n      if (this._bestTriangle.id > 0) {\r\n        intervalA.advanceBegin();\r\n        handler(this._bestTriangle);\r\n        if (addOnly1)\r\n          return;\r\n      } else {\r\n        intervalB.advanceBegin();\r\n        handler(this._bestTriangle);\r\n        if (addOnly1)\r\n          return;\r\n      }\r\n    }\r\n    // sweep in trailing points from either side.  At least one of intervalA.begin, intervalB.begin is at its limit, so only one of these will execute any bodies.\r\n    if (intervalA.isSingleton) {\r\n      while (intervalB.length >= 2) {\r\n        this._workTriangle = TriangleCandidate.createFromIndexedXYZ(intervalB.points, intervalB.begin + 1, intervalB.points, intervalB.begin, intervalA.points, intervalA.begin, 0, this._workTriangle);\r\n        //  this._workTriangle.scaleFromPointInPlace(this._workTriangle.points[2], 0.95); // crude visualization aid for tracking logic.\r\n        handler(this._workTriangle);\r\n        intervalB.advanceBegin();\r\n      }\r\n    }\r\n\r\n    // sweep in trailing points from either side.  At least one of baseA, baseB is at its limit, so only one of these will execute any bodies.\r\n    if (intervalB.isSingleton) {\r\n      while (intervalA.length >= 2) {\r\n        this._workTriangle = TriangleCandidate.createFromIndexedXYZ(intervalA.points, intervalA.begin, intervalA.points, intervalA.begin + 1, intervalB.points, intervalB.begin, 0, this._workTriangle);\r\n        // this._workTriangle.scaleFromPointInPlace(this._workTriangle.points[2], 0.95); // crude visualization aid for tracking logic.\r\n        handler(this._workTriangle);\r\n        intervalA.advanceBegin();\r\n      }\r\n    }\r\n  }\r\n\r\n  private _xyzA: Point3d;\r\n  private _xyzB: Point3d;\r\n  private _forwardA: Vector3d;\r\n  private _forwardB: Vector3d;\r\n  private _crossA: Vector3d;\r\n  private _crossB: Vector3d;\r\n  /**\r\n   * Working from start to finish, emit triangles with heuristic lookahead to get pleasing matching between the linestrings.\r\n   * @param pointsA\r\n   * @param pointsB\r\n   * @param handler\r\n   */\r\n  public emitTriangles(\r\n    pointsA: IndexedXYZCollection,\r\n    pointsB: IndexedXYZCollection,\r\n    handler: (triangle: BarycentricTriangle) => void) {\r\n    /** Clean up duplicates for the real logic . . . */\r\n    this.emitTrianglesGo(resolveToNoDuplicates(pointsA), resolveToNoDuplicates(pointsB), handler);\r\n  }\r\n  /**\r\n   * Run triangle logic on inputs with no duplicates.\r\n   * @param pointsA\r\n   * @param pointsB\r\n   * @param handler\r\n   */\r\n  private emitTrianglesGo(\r\n    pointsA: IndexedXYZCollection,\r\n    pointsB: IndexedXYZCollection,\r\n    handler: (triangle: BarycentricTriangle) => void) {\r\n    const intervalA = IndexedXYZCollectionInterval.createComplete(pointsA);\r\n    const intervalB = IndexedXYZCollectionInterval.createComplete(pointsB);\r\n    const childA = IndexedXYZCollectionInterval.createComplete(pointsA);\r\n    const childB = IndexedXYZCollectionInterval.createComplete(pointsB);\r\n    while (intervalA.length > 0 && intervalB.length > 0 && (intervalA.length > 1 || intervalB.length > 1)) {\r\n      // const lA = intervalA.length;\r\n      // const lB = intervalB.length;\r\n      if (this.isPlanarBase(pointsA, intervalA.begin, pointsB, intervalB.begin, this._xyzA, this._crossA, this._forwardA, this._xyzB, this._crossB, this._forwardB)) {\r\n        this.advanceToPlanarLimit(intervalA, childA, intervalA.begin + 1, this._xyzA, this._crossA, this._forwardA, this._crossB, this._forwardB);\r\n        this.advanceToPlanarLimit(intervalB, childB, intervalB.begin + 1, this._xyzB, this._crossB, this._forwardB, this._crossA, this._forwardA);\r\n        this.addGreedy(childA, childB, handler);\r\n        intervalA.advanceToTail(childA);\r\n        intervalB.advanceToTail(childB);\r\n      } else if (this.isPlanarBase(pointsA, intervalA.begin + 1, pointsB, intervalB.begin, this._xyzA, this._crossA, this._forwardA, this._xyzB, this._crossB, this._forwardB)) {\r\n        childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 2);\r\n        childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 1);\r\n        this.addGreedy(childA, childB, handler);\r\n        intervalA.advanceToTail(childA);\r\n        intervalB.advanceToTail(childB);\r\n      } else if (this.isPlanarBase(pointsA, intervalA.begin, pointsB, intervalB.begin + 1, this._xyzA, this._crossA, this._forwardA, this._xyzB, this._crossB, this._forwardB)) {\r\n        childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 1);\r\n        childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 2);\r\n        this.addGreedy(childA, childB, handler);\r\n        intervalA.advanceToTail(childA);\r\n        intervalB.advanceToTail(childB);\r\n      } else if (intervalA.length > 1 && intervalB.length > 1) {\r\n        childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 2);\r\n        childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 2);\r\n        this.addGreedy(childA, childB, handler, true);\r\n        intervalA.advanceToHead(childA);\r\n        intervalB.advanceToHead(childB);\r\n      } else if (intervalA.length > 1) {\r\n        childA.setFrom(intervalA, intervalA.begin, intervalA.begin + 2);\r\n        childB.setFrom(intervalB);\r\n        this.addGreedy(childA, childB, handler);\r\n        intervalA.advanceToTail(childA);\r\n        intervalB.advanceToTail(childB);\r\n      } else if (intervalB.length > 1) {\r\n        childA.setFrom(intervalA);\r\n        childB.setFrom(intervalB, intervalB.begin, intervalB.begin + 2);\r\n        this.addGreedy(childA, childB, handler);\r\n        intervalA.advanceToTail(childA);\r\n        intervalB.advanceToTail(childB);\r\n      }\r\n      /*      if (intervalA.length >= lA && intervalB.length >= lB) {\r\n              // This should not happen == neither one advanced.   Just move ahead in the longer one ..\r\n              if (intervalA.length > intervalB.length)\r\n                intervalA.advanceBegin();\r\n              else intervalB.advanceBegin();\r\n            } */\r\n    }\r\n    // catch everything else blindly\r\n    this.addGreedy(intervalA, intervalB, handler);\r\n  }\r\n  /** Default angle for considering two vectors to be colinear */\r\n  public static defaultNearColinearAngle = Angle.createDegrees(15);\r\n  public static createContext(planarTurnAngle: Angle = this.defaultNearColinearAngle) {\r\n    return new GreedyTriangulationBetweenLineStrings(planarTurnAngle.radians);\r\n  }\r\n}\r\n\r\n/**\r\n * * If there are no contiguous duplicated points in `data` return `data` unchanged.\r\n * * If there are duplicates, compress to a new array.\r\n * @param data\r\n * @param tolerance\r\n */\r\nfunction resolveToNoDuplicates(data: IndexedXYZCollection, tolerance = Geometry.smallMetricDistance): IndexedXYZCollection {\r\n  let hasDuplicates = false;\r\n  const n = data.length;\r\n  for (let i = 0; i + 1 < n; i++) {\r\n    if (data.distanceIndexIndex(i, i + 1)! <= tolerance) {\r\n      hasDuplicates = true;\r\n      break;\r\n    }\r\n  }\r\n  if (!hasDuplicates)\r\n    return data;\r\n  const result = new GrowableXYZArray(n);\r\n  result.pushXYZ(data.getXAtUncheckedPointIndex(0), data.getYAtUncheckedPointIndex(0), data.getZAtUncheckedPointIndex(0));\r\n  let i0 = 0;\r\n  for (let i = 1; i < n; i++) {\r\n    if (data.distanceIndexIndex(i0, i)! > tolerance) {\r\n      result.pushXYZ(data.getXAtUncheckedPointIndex(i), data.getYAtUncheckedPointIndex(i), data.getZAtUncheckedPointIndex(i));\r\n      i0 = i;\r\n    }\r\n  }\r\n  /** enforce exact closure if original was closed. */\r\n  if (data.distanceIndexIndex(0, n - 1)! <= tolerance) {\r\n    result.pop();\r\n    result.pushFromGrowableXYZArray(result, 0);\r\n  }\r\n  return result;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// For boundary sorting, an edge exists as a (packed!) Float64Array.\r\n// Fixed entries are:\r\n// 0:\r\n/**\r\n * * For boundary sorting, an edge is a (packed!) Float64Array.\r\n * * Fixed entry positions are:\r\n *   * [0] is start vertex index (in CCW order around its facet)\r\n *   * [1] is end vertex index (in CCW order around its facet)\r\n *   * [2] is facet index.\r\n */\r\nexport class SortableEdge extends Float64Array {\r\n  /** Return the vertex index that appears first in the order stored.  */\r\n  public get vertexIndexA(): number { return this[0]; }\r\n  /** Return the vertex index that appears second in the order stored.  */\r\n  public get vertexIndexB(): number { return this[1]; }\r\n  /** Return the facet index.  */\r\n  public get facetIndex(): number { return this[2]; }\r\n  /** return true if vertexIndexA is less than vertexIndexB */\r\n  public get isLowHigh(): boolean { return this[0] < this[1]; }\r\n  /** Return the vertex index with lower numeric value */\r\n  public get lowVertexIndex(): number { return this[0] < this[1] ? this[0] : this[1]; }\r\n  /** Return the vertex index with higher numeric value */\r\n  public get highVertexIndex(): number { return this[0] > this[1] ? this[0] : this[1]; }\r\n  /** Return true if the vertices edgeA and edgeB are the same vertex indices in opposite order */\r\n  public static areDirectedPartners(edgeA: SortableEdge, edgeB: SortableEdge): boolean { return edgeA[0] === edgeB[1] && edgeA[1] === edgeB[0]; }\r\n  /** Return true if the vertices edgeA and edgeB are the same vertex indices with no consideration of order */\r\n  public static areUndirectedPartners(edgeA: SortableEdge, edgeB: SortableEdge): boolean {\r\n    return (edgeA[0] === edgeB[0] && edgeA[1] === edgeB[1]) || ((edgeA[0] === edgeB[1] && edgeA[1] === edgeB[0]));\r\n  }\r\n  public get isNullEdge(): boolean { return this[0] === this[1]; }\r\n  /**\r\n   * lexical comparison of two edges.\r\n   * * If the edges have the same vertex pair (in same or opposite order) they will end up adjacent in a sort\r\n   * * If the edges have 0 or 1 shared vertex indices, the one with lowest low comes first.\r\n   * @param edgeA first edge\r\n   * @param edgeB second edge\r\n   */\r\n  public static lessThan(edgeA: SortableEdge, edgeB: SortableEdge): number {\r\n    // primary compare is based on indirect indices\r\n    const lowA = edgeA.lowVertexIndex;\r\n    const lowB = edgeB.lowVertexIndex;\r\n    if (lowA < lowB)\r\n      return -1;\r\n    if (lowB < lowA)\r\n      return 1;\r\n    const highA = edgeA.highVertexIndex;\r\n    const highB = edgeB.highVertexIndex;\r\n    if (highA < highB)\r\n      return -1;\r\n    if (highB < highA)\r\n      return 1;\r\n    // undirected indices match ... use directed vertexIndexA\r\n    return edgeA.vertexIndexA - edgeB.vertexIndexA;\r\n  }\r\n  public constructor(vertexA: number, vertexB: number, facetIndex: number) {\r\n    super(3);\r\n    this[0] = vertexA;\r\n    this[1] = vertexB;\r\n    this[2] = facetIndex;\r\n  }\r\n  public toJSON(): any { return [this[0], this[1], this[2]]; }\r\n  public static clusterToJSON(data: SortableEdgeCluster): any {\r\n    if (data instanceof SortableEdge)\r\n      return data.toJSON();\r\n\r\n    const result = [];\r\n    for (const edge of data) result.push(edge.toJSON());\r\n  }\r\n  public static clusterArrayToJSON(data: SortableEdgeCluster[]) {\r\n    const result = [];\r\n    for (const cluster of data)\r\n      result.push(SortableEdge.clusterToJSON(cluster));\r\n    return result;\r\n  }\r\n}\r\n\r\nexport type SortableEdgeCluster = SortableEdge | SortableEdge[];\r\n/**\r\n * An IndexedEdgeMatcher carries an array (`edges`) of edges start & end indices for sorting and subsequent analyses (such as testing for closed mesh)\r\n */\r\nexport class IndexedEdgeMatcher {\r\n  public edges: SortableEdge[];\r\n\r\n  constructor() {\r\n    this.edges = [];\r\n  }\r\n  /**\r\n   * push a new edge.\r\n   * @returns the edge (as emplaced at the back of the sortableEdge array)\r\n   * @param vertexA start vertex\r\n   * @param vertexB end vertex\r\n   * @param facetIndex facet index\r\n   */\r\n  public addEdge(vertexA: number, vertexB: number, facetIndex: number): SortableEdge {\r\n    const edge = new SortableEdge(vertexA, vertexB, facetIndex);\r\n    this.edges.push(edge);\r\n    return edge;\r\n  }\r\n  /**\r\n   * Push edges all around a facet, returning to vertexArray[0]\r\n   * @param vertexArray array of vertex indices around facet\r\n   * @param facetIndex\r\n   */\r\n  public addPath(vertexArray: number[], facetIndex: number, closeLoop: boolean = true) {\r\n    if (vertexArray.length === 0) return;\r\n    const m = vertexArray.length - 1;\r\n    for (let i = 0; i < m; i++) {\r\n      this.addEdge(vertexArray[i], vertexArray[i + 1], facetIndex);\r\n    }\r\n    if (closeLoop)\r\n      this.addEdge(vertexArray[m], vertexArray[0], facetIndex);\r\n  }\r\n  /** Sort the edge index array. */\r\n  public sort() {\r\n    this.edges.sort(SortableEdge.lessThan);\r\n  }\r\n  /** Create a single or compound SortableEdgeCluster in dest. */\r\n  private collectSortableEdgeCluster(index0: number, index1: number, dest: SortableEdgeCluster[] | undefined) {\r\n    if (dest !== undefined && index1 > index0) {\r\n      if (index1 === index0 + 1) {\r\n        dest.push(this.edges[index0]);\r\n      } else {\r\n        const cluster = [];\r\n        for (let i = index0; i < index1; i++)\r\n          cluster.push(this.edges[i]);\r\n        dest.push(cluster);\r\n      }\r\n\r\n    }\r\n  }\r\n  /**\r\n   * sort the edges, and look for three categories of paired edges:\r\n   * * caller must allocate all result arrays of interest.\r\n   * * Any combination of the result arrays may be `undefined`, indicating that category is to be ignored.\r\n   * * Any combination of the result arrays may be aliased as the same target, in which case those to categories are merged into the target.\r\n   * * For instance, to ignore manifold pairs and collect all others (singleton and other) as a single array `allOther`, create `const allOther = []` as an empty array and call\r\n   * `sortAndCollectClusters (undefined, allOther, allOther);`\r\n   * @param manifoldPairs optional array to receive pairs of properly mated SortableEdgePairs, i.e. simple interior edges adjacent to two facets in opposing directions.\r\n   * @param singletons optional array to receive edges that are simple boundary edges.\r\n   * @param nullEdges clusters with null edges (same start and end vertex)\r\n   * @param allOtherClusters optional array to receive arrays in which all the edges are partners in an undirected sense but not a simple directed pair.\r\n   */\r\n  public sortAndCollectClusters(manifoldPairs: SortableEdgeCluster[] | undefined, singletons: SortableEdgeCluster[] | undefined, nullEdges: SortableEdgeCluster[] | undefined, allOtherClusters: SortableEdgeCluster[] | undefined) {\r\n    this.sort();\r\n    if (manifoldPairs) manifoldPairs.length = 0;\r\n    if (singletons) singletons.length = 0;\r\n    if (nullEdges) nullEdges.length = 0;\r\n    if (allOtherClusters) allOtherClusters.length = 0;\r\n    const n = this.edges.length;\r\n    let clusterLength;\r\n    for (let index0 = 0; index0 < n; index0 += clusterLength) {\r\n      const baseEdge = this.edges[index0];\r\n      clusterLength = 1;\r\n      for (let index1 = index0 + 1; index1 < n && SortableEdge.areUndirectedPartners(baseEdge, this.edges[index1]); index1++) {\r\n        clusterLength++;\r\n      }\r\n      if (this.edges[index0].isNullEdge) {\r\n        this.collectSortableEdgeCluster(index0, index0 + clusterLength, nullEdges);\r\n      } else if (clusterLength === 2 && SortableEdge.areDirectedPartners(baseEdge, this.edges[index0 + 1])) {\r\n        this.collectSortableEdgeCluster(index0, index0 + clusterLength, manifoldPairs);\r\n      } else if (clusterLength === 1) {\r\n        this.collectSortableEdgeCluster(index0, index0 + 1, singletons);\r\n      } else {\r\n        this.collectSortableEdgeCluster(index0, index0 + clusterLength, allOtherClusters);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty*/\r\n// import { Geometry } from \"./Geometry\";\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { PolyfaceData } from \"./PolyfaceData\";\r\nimport { FacetFaceData } from \"./FacetFaceData\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\r\n\r\nfunction allDefined(valueA: any, valueB: any, valueC: any): boolean {\r\n  return valueA !== undefined && valueB !== undefined && valueC !== undefined;\r\n}\r\n\r\n/**\r\n * A Polyface is n abstract mesh structure (of unspecified implementation) that provides a PolyfaceVisitor\r\n * to iterate over its facets.\r\n * @public\r\n */\r\nexport abstract class Polyface extends GeometryQuery {\r\n  /** String name for schema properties */\r\n  public readonly geometryCategory = \"polyface\";\r\n\r\n  /** Underlying polyface data. */\r\n  public data: PolyfaceData;\r\n  protected constructor(data: PolyfaceData) {\r\n    super();\r\n    this.data = data;\r\n  }\r\n  /** create and return a visitor for this concrete polyface. */\r\n  public abstract createVisitor(_numWrap: number): PolyfaceVisitor;\r\n  /** Return the flag indicating if the mesh display must assume both sides are visible. */\r\n  public get twoSided() { return this.data.twoSided; }\r\n  /** set the flag indicating if the mesh display must assume both sides are visible. */\r\n  public set twoSided(value: boolean) { this.data.twoSided = value; }\r\n  /**\r\n     * Check validity of indices into a data array.\r\n     * * It is valid to have  both indices and data undefined.\r\n     * * It is NOT valid for just one to be defined.\r\n     * * Index values at indices[indexPositionA <= i < indexPositionB] must be valid indices to the data array.\r\n     * @param indices array of indices.\r\n     * @param indexPositionA first index to test\r\n     * @param indexPositionB one past final index to test\r\n     * @param data data array.  Only its length is referenced.\r\n     */\r\n  public static areIndicesValid(indices: number[] | undefined, indexPositionA: number, indexPositionB: number, data: any | undefined, dataLength: number): boolean {\r\n    if (indices === undefined && data === undefined)\r\n      return true;\r\n    if (!indices || !data)\r\n      return false;\r\n    if (indexPositionA < 0 || indexPositionA >= indices.length)\r\n      return false;\r\n    if (indexPositionB < indexPositionA || indexPositionB > indices.length)\r\n      return false;\r\n    for (let i = indexPositionA; i < indexPositionB; i++)\r\n      if (indices[i] < 0 || indices[i] >= dataLength)\r\n        return false;\r\n    return true;\r\n  }\r\n  /**\r\n   * Returns true if this polyface has no facets.\r\n   */\r\n  public abstract get isEmpty(): boolean;\r\n}\r\n/**\r\n * An `IndexedPolyface` is a set of facets which can have normal, param, and color arrays with independent point, normal, param, and color indices.\r\n * @public\r\n */\r\nexport class IndexedPolyface extends Polyface {\r\n  /** Test if other is an instance of `IndexedPolyface` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof IndexedPolyface; }\r\n  /** Tests for equivalence between two IndexedPolyfaces. */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof IndexedPolyface) {\r\n      return this.data.isAlmostEqual(other.data) && NumberArray.isExactEqual(this._facetStart, other._facetStart) &&\r\n        NumberArray.isExactEqual(this._facetToFaceData, other._facetToFaceData);\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * Returns true if either the point array or the point index array is empty.\r\n   */\r\n  public get isEmpty(): boolean { return this.data.pointCount === 0 || this.data.pointIndex.length === 0; }\r\n  /**\r\n   * * apply the transform to points\r\n   * * apply the (inverse transpose of) the matrix part to normals\r\n   * * If determinant is negative, also\r\n   *   * negate normals\r\n   *   * reverse index order around each facet.\r\n   * @param transform\r\n   */\r\n  public tryTransformInPlace(transform: Transform) {\r\n    if (this.data.tryTransformInPlace(transform)) {\r\n      const determinant = transform.matrix.determinant();\r\n      if (determinant < 0) {\r\n        this.reverseIndices();\r\n        this.reverseNormals();\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Return a deep clone. */\r\n  public clone(): IndexedPolyface {\r\n    const result = new IndexedPolyface(this.data.clone(), this._facetStart.slice(), this._facetToFaceData.slice());\r\n    return result;\r\n  }\r\n  /** Return a deep clone with transformed points and normals */\r\n  public cloneTransformed(transform: Transform): IndexedPolyface {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n  /** Reverse the order of indices around all facets. */\r\n  public reverseIndices() { this.data.reverseIndices(this._facetStart); }\r\n  /** Reverse the direction of all normal vectors. */\r\n  public reverseNormals() { this.data.reverseNormals(); }\r\n  /**\r\n   * * index to the index array entries for a specific facet.\r\n   * * the facet count is facetStart.length - 1\r\n   * * facet [f] indices run from facetStart[f] to upper limit facetStart[f+1].\r\n   * * Note the array is initialized with one entry.\r\n   */\r\n  protected _facetStart: number[];\r\n\r\n  /**\r\n   * * For facet i, _facetToFaceData[i] is the index of the faceData entry for the facet.\r\n   * * _facetToFaceData has one entry per facet.\r\n   */\r\n  protected _facetToFaceData: number[];\r\n\r\n  /** return face data using a facet index. This is the REFERENCE to the FacetFaceData, not a copy. Returns undefined if none found. */\r\n  public tryGetFaceData(i: number): FacetFaceData | undefined {\r\n    const faceIndex = this._facetToFaceData[i];\r\n    if (faceIndex >= this.data.face.length)\r\n      return undefined;\r\n    return this.data.face[faceIndex];\r\n  }\r\n  /**\r\n   * Constructor for a new polyface.\r\n   * @param data PolyfaceData arrays to capture.\r\n   * @param facetStart optional array of facet start indices (e.g. known during clone)\r\n   * @param facetToFacetData optional array of face identifiers (e.g. known during clone)\r\n   */\r\n  protected constructor(data: PolyfaceData, facetStart?: number[], facetToFaceData?: number[]) {\r\n    super(data);\r\n    if (facetStart)\r\n      this._facetStart = facetStart.slice();\r\n    else {\r\n      this._facetStart = [];\r\n      this._facetStart.push(0);\r\n    }\r\n    if (facetToFaceData)\r\n      this._facetToFaceData = facetToFaceData.slice();\r\n    else\r\n      this._facetToFaceData = [];\r\n  }\r\n  /**\r\n   * * Add facets from source to this polyface.\r\n   * * optionally reverse the facets.\r\n   * * optionally apply a transform to points.\r\n   * * will only copy param, normal, color, and face data if we are already tracking them AND/OR the source contains them\r\n   */\r\n  public addIndexedPolyface(source: IndexedPolyface, reversed: boolean, transform: Transform | undefined) {\r\n    const copyParams = allDefined(this.data.param, source.data.param, source.data.paramIndex);\r\n    const copyNormals = allDefined(this.data.normal, source.data.normal, source.data.normalIndex);\r\n    // Add point data\r\n    const sourceToDestPointIndex = new GrowableFloat64Array();\r\n    sourceToDestPointIndex.ensureCapacity(source.data.pointCount);\r\n    const sourcePoints = source.data.point;\r\n    const xyz = Point3d.create();\r\n    for (let i = 0, n = source.data.point.length; i < n; i++) {\r\n      sourcePoints.getPoint3dAtUncheckedPointIndex(i, xyz);\r\n      if (transform) {\r\n        transform.multiplyPoint3d(xyz, xyz);\r\n        sourceToDestPointIndex.push(this.addPoint(xyz));\r\n      } else\r\n        sourceToDestPointIndex.push(this.addPoint(xyz));\r\n    }\r\n\r\n    // Add point index and facet data\r\n    const numSourceFacets = source._facetStart.length - 1;\r\n    for (let i = 0; i < numSourceFacets; i++) {\r\n      const i0 = source._facetStart[i];\r\n      const i1 = source._facetStart[i + 1];\r\n      if (reversed) {\r\n        for (let j = i1; j-- > i0;) {\r\n          this.addPointIndex(sourceToDestPointIndex.atUncheckedIndex(source.data.pointIndex[j]), source.data.edgeVisible[j]);\r\n        }\r\n      } else {\r\n        for (let j = i0; j < i1; j++) {\r\n          this.addPointIndex(sourceToDestPointIndex.atUncheckedIndex(source.data.pointIndex[j]), source.data.edgeVisible[j]);\r\n        }\r\n      }\r\n      this.terminateFacet(false);\r\n    }\r\n\r\n    // Add param and param index data\r\n    if (copyParams) {\r\n      const myParams = this.data.param!;\r\n\r\n      const startOfNewParams = myParams.length;\r\n      myParams.pushFromGrowableXYArray(source.data.param!);\r\n      for (let i = 0; i < source._facetStart.length; i++) {  // Expect facet start and ends for points to match normals\r\n        const i0 = source._facetStart[i];\r\n        const i1 = source._facetStart[i + 1];\r\n        if (reversed) {\r\n          for (let j = i1; j-- > i0;)\r\n            this.addParamIndex(startOfNewParams + source.data.paramIndex![j]);\r\n        } else {\r\n          for (let j = i0; j < i1; j++)\r\n            this.addParamIndex(startOfNewParams + source.data.paramIndex![j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Add normal and normal index data\r\n    if (copyNormals && source.data.normal) {\r\n      const startOfNewNormals = this.data.normal!.length;\r\n      const numNewNormals = source.data.normal.length;\r\n      for (let i = 0; i < numNewNormals; i++) {\r\n        const sourceNormal = source.data.normal.getVector3dAtCheckedVectorIndex(i)!;\r\n        if (transform) {\r\n          transform.multiplyVector(sourceNormal, sourceNormal);\r\n          this.addNormal(sourceNormal);\r\n        } else {\r\n          this.addNormal(sourceNormal);\r\n        }\r\n      }\r\n      for (let i = 0; i < source._facetStart.length; i++) {  // Expect facet start and ends for points to match normals\r\n        const i0 = source._facetStart[i];\r\n        const i1 = source._facetStart[i + 1];\r\n        if (reversed) {\r\n          for (let j = i1; j-- > i0;)\r\n            this.addNormalIndex(startOfNewNormals + source.data.normalIndex![j]);\r\n        } else {\r\n          for (let j = i0; j < i1; j++)\r\n            this.addNormalIndex(startOfNewNormals + source.data.normalIndex![j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Add color and color index data\r\n    if (this.data.color && source.data.color && source.data.colorIndex) {\r\n      const startOfNewColors = this.data.color.length;\r\n      for (const sourceColor of source.data.color) {\r\n        this.addColor(sourceColor);\r\n      }\r\n      for (let i = 0; i < source._facetStart.length; i++) {  // Expect facet start and ends for points to match colors\r\n        const i0 = source._facetStart[i];\r\n        const i1 = source._facetStart[i + 1];\r\n        if (reversed) {\r\n          for (let j = i1; j-- > i0;)\r\n            this.addColorIndex(startOfNewColors + source.data.colorIndex[j - 1]);\r\n        } else {\r\n          for (let j = i0; j < i1; j++)\r\n            this.addColorIndex(startOfNewColors + source.data.colorIndex[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Add face and facetToFace index data\r\n    if (source.data.face.length !== 0) {\r\n      const startOfNewFaceData = this.data.face.length;\r\n      for (const face of source.data.face) {\r\n        const sourceFaceData = face.clone();\r\n        this.data.face.push(sourceFaceData);\r\n      }\r\n      for (const facetToFaceIdx of source._facetToFaceData) {\r\n        this._facetToFaceData.push(startOfNewFaceData + facetToFaceIdx);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Return the total number of param indices in zero-terminated style, which includes\r\n   * * all the indices in the packed zero-based table\r\n   * * one additional index for the zero-terminator of each facet.\r\n   * @note Note that all index arrays (point, normal, param, color) have the same counts, so there\r\n   * is not a separate query for each of them.\r\n   */\r\n  public get zeroTerminatedIndexCount(): number { return this.data.pointIndex.length + this._facetStart.length - 1; }\r\n  /** Create an empty facet set, with coordinate and index data to be supplied later.\r\n   * @param needNormals true if normals will be constructed\r\n   * @param needParams true if uv parameters will be constructed\r\n   * @param needColors true if colors will e constructed.\r\n   */\r\n  public static create(needNormals: boolean = false, needParams: boolean = false, needColors: boolean = false, twoSided: boolean = false): IndexedPolyface {\r\n    return new IndexedPolyface(new PolyfaceData(needNormals, needParams, needColors, twoSided));\r\n  }\r\n  /** add (a clone of ) a point. return its 0 based index.\r\n   * @param point point coordinates\r\n   * @param priorIndex optional index of prior point to check for repeated coordinates\r\n   * @returns Returns the zero-based index of the added or reused point.\r\n   */\r\n  public addPoint(point: Point3d, priorIndex?: number): number {\r\n    if (priorIndex !== undefined) {\r\n      const distance = this.data.point.distanceIndexToPoint(priorIndex, point);\r\n      if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\r\n        return priorIndex;\r\n    }\r\n    this.data.point.pushXYZ(point.x, point.y, point.z);\r\n    return this.data.point.length - 1;\r\n  }\r\n\r\n  /** add a point.\r\n   * @returns Returns the zero-based index of the added point.\r\n   */\r\n  public addPointXYZ(x: number, y: number, z: number): number { this.data.point.push(Point3d.create(x, y, z)); return this.data.point.length - 1; }\r\n  /** Add a uv param.\r\n   * @returns 0-based index of the added param.\r\n   */\r\n  public addParam(param: Point2d): number {\r\n    if (!this.data.param) this.data.param = new GrowableXYArray();\r\n    this.data.param.push(param);\r\n    return this.data.param.length - 1;\r\n  }\r\n  /** Add a uv parameter to the parameter array.\r\n   * @param priorIndexA first index to check for possible duplicate value.\r\n   * @param priorIndexB second index to check for possible duplicate value.\r\n   * @returns 0-based index of the added or reused param.\r\n   */\r\n  public addParamUV(u: number, v: number, priorIndexA?: number, priorIndexB?: number): number {\r\n    if (!this.data.param) this.data.param = new GrowableXYArray();\r\n    if (priorIndexA !== undefined && this.data.isAlmostEqualParamIndexUV(priorIndexA, u, v))\r\n      return priorIndexA;\r\n    if (priorIndexB !== undefined && this.data.isAlmostEqualParamIndexUV(priorIndexB, u, v))\r\n      return priorIndexB;\r\n    this.data.param.push(Point2d.create(u, v));\r\n    return this.data.param.length - 1;\r\n  }\r\n\r\n  /** Add a normal vector\r\n   * @param priorIndexA first index to check for possible duplicate value.\r\n   * @param priorIndexB second index to check for possible duplicate value.\r\n   * @returns 0-based index of the added or reused normal.\r\n   */\r\n  public addNormal(normal: Vector3d, priorIndexA?: number, priorIndexB?: number): number {\r\n    if (this.data.normal !== undefined) {\r\n      let distance;\r\n\r\n      if (priorIndexA !== undefined) {\r\n        distance = this.data.normal.distanceIndexToPoint(priorIndexA, normal);\r\n        if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\r\n          return priorIndexA;\r\n      }\r\n      if (priorIndexB !== undefined) {\r\n        distance = this.data.normal.distanceIndexToPoint(priorIndexB, normal);\r\n        if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\r\n          return priorIndexB;\r\n      }\r\n      const tailIndex = this.data.normal.length - 1;\r\n      distance = this.data.normal.distanceIndexToPoint(tailIndex, normal);\r\n      if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\r\n        return tailIndex;\r\n    }\r\n\r\n    return this.addNormalXYZ(normal.x, normal.y, normal.z);\r\n  }\r\n\r\n  /** Add a normal vector given by direct coordinates\r\n   * @returns 0-based index of the added or reused param.\r\n   */\r\n  public addNormalXYZ(x: number, y: number, z: number): number {\r\n    if (!this.data.normal) this.data.normal = new GrowableXYZArray();\r\n    this.data.normal!.pushXYZ(x, y, z);\r\n    return this.data.normal!.length - 1;\r\n  }\r\n\r\n  /** Add a color\r\n   * @returns 0-based index of the added or reused color.\r\n   */\r\n  public addColor(color: number): number {\r\n    if (!this.data.color) this.data.color = [];\r\n    this.data.color.push(color);\r\n    return this.data.color.length - 1;\r\n  }\r\n  /** Add a point index with edge visibility flag. */\r\n  public addPointIndex(index: number, visible: boolean = true): void { this.data.pointIndex.push(index); this.data.edgeVisible.push(visible); }\r\n  /** Add a normal index */\r\n  public addNormalIndex(index: number): void {\r\n    if (!this.data.normalIndex)\r\n      this.data.normalIndex = [];\r\n    this.data.normalIndex.push(index);\r\n  }\r\n  /** Add a param index */\r\n  public addParamIndex(index: number): void {\r\n    if (!this.data.paramIndex)\r\n      this.data.paramIndex = [];\r\n    this.data.paramIndex.push(index);\r\n  }\r\n  /** Add a color index */\r\n  public addColorIndex(index: number): void {\r\n    if (!this.data.colorIndex)\r\n      this.data.colorIndex = [];\r\n    this.data.colorIndex.push(index);\r\n  }\r\n\r\n  /** clean up the open facet.  return the returnValue (so caller can easily return cleanupOpenFacet(\"message\")) */\r\n  public cleanupOpenFacet(): void {\r\n    this.data.trimAllIndexArrays(this.data.pointIndex.length);\r\n  }\r\n  /** announce the end of construction of a facet.\r\n   *\r\n   * * The \"open\" facet is checked for:\r\n   *\r\n   * **  Same number of indices among all active index arrays --  point, normal, param, color\r\n   * **  All indices are within bounds of the respective data arrays.\r\n   * *  in error cases, all index arrays are trimmed back to the size when previous facet was terminated.\r\n   * *  \"undefined\" return is normal.   Any other return is a description of an error.\r\n   */\r\n  public terminateFacet(validateAllIndices: boolean = true): any {\r\n    const numFacets = this._facetStart.length - 1;\r\n    const lengthA = this._facetStart[numFacets];  // number of indices in accepted facets\r\n    const lengthB = this.data.pointIndex.length; // number of indices including the open facet\r\n    if (validateAllIndices) {\r\n      const messages: any[] = [];\r\n\r\n      if (lengthB < lengthA + 2)\r\n        messages.push(\"Less than 3 indices in open facet\");\r\n      if (this.data.normalIndex && this.data.normalIndex.length !== lengthB)\r\n        messages.push(\"normalIndex count must match pointIndex count\");\r\n      if (this.data.paramIndex && this.data.paramIndex.length !== lengthB)\r\n        messages.push(\"paramIndex count must equal pointIndex count\");\r\n      if (this.data.colorIndex && this.data.colorIndex.length !== lengthB)\r\n        messages.push(\"colorIndex count must equal pointIndex count\");\r\n      if (this.data.edgeVisible.length !== lengthB)\r\n        messages.push(\"visibleIndex count must equal pointIndex count\");\r\n\r\n      if (!Polyface.areIndicesValid(this.data.normalIndex, lengthA, lengthB, this.data.normal, this.data.normal ? this.data.normal.length : 0))\r\n        messages.push(\"invalid normal indices in open facet\");\r\n      if (messages.length > 0) {\r\n        this.cleanupOpenFacet();\r\n        return messages;\r\n      }\r\n    }\r\n    // appending to facetStart accepts the facet !!!\r\n    this._facetStart.push(lengthB);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * All terminated facets added since the declaration of the previous face\r\n   * will be grouped into a new face with their own 2D range.\r\n   */\r\n  /** (read-only property) number of facets */\r\n  public get facetCount(): number { return this._facetStart.length - 1; }\r\n  /** (read-only property) number of faces */\r\n  public get faceCount(): number { return this.data.faceCount; }\r\n  /** (read-only property) number of points */\r\n  public get pointCount(): number { return this.data.pointCount; }\r\n  /** (read-only property) number of colors */\r\n  public get colorCount(): number { return this.data.colorCount; }\r\n  /** (read-only property) number of parameters */\r\n  public get paramCount(): number { return this.data.paramCount; }\r\n  /** (read-only property) number of normals */\r\n  public get normalCount(): number { return this.data.normalCount; }\r\n  /** Return the number of edges in a particular facet. */\r\n  public numEdgeInFacet(facetIndex: number): number {\r\n    if (this.isValidFacetIndex(facetIndex))\r\n      return this._facetStart[facetIndex + 1] - this._facetStart[facetIndex];\r\n    return 0;\r\n  }\r\n  /** test if `index` is a valid facet index. */\r\n  public isValidFacetIndex(index: number): boolean { return index >= 0 && index + 1 < this._facetStart.length; }\r\n  /** ASSUME valid facet index . .. return its start index in index arrays. */\r\n  public facetIndex0(index: number): number { return this._facetStart[index]; }\r\n  /** ASSUME valid facet index . .. return its end index in index arrays. */\r\n  public facetIndex1(index: number): number { return this._facetStart[index + 1]; }\r\n  /** create a visitor for this polyface */\r\n  public createVisitor(numWrap: number = 0): PolyfaceVisitor { return IndexedPolyfaceVisitor.create(this, numWrap); }\r\n  /** Return the range of (optionally transformed) points in this mesh. */\r\n  public range(transform?: Transform, result?: Range3d): Range3d { return this.data.range(result, transform); }\r\n  /** Extend `range` with coordinates from this mesh */\r\n  public extendRange(range: Range3d, transform?: Transform): void { this.data.range(range, transform); }\r\n\r\n  /** Given the index of a facet, return the data pertaining to the face it is a part of. */\r\n  public getFaceDataByFacetIndex(facetIndex: number): FacetFaceData {\r\n    return this.data.face[this._facetToFaceData[facetIndex]];\r\n  }\r\n\r\n  /**\r\n   * All terminated facets since the last face declaration will be mapped to a single new FacetFaceData object\r\n   * using facetToFaceData[]. FacetFaceData holds the 2D range of the face. Returns true if successful, false otherwise.\r\n   */\r\n  public setNewFaceData(endFacetIndex: number = 0): boolean {\r\n    const facetStart = this._facetToFaceData.length;\r\n    if (facetStart >= this._facetStart.length)\r\n      return false;\r\n\r\n    if (0 === endFacetIndex)  // The default for endFacetIndex is really the last facet\r\n      endFacetIndex = this._facetStart.length; // Last facetStart index corresponds to the next facet if we were to create one\r\n\r\n    const faceData = FacetFaceData.createNull();\r\n    const visitor = IndexedPolyfaceVisitor.create(this, 0);\r\n\r\n    if (!visitor.moveToReadIndex(facetStart)) {  // Move visitor to first facet of new face\r\n      return false;\r\n    }\r\n\r\n    // If parameter range is provided (by the polyface planeSet clipper) then use it\r\n    const paramDefined = this.data.param !== undefined;\r\n    const setParamRange: boolean = faceData.paramRange.isNull && paramDefined;\r\n\r\n    do {\r\n      if (setParamRange && visitor.param !== undefined)\r\n        visitor.param.extendRange(faceData.paramRange);\r\n    } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < endFacetIndex);\r\n\r\n    if (paramDefined && !(this.data.param!.length === 0) && faceData.paramDistanceRange.isNull)\r\n      faceData.setParamDistanceRangeFromNewFaceData(this, facetStart, endFacetIndex);\r\n\r\n    this.data.face.push(faceData);\r\n    const faceDataIndex = this.data.face.length - 1;\r\n    for (let i = this._facetToFaceData.length; i < endFacetIndex; i++)\r\n      this._facetToFaceData.push(0 === this._facetStart[i] ? 0 : faceDataIndex);\r\n\r\n    return true;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleIndexedPolyface(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleIndexedPolyface(this);\r\n  }\r\n}\r\n\r\n/**\r\n * A PolyfaceVisitor manages data while walking through facets.\r\n *\r\n * * The polyface visitor holds data for one facet at a time.\r\n * * The caller can request the position in the addressed facets as a \"readIndex.\"\r\n * * The readIndex value (as a number) is not promised to be sequential. (I.e. it might be a simple facet count or might be\r\n * @public\r\n */\r\nexport interface PolyfaceVisitor extends PolyfaceData {\r\n  /** Load data for the facet with given index. */\r\n  moveToReadIndex(index: number): boolean;\r\n  /** Return  the readIndex of the currently loaded facet */\r\n  currentReadIndex(): number;\r\n  /** Load data for the next facet. */\r\n  moveToNextFacet(): boolean;\r\n  /** Reset to initial state for reading all facets sequentially with moveToNextFacet */\r\n  reset(): void;\r\n  /** Return the point index of vertex i within the currently loaded facet */\r\n  clientPointIndex(i: number): number;\r\n  /** Return the param index of vertex i within the currently loaded facet */\r\n  clientParamIndex(i: number): number;\r\n  /** Return the normal index of vertex i within the currently loaded facet */\r\n  clientNormalIndex(i: number): number;\r\n  /** Return the color index of vertex i within the currently loaded facet */\r\n  clientColorIndex(i: number): number;\r\n  /** Return the aux data index of vertex i within the currently loaded facet */\r\n  clientAuxIndex(i: number): number;\r\n  /** return the client polyface */\r\n  clientPolyface(): Polyface;\r\n  /** Set the number of vertices to replicate in visitor arrays. */\r\n  setNumWrap(numWrap: number): void;\r\n\r\n  /** clear the contents of all arrays.  Use this along with transferDataFrom methods to build up new facets */\r\n  clearArrays(): void;\r\n  /** transfer data from a specified index of the other visitor as new data in this visitor. */\r\n  pushDataFrom(other: PolyfaceVisitor, index: number): void;\r\n  /** transfer interpolated data from the other visitor.\r\n   * * all data values are interpolated at `fraction` between `other` values at index0 and index1.\r\n   */\r\n  pushInterpolatedDataFrom(other: PolyfaceVisitor, index0: number, fraction: number, index1: number): void;\r\n\r\n}\r\n\r\n/**\r\n * An `IndexedPolyfaceVisitor` is an iterator-like object that \"visits\" facets of a mesh.\r\n * * The visitor extends a `PolyfaceData ` class, so it can at any time hold all the data of a single facet.\r\n * @public\r\n */\r\nexport class IndexedPolyfaceVisitor extends PolyfaceData implements PolyfaceVisitor {\r\n  private _currentFacetIndex: number;\r\n  private _nextFacetIndex: number;\r\n  private _numWrap: number;\r\n  private _numEdges: number;\r\n  private _polyface: IndexedPolyface;\r\n  // to be called from static factory method that validates the polyface ...\r\n  private constructor(facets: IndexedPolyface, numWrap: number) {\r\n    super(facets.data.normalCount > 0, facets.data.paramCount > 0, facets.data.colorCount > 0, facets.twoSided);\r\n    this._polyface = facets;\r\n    this._numWrap = numWrap;\r\n    if (facets.data.auxData)\r\n      this.auxData = facets.data.auxData.createForVisitor();\r\n\r\n    this.reset();\r\n    this._numEdges = 0;\r\n    this._nextFacetIndex = 0;\r\n    this._currentFacetIndex = -1;\r\n\r\n  }\r\n  /** Return the client polyface object. */\r\n  public clientPolyface(): Polyface { return this._polyface; }\r\n  /** Set the number of vertices duplicated (e.g. 1 for start and end) in arrays in the visitor. */\r\n  public setNumWrap(numWrap: number) { this._numWrap = numWrap; }\r\n\r\n  /** Return the number of edges in the current facet.\r\n   * * Not that if this visitor has `numWrap` greater than zero, the number of edges is smaller than the number of points.\r\n   */\r\n  public get numEdgesThisFacet(): number { return this._numEdges; }\r\n  /** Create a visitor for iterating the facets of `polyface`, with indicated number of points to be added to each facet to produce closed point arrays\r\n   * Typical wrap counts are:\r\n   * * 0 -- leave the point arrays with \"missing final edge\"\r\n   * * 1 -- add point 0 as closure point\r\n   * * 2 -- add points 0 and 1 as closure and wrap point.  This is useful when vertex visit requires two adjacent vectors, e.g. for cross products.\r\n   */\r\n  public static create(polyface: IndexedPolyface, numWrap: number): IndexedPolyfaceVisitor {\r\n    return new IndexedPolyfaceVisitor(polyface, numWrap);\r\n  }\r\n  /** Advance the iterator to a particular facet in the client polyface */\r\n  public moveToReadIndex(facetIndex: number): boolean {\r\n    if (!this._polyface.isValidFacetIndex(facetIndex)) return false;\r\n    this._currentFacetIndex = facetIndex;\r\n    this._nextFacetIndex = facetIndex + 1;\r\n    this._numEdges = this._polyface.numEdgeInFacet(facetIndex);\r\n    this.resizeAllDataArrays(this._numEdges + this._numWrap);\r\n    this.gatherIndexedData(this._polyface.data, this._polyface.facetIndex0(this._currentFacetIndex), this._polyface.facetIndex1(this._currentFacetIndex), this._numWrap);\r\n    return true;\r\n  }\r\n  /** Advance the iterator to a the 'next' facet in the client polyface */\r\n  public moveToNextFacet(): boolean {\r\n    if (this._nextFacetIndex !== this._currentFacetIndex)\r\n      return this.moveToReadIndex(this._nextFacetIndex);\r\n    this._nextFacetIndex++;\r\n    return true;\r\n  }\r\n  /** Reset the iterator to start at the first facet of the polyface. */\r\n  public reset(): void {\r\n    this.moveToReadIndex(0);\r\n    this._nextFacetIndex = 0; // so immediate moveToNextFacet stays here.\r\n  }\r\n\r\n  /**\r\n   * Attempts to extract the distance parameter for the given vertex index on the current facet\r\n   * Returns the distance parameter as a point. Returns undefined on failure.\r\n   */\r\n  public tryGetDistanceParameter(index: number, result?: Point2d): Point2d | undefined {\r\n    if (index >= this.numEdgesThisFacet)\r\n      return undefined;\r\n\r\n    if (this.param === undefined || this._polyface.data.face.length === 0)\r\n      return undefined;\r\n\r\n    const faceData = this._polyface.tryGetFaceData(this._currentFacetIndex);\r\n    if (!faceData)\r\n      return undefined;\r\n    return faceData.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(index), this.param.getYAtUncheckedPointIndex(index), result);\r\n  }\r\n\r\n  /**\r\n   * Attempts to extract the normalized parameter (0,1) for the given vertex index on the current facet.\r\n   * Returns the normalized parameter as a point. Returns undefined on failure.\r\n   */\r\n  public tryGetNormalizedParameter(index: number, result?: Point2d): Point2d | undefined {\r\n    if (index >= this.numEdgesThisFacet)\r\n      return undefined;\r\n\r\n    if (this.param === undefined || this._polyface.data.face.length === 0)\r\n      return undefined;\r\n\r\n    const faceData = this._polyface.tryGetFaceData(this._currentFacetIndex);\r\n    if (!faceData)\r\n      return undefined;\r\n    return faceData.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(index), this.param.getYAtUncheckedPointIndex(index), result);\r\n  }\r\n  /** Return the index (in the client polyface) of the current facet */\r\n  public currentReadIndex(): number { return this._currentFacetIndex; }\r\n  /** Return the point index of vertex i within the currently loaded facet */\r\n  public clientPointIndex(i: number): number { return this.pointIndex[i]; }\r\n  /** Return the param index of vertex i within the currently loaded facet */\r\n  public clientParamIndex(i: number): number { return this.paramIndex ? this.paramIndex[i] : -1; }\r\n  /** Return the normal index of vertex i within the currently loaded facet */\r\n  public clientNormalIndex(i: number): number { return this.normalIndex ? this.normalIndex[i] : -1; }\r\n  /** Return the color index of vertex i within the currently loaded facet */\r\n  public clientColorIndex(i: number): number { return this.colorIndex ? this.colorIndex[i] : -1; }\r\n  /** Return the aux data index of vertex i within the currently loaded facet */\r\n  public clientAuxIndex(i: number): number { return this.auxData ? this.auxData.indices[i] : -1; }\r\n\r\n  /** clear the contents of all arrays.  Use this along with transferDataFrom methods to build up new facets */\r\n  public clearArrays(): void {\r\n    if (this.point !== undefined)\r\n      this.point.length = 0;\r\n    if (this.param !== undefined)\r\n      this.param.length = 0;\r\n    if (this.normal !== undefined)\r\n      this.normal.length = 0;\r\n    if (this.color !== undefined)\r\n      this.color.length = 0;\r\n  }\r\n  /** transfer data from a specified index of the other visitor as new data in this visitor. */\r\n  public pushDataFrom(other: PolyfaceVisitor, index: number): void {\r\n    this.point.pushFromGrowableXYZArray(other.point, index);\r\n    if (this.color && other.color && index < other.color.length)\r\n      this.color.push(other.color[index]);\r\n    if (this.param && other.param && index < other.param.length)\r\n      this.param.pushFromGrowableXYArray(other.param, index);\r\n    if (this.normal && other.normal && index < other.normal.length)\r\n      this.normal.pushFromGrowableXYZArray(other.normal, index);\r\n  }\r\n  /** transfer interpolated data from the other visitor.\r\n   * * all data values are interpolated at `fraction` between `other` values at index0 and index1.\r\n   */\r\n  public pushInterpolatedDataFrom(other: PolyfaceVisitor, index0: number, fraction: number, index1: number): void {\r\n    this.point.pushInterpolatedFromGrowableXYZArray(other.point, index0, fraction, index1);\r\n    if (this.color && other.color && index0 < other.color.length && index1 < other.color.length)\r\n      this.color.push(interpolateColor(other.color[index0], fraction, other.color[index1]));\r\n    if (this.param && other.param && index0 < other.param.length && index1 < other.param.length)\r\n      this.param.pushInterpolatedFromGrowableXYArray(other.param, index0, fraction, index1);\r\n    if (this.normal && other.normal && index0 < other.normal.length && index1 < other.normal.length)\r\n      this.normal.pushInterpolatedFromGrowableXYZArray(other.normal, index0, fraction, index1);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * * shift to right by shiftBits.\r\n * * mask off the low 8 bits\r\n * * interpolate the number\r\n * * truncate to floor\r\n * * shift left\r\n * * Hence all numbers in and out of the floating point are 0..255.\r\n * @param color0\r\n * @param fraction\r\n * @param color1\r\n * @param shiftBits\r\n */\r\nfunction interpolateByte(color0: number, fraction: number, color1: number, shiftBits: number): number {\r\n  color0 = (color0 >>> shiftBits) & 0xFF;\r\n  color1 = (color1 >>> shiftBits) & 0xFF;\r\n  const color = Math.floor(color0 + fraction * (color1 - color0)) & 0xFF;\r\n  return color << shiftBits;\r\n}\r\n\r\nfunction interpolateColor(color0: number, fraction: number, color1: number) {\r\n  // don't allow fractions outside the individual byte ranges.\r\n  fraction = Geometry.clamp(fraction, 0, 1);\r\n  // interpolate each byte in place ....\r\n  /*\r\n  const byte0 = interpolateLowByte(color0 & 0xFF, fraction, color1 & 0xFF);\r\n  const byte1 = interpolateLowByte((color0 & 0xFF00) >>> 8, fraction, (color1 & 0xFF00) >>> 8) << 8;\r\n  const byte2 = interpolateLowByte((color0 & 0xFF0000) >>> 16, fraction, (color1 & 0xFF0000) >>> 16) << 16;\r\n  const byte3 = interpolateLowByte((color0 & 0xFF000000) >>> 24, fraction, (color1 & 0xFF000000) >>> 24) << 24;\r\n  */\r\n  const byte0 = interpolateByte(color0, fraction, color1, 0);\r\n  const byte1 = interpolateByte(color0, fraction, color1, 8);\r\n  const byte2 = interpolateByte(color0, fraction, color1, 16);\r\n  const byte3 = interpolateByte(color0, fraction, color1, 24);\r\n\r\n  return (byte0 | byte1 | byte2 | byte3);\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\nimport { IndexedPolyface, PolyfaceVisitor } from \"./Polyface\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d, XYZ } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { BoxTopology } from \"./BoxTopology\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Cone } from \"../solid/Cone\";\r\nimport { CurveChain, CurveCollection } from \"../curve/CurveCollection\";\r\n\r\nimport { Sphere } from \"../solid/Sphere\";\r\nimport { TorusPipe } from \"../solid/TorusPipe\";\r\nimport { LinearSweep } from \"../solid/LinearSweep\";\r\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\r\nimport { Box } from \"../solid/Box\";\r\nimport { RuledSweep } from \"../solid/RuledSweep\";\r\nimport { AnyCurve, AnyRegion } from \"../curve/CurveChain\";\r\nimport { Geometry, AxisOrder } from \"../Geometry\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { HalfEdgeGraph, HalfEdge, HalfEdgeToBooleanFunction } from \"../topology/Graph\";\r\nimport { NullGeometryHandler, UVSurface } from \"../geometry3d/GeometryHandler\";\r\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { StrokeCountSection } from \"../curve/Query/StrokeCountChain\";\r\nimport { ParityRegion } from \"../curve/ParityRegion\";\r\nimport { Range1d } from \"../geometry3d/Range\";\r\nimport { ConstructCurveBetweenCurves } from \"../curve/ConstructCurveBetweenCurves\";\r\nimport { CylindricalRangeQuery } from \"../curve/Query/CylindricalRange\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { BilinearPatch } from \"../geometry3d/BilinearPatch\";\r\nimport { FrameBuilder } from \"../geometry3d/FrameBuilder\";\r\nimport { Triangulator } from \"../topology/Triangulation\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\nimport { SweepContour } from \"../solid/SweepContour\";\r\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\r\nimport { Point3dArrayCarrier } from \"../geometry3d/Point3dArrayCarrier\";\r\nimport { GreedyTriangulationBetweenLineStrings } from \"./GreedyTriangulationBetweenLineStrings\";\r\nimport { BarycentricTriangle } from \"../geometry3d/BarycentricTriangle\";\r\n\r\n/* tslint:disable:variable-name prefer-for-of*/\r\n/**\r\n * A FacetSector\r\n * * initially holds coordinate data for a place where xyz and sectionDerivative are known\r\n * * normal is computed as a deferred step using an edge to adjacent place on ruled surface\r\n * * indices are set up even later.\r\n */\r\nclass FacetSector {\r\n  public xyz: Point3d;\r\n  public xyzIndex: number;\r\n  public normal?: Vector3d;\r\n  public normalIndex: number;\r\n  public uv?: Point2d;\r\n  public uvIndex: number;\r\n  public sectionDerivative?: Vector3d;\r\n  public constructor(needNormal: boolean = false, needUV: boolean = false, needSectionDerivative: boolean = false) {\r\n    this.xyz = Point3d.create();\r\n    this.normalIndex = -1;\r\n    this.uvIndex = -1;\r\n\r\n    this.xyzIndex = -1;\r\n    if (needNormal) {\r\n      this.normal = Vector3d.create();\r\n    }\r\n    if (needUV) {\r\n      this.uv = Point2d.create();\r\n      this.uvIndex = -1;\r\n    }\r\n    if (needSectionDerivative) {\r\n      this.sectionDerivative = Vector3d.create();\r\n    }\r\n  }\r\n  /** copy contents (not pointers) from source\r\n   * * ASSUME all fields defined in this are defined int the source (undefined check only needed on this)\r\n   */\r\n  public copyContentsFrom(other: FacetSector) {\r\n    this.xyz.setFromPoint3d(other.xyz);\r\n    this.xyzIndex = other.xyzIndex;\r\n    if (this.normal)\r\n      this.normal.setFromVector3d(other.normal!);\r\n    this.normalIndex = other.normalIndex;\r\n    if (this.uv)\r\n      this.uv.setFrom(other.uv);\r\n    this.uvIndex = other.uvIndex;\r\n    if (this.sectionDerivative)\r\n      this.sectionDerivative.setFrom(other.sectionDerivative!);\r\n  }\r\n  /** access xyz, derivative from given arrays.\r\n   * * ASSUME corresponding defined conditions\r\n   * * xyz and derivative are set.\r\n   * * index fields for updated data are cleared to -1.\r\n   */\r\n  public loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i: number, packedXYZ: GrowableXYZArray, packedDerivatives?: GrowableXYZArray, fractions?: GrowableFloat64Array, v?: number) {\r\n    packedXYZ.getPoint3dAtCheckedPointIndex(i, this.xyz);\r\n    if (fractions && v !== undefined)\r\n      this.uv = Point2d.create(fractions.atUncheckedIndex(i), v);\r\n    this.xyzIndex = -1;\r\n    this.normalIndex = -1;\r\n    this.uvIndex = -1;\r\n    if (this.sectionDerivative !== undefined && packedDerivatives !== undefined)\r\n      packedDerivatives!.getVector3dAtCheckedVectorIndex(i, this.sectionDerivative);\r\n  }\r\n  private static suppressSmallUnitVectorComponents(uvw: XYZ) {\r\n    const tol = 1.0e-15;\r\n    if (Math.abs(uvw.x) < tol) uvw.x = 0.0;\r\n    if (Math.abs(uvw.y) < tol) uvw.y = 0.0;\r\n    if (Math.abs(uvw.z) < tol) uvw.z = 0.0;\r\n  }\r\n  private static _edgeVector: Vector3d = Vector3d.create();\r\n  /**\r\n   * given two sectors with xyz and sectionDerivative (u derivative)\r\n   * use the edge from A to B as v direction in-surface derivative.\r\n   * compute cross products (and normalize)\r\n   * @param sectorA \"lower\" sector\r\n   * @param sectorB \"upper\" sector\r\n   *\r\n   */\r\n  public static computeNormalsAlongRuleLine(sectorA: FacetSector, sectorB: FacetSector) {\r\n    // We expect that if sectionDerivative is defined so is normal.\r\n    // (If not, the cross product calls will generate normals that are never used ..  not good, garbage collector will clean up.)\r\n    if (sectorA.sectionDerivative && sectorB.sectionDerivative) {\r\n      const vectorAB = FacetSector._edgeVector;\r\n      Vector3d.createStartEnd(sectorA.xyz, sectorB.xyz, vectorAB);\r\n      sectorA.sectionDerivative!.crossProduct(vectorAB, sectorA.normal);\r\n      sectorB.sectionDerivative!.crossProduct(vectorAB, sectorB.normal);\r\n      sectorA.normal!.normalizeInPlace();\r\n      sectorB.normal!.normalizeInPlace();\r\n      FacetSector.suppressSmallUnitVectorComponents(sectorA.normal!);\r\n      FacetSector.suppressSmallUnitVectorComponents(sectorB.normal!);\r\n    }\r\n  }\r\n}\r\n/**\r\n * UVSurfaceOps is a class containing static methods operating on UVSurface objects.\r\n * @public\r\n */\r\nexport class UVSurfaceOps {\r\n  private constructor() { }  // private constructor -- no instances.\r\n  /**\r\n   * * evaluate `numEdge+1` points at surface uv parameters interpolated between (u0,v0) and (u1,v1)\r\n   * * accumulate the xyz in a linestring.\r\n   * * If xyzToUV is given, also accumulate transformed values as surfaceUV\r\n   * * use xyzToUserUV transform to convert xyz to uv stored in the linestring (this uv is typically different from surface uv -- e.g. torus cap plane coordinates)\r\n   * @param surface\r\n   * @param u0 u coordinate at start of parameter space line\r\n   * @param v0 v coordinate at end of parameter space line\r\n   * @param u1 u coordinate at start of parameter space line\r\n   * @param v1 v coordinate at end of parameter space line\r\n   * @param numEdge number of edges.   (`numEdge+1` points are evaluated)\r\n   * @param saveUV if true, save each surface uv fractions with `linestring.addUVParamsAsUV (u,v)`\r\n   * @param saveFraction if true, save each fractional coordinate (along the u,v line) with `linestring.addFraction (fraction)`\r\n   *\r\n   * @param xyzToUV\r\n   */\r\n  public static createLinestringOnUVLine(\r\n    surface: UVSurface,\r\n    u0: number,\r\n    v0: number,\r\n    u1: number,\r\n    v1: number,\r\n    numEdge: number,\r\n    saveUV: boolean = false,\r\n    saveFraction: boolean = false): LineString3d {\r\n\r\n    const ls = LineString3d.create();\r\n    const xyz = Point3d.create();\r\n    let fraction, u, v;\r\n    const numEvaluate = numEdge + 1;\r\n    for (let i = 0; i < numEvaluate; i++) {\r\n      fraction = i / numEdge;\r\n      u = Geometry.interpolate(u0, fraction, u1);\r\n      v = Geometry.interpolate(v0, fraction, v1);\r\n      surface.uvFractionToPoint(u, v, xyz);\r\n      ls.addPoint(xyz);\r\n      if (saveUV)\r\n        ls.addUVParamAsUV(u, v);\r\n      if (saveFraction)\r\n        ls.addFraction(fraction);\r\n    }\r\n    return ls;\r\n  }\r\n}\r\n/**\r\n *\r\n * * Simple construction for strongly typed GeometryQuery objects:\r\n *\r\n *  * Create a builder with `builder = PolyfaceBuilder.create()`\r\n *  * Add GeometryQuery objects:\r\n *\r\n *    * `builder.addGeometryQuery(g: GeometryQuery)`\r\n *    * `builder.addCone(cone: Cone)`\r\n *    * `builder.addTorusPipe(surface: TorusPipe)`\r\n *    * `builder.addLinearSweepLineStrings(surface: LinearSweep)`\r\n *    * `builder.addRotationalSweep(surface: RotationalSweep)`\r\n *    * `builder.addLinearSweep(surface: LinearSweep)`\r\n *    * `builder.addRuledSweep(surface: RuledSweep)`\r\n *    * `builder.addSphere(sphere: Sphere)`\r\n *    * `builder.addBox(box: Box)`\r\n *    * `builder.addIndexedPolyface(polyface)`\r\n *  *  Extract with `builder.claimPolyface (true)`\r\n *\r\n * * Simple construction for ephemeral constructive data:\r\n *\r\n *  * Create a builder with `builder = PolyfaceBuilder.create()`\r\n *  * Add from fragmentary data:\r\n *    * `builder.addBetweenLineStrings (linestringA, linestringB, addClosure)`\r\n *    * `builder.addBetweenTransformedLineStrings (curves, transformA, transformB, addClosure)`\r\n *    * `builder.addBetweenStroked (curveA, curveB)`\r\n *    * `builder.addLinearSweepLineStrings (contour, vector)`\r\n *    * `builder.addPolygon (points, numPointsToUse)`\r\n *    * `builder.addTransformedUnitBox (transform)`\r\n *    * `builder.addTriangleFan (conePoint, linestring, toggleOrientation)`\r\n *    * `builder.addTrianglesInUncheckedPolygon (linestring, toggle)`\r\n *    * `builder.addUVGridBody(surface,numU, numV, createFanInCaps)`\r\n *    * `builder.addGraph(Graph, acceptFaceFunction)`\r\n *  *  Extract with `builder.claimPolyface(true)`\r\n *\r\n * * Low-level detail construction -- direct use of indices\r\n *  * Create a builder with `builder = PolyfaceBuilder.create()`\r\n *  * Add GeometryQuery objects\r\n *    * `builder.findOrAddPoint(point)`\r\n *    * `builder.findOrAddPointInLineString (linestring, index)`\r\n *    * `builder.findOrAddTransformedPointInLineString(linestring, index, transform)`\r\n *    * `builder.findOrAddPointXYZ(x,y,z)`\r\n *    * `builder.addTriangle (point0, point1, point2)`\r\n *    * `builder.addQuad (point0, point1, point2, point3)`\r\n *    * `builder.addOneBasedPointIndex (index)`\r\n * @public\r\n */\r\nexport class PolyfaceBuilder extends NullGeometryHandler {\r\n  private _polyface: IndexedPolyface;\r\n  private _options: StrokeOptions;\r\n  /** return (pointer to) the `StrokeOptions` in use by the builder. */\r\n  public get options(): StrokeOptions { return this._options; }\r\n  // State data that affects the current construction.\r\n  private _reversed: boolean;\r\n  /** Ask if this builder is reversing vertex order as loops are received. */\r\n  public get reversedFlag(): boolean { return this._reversed; }\r\n  /** extract the polyface. */\r\n  public claimPolyface(compress: boolean = true): IndexedPolyface {\r\n    if (compress)\r\n      this._polyface.data.compress();\r\n    return this._polyface;\r\n  }\r\n  /** Toggle (reverse) the flag controlling orientation flips for newly added facets. */\r\n  public toggleReversedFacetFlag() { this._reversed = !this._reversed; }\r\n\r\n  private constructor(options?: StrokeOptions) {\r\n    super();\r\n    this._options = options ? options : StrokeOptions.createForFacets();\r\n    this._polyface = IndexedPolyface.create(this._options.needNormals,\r\n      this._options.needParams, this._options.needColors, this._options.needTwoSided);\r\n    this._reversed = false;\r\n  }\r\n  /**\r\n   * Create a builder with given StrokeOptions\r\n   * @param options StrokeOptions (captured)\r\n   */\r\n  public static create(options?: StrokeOptions): PolyfaceBuilder {\r\n    return new PolyfaceBuilder(options);\r\n  }\r\n  /** add facets for a transformed unit box. */\r\n  public addTransformedUnitBox(transform: Transform) {\r\n    const pointIndex0 = this._polyface.data.pointCount;\r\n    // these will have sequential indices starting at pointIndex0 . . .\r\n    for (const p of BoxTopology.points)\r\n      this._polyface.addPoint(transform.multiplyPoint3d(p));\r\n\r\n    for (const facet of BoxTopology.cornerIndexCCW) {\r\n      for (const pointIndex of facet)\r\n        this._polyface.addPointIndex(pointIndex0 + pointIndex);\r\n      this._polyface.terminateFacet();\r\n    }\r\n  }\r\n\r\n  /** Add triangles from points[0] to each far edge.\r\n   * @param ls linestring with point coordinates\r\n   * @param toggle if true, wrap the triangle creation in toggleReversedFacetFlag.\r\n   */\r\n  public addTriangleFan(conePoint: Point3d, ls: LineString3d, toggle: boolean): void {\r\n    const n = ls.numPoints();\r\n    if (n > 2) {\r\n      if (toggle)\r\n        this.toggleReversedFacetFlag();\r\n      const index0 = this.findOrAddPoint(conePoint);\r\n      let index1 = this.findOrAddPointInLineString(ls, 0)!;\r\n      let index2 = 0;\r\n      for (let i = 1; i < n; i++) {\r\n        index2 = this.findOrAddPointInLineString(ls, i)!;\r\n        this.addIndexedTrianglePointIndexes(index0, index1, index2);\r\n        index1 = index2;\r\n      }\r\n      if (toggle)\r\n        this.toggleReversedFacetFlag();\r\n    }\r\n  }\r\n\r\n  /** Add triangles from points[0] to each far edge\r\n   * * Assume the polygon is convex.\r\n   * * i.e. simple triangulation from point0\r\n   * * i.e. simple cross products give a good normal.\r\n   * @param ls linestring with point coordinates\r\n   * @param reverse if true, wrap the triangle creation in toggleReversedFacetFlag.\r\n   */\r\n  public addTrianglesInUncheckedConvexPolygon(ls: LineString3d, toggle: boolean): void {\r\n    const n = ls.numPoints();\r\n    if (n > 2) {\r\n      if (toggle)\r\n        this.toggleReversedFacetFlag();\r\n      let normal;\r\n      let normalIndex;\r\n      if (this._options.needNormals) {\r\n        normal = ls.quickUnitNormal(PolyfaceBuilder._workVectorFindOrAdd)!;\r\n        if (toggle)\r\n          normal.scaleInPlace(-1.0);\r\n        normalIndex = this._polyface.addNormal(normal);\r\n      }\r\n      const needParams = this._options.needParams;\r\n\r\n      const packedUV = needParams ? ls.packedUVParams : undefined;\r\n      let paramIndex0 = -1;\r\n      let paramIndex1 = -1;\r\n      let paramIndex2 = -1;\r\n      if (packedUV) {\r\n        paramIndex0 = this.findOrAddParamInGrowableXYArray(packedUV, 0)!;\r\n        paramIndex1 = this.findOrAddParamInGrowableXYArray(packedUV, 1)!;\r\n      }\r\n      const pointIndex0 = this.findOrAddPointInLineString(ls, 0)!;\r\n      let pointIndex1 = this.findOrAddPointInLineString(ls, 1)!;\r\n      let pointIndex2 = 0;\r\n      let numEdge = n;\r\n      if (ls.isPhysicallyClosed)\r\n        numEdge--;\r\n      for (let i = 2; i < numEdge; i++ , pointIndex1 = pointIndex2, paramIndex1 = paramIndex2) {\r\n        pointIndex2 = this.findOrAddPointInLineString(ls, i)!;\r\n        this.addIndexedTrianglePointIndexes(pointIndex0, pointIndex1, pointIndex2, false);\r\n        if (normalIndex !== undefined)\r\n          this.addIndexedTriangleNormalIndexes(normalIndex, normalIndex, normalIndex);\r\n        if (packedUV) {\r\n          paramIndex2 = this.findOrAddParamInGrowableXYArray(packedUV, i)!;\r\n          this.addIndexedTriangleParamIndexes(paramIndex0, paramIndex1, paramIndex2);\r\n        }\r\n        this._polyface.terminateFacet();\r\n      }\r\n      if (toggle)\r\n        this.toggleReversedFacetFlag();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.\r\n   */\r\n  public findOrAddPoint(xyz: Point3d): number {\r\n    return this._polyface.addPoint(xyz);\r\n  }\r\n\r\n  /**\r\n   * Announce point coordinates.  The implementation is free to either create a new param or (if known) return index of a prior param with the same coordinates.\r\n   */\r\n  public findOrAddParamXY(x: number, y: number): number {\r\n    return this._polyface.addParamUV(x, y);\r\n  }\r\n  private static _workPointFindOrAddA = Point3d.create();\r\n  private static _workVectorFindOrAdd = Vector3d.create();\r\n  private static _workUVFindOrAdd = Point2d.create();\r\n  /**\r\n   * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the point in the linestring.\r\n   */\r\n  public findOrAddPointInLineString(ls: LineString3d, index: number, transform?: Transform, priorIndex?: number): number | undefined {\r\n    const q = ls.pointAt(index, PolyfaceBuilder._workPointFindOrAddA);\r\n    if (q) {\r\n      if (transform)\r\n        transform.multiplyPoint3d(q, q);\r\n      return this._polyface.addPoint(q, priorIndex);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the point in the linestring.\r\n   */\r\n  public findOrAddPointInGrowableXYZArray(xyz: GrowableXYZArray, index: number, transform?: Transform, priorIndex?: number): number | undefined {\r\n    const q = xyz.getPoint3dAtCheckedPointIndex(index, PolyfaceBuilder._workPointFindOrAddA);\r\n    if (q) {\r\n      if (transform)\r\n        transform.multiplyPoint3d(q, q);\r\n      return this._polyface.addPoint(q, priorIndex);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the point in the linestring.\r\n   */\r\n  public findOrAddNormalInGrowableXYZArray(xyz: GrowableXYZArray, index: number, transform?: Transform, priorIndex?: number): number | undefined {\r\n    const q = xyz.getVector3dAtCheckedVectorIndex(index, PolyfaceBuilder._workVectorFindOrAdd);\r\n    if (q) {\r\n      if (transform)\r\n        transform.multiplyVector(q, q);\r\n      return this._polyface.addNormal(q, priorIndex);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Announce param coordinates.  The implementation is free to either create a new param or (if known) return index of a prior point with the same coordinates.\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the param in the linestring.\r\n   */\r\n  public findOrAddParamInGrowableXYArray(data: GrowableXYArray, index: number): number | undefined {\r\n    if (!data)\r\n      return undefined;\r\n    const q = data.getPoint2dAtUncheckedPointIndex(index, PolyfaceBuilder._workUVFindOrAdd);\r\n    if (q) {\r\n      return this._polyface.addParam(q);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Announce param coordinates, taking u from ls.fractions and v from parameter.  The implementation is free to either create a new param or (if known) return index of a prior point with the same coordinates.\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the point in the linestring.\r\n   */\r\n  public findOrAddParamInLineString(ls: LineString3d, index: number, v: number, priorIndexA?: number, priorIndexB?: number): number | undefined {\r\n    const u = (ls.fractions && index < ls.fractions.length) ? ls.fractions.atUncheckedIndex(index) : index / ls.points.length;\r\n    return this._polyface.addParamUV(u, v, priorIndexA, priorIndexB);\r\n  }\r\n\r\n  /**\r\n   * Announce normal coordinates found at index in the surfaceNormal array stored on the linestring\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the point in the linestring.\r\n   * @param priorIndex possible prior normal index to reuse\r\n   */\r\n  public findOrAddNormalInLineString(ls: LineString3d, index: number, transform?: Transform, priorIndexA?: number, priorIndexB?: number): number | undefined {\r\n    const linestringNormals = ls.packedSurfaceNormals;\r\n    if (linestringNormals) {\r\n      const q = linestringNormals.getVector3dAtCheckedVectorIndex(index, PolyfaceBuilder._workVectorFindOrAdd);\r\n      if (q) {\r\n        if (transform)\r\n          transform.multiplyVector(q, q);\r\n        return this._polyface.addNormal(q, priorIndexA, priorIndexB);\r\n      }\r\n    }\r\n    return undefined;\r\n\r\n  }\r\n  // cspell:word Normaln\r\n  /**\r\n   * This is a misspelling of findOrAddNormalInLineString\r\n   * @deprecated\r\n   */\r\n  public findOrAddNormalnLineString(ls: LineString3d, index: number, transform?: Transform, priorIndexA?: number, priorIndexB?: number): number | undefined {\r\n    return this.findOrAddNormalInLineString(ls, index, transform, priorIndexA, priorIndexB);\r\n  }\r\n\r\n  /**\r\n   * Announce point coordinates.  The implementation is free to either create a new point or (if known) return index of a prior point with the same coordinates.\r\n   */\r\n  public findOrAddPointXYZ(x: number, y: number, z: number): number {\r\n    return this._polyface.addPointXYZ(x, y, z);\r\n  }\r\n\r\n  /** Returns a transform who can be applied to points on a triangular facet in order to obtain UV parameters. */\r\n  private getUVTransformForTriangleFacet(pointA: Point3d, pointB: Point3d, pointC: Point3d): Transform | undefined {\r\n    const vectorAB = pointA.vectorTo(pointB);\r\n    const vectorAC = pointA.vectorTo(pointC);\r\n    const unitAxes = Matrix3d.createRigidFromColumns(vectorAB, vectorAC, AxisOrder.XYZ);\r\n    const localToWorld = Transform.createOriginAndMatrix(pointA, unitAxes);\r\n    return localToWorld.inverse();\r\n  }\r\n\r\n  /** Returns the normal to a triangular facet. */\r\n  private getNormalForTriangularFacet(pointA: Point3d, pointB: Point3d, pointC: Point3d): Vector3d {\r\n    const vectorAB = pointA.vectorTo(pointB);\r\n    const vectorAC = pointA.vectorTo(pointC);\r\n    let normal = vectorAB.crossProduct(vectorAC).normalize();\r\n    normal = normal ? normal : Vector3d.create();\r\n    return normal;\r\n  }\r\n\r\n  // ###: Consider case where normals will be reversed and point through the other end of the facet\r\n  /**\r\n   * Add a quad to the polyface given its points in order around the edges.\r\n   * Optionally provide params and the plane normal, otherwise they will be calculated without reference data.\r\n   * Optionally mark this quad as the last piece of a face in this polyface.\r\n   */\r\n  public addQuadFacet(points: Point3d[] | GrowableXYZArray, params?: Point2d[], normals?: Vector3d[]) {\r\n    if (points instanceof GrowableXYZArray)\r\n      points = points.getPoint3dArray();\r\n    // If params and/or normals are needed, calculate them first\r\n    const needParams = this.options.needParams;\r\n    const needNormals = this.options.needNormals;\r\n    let param0: Point2d, param1: Point2d, param2: Point2d, param3: Point2d;\r\n    let normal0: Vector3d, normal1: Vector3d, normal2: Vector3d, normal3: Vector3d;\r\n    if (needParams) {\r\n      if (params !== undefined && params.length > 3) {\r\n        param0 = params[0];\r\n        param1 = params[1];\r\n        param2 = params[2];\r\n        param3 = params[3];\r\n      } else {\r\n        const paramTransform = this.getUVTransformForTriangleFacet(points[0], points[1], points[2]);\r\n        if (paramTransform === undefined) {\r\n          param0 = param1 = param2 = param3 = Point2d.createZero();\r\n        } else {\r\n          param0 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[0]));\r\n          param1 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[1]));\r\n          param2 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[2]));\r\n          param3 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[3]));\r\n        }\r\n      }\r\n    }\r\n    if (needNormals) {\r\n      if (normals !== undefined && normals.length > 3) {\r\n        normal0 = normals[0];\r\n        normal1 = normals[1];\r\n        normal2 = normals[2];\r\n        normal3 = normals[3];\r\n      } else {\r\n        normal0 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\r\n        normal1 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\r\n        normal2 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\r\n        normal3 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\r\n      }\r\n    }\r\n\r\n    if (this._options.shouldTriangulate) {\r\n      // Add as two triangles, with a diagonal along the shortest distance\r\n      const vectorAC = points[0].vectorTo(points[2]);\r\n      const vectorBD = points[1].vectorTo(points[3]);\r\n\r\n      // Note: We pass along any values for normals or params that we calculated\r\n      if (vectorAC.magnitude() >= vectorBD.magnitude()) {\r\n        this.addTriangleFacet([points[0], points[1], points[2]], needParams ? [param0!, param1!, param2!] : undefined, needNormals ? [normal0!, normal1!, normal2!] : undefined);\r\n        this.addTriangleFacet([points[0], points[2], points[3]], needParams ? [param0!, param2!, param3!] : undefined, needNormals ? [normal0!, normal2!, normal3!] : undefined);\r\n      } else {\r\n        this.addTriangleFacet([points[0], points[1], points[3]], needParams ? [param0!, param1!, param3!] : undefined, needNormals ? [normal0!, normal1!, normal3!] : undefined);\r\n        this.addTriangleFacet([points[1], points[2], points[3]], needParams ? [param1!, param2!, param3!] : undefined, needNormals ? [normal1!, normal2!, normal3!] : undefined);\r\n      }\r\n      return;\r\n    }\r\n\r\n    let idx0, idx1, idx2, idx3;\r\n\r\n    // Add params if needed\r\n    if (needParams) {\r\n      idx0 = this._polyface.addParam(param0!);\r\n      idx1 = this._polyface.addParam(param1!);\r\n      idx2 = this._polyface.addParam(param2!);\r\n      idx3 = this._polyface.addParam(param3!);\r\n      this.addIndexedQuadParamIndexes(idx0, idx1, idx3, idx2);\r\n    }\r\n\r\n    // Add normals if needed\r\n    if (needNormals) {\r\n      idx0 = this._polyface.addNormal(normal0!);\r\n      idx1 = this._polyface.addNormal(normal1!);\r\n      idx2 = this._polyface.addNormal(normal2!);\r\n      idx3 = this._polyface.addNormal(normal3!);\r\n      this.addIndexedQuadNormalIndexes(idx0, idx1, idx3, idx2);\r\n    }\r\n\r\n    // Add point and point indexes last (terminates the facet)\r\n    idx0 = this.findOrAddPoint(points[0]);\r\n    idx1 = this.findOrAddPoint(points[1]);\r\n    idx2 = this.findOrAddPoint(points[2]);\r\n    idx3 = this.findOrAddPoint(points[3]);\r\n    this.addIndexedQuadPointIndexes(idx0, idx1, idx3, idx2);\r\n  }\r\n\r\n  /** Announce a single quad facet's point indexes.\r\n   *\r\n   * * The actual quad may be reversed or triangulated based on builder setup.\r\n   * *  indexA0 and indexA1 are in the forward order at the \"A\" end of the quad\r\n   * *  indexB0 and indexB1 are in the forward order at the \"B\" end of the quad.\r\n   */\r\n  private addIndexedQuadPointIndexes(indexA0: number, indexA1: number, indexB0: number, indexB1: number, terminate: boolean = true) {\r\n    if (this._reversed) {\r\n      this._polyface.addPointIndex(indexA0);\r\n      this._polyface.addPointIndex(indexB0);\r\n      this._polyface.addPointIndex(indexB1);\r\n      this._polyface.addPointIndex(indexA1);\r\n    } else {\r\n      this._polyface.addPointIndex(indexA0);\r\n      this._polyface.addPointIndex(indexA1);\r\n      this._polyface.addPointIndex(indexB1);\r\n      this._polyface.addPointIndex(indexB0);\r\n    }\r\n    if (terminate)\r\n      this._polyface.terminateFacet();\r\n  }\r\n\r\n  /** For a single quad facet, add the indexes of the corresponding param points. */\r\n  private addIndexedQuadParamIndexes(indexA0: number, indexA1: number, indexB0: number, indexB1: number) {\r\n    if (this._reversed) {\r\n      this._polyface.addParamIndex(indexA0);\r\n      this._polyface.addParamIndex(indexB0);\r\n      this._polyface.addParamIndex(indexB1);\r\n      this._polyface.addParamIndex(indexA1);\r\n    } else {\r\n      this._polyface.addParamIndex(indexA0);\r\n      this._polyface.addParamIndex(indexA1);\r\n      this._polyface.addParamIndex(indexB1);\r\n      this._polyface.addParamIndex(indexB0);\r\n    }\r\n  }\r\n\r\n  /** For a single quad facet, add the indexes of the corresponding normal vectors. */\r\n  private addIndexedQuadNormalIndexes(indexA0: number, indexA1: number, indexB0: number, indexB1: number) {\r\n    if (this._reversed) {\r\n      this._polyface.addNormalIndex(indexA0);\r\n      this._polyface.addNormalIndex(indexB0);\r\n      this._polyface.addNormalIndex(indexB1);\r\n      this._polyface.addNormalIndex(indexA1);\r\n    } else {\r\n      this._polyface.addNormalIndex(indexA0);\r\n      this._polyface.addNormalIndex(indexA1);\r\n      this._polyface.addNormalIndex(indexB1);\r\n      this._polyface.addNormalIndex(indexB0);\r\n    }\r\n  }\r\n\r\n  // ### TODO: Consider case where normals will be reversed and point through the other end of the facet\r\n  /**\r\n   * Add a triangle to the polyface given its points in order around the edges.\r\n   * * Optionally provide params and triangle normals, otherwise they will be calculated without reference data.\r\n   */\r\n  public addTriangleFacet(points: Point3d[] | GrowableXYZArray, params?: Point2d[], normals?: Vector3d[]) {\r\n    if (points.length < 3)\r\n      return;\r\n    let idx0: number;\r\n    let idx1: number;\r\n    let idx2: number;\r\n    let point0, point1, point2;\r\n    if (points instanceof GrowableXYZArray) {\r\n      point0 = points.getPoint3dAtCheckedPointIndex(0)!;\r\n      point1 = points.getPoint3dAtCheckedPointIndex(1)!;\r\n      point2 = points.getPoint3dAtCheckedPointIndex(2)!;\r\n    } else {\r\n      point0 = points[0];\r\n      point1 = points[1];\r\n      point2 = points[2];\r\n    }\r\n\r\n    // Add params if needed\r\n    if (this._options.needParams) {\r\n      if (params && params.length >= 3) { // Params were given\r\n        idx0 = this._polyface.addParam(params[0]);\r\n        idx1 = this._polyface.addParam(params[1]);\r\n        idx2 = this._polyface.addParam(params[2]);\r\n      } else {  // Compute params\r\n        const paramTransform = this.getUVTransformForTriangleFacet(point0, point1, point2);\r\n        idx0 = this._polyface.addParam(Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point0) : undefined));\r\n        idx1 = this._polyface.addParam(Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point1) : undefined));\r\n        idx2 = this._polyface.addParam(Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point1) : undefined));\r\n      }\r\n      this.addIndexedTriangleParamIndexes(idx0, idx1, idx2);\r\n    }\r\n\r\n    // Add normals if needed\r\n    if (this._options.needNormals) {\r\n      if (normals !== undefined && normals.length > 2) { // Normals were given\r\n        idx0 = this._polyface.addNormal(normals[0]);\r\n        idx1 = this._polyface.addNormal(normals[1]);\r\n        idx2 = this._polyface.addNormal(normals[2]);\r\n      } else {  // Compute normals\r\n        const normal = this.getNormalForTriangularFacet(point0, point1, point2);\r\n        idx0 = this._polyface.addNormal(normal);\r\n        idx1 = this._polyface.addNormal(normal);\r\n        idx2 = this._polyface.addNormal(normal);\r\n      }\r\n      this.addIndexedTriangleNormalIndexes(idx0, idx1, idx2);\r\n    }\r\n\r\n    // Add point and point indexes last (terminates the facet)\r\n    idx0 = this.findOrAddPoint(point0);\r\n    idx1 = this.findOrAddPoint(point1);\r\n    idx2 = this.findOrAddPoint(point2);\r\n    this.addIndexedTrianglePointIndexes(idx0, idx1, idx2);\r\n  }\r\n\r\n  /** Announce a single triangle facet's point indexes.\r\n   *\r\n   * * The actual quad may be reversed or triangulated based on builder setup.\r\n   * *  indexA0 and indexA1 are in the forward order at the \"A\" end of the quad\r\n   * *  indexB0 and indexB1 are in the forward order at the \"B\" end of hte quad.\r\n   */\r\n  private addIndexedTrianglePointIndexes(indexA: number, indexB: number, indexC: number, terminateFacet: boolean = true) {\r\n    if (!this._reversed) {\r\n      this._polyface.addPointIndex(indexA);\r\n      this._polyface.addPointIndex(indexB);\r\n      this._polyface.addPointIndex(indexC);\r\n    } else {\r\n      this._polyface.addPointIndex(indexA);\r\n      this._polyface.addPointIndex(indexC);\r\n      this._polyface.addPointIndex(indexB);\r\n    }\r\n    if (terminateFacet)\r\n      this._polyface.terminateFacet();\r\n  }\r\n\r\n  /** For a single triangle facet, add the indexes of the corresponding params. */\r\n  private addIndexedTriangleParamIndexes(indexA: number, indexB: number, indexC: number) {\r\n    if (!this._reversed) {\r\n      this._polyface.addParamIndex(indexA);\r\n      this._polyface.addParamIndex(indexB);\r\n      this._polyface.addParamIndex(indexC);\r\n    } else {\r\n      this._polyface.addParamIndex(indexA);\r\n      this._polyface.addParamIndex(indexC);\r\n      this._polyface.addParamIndex(indexB);\r\n    }\r\n  }\r\n\r\n  /** For a single triangle facet, add the indexes of the corresponding params. */\r\n  private addIndexedTriangleNormalIndexes(indexA: number, indexB: number, indexC: number) {\r\n    if (!this._reversed) {\r\n      this._polyface.addNormalIndex(indexA);\r\n      this._polyface.addNormalIndex(indexB);\r\n      this._polyface.addNormalIndex(indexC);\r\n    } else {\r\n      this._polyface.addNormalIndex(indexA);\r\n      this._polyface.addNormalIndex(indexC);\r\n      this._polyface.addNormalIndex(indexB);\r\n    }\r\n  }\r\n  /** Find or add xyzIndex and normalIndex for coordinates in the sector. */\r\n  private setSectorIndices(sector: FacetSector) {\r\n    sector.xyzIndex = this.findOrAddPoint(sector.xyz);\r\n    if (sector.normal)\r\n      sector.normalIndex = this._polyface.addNormal(sector.normal);\r\n    if (sector.uv)\r\n      sector.uvIndex = this._polyface.addParam(sector.uv);\r\n  }\r\n  private addSectorQuadA01B01(sectorA0: FacetSector, sectorA1: FacetSector, sectorB0: FacetSector, sectorB1: FacetSector) {\r\n    if (sectorA0.xyz.isAlmostEqual(sectorA1.xyz) && sectorB0.xyz.isAlmostEqual(sectorB1.xyz)) {\r\n      // ignore null quad !!\r\n    } else {\r\n      if (this._options.needNormals)\r\n        this.addIndexedQuadNormalIndexes(sectorA0.normalIndex, sectorA1.normalIndex, sectorB0.normalIndex, sectorB1.normalIndex);\r\n      if (this._options.needParams)\r\n        this.addIndexedQuadParamIndexes(sectorA0.uvIndex, sectorA1.uvIndex, sectorB0.uvIndex, sectorB1.uvIndex);\r\n      this.addIndexedQuadPointIndexes(sectorA0.xyzIndex, sectorA1.xyzIndex, sectorB0.xyzIndex, sectorB1.xyzIndex);\r\n      this._polyface.terminateFacet();\r\n\r\n    }\r\n\r\n  }\r\n  /** Add facets between lineStrings with matched point counts.\r\n   * * surface normals are computed from (a) curve tangents in the linestrings and (b)rule line between linestrings.\r\n   * * Facets are announced to addIndexedQuad.\r\n   * * addIndexedQuad is free to apply reversal or triangulation options.\r\n   */\r\n  public addBetweenLineStringsWithRuleEdgeNormals(lineStringA: LineString3d, vA: number, lineStringB: LineString3d, vB: number, addClosure: boolean = false) {\r\n    const pointA = lineStringA.packedPoints;\r\n    const pointB = lineStringB.packedPoints;\r\n    const derivativeA = lineStringA.packedDerivatives;\r\n    const derivativeB = lineStringB.packedDerivatives;\r\n    const fractionA = lineStringA.fractions;\r\n    const fractionB = lineStringB.fractions;\r\n    const needNormals = this._options.needNormals;\r\n    const needParams = this._options.needParams;\r\n    const sectorA0 = new FacetSector(needNormals, needParams, needNormals);\r\n    const sectorA1 = new FacetSector(needNormals, needParams, needNormals);\r\n    const sectorB0 = new FacetSector(needNormals, needParams, needNormals);\r\n    const sectorB1 = new FacetSector(needNormals, needParams, needNormals);\r\n    const sectorA00 = new FacetSector(needNormals, needParams, needNormals);\r\n    const sectorB00 = new FacetSector(needNormals, needParams, needNormals);\r\n\r\n    const numPoints = pointA.length;\r\n    if (numPoints < 2 || numPoints !== pointB.length) return;\r\n    sectorA0.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0, pointA, derivativeA, fractionA, vA);\r\n    sectorB0.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0, pointB, derivativeB, fractionB, vB);\r\n    if (needNormals)\r\n      FacetSector.computeNormalsAlongRuleLine(sectorA0, sectorB0);\r\n    this.setSectorIndices(sectorA0);\r\n    this.setSectorIndices(sectorB0);\r\n\r\n    sectorA00.copyContentsFrom(sectorA0);\r\n    sectorB00.copyContentsFrom(sectorB0);\r\n    for (let i = 1; i < numPoints; i++) {\r\n      sectorA1.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i, pointA, derivativeA, fractionA, vA);\r\n      sectorB1.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i, pointB, derivativeA, fractionB, vB);\r\n      FacetSector.computeNormalsAlongRuleLine(sectorA1, sectorB1);\r\n      this.setSectorIndices(sectorA1);\r\n      this.setSectorIndices(sectorB1);\r\n      // create the facet ...\r\n      this.addSectorQuadA01B01(sectorA0, sectorA1, sectorB0, sectorB1);\r\n      sectorA0.copyContentsFrom(sectorA1);\r\n      sectorB0.copyContentsFrom(sectorB1);\r\n    }\r\n    if (addClosure)\r\n      this.addSectorQuadA01B01(sectorA0, sectorA00, sectorB0, sectorB00);\r\n  }\r\n\r\n  /** Add facets between lineStrings with matched point counts.\r\n   * * point indices pre-stored\r\n   * * normal indices pre-stored\r\n   * * uv indices pre-stored\r\n   */\r\n  public addBetweenLineStringsWithStoredIndices(lineStringA: LineString3d, lineStringB: LineString3d) {\r\n    const pointA = lineStringA.pointIndices!;\r\n    const pointB = lineStringB.pointIndices!;\r\n    let normalA: GrowableFloat64Array | undefined = lineStringA.normalIndices;\r\n    let normalB: GrowableFloat64Array | undefined = lineStringB.normalIndices;\r\n    if (!this._options.needNormals) {\r\n      normalA = undefined;\r\n      normalB = undefined;\r\n    }\r\n    let paramA: GrowableFloat64Array | undefined = lineStringA.paramIndices;\r\n    let paramB: GrowableFloat64Array | undefined = lineStringB.paramIndices;\r\n    if (!this._options.needParams) {\r\n      paramA = undefined;\r\n      paramB = undefined;\r\n    }\r\n\r\n    const numPoints = pointA.length;\r\n    for (let i = 1; i < numPoints; i++) {\r\n      if (pointA.atUncheckedIndex(i - 1) !== pointA.atUncheckedIndex(i) || pointB.atUncheckedIndex(i - 1) !== pointB.atUncheckedIndex(i)) {\r\n        this.addIndexedQuadPointIndexes(pointA.atUncheckedIndex(i - 1), pointA.atUncheckedIndex(i), pointB.atUncheckedIndex(i - 1), pointB.atUncheckedIndex(i));\r\n        if (normalA && normalB)\r\n          this.addIndexedQuadNormalIndexes(normalA.atUncheckedIndex(i - 1), normalA.atUncheckedIndex(i), normalB.atUncheckedIndex(i - 1), normalB.atUncheckedIndex(i));\r\n        if (paramA && paramB)\r\n          this.addIndexedQuadParamIndexes(paramA.atUncheckedIndex(i - 1), paramA.atUncheckedIndex(i), paramB.atUncheckedIndex(i - 1), paramB.atUncheckedIndex(i));\r\n        this._polyface.terminateFacet();\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Add facets between lineStrings with matched point counts.\r\n   *\r\n   * * Facets are announced to addIndexedQuad.\r\n   * * addIndexedQuad is free to apply reversal or triangulation options.\r\n   */\r\n  public addBetweenTransformedLineStrings(curves: AnyCurve, transformA: Transform, transformB: Transform, addClosure: boolean = false) {\r\n    if (curves instanceof LineString3d) {\r\n      const pointA = curves.points;\r\n      const numPoints = pointA.length;\r\n      let indexA0 = this.findOrAddPointInLineString(curves, 0, transformA)!;\r\n      let indexB0 = this.findOrAddPointInLineString(curves, 0, transformB)!;\r\n      const indexA00 = indexA0;\r\n      const indexB00 = indexB0;\r\n      let indexA1 = 0;\r\n      let indexB1 = 0;\r\n      for (let i = 1; i < numPoints; i++) {\r\n        indexA1 = this.findOrAddPointInLineString(curves, i, transformA)!;\r\n        indexB1 = this.findOrAddPointInLineString(curves, i, transformB)!;\r\n        this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);\r\n        indexA0 = indexA1;\r\n        indexB0 = indexB1;\r\n      }\r\n      if (addClosure)\r\n        this.addIndexedQuadPointIndexes(indexA0, indexA00, indexB0, indexB00);\r\n    } else {\r\n      const children = curves.children;\r\n      // just send the children individually -- final s will fix things??\r\n      if (children)\r\n        for (const c of children) {\r\n          this.addBetweenTransformedLineStrings(c as AnyCurve, transformA, transformB);\r\n        }\r\n    }\r\n  }\r\n\r\n  private addBetweenStrokeSetPair(dataA: AnyCurve, vA: number, dataB: AnyCurve, vB: number) {\r\n    if (dataA instanceof LineString3d && dataB instanceof LineString3d) {\r\n      this.addBetweenLineStringsWithRuleEdgeNormals(dataA, vA, dataB, vB, false);\r\n    } else if (dataA instanceof ParityRegion && dataB instanceof ParityRegion) {\r\n      if (dataA.children.length === dataB.children.length) {\r\n        for (let i = 0; i < dataA.children.length; i++) {\r\n          this.addBetweenStrokeSetPair(dataA.children[i], vA, dataB.children[i], vB);\r\n        }\r\n      }\r\n    } else if (dataA instanceof CurveChain && dataB instanceof CurveChain) {\r\n      const chainA = dataA.children;\r\n      const chainB = dataB.children;\r\n      if (chainA.length === chainB.length) {\r\n        for (let i = 0; i < chainA.length; i++) {\r\n          const cpA = chainA[i];\r\n          const cpB = chainB[i];\r\n          if (cpA instanceof LineString3d && cpB instanceof LineString3d) {\r\n            this.addBetweenLineStringsWithRuleEdgeNormals(cpA, vA, cpB, vB);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Add facets from a Cone\r\n   */\r\n  public addCone(cone: Cone) {\r\n    // ensure identical stroke counts at each end . . .\r\n    let strokeCount = 16;\r\n    if (this._options)\r\n      strokeCount = this._options.applyTolerancesToArc(cone.getMaxRadius());\r\n    let axisStrokeCount = 1;\r\n    const lineStringA = cone.strokeConstantVSection(0.0, strokeCount, this._options);\r\n    const lineStringB = cone.strokeConstantVSection(1.0, strokeCount, this._options);\r\n\r\n    if (this._options) {\r\n      const vDistanceRange = GrowableXYZArray.distanceRangeBetweenCorrespondingPoints(lineStringA.packedPoints, lineStringB.packedPoints);\r\n      axisStrokeCount = this._options.applyMaxEdgeLength(1, vDistanceRange.low);\r\n    }\r\n    const sizes = cone.maxIsoParametricDistance();\r\n    this.addUVGridBody(cone, strokeCount, axisStrokeCount, Segment1d.create(0, sizes.x), Segment1d.create(0, sizes.y));\r\n    this.endFace();\r\n\r\n    if (cone.capped) {\r\n      if (!Geometry.isSmallMetricDistance(cone.getRadiusA())) {\r\n        this.addTrianglesInUncheckedConvexPolygon(lineStringA, true);  // lower triangles flip\r\n        this.endFace();\r\n      }\r\n      if (!Geometry.isSmallMetricDistance(cone.getRadiusB())) {\r\n        this.addTrianglesInUncheckedConvexPolygon(lineStringB, false); // upper triangles to not flip.\r\n        this.endFace();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add facets for a TorusPipe.\r\n   */\r\n  public addTorusPipe(surface: TorusPipe, phiStrokeCount?: number, thetaStrokeCount?: number) {\r\n    const thetaFraction = surface.getThetaFraction();\r\n    const numU = Geometry.clamp(Geometry.resolveNumber(phiStrokeCount, 8), 4, 64);\r\n    const numV = Geometry.clamp(\r\n      Geometry.resolveNumber(thetaStrokeCount, Math.ceil(16 * thetaFraction)),\r\n      2, 64);\r\n\r\n    this.toggleReversedFacetFlag();\r\n    const sizes = surface.maxIsoParametricDistance();\r\n    this.addUVGridBody(surface, numU, numV, Segment1d.create(0, sizes.x), Segment1d.create(0, sizes.y));\r\n    this.toggleReversedFacetFlag();\r\n\r\n    if (surface.capped && thetaFraction < 1.0) {\r\n      const centerFrame = surface.getConstructiveFrame()!;\r\n      const minorRadius = surface.getMinorRadius();\r\n      const majorRadius = surface.getMajorRadius();\r\n      const a = 2 * minorRadius;\r\n      const r0 = majorRadius - minorRadius;\r\n      const r1 = majorRadius + minorRadius;\r\n      const z0 = -minorRadius;\r\n      const cap0ToLocal = Transform.createRowValues(\r\n        a, 0, 0, r0,\r\n        0, 0, -1, 0,\r\n        0, a, 0, z0);\r\n      const cap0ToWorld = centerFrame.multiplyTransformTransform(cap0ToLocal);\r\n      const worldToCap0 = cap0ToWorld.inverse();\r\n      if (worldToCap0) {\r\n        const ls0 = UVSurfaceOps.createLinestringOnUVLine(surface, 0, 0, 1, 0, numU, false, true);\r\n        ls0.computeUVFromXYZTransform(worldToCap0);\r\n        this.addTrianglesInUncheckedConvexPolygon(ls0, false);\r\n      }\r\n      const thetaRadians = surface.getSweepAngle().radians;\r\n      const cc = Math.cos(thetaRadians);\r\n      const ss = Math.sin(thetaRadians);\r\n\r\n      const cap1ToLocal = Transform.createRowValues(\r\n        -cc * a, 0, -ss, r1 * cc,\r\n        -ss * a, 0, cc, r1 * ss,\r\n        0, a, 0, z0);\r\n\r\n      const cap1ToWorld = centerFrame.multiplyTransformTransform(cap1ToLocal);\r\n      const worldToCap1 = cap1ToWorld.inverse();\r\n      if (worldToCap1) {\r\n        const ls1 = UVSurfaceOps.createLinestringOnUVLine(surface, 1, 1, 0, 1, numU, false, true);\r\n        ls1.computeUVFromXYZTransform(worldToCap1);\r\n        this.addTrianglesInUncheckedConvexPolygon(ls1, false);\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add point data (no params, normals) for linestrings.\r\n   * * This recurses through curve chains (loops and paths)\r\n   * * linestrings are swept\r\n   * * All other curve types are ignored.\r\n   * @param vector sweep vector\r\n   * @param contour contour which contains only linestrings\r\n   */\r\n  public addLinearSweepLineStringsXYZOnly(contour: AnyCurve, vector: Vector3d) {\r\n    if (contour instanceof LineString3d) {\r\n      const ls = contour as LineString3d;\r\n      let pointA = Point3d.create();\r\n      let pointB = Point3d.create();\r\n      let indexA0 = 0;\r\n      let indexA1 = 0;\r\n      let indexB0 = 0;\r\n      let indexB1 = 0;\r\n      const n = ls.numPoints();\r\n      for (let i = 0; i < n; i++) {\r\n        pointA = ls.pointAt(i, pointA)!;\r\n        pointB = pointA.plus(vector, pointB);\r\n        indexA1 = this.findOrAddPoint(pointA);\r\n        indexB1 = this.findOrAddPoint(pointB);\r\n        if (i > 0) {\r\n          this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);\r\n        }\r\n        indexA0 = indexA1;\r\n        indexB0 = indexB1;\r\n      }\r\n    } else if (contour instanceof CurveChain) {\r\n      for (const ls of contour.children) {\r\n        this.addLinearSweepLineStringsXYZOnly(ls, vector);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Construct facets for a rotational sweep.\r\n   */\r\n  public addRotationalSweep(surface: RotationalSweep) {\r\n    const contour = surface.getCurves();\r\n    const section0 = StrokeCountSection.createForParityRegionOrChain(contour, this._options);\r\n    const baseStrokes = section0.getStrokes();\r\n\r\n    const axis = surface.cloneAxisRay();\r\n    const perpendicularVector = CylindricalRangeQuery.computeMaxVectorFromRay(axis, baseStrokes);\r\n    const swingVector = axis.direction.crossProduct(perpendicularVector);\r\n    if (this._options.needNormals)\r\n      CylindricalRangeQuery.buildRotationalNormalsInLineStrings(baseStrokes, axis, swingVector);\r\n    const maxDistance = perpendicularVector.magnitude();\r\n    const maxPath = Math.abs(maxDistance * surface.getSweep().radians);\r\n    let numStep = StrokeOptions.applyAngleTol(this._options, 1, surface.getSweep().radians, undefined);\r\n    numStep = StrokeOptions.applyMaxEdgeLength(this._options, numStep, maxPath);\r\n    for (let i = 1; i <= numStep; i++) {\r\n      const transformA = surface.getFractionalRotationTransform((i - 1) / numStep);\r\n      const transformB = surface.getFractionalRotationTransform(i / numStep);\r\n      this.addBetweenRotatedStrokeSets(baseStrokes, transformA, i - 1, transformB, i);\r\n    }\r\n    if (surface.capped) {\r\n      const capContour = surface.getSweepContourRef();\r\n      capContour.purgeFacets();\r\n      capContour.emitFacets(this, true, undefined);\r\n      // final loop pass left transformA at end ..\r\n      capContour.emitFacets(this, false, surface.getFractionalRotationTransform(1.0));\r\n    }\r\n  }\r\n  /**\r\n   * Construct facets for any planar region\r\n   */\r\n  public addTriangulatedRegion(region: AnyRegion) {\r\n    const contour = SweepContour.createForLinearSweep(region);\r\n    if (contour)\r\n      contour.emitFacets(this, true, undefined);\r\n  }\r\n\r\n  /**\r\n   * * Recursively visit all children of data.\r\n   * * At each primitive, invoke the computeStrokeCountForOptions method, with options from the builder.\r\n   * @param data\r\n   */\r\n  public applyStrokeCountsToCurvePrimitives(data: AnyCurve | GeometryQuery) {\r\n    const options = this._options;\r\n    if (data instanceof CurvePrimitive) {\r\n      data.computeStrokeCountForOptions(options);\r\n    } else if (data instanceof CurveCollection) {\r\n      const children = data.children;\r\n      if (children)\r\n        for (const child of children) {\r\n          this.applyStrokeCountsToCurvePrimitives(child);\r\n        }\r\n    }\r\n  }\r\n\r\n  private addBetweenStrokeSetsWithRuledNormals(stroke0: AnyCurve, stroke1: AnyCurve, numVEdge: number) {\r\n    const strokeSets = [stroke0];\r\n    const fractions = [0.0];\r\n    for (let vIndex = 1; vIndex < numVEdge; vIndex++) {\r\n      const vFraction = vIndex / numVEdge;\r\n      const strokeA = ConstructCurveBetweenCurves.interpolateBetween(stroke0, vIndex / numVEdge, stroke1) as AnyCurve;\r\n      strokeSets.push(strokeA);\r\n      fractions.push(vFraction);\r\n    }\r\n    strokeSets.push(stroke1);\r\n    fractions.push(1.0);\r\n    for (let vIndex = 0; vIndex < numVEdge; vIndex++) {\r\n      this.addBetweenStrokeSetPair(strokeSets[vIndex], fractions[vIndex], strokeSets[vIndex + 1], fractions[vIndex + 1]);\r\n    }\r\n  }\r\n  private createIndicesInLineString(ls: LineString3d, vParam: number, transform?: Transform) {\r\n\r\n    const n = ls.numPoints();\r\n    {\r\n      const pointIndices = ls.ensureEmptyPointIndices();\r\n      const index0 = this.findOrAddPointInLineString(ls, 0, transform);\r\n      pointIndices.push(index0!);\r\n      if (n > 1) {\r\n        let indexA = index0;\r\n        let indexB;\r\n        for (let i = 1; i + 1 < n; i++) {\r\n          indexB = this.findOrAddPointInLineString(ls, i, transform, indexA);\r\n          pointIndices.push(indexB!);\r\n          indexA = indexB;\r\n        }\r\n        // assume last point can only repeat back to zero ...\r\n        indexB = this.findOrAddPointInLineString(ls, n - 1, transform, index0);\r\n        pointIndices.push(indexB!);\r\n      }\r\n    }\r\n    if (this._options.needNormals && ls.packedSurfaceNormals !== undefined) {\r\n      const normalIndices = ls.ensureEmptyNormalIndices();\r\n      const normalIndex0 = this.findOrAddNormalInLineString(ls, 0, transform);\r\n      normalIndices.push(normalIndex0!);\r\n      let normalIndexA = normalIndex0;\r\n      let normalIndexB;\r\n      if (n > 1) {\r\n        for (let i = 1; i + 1 < n; i++) {\r\n          normalIndexB = this.findOrAddNormalInLineString(ls, i, transform, normalIndexA);\r\n          normalIndices.push(normalIndexB!);\r\n          normalIndexA = normalIndexB;\r\n        }\r\n        // assume last point can only repeat back to zero ...\r\n        normalIndexB = this.findOrAddNormalInLineString(ls, n - 1, transform, normalIndex0, normalIndexA);\r\n        normalIndices.push(normalIndexB!);\r\n      }\r\n    }\r\n    if (this._options.needParams && ls.packedUVParams !== undefined) {\r\n      const uvIndices = ls.ensureEmptyUVIndices();\r\n      const uvIndex0 = this.findOrAddParamInLineString(ls, 0, vParam);\r\n      uvIndices.push(uvIndex0!);\r\n      let uvIndexA = uvIndex0;\r\n      let uvIndexB;\r\n      if (n > 1) {\r\n        for (let i = 1; i + 1 < n; i++) {\r\n          uvIndexB = this.findOrAddParamInLineString(ls, i, vParam, uvIndexA);\r\n          uvIndices.push(uvIndexB!);\r\n          uvIndexA = uvIndexB;\r\n        }\r\n        // assume last point can only repeat back to zero ...\r\n        uvIndexB = this.findOrAddParamInLineString(ls, n - 1, vParam, uvIndexA, uvIndex0);\r\n        uvIndices.push(uvIndexB!);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  private addBetweenRotatedStrokeSets(stroke0: AnyCurve, transformA: Transform, vA: number, transformB: Transform, vB: number) {\r\n    if (stroke0 instanceof LineString3d) {\r\n      const strokeA = stroke0.cloneTransformed(transformA) as LineString3d;\r\n      this.createIndicesInLineString(strokeA, vA);\r\n      const strokeB = stroke0.cloneTransformed(transformB) as LineString3d;\r\n      this.createIndicesInLineString(strokeB, vB);\r\n      this.addBetweenLineStringsWithStoredIndices(strokeA, strokeB);\r\n    } else if (stroke0 instanceof ParityRegion) {\r\n      for (let i = 0; i < stroke0.children.length; i++) {\r\n        this.addBetweenRotatedStrokeSets(stroke0.children[i], transformA, vA, transformB, vB);\r\n      }\r\n    } else if (stroke0 instanceof CurveChain) {\r\n      const chainA = stroke0.children;\r\n      for (let i = 0; i < chainA.length; i++) {\r\n        const cpA = chainA[i];\r\n        if (cpA instanceof LineString3d) {\r\n          this.addBetweenRotatedStrokeSets(cpA, transformA, vA, transformB, vB);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   *\r\n   * Add facets from\r\n   * * The swept contour\r\n   * * each cap.\r\n   */\r\n  public addLinearSweep(surface: LinearSweep) {\r\n    const contour = surface.getCurvesRef();\r\n    const section0 = StrokeCountSection.createForParityRegionOrChain(contour, this._options);\r\n    const stroke0 = section0.getStrokes();\r\n    const sweepVector = surface.cloneSweepVector();\r\n    const sweepTransform = Transform.createTranslation(sweepVector);\r\n    const stroke1 = stroke0.cloneTransformed(sweepTransform) as AnyCurve;\r\n    const numVEdge = this._options.applyMaxEdgeLength(1, sweepVector.magnitude());\r\n    this.addBetweenStrokeSetsWithRuledNormals(stroke0, stroke1, numVEdge);\r\n\r\n    if (surface.capped && contour.isAnyRegionType) {\r\n      const contourA = surface.getSweepContourRef();\r\n      contourA.purgeFacets();\r\n\r\n      contourA.emitFacets(this, true, undefined);\r\n      contourA.emitFacets(this, false, sweepTransform);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add facets from a ruled sweep.\r\n   */\r\n  public addRuledSweep(surface: RuledSweep): boolean {\r\n    const contours = surface.sweepContoursRef();\r\n    let stroke0: AnyCurve | undefined;\r\n    let stroke1: AnyCurve;\r\n    const sectionMaps = [];\r\n    for (let i = 0; i < contours.length; i++) {\r\n      sectionMaps.push(StrokeCountSection.createForParityRegionOrChain(contours[i].curves, this._options));\r\n    }\r\n    if (StrokeCountSection.enforceStrokeCountCompatibility(sectionMaps)) {\r\n      StrokeCountSection.enforceCompatibleDistanceSums(sectionMaps);\r\n      for (let i = 0; i < contours.length; i++) {\r\n        stroke1 = sectionMaps[i].getStrokes();\r\n        if (!stroke1)\r\n          stroke1 = contours[i].curves.cloneStroked();\r\n        if (i > 0 && stroke0 && stroke1) {\r\n          const distanceRange = Range1d.createNull();\r\n          if (StrokeCountSection.extendDistanceRangeBetweenStrokes(stroke0, stroke1, distanceRange)\r\n            && !distanceRange.isNull) {\r\n            const numVEdge = this._options.applyMaxEdgeLength(1, distanceRange.high);\r\n            this.addBetweenStrokeSetsWithRuledNormals(stroke0, stroke1, numVEdge);\r\n          }\r\n        }\r\n        stroke0 = stroke1;\r\n      }\r\n    }\r\n\r\n    if (surface.capped && contours[0].curves.isAnyRegionType) {\r\n      contours[0].purgeFacets();\r\n\r\n      contours[0].emitFacets(this, true, undefined);\r\n      contours[contours.length - 1].purgeFacets();\r\n      contours[contours.length - 1].emitFacets(this, false, undefined);\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Add facets from a Sphere\r\n   */\r\n  public addSphere(sphere: Sphere, strokeCount?: number) {\r\n    const numStrokeTheta = strokeCount ? strokeCount : this._options.defaultCircleStrokes;\r\n    const numStrokePhi = Geometry.clampToStartEnd(Math.abs(numStrokeTheta * sphere.latitudeSweepFraction), 1, Math.ceil(numStrokeTheta * 0.5));\r\n\r\n    const lineStringA = sphere.strokeConstantVSection(0.0, numStrokeTheta, this._options);\r\n    if (sphere.capped && !Geometry.isSmallMetricDistance(lineStringA.quickLength())) {\r\n      this.addTrianglesInUncheckedConvexPolygon(lineStringA, true);  // lower triangles flip\r\n      this.endFace();\r\n    }\r\n\r\n    const sizes = sphere.maxIsoParametricDistance();\r\n\r\n    this.addUVGridBody(sphere, numStrokeTheta, numStrokePhi, Segment1d.create(0, sizes.x), Segment1d.create(0, sizes.y));\r\n    this.endFace();\r\n\r\n    const lineStringB = sphere.strokeConstantVSection(1.0, numStrokeTheta, this._options);\r\n    if (sphere.capped && !Geometry.isSmallMetricDistance(lineStringB.quickLength())) {\r\n      this.addTrianglesInUncheckedConvexPolygon(lineStringB, false);  // upper triangles do not flip\r\n      this.endFace();\r\n    }\r\n  }\r\n  /**\r\n   * Add facets from a Box\r\n   */\r\n  public addBox(box: Box) {\r\n    const corners = box.getCorners();\r\n    const xLength = Geometry.maxXY(box.getBaseX(), box.getBaseX());\r\n    const yLength = Geometry.maxXY(box.getBaseY(), box.getTopY());\r\n    let zLength = 0.0;\r\n    for (let i = 0; i < 4; i++) {\r\n      zLength = Geometry.maxXY(zLength, corners[i].distance(corners[i + 4]));\r\n\r\n    }\r\n\r\n    const numX = this._options.applyMaxEdgeLength(1, xLength);\r\n    const numY = this._options.applyMaxEdgeLength(1, yLength);\r\n    const numZ = this._options.applyMaxEdgeLength(1, zLength);\r\n    // Wrap the 4 out-of-plane faces as a single parameters space with \"distance\" advancing in x then y then negative x then negative y ...\r\n    const uParamRange = Segment1d.create(0, xLength);\r\n    const vParamRange = Segment1d.create(0, zLength);\r\n    this.addUVGridBody(BilinearPatch.create(corners[0], corners[1], corners[4], corners[5]), numX, numZ, uParamRange, vParamRange);\r\n    uParamRange.shift(xLength);\r\n    this.addUVGridBody(BilinearPatch.create(corners[1], corners[3], corners[5], corners[7]), numY, numZ, uParamRange, vParamRange);\r\n    uParamRange.shift(yLength);\r\n    this.addUVGridBody(BilinearPatch.create(corners[3], corners[2], corners[7], corners[6]), numX, numZ, uParamRange, vParamRange);\r\n    uParamRange.shift(xLength);\r\n    this.addUVGridBody(BilinearPatch.create(corners[2], corners[0], corners[6], corners[4]), numY, numZ, uParamRange, vParamRange);\r\n    // finally end that wraparound face !!\r\n    this.endFace();\r\n    if (box.capped) {\r\n      uParamRange.set(0.0, xLength);\r\n      vParamRange.set(0.0, yLength);\r\n      this.addUVGridBody(BilinearPatch.create(corners[4], corners[5], corners[6], corners[7]), numX, numY, uParamRange, vParamRange);\r\n      this.endFace();\r\n\r\n      uParamRange.set(0.0, xLength);\r\n      vParamRange.set(0.0, yLength);\r\n      this.addUVGridBody(BilinearPatch.create(corners[2], corners[3], corners[0], corners[1]), numX, numY, uParamRange, vParamRange);\r\n      this.endFace();\r\n    }\r\n  }\r\n\r\n  /** Add a polygon to the evolving facets.\r\n   *\r\n   * * Add points to the polyface\r\n   * * indices are added (in reverse order if indicated by the builder state)\r\n   * @param points array of points.  This may contain extra points not to be used in the polygon\r\n   * @param numPointsToUse number of points to use.\r\n   */\r\n  public addPolygon(points: Point3d[], numPointsToUse?: number) {\r\n    // don't use trailing points that match start point.\r\n    if (numPointsToUse === undefined)\r\n      numPointsToUse = points.length;\r\n    while (numPointsToUse > 1 && points[numPointsToUse - 1].isAlmostEqual(points[0]))\r\n      numPointsToUse--;\r\n    let index = 0;\r\n    if (!this._reversed) {\r\n      for (let i = 0; i < numPointsToUse; i++) {\r\n        index = this.findOrAddPoint(points[i]);\r\n        this._polyface.addPointIndex(index);\r\n      }\r\n    } else {\r\n      for (let i = numPointsToUse; --i >= 0;) {\r\n        index = this.findOrAddPoint(points[i]);\r\n        this._polyface.addPointIndex(index);\r\n      }\r\n    }\r\n    this._polyface.terminateFacet();\r\n  }\r\n\r\n  /** Add a polygon to the evolving facets.\r\n   *\r\n   * * Add points to the polyface\r\n   * * indices are added (in reverse order if indicated by the builder state)\r\n   * @param points array of points.  This may contain extra points not to be used in the polygon\r\n   * @param numPointsToUse number of points to use.\r\n   */\r\n  public addPolygonGrowableXYZArray(points: GrowableXYZArray) {\r\n    // don't use trailing points that match start point.\r\n    let numPointsToUse = points.length;\r\n    while (numPointsToUse > 1 && Geometry.isSmallMetricDistance(points.distanceIndexIndex(0, numPointsToUse - 1)!))\r\n      numPointsToUse--;\r\n    let index = 0;\r\n    if (!this._reversed) {\r\n      for (let i = 0; i < numPointsToUse; i++) {\r\n        index = this.findOrAddPointInGrowableXYZArray(points, i)!;\r\n        this._polyface.addPointIndex(index);\r\n      }\r\n    } else {\r\n      for (let i = numPointsToUse; --i >= 0;) {\r\n        index = this.findOrAddPointInGrowableXYZArray(points, i)!;\r\n        this._polyface.addPointIndex(index);\r\n      }\r\n    }\r\n    this._polyface.terminateFacet();\r\n  }\r\n  /** Add a polygon to the evolving facets.\r\n   *\r\n   * * Add points to the polyface\r\n   * * indices are added (in reverse order if indicated by the builder state)\r\n   * @param normals array of points.  This may contain extra points not to be used in the polygon\r\n   * @param numPointsToUse number of points to use.\r\n   */\r\n  public addFacetFromGrowableArrays(points: GrowableXYZArray, normals: GrowableXYZArray | undefined, params: GrowableXYArray | undefined, colors: number[] | undefined) {\r\n    // don't use trailing points that match start point.\r\n    let numPointsToUse = points.length;\r\n    while (numPointsToUse > 1 && Geometry.isSmallMetricDistance(points.distanceIndexIndex(0, numPointsToUse - 1)!))\r\n      numPointsToUse--;\r\n    let index = 0;\r\n    if (normals && normals.length < numPointsToUse)\r\n      normals = undefined;\r\n    if (params && params.length < numPointsToUse)\r\n      params = undefined;\r\n    if (colors && colors.length < numPointsToUse)\r\n    colors = undefined;\r\n    if (!this._reversed) {\r\n      for (let i = 0; i < numPointsToUse; i++) {\r\n        index = this.findOrAddPointInGrowableXYZArray(points, i)!;\r\n        this._polyface.addPointIndex(index);\r\n\r\n        if (normals) {\r\n          index = this.findOrAddNormalInGrowableXYZArray(normals, i)!;\r\n          this._polyface.addNormalIndex(index);\r\n        }\r\n\r\n        if (params) {\r\n          index = this.findOrAddParamInGrowableXYArray(params, i)!;\r\n          this._polyface.addParamIndex(index);\r\n        }\r\n        if (colors) {\r\n          index = this._polyface.addColor(colors[i]);\r\n          this._polyface.addColorIndex(index);\r\n        }\r\n      }\r\n    } else {\r\n      for (let i = numPointsToUse; --i >= 0;) {\r\n        index = this.findOrAddPointInGrowableXYZArray(points, i)!;\r\n        this._polyface.addPointIndex(index);\r\n\r\n        if (normals) {\r\n          index = this.findOrAddNormalInGrowableXYZArray(normals, i)!;\r\n          this._polyface.addNormalIndex(index);\r\n        }\r\n\r\n        if (params) {\r\n          index = this.findOrAddParamInGrowableXYArray(params, i)!;\r\n          this._polyface.addParamIndex(index);\r\n        }\r\n        if (colors) {\r\n          index = this._polyface.addColor(colors[i]);\r\n          this._polyface.addColorIndex(index);\r\n        }\r\n      }\r\n    }\r\n    this._polyface.terminateFacet();\r\n  }\r\n\r\n  /** Add the current visitor facet to the evolving polyface.\r\n   * * indices are added (in reverse order if indicated by the builder state)\r\n   */\r\n  public addFacetFromVisitor(visitor: PolyfaceVisitor) {\r\n    this.addFacetFromGrowableArrays(visitor.point, visitor.normal, visitor.param, visitor.color);\r\n  }\r\n\r\n  /** Add a polyface, with optional reverse and transform. */\r\n  public addIndexedPolyface(source: IndexedPolyface, reversed: boolean, transform?: Transform) {\r\n    this._polyface.addIndexedPolyface(source, reversed, transform);\r\n  }\r\n\r\n  /**\r\n   * Produce a new FacetFaceData for all terminated facets since construction of the previous face.\r\n   * Each facet number/index is mapped to the FacetFaceData through the faceToFaceData array.\r\n   * Returns true if successful, and false otherwise.\r\n   */\r\n  public endFace(): boolean {\r\n    return this._polyface.setNewFaceData();\r\n  }\r\n\r\n  /** Double dispatch handler for Cone */\r\n  public handleCone(g: Cone): any { return this.addCone(g); }\r\n  /** Double dispatch handler for TorusPipe */\r\n  public handleTorusPipe(g: TorusPipe): any { return this.addTorusPipe(g); }\r\n  /** Double dispatch handler for Sphere */\r\n  public handleSphere(g: Sphere): any { return this.addSphere(g); }\r\n  /** Double dispatch handler for Box */\r\n  public handleBox(g: Box): any { return this.addBox(g); }\r\n  /** Double dispatch handler for LinearSweep */\r\n  public handleLinearSweep(g: LinearSweep): any { return this.addLinearSweep(g); }\r\n  /** Double dispatch handler for RotationalSweep */\r\n  public handleRotationalSweep(g: RotationalSweep): any { return this.addRotationalSweep(g); }\r\n  /** Double dispatch handler for RuledSweep */\r\n  public handleRuledSweep(g: RuledSweep): any { return this.addRuledSweep(g); }\r\n  /** add facets for a GeometryQuery object.   This is double dispatch through `dispatchToGeometryHandler(this)` */\r\n  public addGeometryQuery(g: GeometryQuery) { g.dispatchToGeometryHandler(this); }\r\n\r\n  /**\r\n   *\r\n   * * Visit all faces\r\n   * * Test each face with f(node) for any node on the face.\r\n   * * For each face that passes, pass its coordinates to the builder.\r\n   * * Rely on the builder's compress step to find common vertex coordinates\r\n   * @internal\r\n   */\r\n  public addGraph(graph: HalfEdgeGraph, needParams: boolean, acceptFaceFunction: HalfEdgeToBooleanFunction = HalfEdge.testNodeMaskNotExterior) {\r\n    let index = 0;\r\n    const needNormals = this._options.needNormals;\r\n    let normalIndex = 0;\r\n    if (needNormals)\r\n      normalIndex = this._polyface.addNormalXYZ(0, 0, 1);   // big assumption !!!!  someday check if that's where the facets actually are!!\r\n\r\n    graph.announceFaceLoops(\r\n      (_graph: HalfEdgeGraph, seed: HalfEdge) => {\r\n        if (acceptFaceFunction(seed) && seed.countEdgesAroundFace() > 2) {\r\n          let node = seed;\r\n          do {\r\n            index = this.findOrAddPointXYZ(node.x, node.y, node.z);\r\n            this._polyface.addPointIndex(index);\r\n            if (needParams) {\r\n              index = this.findOrAddParamXY(node.x, node.y);\r\n              this._polyface.addParamIndex(index);\r\n            }\r\n            if (needNormals) {\r\n              this._polyface.addNormalIndex(normalIndex);\r\n            }\r\n            node = node.faceSuccessor;\r\n          } while (node !== seed);\r\n          this._polyface.terminateFacet();\r\n        }\r\n        return true;\r\n      });\r\n  }\r\n  /**\r\n   *\r\n   * * For each node in `faces`\r\n   *  * add all of its vertices to the polyface\r\n   *  * add point indices to form a new facet.\r\n   *    * (Note: no normal or param indices are added)\r\n   *  * terminate the facet\r\n   * @internal\r\n   */\r\n  public addGraphFaces(_graph: HalfEdgeGraph, faces: HalfEdge[]) {\r\n    let index = 0;\r\n    for (const seed of faces) {\r\n      let node = seed;\r\n      do {\r\n        index = this.findOrAddPointXYZ(node.x, node.y, node.z);\r\n        this._polyface.addPointIndex(index);\r\n        node = node.faceSuccessor;\r\n      } while (node !== seed);\r\n      this._polyface.terminateFacet();\r\n    }\r\n  }\r\n  /** Create a polyface containing the faces of a HalfEdgeGraph, with test function to filter faces.\r\n   * @internal\r\n   */\r\n  public static graphToPolyface(graph: HalfEdgeGraph, options?: StrokeOptions, acceptFaceFunction: HalfEdgeToBooleanFunction = HalfEdge.testNodeMaskNotExterior): IndexedPolyface {\r\n    const builder = PolyfaceBuilder.create(options);\r\n    builder.addGraph(graph, builder.options.needParams, acceptFaceFunction);\r\n    builder.endFace();\r\n    return builder.claimPolyface();\r\n  }\r\n  /** Create a polyface containing an array of faces of a HalfEdgeGraph, with test function to filter faces.\r\n   * @internal\r\n   */\r\n  public static graphFacesToPolyface(graph: HalfEdgeGraph, faces: HalfEdge[]): IndexedPolyface {\r\n    const builder = PolyfaceBuilder.create();\r\n    builder.addGraphFaces(graph, faces);\r\n    builder.endFace();\r\n    return builder.claimPolyface();\r\n  }\r\n\r\n  /** Create a polyface containing triangles in a (space) polygon.\r\n   * * The polyface contains only coordinate data (no params or normals).\r\n   */\r\n  public static polygonToTriangulatedPolyface(points: Point3d[], localToWorld?: Transform): IndexedPolyface | undefined {\r\n    if (!localToWorld)\r\n      localToWorld = FrameBuilder.createFrameWithCCWPolygon(points);\r\n    if (localToWorld) {\r\n      const localPoints = localToWorld.multiplyInversePoint3dArray(points)!;\r\n      const areaXY = PolygonOps.areaXY(localPoints);\r\n      if (areaXY < 0.0)\r\n        localPoints.reverse();\r\n      const graph = Triangulator.createTriangulatedGraphFromSingleLoop(localPoints);\r\n      if (graph) {\r\n        const polyface = this.graphToPolyface(graph);\r\n        polyface.tryTransformInPlace(localToWorld);\r\n        return polyface;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Given arrays of coordinates for multiple facets.\r\n   * * pointArray[i] is an array of 3 or 4 points\r\n   * * paramArray[i] is an array of matching number of params\r\n   * * normalArray[i] is an array of matching number of normals.\r\n   * @param pointArray array of arrays of point coordinates\r\n   * @param paramArray array of arrays of uv parameters\r\n   * @param normalArray array of arrays of normals\r\n   * @param endFace if true, call this.endFace after adding all the facets.\r\n   */\r\n  public addCoordinateFacets(pointArray: Point3d[][], paramArray?: Point2d[][], normalArray?: Vector3d[][], endFace: boolean = false) {\r\n    for (let i = 0; i < pointArray.length; i++) {\r\n      const params = paramArray ? paramArray[i] : undefined;\r\n      const normals = normalArray ? normalArray[i] : undefined;\r\n\r\n      if (pointArray[i].length === 3)\r\n        this.addTriangleFacet(pointArray[i], params, normals);\r\n      else if (pointArray[i].length === 4)\r\n        this.addQuadFacet(pointArray[i], params, normals);\r\n    }\r\n\r\n    if (endFace)\r\n      this.endFace();\r\n  }\r\n  /**\r\n   * * Evaluate `(numU + 1) * (numV + 1)` grid points (in 0..1 in both u and v) on a surface.\r\n   * * Add the facets for `numU * numV` quads.\r\n   * * uv params are the 0..1 fractions.\r\n   * * normals are cross products of u and v direction partial derivatives.\r\n   * @param surface\r\n   * @param numU\r\n   * @param numV\r\n   */\r\n  public addUVGridBody(surface: UVSurface, numU: number, numV: number, uMap?: Segment1d, vMap?: Segment1d) {\r\n    let xyzIndex0 = new GrowableFloat64Array(numU);\r\n    let xyzIndex1 = new GrowableFloat64Array(numU);\r\n    let paramIndex0: GrowableFloat64Array | undefined;\r\n    let paramIndex1: GrowableFloat64Array | undefined;\r\n    let normalIndex0: GrowableFloat64Array | undefined;\r\n    let normalIndex1: GrowableFloat64Array | undefined;\r\n    const reverse = this._reversed;\r\n    const needNormals = this.options.needNormals;\r\n    if (needNormals) {\r\n      normalIndex0 = new GrowableFloat64Array(numU);\r\n      normalIndex1 = new GrowableFloat64Array(numU);\r\n    }\r\n    const needParams = this.options.needParams;\r\n    if (needParams) {\r\n      paramIndex0 = new GrowableFloat64Array(numU);\r\n      paramIndex1 = new GrowableFloat64Array(numU);\r\n    }\r\n\r\n    let indexSwap;\r\n    xyzIndex0.ensureCapacity(numU);\r\n    xyzIndex1.ensureCapacity(numU);\r\n    const uv = Point2d.create();\r\n    const normal = Vector3d.create();\r\n    const du = 1.0 / numU;\r\n    const dv = 1.0 / numV;\r\n    const plane = Plane3dByOriginAndVectors.createXYPlane();\r\n    for (let v = 0; v <= numV; v++) {\r\n      // evaluate new points ....\r\n      xyzIndex1.clear();\r\n      if (needNormals)\r\n        normalIndex1!.clear();\r\n      if (needParams)\r\n        paramIndex1!.clear();\r\n      for (let u = 0; u <= numU; u++) {\r\n        const uFrac = u * du;\r\n        const vFrac = v * dv;\r\n        surface.uvFractionToPointAndTangents(uFrac, vFrac, plane);\r\n        xyzIndex1.push(this._polyface.addPoint(plane.origin));\r\n        if (needNormals) {\r\n          plane.vectorU.crossProduct(plane.vectorV, normal);\r\n          normal.normalizeInPlace();\r\n          if (reverse)\r\n            normal.scaleInPlace(-1.0);\r\n          normalIndex1!.push(this._polyface.addNormal(normal));\r\n        }\r\n        if (needParams)\r\n          paramIndex1!.push(this._polyface.addParam(Point2d.create(\r\n            uMap ? uMap.fractionToPoint(uFrac) : uFrac,\r\n            vMap ? vMap.fractionToPoint(vFrac) : vFrac,\r\n            uv)));\r\n      }\r\n\r\n      if (v > 0) {\r\n        for (let u = 0; u < numU; u++) {\r\n          this.addIndexedQuadPointIndexes(\r\n            xyzIndex0.atUncheckedIndex(u), xyzIndex0.atUncheckedIndex(u + 1),\r\n            xyzIndex1.atUncheckedIndex(u), xyzIndex1.atUncheckedIndex(u + 1), false);\r\n          if (needNormals)\r\n            this.addIndexedQuadNormalIndexes(\r\n              normalIndex0!.atUncheckedIndex(u), normalIndex0!.atUncheckedIndex(u + 1),\r\n              normalIndex1!.atUncheckedIndex(u), normalIndex1!.atUncheckedIndex(u + 1));\r\n          if (needParams)\r\n            this.addIndexedQuadParamIndexes(\r\n              paramIndex0!.atUncheckedIndex(u), paramIndex0!.atUncheckedIndex(u + 1),\r\n              paramIndex1!.atUncheckedIndex(u), paramIndex1!.atUncheckedIndex(u + 1));\r\n          this._polyface.terminateFacet();\r\n        }\r\n      }\r\n      indexSwap = xyzIndex1; xyzIndex1 = xyzIndex0; xyzIndex0 = indexSwap;\r\n      if (needParams) {\r\n        indexSwap = paramIndex1; paramIndex1 = paramIndex0; paramIndex0 = indexSwap;\r\n      }\r\n      if (needNormals) {\r\n        indexSwap = normalIndex1; normalIndex1 = normalIndex0; normalIndex0 = indexSwap;\r\n      }\r\n\r\n    }\r\n    xyzIndex0.clear();\r\n    xyzIndex1.clear();\r\n  }\r\n  /**\r\n   * Triangulate the points as viewed in xy.\r\n   * @param points\r\n   */\r\n  public static pointsToTriangulatedPolyface(points: Point3d[]): IndexedPolyface | undefined {\r\n    const graph = Triangulator.createTriangulatedGraphFromPoints(points);\r\n    if (graph)\r\n      return PolyfaceBuilder.graphToPolyface(graph);\r\n    return undefined;\r\n  }\r\n  /** Create (and add to the builder) triangles that bridge the gap between two linestrings.\r\n   * * Each triangle will have 1 vertex on one of the linestrings and 2 on the other\r\n   * * Choice of triangles is heuristic, hence does not have a unique solution.\r\n   * * Logic to choice among the various possible triangle orders prefers\r\n   *    * Make near-coplanar facets\r\n   *    * make facets with good aspect ratio.\r\n   *    * This is exercised with a limited number of lookahead points, i.e. greedy to make first-available decision.\r\n   * @param pointsA points of first linestring.\r\n   * @param pointsB points of second linestring.\r\n   */\r\n  public addGreedyTriangulationBetweenLineStrings(pointsA: Point3d[] | LineString3d | IndexedXYZCollection, pointsB: Point3d[] | LineString3d | IndexedXYZCollection) {\r\n    const context = GreedyTriangulationBetweenLineStrings.createContext();\r\n    context.emitTriangles(\r\n      resolveToIndexedXYZCollectionOrCarrier(pointsA),\r\n      resolveToIndexedXYZCollectionOrCarrier(pointsB),\r\n      (triangle: BarycentricTriangle) => {\r\n        this.addTriangleFacet(triangle.points);\r\n      });\r\n  }\r\n}\r\n\r\nfunction resolveToIndexedXYZCollectionOrCarrier(points: Point3d[] | LineString3d | IndexedXYZCollection): IndexedXYZCollection {\r\n  if (Array.isArray(points))\r\n    return new Point3dArrayCarrier(points);\r\n  if (points instanceof LineString3d)\r\n    return points.packedPoints;\r\n  return points;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty*/\r\n// import { Point3d, Vector3d, Point2d } from \"./PointVector\";\r\nimport { Polyface, PolyfaceVisitor, IndexedPolyface } from \"./Polyface\";\r\nimport { ClipPlane } from \"../clipping/ClipPlane\";\r\nimport { ConvexClipPlaneSet } from \"../clipping/ConvexClipPlaneSet\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { PolyfaceBuilder } from \"./PolyfaceBuilder\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { ChainMergeContext } from \"../topology/ChainMerge\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { SweepContour } from \"../solid/SweepContour\";\r\nimport { PolygonOps, IndexedXYZCollectionPolygonOps } from \"../geometry3d/PolygonOps\";\r\nimport { Range3d, Range2d, Range1d } from \"../geometry3d/Range\";\r\nimport { PolyfaceQuery } from \"./PolyfaceQuery\";\r\nimport { RangeSearch } from \"./multiclip/RangeSearch\";\r\n\r\n/** PolyfaceClip is a static class gathering operations using Polyfaces and clippers.\r\n * @public\r\n */\r\nexport class PolyfaceClip {\r\n  /** Clip each facet of polyface to the ClipPlane.\r\n   * * Return all surviving clip as a new mesh.\r\n   * * WARNING: The new mesh is \"points only\".\r\n   */\r\n  public static clipPolyfaceClipPlaneWithClosureFace(polyface: Polyface, clipper: ClipPlane, insideClip: boolean = true, buildClosureFace: boolean = true): Polyface {\r\n    const visitor = polyface.createVisitor(0);\r\n    const builder = PolyfaceBuilder.create();\r\n    const chainContext = ChainMergeContext.create();\r\n\r\n    const work = new GrowableXYZArray(10);\r\n    const point0 = Point3d.create();\r\n    const point1 = Point3d.create();\r\n    for (visitor.reset(); visitor.moveToNextFacet();) {\r\n      clipper.clipConvexPolygonInPlace(visitor.point, work, insideClip);\r\n      if (visitor.point.length > 2)\r\n        builder.addPolygonGrowableXYZArray(visitor.point);\r\n      this.collectEdgesOnPlane(visitor.point, clipper, chainContext, point0, point1);\r\n    }\r\n    // SweepContour is your friend .. but maybe it doesn't do holes and multi-loops yet?\r\n    if (buildClosureFace) {\r\n      const outwardNormal = clipper.getPlane3d().getNormalRef().scale(-1.0);\r\n      chainContext.clusterAndMergeVerticesXYZ();\r\n      const loops = chainContext.collectMaximalGrowableXYZArrays();\r\n      PolygonOps.orientLoopsCCWForOutwardNormalInPlace(loops, outwardNormal);\r\n      const contour = SweepContour.createForPolygon(loops, outwardNormal);\r\n      if (contour !== undefined) {\r\n        contour.emitFacets(builder, insideClip);\r\n      }\r\n    }\r\n    return builder.claimPolyface(true);\r\n  }\r\n\r\n  /** Clip each facet of polyface to the ClipPlane.\r\n   * * Return all surviving clip as a new mesh.\r\n   * * WARNING: The new mesh is \"points only\".\r\n   */\r\n  public static clipPolyfaceClipPlane(polyface: Polyface, clipper: ClipPlane, insideClip: boolean = true): Polyface {\r\n    return this.clipPolyfaceClipPlaneWithClosureFace(polyface, clipper, insideClip, false);\r\n  }\r\n\r\n  /** Clip each facet of polyface to the ClipPlane.\r\n   * * Return surviving clip as a new mesh.\r\n   * * WARNING: The new mesh is \"points only\".\r\n   */\r\n  public static clipPolyfaceConvexClipPlaneSet(polyface: Polyface, clipper: ConvexClipPlaneSet): Polyface {\r\n    const visitor = polyface.createVisitor(0);\r\n    const builder = PolyfaceBuilder.create();\r\n    const work = new GrowableXYZArray(10);\r\n    for (visitor.reset(); visitor.moveToNextFacet();) {\r\n      clipper.clipConvexPolygonInPlace(visitor.point, work);\r\n      if (visitor.point.length > 2)\r\n        builder.addPolygonGrowableXYZArray(visitor.point);\r\n    }\r\n    return builder.claimPolyface(true);\r\n  }\r\n\r\n  /** Clip each facet of polyface to the ClipPlane or ConvexClipPlaneSet\r\n   * * This method parses  the variant input types and calls a more specific method.\r\n   * * WARNING: The new mesh is \"points only\".\r\n   */\r\n  public static clipPolyface(polyface: Polyface, clipper: ClipPlane | ConvexClipPlaneSet): Polyface | undefined {\r\n    if (clipper instanceof ClipPlane)\r\n      return this.clipPolyfaceClipPlane(polyface, clipper);\r\n    if (clipper instanceof ConvexClipPlaneSet)\r\n      return this.clipPolyfaceConvexClipPlaneSet(polyface, clipper);\r\n    // (The if tests exhaust the type space -- this line is unreachable.)\r\n    return undefined;\r\n  }\r\n\r\n  /** Find consecutive points around a polygon (with implied closure edge) that are ON a plane\r\n   * @param points array of points around polygon.  Closure edge is implied.\r\n   * @param chainContext context receiving edges\r\n   * @param point0 work point\r\n   * @param point1 work point\r\n  */\r\n  private static collectEdgesOnPlane(points: GrowableXYZArray, clipper: ClipPlane, chainContext: ChainMergeContext, point0: Point3d, point1: Point3d) {\r\n    const n = points.length;\r\n    if (n > 1) {\r\n      points.getPoint3dAtUncheckedPointIndex(n - 1, point0);\r\n      for (let i = 0; i < n; i++) {\r\n        points.getPoint3dAtUncheckedPointIndex(i, point1);\r\n        if (clipper.isPointOn(point0) && clipper.isPointOn(point1))\r\n          chainContext.addSegment(point0, point1);\r\n        point0.setFromPoint3d(point1);\r\n      }\r\n    }\r\n  }\r\n  /** Intersect each facet with the clip plane. (Producing intersection edges.)\r\n   * * Return all edges  chained as array of LineString3d.\r\n   */\r\n  public static sectionPolyfaceClipPlane(polyface: Polyface, clipper: ClipPlane): LineString3d[] {\r\n    const chainContext = ChainMergeContext.create();\r\n\r\n    const visitor = polyface.createVisitor(0);\r\n    const work = new GrowableXYZArray(10);\r\n    const point0 = Point3d.create();\r\n    const point1 = Point3d.create();\r\n    for (visitor.reset(); visitor.moveToNextFacet();) {\r\n      clipper.clipConvexPolygonInPlace(visitor.point, work, true);\r\n      this.collectEdgesOnPlane(visitor.point, clipper, chainContext, point0, point1);\r\n    }\r\n    chainContext.clusterAndMergeVerticesXYZ();\r\n    return chainContext.collectMaximalChains();\r\n  }\r\n\r\n  /**\r\n   * * Split facets of mesh \"A\" into parts that are\r\n   *     * under mesh \"B\"\r\n   *     * over mesh \"B\"\r\n   * * both meshes are represented by visitors rather than the meshes themselves\r\n   *     * If the data in-hand is a mesh, call with `mesh.createVisitor`\r\n   * * The respective clip parts are fed to caller-supplied builders.\r\n   *    * Caller may set either or both builders to toggle facet order (e.g. toggle the lower facets to make them \"point down\" in cut-fill application)\r\n   *    * This step is commonly one-half of \"cut fill\".\r\n   *       * A \"cut fill\" wrapper will call this twice with the visitor and builder roles reversed.\r\n   * * Both polyfaces are assumed convex with CCW orientation viewed from above.\r\n   * @param visitorA iterator over polyface to be split.\r\n   * @param visitorB iterator over polyface that acts as a splitter\r\n   * @param orientUnderMeshDownward if true, the \"meshAUnderB\" output is oriented with its normals reversed so it can act as the bottom side of a cut-fill pair.\r\n   */\r\n  public static clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(visitorA: PolyfaceVisitor, visitorB: PolyfaceVisitor,\r\n    builderAUnderB: PolyfaceBuilder | undefined,\r\n    builderAOverB: PolyfaceBuilder | undefined) {\r\n    const rangeDataA = PolyfaceQuery.collectRangeLengthData(visitorA);\r\n    const searchA = RangeSearch.create2dSearcherForRangeLengthData<number>(rangeDataA);\r\n    if (!searchA)\r\n      return;\r\n    const range = Range3d.create();\r\n    for (visitorA.reset(); visitorA.moveToNextFacet();) {\r\n      visitorA.point.setRange(range);\r\n      searchA.addRange(range, visitorA.currentReadIndex());\r\n    }\r\n    const xyClip = new GrowableXYZArray(10);\r\n    const workArray = new GrowableXYZArray(10);\r\n    const xyFrustum = ConvexClipPlaneSet.createEmpty();\r\n    const below = new GrowableXYZArray(10);\r\n    const above = new GrowableXYZArray(10);\r\n    const planeOfFacet = ClipPlane.createNormalAndPointXYZXYZ(0, 0, 1, 0, 0, 0)!;\r\n    const altitudeRange = Range1d.createNull();\r\n\r\n    for (visitorB.reset(); visitorB.moveToNextFacet();) {\r\n      visitorB.point.setRange(range);\r\n      ConvexClipPlaneSet.setPlaneAndXYLoopCCW(visitorB.point, planeOfFacet, xyFrustum);\r\n      searchA.searchRange2d(range, (_rangeA: Range2d, readIndexA: number) => {\r\n        visitorA.moveToReadIndex(readIndexA);\r\n        xyFrustum.polygonClip(visitorA.point, xyClip, workArray);\r\n        // builderAOverB.addPolygonGrowableXYZArray(xyClip);\r\n        if (xyClip.length > 0) {\r\n          // planeOfFacet.convexPolygonSplitInsideOutsideGrowableArrays(xyClip, below, above, altitudeRange);\r\n          IndexedXYZCollectionPolygonOps.splitConvexPolygonInsideOutsidePlane(planeOfFacet, xyClip, below, above, altitudeRange);\r\n          if (below.length > 0 && builderAUnderB)\r\n            builderAUnderB.addPolygonGrowableXYZArray(below);\r\n          if (above.length > 0 && builderAOverB)\r\n            builderAOverB.addPolygonGrowableXYZArray(above);\r\n        }\r\n        return true;\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * * Split facets into vertically overlapping sections\r\n   * * both meshes are represented by visitors rather than the meshes themselves\r\n   *     * If the data in-hand is a mesh, call with `mesh.createVisitor`\r\n   * * The respective clip parts are returned as separate meshes.\r\n   *    * Caller may set either or both builders to toggle facet order (e.g. toggle the lower facets to make them \"point down\" in cut-fill application)\r\n   * * Both polyfaces are assumed convex with CCW orientation viewed from above.\r\n   * * Each output contains some facets from meshA and some from meshB:\r\n   *    * meshAUnderB -- areas where meshA is underneath mesh B.\r\n   *        * If A is \"design surface\" and B is existing DTM, this is \"cut\" volume\r\n   *    * meshAOverB  -- areas where meshB is over meshB.\r\n   *        * If A is \"design surface\" and B is existing DTM, this is \"fill\" volume\r\n   *\r\n   * @param visitorA iterator over polyface to be split.\r\n   * @param visitorB iterator over polyface that acts as a splitter\r\n   * @param orientUnderMeshDownward if true, the \"meshAUnderB\" output is oriented with its normals reversed so it can act as the bottom side of a cut-fill pair.\r\n   */\r\n  public static computeCutFill(meshA: IndexedPolyface, meshB: IndexedPolyface): { meshAUnderB: IndexedPolyface, meshAOverB: IndexedPolyface } {\r\n    const visitorA = meshA.createVisitor();\r\n    const visitorB = meshB.createVisitor();\r\n    const builderAUnderB = PolyfaceBuilder.create();\r\n    const builderAOverB = PolyfaceBuilder.create();\r\n    builderAUnderB.toggleReversedFacetFlag();\r\n    this.clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(visitorA, visitorB, builderAUnderB, builderAOverB);\r\n    builderAUnderB.toggleReversedFacetFlag();\r\n    builderAOverB.toggleReversedFacetFlag();\r\n    this.clipPolyfaceUnderOverConvexPolyfaceIntoBuilders(visitorB, visitorA, builderAOverB, builderAUnderB);\r\n    return {\r\n      meshAUnderB: builderAUnderB.claimPolyface(),\r\n      meshAOverB: builderAOverB.claimPolyface(),\r\n    };\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { ClusterableArray } from \"../numerics/ClusterableArray\";\r\nimport { PolyfaceAuxData } from \"./AuxData\";\r\nimport { FacetFaceData } from \"./FacetFaceData\";\r\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\r\nimport { Geometry } from \"../Geometry\";\r\n\r\n/**\r\n * PolyfaceData carries data arrays for point, normal, param, color and their indices.\r\n *\r\n * * IndexedPolyface carries a PolyfaceData as a member. (NOT as a base class -- it already has GeometryQuery as base)\r\n * * IndexedPolyfaceVisitor uses PolyfaceData as a base class.\r\n * @public\r\n */\r\nexport class PolyfaceData {\r\n  // <ul\r\n  // <li>optional arrays (normal, uv, color) must be indicated at constructor time.\r\n  // <li>all arrays are (independently) indexed.\r\n  // <li>with regret, the point, param, normal, and color arrays are exposed publicly.\r\n  // <li>getX methods are \"trusting\" -- no bounds check\r\n  // <li>getX methods return references to X.\r\n  // <li> EXCEPT -- for optional arrays, the return 000.\r\n  // <li>copyX methods move data to caller-supplied result..\r\n  // </ul>\r\n  /** Relative tolerance used in tests for planar facets\r\n   * @internal\r\n   */\r\n  public static readonly planarityLocalRelTol = 1.0e-13;\r\n  /** Coordinate data for points in the facets, packed as numbers in a contiguous array. */\r\n  public point: GrowableXYZArray;\r\n  /** Indices of points at facet vertices. */\r\n  public pointIndex: number[];\r\n  /** booleans indicating visibility of corresponding edges */\r\n  public edgeVisible: boolean[];\r\n  /** Coordinates of normal vectors, packed as numbers in a contiguous array */\r\n  public normal: GrowableXYZArray | undefined;\r\n  /** indices of normals at facet vertices. */\r\n  public normalIndex: number[] | undefined;\r\n  /** Coordinates of uv parameters, packed as numbers in a contiguous array. */\r\n  public param?: GrowableXYArray;\r\n  /** Indics of params at facet vertices. */\r\n  public paramIndex: number[] | undefined;\r\n  /** Color values.  These are carried around as simple numbers, but are probably\r\n   * required (by display systems) map exactly to 32 bit integers.\r\n   */\r\n  public color: number[] | undefined;\r\n  /** Indices of colors at facet vertices. */\r\n  public colorIndex: number[] | undefined;\r\n  /** Face data will remain empty until a face is specified. */\r\n  public face: FacetFaceData[];\r\n  /** Auxiliary data */\r\n  public auxData: PolyfaceAuxData | undefined;\r\n  private _twoSided: boolean;\r\n  /** boolean tag indicating if the facets are viewable from the back */\r\n  public get twoSided(): boolean { return this._twoSided; }\r\n  /** boolean tag indicating if the facets are viewable from the back */\r\n  public set twoSided(value: boolean) { this._twoSided = value; }\r\n  /** Constructor for facets.  The various params control whether respective arrays are to be allocated. */\r\n  public constructor(needNormals: boolean = false, needParams: boolean = false, needColors: boolean = false, twoSided: boolean = false) {\r\n    this.point = new GrowableXYZArray();\r\n    this.pointIndex = []; this.edgeVisible = [];\r\n    this.face = [];\r\n    if (needNormals) { this.normal = new GrowableXYZArray(); this.normalIndex = []; }\r\n    if (needParams) { this.param = new GrowableXYArray(); this.paramIndex = []; }\r\n    if (needColors) { this.color = []; this.colorIndex = []; }\r\n    this._twoSided = twoSided;\r\n  }\r\n  /** Return a depp clone. */\r\n  public clone(): PolyfaceData {\r\n    const result = new PolyfaceData();\r\n    result.point = this.point.clone();\r\n    result.pointIndex = this.pointIndex.slice();\r\n    result.edgeVisible = this.edgeVisible.slice();\r\n    result.face = this.face.slice();\r\n    result.twoSided = this.twoSided;\r\n    if (this.normal)\r\n      result.normal = this.normal.clone();\r\n    if (this.param)\r\n      result.param = this.param.clone();\r\n    if (this.color)\r\n      result.color = this.color.slice();\r\n\r\n    if (this.normalIndex)\r\n      result.normalIndex = this.normalIndex.slice();\r\n    if (this.paramIndex)\r\n      result.paramIndex = this.paramIndex.slice();\r\n    if (this.colorIndex)\r\n      result.colorIndex = this.colorIndex.slice();\r\n    if (this.auxData)\r\n      result.auxData = this.auxData.clone();\r\n    return result;\r\n  }\r\n  /** Test for equal indices and nearly equal coordinates */\r\n  public isAlmostEqual(other: PolyfaceData): boolean {\r\n    if (!GrowableXYZArray.isAlmostEqual(this.point, other.point))\r\n      return false;\r\n    if (!NumberArray.isExactEqual(this.pointIndex, other.pointIndex))\r\n      return false;\r\n\r\n    if (!GrowableXYZArray.isAlmostEqual(this.normal, other.normal)) return false;\r\n    if (!NumberArray.isExactEqual(this.normalIndex, other.normalIndex)) return false;\r\n\r\n    if (!GrowableXYArray.isAlmostEqual(this.param, other.param)) return false;\r\n    if (!NumberArray.isExactEqual(this.paramIndex, other.paramIndex)) return false;\r\n\r\n    if (!NumberArray.isExactEqual(this.color, other.color)) return false;\r\n    if (!NumberArray.isExactEqual(this.colorIndex, other.colorIndex)) return false;\r\n\r\n    if (!NumberArray.isExactEqual(this.edgeVisible, other.edgeVisible)) return false;\r\n    if (!PolyfaceAuxData.isAlmostEqual(this.auxData, other.auxData)) return false;\r\n    return true;\r\n  }\r\n  /** Ask if normals are required in this mesh. */\r\n  public get requireNormals(): boolean { return undefined !== this.normal; }\r\n  /** Get the point count */\r\n  public get pointCount() { return this.point.length; }\r\n  /** Get the normal count */\r\n  public get normalCount() { return this.normal ? this.normal.length : 0; }\r\n  /** Get the param count */\r\n  public get paramCount() { return this.param ? this.param.length : 0; }\r\n  /** Get the color count */\r\n  public get colorCount() { return this.color ? this.color.length : 0; }\r\n  /** Get the index count.  Note that there is one count, and all index arrays (point, normal, param, color) must match */\r\n  public get indexCount() { return this.pointIndex.length; }  // ALWAYS INDEXED ... all index vectors must have same length.\r\n  /** Get the number of faces.\r\n   * * Note that a \"face\" is not a facet.\r\n   * * A \"face\" is a subset of facets grouped for application purposes.\r\n   */\r\n  public get faceCount() { return this.face.length; }\r\n\r\n  /** return indexed point. This is a copy of the coordinates, not a reference. */\r\n  public getPoint(i: number): Point3d | undefined { return this.point.getPoint3dAtCheckedPointIndex(i); }\r\n  /** return indexed normal. This is the COPY to the normal, not a reference. */\r\n  public getNormal(i: number): Vector3d | undefined { return this.normal ? this.normal.getVector3dAtCheckedVectorIndex(i) : undefined; }\r\n  /** return indexed param. This is the COPY of the coordinates, not a reference. */\r\n  public getParam(i: number): Point2d | undefined { return this.param ? this.param.getPoint2dAtCheckedPointIndex(i) : undefined; }\r\n  /** return indexed color */\r\n  public getColor(i: number): number { return this.color ? this.color[i] : 0; }\r\n  /** return indexed visibility */\r\n  public getEdgeVisible(i: number): boolean { return this.edgeVisible[i]; }\r\n  /** Copy the contents (not pointer) of point[i] into dest. */\r\n  public copyPointTo(i: number, dest: Point3d): void { this.point.getPoint3dAtUncheckedPointIndex(i, dest); }\r\n  /** Copy the contents (not pointer) of normal[i] into dest. */\r\n  public copyNormalTo(i: number, dest: Vector3d): void { if (this.normal) this.normal.getVector3dAtCheckedVectorIndex(i, dest); }\r\n  /** Copy the contents (not pointer) of param[i] into dest. */\r\n  public copyParamTo(i: number, dest: Point2d): void { if (this.param) this.param.getPoint2dAtCheckedPointIndex(i, dest); }\r\n  /** test if normal at a specified index matches uv */\r\n  public isAlmostEqualParamIndexUV(index: number, u: number, v: number): boolean {\r\n    if (this.param !== undefined && index >= 0 && index < this.param.length)\r\n      return Geometry.isSameCoordinate(u, this.param.getXAtUncheckedPointIndex(index))\r\n        && Geometry.isSameCoordinate(v, this.param.getYAtUncheckedPointIndex(index));\r\n    return false;\r\n  }\r\n  /**\r\n   * * Copy data from other to this.\r\n   * * This is the essence of transferring coordinates spread throughout a large polyface into a visitor's single facet.\r\n   * * \"other\" is the large polyface\r\n   * * \"this\" is the visitor\r\n   * * does NOT copy face data - visitors reference the FacetFaceData array for the whole polyface!!\r\n   * @param other polyface data being mined.\r\n   * @param index0 start index in other's index arrays\r\n   * @param index1 end index (one beyond last data accessed0 in other's index arrays\r\n   * @param numWrap number of points to replicate as wraparound.\r\n   */\r\n  public gatherIndexedData(other: PolyfaceData, index0: number, index1: number, numWrap: number) {\r\n    const numEdge = index1 - index0;\r\n    const numTotal = numEdge + numWrap;\r\n    this.resizeAllDataArrays(numTotal);\r\n    // copy wrapped points\r\n    for (let i = 0; i < numEdge; i++)\r\n      this.point.transferFromGrowableXYZArray(i, other.point, other.pointIndex[index0 + i]);\r\n    for (let i = 0; i < numWrap; i++)\r\n      this.point.transferFromGrowableXYZArray(numEdge + i, this.point, i);\r\n\r\n    // copy wrapped pointIndex\r\n    for (let i = 0; i < numEdge; i++)\r\n      this.pointIndex[i] = other.pointIndex[index0 + i];\r\n    for (let i = 0; i < numWrap; i++)\r\n      this.pointIndex[numEdge + i] = this.pointIndex[i];\r\n    // copy wrapped edge visibility\r\n    for (let i = 0; i < numEdge; i++)\r\n      this.edgeVisible[i] = other.edgeVisible[index0 + i];\r\n    for (let i = 0; i < numWrap; i++)\r\n      this.edgeVisible[numEdge + i] = this.edgeVisible[i];\r\n\r\n    if (this.normal && this.normalIndex && other.normal && other.normalIndex) {\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.normal.transferFromGrowableXYZArray(i, other.normal, other.normalIndex[index0 + i]);\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.normal.transferFromGrowableXYZArray(numEdge + i, this.normal, i);\r\n\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.normalIndex[i] = other.normalIndex[index0 + i];\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.normalIndex[numEdge + i] = this.normalIndex[i];\r\n    }\r\n\r\n    if (this.param && this.paramIndex && other.param && other.paramIndex) {\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.param.transferFromGrowableXYArray(i, other.param, other.paramIndex[index0 + i]);\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.param.transferFromGrowableXYArray(numEdge + i, this.param, i);\r\n\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.paramIndex[i] = other.paramIndex[index0 + i];\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.paramIndex[numEdge + i] = this.paramIndex[i];\r\n    }\r\n\r\n    if (this.color && this.colorIndex && other.color && other.colorIndex) {\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.color[i] = other.color[other.colorIndex[index0 + i]];\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.color[numEdge + i] = this.color[i];\r\n\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.colorIndex[i] = other.colorIndex[index0 + i];\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.colorIndex[numEdge + i] = this.colorIndex[i];\r\n    }\r\n    if (this.auxData && other.auxData && this.auxData.channels.length === other.auxData.channels.length) {\r\n      for (let iChannel = 0; iChannel < this.auxData.channels.length; iChannel++) {\r\n        const thisChannel = this.auxData.channels[iChannel];\r\n        const otherChannel = other.auxData.channels[iChannel];\r\n        const blockSize = thisChannel.entriesPerValue;\r\n        if (thisChannel.data.length === otherChannel.data.length) {\r\n          for (let iData = 0; iData < thisChannel.data.length; iData++) {\r\n            const thisData = thisChannel.data[iData];\r\n            const otherData = otherChannel.data[iData];\r\n            for (let i = 0; i < numEdge; i++)\r\n              thisData.copyValues(otherData, i, index0 + i, blockSize);\r\n            for (let i = 0; i < numWrap; i++)\r\n              thisData.copyValues(thisData, numEdge + i, i, blockSize);\r\n          }\r\n        }\r\n      }\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.auxData.indices[i] = other.auxData.indices[index0 + i];\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.auxData.indices[numEdge + i] = this.auxData.indices[i];\r\n    }\r\n  }\r\n  private static trimArray(data: any[] | undefined, length: number) { if (data && length < data.length) data.length = length; }\r\n  /** Trim all index arrays to stated length.\r\n   * * This is called by PolyfaceBuilder to clean up after an aborted construction sequence.\r\n   */\r\n  public trimAllIndexArrays(length: number): void {\r\n    PolyfaceData.trimArray(this.pointIndex, length);\r\n    PolyfaceData.trimArray(this.paramIndex, length);\r\n    PolyfaceData.trimArray(this.normalIndex, length);\r\n    PolyfaceData.trimArray(this.colorIndex, length);\r\n    PolyfaceData.trimArray(this.edgeVisible, length);\r\n    if (this.auxData) {\r\n      PolyfaceData.trimArray(this.auxData.indices, length);\r\n      for (const channel of this.auxData.channels) {\r\n        for (const data of channel.data)\r\n          PolyfaceData.trimArray(data.values, channel.entriesPerValue * length);\r\n      }\r\n    }\r\n  }\r\n  /** Resize all data arrays to specified length */\r\n  public resizeAllDataArrays(length: number): void {\r\n    if (length > this.point.length) {\r\n      while (this.point.length < length) this.point.push(Point3d.create());\r\n      while (this.pointIndex.length < length) this.pointIndex.push(-1);\r\n      while (this.edgeVisible.length < length) this.edgeVisible.push(false);\r\n      if (this.normal)\r\n        while (this.normal.length < length) this.normal.push(Vector3d.create());\r\n      if (this.param)\r\n        while (this.param.length < length) this.param.push(Point2d.create());\r\n      if (this.color)\r\n        while (this.color.length < length) this.color.push(0);\r\n      if (this.auxData) {\r\n        for (const channel of this.auxData.channels) {\r\n          for (const channelData of channel.data) {\r\n            while (channelData.values.length < length * channel.entriesPerValue) channelData.values.push(0);\r\n          }\r\n        }\r\n      }\r\n    } else if (length < this.point.length) {\r\n      this.point.resize(length);\r\n      this.edgeVisible.length = length;\r\n      this.pointIndex.length = length;\r\n      if (this.normal) this.normal.resize(length);\r\n      if (this.param) this.param.resize(length);\r\n      if (this.color) this.color.length = length;\r\n      if (this.auxData) {\r\n        for (const channel of this.auxData.channels) {\r\n          for (const channelData of channel.data) {\r\n            channelData.values.length = length * channel.entriesPerValue;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /** Return the range of the point array (optionally transformed) */\r\n  public range(result?: Range3d, transform?: Transform): Range3d {\r\n    result = result ? result : Range3d.createNull();\r\n    result.extendArray(this.point, transform);\r\n    return result;\r\n  }\r\n  /** reverse indices facet-by-facet, with the given facetStartIndex array delimiting faces.\r\n   *\r\n   * * facetStartIndex[0] == 0 always -- start of facet zero.\r\n   * * facet k has indices from facetStartIndex[k] <= i < facetStartIndex[k+1]\r\n   * * hence for \"internal\" k, facetStartIndex[k] is both the upper limit of facet k-1 and the start of facet k.\r\n   * *\r\n   */\r\n  public reverseIndices(facetStartIndex?: number[]) {\r\n    if (facetStartIndex && PolyfaceData.isValidFacetStartIndexArray(facetStartIndex)) {\r\n      PolyfaceData.reverseIndices(facetStartIndex, this.pointIndex, true);\r\n      PolyfaceData.reverseIndices(facetStartIndex, this.normalIndex, true);\r\n      PolyfaceData.reverseIndices(facetStartIndex, this.paramIndex, true);\r\n      PolyfaceData.reverseIndices(facetStartIndex, this.colorIndex, true);\r\n      PolyfaceData.reverseIndices(facetStartIndex, this.edgeVisible, false);\r\n    }\r\n  }\r\n  /** Scale all the normals by -1 */\r\n  public reverseNormals() {\r\n    if (this.normal)\r\n      this.normal.scaleInPlace(-1.0);\r\n  }\r\n  /** Apply `transform` to point and normal arrays.\r\n   * * IMPORTANT This base class is just a data carrier.  It does not know if the index order and normal directions have special meaning.\r\n   * * i.e. caller must separately reverse index order and normal direction if needed.\r\n   */\r\n  public tryTransformInPlace(\r\n    transform: Transform): boolean {\r\n    this.point.multiplyTransformInPlace(transform);\r\n\r\n    if (this.normal && !transform.matrix.isIdentity)\r\n      this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(transform.matrix);\r\n    return true;\r\n  }\r\n  /**\r\n   * * Search for duplication of coordinates within points, normals, and params.\r\n   * * compress the coordinate arrays.\r\n   * * revise all indexing for the relocated coordinates\r\n   */\r\n  public compress() {\r\n    const packedData = ClusterableArray.clusterGrowablePoint3dArray(this.point);\r\n    this.point = packedData.growablePackedPoints!;\r\n    packedData.updateIndices(this.pointIndex);\r\n    //    if (this.paramIndex)  // Tracking uv params\r\n    //      packedData.updateIndices(this.paramIndex);\r\n    //    if (this.normalIndex) // Tracking normals\r\n    //      packedData.updateIndices(this.normalIndex);\r\n  }\r\n\r\n  /**\r\n   * Test if facetStartIndex is (minimally!) valid:\r\n   * * length must be nonzero (recall that for \"no facets\" the facetStartIndexArray still must contain a 0)\r\n   * * Each entry must be strictly smaller than the one that follows.\r\n   * @param facetStartIndex array of facetStart data.  facet `i` has indices at `facetsStartIndex[i]` to (one before) `facetStartIndex[i+1]`\r\n   */\r\n  public static isValidFacetStartIndexArray(facetStartIndex: number[]): boolean {\r\n    // facetStartIndex for empty facets has a single entry \"0\" -- empty array is not allowed\r\n    if (facetStartIndex.length === 0)\r\n      return false;\r\n    for (let i = 0; i + 1 < facetStartIndex.length; i++)\r\n      if (facetStartIndex[i] >= facetStartIndex[i + 1])\r\n        return false;\r\n    return true;\r\n  }\r\n  /** Reverse data in facet indexing arrays.\r\n   * * parameterized over type T so non-number data -- e.g. boolean visibility flags -- can be reversed.\r\n   */\r\n  public static reverseIndices<T>(facetStartIndex: number[], indices: T[] | undefined, preserveStart: boolean): boolean {\r\n    if (!indices || indices.length === 0)\r\n      return true;  // empty case\r\n    if (indices.length > 0) {\r\n      if (facetStartIndex[facetStartIndex.length - 1] === indices.length) {\r\n        for (let i = 0; i + 1 < facetStartIndex.length; i++) {\r\n          let index0 = facetStartIndex[i];\r\n          let index1 = facetStartIndex[i + 1];\r\n          if (preserveStart) {\r\n            // leave [index0] as is so reversed facet starts at same vertex\r\n            while (index1 > index0 + 2) {\r\n              index1--; index0++;\r\n              const a = indices[index0];\r\n              indices[index0] = indices[index1];\r\n              indices[index1] = a;\r\n            }\r\n          } else {\r\n            // reverse all\r\n            while (index1 > index0 + 1) {\r\n              index1--;\r\n              const a = indices[index0];\r\n              indices[index0] = indices[index1];\r\n              indices[index1] = a;\r\n              index0++;\r\n            }\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty*/\r\n// import { Point3d, Vector3d, Point2d } from \"./PointVector\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Polyface, PolyfaceVisitor } from \"./Polyface\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { BagOfCurves, CurveCollection } from \"../curve/CurveCollection\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\nimport { MomentData } from \"../geometry4d/MomentData\";\r\nimport { IndexedEdgeMatcher, SortableEdgeCluster, SortableEdge } from \"./IndexedEdgeMatcher\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { PolyfaceBuilder } from \"./PolyfaceBuilder\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { ChainMergeContext } from \"../topology/ChainMerge\";\r\nimport { UnionFindContext } from \"../numerics/UnionFind\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { RangeLengthData } from \"./RangeLengthData\";\r\nimport { XYPointBuckets } from \"./multiclip/XYPointBuckets\";\r\nimport { CurveLocationDetail } from \"../curve/CurveLocationDetail\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\n/**\r\n * Structure to return multiple results from volume between facets and plane\r\n * @public\r\n */\r\nexport interface FacetProjectedVolumeSums {\r\n  /** Summed (signed) volume */\r\n  volume: number;\r\n  /** summed area moments for positive contributions */\r\n  positiveProjectedFacetAreaMoments?: MomentData;\r\n  /** summed area moments for negative contributions */\r\n  negativeProjectedFacetAreaMoments?: MomentData;\r\n}\r\n\r\n/** PolyfaceQuery is a static class whose methods implement queries on a polyface or polyface visitor provided as a parameter to each method.\r\n * @public\r\n */\r\nexport class PolyfaceQuery {\r\n  /** copy the points from a visitor into a Linestring3d in a Loop object */\r\n  public static visitorToLoop(visitor: PolyfaceVisitor) {\r\n    const ls = LineString3d.createPoints(visitor.point.getPoint3dArray());\r\n    return Loop.create(ls);\r\n  }\r\n  /** Create a linestring loop for each facet of the polyface. */\r\n  public static indexedPolyfaceToLoops(polyface: Polyface): BagOfCurves {\r\n    const result = BagOfCurves.create();\r\n    const visitor = polyface.createVisitor(1);\r\n    while (visitor.moveToNextFacet()) {\r\n      const loop = PolyfaceQuery.visitorToLoop(visitor);\r\n      result.tryAddChild(loop);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return the sum of all facets areas. */\r\n  public static sumFacetAreas(source: Polyface | PolyfaceVisitor): number {\r\n    let s = 0;\r\n    if (source instanceof Polyface)\r\n      return PolyfaceQuery.sumFacetAreas(source.createVisitor(1));\r\n\r\n    const visitor = source as PolyfaceVisitor;\r\n    visitor.reset();\r\n    while (visitor.moveToNextFacet()) {\r\n      s += PolygonOps.sumTriangleAreas(visitor.point.getPoint3dArray());\r\n    }\r\n    return s;\r\n  }\r\n  /** sum volumes of tetrahedra from origin to all facets.\r\n   * * if origin is omitted, the first point encountered (by the visitor) is used as origin.\r\n   * * If the mesh is closed, this sum is the volume.\r\n   * * If the mesh is not closed, this sum is the volume of a mesh with various additional facets\r\n   * from the origin to facets.\r\n  */\r\n  public static sumTetrahedralVolumes(source: Polyface | PolyfaceVisitor, origin?: Point3d): number {\r\n    let s = 0;\r\n    if (source instanceof Polyface)\r\n      return PolyfaceQuery.sumTetrahedralVolumes(source.createVisitor(0), origin);\r\n    let myOrigin = origin;\r\n    const visitor = source as PolyfaceVisitor;\r\n    const facetOrigin = Point3d.create();\r\n    const targetA = Point3d.create();\r\n    const targetB = Point3d.create();\r\n    visitor.reset();\r\n    while (visitor.moveToNextFacet()) {\r\n      if (myOrigin === undefined)\r\n        myOrigin = visitor.point.getPoint3dAtUncheckedPointIndex(0);\r\n      visitor.point.getPoint3dAtUncheckedPointIndex(0, facetOrigin);\r\n      for (let i = 1; i + 1 < visitor.point.length; i++) {\r\n        visitor.point.getPoint3dAtUncheckedPointIndex(i, targetA);\r\n        visitor.point.getPoint3dAtUncheckedPointIndex(i + 1, targetB);\r\n        s += myOrigin.tripleProductToPoints(facetOrigin, targetA, targetB);\r\n      }\r\n    }\r\n    return s / 6.0;\r\n  }\r\n  /** sum (signed) volumes between facets and a plane.\r\n   * Return a structure with multiple sums:\r\n   * * volume = the sum of (signed) volumes between facets and the plane.\r\n   * * positiveAreaMomentData, negativeProjectedFacetAreaMoments = moment data with centroid, area, and second moments with respect to the centroid.\r\n   *\r\n  */\r\n  public static sumVolumeBetweenFacetsAndPlane(source: Polyface | PolyfaceVisitor, plane: Plane3dByOriginAndUnitNormal): FacetProjectedVolumeSums {\r\n    if (source instanceof Polyface)\r\n      return PolyfaceQuery.sumVolumeBetweenFacetsAndPlane(source.createVisitor(0), plane);\r\n    const visitor = source as PolyfaceVisitor;\r\n    const facetOrigin = Point3d.create();\r\n    const targetA = Point3d.create();\r\n    const targetB = Point3d.create();\r\n    const triangleNormal = Vector3d.create();\r\n    const planeNormal = plane.getNormalRef();\r\n    let h0, hA, hB;\r\n    let signedVolumeSum = 0.0;\r\n    let signedTriangleArea;\r\n    let singleFacetArea;\r\n    const positiveAreaMomentSums = MomentData.create(undefined, true);\r\n    const negativeAreaMomentSums = MomentData.create(undefined, true);\r\n    const singleFacetProducts = Matrix4d.createZero();\r\n    const projectToPlane = plane.getProjectionToPlane();\r\n\r\n    visitor.reset();\r\n    // For each facet ..\r\n    //   Form triangles from facet origin to each far edge.\r\n    //   Sum signed area and volume contributions\r\n    // each \"projectedArea\" contribution is twice the area of a triangle.\r\n    // each volume contribution is  3 times the actual volume -- (1/3) of the altitude sums was the centroid altitude.\r\n    while (visitor.moveToNextFacet()) {\r\n      visitor.point.getPoint3dAtUncheckedPointIndex(0, facetOrigin);\r\n      h0 = plane.altitude(facetOrigin);\r\n      singleFacetArea = 0;\r\n      // within a single facets, the singleFacetArea sum is accumulated with signs of individual triangles.\r\n      // For a non-convex facet, this can be a mixture of positive and negative areas.\r\n      // The absoluteProjectedAreaSum contribution is forced positive after the sum for the facet.\r\n      for (let i = 1; i + 1 < visitor.point.length; i++) {\r\n        visitor.point.getPoint3dAtUncheckedPointIndex(i, targetA);\r\n        visitor.point.getPoint3dAtUncheckedPointIndex(i + 1, targetB);\r\n        facetOrigin.crossProductToPoints(targetA, targetB, triangleNormal);\r\n        hA = plane.altitude(targetA);\r\n        hB = plane.altitude(targetB);\r\n        signedTriangleArea = planeNormal.dotProduct(triangleNormal);\r\n        singleFacetArea += signedTriangleArea;\r\n        signedVolumeSum += signedTriangleArea * (h0 + hA + hB);\r\n      }\r\n\r\n      singleFacetProducts.setZero();\r\n      visitor.point.multiplyTransformInPlace(projectToPlane);\r\n      PolygonOps.addSecondMomentAreaProducts(visitor.point, facetOrigin, singleFacetProducts);\r\n\r\n      if (singleFacetArea > 0) {\r\n        positiveAreaMomentSums.accumulateProductsFromOrigin(facetOrigin, singleFacetProducts, 1.0);\r\n      } else {\r\n        negativeAreaMomentSums.accumulateProductsFromOrigin(facetOrigin, singleFacetProducts, 1.0);\r\n\r\n      }\r\n    }\r\n    positiveAreaMomentSums.shiftOriginAndSumsToCentroidOfSums();\r\n    negativeAreaMomentSums.shiftOriginAndSumsToCentroidOfSums();\r\n    const positiveAreaMoments = MomentData.inertiaProductsToPrincipalAxes(positiveAreaMomentSums.origin, positiveAreaMomentSums.sums);\r\n    const negativeAreaMoments = MomentData.inertiaProductsToPrincipalAxes(negativeAreaMomentSums.origin, negativeAreaMomentSums.sums);\r\n\r\n    return {\r\n      volume: signedVolumeSum / 6.0,\r\n      positiveProjectedFacetAreaMoments: positiveAreaMoments,\r\n      negativeProjectedFacetAreaMoments: negativeAreaMoments,\r\n    };\r\n  }\r\n\r\n  /** Return the inertia products [xx,xy,xz,xw, yw, etc] integrated over all all facets, as viewed from origin. */\r\n  public static sumFacetSecondAreaMomentProducts(source: Polyface | PolyfaceVisitor, origin: Point3d): Matrix4d {\r\n    if (source instanceof Polyface)\r\n      return PolyfaceQuery.sumFacetSecondAreaMomentProducts(source.createVisitor(0), origin);\r\n    const products = Matrix4d.createZero();\r\n    const visitor = source as PolyfaceVisitor;\r\n    visitor.reset();\r\n    while (visitor.moveToNextFacet()) {\r\n      PolygonOps.addSecondMomentAreaProducts(visitor.point, origin, products);\r\n    }\r\n    return products;\r\n  }\r\n  /** Return the inertia products [xx,xy,xz,xw, yw, etc] integrated over all tetrahedral volumes from origin */\r\n  public static sumFacetSecondVolumeMomentProducts(source: Polyface | PolyfaceVisitor, origin: Point3d): Matrix4d {\r\n    if (source instanceof Polyface)\r\n      return PolyfaceQuery.sumFacetSecondVolumeMomentProducts(source.createVisitor(0), origin);\r\n    const products = Matrix4d.createZero();\r\n    const visitor = source as PolyfaceVisitor;\r\n    visitor.reset();\r\n    while (visitor.moveToNextFacet()) {\r\n      PolygonOps.addSecondMomentVolumeProducts(visitor.point, origin, products);\r\n    }\r\n    return products;\r\n  }\r\n\r\n  /** Compute area moments for the mesh. In the returned MomentData:\r\n   * * origin is the centroid.\r\n   * * localToWorldMap has the origin and principal directions\r\n   * * radiiOfGyration radii for rotation around the x,y,z axes.\r\n   */\r\n  public static computePrincipalAreaMoments(source: Polyface): MomentData | undefined {\r\n    const origin = source.data.getPoint(0);\r\n    if (!origin) return undefined;\r\n    const inertiaProducts = PolyfaceQuery.sumFacetSecondAreaMomentProducts(source, origin);\r\n    return MomentData.inertiaProductsToPrincipalAxes(origin, inertiaProducts);\r\n  }\r\n  /** Compute area moments for the mesh. In the returned MomentData:\r\n   * * origin is the centroid.\r\n   * * localToWorldMap has the origin and principal directions\r\n   * * radiiOfGyration radii for rotation around the x,y,z axes.\r\n   * * The result is only valid if the mesh is closed.\r\n   * * There is no test for closure.  Use `PolyfaceQuery.isPolyfaceClosedByEdgePairing(polyface)` to test for closure.\r\n   */\r\n  public static computePrincipalVolumeMoments(source: Polyface): MomentData | undefined {\r\n    const origin = source.data.getPoint(0);\r\n    if (!origin) return undefined;\r\n    const inertiaProducts = PolyfaceQuery.sumFacetSecondVolumeMomentProducts(source, origin);\r\n    return MomentData.inertiaProductsToPrincipalAxes(origin, inertiaProducts);\r\n  }\r\n\r\n  /**\r\n   * Test if the facets in `source` occur in perfectly mated pairs, as is required for a closed manifold volume.\r\n   * @param source\r\n   */\r\n  public static isPolyfaceClosedByEdgePairing(source: Polyface): boolean {\r\n    const edges = new IndexedEdgeMatcher();\r\n    const visitor = source.createVisitor(1) as PolyfaceVisitor;\r\n    visitor.reset();\r\n    while (visitor.moveToNextFacet()) {\r\n      const numEdges = visitor.pointCount - 1;\r\n      for (let i = 0; i < numEdges; i++) {\r\n        edges.addEdge(visitor.clientPointIndex(i), visitor.clientPointIndex(i + 1), visitor.currentReadIndex());\r\n      }\r\n    }\r\n    const badClusters: SortableEdgeCluster[] = [];\r\n    edges.sortAndCollectClusters(undefined, badClusters, undefined, badClusters);\r\n    return badClusters.length === 0;\r\n  }\r\n  /**\r\n  * Test if the facets in `source` occur in perfectly mated pairs, as is required for a closed manifold volume.\r\n  * If not, extract the boundary edges as lines.\r\n  * @param source\r\n  */\r\n  public static boundaryEdges(source: Polyface, includeDanglers: boolean = true, includeMismatch: boolean = true, includeNull: boolean = true): CurveCollection | undefined {\r\n    const edges = new IndexedEdgeMatcher();\r\n    const visitor = source.createVisitor(1) as PolyfaceVisitor;\r\n    visitor.reset();\r\n    while (visitor.moveToNextFacet()) {\r\n      const numEdges = visitor.pointCount - 1;\r\n      for (let i = 0; i < numEdges; i++) {\r\n        edges.addEdge(visitor.clientPointIndex(i), visitor.clientPointIndex(i + 1), visitor.currentReadIndex());\r\n      }\r\n    }\r\n    const bad1: SortableEdgeCluster[] = [];\r\n    const bad2: SortableEdgeCluster[] = [];\r\n    const bad0: SortableEdgeCluster[] = [];\r\n    edges.sortAndCollectClusters(undefined, bad1, bad0, bad2);\r\n    const badList = [];\r\n    if (includeDanglers && bad1.length > 0)\r\n      badList.push(bad1);\r\n    if (includeMismatch && bad2.length > 0)\r\n      badList.push(bad2);\r\n    if (includeNull && bad0.length > 0)\r\n      badList.push(bad0);\r\n    if (badList.length === 0)\r\n      return undefined;\r\n    const result = new BagOfCurves();\r\n    for (const list of badList) {\r\n      for (const e of list) {\r\n        const e1 = e instanceof SortableEdge ? e : e[0];\r\n        const indexA = e1.vertexIndexA;\r\n        const indexB = e1.vertexIndexB;\r\n        const pointA = source.data.getPoint(indexA);\r\n        const pointB = source.data.getPoint(indexB);\r\n        if (pointA && pointB)\r\n          result.tryAddChild(LineSegment3d.create(pointA, pointB));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Find segments (within the linestring) which project to facets.\r\n   * * Announce each pair of linestring segment and on-facet segment through a callback.\r\n   * * Facets are ASSUMED to be convex and planar.\r\n   */\r\n  public static announceSweepLinestringToConvexPolyfaceXY(linestringPoints: GrowableXYZArray, polyface: Polyface,\r\n    announce: AnnounceDrapePanel): any {\r\n    const visitor = polyface.createVisitor(0);\r\n    const numLinestringPoints = linestringPoints.length;\r\n    const segmentPoint0 = Point3d.create();\r\n    const segmentPoint1 = Point3d.create();\r\n    const localSegmentPoint0 = Point3d.create();\r\n    const localSegmentPoint1 = Point3d.create();\r\n    const clipFractions = Segment1d.create(0, 1);\r\n    const localFrame = Transform.createIdentity();\r\n    let frame;\r\n    for (visitor.reset(); visitor.moveToNextFacet();) {\r\n      // For each triangle within the facet ...\r\n      for (let k1 = 1; k1 + 1 < visitor.point.length; k1++) {\r\n        frame = visitor.point.fillLocalXYTriangleFrame(0, k1, k1 + 1, localFrame);\r\n        if (frame) {\r\n          // For each stroke of the linestring ...\r\n          for (let i1 = 1; i1 < numLinestringPoints; i1++) {\r\n            linestringPoints.getPoint3dAtCheckedPointIndex(i1 - 1, segmentPoint0);\r\n            linestringPoints.getPoint3dAtCheckedPointIndex(i1, segmentPoint1);\r\n            frame.multiplyInversePoint3d(segmentPoint0, localSegmentPoint0);\r\n            frame.multiplyInversePoint3d(segmentPoint1, localSegmentPoint1);\r\n            clipFractions.set(0, 1);\r\n            /** (x,y,1-x-y) are barycentric coordinates in the triangle !!! */\r\n            if (clipFractions.clipBy01FunctionValuesPositive(localSegmentPoint0.x, localSegmentPoint1.x)\r\n              && clipFractions.clipBy01FunctionValuesPositive(localSegmentPoint0.y, localSegmentPoint1.y)\r\n              && clipFractions.clipBy01FunctionValuesPositive(\r\n                1 - localSegmentPoint0.x - localSegmentPoint0.y,\r\n                1 - localSegmentPoint1.x - localSegmentPoint1.y)) {\r\n              /* project the local segment point to the plane. */\r\n              const localClippedPointA = localSegmentPoint0.interpolate(clipFractions.x0, localSegmentPoint1);\r\n              const localClippedPointB = localSegmentPoint0.interpolate(clipFractions.x1, localSegmentPoint1);\r\n              const worldClippedPointA = localFrame.multiplyPoint3d(localClippedPointA)!;\r\n              const worldClippedPointB = localFrame.multiplyPoint3d(localClippedPointB)!;\r\n              const planePointA = localFrame.multiplyXYZ(localClippedPointA.x, localClippedPointA.y, 0.0)!;\r\n              const planePointB = localFrame.multiplyXYZ(localClippedPointB.x, localClippedPointB.y, 0.0)!;\r\n              const splitParameter = Geometry.inverseInterpolate01(localSegmentPoint0.z, localSegmentPoint1.z);\r\n              // emit 1 or 2 panels, oriented so panel normal is always to the left of the line.\r\n              if (splitParameter !== undefined && splitParameter > clipFractions.x0 && splitParameter < clipFractions.x1) {\r\n                const piercePointX = segmentPoint0.interpolate(splitParameter, segmentPoint1);\r\n                const piercePointY = piercePointX.clone();   // so points are distinct for the two triangle announcements.\r\n                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointA, piercePointX, planePointA], 2, 1);\r\n                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointB, piercePointY, planePointB], 1, 2);\r\n              } else if (localSegmentPoint0.z > 0) {  // segment is entirely above\r\n                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointA, worldClippedPointB, planePointB, planePointA], 3, 2);\r\n              } else // segment is entirely under\r\n                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointB, worldClippedPointA, planePointA, planePointB], 2, 3);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Search the facets for facet subsets that are connected with at least vertex contact.\r\n   * * Return array of arrays of facet indices.\r\n   */\r\n  public static partitionFacetIndicesByVertexConnectedComponent(polyface: Polyface | PolyfaceVisitor): number[][] {\r\n    if (polyface instanceof Polyface) {\r\n      return this.partitionFacetIndicesByVertexConnectedComponent(polyface.createVisitor(0));\r\n    }\r\n    // The polyface is really a visitor !!!\r\n    const context = new UnionFindContext(polyface.clientPolyface().data.point.length);\r\n    for (polyface.reset(); polyface.moveToNextFacet();) {\r\n      const firstVertexIndexOnThisFacet = polyface.pointIndex[0];\r\n      for (const vertexIndex of polyface.pointIndex)\r\n        context.mergeSubsets(firstVertexIndexOnThisFacet, vertexIndex);\r\n    }\r\n    const roots = context.collectRootIndices();\r\n    const facetsInComponent: number[][] = [];\r\n    const numRoots = roots.length;\r\n    for (let i = 0; i < numRoots; i++) {\r\n      facetsInComponent.push([]);\r\n    }\r\n    for (polyface.reset(); polyface.moveToNextFacet();) {\r\n      const firstVertexIndexOnThisFacet = polyface.pointIndex[0];\r\n      const rootVertexForThisFacet = context.findRoot(firstVertexIndexOnThisFacet);\r\n      for (let rootIndex = 0; rootIndex < numRoots; rootIndex++) {\r\n        if (roots[rootIndex] === rootVertexForThisFacet) {\r\n          facetsInComponent[rootIndex].push(polyface.currentReadIndex());\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return facetsInComponent;\r\n  }\r\n  /** Clone the facets in each partition to a separate polyface.\r\n   *\r\n   */\r\n  public static clonePartitions(polyface: Polyface | PolyfaceVisitor, partitions: number[][]): Polyface[] {\r\n    if (polyface instanceof Polyface) {\r\n      return this.clonePartitions(polyface.createVisitor(0), partitions);\r\n    }\r\n    polyface.setNumWrap(0);\r\n    const polyfaces: Polyface[] = [];\r\n    const options = StrokeOptions.createForFacets();\r\n    options.needNormals = polyface.normal !== undefined;\r\n    options.needParams = polyface.param !== undefined;\r\n    options.needColors = polyface.color !== undefined;\r\n    options.needTwoSided = polyface.twoSided;\r\n    for (const partition of partitions) {\r\n      const builder = PolyfaceBuilder.create(options);\r\n      polyface.reset();\r\n      for (const facetIndex of partition) {\r\n        polyface.moveToReadIndex(facetIndex);\r\n        builder.addFacetFromVisitor(polyface);\r\n      }\r\n      polyfaces.push(builder.claimPolyface(true));\r\n    }\r\n    return polyfaces;\r\n  }\r\n\r\n  /** Search the facets for facet subsets that are connected with at least edge contact.\r\n   * * Return array of arrays of facet indices.\r\n   */\r\n  public static partitionFacetIndicesByEdgeConnectedComponent(polyface: Polyface | PolyfaceVisitor): number[][] {\r\n    if (polyface instanceof Polyface) {\r\n      return this.partitionFacetIndicesByEdgeConnectedComponent(polyface.createVisitor(0));\r\n    }\r\n    polyface.setNumWrap(1);\r\n    const matcher = new IndexedEdgeMatcher();\r\n    polyface.reset();\r\n    let numFacets = 0;\r\n    while (polyface.moveToNextFacet()) {\r\n      const numEdges = polyface.pointCount - 1;\r\n      numFacets++;\r\n      for (let i = 0; i < numEdges; i++) {\r\n        matcher.addEdge(polyface.clientPointIndex(i), polyface.clientPointIndex(i + 1), polyface.currentReadIndex());\r\n      }\r\n    }\r\n    const allEdges: SortableEdgeCluster[] = [];\r\n    matcher.sortAndCollectClusters(allEdges, allEdges, allEdges, allEdges);\r\n    const context = new UnionFindContext(numFacets);\r\n    for (const cluster of allEdges) {\r\n      if (cluster instanceof SortableEdge) {\r\n        // this edge does not connect anywhere.  Ignore it!!\r\n      } else {\r\n        const edge0 = cluster[0];\r\n        for (let i = 1; i < cluster.length; i++)\r\n          context.mergeSubsets(edge0.facetIndex, cluster[i].facetIndex);\r\n      }\r\n    }\r\n\r\n    const roots = context.collectRootIndices();\r\n    const facetsInComponent: number[][] = [];\r\n    const numRoots = roots.length;\r\n    for (let i = 0; i < numRoots; i++) {\r\n      facetsInComponent.push([]);\r\n    }\r\n\r\n    for (let facetIndex = 0; facetIndex < numFacets; facetIndex++) {\r\n      const rootOfFacet = context.findRoot(facetIndex);\r\n      for (let rootIndex = 0; rootIndex < numRoots; rootIndex++) {\r\n        if (roots[rootIndex] === rootOfFacet) {\r\n          facetsInComponent[rootIndex].push(facetIndex);\r\n          break;\r\n        }\r\n      }\r\n    }\r\n    return facetsInComponent;\r\n  }\r\n  /** Find segments (within the linestring) which project to facets.\r\n   * * Assemble each segment pair as a facet in a new polyface\r\n   * * Facets are ASSUMED to be convex and planar.\r\n   */\r\n  public static sweepLinestringToFacetsXYreturnSweptFacets(linestringPoints: GrowableXYZArray, polyface: Polyface): Polyface {\r\n    const builder = PolyfaceBuilder.create();\r\n    this.announceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface,\r\n      (_linestring: GrowableXYZArray, _segmentIndex: number,\r\n        _polyface: Polyface, _facetIndex: number, points: Point3d[]) => {\r\n        if (points.length === 4)\r\n          builder.addQuadFacet(points);\r\n        else if (points.length === 3)\r\n          builder.addTriangleFacet(points);\r\n\r\n      });\r\n    return builder.claimPolyface(true);\r\n  }\r\n  /** Find segments (within the linestring) which project to facets.\r\n   * * Return collected line segments\r\n   */\r\n  public static sweepLinestringToFacetsXYReturnLines(linestringPoints: GrowableXYZArray, polyface: Polyface): LineSegment3d[] {\r\n    const drapeGeometry: LineSegment3d[] = [];\r\n    this.announceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface,\r\n      (_linestring: GrowableXYZArray, _segmentIndex: number,\r\n        _polyface: Polyface, _facetIndex: number, points: Point3d[], indexA: number, indexB: number) => {\r\n        drapeGeometry.push(LineSegment3d.create(points[indexA], points[indexB]));\r\n      });\r\n    return drapeGeometry;\r\n  }\r\n\r\n  /** Find segments (within the linestring) which project to facets.\r\n   * * Return chains.\r\n   */\r\n  public static sweepLinestringToFacetsXYReturnChains(linestringPoints: GrowableXYZArray, polyface: Polyface): LineString3d[] {\r\n    const chainContext = ChainMergeContext.create();\r\n\r\n    this.announceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface,\r\n      (_linestring: GrowableXYZArray, _segmentIndex: number,\r\n        _polyface: Polyface, _facetIndex: number, points: Point3d[], indexA: number, indexB: number) => {\r\n        chainContext.addSegment(points[indexA], points[indexB]);\r\n      });\r\n    chainContext.clusterAndMergeVerticesXYZ();\r\n    return chainContext.collectMaximalChains();\r\n  }\r\n\r\n  /** Find segments (within the linestring) which project to facets.\r\n   * * Return chains.\r\n   */\r\n  public static collectRangeLengthData(polyface: Polyface | PolyfaceVisitor): RangeLengthData {\r\n    if (polyface instanceof Polyface) {\r\n      return this.collectRangeLengthData(polyface.createVisitor(0));\r\n    }\r\n    const rangeData = new RangeLengthData();\r\n    // polyface is a visitor ...\r\n    for (polyface.reset(); polyface.moveToNextFacet();)\r\n      rangeData.accumulateGrowableXYZArrayRange(polyface.point);\r\n    return rangeData;\r\n  }\r\n\r\n  /** Clone the facets, inserting vertices (within edges) where points not part of each facet's vertex indices impinge within edges.\r\n   *\r\n   */\r\n  public static cloneWithTVertexFixup(polyface: Polyface): Polyface {\r\n    const oldFacetVisitor = polyface.createVisitor(1);  // This is to visit the existing facets.\r\n    const newFacetVisitor = polyface.createVisitor(0); // This is to build the new facets.\r\n    const rangeSearcher = XYPointBuckets.create(polyface.data.point, 30)!;\r\n    const builder = PolyfaceBuilder.create();\r\n    const edgeRange = Range3d.createNull();\r\n    const point0 = Point3d.create();\r\n    const point1 = Point3d.create();\r\n    const spacePoint = Point3d.create();\r\n    const segment = LineSegment3d.create(point0, point1);\r\n\r\n    for (oldFacetVisitor.reset(); oldFacetVisitor.moveToNextFacet();) {\r\n      newFacetVisitor.clearArrays();\r\n      for (let i = 0; i + 1 < oldFacetVisitor.point.length; i++) {\r\n        // each base vertex is part of the result ...\r\n        oldFacetVisitor.point.getPoint3dAtUncheckedPointIndex(i, point0);\r\n        oldFacetVisitor.point.getPoint3dAtUncheckedPointIndex(i + 1, point1);\r\n        newFacetVisitor.pushDataFrom(oldFacetVisitor, i);\r\n        edgeRange.setNull();\r\n        LineSegment3d.create(point0, point1, segment);\r\n        let detailArray: CurveLocationDetail[] | undefined;\r\n        edgeRange.extend(point0);\r\n        edgeRange.extend(point1);\r\n        rangeSearcher.announcePointsInRange(edgeRange, (index: number, _x: number, _y: number, _z: number) => {\r\n          // x,y,z has x,y within the range of the search ... test for exact on (in full 3d!)\r\n          polyface.data.point.getPoint3dAtUncheckedPointIndex(index, spacePoint);\r\n          const detail = segment.closestPoint(spacePoint, false);\r\n          if (undefined !== detail) {\r\n            if (detail.fraction >= 0.0 && detail.fraction < 1.0 && !detail.point.isAlmostEqual(point0) && !detail.point.isAlmostEqual(point1)) {\r\n              if (detailArray === undefined)\r\n                detailArray = [];\r\n              detail.a = index;\r\n              detailArray.push(detail);\r\n            }\r\n          }\r\n          return true;\r\n        });\r\n        if (detailArray !== undefined) {\r\n          detailArray.sort((a: CurveLocationDetail, b: CurveLocationDetail) => (a.fraction - b.fraction));\r\n          for (const d of detailArray) {\r\n            newFacetVisitor.pushInterpolatedDataFrom(oldFacetVisitor, i, d.fraction, i + 1);\r\n          }\r\n        }\r\n      }\r\n      builder.addFacetFromGrowableArrays(newFacetVisitor.point, newFacetVisitor.normal, newFacetVisitor.param, newFacetVisitor.color);\r\n    }\r\n\r\n    return builder.claimPolyface();\r\n  }\r\n\r\n  /** Clone the facets, inserting removing points that are simply within colinear edges.\r\n   *\r\n   */\r\n  public static cloneWithColinearEdgeFixup(polyface: Polyface): Polyface {\r\n    const oldFacetVisitor = polyface.createVisitor(2);  // This is to visit the existing facets.\r\n    const newFacetVisitor = polyface.createVisitor(0); // This is to build the new facets.\r\n    const builder = PolyfaceBuilder.create();\r\n    const vector01 = Vector3d.create();\r\n    const vector12 = Vector3d.create();\r\n    const numPoint = polyface.data.point.length;\r\n    const pointState = new Int32Array(numPoint);\r\n    // FIRST PASS -- in each sector of each facet, determine if the sector has colinear incoming and outgoing vectors.\r\n    //   Mark each point as\r\n    //  0 unvisited\r\n    // -1 incident to a non-colinear sector\r\n    //  n incident to n colinear sectors\r\n    for (oldFacetVisitor.reset(); oldFacetVisitor.moveToNextFacet();) {\r\n      for (let i = 0; i + 2 < oldFacetVisitor.point.length; i++) {\r\n        // each base vertex is part of the result ...\r\n        oldFacetVisitor.point.vectorIndexIndex(i, i + 1, vector01);\r\n        oldFacetVisitor.point.vectorIndexIndex(i + 1, i + 2, vector12);\r\n        const pointIndex = oldFacetVisitor.clientPointIndex(i + 1);\r\n        if (pointState[pointIndex] >= 0) {\r\n          const theta = vector01.angleTo(vector12);\r\n          if (theta.isAlmostZero) {\r\n            pointState[pointIndex]++;\r\n          } else {\r\n            pointState[pointIndex] = -1;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    // SECOND PASS -- make copies, omitting references to points at colinear sectors\r\n    for (oldFacetVisitor.reset(); oldFacetVisitor.moveToNextFacet();) {\r\n      newFacetVisitor.clearArrays();\r\n      for (let i = 0; i + 2 < oldFacetVisitor.point.length; i++) {\r\n        const pointIndex = oldFacetVisitor.clientPointIndex(i);\r\n        if (pointState[pointIndex] < 0) {\r\n          newFacetVisitor.pushDataFrom(oldFacetVisitor, i);\r\n        }\r\n      }\r\n      if (newFacetVisitor.point.length > 2)\r\n        builder.addFacetFromGrowableArrays(newFacetVisitor.point, newFacetVisitor.normal, newFacetVisitor.param, newFacetVisitor.color);\r\n    }\r\n    return builder.claimPolyface();\r\n  }\r\n}\r\n\r\n/** Announce the points on a drape panel.\r\n * * The first two points in the array are always along the draped line segment.\r\n * * The last two are always on the facet.\r\n * * If there are 4 points, those two pairs are distinct, i.e. both segment points are to the same side of the facet.\r\n * * If there are 3 points, those two pairs share an on-facet point.\r\n * * The panel is ordered so the outward normal is to the right of the draped segment.\r\n * @param indexAOnFacet index (in points) of the point that is the first facet point for moving forward along the linestring\r\n * @param indexBOnFacet index (in points) of the point that is the second facet point for moving forward along the linestring\r\n * @public\r\n */\r\nexport type AnnounceDrapePanel = (linestring: GrowableXYZArray, segmentIndex: number,\r\n  polyface: Polyface, facetIndex: number, points: Point3d[], indexAOnFacet: number, indexBOnFacet: number) => any;\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { UsageSums } from \"../numerics/UsageSums\";\r\n/**\r\n * Accumulated data for x,y,z length statistics in ranges.\r\n * * Usage pattern:\r\n *   * create a enw RangeLengthData:\r\n *      * `myData = new RangeLengthData ();`\r\n *   * announce ranges to be accumulated:\r\n *     * (many times)  `myData.accumulateRowableXYZArrayRange (points);\r\n *   * access data in public members:\r\n *     * `myData.range` -- the composite range.\r\n *     * `myData.xLength`, `myData.yLength`, `myData.zLength` -- mean, minMax, count, and standardDeviation of range lengths in x,y,z directions.\r\n * @public\r\n */\r\nexport class RangeLengthData {\r\n  /** Overall range of all data observed by `accumulate` methods. */\r\n  public range: Range3d;\r\n  /** */\r\n  public xSums: UsageSums;\r\n  public ySums: UsageSums;\r\n  public zSums: UsageSums;\r\n  public constructor() {\r\n    this.range = Range3d.createNull();\r\n    this.xSums = new UsageSums();\r\n    this.ySums = new UsageSums();\r\n    this.zSums = new UsageSums();\r\n    this._workRange = Range3d.createNull();\r\n  }\r\n  private _workRange: Range3d;\r\n  /** Extend the range and length sums by the range of points in an array. */\r\n  public accumulateGrowableXYZArrayRange(points: GrowableXYZArray) {\r\n    points.setRange(this._workRange);\r\n    this.range.extendRange(this._workRange);\r\n    this.xSums.accumulate(this._workRange.xLength());\r\n    this.ySums.accumulate(this._workRange.yLength());\r\n    this.zSums.accumulate(this._workRange.zLength());\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\r\nimport { BarycentricTriangle } from \"../geometry3d/BarycentricTriangle\";\r\n\r\n/** @module Polyface */\r\n/**\r\n * `TriangleCandidate` is a `BarycentricTriangle` with additional application-specific label data:\r\n * * `quality` = numeric indicator of quality (e.g. aspect ratio of this triangle or a combination with other triangles)\r\n * * `isValid` = boolean flag.\r\n * * `id` = application specific identifier\r\n * @internal\r\n */\r\nexport class TriangleCandidate extends BarycentricTriangle {\r\n  private _quality: number;\r\n  private _isValid: boolean;\r\n  public id: number;\r\n  private constructor(point0: Point3d, point1: Point3d, point2: Point3d, id: number, quality: number, isValid: boolean) {\r\n    super(point0, point1, point2);\r\n    this._isValid = isValid;\r\n    this._quality = quality;\r\n    this.id = id;\r\n  }\r\n  /**\r\n   * Copy all coordinate and label data from `other` to this.\r\n   * @param other source triangle\r\n   */\r\n  public setFrom(other: TriangleCandidate): TriangleCandidate {\r\n    super.setFrom(other);\r\n    this._isValid = other._isValid;\r\n    this._quality = other._quality;\r\n    this.id = other.id;\r\n    return this;\r\n  }\r\n\r\n  /** Create (always) a TriangleCandidate.\r\n   * * Access points from multiple `IndexedXYZCollection`\r\n   * * mark invalid if any indices are invalid.\r\n   */\r\n  public static createFromIndexedXYZ(source0: IndexedXYZCollection, index0: number, source1: IndexedXYZCollection, index1: number, source2: IndexedXYZCollection, index2: number, id: number, result?: TriangleCandidate): TriangleCandidate {\r\n    if (!result)\r\n      result = new TriangleCandidate(Point3d.create(), Point3d.create(), Point3d.create(), id, 0.0, false);\r\n    result.id = id;\r\n    let numValid = 0;\r\n    if (undefined !== source0.getPoint3dAtCheckedPointIndex(index0, result.points[0]))\r\n      numValid++;\r\n    if (undefined !== source1.getPoint3dAtCheckedPointIndex(index1, result.points[1]))\r\n      numValid++;\r\n    if (undefined !== source2.getPoint3dAtCheckedPointIndex(index2, result.points[2]))\r\n      numValid++;\r\n    if (numValid === 3)\r\n      result.updateAspectRatio();\r\n    else\r\n      result.markInvalid();\r\n    return result;\r\n  }\r\n/** (property) return the validity flag. */\r\n  public get isValid(): boolean { return this._isValid; }\r\n  /**\r\n   * * Mark this triangle invalid.\r\n   * * optionally set aspect ratio.\r\n   * * points are not changed\r\n   * @param aspectRatio\r\n   */\r\n  public markInvalid(quality?: number) {\r\n    this._isValid = false;\r\n    if (quality !== undefined)\r\n      this._quality = quality;\r\n  }\r\n  /**\r\n   * * Recompute the aspect ratio.\r\n   * * Mark invalid if aspect ratio is 0 or negative.\r\n   */\r\n  public updateAspectRatio() {\r\n    this._quality = super.aspectRatio;\r\n    this._isValid = this._quality > 0.0;\r\n  }\r\n  /**\r\n   * Clone all coordinate and label data.\r\n   * @param result optional preallocated `TriangleCandidate`\r\n   */\r\n  public clone(result?: TriangleCandidate): TriangleCandidate {\r\n    if (result)\r\n      return result.setFrom(this);\r\n    return new TriangleCandidate(this.points[0].clone(), this.points[1].clone(), this.points[2].clone(), this.id, this._quality, this._isValid);\r\n  }\r\n  /**\r\n   * Return a `TriangleCandidate` with\r\n   *  * coordinate data and labels from `candidateA`\r\n   *  * LOWER quality of the two candidates.\r\n   *  * quality reduced by 1 if triangles have opposing normals (negative dot product of the two normals)\r\n   * @param candidateA candidate known to be valid\r\n   * @param candidateB candidate that may by valid\r\n   * @param result copy of candidate A, but if candidateB is valid the result aspect ratio is reduced (a) to the minimum of the two ratios and then (b) reduced by 1 if orientations clash.\r\n   */\r\n  public static copyWithLowerQuality(candidateA: TriangleCandidate, candidateB: TriangleCandidate, result?: TriangleCandidate): TriangleCandidate {\r\n    result = candidateA.clone(result);\r\n    if (candidateB.isValid) {\r\n      const dot = candidateA.dotProductOfCrossProductsFromOrigin(candidateB);\r\n      result._quality = Geometry.minXY(candidateA.aspectRatio, candidateB.aspectRatio);\r\n      if (dot < 0.0)\r\n        result._quality -= 1.0;\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * choose better aspect ratio of triangle, other.\r\n   * @param triangle known valid triangle, to be updated\r\n   * @param other candidate replacement\r\n   */\r\n  public static updateIfOtherHasHigherQuality(triangle: TriangleCandidate, other: TriangleCandidate) {\r\n    if (other.isValid && other._quality > triangle._quality)\r\n      triangle.setFrom(other);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Range2d, Range3d } from \"../../geometry3d/Range\";\r\nimport { LowAndHighXY } from \"../../geometry3d/XYZProps\";\r\nimport { LinearSearchRange2dArray } from \"./LinearSearchRange2dArray\";\r\n\r\nexport type OptionalLinearSearchRange2dArray<T> = LinearSearchRange2dArray<T> | undefined;\r\n/**\r\n * A GriddedRaggedRange2dSet is\r\n * * A doubly dimensioned array of LinearSearchRange2dArray\r\n * * Each entry represents a block in a uniform grid within the master range of the GriddedRaggedRange2dSet.\r\n * * Member ranges are noted in the grid block containing the range's lower left corner.\r\n * * Member ranges larger than twice the grid size are rejected by the insert method.\r\n * * Hence a search involving a point in grid block (i,j) must examine ranges in grid blocks left and below, i.e. (i-1,j-1), (i-1,j), (i,j-1)\r\n * @internal\r\n */\r\nexport class GriddedRaggedRange2dSet<T> {\r\n  private _range: Range2d;\r\n  private _numXEdge: number;\r\n  private _numYEdge: number;\r\n  /** Each grid block is a simple linear search set\r\n   *\r\n   */\r\n  private _rangesInBlock: Array<Array<OptionalLinearSearchRange2dArray<T>>>;\r\n  private constructor(range: Range2d, numXEdge: number, numYEdge: number) {\r\n    this._range = range;\r\n    this._numXEdge = numXEdge;\r\n    this._numYEdge = numYEdge;\r\n    this._rangesInBlock = [];\r\n    for (let j = 0; j < this._numYEdge; j++) {\r\n      const thisRow: Array<OptionalLinearSearchRange2dArray<T>> = [];\r\n      for (let i = 0; i < this._numXEdge; i++) {\r\n        thisRow.push(undefined);\r\n      }\r\n      this._rangesInBlock.push(thisRow);\r\n    }\r\n  }\r\n  /**\r\n   * Create an (empty) set of ranges.\r\n   * @param range\r\n   * @param numXEdge\r\n   * @param numYEdge\r\n   */\r\n  public static create<T>(range: Range2d, numXEdge: number, numYEdge: number): GriddedRaggedRange2dSet<T> | undefined {\r\n    if (numXEdge < 1 || numYEdge < 1 || range.isNull || range.isSinglePoint)\r\n      return undefined;\r\n    return new GriddedRaggedRange2dSet(range.clone(), numXEdge, numYEdge);\r\n  }\r\n  private xIndex(x: number): number {\r\n    const fraction = (x - this._range.low.x) / (this._range.high.x - this._range.low.x);\r\n    return Math.floor(fraction * this._numXEdge);\r\n  }\r\n  private yIndex(y: number): number {\r\n    const fraction = (y - this._range.low.y) / (this._range.high.y - this._range.low.y);\r\n    return Math.floor(fraction * this._numXEdge);\r\n  }\r\n  private getBlock(i: number, j: number): LinearSearchRange2dArray<T> | undefined {\r\n    if (i >= 0 && i < this._numXEdge && j >= 0 && j < this._numYEdge) {\r\n      if (!this._rangesInBlock[j][i])\r\n        this._rangesInBlock[j][i] = new LinearSearchRange2dArray();\r\n      return this._rangesInBlock[j][i];\r\n    }\r\n    return undefined;\r\n  }\r\n  /** If possible, insert a range into the set.\r\n   * * Decline to insert (and return false) if\r\n   *   * range is null\r\n   *   * range is not completely contained in the overall range of this set.\r\n   *   * range x or y extent is larger than 2 grid blocks.\r\n   */\r\n  public conditionalInsert(range: Range2d | Range3d, tag: T): boolean {\r\n    if (range.isNull)\r\n      return false;\r\n    if (!this._range.containsRange(range))\r\n      return false;\r\n    const xIndex0 = this.xIndex(range.low.x);\r\n    const xIndex1 = this.xIndex(range.high.x);\r\n    const yIndex0 = this.yIndex(range.low.y);\r\n    const yIndex1 = this.yIndex(range.high.y);\r\n    if (!(xIndex0 === xIndex1 || xIndex0 + 1 === xIndex1))\r\n      return false;\r\n    if (!(yIndex0 === yIndex1 || yIndex0 + 1 === yIndex1))\r\n      return false;\r\n    const rangesInBlock = this.getBlock(xIndex0, yIndex0);\r\n    if (rangesInBlock) {\r\n      rangesInBlock.addRange(range, tag);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * * Search a single block\r\n   * * Pass each range and tag to handler\r\n   * * and return false if bad cell or if handler returns false.\r\n   * @param testRange search range.\r\n   * @param handler function to receive range and tag hits.\r\n   * @return false if search terminated by handler.  Return true if no handler returned false.\r\n   */\r\n  private searchXYInIndexedBlock(i: number, j: number, x: number, y: number, handler: (range: Range2d, tag: T) => boolean): boolean {\r\n    const rangesInBlock = this.getBlock(i, j);\r\n    if (!rangesInBlock)\r\n      return true;\r\n    return rangesInBlock.searchXY(x, y, handler);\r\n  }\r\n  /**\r\n   * * Search a single block\r\n   * * Pass each range and tag to handler\r\n   * * and return false if bad cell or if handler returns false.\r\n   * @param testRange search range.\r\n   * @param handler function to receive range and tag hits.\r\n   * @return false if search terminated by handler.  Return true if no handler returned false.\r\n   */\r\n  private searchRange2dInIndexedBlock(i: number, j: number, testRange: LowAndHighXY, handler: (range: Range2d, tag: T) => boolean): boolean {\r\n    const rangesInBlock = this.getBlock(i, j);\r\n    if (!rangesInBlock)\r\n      return true;\r\n    return rangesInBlock.searchRange2d(testRange, handler);\r\n  }\r\n  /**\r\n   * * Search for ranges containing testRange\r\n   * * Pass each range and tag to handler\r\n   * * terminate search if handler returns false.\r\n   * @param testRange search range.\r\n   * @param handler function to receive range and tag hits.\r\n   * @return false if search terminated by handler.  Return true if no handler returned false.\r\n   */\r\n  public searchXY(x: number, y: number, handler: (range: Range2d, tag: T) => boolean): boolean {\r\n    const i = this.xIndex(x);\r\n    const j = this.yIndex(y);\r\n    return this.searchXYInIndexedBlock(i, j, x, y, handler)\r\n      && this.searchXYInIndexedBlock(i - 1, j, x, y, handler)\r\n      && this.searchXYInIndexedBlock(i, j - 1, x, y, handler)\r\n      && this.searchXYInIndexedBlock(i - 1, j - 1, x, y, handler);\r\n  }\r\n  /**\r\n   * * Search for ranges overlapping testRange\r\n   * * Pass each range and tag to handler\r\n   * * terminate search if handler returns false.\r\n   * @param testRange search range.\r\n   * @param handler function to receive range and tag hits.\r\n   * @return false if search terminated by handler.  Return true if no handler returned false.\r\n   */\r\n  public searchRange2d(testRange: LowAndHighXY, handler: (range: Range2d, tag: T) => boolean): boolean {\r\n    const xIndex0 = this.xIndex(testRange.low.x) - 1;\r\n    const xIndex1 = this.xIndex(testRange.high.x);\r\n    const yIndex0 = this.yIndex(testRange.low.y) - 1;\r\n    const yIndex1 = this.yIndex(testRange.high.y);\r\n    for (let i = xIndex0; i <= xIndex1; i++) {\r\n      for (let j = yIndex0; j <= yIndex1; j++) {\r\n        if (!this.searchRange2dInIndexedBlock(i, j, testRange, handler))\r\n          return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  public visitChildren(initialDepth: number, handler: (depth: number, child: LinearSearchRange2dArray<T>) => void) {\r\n    for (const row of this._rangesInBlock) {\r\n      for (const block of row) {\r\n        if (block)\r\n          handler(initialDepth, block);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Range2d, Range3d } from \"../../geometry3d/Range\";\r\nimport { LowAndHighXY } from \"../../geometry3d/XYZProps\";\r\nimport { LinearSearchRange2dArray } from \"./LinearSearchRange2dArray\";\r\nimport { GriddedRaggedRange2dSet } from \"./GriddedRaggedRange2dSet\";\r\n/**\r\n * Use GriddedRaggedRange2dSetWithOverflow for searching among many ranges for which\r\n * * Most ranges are of somewhat consistent size.\r\n * * A modest number of oversizes.\r\n * * Maintain the smallish ones in a GriddedRaggedRange2dSet.\r\n * * Maintain the overflows in a LinearSearchRange2dArray\r\n * @internal\r\n */\r\nexport class GriddedRaggedRange2dSetWithOverflow<T> {\r\n  private _gridSet: GriddedRaggedRange2dSet<T>;\r\n  private _overflowSet: LinearSearchRange2dArray<T>;\r\n  private constructor(gridSet: GriddedRaggedRange2dSet<T>, overflowSet: LinearSearchRange2dArray<T>) {\r\n    this._gridSet = gridSet;\r\n    this._overflowSet = overflowSet;\r\n  }\r\n  /**\r\n   * Create an (empty) set of ranges.\r\n   * @param range\r\n   * @param numXEdge\r\n   * @param numYEdge\r\n   */\r\n  public static create<T>(range: Range2d, numXEdge: number, numYEdge: number): GriddedRaggedRange2dSetWithOverflow<T> | undefined {\r\n    const grids = GriddedRaggedRange2dSet.create<T>(range.clone(), numXEdge, numYEdge);\r\n    if (grids)\r\n      return new GriddedRaggedRange2dSetWithOverflow<T>(grids, new LinearSearchRange2dArray<T>());\r\n    return undefined;\r\n  }\r\n  /**\r\n   * * Search for ranges containing testRange\r\n   * * Pass each range and tag to handler\r\n   * * terminate search if handler returns false.\r\n   * @param testRange search range.\r\n   * @param handler function to receive range and tag hits.\r\n   * @return false if search terminated by handler.  Return true if no handler returned false.\r\n   */\r\n  public searchXY(x: number, y: number, handler: (range: Range2d, tag: T) => boolean): boolean {\r\n    return this._gridSet.searchXY(x, y, handler) && this._overflowSet.searchXY(x, y, handler);\r\n  }\r\n  /**\r\n   * * Search for ranges overlapping testRange\r\n   * * Pass each range and tag to handler\r\n   * * terminate search if handler returns false.\r\n   * @param testRange search range.\r\n   * @param handler function to receive range and tag hits.\r\n   * @return false if search terminated by handler.  Return true if no handler returned false.\r\n   */\r\n  public searchRange2d(testRange: LowAndHighXY, handler: (range: Range2d, tag: T) => boolean): boolean {\r\n    return this._gridSet.searchRange2d(testRange, handler) && this._overflowSet.searchRange2d(testRange, handler);\r\n  }\r\n  /** If possible, insert a range into the set.\r\n   * * Decline to insert (and return false) if\r\n   *   * range is null\r\n   *   * range is not completely contained in the overall range of this set.\r\n   *   * range x or y extent is larger than 2 grid blocks.\r\n   */\r\n  public addRange(range: Range2d | Range3d, tag: T): void {\r\n    if (!range.isNull) {\r\n      if (!this._gridSet.conditionalInsert(range, tag))\r\n        this._overflowSet.addRange(range, tag);\r\n    }\r\n  }\r\n  public visitChildren(initialDepth: number, handler: (depth: number, child: LinearSearchRange2dArray<T>) => void) {\r\n    handler(initialDepth, this._overflowSet);\r\n    this._gridSet.visitChildren(initialDepth + 1, handler);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Range2d } from \"../../geometry3d/Range\";\r\nimport { LowAndHighXY } from \"../../geometry3d/XYZProps\";\r\nimport { Range2dSearchInterface } from \"./Range2dSearchInterface\";\r\n/**\r\n * * Array of Range2d\r\n * * user data tag attached to each range via cast as (any).userTag.\r\n * * Search operations are simple linear.\r\n * * This class can be used directly for \"smallish\" range sets, or as the leaf level of hierarchical structures for larger range sets.\r\n * *\r\n * @internal\r\n */\r\nexport class LinearSearchRange2dArray<T> implements Range2dSearchInterface<T> {\r\n  private _rangeArray: Range2d[];\r\n  private _isDirty: boolean;\r\n  private _compositeRange: Range2d;\r\n  public constructor() {\r\n    this._rangeArray = [];\r\n    this._isDirty = false;\r\n    this._compositeRange = Range2d.createNull();\r\n  }\r\n  // TODO: build search structure\r\n  private updateForSearch() {\r\n    this._isDirty = false;\r\n  }\r\n  /** Return the overall range of all member ranges. */\r\n  public totalRange(result?: Range2d): Range2d {\r\n    result = result ? result : Range2d.createNull();\r\n    return this._compositeRange.clone(result);\r\n  }\r\n  /** Add a range to the search set. */\r\n  public addRange(range: LowAndHighXY, tag: T) {\r\n    this._isDirty = true;\r\n    const myRange = Range2d.createNull();\r\n    (myRange as any).tag = tag;\r\n    myRange.extendXY(range.low.x, range.low.y);\r\n    myRange.extendXY(range.high.x, range.high.y);\r\n    this._compositeRange.extendRange(myRange);\r\n    this._rangeArray.push(myRange);\r\n  }\r\n  /**\r\n   * * Search for ranges containing testRange\r\n   * * Pass each range and tag to handler\r\n   * * terminate search if handler returns false.\r\n   * @param testRange search range.\r\n   * @param handler function to receive range and tag hits.\r\n   * @return false if search terminated by handler.  Return true if no handler returned false.\r\n   */\r\n  public searchXY(x: number, y: number, handler: (range: Range2d, tag: T) => boolean): boolean {\r\n    if (this._isDirty)\r\n      this.updateForSearch();\r\n    // NEEDS WORK: Linear search here -- do better!\r\n    for (const candidate of this._rangeArray) {\r\n      if (candidate.containsXY(x, y))\r\n        if (!handler(candidate, (candidate as any).tag))\r\n          return false;\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * * Search for ranges overlapping testRange\r\n   * * Pass each range and tag to handler\r\n   * * terminate search if handler returns false.\r\n   * @param testRange search range.\r\n   * @param handler function to receive range and tag hits.\r\n   * @return false if search terminated by handler.  Return true if no handler returned false.\r\n   */\r\n  public searchRange2d(testRange: LowAndHighXY, handler: (range: Range2d, tag: T) => boolean): boolean {\r\n    if (this._isDirty)\r\n      this.updateForSearch();\r\n    for (const candidate of this._rangeArray) {\r\n      if (candidate.intersectsRange(testRange))\r\n        if (!handler(candidate, (candidate as any).tag))\r\n          return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Range2d } from \"../../geometry3d/Range\";\r\nimport { RangeLengthData } from \"../RangeLengthData\";\r\nimport { UsageSums } from \"../../numerics/UsageSums\";\r\nimport { Geometry } from \"../../Geometry\";\r\nimport { Range2dSearchInterface } from \"./Range2dSearchInterface\";\r\nimport { GriddedRaggedRange2dSetWithOverflow } from \"./GriddedRaggedRange2dSetWithOverflow\";\r\nimport { LinearSearchRange2dArray } from \"./LinearSearchRange2dArray\";\r\n/** Class with static members to work with various range searchers. */\r\nexport class RangeSearch {\r\n  public static readonly smallCountLimit = 40;\r\n  /** Target size for grid block size divided by representative per-entry range size. */\r\n  public static readonly defaultRangesPerBlockEdge = 4;\r\n  /** the \"representative range size\"is the mean range size plus this number of standard deviations */\r\n  public static readonly defaultStandardDeviationAdjustment = 1.0;\r\n  /** Based on range count and distribution, return an object which can answer 2d range queries */\r\n  public static create2dSearcherForRangeLengthData<T>(rangeLengthData: RangeLengthData, rangesPerBlockEdge: number = RangeSearch.defaultRangesPerBlockEdge, standardDeviationAdjustment: number = RangeSearch.defaultStandardDeviationAdjustment): Range2dSearchInterface<T> | undefined {\r\n    // for smallish sets, just linear search  . . ..\r\n    if (rangeLengthData.xSums.count < RangeSearch.smallCountLimit)\r\n      return new LinearSearchRange2dArray();\r\n    const numXBlock = this.estimateGridBlockCount(rangeLengthData.range.xLength(), rangeLengthData.xSums, rangesPerBlockEdge, standardDeviationAdjustment);\r\n    const numYBlock = this.estimateGridBlockCount(rangeLengthData.range.yLength(), rangeLengthData.ySums, rangesPerBlockEdge, standardDeviationAdjustment);\r\n    if (numXBlock < 2 && numYBlock < 2)\r\n      return new LinearSearchRange2dArray();\r\n    return GriddedRaggedRange2dSetWithOverflow.create<T>(Range2d.createFrom(rangeLengthData.range), numXBlock, numYBlock);\r\n  }\r\n  /** Return the number of grid bocks (in one direction) for\r\n   * * The total range length in this direction\r\n   * * individual ranges whose count, mean and standard deviation are available in the sums.\r\n   * @param totalRange the total range being searched (in this direction)\r\n   * @param sums source for mean, count, and standard deviation of individual ranges\r\n   * @param rangesPerBlockEdge target ratio of edge length in search blocks divided by representative length of individual range edges\r\n   * @param standardDeviationAdjustment the number of standard deviations above the mean to be applied to convert mean to representative length.  Typically 0 to 1.\r\n   * @returns number of blocks in grid.\r\n   */\r\n  public static estimateGridBlockCount(totalLength: number, sums: UsageSums, rangesPerBlockEdge: number = RangeSearch.defaultRangesPerBlockEdge, standardDeviationAdjustment: number = RangeSearch.defaultStandardDeviationAdjustment): number {\r\n    if (sums.count < 1)\r\n      return 1;\r\n    const representativeRangeLength = rangesPerBlockEdge * (sums.mean + standardDeviationAdjustment * sums.standardDeviation);\r\n    const gridEdgeLength = Geometry.conditionalDivideFraction(totalLength, representativeRangeLength);\r\n    if (gridEdgeLength === undefined)\r\n      return 1;\r\n    return Math.ceil(gridEdgeLength);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Range2d, Range3d } from \"../../geometry3d/Range\";\r\nimport { LowAndHighXY } from \"../../geometry3d/XYZProps\";\r\nimport { Geometry } from \"../../Geometry\";\r\nimport { IndexedXYZCollection } from \"../../geometry3d/IndexedXYZCollection\";\r\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\r\n/** Type for a value which may be either (a) undefined or (b) an array of type []. */\r\nexport type OptionalArray<T> = T[] | undefined;\r\n/**\r\n * Arrays of type T values distributed by xy position when entered.\r\n * @internal\r\n */\r\nexport class XYIndexGrid<T> {\r\n  private _range: Range2d;\r\n  private _numXEdge: number;\r\n  private _numYEdge: number;\r\n\r\n  private _data: Array<Array<OptionalArray<T>>>; // _indices[j][i][k] = index k value in row j block i\r\n\r\n  protected constructor(range: Range2d, numX: number, numY: number) {\r\n    this._range = range;\r\n    this._numXEdge = Math.max(numX, 1);\r\n    this._numYEdge = Math.max(numY, 1);\r\n    this._data = [];\r\n    for (let j = 0; j < numY; j++) {\r\n      const thisRow: Array<OptionalArray<T>> = [];\r\n      for (let i = 0; i < numX; i++) {\r\n        thisRow.push(undefined);\r\n      }\r\n      this._data.push(thisRow);\r\n    }\r\n  }\r\n  /** Return the number of x edges in the grid */\r\n  public get numXEdge(): number { return this._numXEdge; }\r\n  /** Return the number of y edges in the grid */\r\n  public get numYEdge(): number { return this._numYEdge; }\r\n\r\n  /** Return the `i` index of cells containing x coordinate */\r\n  public xIndex(x: number): number {\r\n    const fraction = (x - this._range.low.x) / (this._range.high.x - this._range.low.x);\r\n    const q = Math.floor(fraction * this._numXEdge);\r\n    if (q < 0)\r\n      return 0;\r\n    if (q > this._numXEdge - 1)\r\n      return this._numXEdge - 1;\r\n    return q;\r\n  }\r\n  /** Return the `j` index of cells containing x coordinate */\r\n  public yIndex(y: number): number {\r\n    const fraction = (y - this._range.low.y) / (this._range.high.y - this._range.low.y);\r\n    const q = Math.floor(fraction * this._numYEdge);\r\n    if (q < 0)\r\n      return 0;\r\n    if (q > this._numYEdge - 1)\r\n      return this._numYEdge - 1;\r\n    return q;\r\n  }\r\n  /**\r\n   * Construct an array with cells mapped to a range, with counts determined by estimated total count and target number of entries per cell.\r\n   * @param range\r\n   * @param totalEntries\r\n   * @param targetEntriesPerCell\r\n   */\r\n  public static createWithEstimatedCounts<T>(range: LowAndHighXY, totalEntries: number, targetEntriesPerCell: number): XYIndexGrid<T> | undefined {\r\n    if (range.low.x >= range.high.x || range.low.y >= range.high.y)\r\n      return undefined;\r\n    const range2d = Range2d.createXYXY(range.low.x, range.low.y, range.high.x, range.high.y);\r\n\r\n    const dx = range2d.xLength();\r\n    const dy = range2d.yLength();\r\n    // numX / numY = dX / dY  (numX,numY will be integers  . . .)\r\n    // numX = dX * numY / dY\r\n    let numX: number;\r\n    let numY: number;\r\n    if (dy > dx) {\r\n      numY = Math.ceil(Math.sqrt(dy * totalEntries / (targetEntriesPerCell * dx)));\r\n      numX = Math.ceil(totalEntries / numY);\r\n    } else {\r\n      numX = Math.ceil(Math.sqrt(dx * totalEntries / (targetEntriesPerCell * dy)));\r\n      numY = Math.ceil(totalEntries / (numX * targetEntriesPerCell));\r\n    }\r\n    return new XYIndexGrid(range2d, numX, numY);\r\n  }\r\n  /**\r\n   * Add (save) a new data value to the grid cell containing x,y\r\n   * @param x\r\n   * @param y\r\n   * @param value\r\n   */\r\n  public addDataAtXY(x: number, y: number, value: T) {\r\n    const i = this.xIndex(x);\r\n    const j = this.yIndex(y);\r\n    let dataJI = this._data[j][i];\r\n    if (!dataJI) {\r\n      dataJI = [];\r\n      this._data[j][i] = dataJI;\r\n    }\r\n    dataJI.push(value);\r\n    return;\r\n  }\r\n  /**\r\n   * Get the (reference to the possibly null array of) data values for the cell indicated by xy.\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public getDataAtXY(x: number, y: number): OptionalArray<T> {\r\n    const i = this.xIndex(x);\r\n    const j = this.yIndex(y);\r\n    return this._data[j][i];\r\n  }\r\n\r\n  /**\r\n   * Get the (reference to the possibly null array of) data values for the cell indicated by indices in the x and y direction\r\n   * @param xIndex\r\n   * @param yIndex\r\n   */\r\n  public getDataAtIndex(xIndex: number, yIndex: number): OptionalArray<T> {\r\n    if (xIndex < 0)\r\n      return undefined;\r\n    if (xIndex >= this._numXEdge)\r\n      return undefined;\r\n    if (yIndex < 0)\r\n      return undefined;\r\n    if (yIndex >= this._numYEdge)\r\n      return undefined;\r\n\r\n    return this._data[yIndex][xIndex];\r\n  }\r\n  /** Return true if (xIndex, yIndex) is a valid cell index. */\r\n  public isValidIndex(xIndex: number, yIndex: number): boolean {\r\n    if (xIndex < 0)\r\n      return false;\r\n    if (xIndex >= this._numXEdge)\r\n      return false;\r\n    if (yIndex < 0)\r\n      return false;\r\n    if (yIndex >= this._numYEdge)\r\n      return false;\r\n    return true;\r\n  }\r\n}\r\n/** Manage buckets of points for fast search.\r\n * @internal\r\n */\r\nexport class XYPointBuckets {\r\n  private _points: IndexedXYZCollection;\r\n  private _buckets: XYIndexGrid<number>;\r\n  /** Return the underlying grid with indices recorded by block */\r\n  public get indexGrid(): XYIndexGrid<number> { return this._buckets; }\r\n  private constructor(points: IndexedXYZCollection, buckets: XYIndexGrid<number>) {\r\n    this._points = points;\r\n    this._buckets = buckets;\r\n  }\r\n  /** Create an XYIndex grid with all indices of all `points` entered */\r\n  public static create(points: IndexedXYZCollection, targetPointsPerCell: number): XYPointBuckets | undefined {\r\n    const n = points.length;\r\n    if (points.length < 1)\r\n      return undefined;\r\n    const range = points.getRange();\r\n    range.expandInPlace(Geometry.smallMetricDistance * 1000.0);\r\n    const buckets = XYIndexGrid.createWithEstimatedCounts<number>(range, points.length, targetPointsPerCell);\r\n    if (buckets === undefined)\r\n      return undefined;\r\n    const result = new XYPointBuckets(points, buckets);\r\n    const point = Point3d.create();\r\n    for (let i = 0; i < n; i++) {\r\n      points.getPoint3dAtUncheckedPointIndex(i, point);\r\n      buckets.addDataAtXY(point.x, point.y, i);\r\n    }\r\n    return result;\r\n  }\r\n  /** call the `announce` function with the index and coordinates of all points in given range.\r\n   * * continue the search if `announce` returns true.\r\n   * * terminate the search if `announce` returns false;\r\n   */\r\n  public announcePointsInRange(range: Range2d | Range3d, announce: (index: number, x: number, y: number, z: number) => boolean) {\r\n    const i0 = this._buckets.xIndex(range.low.x);\r\n    const i1 = this._buckets.xIndex(range.high.x);\r\n    const j0 = this._buckets.yIndex(range.low.y);\r\n    const j1 = this._buckets.yIndex(range.high.y);\r\n    const n = this._points.length;\r\n    for (let i = i0; i <= i1; i++) {\r\n      for (let j = j0; j <= j1; j++) {\r\n        const candidates = this._buckets.getDataAtIndex(i, j);\r\n        if (candidates !== undefined) {\r\n          for (const k of candidates) {\r\n            if (k < n) {\r\n              const x = this._points.getXAtUncheckedPointIndex(k);\r\n              const y = this._points.getYAtUncheckedPointIndex(k);\r\n              const z = this._points.getZAtUncheckedPointIndex(k);\r\n              if (range.containsXY(x, y))\r\n                if (!announce(k, x, y, z))\r\n                  return;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Serialization */\r\n\r\n/* tslint:disable: object-literal-key-quotes */\r\n\r\n/**\r\n * Utilities to compare json objects by search through properties.\r\n * @internal\r\n */\r\nexport class DeepCompare {\r\n  /** Statistical accumulations during searchers. */\r\n  public typeCounts = {\r\n    \"numbers\": 0,\r\n    \"arrays\": 0,\r\n    \"functions\": 0,\r\n    \"objects\": 0,\r\n    \"strings\": 0,\r\n    \"booleans\": 0,\r\n    \"undefined\": 0,\r\n  };\r\n  /** Counts of property names encountered during various searches. */\r\n  public propertyCounts: { [key: string]: any } = {};\r\n  /** Array of error descriptions. */\r\n  public errorTracker: any[] = [];\r\n  /** relative tolerance for declaring numeric values equal. */\r\n  public numberRelTol: number;\r\n  public constructor(numberRelTol = 1.0e-12) { this.numberRelTol = numberRelTol; }\r\n\r\n  /** test if _a and _b are within tolerance.\r\n   * * If not, push error message to errorTracker.\r\n   */\r\npublic compareNumber(_a: number, _b: number) {\r\n    if (Math.abs(_b - _a) < this.numberRelTol * (1 + Math.abs(_a) + Math.abs(_b))) {\r\n      return this.announce(true);\r\n    } else {\r\n      this.errorTracker.unshift(_b);\r\n      this.errorTracker.unshift(_a);\r\n      this.errorTracker.unshift(\"In \" + this.errorTracker[this.errorTracker.length - 1] + \" property: Mismatched values\");\r\n      return this.announce(false);\r\n    }\r\n  }\r\n\r\n  private compareArray(a: any[], b: any[]) {\r\n    if (a.length !== b.length) {\r\n      const aCounter: { [key: string]: any } = {};\r\n      const bCounter: { [key: string]: any } = {};\r\n      // Append object to tracker that counts the properties of each array element (which is an object) in b, ONLY AT THIS LEVEL\r\n      for (const i of b) {\r\n        if (typeof i === \"object\" && typeof i !== \"function\" && !Array.isArray(i)) {\r\n          for (const property in i) {\r\n            if (i.hasOwnProperty(property)) {\r\n              // Add property to counter if not already there\r\n              if (!bCounter.hasOwnProperty(property))\r\n                bCounter[property] = 0;\r\n              bCounter[property]++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this.errorTracker.unshift(bCounter);\r\n      // Append object to tracker that counts the properties of each array element (which is an object) in a, ONLY AT THIS LEVEL\r\n      for (const i of a) {\r\n        if (typeof i === \"object\" && typeof i !== \"function\" && !Array.isArray(i)) {\r\n          for (const property in i) {\r\n            if (i.hasOwnProperty(property)) {\r\n              // Add property to counter if not already there\r\n              if (!aCounter.hasOwnProperty(property))\r\n                aCounter[property] = 0;\r\n              aCounter[property]++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this.errorTracker.unshift(aCounter);\r\n\r\n      this.errorTracker.unshift(\"Mismatched array lengths a: [\" + a.length + \"] b: [\" + b.length + \"]\");\r\n      return this.announce(false);\r\n    }\r\n    // Keep track of result for each element of array\r\n    let toReturn = true;\r\n    for (let i = 0; i < a.length; i++) {\r\n      toReturn = toReturn && this.compareInternal(a[i], b[i]);\r\n      // If false, break the loop\r\n      if (!toReturn) { this.errorTracker.unshift(\"[\" + i.toString() + \"]\"); break; }\r\n    }\r\n    return this.announce(toReturn);\r\n  }\r\n\r\n  private compareObject(a: any, b: any) {\r\n    // Check that both objects contain the same amount of properties\r\n    if (a == null && b == null)\r\n      return this.announce(true);\r\n    if ((Object.keys(a)).length !== (Object.keys(b)).length) {\r\n      this.errorTracker.unshift(\"Mismatched property lists [\" + (Object.keys(a)) + \"][\" + (Object.keys(b)) + \"]\");\r\n      return this.announce(false);\r\n    }\r\n    // Keep track of result for each property of object\r\n    let toReturn = true;\r\n    for (const property in a) {\r\n      // Only check non-generic object properties\r\n      if (a.hasOwnProperty(property)) {\r\n        // If property does not exist in propertyCounter, add it\r\n        if (!this.propertyCounts.hasOwnProperty(property)) {\r\n          this.propertyCounts[property] = 0;\r\n        }\r\n        this.propertyCounts[property]++;\r\n\r\n        // Check that same property exists in b\r\n        if (!(b.hasOwnProperty(property))) {\r\n          this.errorTracker.unshift(\"Property \" + property + \" of A not in B\");\r\n          this.errorTracker.unshift(a);\r\n          this.errorTracker.unshift(b);\r\n          return this.announce(false);\r\n        }\r\n\r\n        toReturn = toReturn && this.compareInternal(a[property], b[property]);\r\n        // If not true, push property and break the loop\r\n        if (!toReturn) { this.errorTracker.unshift(property); break; }\r\n      }\r\n    }\r\n    return this.announce(toReturn);\r\n  }\r\n\r\n  // this is a convenient place for a breakpoint on failures in areSameStructure.\r\n  private announce(value: boolean): boolean {\r\n    if (value)\r\n      return true;\r\n    return false;\r\n  }\r\n\r\n  /** Main entry for comparing deep json objects.\r\n   * * errorTracker, typeCounts, and propertyCounts are cleared.\r\n   */\r\n  public compare(a: any, b: any, tolerance?: number): boolean {\r\n    if (tolerance !== undefined)\r\n      this.numberRelTol = tolerance;\r\n    this.errorTracker.length = 0;\r\n    this.typeCounts.numbers = this.typeCounts.arrays = this.typeCounts.functions = this.typeCounts.objects = this.typeCounts.strings = this.typeCounts.booleans = this.typeCounts.undefined = 0;\r\n    this.propertyCounts = {};\r\n    return this.compareInternal(a, b);\r\n  }\r\n\r\n  // Recursive function for comparing any two nodes in a json object \"tree\"\r\n  private compareInternal(a: any, b: any): boolean {\r\n    if (typeof a !== typeof b) {\r\n      return this.announce(false);\r\n    }\r\n    if ((typeof a === \"number\") && (typeof b === \"number\")) {\r\n      this.typeCounts.numbers++;\r\n      return this.compareNumber(a, b);\r\n    } else if (Array.isArray(a) && Array.isArray(b)) {\r\n      this.typeCounts.arrays++;\r\n      return this.compareArray(a, b);\r\n    } else if (typeof a === \"function\" && typeof b === \"function\") {\r\n      // No current necessity to check functions\r\n      this.typeCounts.functions++;\r\n      return true;\r\n    } else if (typeof a === \"object\" && typeof b === \"object\") {\r\n      // Argument is object but not array or function\r\n      this.typeCounts.objects++;\r\n      return (a === b) ? true : this.compareObject(a, b);\r\n    } else if (typeof a === \"string\" && typeof b === \"string\") {\r\n      this.typeCounts.strings++;\r\n      return a === b;\r\n    } else if (typeof a === \"boolean\" && typeof b === \"boolean\") {\r\n      this.typeCounts.booleans++;\r\n      return a === b;\r\n    } else if (typeof a === \"undefined\" && typeof b === \"undefined\") {\r\n      // As long as both are undefined, return true\r\n      this.typeCounts.undefined++;\r\n      return true;\r\n    } else {\r\n      // Unsupported type\r\n      return this.announce(false);\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Serialization */\r\n\r\nimport { Geometry, AxisOrder } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\n\r\nimport { Range1d, Range2d, Range3d } from \"../geometry3d/Range\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Map4d } from \"../geometry4d/Map4d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { UnionRegion } from \"../curve/UnionRegion\";\r\nimport { BagOfCurves } from \"../curve/CurveCollection\";\r\nimport { ParityRegion } from \"../curve/ParityRegion\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { Path } from \"../curve/Path\";\r\nimport { IndexedPolyface } from \"../polyface/Polyface\";\r\nimport { BSplineCurve3d, BSplineCurve3dBase } from \"../bspline/BSplineCurve\";\r\nimport { BSplineSurface3d, BSplineSurface3dH, WeightStyle } from \"../bspline/BSplineSurface\";\r\nimport { Sphere } from \"../solid/Sphere\";\r\nimport { Cone } from \"../solid/Cone\";\r\nimport { Box } from \"../solid/Box\";\r\nimport { TorusPipe } from \"../solid/TorusPipe\";\r\nimport { LinearSweep } from \"../solid/LinearSweep\";\r\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\r\nimport { RuledSweep } from \"../solid/RuledSweep\";\r\n\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { TransitionSpiral3d } from \"../curve/TransitionSpiral\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { PointString3d } from \"../curve/PointString3d\";\r\nimport { ClipPlane } from \"../clipping/ClipPlane\";\r\nimport { ConvexClipPlaneSet } from \"../clipping/ConvexClipPlaneSet\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { UnionOfConvexClipPlaneSets } from \"../clipping/UnionOfConvexClipPlaneSets\";\r\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\r\nimport { BezierCurve3d } from \"../bspline/BezierCurve3d\";\r\nimport { BezierCurve3dH } from \"../bspline/BezierCurve3dH\";\r\nimport { CurveChainWithDistanceIndex } from \"../curve/CurveChainWithDistanceIndex\";\r\nimport { KnotVector, BSplineWrapMode } from \"../bspline/KnotVector\";\r\nimport { SolidPrimitive } from \"../solid/SolidPrimitive\";\r\nimport { CoordinateXYZ } from \"../curve/CoordinateXYZ\";\r\n\r\n/* tslint:disable:no-console */\r\n/**\r\n * `Sample` has static methods to create a variety of geometry samples useful in testing.\r\n * @alpha\r\n */\r\nexport class Sample {\r\n  /** Array with assorted Point2d samples */\r\n  public static readonly point2d: Point2d[] = [\r\n    Point2d.create(0, 0),\r\n    Point2d.create(1, 0),\r\n    Point2d.create(0, 1),\r\n    Point2d.create(2, 3)];\r\n\r\n  /** Array with assorted Point3d samples */\r\n  public static readonly point3d: Point3d[] = [\r\n    Point3d.create(0, 0, 0),\r\n    Point3d.create(1, 0, 0),\r\n    Point3d.create(0, 1, 0),\r\n    Point3d.create(0, 1, 0),\r\n    Point3d.create(0, 0, 1),\r\n    Point3d.create(2, 3, 0),\r\n    Point3d.create(0, 2, 5),\r\n    Point3d.create(-3, 0, 5),\r\n    Point3d.create(4, 3, -2)];\r\n\r\n  /** Return an array of Point3d, with x,y,z all stepping through a range of values.\r\n   * x varies fastest, then y then z\r\n   */\r\n  public static createPoint3dLattice(low: number, step: number, high: number): Point3d[] {\r\n    const points = [];\r\n    for (let z = low; z <= high; z += step)\r\n      for (let y = low; y <= high; y += step)\r\n        for (let x = low; x <= high; x += step)\r\n          points.push(Point3d.create(x, y, z));\r\n    return points;\r\n  }\r\n\r\n  /** Return an array of Point2d, with x,y all stepping through a range of values.\r\n   * x varies fastest, then y\r\n   */\r\n  public static createPoint2dLattice(low: number, step: number, high: number): Point2d[] {\r\n    const points = [];\r\n    for (let y = low; y <= high; y += step)\r\n      for (let x = low; x <= high; x += step)\r\n        points.push(Point2d.create(x, y));\r\n    return points;\r\n  }\r\n  /** Array with assorted Point4d samples */\r\n  public static readonly point4d: Point4d[] = [\r\n    Point4d.create(0, 0, 0, 1),\r\n    Point4d.create(1, 0, 0, 1),\r\n    Point4d.create(0, 1, 0, 1),\r\n    Point4d.create(0, 1, 0, 1),\r\n    Point4d.create(0, 0, 1, 1),\r\n    Point4d.create(2, 3, 0, 1),\r\n    Point4d.create(0, 2, 5, 1),\r\n    Point4d.create(-3, 0, 5, 1),\r\n    Point4d.create(-3, 0, 5, 0.3),\r\n    Point4d.create(-3, 0, 5, -0.2),\r\n    Point4d.create(4, 3, -2, 1)];\r\n  /** Array with assorted nonzero vector samples. */\r\n  public static createNonZeroVectors(): Vector3d[] {\r\n    return [\r\n      Vector3d.create(1, 0, 0),\r\n      Vector3d.create(0, 1, 0),\r\n      Vector3d.create(0, 0, 1),\r\n      Vector3d.create(-1, 0, 0),\r\n      Vector3d.create(0, -1, 0),\r\n      Vector3d.create(0, 0, -1),\r\n      Vector3d.createPolar(1.0, Angle.createDegrees(20)),\r\n      Vector3d.createSpherical(1.0, Angle.createDegrees(20), Angle.createDegrees(10)),\r\n      Vector3d.createPolar(2.0, Angle.createDegrees(20)),\r\n      Vector3d.createSpherical(2.0, Angle.createDegrees(20), Angle.createDegrees(10)),\r\n      Vector3d.create(2, 3, 0)];\r\n  }\r\n  /** Array with assorted nonzero Vector2d samples */\r\n  public static readonly vector2d: Vector2d[] = [\r\n    Vector2d.create(1, 0),\r\n    Vector2d.create(0, 1),\r\n    Vector2d.create(0, 0),\r\n    Vector2d.create(-1, 0),\r\n    Vector2d.create(0, -1),\r\n    Vector2d.create(0, 0),\r\n    Vector2d.createPolar(1.0, Angle.createDegrees(20)),\r\n    Vector2d.createPolar(2.0, Angle.createDegrees(20)),\r\n    Vector2d.create(2, 3)];\r\n  /** Return an array with assorted Range3d samples */\r\n  public static createRange3ds(): Range3d[] {\r\n    return [\r\n      Range3d.createXYZXYZ(0, 0, 0, 1, 1, 1),\r\n      Range3d.createXYZ(1, 2, 3),\r\n      Range3d.createXYZXYZ(-2, -3, 1, 200, 301, 8)];\r\n  }\r\n  /** Create 5 points of a (axis aligned) rectangle with corners (x0,y0) and (x1,y1) */\r\n  public static createRectangleXY(x0: number, y0: number, ax: number, ay: number, z: number = 0): Point3d[] {\r\n    return [\r\n      Point3d.create(x0, y0, z),\r\n      Point3d.create(x0 + ax, y0, z),\r\n      Point3d.create(x0 + ax, y0 + ay, z),\r\n      Point3d.create(x0, y0 + ay, z),\r\n      Point3d.create(x0, y0, z),\r\n    ];\r\n  }\r\n  /** Access the last point in the array. push another shifted by dx,dy,dz.\r\n   * * No push if all are 0.\r\n   * * If array is empty, push a leading 000\r\n   */\r\n  public static pushMove(data: Point3d[], dx: number, dy: number, dz: number = 0.0) {\r\n    if (data.length === 0)\r\n      data.push(Point3d.create(0, 0, 0));\r\n    const back = data[data.length - 1];\r\n    if (dx !== 0 || dy !== 0 || dz !== 0)\r\n      data.push(Point3d.create(back.x + dx, back.y + dy, back.z + dz));\r\n  }\r\n  /** push a clone of the data[0] */\r\n  public static pushClosure(data: Point3d[]) {\r\n    if (data.length > 0)\r\n      data.push(data[data.length - 1].clone());\r\n  }\r\n  /** Return an array with numPoints on the unit circle (counting closure) */\r\n  public static createUnitCircle(numPoints: number): Point3d[] {\r\n    const points: Point3d[] = [];\r\n    const dTheta = Geometry.safeDivideFraction(Math.PI * 2, numPoints - 1, 0.0);\r\n    for (let i = 0; i < numPoints; i++) {\r\n      const theta = i * dTheta;\r\n      points.push(Point3d.create(Math.cos(theta), Math.sin(theta), 0.0));\r\n    }\r\n    return points;\r\n  }\r\n  /** Create points for an L shaped polygon\r\n   * * lower left at x0,y0.\r\n   * * ax,ay are larger side lengths (lower left to corners along x and y directions)\r\n   * * bx,by are smaller side lengths (inner corner to points along x and y directions)\r\n   */\r\n  public static createLShapedPolygon(x0: number, y0: number, ax: number, ay: number, bx: number, by: number, z: number = 0): Point3d[] {\r\n    return [\r\n      Point3d.create(x0, y0, z),\r\n      Point3d.create(x0 + ax, y0, z),\r\n      Point3d.create(x0 + ax, y0 + by),\r\n      Point3d.create(x0 + bx, y0 + by),\r\n      Point3d.create(x0 + bx, y0 + ay, z),\r\n      Point3d.create(x0, y0 + ay, z),\r\n      Point3d.create(x0, y0, z),\r\n    ];\r\n  }\r\n  /** Create assorted clip planes. */\r\n  public static createClipPlanes(): ClipPlane[] {\r\n    const plane0 = ClipPlane.createNormalAndDistance(Vector3d.create(1, 0, 0), 2.0)!;\r\n    const plane1 = plane0.cloneNegated();\r\n    const plane2 = plane1.clone();\r\n    plane2.setFlags(true, true);\r\n    return [\r\n      plane0, plane1, plane2,\r\n      ClipPlane.createNormalAndDistance(Vector3d.create(3, 4, 0), 2.0)!,\r\n      ClipPlane.createEdgeXY(Point3d.create(1, 0, 0), Point3d.create(24, 32, 0))!];\r\n  }\r\n\r\n  /**\r\n   * * A first-quadrant unit square\r\n   * * Two squares -- first and fourth quadrant unit squares\r\n   * * Three squares -- first, second and fourth quadrant unit squares\r\n   */\r\n  public static createClipPlaneSets(): UnionOfConvexClipPlaneSets[] {\r\n    const result = [];\r\n    const quadrant1 = ConvexClipPlaneSet.createXYBox(0, 0, 1, 1);\r\n    result.push(UnionOfConvexClipPlaneSets.createConvexSets([quadrant1.clone()]));\r\n    const quadrant2 = ConvexClipPlaneSet.createXYBox(-1, 0, 0, 1);\r\n    const quadrant4 = ConvexClipPlaneSet.createXYBox(0, -1, 1, 0);\r\n\r\n    result.push(UnionOfConvexClipPlaneSets.createConvexSets([\r\n      quadrant1.clone(),\r\n      quadrant4.clone()]));\r\n    result.push(UnionOfConvexClipPlaneSets.createConvexSets([\r\n      quadrant1.clone(),\r\n      quadrant2.clone(),\r\n      quadrant4.clone()]));\r\n    return result;\r\n  }\r\n  /** Create (unweighted) bspline curves.\r\n   * order varies from 2 to 5\r\n   */\r\n  public static createBsplineCurves(includeMultipleKnots: boolean = false): BSplineCurve3d[] {\r\n    const result: BSplineCurve3d[] = [];\r\n    const yScale = 0.1;\r\n    for (const order of [2, 3, 4, 5]) {\r\n      const points = [];\r\n      for (const x of [0, 1, 2, 3, 4, 5, 7]) {\r\n        points.push(Point3d.create(x, yScale * (1 + x * x), 0.0));\r\n      }\r\n      const curve = BSplineCurve3d.createUniformKnots(points, order) as BSplineCurve3d;\r\n      result.push(curve);\r\n    }\r\n    if (includeMultipleKnots) {\r\n      const interiorKnotCandidates = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8];\r\n      for (const order of [3, 4]) {\r\n        const numPoints = 8;\r\n        const points = [];\r\n        for (let i = 0; i < numPoints; i++)\r\n          points.push(Point3d.create(i, i * i, 0));\r\n        const knots = [];\r\n        for (let i = 0; i < order - 1; i++) knots.push(0);\r\n        const numInteriorNeeded = numPoints - order;\r\n        for (let i = 0; i < numInteriorNeeded; i++)knots.push(interiorKnotCandidates[i]);\r\n        const lastKnot = knots[knots.length - 1] + 1;\r\n        for (let i = 0; i < order - 1; i++) knots.push(lastKnot);\r\n        const curve = BSplineCurve3d.create(points, knots, order);\r\n        if (curve)\r\n          result.push(curve);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Create weighted bspline curves.\r\n   * order varies from 2 to 5\r\n   */\r\n  public static createBspline3dHCurves(): BSplineCurve3dH[] {\r\n    const result: BSplineCurve3dH[] = [];\r\n    const yScale = 0.1;\r\n    for (const weightVariation of [0, 0.125]) {\r\n      for (const order of [2, 3, 4, 5]) {\r\n        const points = [];\r\n        for (const x of [0, 1, 2, 3, 4, 5, 7]) {\r\n          points.push(Point4d.create(x, yScale * (1 + x * x), 0.0, 1.0 + weightVariation * Math.sin(x * Math.PI * 0.25)));\r\n        }\r\n        const curve = BSplineCurve3dH.createUniformKnots(points, order) as BSplineCurve3dH;\r\n        result.push(curve);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Create weighted bsplines for circular arcs.\r\n   */\r\n  public static createBspline3dHArcs(): BSplineCurve3dH[] {\r\n    const result: BSplineCurve3dH[] = [];\r\n    const halfRadians = Angle.degreesToRadians(60.0);\r\n    const c = Math.cos(halfRadians);\r\n    const s = Math.sin(halfRadians);\r\n    // const sec = 1.0 / c;\r\n    // const t = s / c;\r\n    const points = [\r\n      Point4d.create(1, 0, 0, 1),\r\n      Point4d.create(c, s, 0, c),\r\n      Point4d.create(-c, s, 0, 1),\r\n      Point4d.create(-1, 0, 0, c),\r\n      Point4d.create(-c, -s, 0, 1),\r\n      Point4d.create(c, -s, 0, c),\r\n      Point4d.create(1, 0, 0, 1)];\r\n    const knots = [0, 0, 1, 1, 2, 2, 3, 3];\r\n\r\n    const curve = BSplineCurve3dH.create(points, knots, 3) as BSplineCurve3dH;\r\n    result.push(curve);\r\n    return result;\r\n  }\r\n\r\n  /** Return array   [x,y,z,w] bspline control points for an arc in 90 degree bspline spans.\r\n   * @param points array of [x,y,z,w]\r\n   * @param center center of arc\r\n   * @param axes matrix with 0 and 90 degree axes\r\n   * @param radius0 radius multiplier for x direction.\r\n   * @param radius90 radius multiplier for y direction.\r\n   * @param applyWeightsToXYZ\r\n   */\r\n  public static createBsplineArc90SectionToXYZWArrays(\r\n    center: Point3d,\r\n    axes: Matrix3d,\r\n    radius0: number,\r\n    radius90: number,\r\n    applyWeightsToXYZ: boolean): number[][] {\r\n    const a = Math.sqrt(0.5);\r\n    const xyz = Point3d.create();\r\n    Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0, 0.0, 0, xyz);\r\n    const controlPoints = [];\r\n    controlPoints.push([xyz.x, xyz.y, xyz.z, 1.0]);\r\n    const cornerTrig = [1, 1, -1, -1, 1];\r\n    const axisTrig = [1, 0, -1, 0, 1];\r\n    for (let i = 0; i < 4; i++) {\r\n      Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0 * cornerTrig[i + 1], radius90 * cornerTrig[i], 0, xyz);\r\n      controlPoints.push([xyz.x, xyz.y, xyz.z, a]);\r\n      Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0 * axisTrig[i + 1], radius90 * axisTrig[i], 0, xyz);\r\n      controlPoints.push([xyz.x, xyz.y, xyz.z, 1.0]);\r\n    }\r\n    if (applyWeightsToXYZ) {\r\n      for (const xyzw of controlPoints) {\r\n        const b = xyzw[3];\r\n        xyzw[0] *= b;\r\n        xyzw[1] *= b;\r\n        xyzw[2] *= b;\r\n      }\r\n    }\r\n    return controlPoints;\r\n  }\r\n\r\n  /**\r\n   * Create both unweighted and weighted bspline curves.\r\n   * (This is the combined results from createBsplineCurves and createBspline3dHCurves)\r\n   */\r\n  public static createMixedBsplineCurves(): BSplineCurve3dBase[] {\r\n    const arrayA = Sample.createBsplineCurves();\r\n    const arrayB = Sample.createBspline3dHCurves();\r\n    const result = [];\r\n    for (const a of arrayA) result.push(a);\r\n    for (const b of arrayB) result.push(b);\r\n    return result;\r\n  }\r\n\r\n  /** create a plane from origin and normal coordinates -- default to 001 normal if needed. */\r\n  public static createPlane(x: number, y: number, z: number, u: number, v: number, w: number): Plane3dByOriginAndUnitNormal {\r\n    const point = Point3d.create(x, y, z);\r\n    const vector = Vector3d.create(u, v, w).normalize();\r\n    if (vector) {\r\n      const plane = Plane3dByOriginAndUnitNormal.create(point, vector);\r\n      if (plane)\r\n        return plane;\r\n    }\r\n    return Sample.createPlane(x, y, z, u, v, 1);\r\n  }\r\n\r\n  /** Create ray from (x,y,z) and direction components.   (Normalize the direction) */\r\n  public static createRay(x: number, y: number, z: number, u: number, v: number, w: number): Ray3d {\r\n    return Ray3d.create(\r\n      Point3d.create(x, y, z),\r\n      Vector3d.create(u, v, w).normalize() as Vector3d);\r\n  }\r\n  /** Assorted Plane3dBYOriginAndUnitNormal */\r\n  public static readonly plane3dByOriginAndUnitNormal: Plane3dByOriginAndUnitNormal[] = [\r\n    Plane3dByOriginAndUnitNormal.createXYPlane(),\r\n    Plane3dByOriginAndUnitNormal.createYZPlane(),\r\n    Plane3dByOriginAndUnitNormal.createZXPlane(),\r\n    Sample.createPlane(0, 0, 0, 3, 0, 1),\r\n    Sample.createPlane(1, 2, 3, 2, 4, -1)];\r\n\r\n  /** Assorted Ray3d, not all unit direction vectors. */\r\n  public static readonly ray3d: Ray3d[] = [\r\n    Sample.createRay(0, 0, 0, 1, 0, 0),\r\n    Sample.createRay(0, 0, 0, 0, 1, 0),\r\n    Sample.createRay(0, 0, 0, 0, 0, 1),\r\n    Sample.createRay(0, 0, 0, 1, 2, 0),\r\n    Sample.createRay(1, 2, 3, 4, 2, -1)];\r\n  /** Assorted angles.  All principal directions, some others included. */\r\n  public static readonly angle: Angle[] = [\r\n    Angle.createDegrees(0),\r\n    Angle.createDegrees(90),\r\n    Angle.createDegrees(180),\r\n    Angle.createDegrees(-90),\r\n    Angle.createDegrees(30),\r\n    Angle.createDegrees(-105)];\r\n  /** Assorted angle sweeps */\r\n  public static readonly angleSweep: AngleSweep[] = [\r\n    AngleSweep.createStartEndDegrees(0, 90),\r\n    AngleSweep.createStartEndDegrees(0, 180),\r\n    AngleSweep.createStartEndDegrees(-90, 0),\r\n    AngleSweep.createStartEndDegrees(0, -90),\r\n    AngleSweep.createStartEndDegrees(0, 30),\r\n    AngleSweep.createStartEndDegrees(45, 110)];\r\n\r\n  /** assorted line segments */\r\n  public static readonly lineSegment3d: LineSegment3d[] = [\r\n    LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(1, 0, 0)),\r\n    LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(0, 1, 0)),\r\n    LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(0, 0, 1)),\r\n    LineSegment3d.create(Point3d.create(1, 2, 3), Point3d.create(-2, -3, 0.5))];\r\n  /** Assorted lines strings */\r\n  public static createLineStrings(): LineString3d[] {\r\n    return [\r\n      LineString3d.createPoints(\r\n        [\r\n          Point3d.create(0, 0, 0),\r\n          Point3d.create(1, 0, 0)]),\r\n      LineString3d.createPoints(\r\n        [\r\n          Point3d.create(0, 0, 0),\r\n          Point3d.create(1, 0, 0),\r\n          Point3d.create(1, 1, 0)]),\r\n      LineString3d.createPoints(\r\n        [\r\n          Point3d.create(0, 0, 0),\r\n          Point3d.create(1, 0, 0),\r\n          Point3d.create(1, 1, 0),\r\n          Point3d.create(2, 2, 0)])];\r\n  }\r\n  /** Assorted Range1d:   single point, null, simple forward, simple reverse */\r\n  public static readonly range1d: Range1d[] = [\r\n    Range1d.createX(1),\r\n    Range1d.createNull(),\r\n    Range1d.createXX(1, 2),\r\n    Range1d.createXX(2, 1)];\r\n  /** Assorted range2d: single point, null, 2 point with various creation orders. */\r\n  public static readonly range2d: Range2d[] = [\r\n    Range2d.createXY(1, 2),\r\n    Range2d.createNull(),\r\n    Range2d.createXYXY(1, 2, 0, 3),\r\n    Range2d.createXYXY(1, 2, 3, 4)];\r\n  /** Assorted range2d: single point, null, 2 point with various creation orders. */\r\n  public static readonly range3d: Range3d[] = [\r\n    Range3d.createXYZ(1, 2, 3),\r\n    Range3d.createNull(),\r\n    Range3d.createXYZXYZ(1, 2, 0, 3, 4, 7),\r\n    Range3d.createXYZXYZ(1, 2, 3, -2, -4, -1)];\r\n  /** Assorted Matrix3d:\r\n   * * identity\r\n   * * rotation around x\r\n   * * rotation around general vector\r\n   * * uniform scale\r\n   * * nonuniform scale (including negative scales!)\r\n   */\r\n  public static createMatrix3dArray(): Matrix3d[] {\r\n    return [\r\n      Matrix3d.createIdentity(),\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.create(1, 0, 0), Angle.createDegrees(10)) as Matrix3d,\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.create(1, -2, 5), Angle.createDegrees(-6.0)) as Matrix3d,\r\n\r\n      Matrix3d.createUniformScale(2.0),\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.create(1, 2, 3), Angle.createDegrees(49.0)) as Matrix3d,\r\n      Matrix3d.createScale(1, 1, -1),\r\n      Matrix3d.createScale(2, 3, 4)];\r\n  }\r\n  /** Assorted invertible transforms. */\r\n  public static createInvertibleTransforms(): Transform[] {\r\n    return [\r\n      Transform.createIdentity(),\r\n      Transform.createTranslationXYZ(1, 2, 0),\r\n      Transform.createTranslationXYZ(1, 2, 3),\r\n      Transform.createFixedPointAndMatrix(\r\n        Point3d.create(4, 1, -2),\r\n        Matrix3d.createUniformScale(2.0)),\r\n      Transform.createFixedPointAndMatrix(\r\n        Point3d.create(4, 1, -2),\r\n        Matrix3d.createRotationAroundVector(\r\n          Vector3d.create(1, 2, 3), Angle.createRadians(10)) as Matrix3d)];\r\n  }\r\n\r\n  /** Return an array of Matrix3d with various skew and scale.  This includes at least:\r\n   * * identity\r\n   * * 3 distinct diagonals.\r\n   * * The distinct diagonal base with smaller value added to\r\n   *    other 6 spots in succession.\r\n   * * the distinct diagonals with all others also smaller non-zeros.\r\n   */\r\n  public static createScaleSkewMatrix3d(): Matrix3d[] {\r\n    return [\r\n      Matrix3d.createRowValues(\r\n        1, 0, 0,\r\n        0, 1, 0,\r\n        0, 0, 1),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 0,\r\n        0, 6, 0,\r\n        0, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 2, 0,\r\n        0, 6, 0,\r\n        0, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 2,\r\n        0, 6, 0,\r\n        0, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 0,\r\n        1, 6, 0,\r\n        0, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 0,\r\n        0, 6, 1,\r\n        0, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 0,\r\n        0, 6, 0,\r\n        1, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 0,\r\n        0, 6, 0,\r\n        0, 1, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 2, 3,\r\n        2, 6, 1,\r\n        -1, 2, 7)];\r\n  }\r\n\r\n  /** Return an array of singular Matrix3d.  This includes at least:\r\n   * * all zeros\r\n   * * one nonzero column\r\n   * * two independent columns, third is zero\r\n   * * two independent columns, third is sum of those\r\n   * * two independent columns, third is copy of one\r\n   */\r\n  public static createSingularMatrix3d(): Matrix3d[] {\r\n    const vectorU = Vector3d.create(2, 3, 6);\r\n    const vectorV = Vector3d.create(-1, 5, 2);\r\n    const vectorUPlusV = vectorU.plus(vectorV);\r\n    const vector0 = Vector3d.createZero();\r\n    return [\r\n      Matrix3d.createZero(),\r\n      // one nonzero column\r\n      Matrix3d.createColumns(vectorU, vector0, vector0),\r\n      Matrix3d.createColumns(vector0, vectorU, vector0),\r\n      Matrix3d.createColumns(vector0, vector0, vector0),\r\n      // two independent nonzero columns with zero\r\n      Matrix3d.createColumns(vectorU, vectorV, vector0),\r\n      Matrix3d.createColumns(vector0, vectorU, vectorV),\r\n      Matrix3d.createColumns(vectorV, vector0, vector0),\r\n      // third column dependent\r\n      Matrix3d.createColumns(vectorU, vectorV, vectorUPlusV),\r\n      Matrix3d.createColumns(vectorU, vectorUPlusV, vectorV),\r\n      Matrix3d.createColumns(vectorUPlusV, vectorV, vectorU),\r\n      // two independent with duplicate\r\n      Matrix3d.createColumns(vectorU, vectorV, vectorU),\r\n      Matrix3d.createColumns(vectorU, vectorU, vectorV),\r\n      Matrix3d.createColumns(vectorV, vectorV, vectorU)];\r\n  }\r\n\r\n  /**\r\n   * * Return an array of rigid transforms.  This includes (at least)\r\n   *   * Identity\r\n   *   * translation with identity matrix\r\n   *   * rotation around origin and arbitrary vector\r\n   *   * rotation around space point and arbitrary vector\r\n   * * use given refDistance is crude distance of translation and distance to fixed point.\r\n   */\r\n  public static createRigidTransforms(distanceScale: number = 4.0): Transform[] {\r\n    const distanceScale3 = distanceScale / 3.0;\r\n    const distanceScale4 = distanceScale / 4.0;\r\n    return [\r\n      Transform.createIdentity(),\r\n      Transform.createTranslationXYZ(distanceScale3 * 1, distanceScale3 * 2, distanceScale3 * 3),\r\n      Transform.createFixedPointAndMatrix(\r\n        Point3d.create(0, 0, 0),\r\n        Matrix3d.createRotationAroundVector(\r\n          Vector3d.unitY(), Angle.createDegrees(10)) as Matrix3d),\r\n      Transform.createFixedPointAndMatrix(\r\n        Point3d.create(distanceScale4 * 4, distanceScale4 * 1, -distanceScale4 * 2),\r\n        Matrix3d.createRotationAroundVector(\r\n          Vector3d.create(1, 2, 3), Angle.createDegrees(10)) as Matrix3d),\r\n      Transform.createFixedPointAndMatrix(\r\n        Point3d.create(distanceScale4 * 4, distanceScale4 * 1, -distanceScale4 * 2),\r\n        Matrix3d.createRotationAroundVector(\r\n          Vector3d.create(-2, 1, 4), Angle.createDegrees(35)) as Matrix3d)];\r\n  }\r\n  /**\r\n   * Return a single rigid transform with all terms nonzero.\r\n   */\r\n  public static createMessyRigidTransform(fixedPoint?: Point3d): Transform {\r\n    return Transform.createFixedPointAndMatrix(\r\n      fixedPoint ? fixedPoint : Point3d.create(1, 2, 3),\r\n      Matrix3d.createRotationAroundVector(Vector3d.create(0.3, -0.2, 1.2), Angle.createDegrees(15.7))!);\r\n  }\r\n  /** Return various rigid matrices:\r\n   * * identity\r\n   * * small rotations around x, y, z\r\n   * * small rotation around (1,2,3)\r\n   */\r\n  public static createRigidAxes(): Matrix3d[] {\r\n    return [\r\n      Matrix3d.createIdentity(),\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.unitX(), Angle.createDegrees(10)) as Matrix3d,\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.unitY(), Angle.createDegrees(10)) as Matrix3d,\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.unitZ(), Angle.createDegrees(10)) as Matrix3d,\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.create(1, 2, 3), Angle.createDegrees(10)) as Matrix3d,\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Return various Matrix4d\r\n   * * Simple promotion of each Sample.createInvertibleTransforms ()\r\n   * * optional nasty [1,2,3,4...15] row order\r\n   * @param includeIrregular if true, include [1,2,..15] row major\r\n   */ // promote each transform[] to a Matrix4d.\r\n  public static createMatrix4ds(includeIrregular: boolean = false): Matrix4d[] {\r\n    const result = [];\r\n    let transform;\r\n    for (transform of Sample.createInvertibleTransforms())\r\n      result.push(Matrix4d.createTransform(transform));\r\n    if (includeIrregular) {\r\n      result.push(Matrix4d.createRowValues(\r\n        1, 2, 3, 4,\r\n        5, 6, 7, 8,\r\n        9, 10, 11, 12,\r\n        13, 14, 15, 16));\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Create full Map4d for each `Sample.createInvertibleTransforms ()`\r\n   */\r\n  public static createMap4ds(): Map4d[] {\r\n    const result = [];\r\n    let transform;\r\n    for (transform of Sample.createInvertibleTransforms()) {\r\n      const inverse = transform.inverse();\r\n      if (inverse) {\r\n        const map = Map4d.createTransform(transform, inverse);\r\n        if (map)\r\n          result.push(map);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Assorted simple `Path` objects. */\r\n  public static createSimplePaths(withGaps: boolean = false): Path[] {\r\n    const point0 = Point3d.create(0, 0, 0);\r\n    const point1 = Point3d.create(10, 0, 0);\r\n\r\n    const p1 = [point1, Point3d.create(0, 10, 0), Point3d.create(6, 10, 0), Point3d.create(6, 10, 0), Point3d.create(0, 10, 0)];\r\n    const segment1 = LineSegment3d.create(point0, point1);\r\n    const vectorU = Vector3d.unitX(3);\r\n    const vectorV = Vector3d.unitY(3);\r\n    const arc2 = Arc3d.create(point1.minus(vectorU), vectorU, vectorV, AngleSweep.createStartEndDegrees(0, 90));\r\n    const simplePaths = [\r\n      Path.create(segment1),\r\n      Path.create(segment1, arc2),\r\n      Path.create(\r\n        LineSegment3d.create(point0, point1),\r\n        LineString3d.create(p1)),\r\n      Sample.createCappedArcPath(4, 0, 180),\r\n    ];\r\n    if (withGaps)\r\n      simplePaths.push(\r\n        Path.create(\r\n          LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(10, 0, 0)),\r\n          LineSegment3d.create(Point3d.create(10, 10, 0), Point3d.create(5, 0, 0))));\r\n\r\n    return simplePaths;\r\n  }\r\n  /** Assorted `Path` with lines and arcs.\r\n   * Specifically useful for offset tests.\r\n   */\r\n  public static createLineArcPaths(): Path[] {\r\n    const paths = [];\r\n    const x1 = 10.0;\r\n    const y2 = 5.0;\r\n    const y3 = 10.0;\r\n    for (const y0 of [0, -1, 1]) {\r\n      for (const x2 of [15, 11, 20, 9, 7]) {\r\n\r\n        const point0 = Point3d.create(0, y0, 0);\r\n        const point1 = Point3d.create(x1, 0, 0);\r\n        const point2 = Point3d.create(x2, y2, 0);\r\n        const point3 = Point3d.create(x1, y3, 0);\r\n        const point4 = Point3d.create(0, y3 + y0, 0);\r\n        const path0 = Path.create();\r\n        path0.tryAddChild(LineString3d.create(point0, point1, point2, point3, point4));\r\n        paths.push(path0);\r\n        const path1 = Path.create();\r\n        path1.tryAddChild(LineSegment3d.create(point0, point1));\r\n        path1.tryAddChild(Arc3d.createCircularStartMiddleEnd(point1, Point3d.create(x2, y2, 0), point3));\r\n        path1.tryAddChild(LineSegment3d.create(point3, point4));\r\n        paths.push(path1);\r\n      }\r\n    }\r\n    return paths;\r\n  }\r\n\r\n  /** Assorted `PointString3d` objects. */\r\n  public static createSimplePointStrings(): PointString3d[] {\r\n    const p1 = [[Point3d.create(0, 10, 0)], [Point3d.create(6, 10, 0)], [Point3d.create(6, 10, 0), [Point3d.create(6, 10, 0)]]];\r\n    const simplePaths = [\r\n      PointString3d.create(Point3d.create(1, 2, 0)),\r\n      PointString3d.create(Point3d.create(0, 0, 0), Point3d.create(10, 0, 0)),\r\n      PointString3d.create(\r\n        Point3d.create(10, 0, 0),\r\n        Point3d.create(10, 5, 0)),\r\n      PointString3d.create(p1)];\r\n\r\n    return simplePaths;\r\n  }\r\n  /** Assorted `Loop` objects */\r\n  public static createSimpleLoops(): Loop[] {\r\n    const point0 = Point3d.create(0, 0, 0);\r\n    const point1 = Point3d.create(10, 0, 0);\r\n    const point2 = Point3d.create(10, 5, 0);\r\n    const point3 = Point3d.create(0, 5, 0);\r\n    const result = [\r\n      // rectangle with single linestring\r\n      Loop.create(LineString3d.create(point0, point1, point2, point3, point0)),\r\n      // unit circle\r\n      Loop.create(Arc3d.createUnitCircle()),\r\n      // rectangle, but with individual line segments\r\n      Loop.create(\r\n        LineSegment3d.create(point0, point1),\r\n        LineSegment3d.create(point1, point2),\r\n        LineSegment3d.create(point2, point3),\r\n        LineSegment3d.create(point3, point0),\r\n      ),\r\n      // Semicircle\r\n      Sample.createCappedArcLoop(4, -90, 90),\r\n    ];\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a square wave along x direction\r\n   * @param dx0 distance along x axis at y=0\r\n   * @param dy vertical rise\r\n   * @param dx1 distance along x axis at y=dy\r\n   * @param numPhase number of phases of the jump.\r\n   * @param dyReturn y value for return to origin.  If 0, the wave ends at y=0 after then final \"down\" with one extra horizontal dx0\r\n   *     If nonzero, rise to that y value, return to x=0, and return down to origin.\r\n   *\r\n   */\r\n  public static createSquareWave(origin: Point3d, dx0: number, dy: number, dx1: number, numPhase: number, dyReturn: number): Point3d[] {\r\n    const result = [origin.clone()];\r\n    for (let i = 0; i < numPhase; i++) {\r\n      this.pushMove(result, dx0, 0);\r\n      this.pushMove(result, 0, dy);\r\n      this.pushMove(result, dx1, 0);\r\n      this.pushMove(result, 0, -dy);\r\n    }\r\n    this.pushMove(result, dx0, 0);\r\n    if (dyReturn !== 0.0) {\r\n      this.pushMove(result, 0, dyReturn);\r\n      result.push(Point3d.create(origin.x, origin.y + dyReturn));\r\n      result.push(result[0].clone());\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create multiple interpolated points between two points\r\n   * @param point0 start point (at fraction0)\r\n   * @param point1 end point (at fraction1)\r\n   * @param numPoints total number of points.  This is force to at least 2.\r\n   * @param result optional existing array to receive points.\r\n   * @param index0 optional index of first point.  Default is 0.\r\n   * @param index1 optional index of final point.  Default is numPoints\r\n   */\r\n  public static createInterpolatedPoints(point0: Point3d, point1: Point3d, numPoints: number, result?: Point3d[], index0?: number, index1?: number): Point3d[] {\r\n    if (numPoints < 2)\r\n      numPoints = 2;\r\n    if (result === undefined)\r\n      result = [];\r\n    if (index0 === undefined)\r\n      index0 = 0;\r\n    if (index1 === undefined)\r\n      index1 = numPoints;\r\n\r\n    for (let i = index0; i <= index1; i++) {\r\n      result.push(point0.interpolate(i / numPoints, point1));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Append numPhase teeth.  Each tooth starts with dxLow dwell at initial y, then sloped rise, then dwell at top, then sloped fall\r\n   * * If no points are present, start with 000.  (this happens in pushMove) Otherwise start from final point.\r\n   * * return points array reference.\r\n   * @param points point array to receive points\r\n   * @param dxLow starting step along x direction\r\n   * @param riseX width of rising and falling parts\r\n   * @param riseY height of rise\r\n   * @param dxHigh width at top\r\n   * @param numPhase number of phases.\r\n   */\r\n  public static appendSawTooth(points: Point3d[], dxLow: number, riseX: number, riseY: number, dxHigh: number, numPhase: number): Point3d[] {\r\n    for (let i = 0; i < numPhase; i++) {\r\n      this.pushMove(points, dxLow, 0, 0);\r\n      this.pushMove(points, riseX, riseY, 0);\r\n      this.pushMove(points, dxHigh, 0, 0);\r\n      this.pushMove(points, riseX, -riseY, 0);\r\n    }\r\n    return points;\r\n  }\r\n  /** append sawtooth with x distances successively scaled by xFactor */\r\n  public static appendVariableSawTooth(points: Point3d[], dxLow: number, riseX: number, riseY: number, dxHigh: number, numPhase: number, xFactor: number): Point3d[] {\r\n    let factor = 1.0;\r\n    for (let i = 0; i < numPhase; i++) {\r\n      this.appendSawTooth(points, factor * dxLow, factor * riseX, riseY, factor * dxHigh, 1);\r\n      factor *= xFactor;\r\n    }\r\n    return points;\r\n  }\r\n  /**\r\n   * Create a pair of sawtooth patterns, one (nominally) outbound and up, the other inbound and down.\r\n   * * return phase count adjusted to end at start x\r\n   * * enter return dx values as lengths -- sign will be negated in construction.\r\n   * @param origin start of entire path.\r\n   * @param dxLow low outbound dwell\r\n   * @param riseX x part of outbound rise and fall\r\n   * @param riseY y part of outbound rise and fall\r\n   * @param dxHigh high outbound dwell\r\n   * @param numPhaseOutbound number of phases outbound.  Final phase followed by dxLow dwell.\r\n   * @param dyFinal rise after final dwell.\r\n   * @param dxLowReturn dwell at return high\r\n   * @param riseXReturn rise x part of return\r\n   * @param riseYReturn rise y part of return\r\n   * @param dxHighReturn  dwell at return high\r\n   */\r\n  public static createBidirectionalSawtooth(origin: Point3d, dxLow: number, riseX: number, riseY: number, dxHigh: number, numPhaseOutbound: number,\r\n    dyFinal: number,\r\n    dxLowReturn: number, riseXReturn: number, riseYReturn: number, dxHighReturn: number): Point3d[] {\r\n    const data = [origin.clone()];\r\n    const x0 = data[0].x;\r\n    this.appendSawTooth(data, dxLow, riseX, riseY, dxHigh, numPhaseOutbound);\r\n    this.pushMove(data, dxLow, 0, 0);\r\n    this.pushMove(data, 0, dyFinal);\r\n    const x1 = data[data.length - 1].x;\r\n    const returnPhase = Math.abs(dxLowReturn + 2 * riseXReturn + dxHighReturn);\r\n    const totalDX = Math.abs(x1 - x0);\r\n    const numReturnPhase = Math.floor(Math.abs(totalDX / returnPhase));\r\n    this.appendSawTooth(data, -dxLowReturn, -riseXReturn, riseYReturn, -dxHighReturn, numReturnPhase);\r\n    const x2 = data[data.length - 1].x;\r\n    this.pushMove(data, x0 - x2, 0, 0);\r\n    data.push(data[0].clone());\r\n    return data;\r\n  }\r\n  /** append to a linestring, taking steps along given vector directions\r\n   * If the linestring is empty, a 000 point is added.\r\n   * @param linestring LineString3d to receive points.\r\n   * @param numPhase number of phases of the sawtooth\r\n   * @param vectors any number of vector steps.\r\n   */\r\n  public static appendPhases(linestring: LineString3d, numPhase: number, ...vectors: Vector3d[]): void {\r\n    const tailPoint = linestring.endPoint(); // and this defaults to 000 . ..\r\n    if (linestring.numPoints() === 0)\r\n      linestring.addPoint(tailPoint);\r\n\r\n    for (let i = 0; i < numPhase; i++) {\r\n      for (const v of vectors) {\r\n        tailPoint.addInPlace(v);\r\n        linestring.addPoint(tailPoint);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Assorted regions with arc boundaries\r\n   * * full circle\r\n   * * with varying sweep:\r\n   *    * partial arc with single chord closure\r\n   *    * partial arc with 2-edge closure via center\r\n   */\r\n  public static createArcRegions(): Loop[] {\r\n    const result = [];\r\n    const center = Point3d.create(0, 0, 0);\r\n    for (const sweep of [\r\n      AngleSweep.createStartEndDegrees(0, 360),\r\n      AngleSweep.createStartEndDegrees(-20, 20),\r\n      AngleSweep.createStartEndDegrees(0, 90),\r\n      AngleSweep.createStartEndDegrees(0, 180),\r\n    ]) {\r\n      const arc0 = Arc3d.createXY(Point3d.create(0, 0), 2.0, sweep);\r\n      if (arc0.sweep.isFullCircle) {\r\n        result.push(Loop.create(arc0));\r\n      } else {\r\n        const chord = LineSegment3d.create(arc0.endPoint(), arc0.startPoint());\r\n        result.push(Loop.create(arc0, chord));\r\n        result.push(Loop.create(arc0, LineString3d.create(arc0.endPoint(), center, arc0.startPoint())));\r\n      }\r\n\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Assorted loops in xy plane:\r\n   * * unit square\r\n   * * rectangle\r\n   * * L shape\r\n   */\r\n  public static createSimpleXYPointLoops(): Point3d[][] {\r\n    const result = [];\r\n    result.push(Sample.createRectangleXY(0, 0, 1, 1));\r\n    result.push(Sample.createRectangleXY(0, 0, 4, 3));\r\n    result.push(Sample.createLShapedPolygon(0, 0, 5, 4, 1, 2));\r\n    return result;\r\n  }\r\n  /** Assorted `ParityRegion` objects */\r\n  public static createSimpleParityRegions(includeBCurves: boolean = false): ParityRegion[] {\r\n    const pointC = Point3d.create(-5, 0, 0);\r\n    const point0 = Point3d.create(0, 0, 0);\r\n    const point1 = Point3d.create(4, 2, 0);\r\n    const point2 = Point3d.create(6, 4, 0);\r\n    const point3 = Point3d.create(5, 5, 0);\r\n    const point4 = Point3d.create(8, 3, 0);\r\n\r\n    const reverseSweep = AngleSweep.createStartEndDegrees(0, -360);\r\n    const ax = 10.0;\r\n    const ay = 8.0;\r\n    const bx = -3.0;\r\n    const by = 2.0;\r\n    const r2 = 0.5;\r\n    const r2A = 2.5;\r\n    const pointA = point0.plusXYZ(ax, 0, 0);\r\n    const pointB = pointA.plusXYZ(0, ay, 0);\r\n    const pointC1 = point0.plusXYZ(0, ay);\r\n\r\n    const result = [\r\n      ParityRegion.create(\r\n        Loop.create(LineString3d.create(point0, pointA, pointB), Arc3d.createCircularStartMiddleEnd(pointB, pointC1, point0)!),\r\n        Loop.create(LineString3d.createRectangleXY(point1, bx, by))),\r\n      ParityRegion.create(\r\n        Loop.create(\r\n          Arc3d.createXY(pointC, 2.0)),\r\n        Loop.create(Arc3d.createXY(pointC, 1.0, reverseSweep))),\r\n      ParityRegion.create(\r\n        Loop.create(LineString3d.createRectangleXY(point0, ax, ay)),\r\n        Loop.create(LineString3d.createRectangleXY(point1, bx, by))),\r\n      ParityRegion.create(\r\n        Loop.create(LineString3d.createRectangleXY(point0, ax, ay)),\r\n        Loop.create(LineString3d.createRectangleXY(point1, bx, by)),\r\n        Loop.create(Arc3d.createXY(point2, r2, reverseSweep))),\r\n      ParityRegion.create(\r\n        Loop.create(LineString3d.createRectangleXY(point0, ax, ay)),\r\n        Loop.create(LineString3d.createRectangleXY(point1, bx, by)),\r\n        Loop.create(Arc3d.createXY(point2, r2, reverseSweep)),\r\n        Loop.create(LineString3d.createRectangleXY(point3, bx, by))),\r\n      ParityRegion.create(\r\n        Loop.create(LineString3d.create(point0, pointA, pointB), Arc3d.createCircularStartMiddleEnd(pointB, pointC1, point0)!),\r\n        Loop.create(LineString3d.createRectangleXY(point1, bx, by)),\r\n        Loop.create(Arc3d.create(point4, Vector3d.create(-r2, 0), Vector3d.create(0, r2A))),\r\n        Loop.create(LineString3d.createRectangleXY(point3, bx, by))),\r\n    ];\r\n    if (includeBCurves) {\r\n      const ey = 1.0;\r\n      result.push(\r\n        ParityRegion.create(Loop.create(\r\n          LineSegment3d.create(point0, pointA),\r\n          BSplineCurve3d.createUniformKnots(\r\n            [pointA, Point3d.create(ax + 1, ey),\r\n              Point3d.create(ax + 1, 2 * ey),\r\n              Point3d.create(ax + 2, 3 * ey),\r\n              Point3d.create(ax + 1, 4 * ey), pointB], 3)!,\r\n          Arc3d.createCircularStartMiddleEnd(pointB, pointC1, point0)!)));\r\n    }\r\n    return result;\r\n  }\r\n  /** Union region. */\r\n  public static createSimpleUnions(): UnionRegion[] {\r\n    const parityRegions = Sample.createSimpleParityRegions();\r\n    const parityRange = parityRegions[0].range();\r\n    const ax = 3.0;\r\n    const ay = 1.0;\r\n    const bx = 4.0;\r\n    const by = 2.0;\r\n    const result = [\r\n      UnionRegion.create(\r\n        Loop.create(LineString3d.createRectangleXY(Point3d.create(0, 0, 0), ax, ay)),\r\n        Loop.create(LineString3d.createRectangleXY(Point3d.create(0, 2 * ay, 0), bx, by))),\r\n      UnionRegion.create(\r\n        Loop.create(LineString3d.create(Sample.createRectangleXY(parityRange.low.x, parityRange.high.y + 0.5, parityRange.xLength(), parityRange.yLength()))),\r\n        parityRegions[0])];\r\n    return result;\r\n  }\r\n  /** Assorted unstructured curve sets. */\r\n  public static createBagOfCurves(): BagOfCurves[] {\r\n    const parityRegions = Sample.createSimpleParityRegions();\r\n    const loops = Sample.createSimpleLoops();\r\n    const result = [\r\n      BagOfCurves.create(loops[0], parityRegions[0], LineSegment3d.createXYXY(0, 1, 4, 2, 1)),\r\n      // a bag with just an arc\r\n      BagOfCurves.create(Arc3d.createUnitCircle()),\r\n      // a bag with just a line segment\r\n      BagOfCurves.create(LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(1, 1, 0))),\r\n      // a bag with just a linestring\r\n      BagOfCurves.create(LineString3d.create(Point3d.create(0, 0, 0), Point3d.create(1, 1, 0), Point3d.create(2, 1, 0))),\r\n    ];\r\n    return result;\r\n  }\r\n\r\n  /** Assorted smooth curve primitives:\r\n   * * line segments\r\n   * * arcs\r\n   */\r\n  public static createSmoothCurvePrimitives(size: number = 1.0): CurvePrimitive[] {\r\n    const alpha = 0.1;\r\n    const beta = 0.3;\r\n    return [\r\n      LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(size, 0, 0)),\r\n      LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(size, size, 0)),\r\n      Arc3d.create(\r\n        Point3d.create(0, 0, 0),\r\n        Vector3d.create(size, 0, 0),\r\n        Vector3d.create(0, size, 0),\r\n        AngleSweep.createStartEndDegrees(0, 90)) as Arc3d,\r\n      Arc3d.create(\r\n        Point3d.create(0, 0, 0),\r\n        Vector3d.create(size, 0, 0),\r\n        Vector3d.create(0, size, 0),\r\n        AngleSweep.createStartEndDegrees(-40, 270)) as Arc3d,\r\n      Arc3d.create(\r\n        Point3d.create(0, 0, 0),\r\n        Vector3d.create(size, alpha * size, 0),\r\n        Vector3d.create(-alpha * beta * size, beta * size, 0),\r\n        AngleSweep.createStartEndDegrees(-40, 270)) as Arc3d,\r\n    ];\r\n  }\r\n  /** assorted small polyface grids, possibly expanded by gridMultiplier */\r\n  public static createSimpleIndexedPolyfaces(gridMultiplier: number): IndexedPolyface[] {\r\n    return [\r\n      Sample.createTriangularUnitGridPolyface(\r\n        Point3d.create(),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitY(),\r\n        gridMultiplier * 3, 2 * gridMultiplier, false, false, false),\r\n      Sample.createTriangularUnitGridPolyface(\r\n        Point3d.create(),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitY(),\r\n        3 * gridMultiplier, 2 * gridMultiplier, true, false, false),\r\n      Sample.createTriangularUnitGridPolyface(\r\n        Point3d.create(),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitY(),\r\n        3 * gridMultiplier, 2 * gridMultiplier, false, true, false),\r\n      Sample.createTriangularUnitGridPolyface(\r\n        Point3d.create(),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitY(),\r\n        3 * gridMultiplier, 2 * gridMultiplier, false, false, true),\r\n      Sample.createTriangularUnitGridPolyface(\r\n        Point3d.create(),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitY(),\r\n        3 * gridMultiplier, 2 * gridMultiplier, true, true, true),\r\n    ];\r\n  }\r\n  /**\r\n   * Build a mesh that is a (possibly skewed) grid in a plane.\r\n   * @param origin \"lower left\" coordinate\r\n   * @param vectorX step in \"X\" direction\r\n   * @param vectorY step in \"Y\" direction\r\n   * @param numXVertices number of vertices in X direction\r\n   * @param numYVertices number of vertices in y direction\r\n   * @param createParams true to create parameters, with paramter value `(i,j)` for point at (0 based) vertex in x,y directions\r\n   * @param createNormals true to create a (single) normal indexed from all facets\r\n   * @param createColors true to create a single color on each quad.  (shared between its triangles)\r\n   * @note edgeVisible is false only on the diagonals\r\n   */\r\n  public static createTriangularUnitGridPolyface(origin: Point3d, vectorX: Vector3d, vectorY: Vector3d,\r\n    numXVertices: number, numYVertices: number, createParams: boolean = false, createNormals: boolean = false, createColors: boolean = false): IndexedPolyface {\r\n    const mesh = IndexedPolyface.create(createNormals, createParams, createColors);\r\n    const normal = vectorX.crossProduct(vectorY);\r\n    if (createNormals) {\r\n      normal.normalizeInPlace();\r\n      mesh.addNormalXYZ(normal.x, normal.y, normal.z);  // use XYZ to help coverage count!!\r\n    }\r\n\r\n    // Push to coordinate arrays\r\n    for (let j = 0; j < numYVertices; j++) {\r\n      for (let i = 0; i < numXVertices; i++) {\r\n        mesh.addPoint(origin.plus2Scaled(vectorX, i, vectorY, j));\r\n        if (createParams)\r\n          mesh.addParamUV(i, j);\r\n      }\r\n    }\r\n    let color = 10; // arbitrarily start at color 10 so colorIndex is different from color.\r\n    // Push elements to index array (vertices are calculated using i and j positioning for each point)\r\n    let thisColorIndex = 0;\r\n    for (let j = 0; j + 1 < numYVertices; j++) {\r\n      for (let i = 0; i + 1 < numXVertices; i++) {\r\n        const vertex00 = numXVertices * j + i;\r\n        const vertex10 = vertex00 + 1;\r\n        const vertex01 = vertex00 + numXVertices;\r\n        const vertex11 = vertex01 + 1;\r\n        // Push lower triangle\r\n        mesh.addPointIndex(vertex00, true);\r\n        mesh.addPointIndex(vertex10, true);\r\n        mesh.addPointIndex(vertex11, false);\r\n        // make color === faceIndex\r\n        if (createColors) {\r\n          thisColorIndex = mesh.addColor(color++);\r\n          mesh.addColorIndex(thisColorIndex);\r\n          mesh.addColorIndex(thisColorIndex);\r\n          mesh.addColorIndex(thisColorIndex);\r\n        }\r\n        // param indexing matches points .  .\r\n        if (createParams) {\r\n          mesh.addParamIndex(vertex00);\r\n          mesh.addParamIndex(vertex10);\r\n          mesh.addParamIndex(vertex11);\r\n        }\r\n\r\n        if (createNormals) {\r\n          mesh.addNormalIndex(0);\r\n          mesh.addNormalIndex(0);\r\n          mesh.addNormalIndex(0);\r\n        }\r\n        mesh.terminateFacet(false);\r\n\r\n        // upper triangle\r\n        mesh.addPointIndex(vertex11, true);\r\n        mesh.addPointIndex(vertex01, true);\r\n        mesh.addPointIndex(vertex00, false);\r\n        // make color === faceIndex\r\n        if (createColors) {\r\n          mesh.addColorIndex(thisColorIndex);\r\n          mesh.addColorIndex(thisColorIndex);\r\n          mesh.addColorIndex(thisColorIndex);\r\n        }\r\n        // param indexing matches points.\r\n        if (createParams) {\r\n          mesh.addParamIndex(vertex11);\r\n          mesh.addParamIndex(vertex01);\r\n          mesh.addParamIndex(vertex00);\r\n        }\r\n        if (createNormals) {\r\n          mesh.addNormalIndex(0);\r\n          mesh.addNormalIndex(0);\r\n          mesh.addNormalIndex(0);\r\n        }\r\n        mesh.terminateFacet(false);\r\n      }\r\n    }\r\n    return mesh;\r\n  }\r\n  /** Create an xy grid of points in single array with x varying fastest. */\r\n  public static createXYGrid(numU: number, numV: number, dX: number = 1.0, dY: number = 1.0): Point3d[] {\r\n    const points = [];\r\n    for (let j = 0; j < numV; j++) {\r\n      for (let i = 0; i < numU; i++) {\r\n        points.push(Point3d.create(i * dX, j * dY, 0));\r\n      }\r\n    }\r\n    return points;\r\n  }\r\n  /** Create simple bspline surface on xy plane grid. */\r\n  public static createXYGridBsplineSurface(numU: number, numV: number, orderU: number, orderV: number): BSplineSurface3d | undefined {\r\n    return BSplineSurface3d.create(\r\n      Sample.createXYGrid(numU, numV, 1.0, 1.0), numU, orderU, undefined, numV, orderV, undefined);\r\n  }\r\n  /**\r\n   * Create a bspline surface whose poles area on circular paths.\r\n   * * (BUT not weighted bspline, therefore although u and v isolines \"go around\" they are not true circles.)\r\n   * @param radiusU major radius\r\n   * @param radiusV minor radius\r\n   * @param numU number of facets around major hoop\r\n   * @param numV number of facets around minor hoop\r\n   * @param orderU major hoop order\r\n   * @param orderV minor hoop order\r\n   */\r\n  public static createPseudoTorusBsplineSurface(radiusU: number, radiusV: number, numU: number, numV: number, orderU: number, orderV: number): BSplineSurface3d | undefined {\r\n    const points = [];\r\n    const numUPole = numU + orderU - 1;\r\n    const numVPole = numV + orderV - 1;\r\n    const uKnots = KnotVector.createUniformWrapped(numU, orderU - 1, 0, 1);\r\n    const vKnots = KnotVector.createUniformWrapped(numV, orderV - 1, 0, 1);\r\n    const dURadians = 2.0 * Math.PI / numU;\r\n    const dVRadians = 2.0 * Math.PI / numV;\r\n    for (let iV = 0; iV < numVPole; iV++) {\r\n      const vRadians = iV * dVRadians;\r\n      const cV = Math.cos(vRadians);\r\n      const sV = Math.sin(vRadians);\r\n      for (let iU = 0; iU < numUPole; iU++) {\r\n        const uRadians = iU * dURadians;\r\n        const cU = Math.cos(uRadians);\r\n        const sU = Math.sin(uRadians);\r\n        const rho = radiusU + cV * radiusV;\r\n        points.push(Point3d.create(rho * cU, rho * sU, sV * radiusV));\r\n\r\n      }\r\n    }\r\n    const result = BSplineSurface3d.create(points, numUPole, orderU, uKnots.knots, numVPole, orderV, vKnots.knots);\r\n    if (result) {\r\n      result.setWrappable(0, BSplineWrapMode.OpenByAddingControlPoints);\r\n      result.setWrappable(1, BSplineWrapMode.OpenByAddingControlPoints);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a Bspline surface for a cone.\r\n   * @param centerA center at section A\r\n   * @param centerB center at section B\r\n   * @param radiusA radius at point A\r\n   * @param radiusB radius at point B\r\n   */\r\n  public static createConeBsplineSurface(\r\n    centerA: Point3d,\r\n    centerB: Point3d,\r\n    radiusA: number,\r\n    radiusB: number,\r\n    numSection: number): BSplineSurface3dH | undefined {\r\n    if (numSection < 2)\r\n      numSection = 2;\r\n    const controlPoints: number[][][] = [];\r\n    const numVPole = numSection;\r\n    const q1 = 0.25;\r\n    const q2 = 0.5;\r\n    const q3 = 0.75;\r\n\r\n    const uKnots = [0, 0, q1, q1, q2, q2, q3, q3, 1, 1];\r\n    const vKnots = [];\r\n    const dv = 1.0 / (numSection - 1);\r\n    for (let i = 0; i < numSection; i++) {\r\n      vKnots.push(i * dv);\r\n    }\r\n    const center = Point3d.create();\r\n    const vectorAB = Vector3d.createStartEnd(centerA, centerB);\r\n    const axes = Matrix3d.createRigidHeadsUp(vectorAB, AxisOrder.ZXY);\r\n    let r0, r90, v;\r\n    for (let iV = 0; iV < numVPole; iV++) {\r\n      v = iV * dv;\r\n      centerA.interpolate(v, centerB, center);\r\n      r0 = r90 = Geometry.interpolate(radiusA, v, radiusB);\r\n      controlPoints.push(Sample.createBsplineArc90SectionToXYZWArrays(center, axes, r0, r90, false));\r\n    }\r\n\r\n    const result = BSplineSurface3dH.createGrid(controlPoints,\r\n      WeightStyle.WeightsSeparateFromCoordinates,\r\n      3, uKnots, 2, vKnots);\r\n    // if (result) {\r\n    // result.setWrappable(0, BSplineWrapMode.OpenByAddingControlPoints);\r\n    // result.setWrappable(1, BSplineWrapMode.OpenByAddingControlPoints);\r\n    // }\r\n    return result;\r\n  }\r\n  /** Create bspline surface on xy grid with weights. */\r\n  public static createWeightedXYGridBsplineSurface(\r\n    numU: number, numV: number, orderU: number, orderV: number,\r\n    weight00: number = 1.0,\r\n    weight10: number = 1.0,\r\n    weight01: number = 1.0,\r\n    weight11: number = 1.0): BSplineSurface3dH | undefined {\r\n    const xyzPoles = Sample.createXYGrid(numU, numV, 1.0, 1.0);\r\n    const weights = [];\r\n    for (let i = 0; i < numU; i++)\r\n      for (let j = 0; j < numV; j++) {\r\n        const wu0 = Geometry.interpolate(weight00, i / (numU - 1), weight10);\r\n        const wu1 = Geometry.interpolate(weight01, i / (numU - 1), weight11);\r\n        weights.push(Geometry.interpolate(wu0, j / (numV - 1), wu1));\r\n      }\r\n\r\n    return BSplineSurface3dH.create(xyzPoles,\r\n      weights,\r\n      numU, orderU, undefined,\r\n      numV, orderV, undefined);\r\n  }\r\n  /** assorted linear sweeps */\r\n  public static createSimpleLinearSweeps(): LinearSweep[] {\r\n    const result: LinearSweep[] = [];\r\n    const base = Loop.create(LineString3d.createRectangleXY(Point3d.create(), 2, 3));\r\n    const vectorZ = Vector3d.create(0, 0, 1.234);\r\n    const vectorQ = Vector3d.create(0.1, 0.21, 1.234);\r\n    result.push(LinearSweep.create(base, vectorZ, false) as LinearSweep);\r\n    result.push(LinearSweep.create(base, vectorZ, true) as LinearSweep);\r\n    result.push(LinearSweep.create(base, vectorQ, false) as LinearSweep);\r\n    result.push(LinearSweep.create(base, vectorQ, true) as LinearSweep);\r\n    result.push(LinearSweep.create(Sample.createCappedArcLoop(5, -45, 90), vectorQ, true) as LinearSweep);\r\n    for (const curve of Sample.createSmoothCurvePrimitives()) {\r\n      const path = Path.create(curve);\r\n      result.push(LinearSweep.create(path, vectorZ, false)!);\r\n    }\r\n    // coordinates for a clearly unclosed linestring ....\r\n    const xyPoints = [\r\n      Point2d.create(0, 0),\r\n      Point2d.create(1, 0),\r\n      Point2d.create(1, 1)];\r\n\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, false)!);\r\n    // this forces artificial closure point . . .\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, true)!);\r\n\r\n    // add a not-quite-exact closure point ...\r\n    const e = 1.0e-11;\r\n    xyPoints.push(Point2d.create(e, e));\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, false)!);\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, true)!);\r\n    // make it a better closure\r\n    xyPoints.pop();\r\n    xyPoints.push(xyPoints[0]);\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, false)!);\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, true)!);\r\n    // negative sweep ...\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, -3, true)!);\r\n    return result;\r\n  }\r\n  /**\r\n   * Create an array of primitives with an arc centered at origin and a line segment closing back to the arc start.\r\n   * This can be bundled into Path or Loop by caller.\r\n   */\r\n  public static createCappedArcPrimitives(radius: number, startDegrees: number, endDegrees: number): CurvePrimitive[] {\r\n    const arc = Arc3d.create(\r\n      Point3d.create(0, 0, 0),\r\n      Vector3d.unitX(radius),\r\n      Vector3d.unitY(radius),\r\n      AngleSweep.createStartEndDegrees(startDegrees, endDegrees));\r\n    return [arc, LineSegment3d.create(arc.fractionToPoint(1.0), arc.fractionToPoint(0.0))];\r\n  }\r\n  /** Return a Path structure for a segment of arc, with closure segment */\r\n  public static createCappedArcPath(radius: number, startDegrees: number, endDegrees: number): Path {\r\n    return Path.createArray(Sample.createCappedArcPrimitives(radius, startDegrees, endDegrees));\r\n  }\r\n  /** Return a Loop structure for a segment of arc, with closure segment */\r\n  public static createCappedArcLoop(radius: number, startDegrees: number, endDegrees: number): Loop {\r\n    return Loop.createArray(Sample.createCappedArcPrimitives(radius, startDegrees, endDegrees));\r\n  }\r\n  /** Create assorted rotational sweeps. */\r\n  public static createSimpleRotationalSweeps(): RotationalSweep[] {\r\n    const result: RotationalSweep[] = [];\r\n    // rectangle in xy plane\r\n    const base = Loop.create(LineString3d.createRectangleXY(Point3d.create(1, 0, 0), 2, 3));\r\n    // rotate around the y axis\r\n    for (const axis of [\r\n      Ray3d.createXYZUVW(0, 0, 0, 0, 1, 0),\r\n      Ray3d.createXYZUVW(5, 0, 0, 0, 1, 0),\r\n      Ray3d.createXYZUVW(-1, 0, 0, -1, 1, 0)]) {\r\n      result.push(RotationalSweep.create(base, axis, Angle.createDegrees(45.0), false) as RotationalSweep);\r\n      result.push(RotationalSweep.create(base, axis, Angle.createDegrees(150.0), true) as RotationalSweep);\r\n    }\r\n\r\n    return result;\r\n  }\r\n  /** Create assorted spheres */\r\n  public static createSpheres(includeEllipsoidal: boolean = false): Sphere[] {\r\n    const result: Sphere[] = [];\r\n    result.push(Sphere.createCenterRadius(Point3d.create(0, 0, 0), 1.0));\r\n    result.push(Sphere.createCenterRadius(Point3d.create(1, 2, 3), 3.0));\r\n    const s1 = Sphere.createCenterRadius(Point3d.create(1, 2, 3), 2.0,\r\n      AngleSweep.createStartEndDegrees(-45, 80));\r\n    s1.capped = true;\r\n    result.push(s1);\r\n    // still a sphere, but with axes KIJ . .\r\n    const s2 = Sphere.createFromAxesAndScales(\r\n      Point3d.create(1, 2, 3),\r\n      Matrix3d.createRowValues(\r\n        0, 1, 0,\r\n        0, 0, 1,\r\n        1, 0, 0),\r\n      4, 4, 4,\r\n      AngleSweep.createStartEndDegrees(-45, 45), true)!;\r\n    result.push(s2);\r\n    if (includeEllipsoidal)\r\n      result.push(Sphere.createDgnSphere(\r\n        Point3d.create(1, 2, 3),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitZ(), 3, 2, AngleSweep.createFullLatitude(), false)!);\r\n    return result;\r\n  }\r\n  /** Create true (non-spherical) ellipsoids. */\r\n  public static createEllipsoids(): Sphere[] {\r\n    return [\r\n      Sphere.createEllipsoid(\r\n        Transform.createOriginAndMatrix(\r\n          Point3d.create(0, 0, 0),\r\n          Matrix3d.createRowValues(\r\n            4, 1, 1,\r\n            1, 4, 1,\r\n            0.5, 0.2, 5)),\r\n        AngleSweep.createFullLatitude(),\r\n        true)!];\r\n  }\r\n  /** Create assorted cones. */\r\n  public static createCones(): Cone[] {\r\n    const result: Cone[] = [];\r\n    const origin = Point3d.create(0, 0, 0);\r\n    const topZ = Point3d.create(0, 0, 5);\r\n    const centerA = Point3d.create(1, 2, 1);\r\n    const centerB = Point3d.create(2, 3, 8);\r\n    result.push(Cone.createAxisPoints(Point3d.create(0, 0, 0), Point3d.create(0, 0, 1), 0.5, 0.5, false) as Cone);\r\n\r\n    result.push(Cone.createAxisPoints(centerA, centerB, 0.5, 0.5, false) as Cone);\r\n    result.push(Cone.createAxisPoints(origin, topZ, 1.0, 0.2, true) as Cone);\r\n    result.push(Cone.createAxisPoints(centerA, centerB, 0.2, 0.5, false) as Cone);\r\n    result.push(Cone.createAxisPoints(origin, centerB, 1.0, 0.0, false) as Cone);\r\n    result.push(Cone.createAxisPoints(topZ, origin, 0.0, 1.0, true) as Cone);\r\n    return result;\r\n  }\r\n  /** Create assorted Torus Pipes */\r\n  public static createTorusPipes(): TorusPipe[] {\r\n    const result: TorusPipe[] = [];\r\n    const center = Point3d.create(1, 2, 3);\r\n\r\n    const frame = Matrix3d.createRotationAroundVector(\r\n      Vector3d.create(1, 2, 3), Angle.createRadians(10)) as Matrix3d;\r\n    const vectorX = frame.columnX();\r\n    const vectorY = frame.columnY();\r\n    const vectorZ = frame.columnZ();\r\n    result.push(TorusPipe.createInFrame(Transform.createIdentity(), 5.0, 0.8, Angle.create360(), false)!);\r\n    result.push(TorusPipe.createInFrame(Transform.createIdentity(), 5.0, 1.0, Angle.createDegrees(90), true)!);\r\n    result.push(TorusPipe.createDgnTorusPipe(center, vectorX, vectorY, 10, 1, Angle.createDegrees(180), true)!);\r\n\r\n    result.push(TorusPipe.createDgnTorusPipe(center, vectorY, vectorZ, 10, 1, Angle.createDegrees(45), true) as TorusPipe);\r\n\r\n    return result;\r\n  }\r\n  /** Create assorted boxes. */\r\n  public static createBoxes(capped: boolean = true): Box[] {\r\n    const result: Box[] = [];\r\n    const cornerA = Point3d.create(1, 2, 3);\r\n    const aX = 3.0;\r\n    const aY = 2.0;\r\n    const bX = 1.5;\r\n    const bY = 1.0;\r\n    const h = 5.0;\r\n    const frame = Matrix3d.createRotationAroundVector(\r\n      Vector3d.create(0, 0, 1), Angle.createDegrees(10)) as Matrix3d;\r\n    const vectorX = frame.columnX();\r\n    const vectorY = frame.columnY();\r\n    const cornerB = Matrix3d.xyzPlusMatrixTimesCoordinates(cornerA, frame, 0, 0, h);\r\n    result.push(Box.createDgnBox(cornerA, Vector3d.unitX(), Vector3d.unitY(),\r\n      cornerB, aX, aY, aX, aY, capped) as Box);\r\n\r\n    result.push(Box.createDgnBox(cornerA, Vector3d.unitX(), Vector3d.unitY(),\r\n      cornerB, aX, aY, bX, bY, capped) as Box);\r\n    result.push(Box.createDgnBox(cornerA, vectorX, vectorY, cornerB, aX, aY, bX, bY, capped) as Box);\r\n\r\n    const frameY = Matrix3d.createRotationAroundVector(\r\n      Vector3d.create(0, 1, 0), Angle.createDegrees(10)) as Matrix3d;\r\n    result.push(Box.createDgnBox(cornerA, frameY.columnX(), frameY.columnY(),\r\n      cornerA.plusScaled(frameY.columnZ(), h), aX, aY, bX, bY, capped) as Box);\r\n    return result;\r\n  }\r\n  /** create an array of points for a rectangle with corners (x0,y0,z) and (x1,y1,z)\r\n   */\r\n  public static createRectangle(x0: number, y0: number, x1: number, y1: number, z: number = 0.0, closed: boolean = false): Point3d[] {\r\n    const points = [\r\n      Point3d.create(x0, y0, z),\r\n      Point3d.create(x1, y0, z),\r\n      Point3d.create(x1, y1, z),\r\n      Point3d.create(x0, y1, z),\r\n    ];\r\n    if (closed)\r\n      points.push(Point3d.create(x0, y0, z));\r\n    return points;\r\n  }\r\n  /** create an array of points for a rectangle with corners of a Range2d.\r\n   */\r\n  public static createRectangleInRange2d(range: Range2d, z: number = 0.0, closed: boolean = false): Point3d[] {\r\n    const x0 = range.low.x;\r\n    const x1 = range.high.x;\r\n    const y0 = range.low.y;\r\n    const y1 = range.high.y;\r\n    return this.createRectangle(x0, y0, x1, y1, z, closed);\r\n  }\r\n\r\n  /** Create assorted ruled sweeps */\r\n  public static createRuledSweeps(includeParityRegion: boolean = false, includeBagOfCurves: boolean = false): RuledSweep[] {\r\n    const allSweeps = [];\r\n    const contour0 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 3, 2, 0)));\r\n    const contour1 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 3, 2.5, 2)));\r\n    const contour2 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 4, 3.5, 4)));\r\n    const contour3 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 2, 1, 7)));\r\n    const allContours = [contour0, contour1, contour2];\r\n    allSweeps.push(RuledSweep.create([contour0, contour1], true) as RuledSweep);\r\n    allSweeps.push(RuledSweep.create([contour0, contour1, contour2], true) as RuledSweep);\r\n    allSweeps.push(RuledSweep.create([contour0, contour1, contour2, contour3], true) as RuledSweep);\r\n    allSweeps.push(RuledSweep.create(allContours, false) as RuledSweep);\r\n\r\n    const curves = Sample.createSmoothCurvePrimitives();\r\n    for (const c of curves) {\r\n      const frame = c.fractionToFrenetFrame(0.0);\r\n      if (frame) {\r\n        const perpVector = frame.matrix.columnZ();\r\n        perpVector.scaleInPlace(10.0);\r\n        const c1 = c.cloneTransformed(Transform.createTranslation(perpVector)) as CurvePrimitive;\r\n        allSweeps.push(RuledSweep.create([Path.create(c), Path.create(c1)], false)!);\r\n      }\r\n    }\r\n    if (includeParityRegion) {\r\n      const outer = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 5, 6, 0)));\r\n      const inner = Loop.create(LineString3d.create(this.createRectangleXY(1, 1, 2, 3, 0)));\r\n      const contourA = ParityRegion.create(outer, inner);\r\n      const contourB = contourA.clone();\r\n      contourB.tryTranslateInPlace(0, 0, 2);\r\n      allSweeps.push(RuledSweep.create([contourA, contourB], false)!);\r\n    }\r\n    if (includeBagOfCurves) {\r\n      const contourA = BagOfCurves.create(LineSegment3d.createXYZXYZ(1, 1, 0, 3, 1, 0));\r\n      const contourB = BagOfCurves.create(LineSegment3d.createXYZXYZ(1, 1, 1, 3, 1, 1));\r\n      allSweeps.push(RuledSweep.create([contourA, contourB], false)!);\r\n    }\r\n\r\n    return allSweeps;\r\n  }\r\n  /**\r\n   * Uniformly spaced numbers\r\n   * @param a0 first entry\r\n   * @param delta step between entries\r\n   * @param n number of entries\r\n   */\r\n  public static createGrowableArrayCountedSteps(a0: number, delta: number, n: number): GrowableFloat64Array {\r\n    const data = new GrowableFloat64Array(n);\r\n    for (let i = 0; i < n; i++)\r\n      data.push(a0 + i * delta);\r\n    return data;\r\n  }\r\n  /**\r\n   * Create points on a unit circle\r\n   * @param radius first entry\r\n   * @param numEdge number of edges of chorded circle.  Angle step is 2PI/numEdge (whether or not closed)\r\n   * @param closed true to include final point (i.e. return numEdge+1 points)\r\n   */\r\n  public static createGrowableArrayCirclePoints(radius: number, numEdge: number, closed: boolean = false,\r\n    centerX: number = 0, centerY: number = 0, data?: GrowableXYZArray): GrowableXYZArray {\r\n    if (!data) data = new GrowableXYZArray();\r\n    data.ensureCapacity(numEdge + (closed ? 1 : 0));\r\n    const delta = 2.0 * Math.PI / numEdge;\r\n    for (let i = 0; i < numEdge; i++) {\r\n      const radians = i * delta;\r\n      data.push(Point3d.create(centerX + radius * Math.cos(radians), centerY + radius * Math.sin(radians)));\r\n    }\r\n    return data;\r\n  }\r\n\r\n  private static pushIfDistinct(points: Point3d[], xyz: Point3d, tol: number = 1.0e-12) {\r\n    if (points.length === 0 || points[points.length - 1].distanceXY(xyz) > tol)\r\n      points.push(xyz);\r\n  }\r\n\r\n  private static appendToFractalEval(points: Point3d[], pointA: Point3d, pointB: Point3d, pattern: Point2d[], numRecursion: number, perpendicularFactor: number) {\r\n    const point0 = pointA.clone();\r\n    Sample.pushIfDistinct(points, pointA);\r\n\r\n    for (const uv of pattern) {\r\n      const point1 = pointA.interpolatePerpendicularXY(uv.x, pointB, perpendicularFactor * uv.y);\r\n      if (numRecursion > 0)\r\n        Sample.appendToFractalEval(points, point0, point1, pattern, numRecursion - 1, perpendicularFactor);\r\n      Sample.pushIfDistinct(points, point1);\r\n      point0.setFrom(point1);\r\n    }\r\n\r\n    Sample.pushIfDistinct(points, pointB);\r\n  }\r\n\r\n  /**\r\n   * For each edge of points, construct a transform (with scale, rotate, and translate) that spreads the patter out along the edge.\r\n   * Repeat recursively for each edge\r\n   * @returns Returns an array of recursively generated fractal points\r\n   * @param poles level-0 (coarse) polygon whose edges are to be replaced by recursive fractals\r\n   * @param pattern pattern to map to each edge of poles (and to edges of the recursion)\r\n   * @param numRecursion  number of recursions\r\n   * @param perpendicularFactor factor to apply to perpendicular sizing.\r\n   */\r\n  public static createRecursiveFractalPolygon(poles: Point3d[], pattern: Point2d[], numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const points: Point3d[] = [];\r\n    Sample.pushIfDistinct(points, poles[0]);\r\n    for (let i = 0; i + 1 < poles.length; i++) {\r\n      if (numRecursion > 0)\r\n        Sample.appendToFractalEval(points, poles[i], poles[i + 1], pattern, numRecursion - 1, perpendicularFactor);\r\n      Sample.pushIfDistinct(points, poles[i + 1]);\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /** Primary shape is a \"triangle\" with lower edge pushed in so it becomes a mild nonconvex quad.\r\n   *  Fractal effects are gentle.\r\n   */\r\n  public static nonConvexQuadSimpleFractal(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.5, 0.1),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(0, 0, 0),\r\n      Point3d.create(0.6, 0.1, 0),\r\n      Point3d.create(1, 0.1, 0),\r\n      Point3d.create(0.6, 1, 0),\r\n      Point3d.create(),\r\n    ];\r\n    return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n\r\n  /** create a diamond with convex fractal */\r\n  public static createFractalDiamondConvexPattern(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.3, 0.05),\r\n      Point2d.create(0.5, 0.10),\r\n      Point2d.create(0.7, 0.04),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(0, -1, 0),\r\n      Point3d.create(1, 0, 0),\r\n      Point3d.create(0, 1, 0),\r\n      Point3d.create(-1, 0, 0),\r\n      Point3d.create(0, -1, 0),\r\n    ];\r\n    return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n  /** Create l on a square, with pattern shift to both directions. */\r\n  public static createFractalSquareReversingPattern(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.25, 0),\r\n      Point2d.create(0.5, 0.2),\r\n      Point2d.create(0.75, -0.1),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(),\r\n      Point3d.create(1, 0, 0),\r\n      Point3d.create(1, 1, 0),\r\n      Point3d.create(0, 1, 0),\r\n      Point3d.create(0, 0, 0),\r\n    ];\r\n    return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n  /** Create a fractal on a non-convex base and reversing pattern */\r\n  public static createFractalHatReversingPattern(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.25, 0),\r\n      Point2d.create(0.25, 0.1),\r\n      Point2d.create(0.50, 0.1),\r\n      Point2d.create(0.50, -0.1),\r\n      Point2d.create(0.75, -0.1),\r\n      Point2d.create(0.75, 0),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(),\r\n      Point3d.create(1, 0, 0),\r\n      Point3d.create(1, 1, 0),\r\n      Point3d.create(0, 1, 0),\r\n      Point3d.create(0, 0, 0),\r\n    ];\r\n    return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n  /** Create a fractal on a primary L shape with a reversing pattern */\r\n  public static createFractalLReversingPattern(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.25, 0),\r\n      Point2d.create(0.5, 0.2),\r\n      Point2d.create(0.75, -0.1),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(),\r\n      Point3d.create(1, 0, 0),\r\n      Point3d.create(1, 1, 0),\r\n      Point3d.create(2, 2, 0),\r\n      Point3d.create(2, 3, 0),\r\n      Point3d.create(0, 3, 0),\r\n      Point3d.create(),\r\n    ];\r\n    return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n\r\n  /** Fractal with fewer concavity changes.... */\r\n  public static createFractalLMildConcavePatter(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.25, 0.05),\r\n      Point2d.create(0.5, 0.15),\r\n      Point2d.create(0.75, 0.05),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(),\r\n      Point3d.create(1, 0, 0),\r\n      Point3d.create(1, 1, 0),\r\n      Point3d.create(2, 2, 0),\r\n      Point3d.create(1.5, 3, 0),\r\n      Point3d.create(0, 3, 0),\r\n      Point3d.create(),\r\n    ];\r\n    return Sample.createRecursiveFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n  /** append interpolated points from the array tail to the target. */\r\n  public static appendSplits(points: Point3d[], target: Point3d, numSplit: number, includeTarget: boolean) {\r\n    const pointA = points[points.length - 1];\r\n    for (let i = 0; i < numSplit; i++)\r\n      points.push(pointA.interpolate(i / numSplit, target));\r\n    if (includeTarget)\r\n      points.push(target);\r\n  }\r\n  /**\r\n   * Triangle with 3 given vertices, and indicated extra points on each each.\r\n   * @param numSplitAB number of extra points on edge AB\r\n   * @param numSplitBC number of extra points on edge BC\r\n   * @param numSplitCA number of extra points on edge CA\r\n   * @param wrap true to replicate vertexA at end\r\n   * @param xyzA vertexA\r\n   * @param xyzB vertexB\r\n   * @param xyzC vertexC\r\n   */\r\n  public static createTriangleWithSplitEdges(\r\n    numSplitAB: number,\r\n    numSplitBC: number,\r\n    numSplitCA: number,\r\n    wrap: boolean = true,\r\n    xyzA: Point3d = Point3d.create(0, 0, 0),\r\n    xyzB: Point3d = Point3d.create(1, 0, 0),\r\n    xyzC: Point3d = Point3d.create(0, 1, 0)): Point3d[] {\r\n    const result = [xyzA.clone()];\r\n    Sample.appendSplits(result, xyzB, numSplitAB, true);\r\n    Sample.appendSplits(result, xyzC, numSplitBC, true);\r\n    Sample.appendSplits(result, xyzA, numSplitCA, wrap);\r\n    return result;\r\n  }\r\n  /** Create a box (xyz) from half-lengths and center. */\r\n  public static createCenteredBoxEdges(ax: number = 1, ay: number = 1, az: number = 0, cx: number = 0, cy: number = 0, cz: number = 0,\r\n    geometry?: GeometryQuery[]): GeometryQuery[] {\r\n    if (!geometry)\r\n      geometry = [];\r\n    const x0 = cx - ax;\r\n    const y0 = cy - ay;\r\n    const z0 = cz - az;\r\n\r\n    const x1 = cx + ax;\r\n    const y1 = cy + ay;\r\n    const z1 = cz + az;\r\n\r\n    for (const z of [z0, z1]) {\r\n      geometry.push(\r\n        LineString3d.create(\r\n          Point3d.create(x0, y0, z),\r\n          Point3d.create(x1, y0, z),\r\n          Point3d.create(x1, y1, z),\r\n          Point3d.create(x0, y1, z),\r\n          Point3d.create(x0, y0, z)));\r\n    }\r\n    geometry.push(LineSegment3d.createXYZXYZ(x0, y0, z0, x0, y0, z1));\r\n    geometry.push(LineSegment3d.createXYZXYZ(x1, y0, z0, x1, y0, z1));\r\n    geometry.push(LineSegment3d.createXYZXYZ(x1, y1, z0, x1, y1, z1));\r\n    geometry.push(LineSegment3d.createXYZXYZ(x0, y1, z0, x0, y1, z1));\r\n    return geometry;\r\n  }\r\n  /** Assorted transition spirals\r\n   * * (All combinations of bearing radius bearing radius length subsets.)\r\n   */\r\n  public static createSimpleTransitionSpirals(): TransitionSpiral3d[] {\r\n    // 5 spirals exercise the intricate \"4 out of 5\" input rules for spirals . ..\r\n    const r1 = 1000.0;\r\n    const r0 = 0.0;\r\n    const averageCurvature = TransitionSpiral3d.averageCurvatureR0R1(r0, r1);\r\n    const arcLength = 100.0;\r\n    const dThetaRadians = arcLength * averageCurvature;\r\n\r\n    return [\r\n      TransitionSpiral3d.create(\"clothoid\", r0, r1,\r\n        Angle.createDegrees(0), Angle.createRadians(dThetaRadians),\r\n        undefined,\r\n        undefined, Transform.createIdentity())!,\r\n      TransitionSpiral3d.create(\"clothoid\", r0, r1,\r\n        Angle.createDegrees(0), undefined,\r\n        arcLength,\r\n        undefined, Transform.createIdentity())!,\r\n      TransitionSpiral3d.create(\"clothoid\", r0, r1,\r\n        undefined, Angle.createRadians(dThetaRadians),\r\n        arcLength,\r\n        undefined, Transform.createIdentity())!,\r\n      TransitionSpiral3d.create(\"clothoid\", r0, undefined,\r\n        Angle.createDegrees(0), Angle.createRadians(dThetaRadians),\r\n        arcLength,\r\n        undefined, Transform.createIdentity())!,\r\n      TransitionSpiral3d.create(\"clothoid\", undefined, r1,\r\n        Angle.createDegrees(0), Angle.createRadians(dThetaRadians),\r\n        arcLength,\r\n        undefined, Transform.createIdentity())!,\r\n      TransitionSpiral3d.create(\"clothoid\", r0, r1,\r\n        Angle.createDegrees(0), Angle.createRadians(dThetaRadians), undefined,\r\n        Segment1d.create(0, 0.5),\r\n        Transform.createOriginAndMatrix(Point3d.create(1, 2, 0),\r\n          Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createDegrees(15))!))!,\r\n    ];\r\n  }\r\n  /** Create a Bezier curve with significant twist effects\r\n   * * r and theta are circle in xy plane at steps in thetaStepper\r\n   * * z varies with sin(phi) at steps in phiStepper.\r\n   */\r\n  public static createTwistingBezier(order: number,\r\n    x0: number,\r\n    y0: number,\r\n    r: number,\r\n    thetaStepper: AngleSweep,\r\n    phiStepper: AngleSweep,\r\n    weightInterval?: Segment1d,\r\n  ): CurvePrimitive | undefined {\r\n\r\n    if (weightInterval !== undefined) {\r\n      const points = [];\r\n      for (let i = 0; i < order; i++) {\r\n        const theta = thetaStepper.fractionToRadians(i);\r\n        const phi = phiStepper.fractionToRadians(i);\r\n        const weight = weightInterval.fractionToPoint(i / (order - 1));\r\n        points.push(Point4d.create(\r\n          weight * (x0 + r * Math.cos(theta)),\r\n          weight * (y0 + r * Math.sin(theta)),\r\n          weight * Math.sin(phi), weight));\r\n      }\r\n      return BezierCurve3dH.create(points)!;\r\n    } else {\r\n      const points = [];\r\n      for (let i = 0; i < order; i++) {\r\n        const theta = thetaStepper.fractionToRadians(i);\r\n        const phi = phiStepper.fractionToRadians(i);\r\n        points.push(Point3d.create(x0 + r * Math.cos(theta), y0 + r * Math.sin(theta), Math.sin(phi)));\r\n      }\r\n      return BezierCurve3d.create(points);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Create various curve chains with distance indexing.\r\n   * * LineSegment\r\n   * * CircularArc\r\n   * * LineString\r\n   * * order 3 bspline\r\n   * * order 4 bspline\r\n   * * alternating lines and arcs\r\n   */\r\n  public static createCurveChainWithDistanceIndex(): CurveChainWithDistanceIndex[] {\r\n    const pointsA = [Point3d.create(0, 0, 0), Point3d.create(1, 3, 0), Point3d.create(2, 4, 0), Point3d.create(3, 3, 0), Point3d.create(4, 0, 0)];\r\n    const result = [];\r\n    // one singleton per basic curve type ...\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(5, 0, 0))))!);\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(Arc3d.createCircularStartMiddleEnd(\r\n        Point3d.create(0, 0, 0), Point3d.create(3, 3, 0), Point3d.create(6, 0, 0))!))!);\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(LineString3d.create(pointsA)))!);\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(BSplineCurve3d.createUniformKnots(pointsA, 3)!))!);\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(BSplineCurve3d.createUniformKnots(pointsA, 4)!))!);\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(\r\n        LineSegment3d.create(pointsA[0], pointsA[1]),\r\n        Arc3d.createCircularStartMiddleEnd(pointsA[1], pointsA[2], pointsA[3])!,\r\n        LineSegment3d.create(pointsA[3], pointsA[4])))!);\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a square wave path.\r\n   * @param numTooth number of teeth.\r\n   * @param dxA x size of \"A\" part\r\n   * @param dxB x size of \"B\" part\r\n   * @param yA y for A part\r\n   * @param yB y for B part\r\n   * @param structure 1 for line segments, 2 for one linestring per tooth, 0 for single linestring\r\n   */\r\n  public static createSquareWavePath(numTooth: number, dxA: number, dxB: number, yA: number, yB: number, structure: number): Path {\r\n    const dxAB = dxA + dxB;\r\n    const path = Path.create();\r\n    // build the whole linestring ...\r\n    const allPoints = new GrowableXYZArray(4 * numTooth);\r\n    let x2 = 0.0;\r\n    for (let i = 0; i < numTooth; i++) {\r\n      const x0 = i * dxAB;\r\n      const x1 = x0 + dxA;\r\n      x2 = (i + 1) * dxAB;\r\n      allPoints.pushXYZ(x0, yA, 0);\r\n      allPoints.pushXYZ(x1, yA, 0.0);\r\n      allPoints.pushXYZ(x1, yB, 0.0);\r\n      allPoints.pushXYZ(x2, yB, 0.0);\r\n    }\r\n    allPoints.pushXYZ(x2, yA, 0.0);\r\n\r\n    const numPoints = allPoints.length;\r\n\r\n    if (structure === 1) {\r\n      const pointA = Point3d.create();\r\n      const pointB = Point3d.create();\r\n      allPoints.getPoint3dAtUncheckedPointIndex(0, pointA);\r\n      for (let i1 = 0; i1 + 1 < numPoints; i1++) {\r\n        allPoints.getPoint3dAtUncheckedPointIndex(i1, pointB);\r\n        path.tryAddChild(LineSegment3d.create(pointA, pointB));\r\n        pointA.setFromPoint3d(pointB);\r\n      }\r\n    } else if (structure === 2) {\r\n      for (let i0 = 0; i0 + 4 < numPoints; i0 += 4) {\r\n        const ls = LineString3d.create();\r\n        ls.addSteppedPoints(allPoints, i0, 1, 5);\r\n        path.tryAddChild(ls);\r\n      }\r\n\r\n    } else {\r\n      const ls = LineString3d.create();\r\n      ls.addSteppedPoints(allPoints, 0, 1, numPoints);\r\n      path.tryAddChild(ls);\r\n\r\n    }\r\n    return path;\r\n  }\r\n\r\n  /**\r\n   * Create various elliptic arcs\r\n   * * circle with vector0, vector90 aligned with x,y\r\n   * * circle with axes rotated\r\n   * *\r\n   * @param radiusRatio = vector90.magnitude / vector0.magnitude\r\n   */\r\n  public static createArcs(radiusRatio: number = 1.0, sweep: AngleSweep = AngleSweep.create360()): Arc3d[] {\r\n    const arcs = [];\r\n    const center0 = Point3d.create(0, 0, 0);\r\n    const a = 1.0;\r\n    const b = radiusRatio;\r\n    const direction0 = Vector3d.createPolar(a, Angle.createDegrees(35.0));\r\n    const direction90 = direction0.rotate90CCWXY();\r\n    direction90.scaleInPlace(radiusRatio);\r\n    arcs.push(Arc3d.create(center0, Vector3d.create(a, 0, 0), Vector3d.create(0, b, 0), sweep));\r\n    arcs.push(Arc3d.create(center0, direction0, direction90, sweep));\r\n    return arcs;\r\n  }\r\n  /**\r\n   * Create many arcs, optionally including skews\r\n   * * @param skewFactor array of skew factors.  for each skew factor, all base arcs are replicated with vector90 shifted by the factor times vector0\r\n   */\r\n  public static createManyArcs(skewFactors: number[] = []): Arc3d[] {\r\n    const result: Arc3d[] = [];\r\n    const sweep1 = AngleSweep.createStartEndDegrees(-10, 75);\r\n    const sweep2 = AngleSweep.createStartEndDegrees(160.0, 380.0);\r\n    for (const arcs of [\r\n      Sample.createArcs(1.0), Sample.createArcs(0.5),\r\n      Sample.createArcs(1.0, sweep1), Sample.createArcs(0.3, sweep2)]) {\r\n      for (const arc of arcs)\r\n        result.push(arc);\r\n    }\r\n    const numBase = result.length;\r\n    for (const skewFactor of skewFactors) {\r\n      for (let i = 0; i < numBase; i++) {\r\n        const originalArc = result[i];\r\n        result.push(Arc3d.create(originalArc.center, originalArc.vector0, originalArc.vector90.plusScaled(originalArc.vector0, skewFactor), originalArc.sweep));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create edges of a range box.\r\n   * * Line strings on low and high z\r\n   * * single lines on each low z to high z edge.\r\n   * * @param range (possibly null) range\r\n   */\r\n  public static createRangeEdges(range: Range3d): BagOfCurves | undefined {\r\n    if (range.isNull)\r\n      return undefined;\r\n    const corners = range.corners();\r\n\r\n    return BagOfCurves.create(\r\n      LineString3d.create(corners[0], corners[1], corners[3], corners[2], corners[0]),\r\n      LineString3d.create(corners[4], corners[5], corners[7], corners[6], corners[4]),\r\n      LineSegment3d.create(corners[0], corners[4]),\r\n      LineSegment3d.create(corners[1], corners[5]),\r\n      LineSegment3d.create(corners[2], corners[6]),\r\n      LineSegment3d.create(corners[3], corners[7]));\r\n  }\r\n  /** Create swept \"solids\" that can be capped.\r\n   * * At least one of each solid type.\r\n   * * each is within 10 of the origin all directions.\r\n   */\r\n  public static createClosedSolidSampler(capped: boolean): SolidPrimitive[] {\r\n    const result = [];\r\n    result.push(Box.createRange(Range3d.createXYZXYZ(0, 0, 0, 3, 2, 5), capped)!);\r\n\r\n    result.push(Cone.createAxisPoints(Point3d.create(0, 0, 0), Point3d.create(0, 0, 5), 1.0, 1.0, capped)!);\r\n\r\n    result.push(Sphere.createCenterRadius(Point3d.create(0, 0, 0), 1.0)!);\r\n\r\n    result.push(TorusPipe.createInFrame(Transform.createIdentity(), 3.0, 1.0, Angle.create360(), capped)!);\r\n    const arcA = Arc3d.createXY(Point3d.create(6, 1, 0), 1.0, AngleSweep.createStartEndDegrees(-90, 0));\r\n    const point0 = arcA.fractionAndDistanceToPointOnTangent(0.0, -4);\r\n    const pointQ1 = arcA.fractionAndDistanceToPointOnTangent(1.0, 2);\r\n    const pointQ2 = arcA.fractionAndDistanceToPointOnTangent(1.0, 0.5);\r\n    const pointR1 = Point3d.create(point0.x, pointQ1.y);\r\n    const pointR2 = Point3d.create(point0.x, pointQ1.y);\r\n    const linestringQ1 = LineString3d.create(arcA.fractionToPoint(1.0), pointQ1, pointR1, point0);\r\n    const linestringQ2 = LineString3d.create(arcA.fractionToPoint(1.0), pointQ2, pointR2, point0);\r\n    const contourZ = Path.create(linestringQ1.clone());\r\n\r\n    const contourA = Loop.create(\r\n      LineSegment3d.create(point0, arcA.fractionToPoint(0)),\r\n      arcA.clone(),\r\n      linestringQ1.clone());\r\n    const contourB = Loop.create(\r\n      LineSegment3d.create(point0, arcA.fractionToPoint(0)),\r\n      arcA.clone(),\r\n      linestringQ2.clone());\r\n    contourB.tryTransformInPlace(Transform.createTranslationXYZ(1, 1, 3));\r\n\r\n    // const contourC = contourB.cloneTransformed(Transform.createTranslationXYZ(2, 1, 4))!;\r\n    result.push(LinearSweep.create(contourA, Vector3d.create(0, 0, 5), capped)!);\r\n    const axis = Ray3d.createXYZUVW(0, 8, 0, 1, 0, 0);\r\n    result.push(RotationalSweep.create(contourA.clone()!, axis.clone(), Angle.createDegrees(90), capped)!);\r\n\r\n    if (!capped)\r\n      result.push(RotationalSweep.create(contourZ.clone()!, axis.clone(), Angle.createDegrees(90), false)!);\r\n\r\n    result.push(RuledSweep.create([contourA.clone()!, contourB.clone()!], capped)!);\r\n\r\n    const transformC = Transform.createScaleAboutPoint(Point3d.create(0, 0, 8), 0.5);\r\n    const contourC = contourB.cloneTransformed(transformC)!;\r\n    result.push(RuledSweep.create([contourA.clone()!, contourB.clone()!, contourC.clone()!], capped)!);\r\n    return result;\r\n  }\r\n  /** Create a rotational sweep with segment, arc, and linestring in its contour.\r\n   */\r\n  public static createRotationalSweepLineSegment3dArc3dLineString3d(capped: boolean): SolidPrimitive[] {\r\n    const result = [];\r\n    const arcA = Arc3d.createXY(Point3d.create(6, 1, 0), 1.0, AngleSweep.createStartEndDegrees(-90, 0));\r\n    const point0 = arcA.fractionAndDistanceToPointOnTangent(0.0, -4);\r\n    const pointQ1 = arcA.fractionAndDistanceToPointOnTangent(1.0, 2);\r\n    const pointR1 = Point3d.create(point0.x, pointQ1.y);\r\n    const linestringQ1 = LineString3d.create(arcA.fractionToPoint(1.0), pointQ1, pointR1, point0);\r\n    const contourZ = Path.create(linestringQ1.clone());\r\n    const axis = Ray3d.createXYZUVW(0, 8, 0, 1, 0, 0);\r\n    result.push(RotationalSweep.create(contourZ.clone()!, axis.clone(), Angle.createDegrees(90), capped)!);\r\n    return result;\r\n  }\r\n  /**\r\n   * Create points:\r\n   * *  `numRadialEdges` radially from origin to polar point (r,sweep.start)\r\n   * * `numArcEdges` along arc from (r,sweep.start) to (r,sweep.end)\r\n   * * `numRadialEdges` returning to origin.\r\n   * * optionally include closure point at origin.\r\n   * @param x0 center x\r\n   * @param y0 center y\r\n   * @param radius radius of circle.\r\n   * @param sweep start and end angles of sweep.\r\n   * @param numRadialEdges number of edges from center to arc\r\n   * @param numArcEdges number of edges along arc\r\n   * @param addClosure true to repeat center as closure point\r\n   */\r\n  public static createCutPie(x0: number, y0: number, radius: number, sweep: AngleSweep, numRadialEdges: number, numArcEdges: number, addClosure = false): Point3d[] {\r\n\r\n    const points = [];\r\n    const center = Point3d.create(x0, y0);\r\n    points.push(center);\r\n    const pointA = Point3d.create(x0 + radius * Math.cos(sweep.startRadians), y0 + radius * Math.sin(sweep.startRadians));\r\n    const pointB = Point3d.create(x0 + radius * Math.cos(sweep.endRadians), y0 + radius * Math.sin(sweep.endRadians));\r\n    for (let i = 1; i < numRadialEdges; i++)\r\n      points.push(center.interpolate(i / numRadialEdges, pointA));\r\n    points.push(pointA);\r\n    for (let i = 1; i < numArcEdges; i++) {\r\n      const radians = sweep.fractionToRadians(i / numArcEdges);\r\n      points.push(Point3d.create(x0 + radius * Math.cos(radians), y0 + radius * Math.sin(radians)));\r\n    }\r\n    points.push(pointB);\r\n    for (let i = 1; i < numRadialEdges; i++)\r\n      points.push(pointB.interpolate(i / numRadialEdges, center));\r\n    if (addClosure)\r\n      points.push(center.clone());\r\n    return points;\r\n  }\r\n  /**\r\n   * * let ay = 4\r\n   * * base polygon has vertices (0,0), (ax,0), (2*ax,0), (2* ax,ay), (ax,ay), (0,ay), (0,0).\r\n   * * shift the x coordinates of vertices 1,4 by indicated amounts (0-based numbering)\r\n   * * shift the y coordinates for points 1,2,3,4 by indicated amounts (in 0-based numbering)\r\n   * * This is useful for testing non-y-monotonic face situations.\r\n   * * Return as points.\r\n   * @param dy1\r\n   * @param dy2\r\n   * @param dy3\r\n   * @param dy4\r\n   */\r\n  public static creatVerticalStaggerPolygon(dy1: number, dy2: number, dy3: number, dy4: number,\r\n    ax: number,\r\n    ay: number,\r\n    dx1: number,\r\n    dx4: number): Point3d[] {\r\n    return [Point3d.create(0, 0),\r\n    Point3d.create(ax + dx1, dy1),\r\n    Point3d.create(2 * ax, dy2),\r\n    Point3d.create(2 * ax, ay + dy3),\r\n    Point3d.create(ax + dx4, ay + dy4),\r\n    Point3d.create(0.0, ay),\r\n    Point3d.create(0, 0)];\r\n  }\r\n  /**\r\n   * make line segments for each pair of adjacent points.\r\n   * @param points array of points\r\n   * @param forceClosure if true, inspect coordinates to determine if a closure edge is needed.\r\n   */\r\n  public static convertPointsToSegments(points: Point3d[], forceClosure: boolean = false): LineSegment3d[] {\r\n    const segments = [];\r\n    const n = points.length;\r\n    for (let i = 0; i + 1 < n; i++) {\r\n      segments.push(LineSegment3d.create(points[i], points[i + 1]));\r\n    }\r\n    if (forceClosure && n > 1 && !points[0].isAlmostEqual(points[n - 1]))\r\n      segments.push(LineSegment3d.create(points[n - 1], points[0]));\r\n    return segments;\r\n  }\r\n  /**\r\n   * Create a regular polygon\r\n   * @param angle0 angle from x axis to first point.\r\n   * @param numPoint number of points\r\n   * @param close true to add closure edge.\r\n   */\r\n  public static createRegularPolygon(cx: number, cy: number, cz: number, angle0: Angle, r: number, numPoint: number, close: boolean): Point3d[] {\r\n    const points = [];\r\n    const angleStepRadians = 2.0 * Math.PI / numPoint;\r\n    let radians;\r\n    for (let i = 0; i < numPoint; i++) {\r\n      radians = angle0.radians + i * angleStepRadians;\r\n      points.push(Point3d.create(cx + r * Math.cos(radians), cy + r * Math.sin(radians), cz));\r\n    }\r\n    if (close)\r\n      points.push(points[0].clone());\r\n    return points;\r\n  }\r\n\r\n  /**\r\n   * Create a star by alternating radii (with equal angular steps)\r\n   * @param r0 first point radius\r\n   * @param r1 second point radius (if undefined, this is skipped and the result is points on a circle.)\r\n   * @param numPoint number of points\r\n   * @param close true to add closure edge.\r\n   */\r\n  public static createStar(cx: number, cy: number, cz: number, r0: number, r1: number | undefined, numPoint: number, close: boolean, theta0?: Angle): Point3d[] {\r\n    const points = [];\r\n    const angleStepRadians = Math.PI / numPoint;\r\n    const radians0 = theta0 === undefined ? 0.0 : theta0.radians;\r\n    let radians;\r\n    for (let i = 0; i < numPoint; i++) {\r\n      radians = radians0 + 2 * i * angleStepRadians;\r\n      points.push(Point3d.create(cx + r0 * Math.cos(radians), cy + r0 * Math.sin(radians), cz));\r\n      if (r1 !== undefined) {\r\n        radians = radians0 + (2 * i + 1) * angleStepRadians;\r\n        points.push(Point3d.create(cx + r1 * Math.cos(radians), cy + r1 * Math.sin(radians), cz));\r\n      }\r\n    }\r\n    if (close)\r\n      points.push(points[0].clone());\r\n    return points;\r\n  }\r\n  /**\r\n   * Create an outer star A\r\n   * Place multiple inner stars B with centers on circle C\r\n   * @param rA0 radius to star tips on starA\r\n   * @param rA1 radius to star tips on starA\r\n   * @param numAPoint number of points on starA\r\n   * @param rB0 radius to star B tips\r\n   * @param rB1 radius to star B  tips\r\n   * @param numBPoint\r\n   * @param rC radius for inner star centers\r\n   * @param numC number of inner stars\r\n   */\r\n  public static createStarsInStars(rA0: number, rA1: number, numAPoint: number, rB0: number, rB1: number, numBPoint: number, rC: number, numC: number, close: boolean): Point3d[][] {\r\n    const loops: Point3d[][] = [];\r\n    loops.push(this.createStar(0, 0, 0, rA0, rA1, numAPoint, close));\r\n    if (numC > 0) {\r\n      const radiansStep = Math.PI * 2.0 / numC;\r\n      for (let i = 0; i < numC; i++) {\r\n        const radians = i * radiansStep;\r\n        loops.push(\r\n          this.createStar(rC * Math.cos(radians), rC * Math.sin(radians), 0.0, rB0, rB1, numBPoint, close));\r\n      }\r\n    }\r\n    return loops;\r\n  }\r\n  private static appendGeometry(source: GeometryQuery[], dest: GeometryQuery[]) {\r\n    for (const g of source) dest.push(g);\r\n  }\r\n\r\n  /** Create a simple example of each GeometryQuery type .... */\r\n  public static createAllGeometryQueryTypes(): GeometryQuery[] {\r\n    const result: GeometryQuery[] = [];\r\n    const pointA = Point3d.create(0, 0, 0);\r\n    const pointB = Point3d.create(1, 0, 0);\r\n    const pointC = Point3d.create(1, 1, 0);\r\n    const pointD = Point3d.create(0, 1, 0);\r\n    const pointABC = [pointA, pointB, pointC];\r\n    const pointABCD = [pointA, pointB, pointC, pointD];\r\n    const pointABCDA = [pointA, pointB, pointC, pointD, pointA];\r\n    result.push(LineSegment3d.create(pointA, pointB));\r\n    result.push(CoordinateXYZ.create(pointA));\r\n    result.push(Arc3d.createCircularStartMiddleEnd(pointA, pointB, pointC)!);\r\n    result.push(PointString3d.create(pointA, pointB));\r\n    result.push(TransitionSpiral3d.createRadiusRadiusBearingBearing(Segment1d.create(0, 100), AngleSweep.createStartEndDegrees(0, 5), Segment1d.create(0, 0.5), Transform.createIdentity()));\r\n    result.push(LineString3d.create(pointABCD));\r\n    result.push(BezierCurve3d.create(pointABC)!);\r\n    result.push(BezierCurve3dH.create(pointABC)!);\r\n\r\n    result.push(BSplineCurve3d.createUniformKnots(pointABC, 3)!);\r\n    result.push(BSplineCurve3dH.createUniformKnots(pointABC, 3)!);\r\n\r\n    result.push(Loop.create(LineString3d.create(pointABCDA)));\r\n    result.push(Path.create(LineString3d.create(pointABCD)));\r\n    result.push(this.createConeBsplineSurface(pointA, pointC, 1, 2, 4)!);\r\n    result.push(this.createXYGridBsplineSurface(8, 4, 4, 3)!);\r\n    this.appendGeometry(this.createClosedSolidSampler(true), result);\r\n    result.push(this.createTriangularUnitGridPolyface(pointA, Vector3d.unitX(), Vector3d.unitY(), 4, 5));\r\n    this.appendGeometry(this.createSimpleParityRegions(), result);\r\n    this.appendGeometry(this.createSimpleUnions(), result);\r\n    this.appendGeometry(this.createBagOfCurves(), result);\r\n\r\n    return result;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Serialization */\r\n\r\n// import { Geometry, Angle, AxisOrder, BSIJSONValues } from \"../Geometry\";\r\nimport { Geometry, AngleProps, AngleSweepProps, AxisOrder } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { XYProps, XYZProps } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, XYZ, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { YawPitchRollAngles, YawPitchRollProps } from \"../geometry3d/YawPitchRollAngles\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { AnyGeometryQuery, GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { CoordinateXYZ } from \"../curve/CoordinateXYZ\";\r\nimport { TransitionSpiral3d } from \"../curve/TransitionSpiral\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { UnionRegion } from \"../curve/UnionRegion\";\r\nimport { BagOfCurves, CurveCollection } from \"../curve/CurveCollection\";\r\nimport { ParityRegion } from \"../curve/ParityRegion\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { Path } from \"../curve/Path\";\r\nimport { IndexedPolyface } from \"../polyface/Polyface\";\r\nimport { PolyfaceAuxData, AuxChannel, AuxChannelData, AuxChannelDataType } from \"../polyface/AuxData\";\r\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\r\nimport { BSplineSurface3d, BSplineSurface3dH, WeightStyle } from \"../bspline/BSplineSurface\";\r\nimport { Sphere } from \"../solid/Sphere\";\r\nimport { Cone } from \"../solid/Cone\";\r\nimport { Box } from \"../solid/Box\";\r\nimport { TorusPipe } from \"../solid/TorusPipe\";\r\nimport { LinearSweep } from \"../solid/LinearSweep\";\r\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\r\nimport { RuledSweep } from \"../solid/RuledSweep\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { PointString3d } from \"../curve/PointString3d\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { BezierCurve3dH } from \"../bspline/BezierCurve3dH\";\r\nimport { BezierCurve3d } from \"../bspline/BezierCurve3d\";\r\nimport { BSplineWrapMode } from \"../bspline/KnotVector\";\r\n\r\n/* tslint:disable: object-literal-key-quotes no-console*/\r\n/**\r\n * `ImodelJson` namespace has classes for serializing and deserialization json objects\r\n * @public\r\n */\r\nexport namespace IModelJson {\r\n  /**\r\n   * Property rules for json objects that can be deserialized to various Curve and Solid objects\r\n   * @public\r\n   */\r\n  export interface GeometryProps extends CurvePrimitiveProps, SolidPrimitiveProps, CurveCollectionProps {\r\n    /** `{indexedMesh:...}` */\r\n    indexedMesh?: IndexedMeshProps;\r\n    /** `{point:...}` */\r\n    point?: XYZProps;\r\n    /** `{bsurf:...}` */\r\n    bsurf?: BSplineSurfaceProps;\r\n  }\r\n  /**\r\n   * Property rules for json objects that can be deserialized to various CurvePrimitives\r\n   * * Only one of these is allowed in each instance.\r\n   * @public\r\n   */\r\n  export interface CurvePrimitiveProps {\r\n    /** `{lineSegment:...}` */\r\n    lineSegment?: [XYZProps, XYZProps];\r\n    /** `{lineString:...}` */\r\n    lineString?: XYZProps[];\r\n    /** `{bcurve:...}` */\r\n    bcurve?: BcurveProps;\r\n    /** `{transitionSpiral:...}` */\r\n    transitionSpiral?: TransitionSpiralProps;\r\n    /** `{arc:...}` */\r\n    arc?: ArcByVectorProps | [XYZProps, XYZProps, XYZProps];\r\n  }\r\n\r\n  /**\r\n   * Property rules for json objects that can be deserialized to single point\r\n   * @public\r\n   */\r\n  export interface PointProps {\r\n    /** `{point:...}` */\r\n    point?: XYZProps;\r\n  }\r\n\r\n  /**\r\n   * Property rules for json objects that can be deserialized to a BsplineSurface\r\n   * See `BCurveProps` for discussion of knot and pole counts.\r\n   * @public\r\n   */\r\n  export interface BSplineSurfaceProps {\r\n    /** polynomial order (one more than degree) in the u parameter direction */\r\n    orderU: number;\r\n    /** polynomial order (one more than degree) in the v parameter direction */\r\n    orderV: number;\r\n    /** Square grid of control points (aka poles) in row major order (row is along the u direction) */\r\n    points: [[[number]]];   // each inner array is xyz or xyzw for a single control point. each middle array is a row of control points.\r\n    /** Array of knots for the u direction bspline */\r\n    uKnots: [number];\r\n    /** Array of knots for the v direction bspline */\r\n    vKnots: [number];\r\n  }\r\n\r\n  /**\r\n   * Interface for a collection of curves, eg. as used as a swept contour.\r\n   * @public\r\n   */\r\n  export interface CurveCollectionProps extends PlanarRegionProps {\r\n    /** A sequence of curves joined head to tail: */\r\n    path?: [CurvePrimitiveProps];\r\n    /** A collection of curves with no required structure or connections: */\r\n    bagofCurves?: [CurveCollectionProps];\r\n  }\r\n\r\n  /**\r\n   * Interface for a collection of curves that bound a planar region\r\n   * @public\r\n   */\r\n  export interface PlanarRegionProps {\r\n    /** `{loop:...}`\r\n     * * A sequence of curves which connect head to tail, with the final connecting back to the first\r\n     */\r\n    loop?: [CurvePrimitiveProps];\r\n    /** `{parityRegion:...}`\r\n     * * A collection of loops, with composite inside/outside determined by parity rules.\r\n     * * (The single outer boundary with one or more holes is a parityRegion)\r\n     */\r\n    parityRegion?: [{ loop: [CurvePrimitiveProps] }];\r\n    /** `{unionRegion:...}`\r\n     * * A collection of loops and parityRegions\r\n     */\r\n\r\n    unionRegion?: [PlanarRegionProps];\r\n  }\r\n  /**\r\n   * Interface for solid primitives: box, sphere, cylinder, cone, torusPipe, linear sweep, rotational sweep, ruled sweep.\r\n   * @public\r\n   */\r\n  export interface SolidPrimitiveProps {\r\n    /** `{cylinder:...}` */\r\n    cylinder?: CylinderProps;\r\n    /** `{box:...}` */\r\n    box?: BoxProps;\r\n    /** `{sphere:............}` */\r\n    sphere?: SphereProps;\r\n    /** `{cone:............}` */\r\n    cone?: ConeProps;\r\n    /** `{torusPipe:............}` */\r\n    torusPipe?: TorusPipeProps;\r\n    /** `{linearSweep:.........}` */\r\n    linearSweep?: LinearSweepProps;\r\n    /** `{rotationalSweep:...}` */\r\n    rotationalSweep?: RotationalSweepProps;\r\n    /** `{ruledSweep:...}` */\r\n    ruledSweep?: RuledSweepProps;\r\n  }\r\n  /**\r\n   * * There are multiple ways to specify an orientation\r\n   * * A \"Best\" among these is application specific.\r\n   * * An object with AxesProps should only specify one of the variants.\r\n   * * YawPitchRollAngles uses 3 angles.\r\n   * * * Cases where only one of the 3 is nonzero are intuitive\r\n   * * * Cases where more than one is nonzero have difficult interactions and order issues.\r\n   * * xyVectors uses a vector along the x direction and a vector into positive xy plane\r\n   *    along any direction not parallel to x.\r\n   * * * In most cases, users supply a normalized x and the actual normalized y vector.\r\n   * * zxVectors uses a z vector and another vector into the positive zx plane.\r\n   * * * In most cases, users supply a normalized z and the actual normalized x vector.\r\n   * @public\r\n   */\r\n  export interface AxesProps {\r\n    /**\r\n     * See YawPitchAngles class for further information about using 3 rotations to specify orientation.\r\n     * @public\r\n     */\r\n    yawPitchRollAngles?: YawPitchRollProps;\r\n    /**\r\n     * Cartesian coordinate directions defined by X direction then Y direction.\r\n     * * The right side contains two vectors in an array.\r\n     * * The first vector gives the x axis direction\r\n     * * * This is normalized to unit length.\r\n     * * The second vector gives the positive y direction in the xy plane.\r\n     * * * This vector is adjusted to be unit length and perpendicular to the x direction.\r\n     */\r\n    xyVectors?: [XYZProps, XYZProps];\r\n    /**\r\n     * Cartesian coordinate directions defined by X direction then Y direction.\r\n     * * The right side contains two vectors in an array.\r\n     * * The first vector gives the z axis direction\r\n     * * * This is normalized to unit length.\r\n     * * The second vector gives the positive x direction in the zx plane.\r\n     * * * This vector is adjusted to be unit length and perpendicular to the z direction.\r\n     */\r\n    zxVectors?: [XYZProps, XYZProps];\r\n  }\r\n\r\n  /**\r\n   * Interface for Arc3d value defined by center, vectorX, vectorY and sweepStartEnd.\r\n   * @public\r\n   */\r\n  export interface ArcByVectorProps {\r\n    /** Arc center point */\r\n    center: XYZProps;\r\n    /** Vector from center to 0-degree point (commonly called major axis vector) */\r\n    vectorX: XYZProps;\r\n    /** Vector from center to 90-degree point (common called minor axis vector) */\r\n    vectorY: XYZProps;\r\n    /** Start and end angles in parameterization `X=C+cos(theta) * vectorX + sin(theta) * vectorY` */\r\n    sweepStartEnd: AngleSweepProps;\r\n  }\r\n\r\n  /**\r\n   * Interface for Cone value defined by centers, radii, and (optional) vectors for circular section planes.\r\n   * * VectorX and vectorY are optional.\r\n   * * If either one is missing, both vectors are constructed perpendicular to the vector from start to end.\r\n   * @public\r\n   */\r\n  export interface ConeProps extends AxesProps {\r\n    /** Point on axis at start section. */\r\n    start: XYZProps;\r\n    /** Point on axis at end section  */\r\n    end: XYZProps;\r\n\r\n    /** radius at `start` section */\r\n    startRadius: number;\r\n    /** radius at `end` section */\r\n    endRadius?: number;\r\n    /** optional x vector in start section.  Omit for circular sections perpendicular to axis. */\r\n    vectorX?: XYZProps;\r\n    /** optional y vector in start section.  Omit for circular sections perpendicular to axis. */\r\n    vectorY?: XYZProps;\r\n    /** flag for circular end caps. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for cylinder defined by a radius and axis start and end centers.\r\n   * @public\r\n   */\r\n  export interface CylinderProps {\r\n    /** axis point at start */\r\n    start: XYZProps;\r\n    /** axis point at end */\r\n    end: XYZProps;\r\n    /** cylinder radius */\r\n    radius: number;\r\n    /** flag for circular end caps. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for a linear sweep of a base curve or region.\r\n   * @public\r\n   */\r\n  export interface LinearSweepProps {\r\n    /** The swept curve or region.  Any curve collection */\r\n    contour: CurveCollectionProps;\r\n    /** The sweep vector  */\r\n    vector: XYZProps;\r\n    /** flag for circular end caps. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for a rotational sweep of a base curve or region around an axis.\r\n   * @public\r\n   */\r\n  export interface RotationalSweepProps {\r\n    /** The swept curve or region.  Any curve collection */\r\n    contour: CurveCollectionProps;\r\n    /** any point on the axis of rotation. */\r\n    center: XYZProps;\r\n    /** The axis of rotation  */\r\n    axis: XYZProps;\r\n    /** sweep angle */\r\n    sweepAngle: AngleProps;\r\n    /** flag for circular end caps. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for a surface with ruled sweeps between corresponding curves on successive contours\r\n   * @public\r\n   */\r\n  export interface RuledSweepProps {\r\n    /** The swept curve or region.  An array of curve collections.  */\r\n    contour: [CurveCollectionProps];\r\n    /** flag for circular end caps. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for spiral\r\n   * * Any 4 (but not 5) of the 5 values `[startBearing, endBearing, startRadius, endRadius, length]`\r\n   *       may be defined.\r\n   * * In radius data, zero radius indicates straight line (infinite radius)\r\n   * * Note that the inherited AxesProps allows multiple ways to specify orientation of the placement..\r\n   * @public\r\n   */\r\n  export interface TransitionSpiralProps extends AxesProps {\r\n\r\n    /** origin of the coordinate system. */\r\n    origin: XYZProps;\r\n    /** angle at departure from origin. */\r\n    startBearing?: AngleProps;\r\n    /** End bearing. */\r\n    endBearing?: AngleProps;\r\n    /** Radius at start  (0 for straight line) */\r\n    startRadius?: number;\r\n    /** Radius at end  (0 for straight line) */\r\n    endRadius?: number;\r\n    /** length along curve */\r\n    curveLength?: number;\r\n    /** Fractional part of active interval. */\r\n    fractionInterval?: number[];\r\n    /** TransitionSpiral type.   Default is `\"clothoid\"` */\r\n    type?: string; //   one of:   \"clothoid\" | \"biquadratic\" | \"bloss\" | \"cosine\" | \"sine\";\r\n    /** A fractional portion of the spiral may be selected.\r\n     * * If this is missing, fraction range is `[0,1]`\r\n     */\r\n    intervalFractions?: [number, number];\r\n  }\r\n\r\n  /**\r\n   * Interface for bspline curve (aka bcurve)\r\n   * @public\r\n   */\r\n  export interface BcurveProps {\r\n    /** control points */\r\n    points: [XYZProps];\r\n    /** knots. */\r\n    knots: [number];\r\n    /** order of polynomial\r\n     * * The order is the number of basis functions that are in effect at any knot value.\r\n     * * The order is the number of points that affect the curve at any knot value,\r\n     *     i.e. the size of the \"local support\" set\r\n     * * `order=2` is lines (degree 1)\r\n     * * `order=3` is quadratic (degree 2)\r\n     * * `order=4` is cubic (degree 3)\r\n     * * The number of knots follows the convention \"poles+order= knots\".\r\n     * * In this convention (for example), a clamped cubic with knots `[0,0,0,0, 1,2,3,4,4,4,4]`\r\n     * has:\r\n     * * * 4 (`order`) copies of the start and end knot (0 and 4) and\r\n     * * * 3 interior knots\r\n     * * Hence expect 7 poles.\r\n     */\r\n    order: number;\r\n    /** optional flag for periodic data. */\r\n    closed?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for Box (or frustum with all rectangular sections parallel to primary xy section)\r\n   * * Orientation may be given in any `AxesProp`s way (yawPitchRoll, xyVectors, zxVectors)\r\n   * * if topX or topY are omitted, each defaults to its baseX or baseY peer.\r\n   * * `topOrigin` is determined with this priority order:\r\n   * * * `topOrigin` overrides given `height`\r\n   * * * on the z axis at distance `height`\r\n   * * * If both `topOrigin` and `height` are omitted, `height` defaults to `baseX`\r\n   * @public\r\n   */\r\n  export interface BoxProps extends AxesProps {\r\n    /** Origin of the box coordinate system  (required) */\r\n    origin: XYZProps;\r\n    /** base x size (required) */\r\n    baseX: number;\r\n    /** base size\r\n     * * if omitted, defaults to baseX.\r\n     */\r\n    baseY: number;\r\n    /** top origin.\r\n     * * This is NOT required to be on the z axis.\r\n     * * If omitted, a `heigh` must be present to given topOrigin on z axis.\r\n     */\r\n    topOrigin?: XYZProps;\r\n    /** optional height.  This is only used if `topOrigin` is omitted. */\r\n    height?: number;\r\n    /** x size on top section.\r\n     * * If omitted, `baseX` is used\r\n     */\r\n    topX?: number;\r\n    /** y size on top section.\r\n     * * If omitted, `baseY` is used\r\n     */\r\n    topY?: number;\r\n    /** optional capping flag. */\r\n    capped?: boolean;\r\n\r\n  }\r\n\r\n  /**\r\n   * Interface for Sphere (with optionally different radius to pole versus equator)\r\n   * * Orientation may be given in any `AxesProp`s way (yawPitchRoll, xyVectors, zxVectors)\r\n   * @public\r\n   */\r\n  export interface SphereProps extends AxesProps {\r\n    /** Center of the sphere coordinate system */\r\n    center: XYZProps;\r\n\r\n    /** primary radius */\r\n    radius?: number;\r\n    /** optional x radius */\r\n    radiusX?: number;\r\n    /** optional y radius */\r\n    radiusY?: number;\r\n\r\n    /** optional radius at poles.  */\r\n    radiusZ?: number;\r\n\r\n    /** optional sweep range for latitude.  Default latitude limits are [-90,90 ] degrees. */\r\n    latitudeStartEnd?: AngleSweepProps;\r\n    /** optional capping flag. If missing, implied false */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for TorusPipe data\r\n   * * Orientation may be given in any `AxesProp`s way (yawPitchRoll, xyVectors, zxVectors)\r\n   * * Both radii are required.\r\n   * * axes are required\r\n   * * Axis definition is\r\n   * * xy plane contains the major circle\r\n   * * x axis points from donut hole center to flow center at start of pipe.\r\n   * * z axis points through the hole.\r\n   * @public\r\n   */\r\n  export interface TorusPipeProps extends AxesProps {\r\n    /** Center of the full torus coordinate system. (donut hole center) */\r\n    center: XYZProps;\r\n\r\n    /** primary radius  (elbow radius) */\r\n    majorRadius: number;\r\n    /** pipe radius */\r\n    minorRadius?: number;\r\n    /** sweep angle.\r\n     * * if omitted, full 360 degree sweep.\r\n     */\r\n    sweepAngle?: AngleProps;\r\n    /** optional capping flag. If missing, implied false */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for a ruled sweep.\r\n   * @public\r\n   */\r\n  export interface RuledSweepProps {\r\n    /** Array of contours */\r\n    countour: [CurveCollectionProps];\r\n    /** optional capping flag. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for an indexed mesh.\r\n   * * IMPORTANT: All indices are one-based.\r\n   * * i.e. vertex index given as 11 appears at index 10 in the data array.\r\n   * * This is to allow a negated index to mean \"don't draw the following edge\"\r\n   * * Although negative indices are not allowed for normalIndex, colorIndex, or paramIndex, the \"one based\" style\r\n   *     is used for them so that all indices within the indexedMesh json object are handled similarly.\r\n   * * In all index arrays, a ZERO indicates \"end of facet\".\r\n   * @public\r\n   */\r\n  export interface IndexedMeshProps {\r\n    /** vertex coordinates */\r\n    point: [XYZProps];\r\n    /** surface normals */\r\n    normal?: [XYZProps];\r\n    /** texture space (uv parameter) coordinates */\r\n    param?: [XYProps];\r\n    /** 32 bit color values */\r\n    color?: [number];\r\n\r\n    /** SIGNED ONE BASED ZERO TERMINATED array of point indices. */\r\n    pointIndex: [number];\r\n    /** ONE BASED ZERO TERMINATED array of param indices.  ZERO is terminator for single facet. */\r\n    paramIndex?: [number];\r\n    /** ONE BASED ZERO TERMINATED array of normal indices. ZERO is terminator for single facet. */\r\n    normalIndex?: [number];\r\n    /** ONE BASED ZERO TERMINATED array of color indices. ZERO is terminator for single facet. */\r\n    colorIndex?: [number];\r\n  }\r\n  /** parser services for \"iModelJson\" schema\r\n   * * 1: create a reader with `new ImodelJsonReader`\r\n   * * 2: parse json fragment to strongly typed geometry: `const g = reader.parse (fragment)`\r\n   * @public\r\n   */\r\n  export class Reader {\r\n\r\n    public constructor() { // empty ctor\r\n    }\r\n\r\n    private static parseVector3dProperty(json: any, propertyName: string, defaultValue?: Vector3d | undefined): Vector3d | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (Geometry.isNumberArray(value, 3))\r\n          return Vector3d.create(value[0], value[1], value[2]);\r\n        if (XYZ.isXAndY(value))\r\n          return Vector3d.fromJSON(value);\r\n      }\r\n      return defaultValue;\r\n    }\r\n\r\n    private static parsePoint3dProperty(json: any, propertyName: string, defaultValue?: Point3d | undefined): Point3d | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (Geometry.isNumberArray(value, 3))\r\n          return Point3d.create(value[0], value[1], value[2]);\r\n        if (XYZ.isXAndY(value))\r\n          return Point3d.fromJSON(value);\r\n      }\r\n      return defaultValue;\r\n    }\r\n\r\n    private static parseSegment1dProperty(json: any, propertyName: string, defaultValue?: Segment1d | undefined): Segment1d | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (Geometry.isNumberArray(value, 2))\r\n          return Segment1d.create(value[0], value[1]);\r\n      }\r\n      return defaultValue;\r\n    }\r\n\r\n    private static parseNumberProperty(json: any, propertyName: string, defaultValue?: number | undefined): number | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (Number.isFinite(value))\r\n          return value as number;\r\n      }\r\n      return defaultValue;\r\n    }\r\n    /* ==============\r\n        private static parseNumberArrayProperty(json: any, propertyName: string, minValues: number, maxValues: number, defaultValue?: number[] | undefined): number[] | undefined {\r\n          if (json.hasOwnProperty(propertyName)) {\r\n            const value = json[propertyName];\r\n            if (Array.isArray(value)\r\n              && value.length >= minValues && value.length <= maxValues) {\r\n              const result = [];\r\n              for (const a of value) {\r\n                result.push(a);\r\n              }\r\n              return result;\r\n            }\r\n          }\r\n          return defaultValue;\r\n        }\r\n    */\r\n    private static parseAngleProperty(json: any, propertyName: string, defaultValue?: Angle | undefined): Angle | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        return Angle.fromJSON(value);\r\n      }\r\n      return defaultValue;\r\n    }\r\n    /**\r\n     * @param defaultFunction function to call if needed to produce a default value\r\n     */\r\n    private static parseAngleSweepProps(json: any, propertyName: string, defaultFunction?: () => AngleSweep): AngleSweep | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        return AngleSweep.fromJSON(value);\r\n      }\r\n      if (defaultFunction === undefined)\r\n        return undefined;\r\n      return defaultFunction();\r\n    }\r\n\r\n    private static parseBooleanProperty(json: any, propertyName: string, defaultValue?: boolean | undefined): boolean | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (value === true) return true;\r\n        if (value === false) return false;\r\n      }\r\n      return defaultValue;\r\n    }\r\n\r\n    private static loadContourArray(json: any, propertyName: string): CurveCollection[] | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (Array.isArray(value)) {\r\n          const result = [];\r\n          for (const contourData of value) {\r\n            const contour = Reader.parse(contourData);\r\n            if (contour instanceof CurveCollection) {\r\n              result.push(contour);\r\n            }\r\n          }\r\n          if (result.length > 0)\r\n            return result;\r\n        }\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    private static parseYawPitchRollAnglesToMatrix3d(json: YawPitchRollProps): Matrix3d | undefined {\r\n      const ypr = YawPitchRollAngles.fromJSON(json);\r\n      return ypr.toMatrix3d();\r\n    }\r\n\r\n    private static parseStringProperty(json: any, propertyName: string, defaultValue?: string | undefined): string | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (value.type === \"string\")\r\n          return value;\r\n      }\r\n      return defaultValue;\r\n    }\r\n\r\n    private static parseAxesFromVectors(json: any, axisOrder: AxisOrder, createDefaultIdentity: boolean): Matrix3d | undefined {\r\n      if (Array.isArray(json) && json.length === 2) {\r\n        const xVector = Vector3d.fromJSON(json[0]);\r\n        const yVector = Vector3d.fromJSON(json[1]);\r\n        const matrix = Matrix3d.createRigidFromColumns(xVector, yVector, axisOrder);\r\n        if (matrix) return matrix;\r\n      }\r\n      if (createDefaultIdentity)\r\n        return Matrix3d.createIdentity();\r\n      return undefined;\r\n    }\r\n    /**\r\n     * Look for orientation data and convert to Matrix3d.\r\n     * * Search order is:\r\n     * * * yawPitchRollAngles\r\n     * * * xyVectors\r\n     * * * zxVectors\r\n     * @param json [in] json source data\r\n     * @param createDefaultIdentity [in] If true and no orientation is present, return an identity matrix.  If false and no orientation is present, return undefined.\r\n     */\r\n    private static parseOrientation(json: any, createDefaultIdentity: boolean): Matrix3d | undefined {\r\n      if (json.yawPitchRollAngles) {\r\n        return Reader.parseYawPitchRollAnglesToMatrix3d(json.yawPitchRollAngles);\r\n      } else if (json.xyVectors) {\r\n        return Reader.parseAxesFromVectors(json.xyVectors, AxisOrder.XYZ, createDefaultIdentity);\r\n      } else if (json.zxVectors) {\r\n        return Reader.parseAxesFromVectors(json.zxVectors, AxisOrder.ZXY, createDefaultIdentity);\r\n      }\r\n      if (createDefaultIdentity)\r\n        return Matrix3d.createIdentity();\r\n      return undefined;\r\n    }\r\n\r\n    private static parseArcByVectorProps(data?: ArcByVectorProps): Arc3d | undefined {\r\n      if (data\r\n        && data.center !== undefined\r\n        && data.vectorX !== undefined\r\n        && data.vectorY !== undefined\r\n        && data.sweepStartEnd !== undefined\r\n      ) {\r\n        return Arc3d.create(\r\n          Point3d.fromJSON(data.center),\r\n          Vector3d.fromJSON(data.vectorX),\r\n          Vector3d.fromJSON(data.vectorY),\r\n          AngleSweep.fromJSON(data.sweepStartEnd));\r\n      }\r\n      return undefined;\r\n    }\r\n    // remark: Returns LineString3d as last default when give points are colinear.\r\n    private static parseArcBy3Points(data?: ArcByVectorProps): Arc3d | LineString3d | undefined {\r\n      if (Array.isArray(data) && data.length > 2) {\r\n        const pointA = Point3d.fromJSON(data[0]);\r\n        const pointB = Point3d.fromJSON(data[1]);\r\n        const pointC = Point3d.fromJSON(data[2]);\r\n        return Arc3d.createCircularStartMiddleEnd(pointA, pointB, pointC);\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    private static parseArcObject(data?: ArcByVectorProps): Arc3d | LineString3d | undefined {\r\n      let arc: Arc3d | LineString3d | undefined = Reader.parseArcByVectorProps(data);\r\n      if (arc)\r\n        return arc;\r\n      arc = Reader.parseArcBy3Points(data);\r\n      return arc; // possibly undefined.\r\n    }\r\n    /** Parse point content (right side) `[1,2,3]` to a CoordinateXYZ object. */\r\n    public static parseCoordinate(data?: any): CoordinateXYZ | undefined {\r\n      const point = Point3d.fromJSON(data);\r\n      if (point)\r\n        return CoordinateXYZ.create(point);\r\n      return undefined;\r\n    }\r\n    /** Parse TransitionSpiral content (right side) to TransitionSpiral3d\r\n     * @alpha\r\n     */\r\n    public static parseTransitionSpiral(data?: TransitionSpiralProps): TransitionSpiral3d | undefined {\r\n      const axes = Reader.parseOrientation(data, true)!;\r\n      const origin = Reader.parsePoint3dProperty(data, \"origin\");\r\n      // the create method will juggle any 4 out of these 5 inputs to define the other ..\r\n      const startBearing = Reader.parseAngleProperty(data, \"startBearing\");\r\n      const endBearing = Reader.parseAngleProperty(data, \"endBearing\");\r\n      const startRadius = Reader.parseNumberProperty(data, \"startRadius\");\r\n      const endRadius = Reader.parseNumberProperty(data, \"endRadius\");\r\n      const length = Reader.parseNumberProperty(data, \"curveLength\", undefined);\r\n\r\n      const interval = Reader.parseSegment1dProperty(data, \"fractionInterval\", undefined);\r\n\r\n      const spiralType = Reader.parseStringProperty(data, \"spiralType\", \"clothoid\");\r\n      if (origin)\r\n        return TransitionSpiral3d.create(\r\n          spiralType,\r\n          startRadius, endRadius,\r\n          startBearing, endBearing,\r\n          length,\r\n          interval,\r\n          Transform.createOriginAndMatrix(origin, axes));\r\n      return undefined;\r\n    }\r\n    /**\r\n     * Special closed case if the input was forced to bezier . . . (e.g. arc)\r\n     *       (b-1) 0 0 0  a . . . b 111 (a+1)\r\n     *       with {order} clamp-like values .. no pole duplication needed, but throw out 2 knots at each end . ..\r\n     * @param numPoles number of poles\r\n     * @param knots knot vector\r\n     * @param order curve order\r\n     * @param newKnots array to receive new knots.\r\n     * @returns true if this is a closed-but-clamped case and corrected knots are filled in.\r\n     */\r\n    private static getCorrectedKnotsForClosedClamped(numPoles: number, knots: number[], order: number, newKnots: number[]): boolean {\r\n      const numKnots = knots.length;\r\n      if (numPoles + 2 * order - 1 === numKnots\r\n        && knots[0] < knots[1]\r\n        && knots[numKnots - 2] < knots[numKnots - 1]) {\r\n        const a0 = knots[1];\r\n        const a1 = knots[numKnots - 2];\r\n        for (let i = 2; i <= order; i++) {\r\n          if (knots[i] !== a0)\r\n            return false;\r\n          if (knots[numKnots - 1 - i] !== a1)\r\n            return false;\r\n        }\r\n        // copy only the \"minimal\" set - without the typical extra knots from microstation and psd.\r\n        for (let i = 2; i + 2 < numKnots; i++)\r\n          newKnots.push(knots[i]);\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    /** Parse `bcurve` content (right side)to  BSplineCurve3d or BSplineCurve3dH object. */\r\n    public static parseBcurve(data?: any): BSplineCurve3d | BSplineCurve3dH | undefined {\r\n      if (data === undefined)\r\n        return undefined;\r\n      if (Array.isArray(data.points) && Array.isArray(data.knots) && Number.isFinite(data.order) && data.closed !== undefined) {\r\n        if (data.points[0].length === 4) {\r\n          const hPoles: Point4d[] = [];\r\n          for (const p of data.points) hPoles.push(Point4d.fromJSON(p));\r\n          const knots: number[] = [];\r\n          let wrapMode = BSplineWrapMode.None;\r\n          if (data.closed && this.getCorrectedKnotsForClosedClamped(data.points.length, data.knots, data.order, knots)) {\r\n            // leave the poles alone -- knots are fixed.\r\n            wrapMode = BSplineWrapMode.OpenByRemovingKnots;\r\n          } else if (data.closed) {\r\n            for (const knot of data.knots) knots.push(knot);\r\n            for (let i = 0; i + 1 < data.order; i++) {\r\n              hPoles.push(hPoles[i].clone());\r\n            }\r\n            wrapMode = BSplineWrapMode.OpenByAddingControlPoints;\r\n          } else {\r\n            // simple case .. just copy\r\n            for (const knot of data.knots) knots.push(knot);\r\n          }\r\n          const newCurve = BSplineCurve3dH.create(hPoles, knots, data.order);\r\n          if (newCurve) {\r\n            if (data.closed === true)\r\n              newCurve.setWrappable(wrapMode);\r\n            return newCurve;\r\n          }\r\n        } else if (data.points[0].length === 3 || data.points[0].length === 2) {\r\n\r\n          const poles: Point3d[] = [];\r\n          for (const p of data.points) poles.push(Point3d.fromJSON(p));\r\n          const knots: number[] = [];\r\n          let wrapMode = BSplineWrapMode.None;\r\n          if (data.closed && this.getCorrectedKnotsForClosedClamped(data.points.length, data.knots, data.order, knots)) {\r\n            wrapMode = BSplineWrapMode.OpenByRemovingKnots;\r\n            // leave the poles alone -- knots are fixed.\r\n          } else if (data.closed) {\r\n            for (const knot of data.knots) knots.push(knot);\r\n            for (let i = 0; i + 1 < data.order; i++) {\r\n              poles.push(poles[i].clone());\r\n            }\r\n            wrapMode = BSplineWrapMode.OpenByAddingControlPoints;\r\n          } else {\r\n            // simple case .. just copy\r\n            for (const knot of data.knots) knots.push(knot);\r\n          }\r\n          const newCurve = BSplineCurve3d.create(poles, knots, data.order);\r\n          if (newCurve) {\r\n            if (data.closed === true)\r\n              newCurve.setWrappable(wrapMode);\r\n            return newCurve;\r\n          }\r\n        }\r\n\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** Parse array of json objects to array of instances. */\r\n    public static parseArray(data?: any): any[] | undefined {\r\n      if (Array.isArray(data)) {\r\n        const myArray = [];\r\n        let c;\r\n        for (c of data) {\r\n          const g = Reader.parse(c);\r\n          if (g !== undefined)\r\n            myArray.push(g);\r\n        }\r\n        return myArray;\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    // For each nonzero index, Announce Math.abs (value) -1\r\n    private static addZeroBasedIndicesFromSignedOneBased(data: any, f: (x: number) => any): void {\r\n      if (data && Geometry.isNumberArray(data)) {\r\n        for (const value of data) {\r\n          if (value !== 0)\r\n            f(Math.abs(value) - 1);\r\n        }\r\n      }\r\n    }\r\n    /** parse polyface aux data content to PolyfaceAuxData instance */\r\n    public static parsePolyfaceAuxData(data?: any): PolyfaceAuxData | undefined {\r\n\r\n      if (!Array.isArray(data.channels) || !Array.isArray(data.indices))\r\n        return undefined;\r\n\r\n      const outChannels: AuxChannel[] = [];\r\n      for (const inChannel of data.channels) {\r\n        if (Array.isArray(inChannel.data) && inChannel.hasOwnProperty(\"dataType\")) {\r\n          const outChannelData: AuxChannelData[] = [];\r\n          for (const inChannelData of inChannel.data) {\r\n            if (inChannelData.hasOwnProperty(\"input\") && Array.isArray(inChannelData.values))\r\n              outChannelData.push(new AuxChannelData(inChannelData.input, inChannelData.values));\r\n          }\r\n          outChannels.push(new AuxChannel(outChannelData, inChannel.dataType as AuxChannelDataType, inChannel.name, inChannel.inputName));\r\n        }\r\n      }\r\n\r\n      const auxData = new PolyfaceAuxData(outChannels, []);\r\n      Reader.addZeroBasedIndicesFromSignedOneBased(data.indices, (x: number) => { auxData.indices.push(x); });\r\n\r\n      return auxData;\r\n    }\r\n\r\n    /** parse indexed mesh content to an IndexedPolyface instance */\r\n    public static parseIndexedMesh(data?: any): IndexedPolyface | undefined {\r\n      // {Coord:[[x,y,z],. . . ],   -- simple xyz for each point\r\n      // CoordIndex[1,2,3,0]    -- zero-terminated, one based !!!\r\n      if (data.hasOwnProperty(\"point\") && Array.isArray(data.point)\r\n        && data.hasOwnProperty(\"pointIndex\") && Array.isArray(data.pointIndex)) {\r\n        const polyface = IndexedPolyface.create();\r\n        if (data.hasOwnProperty(\"normal\") && Array.isArray(data.normal)) {\r\n          for (const uvw of data.normal) {\r\n            if (Geometry.isNumberArray(uvw, 3))\r\n              polyface.addNormal(Vector3d.create(uvw[0], uvw[1], uvw[2]));\r\n          }\r\n        }\r\n        if (data.hasOwnProperty(\"param\") && Array.isArray(data.param)) {\r\n          for (const uv of data.param) {\r\n            if (Geometry.isNumberArray(uv, 2))\r\n              polyface.addParam(Point2d.create(uv[0], uv[1]));\r\n          }\r\n        }\r\n        if (data.hasOwnProperty(\"color\") && Array.isArray(data.color)) {\r\n          for (const c of data.color) {\r\n            polyface.addColor(c);\r\n          }\r\n        }\r\n\r\n        for (const p of data.point) polyface.addPoint(Point3d.fromJSON(p));\r\n\r\n        for (const p of data.pointIndex) {\r\n          if (p === 0)\r\n            polyface.terminateFacet(false); // we are responsible for index checking !!!\r\n          else {\r\n            const p0 = Math.abs(p) - 1;\r\n            polyface.addPointIndex(p0, p > 0);\r\n          }\r\n        }\r\n\r\n        if (data.hasOwnProperty(\"normalIndex\")) {\r\n          Reader.addZeroBasedIndicesFromSignedOneBased(data.normalIndex,\r\n            (x: number) => { polyface.addNormalIndex(x); });\r\n        }\r\n        if (data.hasOwnProperty(\"paramIndex\")) {\r\n          Reader.addZeroBasedIndicesFromSignedOneBased(data.paramIndex,\r\n            (x: number) => { polyface.addParamIndex(x); });\r\n        }\r\n\r\n        if (data.hasOwnProperty(\"colorIndex\")) {\r\n          Reader.addZeroBasedIndicesFromSignedOneBased(data.colorIndex,\r\n            (x: number) => { polyface.addColorIndex(x); });\r\n        }\r\n        if (data.hasOwnProperty(\"auxData\"))\r\n          polyface.data.auxData = Reader.parsePolyfaceAuxData(data.auxData);\r\n\r\n        return polyface;\r\n      }\r\n      return undefined;\r\n    }\r\n    /** parse contents of a curve collection to a CurveCollection instance */\r\n    public static parseCurveCollectionMembers(result: CurveCollection, data?: any): CurveCollection | undefined {\r\n      if (data && Array.isArray(data)) {\r\n        for (const c of data) {\r\n          const g = Reader.parse(c);\r\n          if (g instanceof GeometryQuery && (\"curveCollection\" === g.geometryCategory || \"curvePrimitive\" === g.geometryCategory))\r\n            result.tryAddChild(g);\r\n        }\r\n        return result;\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse content of `bsurf` to BSplineSurface3d or BSplineSurface3dH */\r\n    public static parseBsurf(data?: any): BSplineSurface3d | BSplineSurface3dH | undefined {\r\n      if (data.hasOwnProperty(\"uKnots\") && Array.isArray(data.uKnots)\r\n        && data.hasOwnProperty(\"vKnots\") && Array.isArray(data.vKnots)\r\n        && data.hasOwnProperty(\"orderU\") && Number.isFinite(data.orderU)\r\n        && data.hasOwnProperty(\"orderV\") && Number.isFinite(data.orderV)\r\n        && data.hasOwnProperty(\"points\") && Array.isArray(data.points)\r\n      ) {\r\n        const orderU = data.orderU;\r\n        const orderV = data.orderV;\r\n        if (Array.isArray(data.points[0]) && Array.isArray(data.points[0][0])) {\r\n          const d = data.points[0][0].length;\r\n          /** xyz surface (no weights) */\r\n          if (d === 3) {\r\n            return BSplineSurface3d.createGrid(data.points,\r\n              orderU, data.uKnots,\r\n              orderV, data.vKnots);\r\n          }\r\n          /** xyzw surface (weights already applied) */\r\n          if (d === 4) {\r\n            return BSplineSurface3dH.createGrid(data.points,\r\n              WeightStyle.WeightsAlreadyAppliedToCoordinates,\r\n              orderU, data.uKnots,\r\n              orderV, data.vKnots);\r\n          }\r\n        }\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse `cone` contents to `Cone` instance  */\r\n    public static parseConeProps(json?: ConeProps): Cone | undefined {\r\n      const axes = Reader.parseOrientation(json, false);\r\n      const start = Reader.parsePoint3dProperty(json, \"start\");\r\n      const end = Reader.parsePoint3dProperty(json, \"end\");\r\n\r\n      const startRadius = Reader.parseNumberProperty(json, \"startRadius\");\r\n      const endRadius = Reader.parseNumberProperty(json, \"endRadius\", startRadius);\r\n\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false) as boolean;\r\n\r\n      if (start\r\n        && end\r\n        && startRadius !== undefined\r\n        && endRadius !== undefined) {\r\n        if (axes === undefined) {\r\n          const axisVector = Vector3d.createStartEnd(start, end);\r\n          const frame = Matrix3d.createRigidHeadsUp(axisVector, AxisOrder.ZXY);\r\n          const vectorX = frame.columnX();\r\n          const vectorY = frame.columnY();\r\n          return Cone.createBaseAndTarget(start, end, vectorX, vectorY, startRadius, endRadius, capped);\r\n        } else {\r\n          return Cone.createBaseAndTarget(start, end, axes.columnX(), axes.columnY(), startRadius, endRadius, capped);\r\n        }\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** Parse `cylinder` content to `Cone` instance */\r\n    public static parseCylinderProps(json?: CylinderProps): Cone | undefined {\r\n      const start = Reader.parsePoint3dProperty(json, \"start\");\r\n      const end = Reader.parsePoint3dProperty(json, \"end\");\r\n      const radius = Reader.parseNumberProperty(json, \"radius\");\r\n\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false) as boolean;\r\n\r\n      if (start\r\n        && end\r\n        && radius !== undefined) {\r\n        return Cone.createAxisPoints(start, end, radius, radius, capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse line segment (array of 2 points) properties to `LineSegment3d` instance */\r\n    private static parseLineSegmentProps(value: any[]): LineSegment3d | undefined {\r\n      if (Array.isArray(value) && value.length > 1)\r\n        return LineSegment3d.create(Point3d.fromJSON(value[0]), Point3d.fromJSON(value[1]));\r\n      else\r\n        return undefined;\r\n    }\r\n    /** Parse linear sweep content to `LinearSweep` instance. */\r\n    public static parseLinearSweep(json?: any): LinearSweep | undefined {\r\n      const contour = Reader.parse(json.contour);\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\");\r\n      const extrusionVector = Reader.parseVector3dProperty(json, \"vector\");\r\n      if (contour instanceof GeometryQuery\r\n        && \"curveCollection\" === contour.geometryCategory\r\n        && capped !== undefined\r\n        && extrusionVector\r\n      ) {\r\n        return LinearSweep.create(contour, extrusionVector, capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse rotational sweep contents to `RotationalSweep` instance */\r\n    public static parseRotationalSweep(json?: RotationalSweepProps): RotationalSweep | undefined {\r\n      if (json === undefined)\r\n        return undefined;\r\n      const contour = Reader.parse(json.contour);\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\");\r\n      const axisVector = Reader.parseVector3dProperty(json, \"axis\");\r\n      const center = Reader.parsePoint3dProperty(json, \"center\");\r\n      const sweepDegrees = Reader.parseNumberProperty(json, \"sweepAngle\");\r\n      if (contour instanceof GeometryQuery\r\n        && \"curveCollection\" === contour.geometryCategory\r\n        && sweepDegrees !== undefined\r\n        && capped !== undefined\r\n        && axisVector\r\n        && center\r\n      ) {\r\n        return RotationalSweep.create(\r\n          contour,\r\n          Ray3d.createCapture(center, axisVector),\r\n          Angle.createDegrees(sweepDegrees),\r\n          capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse box contents to `Box` instance */\r\n    public static parseBox(json?: BoxProps): Box | undefined {\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false);\r\n      const baseOrigin = Reader.parsePoint3dProperty(json, \"baseOrigin\");\r\n      const baseX = Reader.parseNumberProperty(json, \"baseX\");\r\n      const baseY = Reader.parseNumberProperty(json, \"baseY\", baseX);\r\n      let topOrigin = Reader.parsePoint3dProperty(json, \"topOrigin\");\r\n      const topX = Reader.parseNumberProperty(json, \"topX\", baseX);\r\n      const topY = Reader.parseNumberProperty(json, \"topY\", baseY);\r\n      const height = Reader.parseNumberProperty(json, \"height\", baseX);\r\n      const axes = Reader.parseOrientation(json, true)!;\r\n\r\n      if (baseOrigin && !topOrigin)\r\n        topOrigin = Matrix3d.xyzMinusMatrixTimesXYZ(baseOrigin, axes, Vector3d.create(0, 0, height));\r\n\r\n      if (capped !== undefined\r\n        && baseX !== undefined\r\n        && baseY !== undefined\r\n        && topY !== undefined\r\n        && topX !== undefined\r\n        && axes\r\n        && baseOrigin\r\n        && topOrigin\r\n      ) {\r\n        return Box.createDgnBoxWithAxes(baseOrigin, axes, topOrigin, baseX, baseY, topX, topY, capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse `SphereProps` to `Sphere` instance. */\r\n    public static parseSphere(json?: SphereProps): Sphere | undefined {\r\n      const center = Reader.parsePoint3dProperty(json, \"center\");\r\n      // optional unqualified radius . . .\r\n      const radius = Reader.parseNumberProperty(json, \"radius\");\r\n      // optional specific X\r\n      const radiusX = Reader.parseNumberProperty(json, \"radiusX\", radius);\r\n      // missing Y and Z both pick up radiusX  (which may have already been defaulted from unqualified radius)\r\n      const radiusY = Reader.parseNumberProperty(json, \"radiusX\", radiusX);\r\n      const radiusZ = Reader.parseNumberProperty(json, \"radiusX\", radiusX);\r\n      const latitudeStartEnd = Reader.parseAngleSweepProps(json, \"latitudeStartEnd\"); // this may be undefined!!\r\n\r\n      const axes = Reader.parseOrientation(json, true)!;\r\n\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false);\r\n\r\n      if (center !== undefined\r\n        && radiusX !== undefined\r\n        && radiusY !== undefined\r\n        && radiusZ !== undefined\r\n        && capped !== undefined) {\r\n        return Sphere.createFromAxesAndScales(center, axes, radiusX, radiusY, radiusZ, latitudeStartEnd, capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse RuledSweepProps to RuledSweep instance. */\r\n    public static parseRuledSweep(json?: RuledSweepProps): RuledSweep | undefined {\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false);\r\n      const contours = this.loadContourArray(json, \"contour\");\r\n      if (contours !== undefined\r\n        && capped !== undefined) {\r\n        return RuledSweep.create(contours, capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse TorusPipe props to TorusPipe instance. */\r\n    public static parseTorusPipe(json?: TorusPipeProps): TorusPipe | undefined {\r\n\r\n      const axes = Reader.parseOrientation(json, true)!;\r\n      const center = Reader.parsePoint3dProperty(json, \"center\");\r\n      const radiusA = Reader.parseNumberProperty(json, \"majorRadius\");\r\n      const radiusB = Reader.parseNumberProperty(json, \"minorRadius\");\r\n      const sweepAngle = Reader.parseAngleProperty(json, \"sweepAngle\", undefined);\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false)!;\r\n      if (center\r\n        && radiusA !== undefined\r\n        && radiusB !== undefined\r\n      ) {\r\n\r\n        return TorusPipe.createDgnTorusPipe(center, axes.columnX(), axes.columnY(),\r\n          radiusA, radiusB,\r\n          sweepAngle ? sweepAngle : Angle.createDegrees(360), capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse an array object to array of Point3d instances. */\r\n    public static parsePointArray(json?: any[]): Point3d[] {\r\n      const points = [];\r\n      if (json && Array.isArray(json)) {\r\n        for (const member of json) {\r\n          if (XYZ.isXAndY(member)) {\r\n            points.push(Point3d.fromJSON(member));\r\n          } else if (Geometry.isNumberArray(member, 2)) {\r\n            points.push(Point3d.fromJSON(member));\r\n          }\r\n        }\r\n      }\r\n      return points;\r\n    }\r\n    /** Deserialize `json` to `GeometryQuery` instances. */\r\n    public static parse(json?: any): AnyGeometryQuery | any[] | undefined {\r\n      if (json !== undefined && json as object) {\r\n        if (json.lineSegment !== undefined) {\r\n          return Reader.parseLineSegmentProps(json.lineSegment);\r\n        } else if (json.lineString !== undefined) {\r\n          return LineString3d.create(Reader.parsePointArray(json.lineString));\r\n        } else if (json.arc !== undefined) {\r\n          return Reader.parseArcObject(json.arc);\r\n        } else if (json.hasOwnProperty(\"point\")) {\r\n          return Reader.parseCoordinate(json.point);\r\n\r\n        } else if (json.hasOwnProperty(\"bcurve\")) {\r\n          return Reader.parseBcurve(json.bcurve);\r\n        } else if (json.hasOwnProperty(\"path\")) {\r\n          return Reader.parseCurveCollectionMembers(new Path(), json.path);\r\n        } else if (json.hasOwnProperty(\"loop\")) {\r\n          return Reader.parseCurveCollectionMembers(new Loop(), json.loop);\r\n        } else if (json.hasOwnProperty(\"parityRegion\")) {\r\n          return Reader.parseCurveCollectionMembers(new ParityRegion(), json.parityRegion);\r\n        } else if (json.hasOwnProperty(\"unionRegion\")) {\r\n          return Reader.parseCurveCollectionMembers(new UnionRegion(), json.unionRegion);\r\n        } else if (json.hasOwnProperty(\"bagOfCurves\")) {\r\n          return Reader.parseCurveCollectionMembers(new BagOfCurves(), json.bagOfCurves);\r\n        } else if (json.hasOwnProperty(\"indexedMesh\")) {\r\n          return Reader.parseIndexedMesh(json.indexedMesh);\r\n        } else if (json.hasOwnProperty(\"bsurf\")) {\r\n          return Reader.parseBsurf(json.bsurf);\r\n        } else if (json.hasOwnProperty(\"cone\")) {\r\n          return Reader.parseConeProps(json.cone);\r\n        } else if (json.hasOwnProperty(\"cylinder\")) {\r\n          return Reader.parseCylinderProps(json.cylinder);\r\n        } else if (json.hasOwnProperty(\"sphere\")) {\r\n          return Reader.parseSphere(json.sphere);\r\n        } else if (json.hasOwnProperty(\"linearSweep\")) {\r\n          return Reader.parseLinearSweep(json.linearSweep);\r\n        } else if (json.hasOwnProperty(\"box\")) {\r\n          return Reader.parseBox(json.box);\r\n        } else if (json.hasOwnProperty(\"rotationalSweep\")) {\r\n          return Reader.parseRotationalSweep(json.rotationalSweep);\r\n        } else if (json.hasOwnProperty(\"ruledSweep\")) {\r\n          return Reader.parseRuledSweep(json.ruledSweep);\r\n        } else if (json.hasOwnProperty(\"torusPipe\")) {\r\n          return Reader.parseTorusPipe(json.torusPipe);\r\n        } else if (json.hasOwnProperty(\"pointString\")) {\r\n          return PointString3d.create(Reader.parsePointArray(json.pointString));\r\n        } else if (json.hasOwnProperty(\"transitionSpiral\")) {\r\n          return Reader.parseTransitionSpiral(json.transitionSpiral);\r\n        } else if (Array.isArray(json))\r\n          return Reader.parseArray(json);\r\n      }\r\n      return undefined;\r\n    }\r\n  }\r\n  // ISSUE: include 3d in names?\r\n  // ISSUE: would like shorter term than lineSegment\r\n  // ISSUE: is arc clear?\r\n  // ISSUE: label center, vectorX, vector90 on arc?\r\n  // ISSUE: sweep data on arc -- serialize as AngleSweep?\r\n  /**\r\n   * Class to deserialize json objects into GeometryQuery objects\r\n   * @public\r\n   */\r\n  export class Writer extends GeometryHandler {\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleLineSegment3d(data: LineSegment3d): any {\r\n      return { \"lineSegment\": [data.point0Ref.toJSON(), data.point1Ref.toJSON()] };\r\n    }\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleCoordinateXYZ(data: CoordinateXYZ): any {\r\n      return { \"point\": data.point.toJSON() };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleArc3d(data: Arc3d): any {\r\n      return {\r\n        \"arc\": {\r\n          \"center\": data.center.toJSON(),\r\n          \"vectorX\": data.vector0.toJSON(),\r\n          \"vectorY\": data.vector90.toJSON(),\r\n          \"sweepStartEnd\": [data.sweep.startDegrees, data.sweep.endDegrees],\r\n        },\r\n      };\r\n    }\r\n    /**\r\n     * Insert orientation description to a data object.\r\n     * @param matrix matrix with orientation\r\n     * @param omitIfIdentity omit the axis data if the matrix is an identity.\r\n     * @param data AxesProps object to be annotated.\r\n     */\r\n    private static insertOrientationFromMatrix(data: AxesProps, matrix: Matrix3d | undefined, omitIfIdentity: boolean) {\r\n      if (omitIfIdentity) {\r\n        if (matrix === undefined)\r\n          return;\r\n        if (matrix.isIdentity)\r\n          return;\r\n      }\r\n      if (matrix)\r\n        data.xyVectors = [matrix.columnX().toJSON(), matrix.columnY().toJSON()];\r\n      else\r\n        data.xyVectors = [[1, 0, 0], [0, 1, 0]];\r\n    }\r\n    private static isIdentityXY(xVector: Vector3d, yVector: Vector3d): boolean {\r\n      return xVector.isAlmostEqualXYZ(1, 0, 0) && yVector.isAlmostEqualXYZ(0, 1, 0);\r\n    }\r\n\r\n    /**\r\n     * Insert orientation description to a data object.\r\n     * @param matrix matrix with orientation\r\n     * @param omitIfIdentity omit the axis data if the matrix is an identity.\r\n     * @param data AxesProps object to be annotated.\r\n     */\r\n    private static insertOrientationFromXYVectors(data: AxesProps, vectorX: Vector3d, vectorY: Vector3d, omitIfIdentity: boolean) {\r\n      if (omitIfIdentity && Writer.isIdentityXY(vectorX, vectorY))\r\n        return;\r\n      data.xyVectors = [vectorX.toJSON(), vectorY.toJSON()];\r\n    }\r\n\r\n    /**\r\n     * Insert orientation description to a data object, with orientation defined by u and v direction\r\n     * vectors.\r\n     * @param vectorX u direction\r\n     * @param vectorV v direction\r\n     * @param omitIfIdentity omit the axis data if the vectorU and vectorV are global x and y vectors.\r\n     * @param data AxesProps object to be annotated.\r\n     */\r\n    private static insertXYOrientation(data: AxesProps, vectorU: Vector3d, vectorV: Vector3d, omitIfIdentity: boolean) {\r\n      if (omitIfIdentity) {\r\n        if (vectorU.isAlmostEqualXYZ(1, 0, 0) && vectorV.isAlmostEqualXYZ(0, 1, 0))\r\n          return;\r\n      }\r\n      data.xyVectors = [vectorU.toJSON(), vectorV.toJSON()];\r\n    }\r\n    /**\r\n     * parse properties of a TransitionSpiral.\r\n     * @alpha\r\n     */\r\n    public handleTransitionSpiral(data: TransitionSpiral3d): any {\r\n      // TODO: HANDLE NONRIGID TRANSFORM !!\r\n      // the spiral may have indication of how it was defined.  If so, use defined/undefined state of the original data\r\n      // as indication of what current data to use.  (Current data may have changed due to transforms.)\r\n      const originalProperties = data.originalProperties;\r\n\r\n      const value: TransitionSpiralProps = {\r\n        origin: data.localToWorld.origin.toJSON(),\r\n        type: data.getSpiralType()!,\r\n      };\r\n      Writer.insertOrientationFromMatrix(value, data.localToWorld.matrix, true);\r\n\r\n      if (!data.activeFractionInterval.isExact01)\r\n        value.fractionInterval = [data.activeFractionInterval.x0, data.activeFractionInterval.x1];\r\n      // Object.defineProperty(value, \"fractionInterval\", { value: [data.activeFractionInterval.x0, data.activeFractionInterval.x1] });\r\n\r\n      // if possible, do selective output of defining data (omit exactly one out of the 5, matching original definition)\r\n      if (originalProperties !== undefined && originalProperties.numDefinedProperties() === 4) {\r\n        if (originalProperties.radius0 !== undefined)\r\n          value.startRadius = data.radius01.x0;\r\n        if (originalProperties.radius1 !== undefined)\r\n          value.endRadius = data.radius01.x1;\r\n        if (originalProperties.bearing0 !== undefined)\r\n          value.startBearing = data.bearing01.startAngle.toJSON();\r\n        if (originalProperties.bearing1 !== undefined)\r\n          value.endBearing = data.bearing01.endAngle.toJSON();\r\n        if (originalProperties.curveLength !== undefined)\r\n          value.curveLength = data.curveLength();\r\n      } else {\r\n        // uh oh ... no original data, but the spiral itself knows all 5 values.  We don't know which to consider primary.\r\n        // DECISION -- put everything out, let readers make sense if they can. (It should be consistent ?)\r\n        value.startRadius = data.radius01.x0;\r\n        value.endRadius = data.radius01.x1;\r\n        value.startBearing = data.bearing01.startAngle.toJSON();\r\n        value.endBearing = data.bearing01.endAngle.toJSON();\r\n        value.curveLength = data.curveLength();\r\n      }\r\n      return { \"transitionSpiral\": value };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleCone(data: Cone): any {\r\n\r\n      const radiusA = data.getRadiusA();\r\n      const radiusB = data.getRadiusB();\r\n      const centerA = data.getCenterA();\r\n      const centerB = data.getCenterB();\r\n      const vectorX = data.getVectorX();\r\n      const vectorY = data.getVectorY();\r\n      const axisVector = Vector3d.createStartEnd(centerA, centerB);\r\n\r\n      if (Geometry.isSameCoordinate(radiusA, radiusB)\r\n        && vectorX.isPerpendicularTo(axisVector)\r\n        && vectorY.isPerpendicularTo(axisVector)\r\n        && Geometry.isSameCoordinate(vectorX.magnitude(), 1.0)\r\n        && Geometry.isSameCoordinate(vectorY.magnitude(), 1.0)) {\r\n        return {\r\n          \"cylinder\": {\r\n            \"capped\": data.capped,\r\n            \"start\": data.getCenterA().toJSON(),\r\n            \"end\": data.getCenterB().toJSON(),\r\n            \"radius\": radiusA,\r\n          },\r\n        };\r\n      } else {\r\n        const coneProps: ConeProps = {\r\n          \"capped\": data.capped,\r\n          \"start\": data.getCenterA().toJSON(),\r\n          \"end\": data.getCenterB().toJSON(),\r\n          \"startRadius\": data.getRadiusA(),\r\n          \"endRadius\": data.getRadiusB(),\r\n        };\r\n        Writer.insertOrientationFromXYVectors(coneProps, vectorX, vectorY, false);\r\n        return { \"cone\": coneProps };\r\n      }\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleSphere(data: Sphere): any {\r\n      const xData = data.cloneVectorX().normalizeWithLength();\r\n      const yData = data.cloneVectorY().normalizeWithLength();\r\n      const zData = data.cloneVectorZ().normalizeWithLength();\r\n      const latitudeSweep = data.cloneLatitudeSweep();\r\n\r\n      const rX = xData.mag;\r\n      const rY = yData.mag;\r\n      const rZ = zData.mag;\r\n      if (xData.v && zData.v) {\r\n        const value: SphereProps = {\r\n          \"center\": data.cloneCenter().toJSON(),\r\n        };\r\n        if (!(data.getConstructiveFrame()!).matrix.isIdentity)\r\n          value.zxVectors = [zData.v.toJSON(), xData.v.toJSON()];\r\n        const fullSweep = latitudeSweep.isFullLatitudeSweep;\r\n\r\n        if (data.capped && !fullSweep)\r\n          value.capped = data.capped;\r\n\r\n        if (Geometry.isSameCoordinate(rX, rY) && Geometry.isSameCoordinate(rX, rZ))\r\n          value.radius = rX;\r\n        else {\r\n          value.radiusX = rX;\r\n          value.radiusY = rY;\r\n          value.radiusZ = rZ;\r\n        }\r\n        if (!fullSweep)\r\n          value.latitudeStartEnd = latitudeSweep.toJSON();\r\n        return { \"sphere\": value };\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleTorusPipe(data: TorusPipe): any {\r\n\r\n      const vectorX = data.cloneVectorX();\r\n      const vectorY = data.cloneVectorY();\r\n      const radiusA = data.getMajorRadius();\r\n      const radiusB = data.getMinorRadius();\r\n      const sweep = data.getSweepAngle();\r\n      if (data.getIsReversed()) {\r\n        vectorY.scaleInPlace(-1.0);\r\n        sweep.setRadians(-sweep.radians);\r\n      }\r\n      const value: TorusPipeProps = {\r\n        \"center\": data.cloneCenter().toJSON(),\r\n        \"majorRadius\": radiusA,\r\n        \"minorRadius\": radiusB,\r\n        \"xyVectors\": [vectorX.toJSON(), vectorY.toJSON()],\r\n      };\r\n      if (!sweep.isFullCircle) {\r\n        value.sweepAngle = sweep.degrees;\r\n        value.capped = data.capped;\r\n      }\r\n      return { \"torusPipe\": value };\r\n\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleLineString3d(data: LineString3d): any {\r\n      const pointsA = data.points;\r\n      const pointsB = [];\r\n      if (pointsA)\r\n        for (const p of pointsA) pointsB.push(p.toJSON());\r\n      return { \"lineString\": pointsB };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handlePointString3d(data: PointString3d): any {\r\n      const pointsA = data.points;\r\n      const pointsB = [];\r\n      if (pointsA)\r\n        for (const p of pointsA) pointsB.push(p.toJSON());\r\n      return { \"pointString\": pointsB };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handlePath(data: Path): any {\r\n      return { \"path\": this.collectChildren(data) };\r\n    }\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleLoop(data: Loop): any {\r\n      return { \"loop\": this.collectChildren(data) };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleParityRegion(data: ParityRegion): any {\r\n      return { \"parityRegion\": this.collectChildren(data) };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleUnionRegion(data: UnionRegion): any {\r\n      return { \"unionRegion\": this.collectChildren(data) };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBagOfCurves(data: BagOfCurves): any {\r\n      return { \"bagOfCurves\": this.collectChildren(data) };\r\n    }\r\n\r\n    private collectChildren(data: CurveCollection): any[] {\r\n      const children = [];\r\n      if (data.children && Array.isArray(data.children)) {\r\n        for (const child of data.children) {\r\n          const cdata = child.dispatchToGeometryHandler(this);\r\n          if (cdata)\r\n            children.push(cdata);\r\n        }\r\n      }\r\n      return children;\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleLinearSweep(data: LinearSweep): any {\r\n      const extrusionVector = data.cloneSweepVector();\r\n      const curves = data.getCurvesRef();\r\n      const capped = data.capped;\r\n      if (extrusionVector\r\n        && curves\r\n        && capped !== undefined) {\r\n        return {\r\n          \"linearSweep\": {\r\n            \"contour\": curves.dispatchToGeometryHandler(this),\r\n            \"capped\": capped,\r\n            \"vector\": extrusionVector.toJSON(),\r\n          },\r\n        };\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleRuledSweep(data: RuledSweep): any {\r\n      const contours = data.cloneContours();\r\n      const capped = data.capped;\r\n      if (contours\r\n        && contours.length > 1\r\n        && capped !== undefined) {\r\n        const jsonContours = [];\r\n        for (const c of contours) {\r\n          jsonContours.push(this.emit(c));\r\n        }\r\n        return {\r\n          \"ruledSweep\": {\r\n            \"contour\": jsonContours,\r\n            \"capped\": capped,\r\n          },\r\n        };\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleRotationalSweep(data: RotationalSweep): any {\r\n      const axisRay = data.cloneAxisRay();\r\n      const curves = data.getCurves();\r\n      const capped = data.capped;\r\n      const sweepAngle = data.getSweep();\r\n      return {\r\n        \"rotationalSweep\": {\r\n          \"axis\": axisRay.direction.toJSON(),\r\n          \"contour\": curves.dispatchToGeometryHandler(this),\r\n          \"capped\": capped,\r\n          \"center\": axisRay.origin.toJSON(),\r\n          \"sweepAngle\": sweepAngle.degrees,\r\n        },\r\n      };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBox(box: Box): any {\r\n      const out: any = {\r\n        \"box\": {\r\n          \"baseOrigin\": box.getBaseOrigin().toJSON(),\r\n          \"baseX\": box.getBaseX(),\r\n          \"baseY\": box.getBaseY(),\r\n          \"capped\": box.capped,\r\n          \"topOrigin\": box.getTopOrigin().toJSON(),\r\n        },\r\n      };\r\n      Writer.insertXYOrientation(out.box, box.getVectorX(), box.getVectorY(), true);\r\n      if (!Geometry.isSameCoordinate(box.getTopX(), box.getBaseX()))\r\n        out.box.topX = box.getTopX();\r\n      if (!Geometry.isSameCoordinate(box.getTopY(), box.getBaseY()))\r\n        out.box.topY = box.getTopY();\r\n\r\n      return out;\r\n    }\r\n\r\n    private handlePolyfaceAuxData(auxData: PolyfaceAuxData, pf: IndexedPolyface): any {\r\n      const contents: { [k: string]: any } = {};\r\n      contents.indices = [];\r\n      const visitor = pf.createVisitor(0);\r\n      if (!visitor.auxData) return;\r\n\r\n      while (visitor.moveToNextFacet()) {\r\n        for (let i = 0; i < visitor.indexCount; i++) {\r\n          contents.indices.push(visitor.auxData.indices[i] + 1);\r\n        }\r\n        contents.indices.push(0);  // facet terminator.\r\n      }\r\n      contents.channels = [];\r\n      for (const inChannel of auxData.channels) {\r\n        const outChannel: { [k: string]: any } = {};\r\n        outChannel.dataType = inChannel.dataType;\r\n        outChannel.name = inChannel.name;\r\n        outChannel.inputName = inChannel.inputName;\r\n        outChannel.data = [];\r\n        for (const inData of inChannel.data) {\r\n          const outData: { [k: string]: any } = {};\r\n          outData.input = inData.input;\r\n          outData.values = inData.values.slice(0);\r\n          outChannel.data.push(outData);\r\n        }\r\n\r\n        contents.channels.push(outChannel);\r\n      }\r\n      return contents;\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleIndexedPolyface(pf: IndexedPolyface): any {\r\n      const points = [];\r\n      const pointIndex: number[] = [];\r\n      const normals = [];\r\n      const params = [];\r\n      const colors = [];\r\n      {\r\n        const p = Point3d.create();\r\n        for (let i = 0; pf.data.point.getPoint3dAtCheckedPointIndex(i, p); i++)\r\n          points.push(p.toJSON());\r\n      }\r\n      if (pf.data.normal) {\r\n        const numNormal = pf.data.normal.length;\r\n        const normal = Vector3d.create();\r\n        for (let i = 0; i < numNormal; i++) {\r\n          pf.data.normal.getVector3dAtCheckedVectorIndex(i, normal);\r\n          normals.push(normal.toJSON());\r\n        }\r\n\r\n      }\r\n\r\n      if (pf.data.param) {\r\n        const uv = Point2d.create();\r\n        for (let i = 0; pf.data.param.getPoint2dAtCheckedPointIndex(i, uv); i++)\r\n          params.push(uv.toJSON());\r\n      }\r\n\r\n      if (pf.data.color) {\r\n        for (const value of pf.data.color) colors.push(value);\r\n      }\r\n\r\n      const visitor = pf.createVisitor(0);\r\n      let indexCounter = 0;\r\n\r\n      const normalIndex = [];\r\n      const paramIndex = [];\r\n      const colorIndex = [];\r\n\r\n      let n;\r\n      while (visitor.moveToNextFacet()) {\r\n        n = visitor.indexCount;\r\n        // All meshes have point and point index ...\r\n        for (let i = 0; i < n; i++) {\r\n          // Change sign of value to be pushed based on whether or not the edge was originally visible or not\r\n          const toPush = pf.data.edgeVisible[indexCounter + i] ? visitor.pointIndex[i] + 1 : - (visitor.clientPointIndex(i) + 1);\r\n          pointIndex.push(toPush);\r\n        }\r\n        pointIndex.push(0);  // facet terminator.\r\n        indexCounter += visitor.indexCount;\r\n\r\n        if (visitor.normalIndex) {\r\n          for (let i = 0; i < n; i++) normalIndex.push(1 + visitor.clientNormalIndex(i));\r\n          normalIndex.push(0);\r\n        }\r\n        if (visitor.paramIndex) {\r\n          for (let i = 0; i < n; i++) paramIndex.push(1 + visitor.clientParamIndex(i));\r\n          paramIndex.push(0);\r\n        }\r\n        if (visitor.colorIndex) {\r\n          for (let i = 0; i < n; i++) colorIndex.push(1 + visitor.clientColorIndex(i));\r\n          colorIndex.push(0);\r\n        }\r\n      }\r\n      // assemble the contents in alphabetical order.\r\n      const contents: { [k: string]: any } = {};\r\n      if (pf.twoSided)\r\n        contents.twoSided = true;\r\n      if (pf.data.auxData)\r\n        contents.auxData = this.handlePolyfaceAuxData(pf.data.auxData, pf);\r\n\r\n      if (pf.data.color) contents.color = colors;\r\n      if (pf.data.colorIndex) contents.colorIndex = colorIndex;\r\n\r\n      if (pf.data.normal) contents.normal = normals;\r\n      if (pf.data.normalIndex) contents.normalIndex = normalIndex;\r\n\r\n      if (pf.data.param) contents.param = params;\r\n      if (pf.data.paramIndex) contents.paramIndex = paramIndex;\r\n\r\n      contents.point = points;\r\n      contents.pointIndex = pointIndex;\r\n\r\n      return { \"indexedMesh\": contents };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBSplineCurve3d(curve: BSplineCurve3d): any {\r\n      // ASSUME -- if the curve originated \"closed\" the knot and pole replication are unchanged,\r\n      // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.\r\n      const wrapMode = curve.isClosable;\r\n      if (wrapMode === BSplineWrapMode.OpenByAddingControlPoints) {\r\n        const knots = curve.copyKnots(true);\r\n        const poles = curve.copyPoints();\r\n        const degree = curve.degree;\r\n        for (let i = 0; i < degree; i++) poles.pop();\r\n        // knots have replicated first and last.  Change the values to be periodic.\r\n        const leftIndex = degree;\r\n        const rightIndex = knots.length - degree - 1;\r\n        const knotPeriod = knots[rightIndex] - knots[leftIndex];\r\n        knots[0] = knots[rightIndex - degree] - knotPeriod;\r\n        knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;\r\n        return {\r\n          \"bcurve\": {\r\n            \"points\": poles,\r\n            \"knots\": knots,\r\n            \"closed\": true,\r\n            \"order\": curve.order,\r\n          },\r\n        };\r\n      } else if (curve.isClosable === BSplineWrapMode.OpenByRemovingKnots) {\r\n        // special case to re-close the case that originated as :    a a0 a0 .. a0 knot0 knot1 knot2 ... b1 b1 .. b1 b\r\n        // with (order) copies of a0 and b1 (usually 0 and 1)\r\n        // and a,b are related to the interior knots\r\n        // (This is the \"bezier saturated arc\")\r\n        const rawKnots = curve.copyKnots(false); // unchanged knots . . .\r\n        const poles = curve.copyPoints();\r\n        const degree = curve.degree;\r\n        const leftIndex = degree - 1;\r\n        const rightIndex = rawKnots.length - degree;\r\n        const leftKnot = rawKnots[leftIndex];\r\n        const rightKnot = rawKnots[rightIndex];\r\n        const knotPeriod = rightKnot - leftKnot;\r\n        const knots = [];\r\n        knots.push(rawKnots[rightIndex - 1] - knotPeriod);\r\n        knots.push(leftKnot);\r\n        for (const k of rawKnots) knots.push(k);\r\n        knots.push(rightKnot);\r\n        knots.push(rawKnots[leftIndex + 1] + knotPeriod);\r\n        return {\r\n          \"bcurve\": {\r\n            \"points\": poles,\r\n            \"knots\": knots,\r\n            \"closed\": true,\r\n            \"order\": curve.order,\r\n          },\r\n        };\r\n      } else {\r\n        return {\r\n          \"bcurve\": {\r\n            \"points\": curve.copyPoints(),\r\n            \"knots\": curve.copyKnots(true),\r\n            \"closed\": false,\r\n            \"order\": curve.order,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBezierCurve3d(curve: BezierCurve3d): any {\r\n      const knots = [];\r\n      const order = curve.order;\r\n      for (let i = 0; i < order; i++) knots.push(0.0);\r\n      for (let i = 0; i < order; i++) knots.push(1.0);\r\n      return {\r\n        \"bcurve\": {\r\n          \"points\": curve.copyPolesAsJsonArray(),\r\n          \"knots\": knots,\r\n          \"closed\": false,\r\n          \"order\": curve.order,\r\n        },\r\n      };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBSplineCurve3dH(curve: BSplineCurve3dH): any {\r\n      // ASSUME -- if the curve originated \"closed\" the knot and pole replication are unchanged,\r\n      // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.\r\n      if (curve.isClosable) {\r\n        const knots = curve.copyKnots(true);\r\n        const poles = curve.copyPoints();\r\n        const degree = curve.degree;\r\n        for (let i = 0; i < degree; i++) poles.pop();\r\n        // knots have replicated first and last.  Change the values to be periodic.\r\n        const leftIndex = degree;\r\n        const rightIndex = knots.length - degree - 1;\r\n        const knotPeriod = knots[rightIndex] - knots[leftIndex];\r\n        knots[0] = knots[rightIndex - degree] - knotPeriod;\r\n        knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;\r\n        return {\r\n          \"bcurve\": {\r\n            \"points\": poles,\r\n            \"knots\": knots,\r\n            \"closed\": true,\r\n            \"order\": curve.order,\r\n          },\r\n        };\r\n      } else {\r\n        return {\r\n          \"bcurve\": {\r\n            \"points\": curve.copyPoints(),\r\n            \"knots\": curve.copyKnots(true),\r\n            \"closed\": false,\r\n            \"order\": curve.order,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBSplineSurface3d(surface: BSplineSurface3d): any {\r\n      // ASSUME -- if the curve originated \"closed\" the knot and pole replication are unchanged,\r\n      // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.\r\n      const periodicU = surface.isClosable(0);\r\n      const periodicV = surface.isClosable(1);\r\n      if (periodicU || periodicV) {\r\n        let numUPoles = surface.numPolesUV(0);\r\n        let numVPoles = surface.numPolesUV(1);\r\n        if (periodicU) numUPoles -= surface.degreeUV(0);\r\n        if (periodicV) numVPoles -= surface.degreeUV(1);\r\n        const xyz = Point3d.create();\r\n        const grid = [];\r\n        for (let j = 0; j < numVPoles; j++) {\r\n          const stringer = [];\r\n          for (let i = 0; i < numUPoles; i++) {\r\n            surface.getPoint3dPole(i, j, xyz)!;\r\n            stringer.push([xyz.x, xyz.y, xyz.z]);\r\n          }\r\n          grid.push(stringer);\r\n        }\r\n        return {\r\n          \"bsurf\": {\r\n            \"points\": grid,\r\n            \"uKnots\": surface.copyKnots(0, true),\r\n            \"vKnots\": surface.copyKnots(1, true),\r\n            \"orderU\": surface.orderUV(0),\r\n            \"orderV\": surface.orderUV(1),\r\n            \"closedU\": periodicU,\r\n            \"closedV\": periodicV,\r\n          },\r\n        };\r\n      } else {\r\n        return {\r\n          \"bsurf\": {\r\n            \"points\": surface.getPointArray(false),\r\n            \"uKnots\": surface.copyKnots(0, true),\r\n            \"vKnots\": surface.copyKnots(1, true),\r\n            \"orderU\": surface.orderUV(0),\r\n            \"orderV\": surface.orderUV(1),\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBezierCurve3dH(curve: BezierCurve3dH): any {\r\n      const knots = [];\r\n      const order = curve.order;\r\n      for (let i = 0; i < order; i++) knots.push(0.0);\r\n      for (let i = 0; i < order; i++) knots.push(1.0);\r\n      return {\r\n        \"bcurve\": {\r\n          \"points\": curve.copyPolesAsJsonArray(),\r\n          \"knots\": knots,\r\n          \"closed\": false,\r\n          \"order\": curve.order,\r\n        },\r\n      };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBSplineSurface3dH(surface: BSplineSurface3dH): any {\r\n      const data = surface.getPointGridJSON();\r\n      return {\r\n        \"bsurf\": {\r\n          \"points\": data.points,\r\n          \"uKnots\": surface.copyKnots(0, true),\r\n          \"vKnots\": surface.copyKnots(1, true),\r\n          \"orderU\": surface.orderUV(0),\r\n          \"orderV\": surface.orderUV(1),\r\n        },\r\n      };\r\n    }\r\n\r\n    /** Convert an array of strongly typed instances to an array of tagged json */\r\n    public emitArray(data: object[]): any {\r\n      const members = [];\r\n      for (const c of data) {\r\n        const toPush = this.emit(c);\r\n        members.push(toPush);\r\n      }\r\n      return members;\r\n    }\r\n    /** Convert GeometryQuery data (array or single instance) to instance to tagged json */\r\n    public emit(data: any): any {\r\n      if (Array.isArray(data))\r\n        return this.emitArray(data);\r\n\r\n      if (data instanceof GeometryQuery) {\r\n        return data.dispatchToGeometryHandler(this);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** One-step static method to create a writer and emit a json object */\r\n    public static toIModelJson(data: any): any {\r\n      const writer = new Writer();\r\n      return writer.emit(data);\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\n/**\r\n * A box-like solid defined by\r\n * * A local coordinate frame\r\n *   * (0,0,0) is left lower rear corner of box (considering \"left\" to reference x, \"lower\" to reference y, \"rear and front\" to reference z=0 and z=1)\r\n *   * (0,0,1) is left lower front corner.\r\n *   * (baseX,baseY,z) is right upper corner at z\r\n *   * note that the frame x and y columns are usually unit vectors in local space, but z is full rear to front vector\r\n * * The separate values for base and top x and y allow the box to be a \"view frustum\" with parallel back and front planes but independent x and y bellows effects.\r\n * @public\r\n */\r\nexport class Box extends SolidPrimitive {\r\n  /** String name for schema properties */\r\n  public readonly solidPrimitiveType = \"box\";\r\n\r\n  private _localToWorld: Transform;\r\n  private _baseX: number;\r\n  private _baseY: number;\r\n  private _topX: number;\r\n  private _topY: number;\r\n\r\n  protected constructor(map: Transform,\r\n    baseX: number, baseY: number, topX: number, topY: number, capped: boolean) {\r\n    super(capped);\r\n    this._localToWorld = map;\r\n    this._baseX = baseX;\r\n    this._baseY = baseY;\r\n    this._topX = topX;\r\n    this._topY = topY;\r\n  }\r\n  /** Return a clone */\r\n  public clone(): Box {\r\n    return new Box(this._localToWorld.clone(), this._baseX, this._baseY, this._topX, this._topY, this.capped);\r\n  }\r\n\r\n  /** Return a coordinate frame (right handed unit vectors)\r\n   * * origin lower left of box\r\n   * * x direction on base rectangle x edge\r\n   * * y direction in base rectangle\r\n   * * z direction perpendicular\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    return this._localToWorld.cloneRigid();\r\n  }\r\n  /** Apply the transform to the box's `localToWorld` frame.\r\n   * * Note that this may make the frame nonrigid.\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\r\n    return true;\r\n  }\r\n  /** Clone the box and immediately apply `transform` to the local frame of the clone. */\r\n  public cloneTransformed(transform: Transform): Box | undefined {\r\n    const result = this.clone();\r\n    transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a new box from vector and size daa.\r\n   * @param baseOrigin Origin of base rectangle\r\n   * @param vectorX  Direction for base rectangle\r\n   * @param vectorY Direction for base rectangle\r\n   * @param topOrigin origin of top rectangle\r\n   * @param baseX size factor for base rectangle (multiplies vectorX)\r\n   * @param baseY size factor for base rectangle (multiplies vectorY)\r\n   * @param topX size factor for top rectangle (multiplies vectorX)\r\n   * @param topY size factor for top rectangle (multiplies vectorY)\r\n   * @param capped true to define top and bottom closure caps\r\n   */\r\n  public static createDgnBox(baseOrigin: Point3d, vectorX: Vector3d, vectorY: Vector3d,\r\n    topOrigin: Point3d,\r\n    baseX: number, baseY: number, topX: number, topY: number,\r\n    capped: boolean): Box | undefined {\r\n    const vectorZ = baseOrigin.vectorTo(topOrigin);\r\n    const localToWorld = Transform.createOriginAndMatrixColumns(baseOrigin, vectorX, vectorY, vectorZ);\r\n    return new Box(localToWorld, baseX, baseY, topX, topY, capped);\r\n  }\r\n\r\n  /**\r\n   * Create a new box with xy directions taken from columns of the `axes` matrix.\r\n   * @param baseOrigin Origin of base rectangle\r\n   * @param axes  Direction for base rectangle\r\n   * @param topOrigin origin of top rectangle\r\n   * @param baseX size factor for base rectangle (multiplies vectorX)\r\n   * @param baseY size factor for base rectangle (multiplies vectorY)\r\n   * @param topX size factor for top rectangle (multiplies vectorX)\r\n   * @param topY size factor for top rectangle (multiplies vectorY)\r\n   * @param capped true to define top and bottom closure caps\r\n   */\r\n  public static createDgnBoxWithAxes(baseOrigin: Point3d, axes: Matrix3d,\r\n    topOrigin: Point3d,\r\n    baseX: number, baseY: number, topX: number, topY: number,\r\n    capped: boolean): Box | undefined {\r\n    return Box.createDgnBox(baseOrigin, axes.columnX(), axes.columnY(), topOrigin,\r\n      baseX, baseY, topX, topY, capped);\r\n  }\r\n\r\n  /**\r\n   * Create an axis-aligned `Box` primitive for a range.\r\n   * @param range range corners Origin of base rectangle\r\n   * @param capped true to define top and bottom closure caps\r\n   */\r\n  public static createRange(range: Range3d, capped: boolean): Box | undefined {\r\n    if (!range.isNull) {\r\n      const lowPoint = range.low;\r\n      const xSize = range.xLength();\r\n      const ySize = range.yLength();\r\n      const zPoint = range.low.clone();\r\n      zPoint.z = zPoint.z + range.zLength();\r\n      return Box.createDgnBox(\r\n        lowPoint,\r\n        Vector3d.unitX(), Vector3d.unitY(),\r\n        zPoint,\r\n        xSize, ySize, xSize, ySize, capped);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** (property accessor) return the x length at z = 0 */\r\n  public getBaseX(): number { return this._baseX; }\r\n  /** (property accessor) return the y length at z = 0 */\r\n  public getBaseY(): number { return this._baseY; }\r\n  /** (property accessor) return the x length at z = 1 */\r\n  public getTopX(): number { return this._topX; }\r\n  /** (property accessor) return the x length at z = 1 */\r\n  public getTopY(): number { return this._topY; }\r\n  /** (property accessor) return the local coordinates point (0,0,0) to world */\r\n  public getBaseOrigin(): Point3d { return this._localToWorld.multiplyXYZ(0, 0, 0); }\r\n  /** (property accessor) return the local coordinates point (0,0,1) to world */\r\n  public getTopOrigin(): Point3d { return this._localToWorld.multiplyXYZ(0, 0, 1); }\r\n  /** (property accessor) return the local coordinate frame x vector */\r\n  public getVectorX(): Vector3d { return this._localToWorld.matrix.columnX(); }\r\n  /** (property accessor) return the local coordinate frame y vector */\r\n  public getVectorY(): Vector3d { return this._localToWorld.matrix.columnY(); }\r\n  /** (property accessor) return the local coordinate frame z vector */\r\n  public getVectorZ(): Vector3d { return this._localToWorld.matrix.columnZ(); }\r\n  /** Test of `other` is also of class `Box` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof Box; }\r\n  /** test for near equality */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof Box) {\r\n      if (this.capped !== other.capped) return false;\r\n      if (!this._localToWorld.isAlmostEqual(other._localToWorld)) return false;\r\n      return Geometry.isSameCoordinate(this._baseX, other._baseX)\r\n        && Geometry.isSameCoordinate(this._baseY, other._baseY)\r\n        && Geometry.isSameCoordinate(this._topX, other._topX)\r\n        && Geometry.isSameCoordinate(this._topY, other._topY);\r\n    }\r\n    return false;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBox(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBox(this);\r\n  }\r\n  /** Return strokes of the cross-section rectangle at local z coordinate */\r\n  public strokeConstantVSection(zFraction: number): LineString3d {\r\n    const ax = Geometry.interpolate(this._baseX, zFraction, this._topX);\r\n    const ay = Geometry.interpolate(this._baseY, zFraction, this._topY);\r\n    const result = LineString3d.create();\r\n    const transform = this._localToWorld;\r\n    const workPoint = Point3d.create();\r\n    transform.multiplyXYZ(0, 0, zFraction, workPoint);\r\n    result.addPoint(workPoint);\r\n    transform.multiplyXYZ(ax, 0, zFraction, workPoint);\r\n    result.addPoint(workPoint);\r\n    transform.multiplyXYZ(ax, ay, zFraction, workPoint);\r\n    result.addPoint(workPoint);\r\n    transform.multiplyXYZ(0, ay, zFraction, workPoint);\r\n    result.addPoint(workPoint);\r\n    transform.multiplyXYZ(0, 0, zFraction, workPoint);\r\n    result.addPoint(workPoint);\r\n    return result;\r\n  }\r\n  /**\r\n   * Returns the 8 corners in x fastest, then y, finally z lexical order.\r\n   */\r\n  public getCorners(): Point3d[] {\r\n    const transform = this._localToWorld;\r\n    const ax = this._baseX;\r\n    const ay = this._baseY;\r\n    const bx = this._topX;\r\n    const by = this._topY;\r\n    return [transform.multiplyXYZ(0, 0, 0),\r\n    transform.multiplyXYZ(ax, 0, 0),\r\n    transform.multiplyXYZ(0, ay, 0),\r\n    transform.multiplyXYZ(ax, ay, 0),\r\n    transform.multiplyXYZ(0, 0, 1),\r\n    transform.multiplyXYZ(bx, 0, 1),\r\n    transform.multiplyXYZ(0, by, 1),\r\n    transform.multiplyXYZ(bx, by, 1)];\r\n  }\r\n\r\n  /**\r\n   * Consider the box sides (not top and bottom) as a (u,v) surface with\r\n   * * v = 0 as the z=0 local plane\r\n   * * v = 1 as the z=1 local plane\r\n   * Return the (rectangular) section at fractional v\r\n   */\r\n  public constantVSection(zFraction: number): CurveCollection {\r\n    const ls = this.strokeConstantVSection(zFraction);\r\n    return Loop.create(ls);\r\n  }\r\n  /** Extend  `rangeToExtend` by each of the 8 corners */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    const boxTransform = this._localToWorld;\r\n    const ax = this._baseX;\r\n    const ay = this._baseY;\r\n    const bx = this._topX;\r\n    const by = this._topY;\r\n    if (transform) {\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 0);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, ax, 0, 0);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, ay, 0);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, ax, ay, 0);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 1);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, bx, 0, 1);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, by, 1);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, bx, by, 1);\r\n    } else {\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, 0, 0, 0);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, ax, 0, 0);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, 0, ay, 0);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, ax, ay, 0);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, 0, 0, 1);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, bx, 0, 1);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, 0, by, 1);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, bx, by, 1);\r\n    }\r\n  }\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GeometryHandler, UVSurface, UVSurfaceIsoParametricDistance } from \"../geometry3d/GeometryHandler\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\n\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\n/**\r\n * A cone with axis along the z axis of a (possibly skewed) local coordinate system.\r\n *\r\n * * In local coordinates, the sections at z=0 and z=1 are circles of radius r0 and r1.\r\n * * Either one individually  may be zero, but they may not both be zero.\r\n * * The stored matrix has unit vectors in the xy columns, and full-length z column.\r\n * @public\r\n */\r\nexport class Cone extends SolidPrimitive implements UVSurface, UVSurfaceIsoParametricDistance {\r\n  /** String name for schema properties */\r\n  public readonly solidPrimitiveType = \"cone\";\r\n\r\n  private _localToWorld: Transform;       // Transform from local to global.\r\n  private _radiusA: number;    // nominal radius at z=0.  skewed axes may make it an ellipse\r\n  private _radiusB: number;    // radius at z=1.  skewed axes may make it an ellipse\r\n  private _maxRadius: number; // maximum radius anywhere on the cone.\r\n  protected constructor(map: Transform, radiusA: number, radiusB: number, capped: boolean) {\r\n    super(capped);\r\n    this._localToWorld = map;\r\n    this._radiusA = radiusA;\r\n    this._radiusB = radiusB;\r\n    this._maxRadius = Math.max(this._radiusA, this._radiusB);  // um... should resolve elliptical sections\r\n  }\r\n  /** Return a clone of this Cone. */\r\n  public clone(): Cone {\r\n    return new Cone(this._localToWorld.clone(), this._radiusA, this._radiusB, this.capped);\r\n  }\r\n  /** Return a coordinate frame (right handed unit vectors)\r\n   * * origin at center of the base circle.\r\n   * * base circle in the xy plane\r\n   * * z axis by right hand rule.\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    return this._localToWorld.cloneRigid();\r\n  }\r\n  /** Apply the transform to this cone's locla to world coordinates.\r\n   * * Note that the radii are not changed.  Scaling is absorbed into the frame.\r\n   * * This fails if the transformation is singular.\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\r\n    return true;\r\n  }\r\n  /**\r\n   * Create a clone and immediately transform the clone.\r\n   */\r\n  public cloneTransformed(transform: Transform): Cone | undefined {\r\n    const result = this.clone();\r\n    transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);\r\n    return result;\r\n  }\r\n  /** create a cylinder or cone from two endpoints and their radii.   The circular cross sections are perpendicular to the axis line\r\n   * from start to end point.\r\n   * * both radii must be of the same sign.\r\n   * * negative radius is accepted to create interior surface.    Downstream effects of that combined with capping may be a problem.\r\n   */\r\n  public static createAxisPoints(centerA: Point3d, centerB: Point3d, radiusA: number, radiusB: number, capped: boolean): Cone | undefined {\r\n    const zDirection = centerA.vectorTo(centerB);\r\n    const a = zDirection.magnitude();\r\n    if (Geometry.isSmallMetricDistance(a)) return undefined;\r\n    // force near-zero radii to true zero\r\n    radiusA = Geometry.correctSmallMetricDistance(radiusA);\r\n    radiusB = Geometry.correctSmallMetricDistance(radiusB);\r\n    // cone tip may not be \"within\" the z range.\r\n    if (radiusA * radiusB < 0.0) return undefined;\r\n    // at least one must be nonzero.\r\n    if (radiusA + radiusB === 0.0) return undefined;\r\n    const matrix = Matrix3d.createRigidHeadsUp(zDirection);\r\n    matrix.scaleColumns(1.0, 1.0, a, matrix);\r\n    const localToWorld = Transform.createOriginAndMatrix(centerA, matrix);\r\n    return new Cone(localToWorld, radiusA, radiusB, capped);\r\n  }\r\n  /** create a cylinder or cone from axis start and end with cross section defined by vectors that do not need to be perpendicular to each other or\r\n   * to the axis.\r\n   */\r\n  public static createBaseAndTarget(centerA: Point3d, centerB: Point3d, vectorX: Vector3d, vectorY: Vector3d, radiusA: number, radiusB: number, capped: boolean) {\r\n    radiusA = Math.abs(Geometry.correctSmallMetricDistance(radiusA));\r\n    radiusB = Math.abs(Geometry.correctSmallMetricDistance(radiusB));\r\n    const vectorZ = centerA.vectorTo(centerB);\r\n    const localToWorld = Transform.createOriginAndMatrixColumns(centerA, vectorX, vectorY, vectorZ);\r\n    return new Cone(localToWorld, radiusA, radiusB, capped);\r\n  }\r\n/** (Property accessor) Return the center point at the base plane */\r\n  public getCenterA(): Point3d { return this._localToWorld.multiplyXYZ(0, 0, 0); }\r\n  /** (Property accessor) */\r\n  public getCenterB(): Point3d { return this._localToWorld.multiplyXYZ(0, 0, 1); }\r\n  /** (Property accessor) Return the x vector in the local frame */\r\n  public getVectorX(): Vector3d { return this._localToWorld.matrix.columnX(); }\r\n  /** (Property accessor) Return the y vector in the local frame */\r\n  public getVectorY(): Vector3d { return this._localToWorld.matrix.columnY(); }\r\n  /** (Property accessor) return the radius at the base plane */\r\n  public getRadiusA(): number { return this._radiusA; }\r\n  /** (Property accessor) return the radius at the top plane */\r\n  public getRadiusB(): number { return this._radiusB; }\r\n  /** (Property accessor) return the larger of the base and top plane radii */\r\n  public getMaxRadius(): number { return this._maxRadius; }\r\n  /** (Property accessor) return the radius at fraction `v` along the axis */\r\n  public vFractionToRadius(v: number): number { return Geometry.interpolate(this._radiusA, v, this._radiusB); }\r\n  /** (Property accessor) test if `other` is an instance of `Cone` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof Cone; }\r\n  /** (Property accessor) Test for nearly equal coordinate data. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof Cone) {\r\n      if (this.capped !== other.capped) return false;\r\n      if (!this._localToWorld.isAlmostEqual(other._localToWorld)) return false;\r\n      return Geometry.isSameCoordinate(this._radiusA, other._radiusA)\r\n        && Geometry.isSameCoordinate(this._radiusB, other._radiusB);\r\n    }\r\n    return false;\r\n  }\r\n/** Second step of double dispatch:   call `handler.handleCone(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleCone(this);\r\n  }\r\n\r\n  /**\r\n   *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.\r\n   * * fixedStrokeCount takes priority over stroke options.\r\n   * * The linestring is created by LineString3d.createForStrokes (fixedStrokeCount, options), which sets up property according to the options:\r\n   *   * optional fractions member\r\n   *   * optional uvParams.  uvParams are installed as full-scale distance parameters.\r\n   *   * optional derivatives.\r\n   * @param v fractional position along the cone axis\r\n   * @param fixedStrokeCount optional stroke count.\r\n   * @param options optional stroke options.\r\n   */\r\n  public strokeConstantVSection(v: number, fixedStrokeCount: number | undefined, options: StrokeOptions | undefined): LineString3d {\r\n    let strokeCount = 16;\r\n    if (fixedStrokeCount !== undefined)\r\n      strokeCount = fixedStrokeCount;\r\n    else if (options !== undefined)\r\n      strokeCount = options.defaultCircleStrokes;   // NEEDS WORK -- get circle stroke count with this.maxRadius !!!\r\n    else {\r\n      // accept the local default\r\n    }\r\n    strokeCount = Geometry.clampToStartEnd(strokeCount, 4, 64);\r\n    const r = this.vFractionToRadius(v);\r\n    const result = LineString3d.createForStrokes(fixedStrokeCount, options);\r\n    const twoPi = Math.PI * 2.0;\r\n    const deltaRadians = twoPi / strokeCount;\r\n    let radians = 0;\r\n    const fractions = result.fractions;     // possibly undefined !!!\r\n    const derivatives = result.packedDerivatives; // possibly undefined !!!\r\n    const uvParams = result.packedUVParams; // possibly undefined !!\r\n    const surfaceNormals = result.packedSurfaceNormals;\r\n    const xyz = Point3d.create();\r\n    const dXdu = Vector3d.create();\r\n    const dXdv = Vector3d.create();\r\n    const normal = Vector3d.create();\r\n    const transform = this._localToWorld;\r\n    let rc, rs, cc, ss;\r\n    for (let i = 0; i <= strokeCount; i++) {\r\n      if (i * 2 <= strokeCount)\r\n        radians = i * deltaRadians;\r\n      else\r\n        radians = (i - strokeCount) * deltaRadians;\r\n      cc = Math.cos(radians);\r\n      ss = Math.sin(radians);\r\n      rc = r * cc;\r\n      rs = r * ss;\r\n\r\n      transform.multiplyXYZ(rc, rs, v, xyz);\r\n      result.addPoint(xyz);\r\n      if (fractions)\r\n        fractions.push(i / strokeCount);\r\n      if (derivatives) {\r\n        transform.matrix.multiplyXYZ(-rs * twoPi, rc * twoPi, 0.0, dXdu);\r\n        derivatives.push(dXdu);\r\n      }\r\n      if (surfaceNormals) {\r\n        // the along-hoop vector does not need to be scaled by radius -- just need the direction for a cross product.\r\n        transform.matrix.multiplyXYZ(-ss, cc, 0.0, dXdu);\r\n        transform.matrix.multiplyXYZ(0, 0, 1, dXdv);\r\n        dXdu.unitCrossProduct(dXdv, normal);\r\n        surfaceNormals.push(normal);\r\n      }\r\n      if (uvParams) {\r\n        uvParams.pushXY(i / strokeCount, v);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the Arc3d section at vFraction\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(vFraction: number): CurveCollection | undefined {\r\n    const r = this.vFractionToRadius(vFraction);\r\n    const transform = this._localToWorld;\r\n    const center = transform.multiplyXYZ(0, 0, vFraction);\r\n    const vector0 = transform.matrix.multiplyXYZ(r, 0, 0);\r\n    const vector90 = transform.matrix.multiplyXYZ(0, r, 0);\r\n    return Loop.create(Arc3d.create(center, vector0, vector90) as Arc3d);\r\n  }\r\n  /** Extend `rangeToExtend` so it includes this `Cone` instance. */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    const arc0 = this.constantVSection(0.0)!;\r\n    const arc1 = this.constantVSection(1.0)!;\r\n    arc0.extendRange(rangeToExtend, transform);\r\n    arc1.extendRange(rangeToExtend, transform);\r\n  }\r\n/** Evaluate a point on the Cone surfaces, with\r\n * * v = 0 is the base plane.\r\n * * v = 1 is the top plane\r\n * * u = 0 to u = 1 wraps the angular range.\r\n */\r\n  public uvFractionToPoint(uFraction: number, vFraction: number, result?: Point3d): Point3d {\r\n    const theta = uFraction * Math.PI * 2.0;\r\n    const r = Geometry.interpolate(this._radiusA, vFraction, this._radiusB);\r\n    const cosTheta = Math.cos(theta);\r\n    const sinTheta = Math.sin(theta);\r\n    return this._localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction, result);\r\n  }\r\n/** Evaluate a point tangent plane on the Cone surfaces, with\r\n * * v = 0 is the base plane.\r\n * * v = 1 is the top plane\r\n * * u = 0 to u = 1 wraps the angular range.\r\n */\r\npublic uvFractionToPointAndTangents(uFraction: number, vFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const theta = uFraction * Math.PI * 2.0;\r\n    const r = Geometry.interpolate(this._radiusA, vFraction, this._radiusB);\r\n    const drdv = this._radiusB - this._radiusA;\r\n    const cosTheta = Math.cos(theta);\r\n    const sinTheta = Math.sin(theta);\r\n    const fTheta = 2.0 * Math.PI;\r\n    return Plane3dByOriginAndVectors.createOriginAndVectors(\r\n      this._localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction),\r\n      this._localToWorld.multiplyVectorXYZ(-r * sinTheta * fTheta, r * cosTheta * fTheta, 0),\r\n      this._localToWorld.multiplyVectorXYZ(drdv * cosTheta, drdv * sinTheta, 1.0),\r\n      result);\r\n  }\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped;\r\n  }\r\n  /**\r\n   * Directional distance query\r\n   * * u direction is around longitude circle at maximum distance from axis.\r\n   * * v direction is on a line of longitude between the latitude limits.\r\n   */\r\n  public maxIsoParametricDistance(): Vector2d {\r\n    const vectorX = this._localToWorld.matrix.columnX();\r\n    const vectorY = this._localToWorld.matrix.columnY();\r\n    const columnZ = this._localToWorld.matrix.columnZ();\r\n\r\n    const xyNormal = vectorX.unitCrossProduct(vectorY)!;\r\n    const hZ = xyNormal.dotProduct(columnZ);\r\n    const zSkewVector = columnZ.plusScaled(xyNormal, hZ);\r\n    const zSkewDistance = zSkewVector.magnitudeXY();\r\n    return Vector2d.create(Math.PI * 2 * Math.max(this._radiusA, this._radiusB),\r\n      Geometry.hypotenuseXY(Math.abs(this._radiusB - this._radiusA) + zSkewDistance, hZ));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { XAndY } from \"../geometry3d/XYZProps\";\r\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\n\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { Path } from \"../curve/Path\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { SweepContour } from \"./SweepContour\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\n/**\r\n * A LinearSweep is a `SolidPrimitive` defined by\r\n * * A set of curves (any Loop, Path, or parityRegion)\r\n * * A sweep vector\r\n * If the object is \"capped\", the curves must be planar.\r\n * @public\r\n */\r\nexport class LinearSweep extends SolidPrimitive {\r\n  /** String name for schema properties */\r\n  public readonly solidPrimitiveType = \"linearSweep\";\r\n\r\n  private _contour: SweepContour;\r\n  private _direction: Vector3d;\r\n\r\n  private constructor(contour: SweepContour, direction: Vector3d, capped: boolean) {\r\n    super(capped);\r\n    this._contour = contour;\r\n    this._direction = direction;\r\n  }\r\n  /**\r\n   * Create a sweep of a starting contour.\r\n   * @param contour contour to be swept\r\n   * @param direction sweep vector.  The contour is swept the full length of the vector.\r\n   * @param capped true to include end caps\r\n   */\r\n  public static create(contour: CurveCollection, direction: Vector3d, capped: boolean): LinearSweep | undefined {\r\n    const sweepable = SweepContour.createForLinearSweep(contour, direction);\r\n    if (!sweepable)\r\n      return undefined;\r\n    return new LinearSweep(sweepable, direction, capped);\r\n  }\r\n  /** Create a z-direction sweep of the polyline or polygon given as xy linestring values.\r\n   * * If not capped, the xyPoints array is always used unchanged.\r\n   * * If capped but the xyPoints array does not close, exact closure will be enforced by one of these:\r\n   * * * If the final point is almost equal to the first, it is replaced by the exact first point.\r\n   * * * if the final point is not close to the first an extra point is added.\r\n   * * If capped, the point order will be reversed if necessary to produce positive volume.\r\n   * @param xyPoints array of xy coordinates\r\n   * @param z z value to be used for all coordinates\r\n   * @param zSweep the sweep distance in the z direction.\r\n   * @param capped true if caps are to be added.\r\n   */\r\n  public static createZSweep(xyPoints: XAndY[], z: number, zSweep: number, capped: boolean): LinearSweep | undefined {\r\n    const xyz = LineString3d.createXY(xyPoints, z, capped);\r\n    if (capped) {\r\n      xyz.addClosurePoint();\r\n      const area = PolygonOps.areaXY(xyz.points);\r\n      if (area * zSweep < 0.0)\r\n        xyz.points.reverse();\r\n    }\r\n    const contour: CurveCollection = capped ? Loop.create(xyz) : Path.create(xyz);\r\n    return LinearSweep.create(contour, Vector3d.create(0, 0, zSweep), capped);\r\n  }\r\n  /** get a reference to the swept curves */\r\n  public getCurvesRef(): CurveCollection { return this._contour.curves; }\r\n  /** Get a reference to the `SweepContour` carrying the plane of the curves */\r\n  public getSweepContourRef(): SweepContour { return this._contour; }\r\n  /** return a clone of the sweep vector */\r\n  public cloneSweepVector(): Vector3d { return this._direction.clone(); }\r\n  /** Test if `other` is also an instance of `LinearSweep` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof LinearSweep; }\r\n  /** Return a deep clone */\r\n  public clone(): LinearSweep {\r\n    return new LinearSweep(this._contour.clone(), this._direction.clone(), this.capped);\r\n  }\r\n  /** apply a transform to the curves and sweep vector */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    if (this._contour.tryTransformInPlace(transform)) {\r\n      transform.multiplyVector(this._direction, this._direction);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Return a coordinate frame (right handed unit vectors)\r\n   * * origin on base contour\r\n   * * x, y directions from base contour.\r\n   * * z direction perpendicular\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    return this._contour.localToWorld.cloneRigid();\r\n  }\r\n  /** Return a transformed clone */\r\n  public cloneTransformed(transform: Transform): LinearSweep {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n  /** Test for near-equality of coordinates in `other` */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof LinearSweep) {\r\n      return this._contour.isAlmostEqual(other._contour)\r\n        && this._direction.isAlmostEqual(other._direction)\r\n        && this.capped === other.capped;\r\n    }\r\n    return false;\r\n  }\r\n  /** Invoke strongly typed `handler.handleLinearSweep(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleLinearSweep(this);\r\n  }\r\n  /**\r\n   * Return the curves at a fraction along the sweep direction.\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(vFraction: number): CurveCollection | undefined {\r\n    const section = this._contour.curves.clone();\r\n    if (section && vFraction !== 0.0)\r\n      section.tryTransformInPlace(Transform.createTranslation(this._direction.scale(vFraction)));\r\n    return section;\r\n  }\r\n  /** Extend `rangeToExtend` to include this geometry. */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform) {\r\n    const contourRange = this._contour.curves.range(transform);\r\n    rangeToExtend.extendRange(contourRange);\r\n    if (transform) {\r\n      const transformedDirection = transform.multiplyVector(this._direction);\r\n      contourRange.low.addInPlace(transformedDirection);\r\n      contourRange.high.addInPlace(transformedDirection);\r\n    } else {\r\n      contourRange.low.addInPlace(this._direction);\r\n      contourRange.high.addInPlace(this._direction);\r\n    }\r\n    rangeToExtend.extendRange(contourRange);\r\n  }\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped && this._contour.curves.isAnyRegionType;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Geometry, AxisOrder } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { SweepContour } from \"./SweepContour\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\n\r\n/**\r\n * A LinearSweep is\r\n * * A planar contour (any Loop, Path, or parityRegion)\r\n * * An axis vector.\r\n *   * The planar contour is expected to be in the plane of the axis vector\r\n *   * The contour may have points and/or lines that are on the axis, but otherwise is entirely on one side of the axis.\r\n * * A sweep angle.\r\n * @public\r\n */\r\nexport class RotationalSweep extends SolidPrimitive {\r\n  /** String name for schema properties */\r\n  public readonly solidPrimitiveType = \"rotationalSweep\";\r\n\r\n  private _contour: SweepContour;\r\n  private _normalizedAxis: Ray3d;\r\n  private _sweepAngle: Angle;\r\n  private constructor(contour: SweepContour, normalizedAxis: Ray3d, sweepAngle: Angle, capped: boolean) {\r\n    super(capped);\r\n    this._contour = contour;\r\n    this._normalizedAxis = normalizedAxis;\r\n    this.capped = capped;\r\n    this._sweepAngle = sweepAngle;\r\n  }\r\n  /** Create a rotational sweep. */\r\n  public static create(contour: CurveCollection, axis: Ray3d, sweepAngle: Angle, capped: boolean): RotationalSweep | undefined {\r\n    if (!axis.direction.normalizeInPlace()) return undefined;\r\n    const sweepable = SweepContour.createForRotation(contour, axis);\r\n    if (!sweepable)\r\n      return undefined;\r\n    return new RotationalSweep(sweepable, axis, sweepAngle.clone(), capped);\r\n  }\r\n\r\n  /** Return a coordinate frame (right handed unit vectors)\r\n   * * origin at origin of rotation ray\r\n   * * z direction along the rotation ray.\r\n   * * y direction perpendicular to the base contour plane\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    const contourPerpendicular = this._contour.localToWorld.matrix.columnZ();\r\n    const axes = Matrix3d.createRigidFromColumns(contourPerpendicular, this._normalizedAxis.direction, AxisOrder.YZX);\r\n    if (axes) {\r\n      return Transform.createOriginAndMatrix(this._normalizedAxis.origin, axes);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** return clone of (not reference to) the axis vector. */\r\n  public cloneAxisRay(): Ray3d { return this._normalizedAxis.clone(); }\r\n  /** Return (REFERENCE TO) the swept curves. */\r\n  public getCurves(): CurveCollection { return this._contour.curves; }\r\n  /** Return (REFERENCE TO) the swept curves with containing plane markup. */\r\n  public getSweepContourRef(): SweepContour { return this._contour; }\r\n  /** Return the sweep angle. */\r\n  public getSweep(): Angle { return this._sweepAngle.clone(); }\r\n/** Test if `other` is a `RotationalSweep` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof RotationalSweep; }\r\n  /** Test for same axis, capping, and swept geometry. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof RotationalSweep) {\r\n      return this._contour.isAlmostEqual(other._contour)\r\n        && this._normalizedAxis.isAlmostEqual(other._normalizedAxis)\r\n        && this.capped === other.capped;\r\n    }\r\n    return false;\r\n  }\r\n/** return a deep clone */\r\n  public clone(): RotationalSweep {\r\n    return new RotationalSweep(this._contour.clone(), this._normalizedAxis.clone(), this._sweepAngle.clone(), this.capped);\r\n  }\r\n  /** Transform the contour and axis */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (!transform.matrix.isSingular()\r\n      && this._contour.tryTransformInPlace(transform)) {\r\n      this._normalizedAxis.transformInPlace(transform);\r\n      return this._normalizedAxis.direction.normalizeInPlace();\r\n    }\r\n    return false;\r\n  }\r\n  /** return a cloned transform. */\r\n  public cloneTransformed(transform: Transform): RotationalSweep {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n/** Dispatch to strongly typed handler  `handler.handleRotationalSweep(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleRotationalSweep(this);\r\n  }\r\n/** Return a transform that rotates around the rotational axis by a fraction of the total sweep. */\r\n  public getFractionalRotationTransform(vFraction: number, result?: Transform): Transform {\r\n    const radians = this._sweepAngle.radians * vFraction;\r\n    const rotation = Transform.createFixedPointAndMatrix(this._normalizedAxis.origin,\r\n      Matrix3d.createRotationAroundVector(this._normalizedAxis.direction, Angle.createRadians(radians),\r\n        result ? result.matrix : undefined) as Matrix3d);\r\n    return rotation;\r\n  }\r\n  /**\r\n   * Return the curves of a constant-v section of the solid.\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(vFraction: number): CurveCollection | undefined {\r\n    const section = this._contour.curves.clone();\r\n    if (section) {\r\n      section.tryTransformInPlace(this.getFractionalRotationTransform(vFraction));\r\n    }\r\n    return section;\r\n  }\r\n/** Extend range using sampled points on the surface. */\r\n  public extendRange(range: Range3d, transform?: Transform) {\r\n    const degreeStep = 360 / 32;\r\n    const options = StrokeOptions.createForCurves();\r\n    options.angleTol = Angle.createDegrees(degreeStep);\r\n    const strokes = this._contour.curves.cloneStroked(options);\r\n    const numStep = Geometry.stepCount(degreeStep, this._sweepAngle.degrees, 4, 32);\r\n    const stepTransform = Transform.createIdentity();\r\n    if (transform) {\r\n      const compositeTransform = Transform.createIdentity();\r\n      for (let i = 0; i <= numStep; i++) {\r\n        transform.multiplyTransformTransform(this.getFractionalRotationTransform(i / numStep, stepTransform), compositeTransform);\r\n        strokes.extendRange(range, compositeTransform);\r\n      }\r\n\r\n    } else {\r\n      for (let i = 0; i <= numStep; i++)\r\n        strokes.extendRange(range, this.getFractionalRotationTransform(i / numStep, stepTransform));\r\n    }\r\n  }\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped || this._sweepAngle.isFullCircle;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\n\r\nimport { CurveCollection, CurveChain } from \"../curve/CurveCollection\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { SweepContour } from \"./SweepContour\";\r\nimport { ConstructCurveBetweenCurves } from \"../curve/ConstructCurveBetweenCurves\";\r\n\r\n/**\r\n * * type for a function argument taking 2 curves and returning another curve or failing with undefined.\r\n * * This is used (for instance) by `RuleSweep.mutatePartners`\r\n * @public\r\n */\r\nexport type CurvePrimitiveMutator = (primitiveA: CurvePrimitive, primitiveB: CurvePrimitive) => CurvePrimitive | undefined;\r\n/**\r\n * A ruled sweep (surface) is a collection of 2 or more contours.\r\n * * All contours must have identical number and type of geometry. (paths, loops, parity regions, lines, arcs, other curves)\r\n * @public\r\n */\r\nexport class RuledSweep extends SolidPrimitive {\r\n  /** String name for schema properties */\r\n  public readonly solidPrimitiveType = \"ruledSweep\";\r\n\r\n  private _contours: SweepContour[];\r\n  private constructor(contours: SweepContour[], capped: boolean) {\r\n    super(capped);\r\n    this._contours = contours;\r\n  }\r\n  /**\r\n   * Create a ruled sweep from an array of contours.\r\n   *  * the contours are CAPTURED (not cloned)\r\n   */\r\n  public static create(contours: CurveCollection[], capped: boolean): RuledSweep | undefined {\r\n    const sweepContours = [];\r\n    for (const contour of contours) {\r\n      const sweepable = SweepContour.createForLinearSweep(contour);\r\n      if (sweepable === undefined) return undefined;\r\n      sweepContours.push(sweepable);\r\n    }\r\n    return new RuledSweep(sweepContours, capped);\r\n  }\r\n  /** Return a reference to the array of SweepContour. */\r\n  public sweepContoursRef(): SweepContour[] { return this._contours; }\r\n  /** Return clones of all the sweep contours\r\n   * * See also cloneContours, which returns the spatial contours without their local coordinate system definitions)\r\n   */\r\n  public cloneSweepContours(): SweepContour[] {\r\n    const result = [];\r\n    for (const sweepable of this._contours) {\r\n      result.push(sweepable.clone());\r\n    }\r\n    return result;\r\n  }\r\n  /** Return clones of all the contours\r\n   * * See also cloneContours, which returns the contours in their local coordinate systems\r\n   */\r\n  public cloneContours(): CurveCollection[] {\r\n    const result = [];\r\n    for (const sweepable of this._contours) {\r\n      result.push(sweepable.curves.clone() as CurveCollection);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return a deep clone */\r\n  public clone(): RuledSweep {\r\n    return new RuledSweep(this.cloneSweepContours(), this.capped);\r\n  }\r\n  /** Transform all contours in place. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    for (const contour of this._contours) {\r\n      contour.tryTransformInPlace(transform);\r\n    }\r\n    return true;\r\n  }\r\n  /** Return a cloned transform. */\r\n  public cloneTransformed(transform: Transform): RuledSweep {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n  /** Return a coordinate frame (right handed unit vectors)\r\n   * * origin on base contour\r\n   * * x, y directions from base contour.\r\n   * * z direction perpendicular\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    if (this._contours.length === 0) return undefined;\r\n    return this._contours[0].localToWorld.cloneRigid();\r\n  }\r\n  /** Test if `other` is an instance of a `RuledSweep` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof RuledSweep; }\r\n  /** test same contour geometry and capping. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof RuledSweep) {\r\n      if (this.capped !== other.capped) return false;\r\n      if (this._contours.length !== other._contours.length) return false;\r\n      for (let i = 0; i < this._contours.length; i++) {\r\n        if (!this._contours[i].isAlmostEqual(other._contours[i]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** dispatch to strongly typed `handler.handleRuledSweep(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleRuledSweep(this);\r\n  }\r\n  /**\r\n   * Return the section curves at a fraction of the sweep\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(vFraction: number): CurveCollection | undefined {\r\n    const numSection = this._contours.length;\r\n    if (numSection < 2)\r\n      return undefined;\r\n    const q = vFraction * numSection;\r\n    let section0 = 0;\r\n    if (vFraction >= 1.0)\r\n      section0 = numSection - 1;\r\n    else\r\n      section0 = Math.floor(q);\r\n    if (section0 + 1 >= numSection)\r\n      section0 = numSection - 2;\r\n    const section1 = section0 + 1;\r\n    const localFraction = Geometry.clampToStartEnd(q - section0, 0, 1);\r\n    return RuledSweep.mutatePartners(this._contours[section0].curves, this._contours[section1].curves,\r\n      (primitive0: CurvePrimitive, primitive1: CurvePrimitive): CurvePrimitive | undefined => {\r\n        const newPrimitive = ConstructCurveBetweenCurves.interpolateBetween(primitive0, localFraction, primitive1);\r\n        if (newPrimitive instanceof CurvePrimitive) return newPrimitive;\r\n        return undefined;\r\n      });\r\n  }\r\n  /** Pass each contour to `extendRange` */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    for (const contour of this._contours)\r\n      contour.curves.extendRange(rangeToExtend, transform);\r\n  }\r\n\r\n  /** Construct a CurveCollection with the same structure as collectionA and collectionB, with primitives constructed by the caller-supplied primitiveMutator function.\r\n   * @returns Returns undefined if there is any type mismatch between the two collections.\r\n   */\r\n  public static mutatePartners(collectionA: CurveCollection, collectionB: CurveCollection, primitiveMutator: CurvePrimitiveMutator): CurveCollection | undefined {\r\n    if (!collectionA.isSameGeometryClass(collectionB))\r\n      return undefined;\r\n    if (collectionA instanceof CurveChain && collectionB instanceof CurveChain) {\r\n      const chainA = collectionA as CurveChain;\r\n      const chainB = collectionB as CurveChain;\r\n      const chainC = chainA.cloneEmptyPeer() as CurveChain;\r\n      const childrenA = chainA.children;\r\n      const childrenB = chainB.children;\r\n      if (childrenA.length !== childrenB.length)\r\n        return undefined;\r\n      for (let i = 0; i < childrenA.length; i++) {\r\n        const newChild = primitiveMutator(childrenA[i], childrenB[i]);\r\n        if (!newChild)\r\n          return undefined;\r\n        chainC.children.push(newChild);\r\n      }\r\n      return chainC;\r\n    } else if (collectionA instanceof CurveCollection && collectionB instanceof CurveCollection) {\r\n      const collectionC = collectionA.cloneEmptyPeer();\r\n      const childrenA = collectionA.children;\r\n      const childrenB = collectionB.children;\r\n      const childrenC = collectionC.children;\r\n      if (childrenA === undefined || childrenB === undefined || childrenC === undefined || childrenA.length !== childrenB.length)\r\n        return undefined;\r\n      for (let i = 0; i < childrenA.length; i++) {\r\n        const childA = childrenA[i];\r\n        const childB = childrenB[i];\r\n        if (childA instanceof CurvePrimitive && childB instanceof CurvePrimitive) {\r\n          const newPrimitive = primitiveMutator(childA, childB);\r\n          if (!newPrimitive)\r\n            return undefined;\r\n          childrenC.push(newPrimitive);\r\n        } else if (childA instanceof CurveCollection && childB instanceof CurveCollection) {\r\n          const newChild = this.mutatePartners(childA, childB, primitiveMutator);\r\n          if (!newChild)\r\n            return undefined;\r\n          if (newChild instanceof CurveCollection)\r\n            childrenC.push(newChild);\r\n        }\r\n      }\r\n      return collectionC;\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return true if this is a closed volume, as observed by\r\n   * * cap flag\r\n   * identical first and last contours.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    const n = this._contours.length;\r\n    return n > 1 && (this.capped || this._contours[0].isAlmostEqual(this._contours[n - 1]));\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Box } from \"./Box\";\r\nimport { Cone } from \"./Cone\";\r\nimport { Sphere } from \"./Sphere\";\r\nimport { LinearSweep } from \"./LinearSweep\";\r\nimport { RotationalSweep } from \"./RotationalSweep\";\r\nimport { RuledSweep } from \"./RuledSweep\";\r\nimport { TorusPipe } from \"./TorusPipe\";\r\n\r\n/** Describes the concrete type of a [[SolidPrimitive]]. Each type name maps to a specific subclass and can be used for type-switching in conditional statements.\r\n *\r\n *  - \"box\" => [[Box]]\r\n *  - \"cone\" => [[Cone]]\r\n *  - \"sphere\" => [[Sphere]]\r\n *  - \"linearSweep\" => [[LinearSweep]]\r\n *  - \"rotationalSweep\" => [[RotationalSweep]]\r\n *  - \"ruledSweep\" => [[RuledSweep]]\r\n *  - \"torusPipe\" => [[TorusPipe]]\r\n *\r\n * @public\r\n */\r\nexport type SolidPrimitiveType = \"box\" | \"cone\" | \"sphere\" | \"linearSweep\" | \"rotationalSweep\" | \"ruledSweep\" | \"torusPipe\";\r\n\r\n/** Union type of all subclasses of [[SolidPrimitive]].\r\n * @public\r\n */\r\nexport type AnySolidPrimitive = Box | Cone | Sphere | LinearSweep | RotationalSweep | RuledSweep | TorusPipe;\r\n\r\n/**\r\n * Base class for SolidPrimitive variants.\r\n *\r\n * * The base class holds capped flag for all derived classes.\r\n * @public\r\n */\r\nexport abstract class SolidPrimitive extends GeometryQuery {\r\n  /** String name for schema properties */\r\n  public readonly geometryCategory = \"solid\";\r\n  /** String name for schema properties */\r\n  public abstract readonly solidPrimitiveType: SolidPrimitiveType;\r\n\r\n  /** flag indicating whether cap region is considered closed (i.e. a planar region, rather than just a wire in space) */\r\n  protected _capped: boolean;\r\n  protected constructor(capped: boolean) { super(); this._capped = capped; }\r\n  /** Ask if this is a capped solid */\r\n  public get capped(): boolean { return this._capped; }\r\n  /** Set the capped flag */\r\n  public set capped(capped: boolean) { this._capped = capped; }\r\n  /** Return a cross section at specified vFraction. */\r\n  public abstract constantVSection(_vFraction: number): CurveCollection | undefined;\r\n  /** Return a Transform from the local system of the solid to world.\r\n   * * The particulars of origin and orientation are specific to each SolidPrimitive type.\r\n   */\r\n  public abstract getConstructiveFrame(): Transform | undefined;\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   * * LinearSweep, Box, Cone only depend on capped.\r\n   * * Sphere affected by capped and latitude sweep\r\n   * * TorusPipe and RotationalSweep affected by capped and sweep\r\n   * * RuledSweep is affected by capped and match of first, last contour\r\n   */\r\n  public abstract get isClosedVolume(): boolean;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\n\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { GeometryHandler, UVSurface } from \"../geometry3d/GeometryHandler\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\n/**\r\n * A Sphere is\r\n *\r\n * * A unit sphere (but read on ....)\r\n * * mapped by an arbitrary (possibly skewed, non-uniform scaled) transform\r\n * * hence possibly the final geometry is ellipsoidal\r\n * @public\r\n */\r\nexport class Sphere extends SolidPrimitive implements UVSurface {\r\n  /** String name for schema properties */\r\n  public readonly solidPrimitiveType = \"sphere\";\r\n\r\n  private _localToWorld: Transform;  // unit sphere maps to world through the transform0 part of this map.\r\n  private _latitudeSweep: AngleSweep;\r\n  /** Return the latitude (in radians) all fractional v. */\r\n  public vFractionToRadians(v: number): number {\r\n    return this._latitudeSweep.fractionToRadians(v);\r\n  }\r\n  /** Return the longitude (in radians) all fractional u. */\r\n  public uFractionToRadians(u: number): number {\r\n    return u * Math.PI * 2.0;\r\n  }\r\n\r\n  private constructor(localToWorld: Transform, latitudeSweep: AngleSweep, capped: boolean) {\r\n    super(capped);\r\n    this._localToWorld = localToWorld;\r\n    this._latitudeSweep = latitudeSweep ? latitudeSweep : AngleSweep.createFullLatitude();\r\n  }\r\n  /** return a deep clone */\r\n  public clone(): Sphere {\r\n    return new Sphere(this._localToWorld.clone(), this._latitudeSweep.clone(), this.capped);\r\n  }\r\n  /** Transform the sphere in place.\r\n   * * Fails if the transform is singular.\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\r\n    return true;\r\n  }\r\n  /** Return a transformed clone. */\r\n  public cloneTransformed(transform: Transform): Sphere | undefined {\r\n    const sphere1 = this.clone();\r\n    transform.multiplyTransformTransform(sphere1._localToWorld, sphere1._localToWorld);\r\n    if (transform.matrix.determinant() < 0.0) {\r\n      if (sphere1._latitudeSweep !== undefined) {\r\n        sphere1._latitudeSweep.reverseInPlace();\r\n      }\r\n    }\r\n    return sphere1;\r\n  }\r\n  /** Return a coordinate frame (right handed, unit axes)\r\n   * * origin at sphere center\r\n   * * equator in xy plane\r\n   * * z axis perpendicular\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    return this._localToWorld.cloneRigid();\r\n  }\r\n  /** Return the latitude sweep as fraction of south pole to north pole. */\r\n  public get latitudeSweepFraction(): number { return this._latitudeSweep.sweepRadians / Math.PI; }\r\n  /** Create from center and radius, with optional restricted latitudes. */\r\n  public static createCenterRadius(center: Point3d, radius: number, latitudeSweep?: AngleSweep): Sphere {\r\n    const localToWorld = Transform.createOriginAndMatrix(center, Matrix3d.createUniformScale(radius));\r\n    return new Sphere(localToWorld,\r\n      latitudeSweep ? latitudeSweep : AngleSweep.createFullLatitude(), false);\r\n  }\r\n  /** Create an ellipsoid which is a unit sphere mapped to position by an (arbitrary, possibly skewed and scaled) transform. */\r\n  public static createEllipsoid(localToWorld: Transform, latitudeSweep: AngleSweep, capped: boolean): Sphere | undefined {\r\n    return new Sphere(localToWorld, latitudeSweep, capped);\r\n  }\r\n\r\n  /** Create a sphere from the typical parameters of the Dgn file */\r\n  public static createDgnSphere(center: Point3d, vectorX: Vector3d, vectorZ: Vector3d, radiusXY: number, radiusZ: number,\r\n    latitudeSweep: AngleSweep,\r\n    capped: boolean): Sphere | undefined {\r\n    const vectorY = vectorX.rotate90Around(vectorZ);\r\n    if (vectorY && !vectorX.isParallelTo(vectorZ)) {\r\n      const matrix = Matrix3d.createColumns(vectorX, vectorY, vectorZ);\r\n      matrix.scaleColumns(radiusXY, radiusXY, radiusZ, matrix);\r\n      const frame = Transform.createOriginAndMatrix(center, matrix);\r\n      return new Sphere(frame, latitudeSweep.clone(), capped);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Create a sphere from the typical parameters of the Dgn file */\r\n  public static createFromAxesAndScales(center: Point3d, axes: undefined | Matrix3d, radiusX: number, radiusY: number, radiusZ: number,\r\n    latitudeSweep: AngleSweep | undefined,\r\n    capped: boolean): Sphere | undefined {\r\n    const localToWorld = Transform.createOriginAndMatrix(center, axes);\r\n    localToWorld.matrix.scaleColumnsInPlace(radiusX, radiusY, radiusZ);\r\n    return new Sphere(localToWorld, latitudeSweep ? latitudeSweep.clone() : AngleSweep.createFullLatitude(), capped);\r\n  }\r\n\r\n  /** return (copy of) sphere center */\r\n  public cloneCenter(): Point3d { return this._localToWorld.getOrigin(); }\r\n  /** return the (full length, i.e. scaled by radius) X vector from the sphere transform */\r\n  public cloneVectorX(): Vector3d { return this._localToWorld.matrix.columnX(); }\r\n  /** return the (full length, i.e. scaled by radius) Y vector from the sphere transform */\r\n  public cloneVectorY(): Vector3d { return this._localToWorld.matrix.columnY(); }\r\n  /** return the (full length, i.e. scaled by radius) Z vector from the sphere transform */\r\n  public cloneVectorZ(): Vector3d { return this._localToWorld.matrix.columnZ(); }\r\n  /** return (a copy of) the sphere's angle sweep. */\r\n  public cloneLatitudeSweep(): AngleSweep { return this._latitudeSweep.clone(); }\r\n  /** Test if the geometry is a true sphere taking the transform (which might have nonuniform scaling) is applied. */\r\n  public trueSphereRadius(): number | undefined {\r\n    const factors = this._localToWorld.matrix.factorRigidWithSignedScale();\r\n    if (!factors) return undefined;\r\n    if (factors && factors.scale > 0)\r\n      return factors.scale;\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a (clone of) the sphere's local to world transformation.\r\n   */\r\n  public cloneLocalToWorld(): Transform { return this._localToWorld.clone(); }\r\n  /** Test if `other` is a `Sphere` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof Sphere; }\r\n  /** Test for same geometry in `other` */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof Sphere) {\r\n      if (this.capped !== other.capped) return false;\r\n      if (!this._localToWorld.isAlmostEqual(other._localToWorld)) return false;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.\r\n   * * if strokeOptions is supplied, it is applied to the equator radii.\r\n   * @param v fractional position along the cone axis\r\n   * @param strokes stroke count or options.\r\n   */\r\n  public strokeConstantVSection(v: number, fixedStrokeCount: number | undefined,\r\n    options?: StrokeOptions): LineString3d {\r\n    let strokeCount = 16;\r\n    if (fixedStrokeCount !== undefined && Number.isFinite(fixedStrokeCount)) {\r\n      strokeCount = fixedStrokeCount as number;\r\n    } else if (options instanceof StrokeOptions) {\r\n      strokeCount = options.applyTolerancesToArc(Geometry.maxXY(this._localToWorld.matrix.columnXMagnitude(), this._localToWorld.matrix.columnYMagnitude()));\r\n    }\r\n    strokeCount = Geometry.clampToStartEnd(strokeCount, 4, 64);\r\n    const transform = this._localToWorld;\r\n    const phi = this.vFractionToRadians(v);\r\n    const c1 = Math.cos(phi);\r\n    const s1 = Math.sin(phi);\r\n    let c0, s0;\r\n    const result = LineString3d.createForStrokes(fixedStrokeCount, options);\r\n    const deltaRadians = Math.PI * 2.0 / strokeCount;\r\n    const fractions = result.fractions;     // possibly undefined !!!\r\n    const derivatives = result.packedDerivatives; // possibly undefined !!!\r\n    const uvParams = result.packedUVParams; // possibly undefined !!\r\n    const surfaceNormals = result.packedSurfaceNormals;\r\n    const dXdu = Vector3d.create();\r\n    const dXdv = Vector3d.create();\r\n    const normal = Vector3d.create();\r\n    let radians = 0;\r\n    for (let i = 0; i <= strokeCount; i++) {\r\n      if (i * 2 <= strokeCount)\r\n        radians = i * deltaRadians;\r\n      else\r\n        radians = (i - strokeCount) * deltaRadians;\r\n      c0 = Math.cos(radians);\r\n      s0 = Math.sin(radians);\r\n      const xyz = transform.multiplyXYZ(c1 * c0, c1 * s0, s1);\r\n      result.addPoint(xyz);\r\n\r\n      if (fractions)\r\n        fractions.push(i / strokeCount);\r\n\r\n      if (derivatives) {\r\n        transform.matrix.multiplyXYZ(-c1 * s0, c1 * c0, 0.0, dXdu);\r\n        derivatives.push(dXdu);\r\n      }\r\n      if (uvParams) {\r\n        uvParams.pushXY(i / strokeCount, v);\r\n      }\r\n      if (surfaceNormals) {\r\n        transform.matrix.multiplyXYZ(-s0, c0, 0, dXdu);\r\n        transform.matrix.multiplyXYZ(-s1 * c0, -s1 * s0, c1, dXdv);\r\n        dXdu.unitCrossProduct(dXdv, normal);\r\n        surfaceNormals.push(normal);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Second step of double dispatch:  call `handler.handleSphere(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleSphere(this);\r\n  }\r\n  /**\r\n   * Return the Arc3d section at vFraction.  For the sphere, this is a latitude circle.\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(vFraction: number): CurveCollection | undefined {\r\n    const phi = this._latitudeSweep.fractionToRadians(vFraction);\r\n    const s1 = Math.sin(phi);\r\n    const c1 = Math.cos(phi);\r\n    const transform = this._localToWorld;\r\n    const center = transform.multiplyXYZ(0, 0, s1);\r\n    const vector0 = transform.matrix.multiplyXYZ(c1, 0, 0);\r\n    const vector90 = transform.matrix.multiplyXYZ(0, c1, 0);\r\n    return Loop.create(Arc3d.create(center, vector0, vector90) as Arc3d);\r\n  }\r\n  /** Extend a range to contain this sphere. */\r\n  public extendRange(range: Range3d, transform?: Transform): void {\r\n    let placement = this._localToWorld;\r\n    if (transform) {\r\n      placement = transform.multiplyTransformTransform(placement);\r\n    }\r\n\r\n    range.extendTransformedXYZ(placement, -1, -1, -1);\r\n    range.extendTransformedXYZ(placement, 1, -1, -1);\r\n    range.extendTransformedXYZ(placement, -1, 1, -1);\r\n    range.extendTransformedXYZ(placement, 1, 1, -1);\r\n\r\n    range.extendTransformedXYZ(placement, -1, -1, 1);\r\n    range.extendTransformedXYZ(placement, 1, -1, 1);\r\n    range.extendTransformedXYZ(placement, -1, 1, 1);\r\n    range.extendTransformedXYZ(placement, 1, 1, 1);\r\n\r\n  }\r\n  /** Evaluate as a uv surface\r\n   * @param uFraction fractional position in minor (phi)\r\n   * @param vFraction fractional position on major (theta) arc\r\n   */\r\n  public uvFractionToPoint(uFraction: number, vFraction: number, result?: Point3d): Point3d {\r\n    // sphere with radius 1 . . .\r\n    const thetaRadians = this.uFractionToRadians(uFraction);\r\n    const phiRadians = this.vFractionToRadians(vFraction);\r\n    const cosTheta = Math.cos(thetaRadians);\r\n    const sinTheta = Math.sin(thetaRadians);\r\n    const sinPhi = Math.sin(phiRadians);\r\n    const cosPhi = Math.cos(phiRadians);\r\n    return this._localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi, result);\r\n  }\r\n  /** Evaluate as a uv surface, returning point and two vectors.\r\n   * @param u fractional position in minor (phi)\r\n   * @param v fractional position on major (theta) arc\r\n   */\r\n  public uvFractionToPointAndTangents(uFraction: number, vFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const thetaRadians = this.uFractionToRadians(uFraction);\r\n    const phiRadians = this.vFractionToRadians(vFraction);\r\n    const fTheta = Math.PI * 2.0;\r\n    const fPhi = this._latitudeSweep.sweepRadians;\r\n    const cosTheta = Math.cos(thetaRadians);\r\n    const sinTheta = Math.sin(thetaRadians);\r\n    const sinPhi = Math.sin(phiRadians);\r\n    const cosPhi = Math.cos(phiRadians);\r\n    return Plane3dByOriginAndVectors.createOriginAndVectors(\r\n      this._localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi),\r\n      this._localToWorld.matrix.multiplyXYZ(-fTheta * sinTheta, fTheta * cosTheta, 0),   // !!! note cosTheta term is omitted -- scale is wrong, but remains non-zero at poles.\r\n      this._localToWorld.matrix.multiplyXYZ(-fPhi * cosTheta * sinPhi, -fPhi * sinTheta * sinPhi, fPhi * cosPhi),\r\n      result);\r\n  }\r\n  /**\r\n   * * A sphere is can be closed two ways:\r\n   *   * full sphere (no caps needed for closure)\r\n   *   * incomplete but with caps\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped || this._latitudeSweep.isFullLatitudeSweep;\r\n  }\r\n  /**\r\n   * Directional distance query\r\n   * * u direction is around longitude circle at maximum distance from axis.\r\n   * * v direction is on a line of longitude between the latitude limits.\r\n   */\r\n  public maxIsoParametricDistance(): Vector2d {\r\n    // approximate radius at equator .. if elliptic, this is not exact . . .\r\n    const rX = this._localToWorld.matrix.columnXMagnitude();\r\n    const rY = this._localToWorld.matrix.columnYMagnitude();\r\n    const rZ = this._localToWorld.matrix.columnZMagnitude();\r\n    const rMaxU = Math.max(rX, rY);\r\n    let dMaxU = Math.PI * 2.0 * rMaxU;\r\n    if (!this._latitudeSweep.isRadiansInSweep(0.0))\r\n      dMaxU *= Math.max(Math.cos(Math.abs(this._latitudeSweep.startRadians)), Math.cos(Math.abs(this._latitudeSweep.endRadians)));\r\n    const dMaxV = Math.max(rMaxU, rZ) * Math.abs(this._latitudeSweep.sweepRadians);\r\n\r\n    return Vector2d.create(dMaxU, dMaxV);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\n\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { FrameBuilder } from \"../geometry3d/FrameBuilder\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { IndexedPolyface } from \"../polyface/Polyface\";\r\nimport { PolyfaceBuilder } from \"../polyface/PolyfaceBuilder\";\r\nimport { Triangulator, MultiLineStringDataVariant } from \"../topology/Triangulation\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { AnyCurve } from \"../curve/CurveChain\";\r\nimport { ParityRegion } from \"../curve/ParityRegion\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\n\r\n/**\r\n * Sweepable contour with Transform for local to world interaction.\r\n * * The surface/solid classes `LinearSweep`, `RotationalSweep`, `RuledSweep` use this for their swept contours.\r\n * @public\r\n */\r\nexport class SweepContour {\r\n  /** The underlying curve collection, in its world coordinates position. */\r\n  public curves: CurveCollection;\r\n  /** coordinate frame that in which the curves are all in the xy plane. */\r\n  public localToWorld: Transform;\r\n  /** Axis used only in rotational case. */\r\n  public axis: Ray3d | undefined;\r\n\r\n  private constructor(contour: CurveCollection, map: Transform, axis: Ray3d | undefined) {\r\n    this.curves = contour;\r\n    this.localToWorld = map;\r\n    this.axis = axis;\r\n  }\r\n  /** Create for linear sweep.\r\n   * * The optional default normal may be useful for guiding coordinate frame setup.\r\n   * * the contour is CAPTURED.\r\n   */\r\n  public static createForLinearSweep(contour: CurveCollection, defaultNormal?: Vector3d): SweepContour | undefined {\r\n    const localToWorld = FrameBuilder.createRightHandedFrame(defaultNormal, contour);\r\n    if (localToWorld) {\r\n      return new SweepContour(contour, localToWorld, undefined);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Create for linear sweep.\r\n   * * The optional default normal may be useful for guiding coordinate frame setup.\r\n   * * the points are captured into linestrings and Loops as needed.\r\n   */\r\n  public static createForPolygon(points: MultiLineStringDataVariant, defaultNormal?: Vector3d): SweepContour | undefined {\r\n    const localToWorld = FrameBuilder.createRightHandedFrame(defaultNormal, points);\r\n    if (localToWorld) {\r\n      if (defaultNormal !== undefined) {\r\n        if (localToWorld.matrix.dotColumnZ(defaultNormal))\r\n          localToWorld.matrix.scaleColumnsInPlace(1.0, -1.0, -1.0);\r\n      }\r\n      const linestrings = LineString3d.createArrayOfLineString3dFromVariantData(points);\r\n      const loops = [];\r\n      for (const ls of linestrings) {\r\n        ls.addClosurePoint();\r\n        loops.push(Loop.create(ls));\r\n      }\r\n      if (loops.length === 1) {\r\n        return new SweepContour(loops[0], localToWorld, undefined);\r\n      } else if (loops.length > 1) {\r\n        return new SweepContour(ParityRegion.createLoops(loops), localToWorld, undefined);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Create for rotational sweep.\r\n   * * The axis ray is retained.\r\n   * * the contour is CAPTURED.\r\n   */\r\n  public static createForRotation(contour: CurveCollection, axis: Ray3d): SweepContour | undefined {\r\n    // createRightHandedFrame -- the axis is a last-gasp resolver for in-plane vectors.\r\n    const localToWorld = FrameBuilder.createRightHandedFrame(undefined, contour, axis);\r\n    if (localToWorld) {\r\n      return new SweepContour(contour, localToWorld, axis.clone());\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return (Reference to) the curves */\r\n  public getCurves(): CurveCollection { return this.curves; }\r\n  /** Apply `transform` to the curves, axis.\r\n   * * The local to world frame is reconstructed for the transformed curves.\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (this.curves.tryTransformInPlace(transform)) {\r\n      if (this.axis)\r\n        this.axis.transformInPlace(transform);\r\n\r\n      const localToWorld = this.axis !== undefined\r\n        ? FrameBuilder.createRightHandedFrame(undefined, this.curves, this.axis)\r\n        : FrameBuilder.createRightHandedFrame(undefined, this.curves);\r\n      if (localToWorld) {\r\n        this.localToWorld.setFrom(localToWorld);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Return a deep clone. */\r\n  public clone(): SweepContour {\r\n    return new SweepContour(this.curves.clone() as CurveCollection, this.localToWorld.clone(), this.axis);\r\n  }\r\n  /** Return a transformed clone. */\r\n  public cloneTransformed(transform: Transform): SweepContour | undefined {\r\n    const newContour = this.clone();\r\n    if (newContour.tryTransformInPlace(transform))\r\n      return newContour;\r\n    return undefined;\r\n  }\r\n  /** Test for near equality of cures and local frame. */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof SweepContour) {\r\n      return this.curves.isAlmostEqual(other.curves) && this.localToWorld.isAlmostEqual(other.localToWorld);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _xyStrokes?: AnyCurve;\r\n  private _facets?: IndexedPolyface;\r\n\r\n  /**\r\n   * build the (cached) internal facets.\r\n   * @param _builder (NOT USED -- an internal builder is constructed for the triangulation)\r\n   * @param options options for stroking the curves.\r\n   */\r\n  public buildFacets(_builder: PolyfaceBuilder, options: StrokeOptions | undefined): void {\r\n    if (!this._facets) {\r\n      if (this.curves instanceof Loop) {\r\n        this._xyStrokes = this.curves.cloneStroked(options);\r\n        if (this._xyStrokes instanceof Loop && this._xyStrokes.children.length === 1) {\r\n          const children = this._xyStrokes.children;\r\n          const linestring = children[0] as LineString3d;\r\n          const points = linestring.points;\r\n          this.localToWorld.multiplyInversePoint3dArrayInPlace(points);\r\n          if (PolygonOps.sumTriangleAreasXY(points) < 0)\r\n            points.reverse();\r\n          const graph = Triangulator.createTriangulatedGraphFromSingleLoop(points);\r\n          if (graph) {\r\n            Triangulator.flipTriangles(graph);\r\n            const unflippedPoly = PolyfaceBuilder.graphToPolyface(graph, options);\r\n            this._facets = unflippedPoly;\r\n            this._facets.tryTransformInPlace(this.localToWorld);\r\n          }\r\n        }\r\n      } else if (this.curves instanceof ParityRegion) {\r\n        this._xyStrokes = this.curves.cloneStroked(options);\r\n        if (this._xyStrokes instanceof (ParityRegion)) {\r\n          const worldToLocal = this.localToWorld.inverse()!;\r\n          this._xyStrokes.tryTransformInPlace(worldToLocal);\r\n          const strokes = [];\r\n          for (const childLoop of this._xyStrokes.children) {\r\n            const loopCurves = childLoop.children;\r\n            if (loopCurves.length === 1) {\r\n              const c = loopCurves[0];\r\n              if (c instanceof LineString3d)\r\n                strokes.push(c.packedPoints);\r\n            }\r\n          }\r\n          const graph = Triangulator.createTriangulatedGraphFromLoops(strokes);\r\n          if (graph) {\r\n            Triangulator.flipTriangles(graph);\r\n            const unflippedPoly = PolyfaceBuilder.graphToPolyface(graph, options);\r\n            this._facets = unflippedPoly;\r\n            this._facets.tryTransformInPlace(this.localToWorld);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /** delete existing facets.\r\n   * * This protects against PolyfaceBuilder reusing facets constructed with different options settings.\r\n   */\r\n  public purgeFacets() {\r\n    this._facets = undefined;\r\n  }\r\n\r\n  /** Emit facets to a builder.\r\n   * This method may cache and reuse facets over multiple calls.\r\n   */\r\n  public emitFacets(builder: PolyfaceBuilder, reverse: boolean, transform?: Transform) {\r\n    this.buildFacets(builder, builder.options);\r\n    if (this._facets)\r\n      builder.addIndexedPolyface(this._facets, reverse, transform);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\n\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { GeometryHandler, UVSurface, UVSurfaceIsoParametricDistance } from \"../geometry3d/GeometryHandler\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { Path } from \"../curve/Path\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\n/**\r\n * A torus pipe is a partial torus (donut).  In a local coordinate system\r\n * * The z axis passes through the hole.\r\n * * The \"major hoop\" arc has\r\n *   * vectorTheta0 = (radiusA,0,0)\r\n *   * vectorTheta90 = (0, radiusA,0)\r\n *   * The major arc point at angle theta is `C(theta) = vectorTheta0 * cos(theta) + vectorTheta90 * sin(theta)\r\n * * The minor hoop at theta various with phi \"around the minor hoop\"\r\n *    * (x,y,z) = C(theta) + (radiusB *cos(theta), radiusB * sin(theta)) * cos(phi) + (0,radiusB,0) * sin(phi)\r\n * * The stored form of the torus pipe is oriented for positive volume:\r\n *   * Both radii are positive, with r0 >= r1 > 0\r\n *   * The sweep is positive\r\n *   * The coordinate system has positive determinant.\r\n * * For uv parameterization,\r\n *   * u is around the minor hoop, with (0..1) mapping to phi of (0 degrees ..360 degrees)\r\n *   * v is along the major hoop with (0..1) mapping to theta of (0 .. sweep)\r\n *   * a constant v section is a full circle\r\n *   * a constant u section is an arc with sweep angle matching the torusPipe sweep angle.\r\n * @public\r\n */\r\nexport class TorusPipe extends SolidPrimitive implements UVSurface, UVSurfaceIsoParametricDistance {\r\n  /** String name for schema properties */\r\n  public readonly solidPrimitiveType = \"torusPipe\";\r\n\r\n  private _localToWorld: Transform;\r\n  private _radiusA: number;  // radius of (large) circle in xy plane\r\n  private _radiusB: number;  // radius of (small) circle in xz plane.\r\n  private _sweep: Angle;\r\n  private _isReversed: boolean;\r\n\r\n  protected constructor(map: Transform, radiusA: number, radiusB: number, sweep: Angle, capped: boolean) {\r\n    super(capped);\r\n    this._localToWorld = map;\r\n    this._radiusA = radiusA;\r\n    this._radiusB = radiusB;\r\n    this._sweep = sweep;\r\n    this._isReversed = false;\r\n  }\r\n  /** return a copy of the TorusPipe */\r\n  public clone(): TorusPipe {\r\n    const result = new TorusPipe(this._localToWorld.clone(), this._radiusA, this._radiusB, this._sweep.clone(), this.capped);\r\n    result._isReversed = this._isReversed;\r\n    return result;\r\n  }\r\n  /** Apply `transform` to the local coordinate system. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\r\n    return true;\r\n  }\r\n  /** Clone this TorusPipe and transform the clone */\r\n  public cloneTransformed(transform: Transform): TorusPipe | undefined {\r\n    const result = this.clone();\r\n    transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);\r\n    return result;\r\n  }\r\n  /** Create a new `TorusPipe`\r\n   * @param frame local to world transformation\r\n   * @param majorRadius major hoop radius\r\n   * @param minorRadius minor hoop radius\r\n   * @param sweep sweep angle for major circle, with positive sweep from x axis towards y axis.\r\n   * @param capped true for circular caps\r\n   */\r\n  public static createInFrame(frame: Transform, majorRadius: number, minorRadius: number, sweep: Angle, capped: boolean): TorusPipe | undefined {\r\n    // force near-zero radii to true zero\r\n    majorRadius = Math.abs(Geometry.correctSmallMetricDistance(majorRadius));\r\n    minorRadius = Math.abs(Geometry.correctSmallMetricDistance(minorRadius));\r\n    if (majorRadius < minorRadius) return undefined;\r\n    if (majorRadius === 0.0) return undefined;\r\n    if (minorRadius === 0.0) return undefined;\r\n\r\n    if (sweep.isAlmostZero) return undefined;\r\n    const xScale = 1.0;\r\n    let yScale = 1.0;\r\n    let zScale = 1.0;\r\n    if (frame.matrix.determinant() < 0.0) zScale *= -1.0;\r\n    let isReversed = false;\r\n    const sweep1 = sweep.clone();\r\n    if (sweep.radians < 0.0) {\r\n      sweep1.setRadians(-sweep.radians);\r\n      zScale *= -1.0;\r\n      yScale *= -1.0;\r\n      isReversed = true;\r\n    }\r\n    const frame1 = frame.clone();\r\n    frame1.matrix.scaleColumns(xScale, yScale, zScale, frame1.matrix);\r\n    const result = new TorusPipe(frame1, majorRadius, minorRadius, sweep1, capped);\r\n    result._isReversed = isReversed;\r\n    return result;\r\n  }\r\n\r\n  /** Create a TorusPipe from the typical parameters of the Dgn file */\r\n  public static createDgnTorusPipe(center: Point3d, vectorX: Vector3d, vectorY: Vector3d, majorRadius: number, minorRadius: number,\r\n    sweep: Angle, capped: boolean) {\r\n    const vectorZ = vectorX.crossProduct(vectorY);\r\n    vectorZ.scaleToLength(vectorX.magnitude(), vectorZ);\r\n    const frame = Transform.createOriginAndMatrixColumns(center, vectorX, vectorY, vectorZ);\r\n    return TorusPipe.createInFrame(frame, majorRadius, minorRadius, sweep, capped);\r\n  }\r\n  /** Return a coordinate frame (right handed, unit axes)\r\n   * * origin at center of major circle\r\n   * * major circle in xy plane\r\n   * * z axis perpendicular\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    return this._localToWorld.cloneRigid();\r\n  }\r\n  /** Return the center of the torus pipe (inside the donut hole) */\r\n  public cloneCenter(): Point3d { return this._localToWorld.getOrigin(); }\r\n  /** return the vector along the x axis (in the major hoops plane) */\r\n  public cloneVectorX(): Vector3d { return this._localToWorld.matrix.columnX(); }\r\n  /** return the vector along the y axis (in the major hoop plane) */\r\n  public cloneVectorY(): Vector3d { return this._localToWorld.matrix.columnY(); }\r\n  /** get the minor hoop radius (`radiusA`) */\r\n  public getMinorRadius(): number { return this._radiusB; }\r\n  /** get the major hoop radius (`radiusB`) */\r\n  public getMajorRadius(): number { return this._radiusA; }\r\n  /** get the sweep angle along the major circle. */\r\n  public getSweepAngle(): Angle { return this._sweep.clone(); }\r\n  /** Ask if this TorusPipe is labeled as reversed */\r\n  public getIsReversed(): boolean { return this._isReversed; }\r\n  /** Return the sweep angle as a fraction of full 360 degrees (2PI radians) */\r\n  public getThetaFraction(): number { return this._sweep.radians / (Math.PI * 2.0); }\r\n  /** ask if `other` is an instance of `TorusPipe` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof TorusPipe; }\r\n  /** test if `this` and `other` have nearly equal geometry */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof TorusPipe) {\r\n      if (this.capped !== other.capped) return false;\r\n      if (!this._localToWorld.isAlmostEqual(other._localToWorld)) return false;\r\n      return Geometry.isSameCoordinate(this._radiusA, other._radiusA)\r\n        && Geometry.isSameCoordinate(this._radiusB, other._radiusB)\r\n        && this._sweep.isAlmostEqualNoPeriodShift(other._sweep);\r\n    }\r\n    return false;\r\n  }\r\n  /** Return the angle (in radians) for given fractional position around the major hoop.\r\n   */\r\n  public vFractionToRadians(v: number): number { return this._sweep.radians * v; }\r\n  /** Second step of double dispatch:  call `handler.handleTorusPipe(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleTorusPipe(this);\r\n  }\r\n\r\n  /**\r\n   * Return the Arc3d section at vFraction.  For the TorusPipe, this is a minor circle.\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(v: number): CurveCollection | undefined {\r\n    const thetaRadians = this.vFractionToRadians(v);\r\n    const c0 = Math.cos(thetaRadians);\r\n    const s0 = Math.sin(thetaRadians);\r\n    const majorRadius = this.getMajorRadius();\r\n    const minorRadius = this.getMinorRadius();\r\n\r\n    const center = this._localToWorld.multiplyXYZ(majorRadius * c0, majorRadius * s0, 0);\r\n    const vector0 = this._localToWorld.multiplyVectorXYZ(minorRadius * c0, minorRadius * s0, 0);\r\n    const vector90 = this._localToWorld.multiplyVectorXYZ(0, 0, minorRadius);\r\n    return Loop.create(Arc3d.create(center, vector0, vector90) as Arc3d);\r\n  }\r\n  /** Return an arc at constant u, and arc sweep  matching this TorusPipe sweep. */\r\n  public constantUSection(uFraction: number): CurveCollection | undefined {\r\n    const theta1Radians = this._sweep.radians;\r\n    const phiRadians = uFraction * Math.PI;\r\n\r\n    const majorRadius = this.getMajorRadius();\r\n    const minorRadius = this.getMinorRadius();\r\n    const transform = this._localToWorld;\r\n    const axes = transform.matrix;\r\n    const center = this._localToWorld.multiplyXYZ(0, 0, minorRadius * Math.sin(phiRadians));\r\n    const rxy = majorRadius + minorRadius * Math.cos(phiRadians);\r\n    const vector0 = axes.multiplyXYZ(rxy, 0, 0);\r\n    const vector90 = axes.multiplyXYZ(0, rxy, 0);\r\n    return Path.create(Arc3d.create(center, vector0, vector90, AngleSweep.createStartEndRadians(0.0, theta1Radians)) as Arc3d);\r\n  }\r\n  /** extend `rangeToExtend` to include this `TorusPipe` */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform) {\r\n    const theta1Radians = this._sweep.radians;\r\n    const majorRadius = this.getMajorRadius();\r\n    const minorRadius = this.getMinorRadius();\r\n    const transform0 = this._localToWorld;\r\n    const numThetaSample = Math.ceil(theta1Radians / (Math.PI / 16.0));\r\n    const numHalfPhiSample = 16;\r\n    let phi0 = 0;\r\n    let dphi = 0;\r\n    let numPhiSample = 0;\r\n    let theta = 0;\r\n    let cosTheta = 0;\r\n    let sinTheta = 0;\r\n    let rxy = 0;\r\n    let phi = 0;\r\n    let j = 0;\r\n    const dTheta = theta1Radians / numThetaSample;\r\n    for (let i = 0; i <= numThetaSample; i++) {\r\n      theta = i * dTheta;\r\n      cosTheta = Math.cos(theta);\r\n      sinTheta = Math.sin(theta);\r\n      // At the ends, do the entire phi circle.\r\n      // Otherwise only do the outer half\r\n      if (i === 0 || i === numThetaSample) {\r\n        phi0 = -Math.PI;\r\n        dphi = 2.0 * Math.PI / numHalfPhiSample;\r\n        numPhiSample = numHalfPhiSample;\r\n      } else {\r\n        phi0 = -0.5 * Math.PI;\r\n        dphi = Math.PI / numHalfPhiSample;\r\n        numPhiSample = 2 * numHalfPhiSample - 1;\r\n      }\r\n      if (transform) {\r\n        for (j = 0; j <= numPhiSample; j++) {\r\n          phi = phi0 + j * dphi;\r\n          rxy = majorRadius + minorRadius * Math.cos(phi);\r\n          rangeToExtend.extendTransformTransformedXYZ(transform, transform0,\r\n            cosTheta * rxy, sinTheta * rxy,\r\n            Math.sin(phi) * minorRadius);\r\n        }\r\n      } else {\r\n        for (j = 0; j <= numPhiSample; j++) {\r\n          phi = phi0 + j * dphi;\r\n          rxy = majorRadius + minorRadius * Math.sin(phi);\r\n          rangeToExtend.extendTransformedXYZ(transform0,\r\n            cosTheta * rxy, sinTheta * rxy,\r\n            Math.sin(phi) * minorRadius);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /** Evaluate as a uv surface\r\n   * @param u fractional position in minor (phi)\r\n   * @param v fractional position on major (theta) arc\r\n   */\r\n  public uvFractionToPoint(u: number, v: number, result?: Point3d): Point3d {\r\n    const thetaRadians = v * this._sweep.radians;\r\n    const phiRadians = u * Math.PI * 2.0;\r\n    const cosTheta = Math.cos(thetaRadians);\r\n    const sinTheta = Math.sin(thetaRadians);\r\n    const minorRadius = this.getMinorRadius();\r\n    const rxy = this.getMajorRadius() + Math.cos(phiRadians) * minorRadius;\r\n    return this._localToWorld.multiplyXYZ(rxy * cosTheta, rxy * sinTheta, minorRadius * Math.sin(phiRadians), result);\r\n  }\r\n  /** Evaluate as a uv surface, returning point and two vectors.\r\n   * @param u fractional position in minor (phi)\r\n   * @param v fractional position on major (theta) arc\r\n   */\r\n  public uvFractionToPointAndTangents(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const thetaRadians = v * this._sweep.radians;\r\n    const phiRadians = u * Math.PI * 2.0;\r\n    const fTheta = this._sweep.radians;\r\n    const fPhi = Math.PI * 2.0;\r\n    const cosTheta = Math.cos(thetaRadians);\r\n    const sinTheta = Math.sin(thetaRadians);\r\n    const sinPhi = Math.sin(phiRadians);\r\n    const cosPhi = Math.cos(phiRadians);\r\n    const minorRadius = this.getMinorRadius();\r\n    const rxy = this.getMajorRadius() + Math.cos(phiRadians) * minorRadius;\r\n    const rSinPhi = minorRadius * sinPhi;\r\n    const rCosPhi = minorRadius * cosPhi;   // appears only as derivative of rSinPhi.\r\n    return Plane3dByOriginAndVectors.createOriginAndVectors(\r\n      this._localToWorld.multiplyXYZ(cosTheta * rxy, sinTheta * rxy, rSinPhi),\r\n      this._localToWorld.multiplyVectorXYZ(-cosTheta * rSinPhi * fPhi, -sinTheta * rSinPhi * fPhi, rCosPhi * fPhi),\r\n      this._localToWorld.multiplyVectorXYZ(-rxy * sinTheta * fTheta, rxy * cosTheta * fTheta, 0),\r\n      result);\r\n  }\r\n  /**\r\n   * Directional distance query\r\n   * * u direction is around the (full) minor hoop\r\n   * * v direction is around the outer radius, sum of (absolute values of) major and minor radii.\r\n   */\r\n  public maxIsoParametricDistance(): Vector2d {\r\n    const a = Math.abs(this.getMajorRadius());\r\n    const b = Math.abs(this.getMinorRadius());\r\n    return Vector2d.create(b * Math.PI * 2.0, (a + b) * this._sweep.radians);\r\n  }\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped || this._sweep.isFullCircle;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n\nimport { Geometry } from \"../Geometry\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { HalfEdge, HalfEdgeGraph, HalfEdgeMask } from \"./Graph\";\nimport { HalfEdgeGraphOps } from \"./Merging\";\nimport { LineString3d } from \"../curve/LineString3d\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\n/**\n * interface containing various options appropriate to merging lines segments into chains.\n */\nexport interface ChainMergeContextOptions {\n  /**\n   * Tolerance for declaring points equal\n   * * Default is `Geometry.smallMetricDistance`\n   */\n  tolerance?: number;\n  /**\n   * Direction for primary sort.\n   * * Default is `Vector3d.create(0.294234298, 0.72391399, 0.45234328798)`\n   * * this vector should NOT be along a principal x,y,z direction.\n   * * The internal form will be normalized.\n   */\n  primarySortDirection?: Vector3d;\n}\n/** Internal form of ChainMergeContextOptions -- same field names, but required to have contents. */\nclass ChainMergeContextValidatedOptions {\n  /**\n   * Tolerance for declaring points equal.\n   */\n  public tolerance: number = Geometry.smallMetricDistance;\n  /** UNNORMALIZED base vector for sorting.\n   * * Actual vector hoisted into an instance is normalized.\n   */\n  private static readonly _defaultPrimarySortDirection = Vector3d.create(0.294234298, 0.72391399, 0.45234328798);\n  /**\n   * Direction for primary sort.  This is normalized !!!\n   */\n  public primarySortDirection: Vector3d;\n  /** return a unit vector aligned with optional direction.\n   * * Default return is into the first quadrant at a quirky angle so any perpendicular plane is unlikely to hit many points\n   */\n  public static createPrimarySortVector(vector?: Vector3d): Vector3d {\n    if (vector === undefined) {\n      vector = this._defaultPrimarySortDirection.clone();\n    }\n    return vector.normalizeWithDefault(\n      ChainMergeContextValidatedOptions._defaultPrimarySortDirection.x,\n      ChainMergeContextValidatedOptions._defaultPrimarySortDirection.y,\n      ChainMergeContextValidatedOptions._defaultPrimarySortDirection.z);\n  }\n  /**\n   * PRIVATE constructor -- assumes all inputs are validated in public create method !!!!\n   * @param tolerance\n   * @param unitVectorForPrimarySort\n   */\n  private constructor(tolerance: number, unitVectorForPrimarySort: Vector3d) {\n    this.tolerance = tolerance;\n    this.primarySortDirection = unitVectorForPrimarySort;\n  }\n  /** return the default option set. */\n  public static createFromUnValidated(options?: ChainMergeContextOptions): ChainMergeContextValidatedOptions {\n    const result = new ChainMergeContextValidatedOptions(Geometry.smallMetricDistance, ChainMergeContextValidatedOptions.createPrimarySortVector());\n    if (options !== undefined) {\n      if (options.tolerance !== undefined)\n        result.tolerance = options.tolerance;\n      if (options.primarySortDirection !== undefined)\n        result.primarySortDirection = ChainMergeContextValidatedOptions.createPrimarySortVector();\n    }\n    return result;\n  }\n  /** Clone this context. */\n  public clone(): ChainMergeContextValidatedOptions {\n    return new ChainMergeContextValidatedOptions(this.tolerance, this.primarySortDirection);\n  }\n}\n/**\n * * Context for assembling line segments into chains.\n * * Use the context in phases:\n *   * Create the context:   `context = ChainMergeContext.create ()`\n *   * Add line with any combination of:\n *      * `context.addSegment(pointA, pointB)`\n *      * `context.addLineSegment3dArray (segments)`\n *   * Scan all coordinate data for common coordinates.  Twist nodes together to form chains:\n *      * `context.clusterAndMergeVerticesXYZ ()`\n *   * Collect the chains:\n *      * myLinestringArray = context.collectMaximalChains();\n *\n * @internal\n */\nexport class ChainMergeContext {\n\n  private _graph: HalfEdgeGraph;\n  private _options: ChainMergeContextValidatedOptions;\n  private constructor(options: ChainMergeContextValidatedOptions) {\n    this._graph = new HalfEdgeGraph();\n    this._options = options;\n  }\n  /**\n   * * Construct an empty chain merge graph.\n   * * The options parameter may contain any combination of the options values.\n   *   * tolerance = absolute tolerance for declaring points equal.\n   *     * Default is `Geometry.smallMetricDistance`\n   *   * primarySortDirection = direction for first sort.\n   *     * To minimize clash among points on primary sort, this should NOT be perpendicular to any principal plane.\n   *     * The default points into the first octant with inobvious components.\n   */\n  public static create(options?: ChainMergeContextOptions): ChainMergeContext {\n    const validatedOptions = ChainMergeContextValidatedOptions.createFromUnValidated(options);\n    return new ChainMergeContext(validatedOptions);\n  }\n  /** Add a segment to the evolving graph. */\n  public addSegment(pointA: Point3d, pointB: Point3d) {\n    this._graph.createEdgeXYZXYZ(pointA.x, pointA.y, pointA.z, 0, pointB.x, pointB.y, pointB.z, 0);\n  }\n  /** Add all segments from an array to the graph. */\n  public addLineSegment3dArray(data: LineSegment3d[]) {\n    for (const segment of data) {\n      this.addSegment(segment.point0Ref, segment.point1Ref);\n    }\n  }\n  /**\n   * Return a numeric value to be used for sorting, with little chance widely separated nodes will have identical key.\n   * * Any single x,y,z component is a poor choice because horizontal and vertical alignment is common.\n   * * Hence take dot product of x,y,z with non-trivial fraction values.\n   * @param node node with x,y,z coordinates\n   */\n  private primarySortKey(node: HalfEdge): number {\n    return this._options.primarySortDirection.dotProductXYZ(node.x, node.y, node.z);\n  }\n  /** Return difference of sortData members as sort comparison */\n  private static nodeCompareSortData(nodeA: HalfEdge, nodeB: HalfEdge): number {\n    return nodeA.sortData! - nodeB.sortData!;\n  }\n  /** test if nodeA is a dangling edge end (i.e. edges around vertex equal 1, but detect it without walking all the way around. */\n  private static isIsolatedEnd(nodeA: HalfEdge): boolean {\n    return nodeA.vertexSuccessor === nodeA;\n  }\n\n  /** test if nodeA is at a vertex with exactly 2 edges (i.e. edges around vertex equal w, but detect it without walking all the way around. */\n  private static isChainInteriorVertex(nodeA: HalfEdge): boolean {\n    const nodeB = nodeA.vertexSuccessor;\n    return nodeB !== nodeA && nodeB.vertexSuccessor === nodeA;\n  }\n\n  /**\n   * * isolate all edge ends.\n   * * perform cluster analysis to determine nearly coincident points.\n   * * pinch all edges together at each vertex.\n   */\n  public clusterAndMergeVerticesXYZ() {\n    HalfEdgeGraphOps.isolateAllEdges(this._graph);\n    for (const p of this._graph.allHalfEdges) {\n      p.sortData = this.primarySortKey(p);\n    }\n    const sortArray = this._graph.allHalfEdges.slice();\n    sortArray.sort(ChainMergeContext.nodeCompareSortData);\n    const xyzTolerance = this._options.tolerance;\n    // A node is unvisited if it is its own vertex successor !!!\n    // otherwise the node has already been twisted into a base vertex.\n    const n = sortArray.length;\n    for (let i0 = 0; i0 < n; i0++) {\n      const node0 = sortArray[i0];\n      const qMin = node0.sortData!;\n      const qMax = qMin + xyzTolerance;\n      if (ChainMergeContext.isIsolatedEnd(node0)) {\n        for (let i1 = i0 + 1; i1 < n; i1++) {\n          const node1 = sortArray[i1];\n          if (ChainMergeContext.isIsolatedEnd(node1)) {\n            if (node1.sortData! > qMax)\n              break;\n            if (node0.distanceXYZ(node1) <= xyzTolerance) {\n              HalfEdge.pinch(node0, node1);\n              node1.setXYZFrom(node0);    // force true equal coordinates.\n            }\n          }\n        }\n      }\n    }\n  }\n  /**\n   * If node0 is not visited, creating a linestring with that starting edge and all successive edges along a chain.\n   * @param chains growing array of chains.\n   * @param node0 start node for search.\n   */\n  private collectMaximalLineString3dFromStartNode(chains: LineString3d[], node0: HalfEdge, visitMask: HalfEdgeMask) {\n    if (!node0.isMaskSet(visitMask)) {\n      const ls = LineString3d.create();\n      ls.addPointXYZ(node0.x, node0.y, node0.z);\n      for (; ;) {\n        node0.setMask(visitMask);\n        node0.edgeMate.setMask(visitMask);\n        node0 = node0.faceSuccessor;\n        ls.addPointXYZ(node0.x, node0.y, node0.z);\n        if (node0.isMaskSet(visitMask) || !ChainMergeContext.isChainInteriorVertex(node0))\n          break;\n      }\n      chains.push(ls);\n    }\n  }\n  /**\n   * If node0 is not visited, creating a linestring with that starting edge and all successive edges along a chain.\n   * @param chains growing array of chains.\n   * @param node0 start node for search.\n   */\n  private collectMaximalGrowableXYXArrayFromStartNode(result: GrowableXYZArray[], node0: HalfEdge, visitMask: HalfEdgeMask) {\n    if (!node0.isMaskSet(visitMask)) {\n      const points = new GrowableXYZArray();\n      points.pushXYZ(node0.x, node0.y, node0.z);\n      for (; ;) {\n        node0.setMask(visitMask);\n        node0.edgeMate.setMask(visitMask);\n        node0 = node0.faceSuccessor;\n        points.pushXYZ(node0.x, node0.y, node0.z);\n        if (node0.isMaskSet(visitMask) || !ChainMergeContext.isChainInteriorVertex(node0))\n          break;\n      }\n      if (points.length > 0)\n        result.push(points);\n    }\n  }\n\n  /**\n   * * find edges with start, end in same vertex loop.\n   * * pinch them away from the loop\n   * * set mask on both sides.\n   * * Return the number of excisions.\n   */\n  private exciseAndMarkSlingEdges(mask: HalfEdgeMask): number {\n    let n = 0;\n    for (const p of this._graph.allHalfEdges) {\n      if (p.distanceXYZ(p.edgeMate) < this._options.tolerance\n        && !p.isMaskSet(mask)) {\n        const q = p.edgeMate;\n        HalfEdge.pinch(p, p.vertexPredecessor);\n        HalfEdge.pinch(q, q.vertexPredecessor);\n        p.setMask(mask);\n        q.setMask(mask);\n        n++;\n      }\n    }\n    return n;\n  }\n  /** Collect chains which have maximum edge count, broken at an vertex with other than 2 edges.\n   * * This is assumed to be preceded by a call to a vertex-cluster step such as `clusterAndMergeVerticesYXZ`\n   */\n  public collectMaximalChains(): LineString3d[] {\n    const result: LineString3d[] = [];\n    const visitMask = HalfEdgeMask.VISITED;\n    // Pass 0: excise and mark zero-length edges.\n    this.exciseAndMarkSlingEdges(visitMask);\n    this._graph.clearMask(visitMask);\n    // Pass 1: only start at non-interior edges -- vertices with one edge or more than 2 edges.\n    // (Note that collectMaximalChain checks the visit mask.)\n    for (const node0 of this._graph.allHalfEdges) {\n      if (!ChainMergeContext.isChainInteriorVertex(node0)) {\n        this.collectMaximalLineString3dFromStartNode(result, node0, visitMask);\n      }\n    }\n    // Pass 2: start anywhere in an unvisited loop.\n    for (const node0 of this._graph.allHalfEdges) {\n      this.collectMaximalLineString3dFromStartNode(result, node0, visitMask);\n    }\n    return result;\n  }\n  public collectMaximalGrowableXYZArrays(): GrowableXYZArray[] {\n    const result: GrowableXYZArray[] = [];\n    const visitMask = HalfEdgeMask.VISITED;\n    // Pass 0: excise and mark zero-length edges.\n    this.exciseAndMarkSlingEdges(visitMask);\n    this._graph.clearMask(visitMask);\n    // Pass 1: only start at non-interior edges -- vertices with one edge or more than 2 edges.\n    // (Note that collectMaximalChain checks the visit mask.)\n    for (const node0 of this._graph.allHalfEdges) {\n      if (!ChainMergeContext.isChainInteriorVertex(node0)) {\n        this.collectMaximalGrowableXYXArrayFromStartNode(result, node0, visitMask);\n      }\n    }\n    // Pass 2: start anywhere in an unvisited loop.\n    for (const node0 of this._graph.allHalfEdges) {\n      this.collectMaximalGrowableXYXArrayFromStartNode(result, node0, visitMask);\n    }\n    return result;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n\nimport { Vector2d, Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { Geometry } from \"../Geometry\";\nimport { SmallSystem } from \"../numerics/Polynomials\";\nimport { Transform } from \"../geometry3d/Transform\";\nimport { XYAndZ } from \"../geometry3d/XYZProps\";\nimport { MaskManager } from \"./MaskManager\";\n/** function signature for function of one node with no return type restrictions\n * @internal\n */\nexport type NodeFunction = (node: HalfEdge) => any;\n/** function signature for function of one node, returning a number\n * @internal\n */\nexport type NodeToNumberFunction = (node: HalfEdge) => number;\n/** function signature for function of one node, returning a boolean\n * @internal\n */\nexport type HalfEdgeToBooleanFunction = (node: HalfEdge) => boolean;\n/** function signature for function of a node and a mask, returning a number\n * @internal\n */\nexport type HalfEdgeAndMaskToBooleanFunction = (node: HalfEdge, mask: HalfEdgeMask) => boolean;\n/** function signature for function of a graph and a node, returning a boolean\n * @internal\n */\nexport type GraphNodeFunction = (graph: HalfEdgeGraph, node: HalfEdge) => boolean;\n/**\n *\n * * A HalfEdge is \"one side of an edge\" in a structure of faces, edges and vertices.  From a node there are navigational links to:\n * ** \"faceSuccessor\" -- the next half edge in a loop around a face.\n * ** \"facePredecessor\" -- the previous half edge in a loop around a face.\n * ** \"edgeMate\"  -- the node's partner on the other side of the edge.\n * * The next, prev, and mate are the essential connectivity.  Additional node content is for application-specific\n *     uses.  The most useful ones are:\n * ** x,y -- coordinates in the xy plane\n * ** z -- z coordinate.  This is normally ignored during planar setup, but used for output.\n * ** buffer -- a integer value manipulated as individual bits.\n * * In properly connected planar graph, interior face loops are counterclockwise.  But that property (along with\n *      expected masking) is a result of extensive validation of inputs, and is not true in intermediate phases\n *      of graph manipulation.\n * @internal\n */\nexport class HalfEdge {\n  /** Vertex index in some parent object's numbering. */\n  public i: number;\n  /** bitmask bits, used to mark nodes as part of a triangle(idx 0) or visited when flipping(idx 1) */\n  public maskBits: number;\n  /** Vertex x coordinate */\n  public x: number;\n  /** Vertex y coordinate */\n  public y: number;\n  /** Vertex z coordinate */\n  public z: number;\n  /** angle used for sort-around-vertex */\n  public sortAngle?: number;  // used in sorting around vertex.\n  /** numeric value for application-specific tagging (e.g. sorting) */\n  public sortData?: number;\n  /** application-specific data for the edge identifier.\n   * * edge split operations are expected to copy this to new sub-edges.\n   */\n  public edgeTag?: any;\n  private _id: any;   // immutable id useful for debugging.\n  /** id assigned sequentially during construction --- useful for debugging. */\n  public get id() { return this._id; }\n  private _facePredecessor: HalfEdge;\n  private _faceSuccessor: HalfEdge;\n  private _edgeMate: HalfEdge;\n  /** previous half edge \"around the face\"\n   */\n  public get facePredecessor(): HalfEdge { return this._facePredecessor; }\n  /** next half edge \"around the face\" */\n  public get faceSuccessor(): HalfEdge { return this._faceSuccessor; }\n  /** Half edge on the other side of this edge.\n   */\n  public get edgeMate(): HalfEdge { return this._edgeMate; }\n  /** Take numStep face steps and return y coordinate\n   * * positive steps are through faceSuccessor\n   * * negative steps are through facePredecessor\n   */\n  public faceStepY(numStep: number): number {\n    let node: HalfEdge = this;\n    if (numStep > 0)\n      for (let i = 0; i < numStep; i++) node = node.faceSuccessor;\n    else if (numStep < 0)\n      for (let i = 0; i > numStep; i--) node = node.facePredecessor;\n    return node.y;\n  }\n  /**\n   * * Create 2 half edges.\n   * * The two edges are joined as edgeMate pair.\n   * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n   * @returns Returns the reference to the first half edge created\n   */\n  public static createHalfEdgePair(heArray: HalfEdge[] | undefined): HalfEdge {\n    const a = new HalfEdge();\n    const b = new HalfEdge();\n    if (heArray) {\n      heArray.push(a);\n      heArray.push(b);\n    }\n\n    HalfEdge.setFaceLinks(a, b);\n    HalfEdge.setFaceLinks(b, a);\n    HalfEdge.setEdgeMates(a, b);\n    return a;\n  }\n\n  /**\n   * * Create 2 half edges.\n   * * The two edges are joined as edgeMate pair.\n   * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n   * * Properties x,y,z,i are inserted in each\n   * @returns Returns the reference to the first half edge created\n   */\n  public static createHalfEdgePairWithCoordinates(\n    xA: number = 0,\n    yA: number = 0,\n    zA: number = 0,\n    iA: number = 0,\n    xB: number = 0,\n    yB: number = 0,\n    zB: number = 0,\n    iB: number = 0,\n    heArray: HalfEdge[] | undefined): HalfEdge {\n    const a = HalfEdge.createHalfEdgePair(heArray);\n    const b = a._edgeMate;\n    a.x = xA; a.y = yA; a.z = zA; a.i = iA;\n    b.x = xB; b.y = yB; b.z = zB; b.i = iB;\n    return a;\n  }\n  /**\n   * * set heA <==> heB pointer relation through heA._faceSuccessor and heB._facePredecessor\n   * * This changes heA._faceSuccessor and heB._facePredecessor, but not heA._facePredecessor and heB._faceSuccessor.\n   * * this must always be done with another call to reestablish the entire double-linked list.\n   */\n  private static setFaceLinks(heA: HalfEdge, heB: HalfEdge) {\n    heA._faceSuccessor = heB;\n    heB._facePredecessor = heA;\n  }\n  /**\n   * * set heA <==> heB pointer relation edgeMate\n   */\n  private static setEdgeMates(heA: HalfEdge, heB: HalfEdge) {\n    heA._edgeMate = heB;\n    heB._edgeMate = heA;\n  }\n\n  /**\n   * * Create a new vertex within the edge from base.\n   * * Insert it \"within\" the base edge.\n   * * This requires two new half edges.\n   * * if the base is undefined, create a single-edge loop.\n   * * This (unlike pinch) breaks the edgeMate pairing of the base edge.\n   * * This preserves xyz and i properties at all existing vertices.\n   * * on each side, if edgeTag is present it is copied to the new edge.\n   * @returns Returns the reference to the half edge created.\n   */\n  public static splitEdge(baseA: undefined | HalfEdge,\n    xA: number = 0, yA: number = 0, zA: number = 0, iA: number = 0, heArray: HalfEdge[] | undefined): HalfEdge {\n    const newA = new HalfEdge(xA, yA, zA, iA);\n    const newB = new HalfEdge(xA, yA, zA, iA);\n    if (heArray) {\n      heArray.push(newA);\n      heArray.push(newB);\n    }\n\n    if (baseA === undefined) {\n      newA._faceSuccessor = newA._facePredecessor = newA;\n      newB._faceSuccessor = newB._facePredecessor = newB;\n      HalfEdge.setEdgeMates(newA, newB);\n    } else {\n      const nextA = baseA._faceSuccessor;\n      const mateA = baseA._edgeMate;\n      const vPredA = mateA._faceSuccessor;\n      HalfEdge.setFaceLinks(newA, nextA);\n      HalfEdge.setFaceLinks(baseA, newA);\n      HalfEdge.setFaceLinks(mateA, newB);\n      HalfEdge.setFaceLinks(newB, vPredA);\n      HalfEdge.setEdgeMates(newA, mateA);\n      HalfEdge.setEdgeMates(newB, baseA);\n      newA.edgeTag = baseA.edgeTag;\n      newB.edgeTag = mateA.edgeTag;\n    }\n    return newA;\n  }\n\n  private static _totalNodesCreated = 0;\n  public constructor(x: number = 0, y: number = 0, z: number = 0, i: number = 0) {\n    this._id = HalfEdge._totalNodesCreated++;\n    this.i = i;\n    this.maskBits = 0x00000000;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    // Explicit init to undefined is important for performance here\n    this.sortAngle = undefined;\n    this.sortData = undefined;\n    this.edgeTag = undefined;\n    // Always created in pairs, init here to make TS compiler and JS runtime happy\n    this._facePredecessor = this;\n    this._faceSuccessor = this;\n    this._edgeMate = this;\n  }\n\n  /**\n   * Return the next outbound half edge around this vertex in the CCW direction\n   */\n  get vertexSuccessor(): HalfEdge { return this.facePredecessor.edgeMate; }\n  /**\n   * Return the next outbound half edge around this vertex in the CW direction\n   */\n  get vertexPredecessor(): HalfEdge { return this.edgeMate.faceSuccessor; }\n  /**\n   * Set mask bits on this HalfEdge\n   * @param mask mask to apply\n   */\n  public setMask(mask: HalfEdgeMask) { this.maskBits |= mask; }\n  /**\n   * Get mask bits from this HalfEdge\n   * @param mask mask to query\n   */\n  public getMask(mask: HalfEdgeMask): number { return (this.maskBits & mask); }\n  /**\n   * Clear mask bits from this HalfEdge\n   * @param mask mask to clear\n   */\n  public clearMask(mask: HalfEdgeMask) { this.maskBits &= ~mask; }\n  /**\n   * Set a mask at all nodes around a vertex.\n   * @param mask mask to apply to the half edges around this HalfEdge's vertex loop\n   */\n  public setMaskAroundVertex(mask: HalfEdgeMask) {\n    let node: HalfEdge = this;\n    do {\n      node.setMask(mask);\n      node = node.vertexSuccessor;\n    } while (node !== this);\n  }\n\n  /**\n   * Set x,y,z at all nodes around a vertex.\n   * @param mask mask to apply to the half edges around this HalfEdge's vertex loop\n   */\n  public setXYZAroundVertex(x: number, y: number, z: number) {\n    let node: HalfEdge = this;\n    do {\n      node.x = x; node.y = y; node.z = z;\n      node = node.vertexSuccessor;\n    } while (node !== this);\n  }\n  /**\n   * Apply a mask to all edges around a face.\n   * @param mask mask to apply to the half edges around this HalfEdge's face loop\n   */\n  public setMaskAroundFace(mask: HalfEdgeMask) {\n    let node: HalfEdge = this;\n    do {\n      node.setMask(mask);\n      node = node.faceSuccessor;\n    } while (node !== this);\n  }\n\n  /**\n   * Apply a mask to both sides of an edge.\n   * @param mask mask to apply to this edge and its `edgeMate`\n   */\n  public setMaskAroundEdge(mask: HalfEdgeMask) {\n    this.setMask(mask);\n    this.edgeMate.setMask(mask);\n  }\n\n  /**\n   * Apply a mask to both sides of an edge.\n   * @param mask mask to apply to this edge and its `edgeMate`\n   */\n  public clearMaskAroundEdge(mask: HalfEdgeMask) {\n    this.clearMask(mask);\n    this.edgeMate.clearMask(mask);\n  }\n\n  /** Returns the number of edges around this face. */\n  public countEdgesAroundFace(): number {\n    let count = 0;\n    let node: HalfEdge = this;\n    do {\n      count++;\n      node = node.faceSuccessor;\n    } while (node !== this);\n    return count;\n  }\n\n  /**\n   * Apply a edgeTag and mask to all edges around a face.\n   * optionally apply it to all edge mates.\n   * @param edgeTag tag to apply\n   * @param bothSides If true, also apply the tag to the mates around the face.\n   */\n  public setMaskAndEdgeTagAroundFace(mask: HalfEdgeMask, tag: any, applyToMate: boolean = false) {\n    let node: HalfEdge = this;\n    do {\n      node.setMask(mask);\n      node.edgeTag = tag;\n      if (applyToMate) {\n        const mate = node.edgeMate;\n        mate.edgeTag = tag;\n        mate.setMask(mask);\n      }\n      node = node.faceSuccessor;\n    } while (node !== this);\n  }\n\n  /** Returns the number of edges around vertex. */\n  public countEdgesAroundVertex(): number {\n    let count = 0;\n    let node: HalfEdge = this;\n    do {\n      count++;\n      node = node.vertexSuccessor;\n    } while (node !== this);\n    return count;\n  }\n\n  /** Returns the number of nodes found with the given mask value around this vertex loop. */\n  public countMaskAroundFace(mask: HalfEdgeMask, value: boolean = true): number {\n    let count = 0;\n    let node: HalfEdge = this;\n    if (value) {\n      do {\n        if (node.isMaskSet(mask)) count++;\n        node = node.faceSuccessor;\n      } while (node !== this);\n    } else {\n      do {\n        if (!node.isMaskSet(mask)) count++;\n        node = node.faceSuccessor;\n      } while (node !== this);\n    }\n    return count;\n  }\n\n  /** Returns the number of nodes found with the given mask value around this vertex loop.   */\n  public countMaskAroundVertex(mask: HalfEdgeMask, value: boolean = true): number {\n    let count = 0;\n    let node: HalfEdge = this;\n    if (value) {\n      do {\n        if (node.isMaskSet(mask)) count++;\n        node = node.vertexSuccessor;\n      } while (node !== this);\n    } else {\n      do {\n        if (!node.isMaskSet(mask)) count++;\n        node = node.vertexSuccessor;\n      } while (node !== this);\n    }\n    return count;\n  }\n\n  /** Set a mask, and return prior value.\n   * @param mask mask to apply\n   */\n  public testAndSetMask(mask: HalfEdgeMask): number {\n    const oldMask = this.maskBits & mask;\n    this.maskBits |= mask;\n    return oldMask;\n  }\n  /**\n   * Set (copy) the this.x, this.y, this.z from node.x, node.y, node.z\n   * @param node node containing xyz\n   */\n  public setXYZFrom(node: HalfEdge) {\n    this.x = node.x;\n    this.y = node.y;\n    this.z = node.z;\n  }\n\n  /**\n   * Test if mask bits are set in the node's bitMask.\n   * @return Return true (as a simple boolean, not a mask) if any bits of the mask parameter match bits of the node's bitMask\n   */\n  public isMaskSet(mask: HalfEdgeMask): boolean { return (this.maskBits & mask) !== 0; }\n\n  /** (static!) method to test if a mask is set on a node.\n   * This is used as filter in searches.\n   * @returns true iff `node.isMaskSet (mask)`\n   */\n  public static filterIsMaskOn(node: HalfEdge, mask: HalfEdgeMask): boolean {\n    return node.isMaskSet(mask);\n  }\n  /** (static!) method to test if a mask is set on a node.\n   * This is used as filter in searches.\n   * @returns true iff `!node.isMaskSet (mask)`\n   */\n  public static filterIsMaskOff(node: HalfEdge, mask: HalfEdgeMask): boolean {\n    return !node.isMaskSet(mask);\n  }\n\n  /**\n   * Create an edge with initial id,x,y at each end.\n   * @param id0 id for first node\n   * @param x0  x coordinate for first node\n   * @param y0  y coordinate for first node\n   * @param id1 id for second node\n   * @param x1 x coordinate for second node\n   * @param y1 y coordinate for second node\n   */\n  public static createEdgeXYXY(id0: any, x0: number, y0: number, id1: any, x1: number, y1: number): HalfEdge {\n    const node0 = new HalfEdge(x0, y0);\n    const node1 = new HalfEdge(x1, y1);\n    node0._faceSuccessor = node0._facePredecessor = node0._edgeMate = node1;\n    node1._faceSuccessor = node1._facePredecessor = node1._edgeMate = node0;\n    node0._id = id0;\n    node1._id = id1;\n    return node0;\n  }\n\n  /** \"pinch\" ...\n   *\n   * * is the universal manipulator for manipulating a node's next and prev pointers\n   * * swaps face predecessors of nodeA and nodeB.\n   * *  is its own inverse.\n   * *  if nodeA, nodeB are in different face loops, the loops join to one loop.\n   * *  if nodeA, nodeB are in the same face loop, the loop splits into two loops.\n   */\n  public static pinch(nodeA: HalfEdge, nodeB: HalfEdge) {\n    if (nodeA !== nodeB) {\n      const predA = nodeA._facePredecessor;\n      const predB = nodeB._facePredecessor;\n      nodeB._facePredecessor = predA;\n      nodeA._facePredecessor = predB;\n      predB._faceSuccessor = nodeA;\n      predA._faceSuccessor = nodeB;\n    }\n  }\n\n  /** Turn all pointers to undefined so garbage collector can reuse the object.\n   *  This is to be called only by a Graph object that is being decommissioned.\n   */\n  public decommission() {\n    (this._facePredecessor as any) = undefined;\n    (this._faceSuccessor as any) = undefined;\n    (this._edgeMate as any) = undefined;\n  }\n\n  /** Return the node. This identity function is useful as the NodeFunction in collector methods. */\n  public static nodeToSelf(node: HalfEdge): any { return node; }\n  /** Return the id of a node.  Useful for collector methods. */\n  public static nodeToId(node: HalfEdge): any { return node.id; }\n  /** Return the id of a node.Useful for collector methods. */\n  public static nodeToIdString(node: HalfEdge): any { return node.id.toString(); }\n\n  /** Return the [id, [x,y]] of a node.  Useful for collector methods. */\n  public static nodeToIdMaskXY(node: HalfEdge): { id: any, mask: any, xy: number[] } {\n    return { id: node.id, mask: HalfEdge.nodeToMaskString(node), xy: [node.x, node.y] };\n  }\n\n  /** Return the [id, [x,y]] of a node.  Useful for collector methods. */\n  public static nodeToIdXYString(node: HalfEdge): string {\n    const s = node.id.toString() + \" \" +\n      HalfEdge.nodeToMaskString(node) + \" [\" + node.x + \",\" + node.y + \"]\";\n    return s;\n  }\n\n  /** Create a string representation of the mask\n   * * Null mask is empty string.\n   * * Appended characters B,P,X for Boundary, Primary, Exterior mask bits.\n   */\n  public static nodeToMaskString(node: HalfEdge): string {\n    let s = \"\";\n    if (node.isMaskSet(HalfEdgeMask.BOUNDARY_EDGE)) s += \"B\";\n    if (node.isMaskSet(HalfEdgeMask.PRIMARY_EDGE)) s += \"P\";\n    if (node.isMaskSet(HalfEdgeMask.EXTERIOR)) s += \"X\";\n    if (node.isMaskSet(HalfEdgeMask.NULL_FACE)) s += \"N\";\n    return s;\n  }\n  /** Return [x,y] with coordinates of node */\n  public static nodeToXY(node: HalfEdge): number[] { return [node.x, node.y]; }\n  /** Return Vector2d to face successor, with only xy coordinates */\n  public vectorToFaceSuccessorXY(result?: Vector2d): Vector2d {\n    return Vector2d.create(this.faceSuccessor.x - this.x, this.faceSuccessor.y - this.y, result);\n  }\n  /** Return Vector3d to face successor */\n  public vectorToFaceSuccessor(result?: Vector3d): Vector3d {\n    return Vector3d.create(\n      this.faceSuccessor.x - this.x,\n      this.faceSuccessor.y - this.y,\n      this.faceSuccessor.z - this.z,\n      result);\n  }\n\n  /** Returns Return cross product (2d) of vectors from base to target1 and this to target2 */\n  public static crossProductXYToTargets(base: HalfEdge, targetA: HalfEdge, targetB: HalfEdge): number {\n    return Geometry.crossProductXYXY(\n      targetA.x - base.x, targetA.y - base.y,\n      targetB.x - base.x, targetB.y - base.y);\n  }\n\n  /** Return cross product (2d) of vectors from nodeA to nodeB and nodeB to nodeC\n   */\n  public static crossProductXYAlongChain(nodeA: HalfEdge, nodeB: HalfEdge, nodeC: HalfEdge): number {\n    return Geometry.crossProductXYXY(\n      nodeB.x - nodeA.x, nodeB.y - nodeA.y,\n      nodeC.x - nodeB.x, nodeC.y - nodeB.y);\n  }\n  /** Return true if `this` is lexically below `other`, comparing y first then x. */\n  public belowYX(other: HalfEdge): boolean {\n    // Check y's\n    // if (!Geometry.isSameCoordinate(a.y, b.y))\n\n    if (this.y < other.y)\n      return true;\n    if (this.y > other.y)\n      return false;\n    // same y.\n    // Check x's\n    if (this.x < other.x)\n      return true;\n    return false;\n  }\n  /** Returns Returns true if the node does NOT have Mask.EXTERIOR_MASK set. */\n  public static testNodeMaskNotExterior(node: HalfEdge) { return !node.isMaskSet(HalfEdgeMask.EXTERIOR); }\n\n  /** Returns Returns true if the face has positive area in xy parts. */\n  public static testFacePositiveAreaXY(node: HalfEdge) {\n    return node.countEdgesAroundFace() > 2 && node.signedFaceArea() > 0.0;\n  }\n\n  /** Return true if x and y coordinates of this and other are exactly equal */\n  public isEqualXY(other: HalfEdge): boolean {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  /** Return true if x and y coordinates of this and other are exactly equal */\n  public distanceXY(other: HalfEdge): number {\n    return Geometry.distanceXYXY(this.x, this.y, other.x, other.y);\n  }\n\n  /** Return true if x and y coordinates of this and other are exactly equal */\n  public distanceXYZ(other: HalfEdge): number {\n    return Geometry.distanceXYZXYZ(this.x, this.y, this.z, other.x, other.y, other.z);\n  }\n  /**\n   *\n   * * Evaluate f(node) at each node around a face loop.\n   * * Collect the function values.\n   * @returns Return the array of function values.\n   */\n  public collectAroundFace(f?: NodeFunction): any[] {\n    const nodes = [];\n    let node: HalfEdge = this;\n    do {\n      nodes.push(f ? f(node) : node);\n      node = node.faceSuccessor;\n    } while (node !== this);\n    return nodes;\n  }\n\n  /**\n   *\n   * * Evaluate f(node) at each outbound node around this node's vertex loop.\n   * * Collect the function values.\n   * @returns Return the array of function values.\n   */\n  public collectAroundVertex(f?: NodeFunction): any[] {\n    const nodes = [];\n    let node: HalfEdge = this;\n    do {\n      nodes.push(f ? f(node) : node);\n      node = node.vertexSuccessor;\n    } while (node !== this);\n    return nodes;\n  }\n\n  /**\n   *\n   * * Evaluate f(node) at each node around a face loop.\n   * * Sum the function values\n   * @returns Return the sum\n   */\n  public sumAroundFace(f: NodeToNumberFunction): number {\n    let node: HalfEdge = this;\n    let sum = 0;\n    do {\n      sum += f(node);\n      node = node.faceSuccessor;\n    } while (node !== this);\n    return sum;\n  }\n\n  /**\n   *\n   * * Evaluate f(node) at each outbound node around this node's vertex loop.\n   * * Sum the function values\n   * @returns Return the sum\n   */\n  public sumAroundVertex(f: NodeToNumberFunction): number {\n    let node: HalfEdge = this;\n    let sum = 0;\n    do {\n      sum += f(node);\n      node = node.vertexSuccessor;\n    } while (node !== this);\n    return sum;\n  }\n  /** For all the nodes in the face loop of the given node, clear out the mask given */\n  public clearMaskAroundFace(mask: HalfEdgeMask) {\n    let node: HalfEdge = this;\n    do {\n      node.clearMask(mask);\n      node = node.faceSuccessor;\n    } while (node !== this);\n  }\n\n  /** For all the nodes in the vertex loop of the given node, clear out the mask given */\n  public clearMaskAroundVertex(mask: HalfEdgeMask) {\n    let node: HalfEdge = this;\n    do {\n      node.clearMask(mask);\n      node = node.vertexSuccessor;\n    } while (node !== this);\n  }\n  /** Returns the signed sum of xy areas of triangles from first node to edges.\n   *\n   * * A positive area is counterclockwise.\n   * * A negative area is clockwise.\n   */\n  public signedFaceArea(): number {\n    let sum = 0;\n    // sum area of trapezoids.\n    // * the formula in the loop gives twice the area (because it does nto average the y values).\n    // * this is fixed up at the end by a single multiply by 0.5\n    // * individual trapezoid heights are measured from y at the start node to keep area values numerical smaller.\n    const y0 = this.y;\n    let dy0 = 0.0;\n    let dy1 = 0.0;\n    let x0 = this.x;\n    let x1 = x0;\n    let node1: HalfEdge = this;  // just to initialize -- reassigned in each loop pass.\n    let node0: HalfEdge = this;\n    do {\n      node1 = node0.faceSuccessor;\n      x1 = node1.x;\n      dy1 = node1.y - y0;\n      sum += (x0 - x1) * (dy0 + dy1);\n      x0 = x1;\n      dy0 = dy1;\n      node0 = node1;\n      node0 = node1;\n    } while (node0 !== this);\n    return 0.5 * sum;\n  }\n  /**\n   * interpolate xy coordinates between this node and its face successor.\n   * @param fraction fractional position along this edge.\n   * @param result xy coordinates\n   */\n  public fractionToPoint2d(fraction: number, result?: Point2d): Point2d {\n    const node1 = this.faceSuccessor;\n    return Point2d.create(\n      this.x + (node1.x - this.x) * fraction,\n      this.y + (node1.y - this.y) * fraction,\n      result);\n  }\n  /**\n   * interpolate xy coordinates between this node and its face successor.\n   * @param fraction fractional position along this edge.\n   * @param result xy coordinates\n   */\n  public fractionToPoint3d(fraction: number, result?: Point3d): Point3d {\n    const node1 = this.faceSuccessor;\n    return Point3d.create(\n      this.x + (node1.x - this.x) * fraction,\n      this.y + (node1.y - this.y) * fraction,\n      this.z + (node1.z - this.z) * fraction,\n      result);\n  }\n  /**\n   * * interpolate xy coordinates at fractionAlong between this node and its face successor.\n   * * shift to left by fractionPerpendicular\n   * @param fraction fractional position along this edge.\n   * @param result xy coordinates\n   */\n  public fractionAlongAndPerpendicularToPoint2d(fractionAlong: number, fractionPerpendicular: number, result?: Point2d): Point2d {\n    const node1 = this.faceSuccessor;\n    const dx = node1.x - this.x;\n    const dy = node1.y - this.y;\n    return Point2d.create(\n      this.x + dx * fractionAlong - dy * fractionPerpendicular,\n      this.y + dy * fractionAlong + dx * fractionPerpendicular,\n      result);\n  }\n\n  /**\n   * Return the interpolated x coordinate between this node and its face successor.\n   * @param fraction fractional position along this edge.\n   */\n  public fractionToX(fraction: number): number {\n    const node1 = this.faceSuccessor;\n    return this.x + (node1.x - this.x) * fraction;\n  }\n  /**\n   * Return the interpolated y coordinate between this node and its face successor.\n   * @param fraction fractional position along this edge.\n   */\n  public fractionToY(fraction: number): number {\n    const node1 = this.faceSuccessor;\n    return this.y + (node1.y - this.y) * fraction;\n  }\n\n  /**\n   * Return the interpolated z coordinate between this node and its face successor.\n   * @param fraction fractional position along this edge.\n   */\n  public fractionToZ(fraction: number): number {\n    const node1 = this.faceSuccessor;\n    return this.z + (node1.z - this.z) * fraction;\n  }\n  /**\n   * * Compute fractional coordinates of the intersection of edges from given base nodes\n   * * If parallel or colinear, return undefined.\n   * * If (possibly extended) lines intersect, return the fractions of intersection as x,y in the result.\n   * @param nodeA0 Base node of edge A\n   * @param nodeB0 Base node of edge B\n   * @param result optional preallocated result\n   */\n  public static transverseIntersectionFractions(nodeA0: HalfEdge, nodeB0: HalfEdge, result?: Vector2d): Vector2d | undefined {\n    const nodeA1 = nodeA0.faceSuccessor;\n    const nodeB1 = nodeB0.faceSuccessor;\n    if (!result)\n      result = Vector2d.create();\n    if (SmallSystem.linearSystem2d(\n      nodeA1.x - nodeA0.x, nodeB0.x - nodeB1.x,\n      nodeA1.y - nodeA0.y, nodeB0.y - nodeB1.y,\n      nodeB0.x - nodeA0.x, nodeB0.y - nodeA0.y,\n      result))\n      return result;\n    return undefined;\n  }\n  /**\n   * * Compute fractional coordinates of the intersection of a horizontal line with an edge.\n   * * If the edge is horizontal with (approximate) identical y, return the node.\n   * * If the edge is horizontal with different y, return undefined.\n   * * If the edge is not horizontal, return the fractional position (possibly outside 0..1) of the intersection.\n   * @param nodeA Base node of edge\n   * @param result optional preallocated result\n   */\n  public static horizontalScanFraction(node0: HalfEdge, y: number): number | undefined | HalfEdge {\n    const node1 = node0.faceSuccessor;\n    const dy = node1.y - node0.y;\n    if (Geometry.isSameCoordinate(y, node0.y) && Geometry.isSameCoordinate(y, node1.y))\n      return node0;\n    if (Geometry.isSameCoordinate(dy, 0.0))\n      return undefined;\n    return Geometry.conditionalDivideFraction(y - node0.y, dy);\n  }\n\n  /**\n   * * Compute fractional coordinates of the intersection of a horizontal line with an edge.\n   * * If the edge is horizontal return undefined (no test for horizontal at y!!!)\n   * * If the edge is not horizontal and y is between its end y's, return the fraction\n   * @param nodeA Base node of edge\n   * @param result optional preallocated result\n   */\n  public static horizontalScanFraction01(node0: HalfEdge, y: number): number | undefined {\n    const node1 = node0.faceSuccessor;\n    const dy = node1.y - node0.y;\n    if (Geometry.isSameCoordinate(y, node0.y) && Geometry.isSameCoordinate(y, node1.y))\n      return undefined;\n    if (Geometry.isSameCoordinate(dy, 0.0))\n      return undefined;\n    const fraction = Geometry.conditionalDivideFraction(y - node0.y, dy);\n    if (fraction !== undefined && fraction >= 0.0 && fraction <= 1.0)\n      return fraction;\n    return undefined;\n  }\n}\n/**\n * A HalfEdgeGraph has:\n * * An array of (pointers to ) HalfEdge objects.\n * * A pool of masks for grab/drop use by algorithms.\n * @internal\n */\nexport class HalfEdgeGraph {\n  /** Simple array with pointers to all the half edges in the graph. */\n  public allHalfEdges: HalfEdge[];\n  private _maskManager: MaskManager;\n  private _numNodesCreated = 0;\n  public constructor() {\n    this.allHalfEdges = [];\n    this._maskManager = MaskManager.create(HalfEdgeMask.ALL_GRAB_DROP_MASKS)!;\n  }\n  /** Ask for a mask (from the graph's free pool.) for caller's use.\n   * * Optionally clear the mask throughout the graph.\n   */\n  public grabMask(clearInAllHalfEdges: boolean = true): HalfEdgeMask {\n    const mask = this._maskManager.grabMask();\n    if (clearInAllHalfEdges) {\n      this.clearMask(mask);\n    }\n    return mask;\n  }\n  /**\n   * Return `mask` to the free pool.\n   */\n  public dropMask(mask: HalfEdgeMask) { this._maskManager.dropMask(mask); }\n  /**\n   * * Create 2 half edges forming 2 vertices, 1 edge, and 1 face\n   * * The two edges are joined as edgeMate pair.\n   * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n   * * The two edges are added to the graph's HalfEdge set\n   * @returns Return pointer to the first half edge created.\n   */\n  public createEdgeXYZXYZ(\n    xA: number = 0,\n    yA: number = 0,\n    zA: number = 0,\n    iA: number = 0,\n    xB: number = 0,\n    yB: number = 0,\n    zB: number = 0,\n    iB: number = 0): HalfEdge {\n    const a = HalfEdge.createHalfEdgePairWithCoordinates(xA, yA, zA, iA, xB, yB, zB, iB, this.allHalfEdges);\n    return a;\n  }\n  /**\n   * * create an edge from coordinates x,y,z to (the tail of) an existing half edge.\n   * @returns Return pointer to the half edge with tail at x,y,z\n   */\n  public createEdgeXYZHalfEdge(\n    xA: number = 0,\n    yA: number = 0,\n    zA: number = 0,\n    iA: number = 0,\n    node: HalfEdge,\n    iB: number = 0): HalfEdge {\n    const a = HalfEdge.createHalfEdgePairWithCoordinates(xA, yA, zA, iA, node.x, node.y, node.z, iB, this.allHalfEdges);\n    const b = a.faceSuccessor;\n    HalfEdge.pinch(node, b);\n    return a;\n  }\n  /**\n   * * create an edge from coordinates x,y,z to (the tail of) an existing half edge.\n   * @returns Return pointer to the half edge with tail at x,y,z\n   */\n  public createEdgeHalfEdgeHalfEdge(\n    nodeA: HalfEdge,\n    idA: number,\n    nodeB: HalfEdge,\n    idB: number = 0): HalfEdge {\n    const a = HalfEdge.createHalfEdgePairWithCoordinates(nodeA.x, nodeA.y, nodeA.z, idA, nodeB.x, nodeB.y, nodeB.z, idB, this.allHalfEdges);\n    const b = a.faceSuccessor;\n    HalfEdge.pinch(nodeA, a);\n    HalfEdge.pinch(nodeB, b);\n    return a;\n  }\n\n  /**\n   * * Create 2 half edges forming 2 vertices, 1 edge, and 1 face\n   * * The two edges are joined as edgeMate pair.\n   * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n   * * The two edges are added to the graph's HalfEdge set\n   * @returns Return pointer to the first half edge created.\n   */\n  public createEdgeXYAndZ(xyz0: XYAndZ, id0: number, xyz1: XYAndZ, id1: number): HalfEdge {\n    const a = HalfEdge.createHalfEdgePairWithCoordinates(xyz0.x, xyz0.y, xyz0.z, id0, xyz1.x, xyz1.y, xyz1.z, id1, this.allHalfEdges);\n    return a;\n  }\n\n  /**\n   * * Insert a vertex in the edge beginning at base.\n   * * this creates two half edges.\n   * * The base of the new edge is 'after' the (possibly undefined) start node in its face loop.\n   * * The existing mate retains its base xyz and i properties but is no longer the mate of base.\n   * * The base and existing mate each become mates with a new half edge.\n   * @returns Returns the reference to the half edge created.\n   */\n  public splitEdge(base: undefined | HalfEdge,\n    xA: number = 0, yA: number = 0, zA: number = 0, iA: number = 0): HalfEdge {\n    const he = HalfEdge.splitEdge(base, xA, yA, zA, iA, this.allHalfEdges);\n    return he;\n  }\n\n  /**\n   * * Insert a vertex in the edge beginning at base, with coordinates specified as a fraction along the existing edge.\n   * * this creates two half edges.\n   * * The base of the new edge is 'after' the (possibly undefined) start node in its face loop.\n   * * The existing mate retains its base xyz and i properties but is no longer the mate of base.\n   * * The base and existing mate each become mates with a new half edge.\n   * @returns Returns the reference to the half edge created.\n   */\n  public splitEdgeAtFraction(base: HalfEdge, fraction: number): HalfEdge {\n    const he = HalfEdge.splitEdge(base, base.fractionToX(fraction), base.fractionToY(fraction), base.fractionToZ(fraction), 0, this.allHalfEdges);\n    return he;\n  }\n  /** This is a destructor-like action that eliminates all interconnection among the graph's nodes.\n   * After this is called the graph is unusable.\n   */\n  public decommission() {\n    for (const node of this.allHalfEdges) { node.decommission(); }\n    this.allHalfEdges.length = 0;\n    (this.allHalfEdges as any) = undefined;\n  }\n  /** create two nodes of a new edge.\n   * @returns Return one of the two nodes, which the caller may consider as the start of the edge.\n   */\n  public addEdgeXY(x0: number, y0: number, x1: number, y1: number): HalfEdge {\n    const baseNode = HalfEdge.createEdgeXYXY(this._numNodesCreated, x0, y0, this._numNodesCreated + 1, x1, y1);\n    this._numNodesCreated += 2;\n    this.allHalfEdges.push(baseNode);\n    this.allHalfEdges.push(baseNode.faceSuccessor);\n    return baseNode;\n\n  }\n  /** Clear selected bits in all nodes of the graph. */\n  public clearMask(mask: HalfEdgeMask) {\n    for (const node of this.allHalfEdges)\n      node.maskBits &= ~mask;\n  }\n  /** Set selected bits in all nodes of the graph. */\n  public setMask(mask: HalfEdgeMask) {\n    for (const node of this.allHalfEdges)\n      node.maskBits |= mask;\n  }\n  /** toggle selected bits in all nodes of the graph. */\n  public reverseMask(mask: HalfEdgeMask) {\n    for (const node of this.allHalfEdges) {\n      node.maskBits ^= mask;\n    }\n  }\n  /**\n   * Return the number of nodes that have a specified mask bit set.\n   * @param mask mask to count\n   */\n  public countMask(mask: HalfEdgeMask): number {\n    let n = 0;\n    for (const node of this.allHalfEdges)\n      if (node.isMaskSet(mask))\n        n++;\n    return n;\n  }\n  /** Return an array LineSegment3d.\n   * * The array has one segment per edge\n   * * The coordinates are taken from a node and its face successor.\n   * * On each edge, the line segment start at the HalfEdge with lower id than its edgeMate.\n   */\n  public collectSegments(): LineSegment3d[] {\n    const segments: LineSegment3d[] = [];\n    for (const node of this.allHalfEdges) {\n      if (node.id < node.edgeMate.id)\n        segments.push(LineSegment3d.create(Point3d.create(node.x, node.y), Point3d.create(node.faceSuccessor.x, node.faceSuccessor.y)));\n    }\n    return segments;\n  }\n\n  /** Returns the number of vertex loops in a graph structure */\n  public countVertexLoops(): number {\n    this.clearMask(HalfEdgeMask.VISITED);\n    let count = 0;\n    this.announceVertexLoops((_graph: HalfEdgeGraph, _seed: HalfEdge) => { count++; return true; });\n    return count;\n  }\n\n  /** Returns the number of face loops */\n  public countFaceLoops(): number {\n    this.clearMask(HalfEdgeMask.VISITED);\n    let count = 0;\n    this.announceFaceLoops((_graph: HalfEdgeGraph, _seed: HalfEdge) => { count++; return true; });\n    return count;\n  }\n  /**\n   * Returns the number of face loops satisfying a filter function with mask argument.\n   *\n   */\n  public countFaceLoopsWithMaskFilter(filter: HalfEdgeAndMaskToBooleanFunction, mask: HalfEdgeMask): number {\n    this.clearMask(HalfEdgeMask.VISITED);\n    let count = 0;\n    this.announceFaceLoops((_graph: HalfEdgeGraph, seed: HalfEdge) => {\n      if (filter(seed, mask))\n        count++;\n      return true;\n    });\n    return count;\n  }\n\n  /** Returns an array of nodes, where each node represents a starting point of a face loop.\n   */\n  public collectFaceLoops(): HalfEdge[] {\n    const returnArray: HalfEdge[] = [];\n    this.announceFaceLoops(\n      (_graph: HalfEdgeGraph, node: HalfEdge) => { returnArray.push(node); return true; });\n    return returnArray;\n  }\n\n  /** Returns an array of nodes, where each node represents a starting point of a vertex loop.\n   */\n  public collectVertexLoops(): HalfEdge[] {\n    this.clearMask(HalfEdgeMask.VISITED);\n    const returnArray: HalfEdge[] = [];\n\n    for (const node of this.allHalfEdges) {\n      if (node.getMask(HalfEdgeMask.VISITED))\n        continue;\n      returnArray.push(node);\n      node.setMaskAroundVertex(HalfEdgeMask.VISITED);\n    }\n    return returnArray;\n  }\n\n  /**\n   * * Visit each facet of the graph once.\n   * * Call the announceFace function\n   * * continue search if announceFace(graph, node) returns true\n   * * terminate search if announce face (graph, node) returns false\n   * @param  announceFace function to apply at one node of each face.\n   */\n  public announceFaceLoops(announceFace: GraphNodeFunction) {\n    this.clearMask(HalfEdgeMask.VISITED);\n    for (const node of this.allHalfEdges) {\n      if (node.getMask(HalfEdgeMask.VISITED))\n        continue;\n      node.setMaskAroundFace(HalfEdgeMask.VISITED);\n      if (!announceFace(this, node))\n        break;\n    }\n  }\n\n  /**\n   * * Visit each vertex loop of the graph once.\n   * * Call the announceVertex function\n   * * continue search if announceFace(graph, node) returns true\n   * * terminate search if announce face (graph, node) returns false\n   * @param  announceVertex function to apply at one node of each face.\n   */\n  public announceVertexLoops(announceVertex: GraphNodeFunction) {\n    this.clearMask(HalfEdgeMask.VISITED);\n    for (const node of this.allHalfEdges) {\n      if (node.getMask(HalfEdgeMask.VISITED))\n        continue;\n      node.setMaskAroundVertex(HalfEdgeMask.VISITED);\n      if (!announceVertex(this, node))\n        break;\n    }\n  }\n  /** Return the number of nodes in the graph */\n  public countNodes(): number { return this.allHalfEdges.length; }\n  /** Apply transform to the xyz coordinates in the graph. */\n  public transformInPlace(transform: Transform) {\n    for (const node of this.allHalfEdges) {\n      transform.multiplyXYAndZInPlace(node);\n    }\n  }\n}\n// cspell:word CONSTU\n// cspell:word CONSTV\n// cspell:word USEAM\n// cspell:word VSEAM\n/**\n * * Each node of the graph has a mask member.\n * * The mask member is a number which is used as set of single bit boolean values.\n * * Particular meanings of the various bits are HIGHLY application dependent.\n *   * The EXTERIOR mask bit is widely used to mark nodes that are \"outside\" the active areas\n *   * The PRIMARY_EDGE bit is widely used to indicate linework created directly from input data, hence protected from triangle edge flipping.\n *   * The BOUNDARY bit is widely used to indicate that crossing this edge is a transition from outside to inside.\n *   * VISITED is used locally in many searches.\n *      * Never use VISITED unless the search logic is highly self contained.\n * @internal\n */\nexport enum HalfEdgeMask {\n  /**  Mask commonly set consistently around exterior faces.\n   * * A boundary edge with interior to one side, exterior to the other will have EXTERIOR only on the outside.\n   * * An an edge inserted \"within a purely exterior face\" can have EXTERIOR on both MediaStreamAudioDestinationNode[Symbol]\n   * * An interior edges (such as added during triangulation) will have no EXTERIOR bits.\n   */\n  EXTERIOR = 0x00000001,\n  /** Mask commonly set (on both sides) of original geometry edges that are transition from outside from to inside.\n   * * At the moment of creating an edge from primary user boundary loop coordinates, the fact that an edge is BOUNDARY is often clear even though\n   *  there is uncertainty about which side should be EXTERIOR.\n   */\n  BOUNDARY_EDGE = 0x00000002,\n  // REMARK: Various mask names are COMMENTED here for reference to native legacy code.\n  // CONSTU_MASK = 0x00000004,\n  // CONSTV_MASK = 0x00000008,\n  // USEAM_MASK = 0x00000010,\n  // VSEAM_MASK = 0x00000020,\n  // BOUNDARY_VERTEX_MASK = 0x00000040,\n  // PRIMARY_VERTEX_MASK = 0x00000080,\n  // DIRECTED_EDGE_MASK = 0x00000100,\n  /** Mask commonly set (on both sides) of original geometry edges, but NOT indicating that the edge is certainly a boundary between outside and inside.\n   * * For instance, if geometry is provided as stray sticks (not loops), it can be marked PRIMARY_EDGE but neither BOUNDARY_EDGE nor EXTERIOR_EDGE\n   */\n  PRIMARY_EDGE = 0x00000004,\n\n  /** Mask used for low level searches to identify previously-visited nodes */\n  VISITED = 0x0000010,\n\n  /** Mask applied to triangles by earcut triangulator */\n  TRIANGULATED_FACE = 0x00000100,\n  /** mask applied in a face with 2 edges. */\n  NULL_FACE = 0x00000200,\n\n  /** no mask bits */\n  NULL_MASK = 0x00000000,\n/** The \"upper 12 \" bits of 32 bit integer. */\n  ALL_GRAB_DROP_MASKS = 0xffF00000,  // 12 masks reserved for grab/drop.\n  /** all mask bits */\n  ALL_MASK = 0xFFFFFFFF,\n  // informal convention on preassigned mask bit numbers:\n  // byte0 (EXTERIOR, BOUNDARY_EDGE, PRIMARY_EDGE) -- edge properties\n  // byte1 (VISITED, VISIT_A, WORK_MASK0, WORK_MASK1) -- temp masks for algorithms.\n  // byte2 (TRIANGULATED_FACE, NULL_FACE) -- face properties.\n\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n\nimport { HalfEdge, HalfEdgeGraph, HalfEdgeMask } from \"./Graph\";\nimport { XYParitySearchContext } from \"./XYParitySearchContext\";\nimport { SignedDataSummary } from \"./SignedDataSummary\";\n/**\n * Interface for an object that executes boolean tests on edges.\n */\nexport interface HalfEdgeTestObject {\n  testEdge(h: HalfEdge): boolean;\n}\n/**\n */\nexport class HalfEdgeMaskTester {\n  private _targetMask: HalfEdgeMask;\n  private _targetValue: boolean;\n  /**\n   *\n   * @param mask mask to test in `testEdge` function\n   * @param targetValue value to match for true return\n   */\n  public constructor(mask: HalfEdgeMask, targetValue: boolean = true) {\n    this._targetMask = mask;\n    this._targetValue = targetValue;\n  }\n  /** Return true if the value of the targetMask matches the targetValue */\n  public testEdge(edge: HalfEdge): boolean {\n    return edge.isMaskSet(this._targetMask) === this._targetValue;\n  }\n\n}\n// Search services for HalfEdgeGraph\nexport class HalfEdgeGraphSearch {\n\n  /**\n   * * for each node of face, set the mask push to allNodesStack\n   * * push the faceSeed on onePerFaceStack[]\n   */\n  private static pushAndMaskAllNodesInFace(faceSeed: HalfEdge, mask: number, allNodeStack: HalfEdge[], onePerFaceStack: HalfEdge[]) {\n    onePerFaceStack.push(faceSeed);\n    faceSeed.collectAroundFace((node: HalfEdge) => {\n      node.setMask(mask);\n      allNodeStack.push(node);\n    });\n  }\n\n  /**\n   * Search an array of faceSeed nodes for the face with the most negative area.\n   * @param oneCandidateNodePerFace array containing one node from each face to be considered.\n   */\n  public static findMinimumAreaFace(oneCandidateNodePerFace: HalfEdgeGraph | HalfEdge[]): HalfEdge {\n    const summary = HalfEdgeGraphSearch.collectFaceAreaSummary (oneCandidateNodePerFace);\n    return summary.largestNegativeItem!;\n  }\n\n  /**\n   *\n   * Return a summary structure data about face areas.\n   */\n  public static collectFaceAreaSummary(source: HalfEdgeGraph | HalfEdge[], collectAllNodes: boolean = false): SignedDataSummary<HalfEdge> {\n    const result = new SignedDataSummary<HalfEdge>(collectAllNodes);\n    let allFaces: HalfEdge[];\n\n    if (source instanceof HalfEdgeGraph)\n      allFaces = source.collectFaceLoops();\n    else\n      allFaces = source;\n\n    for (const node of allFaces) {\n      const area = node.signedFaceArea();\n      result.announceItem(node, area);\n    }\n    return result;\n  }\n\n  /**\n   * Search to all accessible faces from given seed.\n   * * The returned array contains one representative node in each face of the connected component.\n   * * If (nonnull) parity mask is given, on return:\n   *    * It is entirely set or entirely clear around each face\n   *    * It is entirely set on all faces that are an even number of face-to-face steps away from the seed.\n   *    * It is entirely clear on all faces that are an odd number of face-to-face steps away from the seed.\n   * @param seedEdge first edge to search.\n   * @param visitMask mask applied to all faces as visited.\n   * @param parityMask mask to apply (a) to first face, (b) to faces with alternating parity during the search.\n   */\n  private static parityFloodFromSeed(seedEdge: HalfEdge, visitMask: HalfEdgeMask, parityEdgeTester: HalfEdgeTestObject | undefined, parityMask: HalfEdgeMask): HalfEdge[] {\n    const faces: HalfEdge[] = [];\n    if (seedEdge.isMaskSet(visitMask)) return faces; // empty\n\n    const allMasks = parityMask | visitMask;\n    const stack: HalfEdge[] = [];\n    // arbitrarily call the seed face exterior ... others will alternate as visited.\n    HalfEdgeGraphSearch.pushAndMaskAllNodesInFace(seedEdge, allMasks, stack, faces);  // Start with exterior as mask\n    while (stack.length > 0) {\n      const p = stack.pop()!;\n      const mate = p.edgeMate;\n      if (!mate)\n        continue;\n      if (!mate.isMaskSet(visitMask)) {\n        let newState = p.isMaskSet(parityMask);\n        if (!parityEdgeTester || parityEdgeTester.testEdge(p))\n          newState = !newState;\n        HalfEdgeGraphSearch.pushAndMaskAllNodesInFace(mate, newState ? allMasks : visitMask, stack, faces);\n      }\n    }\n    return faces;\n  }\n  /**\n   * * Search the given faces for the one with the minimum area.\n   * * If the mask in that face is OFF, toggle it on (all half edges of) all the faces.\n   * * In a properly merged planar subdivision there should be only one true negative area face per component.\n   * @param graph parent graph\n   * @param parityMask mask which was previously set with alternating parity, but with an arbitrary start face.\n   * @param faces array of faces to search.\n   */\n  private static correctParityInSingleComponent(_graph: HalfEdgeGraph, mask: HalfEdgeMask, faces: HalfEdge[]) {\n    const exteriorHalfEdge = HalfEdgeGraphSearch.findMinimumAreaFace(faces);\n    if (exteriorHalfEdge.isMaskSet(mask)) {\n      // all should be well .. nothing to do.\n    } else {\n      // TOGGLE around the face (assuming all are consistent with the seed)\n      for (const faceSeed of faces) {\n        if (faceSeed.isMaskSet(mask)) {\n          faceSeed.clearMaskAroundFace(mask);\n        } else {\n          faceSeed.setMaskAroundFace(mask);\n        }\n      }\n    }\n  }\n  /** Apply correctParityInSingleComponent to each array in components. (Quick exit if mask in NULL_MASK) */\n  private static correctParityInComponentArrays(graph: HalfEdgeGraph, mask: HalfEdgeMask, components: HalfEdge[][]) {\n    if (mask === HalfEdgeMask.NULL_MASK)\n      return;\n    for (const facesInComponent of components)\n      HalfEdgeGraphSearch.correctParityInSingleComponent(graph, mask, facesInComponent);\n  }\n  /**\n   * Collect arrays gathering faces by connected component.\n   * @param graph graph to inspect\n   * @param parityEdgeTester (optional) function to test of an edge is a parity change.\n   * @param parityMask (optional, along with boundaryTestFunction) mask to apply indicating parity.  If this is Mask.NULL_MASK, there is no record of parity.\n   */\n  public static collectConnectedComponentsWithExteriorParityMasks(graph: HalfEdgeGraph, parityEdgeTester: HalfEdgeTestObject | undefined, parityMask: HalfEdgeMask = HalfEdgeMask.NULL_MASK): HalfEdge[][] {\n    const components = [];\n    const visitMask = HalfEdgeMask.VISITED;\n    const allMasks = parityMask | visitMask;\n    graph.clearMask(allMasks);\n    for (const faceSeed of graph.allHalfEdges) {\n      if (!faceSeed.isMaskSet(HalfEdgeMask.VISITED)) {\n        const newFaces = HalfEdgeGraphSearch.parityFloodFromSeed(faceSeed, visitMask, parityEdgeTester, parityMask);\n        components.push(newFaces);\n      }\n    }\n    HalfEdgeGraphSearch.correctParityInComponentArrays(graph, parityMask, components);\n    return components;\n  }\n  /**\n   * Test if (x,y) is inside (1), on an edge (0) or outside (-1) a face.\n   * @param seedNode any node on the face loop\n   * @param x x coordinate of test point.\n   * @param y y coordinate of test point.\n   */\n  public static pointInOrOnFaceXY(seedNode: HalfEdge, x: number, y: number): number | undefined {\n    const context = new XYParitySearchContext(x, y);\n    // walk around looking for an accepted node to start the search (seedNode is usually ok!)\n    let nodeA = seedNode;\n    let nodeB = seedNode.faceSuccessor;\n    for (; ; nodeA = nodeB) {\n      if (context.tryStartEdge(nodeA.x, nodeA.y, nodeB.x, nodeB.y))\n        break;\n      if (nodeB === seedNode) {\n        // umm.. the face is all on the x axis?\n        return context.classifyCounts();\n      }\n      nodeB = nodeA.faceSuccessor;\n    }\n\n    // nodeB is the real start node for search ... emit ends of each edge around the face,\n    //   stopping after emitting nodeB as an edge end.\n    let node = nodeB.faceSuccessor;\n    for (; ;) {\n      if (!context.advance(node.x, node.y)) {\n        return context.classifyCounts();\n      }\n      if (node === nodeB)\n        break;\n      node = node.faceSuccessor;\n    }\n    return context.classifyCounts();\n  }\n}\n","import { HalfEdgeGraph, HalfEdgeMask, HalfEdge } from \"./Graph\";\n\n/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n/**\n * A class to manage a set of edges as both (a) an array of possible members and (b) mask bits.\n * * A half edge is \"in the MarkSet\" if its mask is set.\n * * The MarkSet array is a superset of the half edges in the set.\n * * Entry of a HalfEdge into the set is indicated by both\n *    * adding the HalfEdge to the array\n *    * setting the mask on the half edge, edge, face, or vertex\n * * Half edges can \"go out of the MarkSet\" if the mask is cleared.\n *   * This clearing can happen independently of the array management.\n *   * Hence the array can contain half edges that are no longer in the MarkSet\n *   * the \"remove\" methods monitor this.\n * * Derived classes expand this concept for edge, vertex, or face MarkSets.\n *   * a single representative of an edge, vertex, or face is entered to the array\n *   * all edges around the edge, vertex, or face are marked with the mask\n *   * Hence the array contains one or more representatives of the edge, face, or vertex\n * * This allows quick query for both:\n *   * Testing the mask gives constant time test of whether a HalfEdge is in the set\n *   * access through the array gives direct access to the HalfEdge pointers\n * @internal\n */\nexport abstract class AbstractHalfEdgeGraphMarkSet {\n  private _graph: HalfEdgeGraph;\n  private _candidates: HalfEdge[];\n  protected _mask: HalfEdgeMask;\n\n  protected constructor(graph: HalfEdgeGraph, mask: HalfEdgeMask) {\n    this._graph = graph;\n    this._candidates = [];\n    this._mask = mask;\n    this._graph.clearMask(mask);\n  }\n  /** remove all nodes from the set.\n   * * This pops from the array, clearing masks as the pop.\n   * * Note that it does NOT walk the entire graph to clear masks.\n   */\n  public clear() {\n    for (; undefined !== this.chooseAndRemoveAny();) {\n    }\n  }\n\n  /**\n   * count the number of active members.\n   * * This is the number of HalfEdges which are (a) in the array and (b) masked.\n   */\n  public getLength(): number {\n    let n = 0;\n    for (const candidate of this._candidates) {\n      if (candidate.isMaskSet(this._mask)) n++;\n    }\n    return n;\n  }\n  /**\n   * Return the number of candidates.\n   * * This may be more than `getLength ()`\n   * * This will typically only be called by the iterator.\n   */\n  public getNumCandidates(): number {\n    return this._candidates.length;\n  }\n  /** Read property accessor: return the graph */\n  public get graph(): HalfEdgeGraph { return this._graph; }\n\n  /** return borrowed assets (the mask!) to the graph. */\n  public teardown() {\n    this._graph.dropMask(this._mask);\n    this._candidates.length = 0;\n    // this._graph = undefined;\n  }\n  /** (Read property) return the mask used to mark members of the set. */\n  public get mask(): HalfEdgeMask { return this._mask; }\n\n  /** pop and return the last node out of the array, without testing if it is still marked. */\n  protected popAndReturn(): HalfEdge | undefined {\n    const n = this._candidates.length;\n    if (n === 0)\n      return undefined;\n    const node = this._candidates[n - 1];\n    this._candidates.pop();\n    return node;\n  }\n\n  /**\n   * * read at an index in the candidates array.\n   * * if that candidate has the mask, return it.\n   * * otherwise return undefined.\n   * * REMARK: This is only to be called by the iterator.\n   */\n  public getAtIndex(index: number): HalfEdge | undefined {\n    if (index >= 0 && index < this._candidates.length) {\n      const candidate = this._candidates[index];\n      if (candidate.isMaskSet(this._mask))\n        return candidate;\n    }\n    return undefined;\n  }\n\n  /** Add a node to the set.  This means\n   * * Set the mask\n   * * push the node on the array\n   * * (BUT!) If the node already has the mask, do nothing.\n   * * This base class method affects only the single given HalfEdge.\n   * * Derived classes for edge, face, and vertex will override this method and also set the mask around the larger structures.\n   * @returns true if the HalfEdge is a new member of the set, false if it was already in the set.\n   */\n  public addToSet(candidate: HalfEdge) {\n    if (candidate.isMaskSet(this._mask))\n      return false;\n    this._candidates.push(candidate);\n    this.setMaskInScope(candidate);\n    return true;\n  }\n  /** Test if `candidate` is already in the set.\n   * * This examines only the mask.\n   */\n  public isCandidateInSet(candidate: HalfEdge): boolean {\n    return candidate.isMaskSet(this._mask);\n  }\n  /**\n   * * If the candidate is not marked as a member of the MarkSet, do nothing.\n   * * If the candidate is marked:\n   *   * clear the mask\n   *   * but do NOT search the array.\n   *   * As the array is searched, the candidate will appear and be ignored because the mask is not set.\n   * @param candidate\n   * @return true if the candidate was a member (an hence removed), false if the candidate was not masked.\n   */\n  public removeFromSet(candidate: HalfEdge): boolean {\n    if (!candidate.isMaskSet(this._mask))\n      return false;\n    this.clearMaskInScope(candidate);\n    return true;\n  }\n  /**\n   *  * Search the array to find any current set member\n   *  * If found, clear its mask and return it.\n   *  * If unmasked HalfEdges are found in the array, they are removed from the array.\n   */\n  public chooseAndRemoveAny(): HalfEdge | undefined {\n    for (; ;) {\n      const candidate = this.popAndReturn();\n      if (!candidate)\n        return undefined;\n      if (this.removeFromSet(candidate))\n        return candidate;\n    }\n  }\n  /** Set mask on candidate -- i.e. edge, face, vertex, or single half edge as required.\n   * * Base class only changes the candidate mask.\n   * * Derived classes change more masks around edge, face, or vertex.\n   */\n  protected abstract setMaskInScope(candidate: HalfEdge | undefined): void;\n\n  /** Clear mask on candidate -- i.e. edge, face, vertex, or single half edge as required.\n   * * Base class only changes the candidate mask.\n   * * Derived classes change more masks around edge, face, or vertex.\n   */\n  protected abstract clearMaskInScope(candidate: HalfEdge | undefined): void;\n  /**\n   * Return the number of half edges that would be set/cleared when dealing with this candidate.\n   * * This is always 1 for HalfEdgeMarkSet\n   * @param candidate\n   */\n  public abstract countHalfEdgesAroundCandidate(candidate: HalfEdge | undefined): number;\n  /** Create an iterator over member HalfEdges */\n  public [Symbol.iterator](): IterableIterator<HalfEdge> { return new IterableHalfEdgeMarkSetIterator(this); }\n  /**\n   * * visit all half edges around face.\n   * * Add each to mark set.\n   */\n  public addAroundFace(seed: HalfEdge): void {\n    let p = seed;\n    do {\n      this.addToSet(p);\n      p = p.faceSuccessor;\n    } while (p !== seed);\n  }\n\n  /**\n   * * visit all half edges around vertex.\n   * * Add each to mark set.\n   */\n  public addAroundVertex(seed: HalfEdge): void {\n    let p = seed;\n    do {\n      this.addToSet(p);\n      p = p.vertexSuccessor;\n    } while (p !== seed);\n  }\n}\n\n/**\n * AbstractHalfEdgeGraphMarkSet specialized to manage the masks on individual half edges\n * @internal\n */\nexport class MarkedHalfEdgeSt extends AbstractHalfEdgeGraphMarkSet {\n  constructor(graph: HalfEdgeGraph, mask: HalfEdgeMask) {\n    super(graph, mask);\n  }\n  /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.\n   * * Returns undefined if unable to get a mask for the graph.\n   * * Undefined return can only happen if the caller is failing to return grabbed masks.\n   */\n  public static create(graph: HalfEdgeGraph): MarkedHalfEdgeSt | undefined {\n    const mask = graph.grabMask();\n    if (mask === HalfEdgeMask.NULL_MASK)\n      return undefined;\n    return new MarkedHalfEdgeSt(graph, mask);\n  }\n\n  /**\n   * * Set mask on candidate's edge.\n   * * This overrides the base class implementation.\n   */\n  protected setMaskInScope(candidate: HalfEdge) {\n    candidate.setMask(this._mask);\n  }\n\n  /**\n   * * Clear mask on candidate's edge.\n   * * This overrides the base class implementation.\n   */\n  protected clearMaskInScope(candidate: HalfEdge) {\n    candidate.clearMask(this._mask);\n  }\n  /**\n   * Return the number of half edges that would be set/cleared when dealing with this candidate.\n   * * This is always 1 for EdgeMarkSet\n   * * return 0 for undefined candidate\n   * @param candidate\n   */\n  public countHalfEdgesAroundCandidate(candidate: HalfEdge | undefined): number {\n    if (!candidate)\n      return 0;\n    return 1;\n  }\n}\n\n/**\n * AbstractHalfEdgeGraphMarkSet specialized to manage the mask on both sides of edges.\n * @internal\n */\nexport class MarkedEdgeSet extends AbstractHalfEdgeGraphMarkSet {\n  constructor(graph: HalfEdgeGraph, mask: HalfEdgeMask) {\n    super(graph, mask);\n  }\n  /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.\n   * * Returns undefined if unable to get a mask for the graph.\n   * * Undefined return can only happen if the caller is failing to return grabbed masks.\n   */\n  public static create(graph: HalfEdgeGraph): MarkedEdgeSet | undefined {\n    const mask = graph.grabMask();\n    if (mask === HalfEdgeMask.NULL_MASK)\n      return undefined;\n    return new MarkedEdgeSet(graph, mask);\n  }\n\n  /**\n   * * Set mask on candidate's edge.\n   * * This overrides the base class implementation.\n   */\n  protected setMaskInScope(candidate: HalfEdge) {\n    candidate.setMaskAroundEdge(this._mask);\n  }\n\n  /**\n   * * Clear mask on candidate's edge.\n   * * This overrides the base class implementation.\n   */\n  protected clearMaskInScope(candidate: HalfEdge) {\n    candidate.clearMaskAroundEdge(this._mask);\n  }\n  /**\n   * Return the number of half edges that would be set/cleared when dealing with this candidate.\n   * * This is always 2 for EdgeMarkSet\n   * @param candidate\n   */\n  public countHalfEdgesAroundCandidate(candidate: HalfEdge | undefined): number {\n    if (!candidate)\n      return 0;\n    return 2;\n  }\n}\n\n/**\n * AbstractHalfEdgeGraphMarkSet specialized to manage the mask around faces\n * @internal\n */\nexport class MarkedFaceSet extends AbstractHalfEdgeGraphMarkSet {\n  constructor(graph: HalfEdgeGraph, mask: HalfEdgeMask) {\n    super(graph, mask);\n  }\n  /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.\n   * * Returns undefined if unable to get a mask for the graph.\n   * * Undefined return can only happen if the caller is failing to return grabbed masks.\n   */\n  public static create(graph: HalfEdgeGraph): MarkedFaceSet | undefined {\n    const mask = graph.grabMask();\n    if (mask === HalfEdgeMask.NULL_MASK)\n      return undefined;\n    return new MarkedFaceSet(graph, mask);\n  }\n\n  /**\n   * * Set mask on (all nodes around) candidate's face\n   * * This overrides the base class implementation.\n   */\n  protected setMaskInScope(candidate: HalfEdge) {\n    candidate.setMaskAroundFace(this._mask);\n  }\n\n  /**\n   * * Clear mask on (all nodes around) candidate's face.\n   * * This overrides the base class implementation.\n   */\n  protected clearMaskInScope(candidate: HalfEdge) {\n    candidate.clearMaskAroundFace(this._mask);\n  }\n  /**\n   * Return the number of half edges that would be set/cleared when dealing with this candidate.\n   * * This is the \"aroundFace\" count.\n   * @param candidate\n   */\n  public countHalfEdgesAroundCandidate(candidate: HalfEdge | undefined): number {\n    if (!candidate)\n      return 0;\n    return candidate.countEdgesAroundFace();\n  }\n}\n/**\n * AbstractHalfEdgeGraphMarkSet specialized to manage the mask around faces\n * @internal\n */\nexport class MarkedVertexSet extends AbstractHalfEdgeGraphMarkSet {\n  constructor(graph: HalfEdgeGraph, mask: HalfEdgeMask) {\n    super(graph, mask);\n  }\n  /** Create a new 'HalfEdgeMarkSet', operating on half edges with only themselves as scope.\n   * * Returns undefined if unable to get a mask for the graph.\n   * * Undefined return can only happen if the caller is failing to return grabbed masks.\n   */\n  public static create(graph: HalfEdgeGraph): MarkedVertexSet | undefined {\n    const mask = graph.grabMask();\n    if (mask === HalfEdgeMask.NULL_MASK)\n      return undefined;\n    return new MarkedVertexSet(graph, mask);\n  }\n\n  /**\n   * * Set mask on (all nodes around) candidate's face\n   * * This overrides the base class implementation.\n   */\n  protected setMaskInScope(candidate: HalfEdge) {\n    candidate.setMaskAroundVertex(this._mask);\n  }\n\n  /**\n   * * Clear mask on (all nodes around) candidate's face.\n   * * This overrides the base class implementation.\n   */\n  protected clearMaskInScope(candidate: HalfEdge) {\n    candidate.clearMaskAroundVertex(this._mask);\n  }\n  /**\n   * Return the number of half edges that would be set/cleared when dealing with this candidate.\n   * * This is the \"aroundVertex\" count.\n   * @param candidate\n   */\n  public countHalfEdgesAroundCandidate(candidate: HalfEdge | undefined): number {\n    if (!candidate)\n      return 0;\n    return candidate.countEdgesAroundVertex();\n  }\n}\n\n/**\n * Class to act as an iterator over points in a markSet.\n * * Internal data is:\n *   * pointer to the parent markSet\n *   * index of index of the next point to read.\n * * the parent markSet class\n */\nclass IterableHalfEdgeMarkSetIterator implements Iterator<HalfEdge> {\n  private _markSet: AbstractHalfEdgeGraphMarkSet;\n  private _nextReadIndex: number;\n  public constructor(markSet: AbstractHalfEdgeGraphMarkSet) {\n    this._markSet = markSet;\n    this._nextReadIndex = 0;\n  }\n  public next(): IteratorResult<HalfEdge> {\n    const n = this._markSet.getNumCandidates();\n    // Walk over candidates that have been quietly de-masked\n    while (this._nextReadIndex < n) {\n      const p = this._markSet.getAtIndex(this._nextReadIndex++);\n      if (p !== undefined)\n        return { done: false, value: p };\n    }\n    return { done: true, value: undefined } as any as IteratorResult<HalfEdge>;\n  }\n\n  public [Symbol.iterator](): IterableIterator<HalfEdge> { return this; }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { HalfEdge } from \"./Graph\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\n\r\n/** @module Topology */\r\n/**\r\n * Reference to a HalfEdge node with extra XYZ and UV data.\r\n * @internal\r\n */\r\nexport class NodeXYZUV {\r\n  private _node: HalfEdge;\r\n  private _x: number;\r\n  private _y: number;\r\n  private _z: number;\r\n  private _u: number;\r\n  private _v: number;\r\n\r\n  private constructor(node: HalfEdge, x: number, y: number, z: number, u: number, v: number) {\r\n    this._x = x; this._y = y; this._z = z;\r\n    this._u = u; this._v = v;\r\n    this._node = node;\r\n  }\r\n  /** Set all content directly from args.\r\n   * @returns `this` reference\r\n   */\r\n  public set(node: HalfEdge, x: number, y: number, z: number, u: number, v: number): NodeXYZUV {\r\n    this._x = x; this._y = y; this._z = z;\r\n    this._u = u; this._v = v;\r\n    this._node = node;\r\n    return this;\r\n  }\r\n\r\n  public setFrom(other: NodeXYZUV) {\r\n    this._x = other.x; this._y = other.y; this._z = other.z;\r\n    this._u = other.u; this._v = other.v;\r\n    this._node = other.node;\r\n\r\n  }\r\n  /** Create a `NodeXYZUV` with\r\n   * * x,y,z at ray origin\r\n   * * u,v as dotXY and crossXY for the ray direction with x,y distances from the ray origin.\r\n   */\r\n  public static createNodeAndRayOrigin(node: HalfEdge, ray: Ray3d, result?: NodeXYZUV): NodeXYZUV {\r\n    const x = node.x;\r\n    const y = node.y;\r\n    const z = node.z;\r\n    const dx = x - ray.origin.x;\r\n    const dy = y - ray.origin.y;\r\n    const u = Geometry.dotProductXYXY(dx, dy, ray.direction.x, ray.direction.y);\r\n    const v = Geometry.crossProductXYXY(ray.direction.x, ray.direction.y, dx, dy);\r\n    if (result)\r\n      return result.set(node, x, y, z, u, v);\r\n    return new NodeXYZUV(node, x, y, z, u, v);\r\n  }\r\n\r\n  /** Access the node. */\r\n  public get node(): HalfEdge { return this._node; }\r\n  /** Access the x coordinate */\r\n  public get x(): number { return this._x; }\r\n  /** Access the y coordinate */\r\n  public get y(): number { return this._y; }\r\n  /** Access the z coordinate */\r\n  public get z(): number { return this._z; }\r\n  /** Access the u coordinate */\r\n  public get u(): number { return this._u; }\r\n  /** Access the v coordinate */\r\n  public get v(): number { return this._v; }\r\n  /** Access the x,y,z coordinates as Point3d with optional caller-supplied result. */\r\n  public getXYZAsPoint3d(result?: Point3d): Point3d {\r\n    return Point3d.create(this._x, this._y, this._z, result);\r\n  }\r\n  /** Access the uv coordinates as Point2d with optional caller-supplied result. */\r\n  public getUVAsPoint2d(result?: Point2d): Point2d { return Point2d.create(this._u, this._v, result); }\r\n\r\n  /** Toleranced comparison function for u coordinate */\r\n  public classifyU(target: number, tol: number): number {\r\n    const delta = this.u - target;\r\n    if (Math.abs(delta) <= tol)\r\n      return 0;\r\n    return delta >= 0 ? 1 : -1;\r\n  }\r\n\r\n  /** Toleranced comparison function for v coordinate */\r\n  public classifyV(target: number, tol: number): number {\r\n    const delta = target - this._v;\r\n    if (Math.abs(delta) <= tol)\r\n      return 0;\r\n    return delta >= 0 ? 1 : -1;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n\nimport { HalfEdge } from \"./Graph\";\nimport { Geometry } from \"../Geometry\";\nimport { HalfEdgePositionDetail } from \"./HalfEdgePositionDetail\";\nimport { NodeXYZUV } from \"./HalfEdgeNodeXYZUV\";\nimport { Ray3d } from \"../geometry3d/Ray3d\";\nimport { Vector3d, Point3d } from \"../geometry3d/Point3dVector3d\";\n\nexport enum RayClassification {\n  RC_NoHits,\n  RC_TargetOnVertex,\n  RC_TargetOnEdge,\n  RC_Bracket,\n  RC_TargetBefore,\n  RC_TargetAfter,\n}\n\nexport class PointSearchContext {\n  private _tol: number;\n  private constructor(tol: number) {\n    this._tol = tol;\n  }\n  public static create(tol: number = Geometry.smallMetricDistance) {\n    return new PointSearchContext(tol);\n  }\n  private panic(): HalfEdgePositionDetail {\n    return HalfEdgePositionDetail.create();\n  }\n  // From given edge start point\n  // The edgeHit is reused as the result.\n  public reAimFromEdge\n    (\n      edgeHit: HalfEdgePositionDetail,\n      ray: Ray3d,\n      targetDistance: number): HalfEdgePositionDetail {\n    const nodeA = edgeHit.node!;\n    const dataA = NodeXYZUV.createNodeAndRayOrigin(nodeA, ray);\n    const dataB = NodeXYZUV.createNodeAndRayOrigin(nodeA.edgeMate, ray);\n    const sideA = -dataA.classifyV(0.0, this._tol);\n    const sideB = -dataB.classifyV(0.0, this._tol);\n    let result;\n    if (sideA * sideB < 0) {\n      // Simple crossing -- just aim into a face\n      if (sideA > 0) {\n        result = edgeHit.resetAsFace(dataA.node);\n      } else {\n        result = edgeHit.resetAsFace(dataB.node);\n      }\n    } else if (sideA === 0 || sideB === 0) {\n      // The usual case is both 0 i.e. ray is clearly along the edge.\n\n      const alongA = dataA.classifyU(targetDistance, this._tol);\n      const alongB = dataB.classifyU(targetDistance, this._tol);\n      if (alongA === 0 && sideA === 0) {\n        result = edgeHit.resetAsVertex(dataA.node);\n        result.setITag(1);\n      } else if (alongB === 0 && sideB === 0) {\n        result = edgeHit.resetAsVertex(dataB.node);\n        result.setITag(1);\n      } else if (alongA * alongB < 0) {\n        // target is within edge\n        // (.. This is written for the case where both sideA and sideB are zero.\n        //    If only one is zero, this computes a close edge point but the strong \"on\" conclusion might be wrong)\n\n        const edgeFraction = (targetDistance - dataA.u) / (dataB.u - dataA.u);\n        result = edgeHit.resetAtEdgeAndFraction(dataA.node, edgeFraction);\n        result.setITag(1);\n      } else if (alongA < 0 && alongB < 0) {\n        // target is beyond the edge -- move towards it.\n        if (dataA.u > dataB.u)\n          result = edgeHit.resetAsVertex(dataA.node);\n          else\n          result = edgeHit.resetAsVertex(dataB.node);\n      } else {\n        // This shouldn't happen -- maybe as if the initial edge point was not within the edge???\n        if (Math.abs(dataA.u) < this._tol\n          && Math.abs(dataA.v) < this._tol\n        ) {\n          result = edgeHit.resetAsVertex(dataA.node); // , dataA);\n        } else if (Math.abs(dataB.u) < this._tol\n          && Math.abs(dataB.v) < this._tol\n        ) {\n          result = edgeHit.resetAsVertex(dataB.node);\n        } else {\n          edgeHit.resetAsUnknown ();\n          result = this.panic();\n        }\n      }\n    } else {\n      // Both vertices are to same side of the line.   This can't happen for edge point between nodes.\n      edgeHit.resetAsUnknown ();\n      result = this.panic();\n    }\n    return result;\n  }\n\n  // From given edge start point, pick vertex or edge side for proceeding along ray.\n  // RAY IS ASSUMED TO START AT THE VERTEX PRECISELY !!!!\n  public reAimFromVertex\n    (\n      searchBase: HalfEdgePositionDetail,\n      ray: Ray3d,\n      targetDistance: number): HalfEdgePositionDetail {\n    const vertexNode = searchBase.node;\n    let result;\n    let outboundEdge = vertexNode!;\n    do {\n      // DPoint3d xyzBase;\n      // vu_getDPoint3d(& xyzBase, outboundEdge);\n      const data0 = NodeXYZUV.createNodeAndRayOrigin(outboundEdge.faceSuccessor, ray);\n      const data1 = NodeXYZUV.createNodeAndRayOrigin(outboundEdge.facePredecessor, ray);\n      const u0 = data0.u;\n      // double u1 = data1.GetU ();\n      const v0 = data0.v;\n      const v1 = data1.v;\n      if (Math.abs(v0) < this._tol) {\n        if (Math.abs(u0 - targetDistance) < this._tol) {\n          // Direct hit at far end\n          result = searchBase.resetAsVertex(data0.node);\n          result.setITag(1);\n          return result;\n        } else if (u0 > targetDistance) {\n          // Direct hig within edge\n          const edgeFraction = targetDistance / u0;\n          result = searchBase.resetAtEdgeAndFraction(outboundEdge, edgeFraction);\n          return result;\n        } else if (Math.abs(u0) <= this._tol) {\n          // Unexpected direct hit on the base of the search, but call it a hit....\n          result = searchBase.resetAsVertex(outboundEdge);\n          result.setITag(1);\n          return result;\n        } else if (u0 > this._tol) {\n          // Advance to vertex  ...\n          // double edgeFraction = targetDistance / u0;\n          result = searchBase.resetAsVertex(data0.node);\n          return result;\n        } else {\n          // Search direction is exactly opposite this edge.\n          // See if the other side of the sector is turned even beyond that ...\n          if (v1 > this._tol) {\n            result = searchBase.resetAsFace(outboundEdge, outboundEdge);\n            return result;\n          }\n        }\n      } else if (v0 < -this._tol) {\n        if (v1 > this._tol) {\n          // The usual simple entry into an angle < 180\n          result = searchBase.resetAsFace(outboundEdge, outboundEdge);\n          return result;\n        }\n      }\n      // NEEDS WORK: angle >= 180 cases !!!!\n      outboundEdge = outboundEdge.vertexSuccessor;\n    } while (outboundEdge !== vertexNode);\n    return this.panic();\n  }\n\n  // Visit all edges around face.\n  // reset lastBefore and firstAfter describing progress towards target distance on ray.\n  public reAimAroundFace\n    (\n      faceNode: HalfEdge,\n      ray: Ray3d,\n      targetDistance: number,  // !< distance to target point\n      lastBefore: HalfEdgePositionDetail,   // CALLER CREATED -- reset as first hit on negative side of ray.\n      firstAfter: HalfEdgePositionDetail): RayClassification {  // ! CALLER CREATED -- reset as first hit on positive side of ray.\n    lastBefore.resetAsUndefinedWithTag(-Number.MAX_VALUE);\n    firstAfter.resetAsUndefinedWithTag(Number.MAX_VALUE);\n    const data0 = NodeXYZUV.createNodeAndRayOrigin(faceNode, ray);\n    let data1;\n    let node0 = faceNode;\n    do {\n      const node1 = node0.faceSuccessor;\n      data1 = NodeXYZUV.createNodeAndRayOrigin(node1, ray, data1);\n      const u0 = data0.u;\n      const u1 = data1.u;\n      const v0 = data0.v;\n      const v1 = data1.v;\n      if (Math.abs(v1) < this._tol) {\n        // Vertex hit ...\n        const vertexHit = HalfEdgePositionDetail.createVertex(node1);\n        vertexHit.setDTag(u1);\n        if (Math.abs(u1 - targetDistance) < this._tol) {\n          firstAfter.setFrom(vertexHit);\n          lastBefore.setFrom(vertexHit);\n          return RayClassification.RC_TargetOnVertex;\n        }\n        if (u1 > targetDistance && u1 < firstAfter.getDTag()!)\n          firstAfter.setFrom(vertexHit);\n        if (u1 < targetDistance && u1 > lastBefore.getDTag()!)\n          lastBefore.setFrom(vertexHit);\n      } else if (v0 * v1 < 0.0) {\n        // Edge Crossing ...\n        const edgeFraction = - v0 / (v1 - v0);\n        const uEdge = Geometry.interpolate(u0, edgeFraction, u1);\n        const edgeHit = HalfEdgePositionDetail.createEdgeAtFraction(data0.node, edgeFraction);\n        edgeHit.setDTag(uEdge);\n        if (Math.abs(uEdge - targetDistance) <= this._tol) {\n          firstAfter.setFrom(edgeHit);\n          lastBefore.setFrom(edgeHit);\n          return RayClassification.RC_TargetOnEdge;\n        }\n        if (uEdge > targetDistance && uEdge < firstAfter.getDTag()!) {\n          firstAfter.setFrom(edgeHit);\n          firstAfter.setITag(v0 > 0.0 ? -1 : 1);\n        }\n        if (uEdge < targetDistance && uEdge > lastBefore.getDTag()!) {\n          lastBefore.setFrom(edgeHit);\n          lastBefore.setDTag(uEdge);\n        }\n      }\n      data0.setFrom(data1);\n      node0 = node0.faceSuccessor;\n    } while (node0 !== faceNode);\n\n    const afterTag = firstAfter.getITag();\n    firstAfter.setITag(0);\n    lastBefore.setITag(0);\n    if (lastBefore.isUnclassified) {\n      if (firstAfter.isUnclassified)\n        return RayClassification.RC_NoHits;\n      return RayClassification.RC_TargetBefore;\n    }\n    if (firstAfter.isUnclassified\n      || (firstAfter.isEdge && afterTag && afterTag < 0)) {\n      return RayClassification.RC_TargetAfter;\n    } else {\n      return RayClassification.RC_Bracket;\n    }\n  }\n\n  // Return false if target is reached !!!!\n  /**\n   * Set (replace contents) ray with\n   * * `origin` at start\n   * * `direction` is unit vector from start towards target\n   * * `a` is distance from start to target.\n   * @param start existing position\n   * @param target target xy coordinates\n   * @param ray ray to update\n   */\n  public setSearchRay(start: HalfEdgePositionDetail, target: Point3d, ray: Ray3d): boolean {\n    ray.origin.setFromPoint3d(start);\n    Vector3d.createStartEnd(ray.origin, target, ray.direction);\n    ray.direction.z = 0.0;\n    const distanceToTarget = ray.direction.magnitudeXY();\n    ray.a = ray.direction.magnitude();\n    ray.direction.scaleInPlace(1 / ray.a);\n    return distanceToTarget >= this._tol;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { HalfEdge } from \"./Graph\";\r\nimport { XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\n\r\n/** @module Topology */\r\n/**\r\n * Enumeration of categorization of \"where\" a HalfEdgePositionDetail is sitting in the graph.\r\n */\r\nexport enum HalfEdgeTopo {\r\n  /** No known position */\r\n  None = 0,\r\n  /**  */\r\n  Vertex = 1,\r\n  Edge = 2,\r\n  Face = 3,\r\n}\r\n/**\r\n * Description of a generalized position within a graph, categorized as:\r\n * * \"at a certain node around a vertex\"\r\n * * \"at a fractional position along an edge\r\n * * \"within a face\"\r\n */\r\nexport class HalfEdgePositionDetail {\r\n  /** the relevant node */\r\n  private _node?: HalfEdge;\r\n  /** The current coordinates */\r\n  public x: number;\r\n  public y: number;\r\n  public z: number;\r\n  /** fractional position along edge.   Only defined if the topo tag is `HalfEdgeTopo.Edge` */\r\n  private _edgeFraction?: number;\r\n  /** Enumeration of status vertex, edge, or face status. */\r\n  private _topo: HalfEdgeTopo;\r\n  /** first data tag */\r\n  private _iTag?: number;\r\n  /** second data tag */\r\n  private _dTag?: number;\r\n  /** Constructor.\r\n   * * The point is CAPTURED.  (static `create` methods normally clone their inputs.)\r\n   */\r\n  private constructor(node: HalfEdge | undefined, x: number, y: number, z: number, topo: HalfEdgeTopo, edgeFraction?: number, iTag?: number, _dTag?: number) {\r\n    this._node = node;\r\n    this.x = x; this.y = y; this.z = z;\r\n    this._topo = topo;\r\n    this._edgeFraction = edgeFraction;\r\n    this._iTag = iTag;\r\n    this._dTag = _dTag;\r\n  }\r\n\r\n  /** Copy (clones of) all data from other */\r\n  public setFrom(other: HalfEdgePositionDetail) {\r\n    this._node = other._node;\r\n    this.x = other.x;\r\n    this.y = other.y;\r\n    this.z = other.z;\r\n    this._topo = other._topo;\r\n    this._edgeFraction = other._edgeFraction;\r\n    this._iTag = other._iTag;\r\n    this._dTag = other._dTag;\r\n  }\r\n  /** reset to null topo state. */\r\n  public resetAsUnknown() {\r\n    this._node = undefined;\r\n    this._topo = HalfEdgeTopo.None;\r\n  }\r\n  /**  Create with null data. */\r\n  public static create(): HalfEdgePositionDetail {\r\n    const detail = new HalfEdgePositionDetail(undefined, 0, 0, 0, HalfEdgeTopo.None);\r\n    return detail;\r\n  }\r\n  public getITag(): number | undefined { return this._iTag; }\r\n  public setITag(value: number): void { this._iTag = value; }\r\n\r\n  public getDTag(): number | undefined { return this._dTag; }\r\n  public setDTag(value: number): void { this._dTag = value; }\r\n  public getTopo(): HalfEdgeTopo { return this._topo; }\r\n\r\n  /** Create with node, fraction along edge, marked as \"HalfEdgeTopo.Edge\".  Compute interpolated xyz on the edge */\r\n  public static createEdgeAtFraction(node: HalfEdge, edgeFraction: number): HalfEdgePositionDetail {\r\n    const node1 = node.faceSuccessor;\r\n    const x = Geometry.interpolate(node.x, edgeFraction, node1.x);\r\n    const y = Geometry.interpolate(node.y, edgeFraction, node1.y);\r\n    const z = Geometry.interpolate(node.z, edgeFraction, node1.z);\r\n    return new HalfEdgePositionDetail(node, x, y, z, HalfEdgeTopo.Edge, edgeFraction);\r\n  }\r\n\r\n  /** reassign contents so this instance becomes a face hit.\r\n   * @param node new node value. If missing, current node is left unchanged.\r\n   * @param xyz new coordinates. if missing, current coordinates are left unchanged.\r\n   */\r\n  public resetAsFace(node?: HalfEdge, xyz?: XYAndZ): HalfEdgePositionDetail {\r\n    this._topo = HalfEdgeTopo.Face;\r\n    if (node)\r\n      this._node = node;\r\n    if (xyz) {\r\n      this.x = xyz.x;\r\n      this.y = xyz.y;\r\n      this.z = xyz.z;\r\n    }\r\n    return this;\r\n  }\r\n\r\n  /** reassign contents so this instance has dTag but no node or HalfEdgeTopo\r\n   */\r\n  public resetAsUndefinedWithTag(dTag: number): HalfEdgePositionDetail {\r\n    this._topo = HalfEdgeTopo.None;\r\n    this._dTag = 0;\r\n    this._iTag = 0;\r\n    this._dTag = dTag;\r\n    this._node = undefined;\r\n    return this;\r\n  }\r\n\r\n  /** reassign contents so this instance becomes an edge hit\r\n   * @param node new node value.\r\n   * @param edgeFraction new edge fraction.   xyz is recomputed from this edge and its face successor.\r\n   */\r\n  public resetAtEdgeAndFraction(node: HalfEdge, edgeFraction: number): HalfEdgePositionDetail {\r\n    this._topo = HalfEdgeTopo.Edge;\r\n    this._node = node;\r\n    const nodeB = node.faceSuccessor;\r\n    this._edgeFraction = edgeFraction;\r\n    this.x = Geometry.interpolate(node.x, edgeFraction, nodeB.x);\r\n    this.y = Geometry.interpolate(node.y, edgeFraction, nodeB.y);\r\n    this.z = Geometry.interpolate(node.z, edgeFraction, nodeB.z);\r\n    return this;\r\n  }\r\n\r\n  /** Create at a node.\r\n   * * Take xyz from the node.\r\n   */\r\n  public static createVertex(node: HalfEdge): HalfEdgePositionDetail {\r\n    return new HalfEdgePositionDetail(node, node.x, node.y, node.z, HalfEdgeTopo.Vertex);\r\n  }\r\n\r\n  /** Create with node and (optional) xyz, marked as \"HalfEdgeTopo.Vertex\"\r\n   * * if the xyz is omitted, take from the node.\r\n   */\r\n  public resetAsVertex(node: HalfEdge): HalfEdgePositionDetail {\r\n    this._topo = HalfEdgeTopo.Vertex;\r\n    this._node = node;\r\n    this.setXYZFromNode(node);\r\n    return this;\r\n  }\r\n  /** Copy x,y,z from the node to this instance local values. */\r\n  public setXYZFromNode(node: HalfEdge) {\r\n    this.x = node.x;\r\n    this.y = node.y;\r\n    this.z = node.z;\r\n  }\r\n  /**\r\n   * Return the (possibly undefined) edge fraction.\r\n   */\r\n  public get edgeFraction(): number | undefined {\r\n    return this._edgeFraction;\r\n  }\r\n\r\n  /** Return true if this detail is marked as being within a face. */\r\n  public get isFace(): boolean { return this._topo === HalfEdgeTopo.Face; }\r\n  /** Return true if this detail is marked as being within an edge. */\r\n  public get isEdge(): boolean { return this._topo === HalfEdgeTopo.Edge; }\r\n  /** Return true if this detail is marked as being at a vertex. */\r\n  public get isVertex(): boolean { return this._topo === HalfEdgeTopo.Vertex; }\r\n  /** Return true if this detail has no vertex, edge, or face qualifier. */\r\n  public get isUnclassified(): boolean { return this._topo === HalfEdgeTopo.None; }\r\n\r\n  /** Return the node reference from this detail */\r\n  public get node(): HalfEdge | undefined { return this._node; }\r\n  /** Return the (clone of, or optional filled in result) coordinates from this detail. */\r\n  public clonePoint(result?: Point3d): Point3d { return Point3d.create(this.x, this.y, this.z, result); }\r\n\r\n  /*\r\n    // If candidateKey is less than resultKey, replace resultPos and resultKey\r\n    // by the candidate data.\r\n    public updateMinimizer(\r\n      HalfEdgePositionDetail & resultPos, number & resultKey,\r\n  : HalfEdgePositionDetail & candidatePos, candidateKey: number\r\n    ): boolean {\r\n      if (candidateKey < resultKey) {\r\n        resultKey = candidateKey;\r\n        resultPos = candidatePos;\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n  */\r\n\r\n  public isAtXY(x: number, y: number): boolean {\r\n    return this._topo !== HalfEdgeTopo.None && Geometry.isSameCoordinate(this.x, x) && Geometry.isSameCoordinate(this.y, y);\r\n\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\nimport { PriorityQueue, OrderedComparator } from \"@bentley/bentleyjs-core\";\nimport { HalfEdge } from \"./Graph\";\nimport { HalfEdgeGraphOps } from \"./Merging\";\n\n/**\n * * Combination of a priority queue of HalfEdges with\n * * Additional \"active\" array to carry edges that have been removed from the queue but are still to be\n *    inspected (possibly many times)\n * * The priority queue default sort is Y-then-X lexical sort.\n * * Caller has direct access to the queue and array.\n * * Methods are added here only to do things that involve both the queue and the array.\n * @internal\n */\nexport class HalfEdgePriorityQueueWithPartnerArray {\n  public priorityQueue: PriorityQueue<HalfEdge>;\n  public activeEdges: HalfEdge[];\n  public constructor(\n    compare: OrderedComparator<HalfEdge> = HalfEdgeGraphOps.compareNodesYXUp) {\n    this.priorityQueue = new PriorityQueue(compare);\n    this.activeEdges = [];\n  }\n  /** Read a member from the queue and transfer to the active array. */\n  public popQueueToArray(): HalfEdge | undefined {\n    if (this.priorityQueue.isEmpty)\n      return undefined;\n    const x = this.priorityQueue.pop()!;\n    this.activeEdges.push(x);\n    return x;\n  }\n  /** Pop the last entry and put it back as replacement for current entry at index i.\n   * * Effectively remove active member at index i\n   * * The array order is changed.\n   * * constant time.\n   */\n  public popArrayToArrayIndex(i: number) {\n    const n = this.activeEdges.length;\n    if (i < n) {\n      const x = this.activeEdges.pop()!;\n      this.activeEdges[i] = x;\n    }\n  }\n  /**\n   * * Scan the active array.\n   * * remove edges whose top y is below y\n   * * (pack all remaining ones back towards the beginning)\n   */\n  public removeArrayMembersWithY1Below(y: number) {\n    let numKeep = 0;\n    const n = this.activeEdges.length;\n    for (let i = 0; i < n; i++) {\n      const q = this.activeEdges[i];\n      const yB = q.faceSuccessor.y;\n      if (yB >= y) {\n        // copy [i] forward to [target]\n        if (numKeep < i)\n          this.activeEdges[numKeep] = q;\n        numKeep++;\n      } else {\n        // let it go by !!!\n      }\n    }\n    this.activeEdges.length = numKeep;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { HalfEdgeGraph, HalfEdgeMask, HalfEdge } from \"./Graph\";\r\nimport { HalfEdgePositionDetail } from \"./HalfEdgePositionDetail\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { SmallSystem } from \"../numerics/Polynomials\";\r\nimport { PointSearchContext, RayClassification } from \"./HalfEdgePointInGraphSearch\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { MarkedEdgeSet } from \"./HalfEdgeMarkSet\";\r\nimport { Triangulator } from \"./Triangulation\";\r\n\r\n/** @module Topology */\r\n/**\r\n * Context for repeated insertion of new points in a graph.\r\n * * Initial graph should have clean outer boundary. (e.g. as typically marked with HalfEdgeMask.EXTERIOR)\r\n * * After each insertion, the current \"position\" within the graph is remembered so that each subsequent insertion\r\n *     can reuse that position as start for walking to the new point.\r\n */\r\nexport class InsertAndRetriangulateContext {\r\n  private _graph: HalfEdgeGraph;\r\n  private _edgeSet: MarkedEdgeSet;\r\n  private _searcher: HalfEdgePositionDetail;\r\n  // Temporaries used in reAimFromFace\r\n  // private _lastBefore: HalfEdgePositionDetail;\r\n  // private _firstAfter: HalfEdgePositionDetail;\r\n\r\n  private constructor(graph: HalfEdgeGraph) {\r\n    this._graph = graph;\r\n    this._edgeSet = MarkedEdgeSet.create(graph)!;\r\n    this._searcher = HalfEdgePositionDetail.create();\r\n    // this._lastBefore = HalfEdgePositionDetail.create();\r\n    // this._firstAfter = HalfEdgePositionDetail.create();\r\n  }\r\n  /** Create a new context referencing the graph. */\r\n  public static create(graph: HalfEdgeGraph) {\r\n    return new InsertAndRetriangulateContext(graph);\r\n  }\r\n  /** Query the (pointer to) the graph in the context. */\r\n  public get graph(): HalfEdgeGraph { return this._graph; }\r\n  // Walk face from edgeNode;  insert new edges back to start node from all except\r\n  //   immediate successor and predecessor.\r\n  // insert all new nodes, and nodes of the existing face, in edgeSet.\r\n  private retriangulateFromBaseVertex(centralNode: HalfEdge) {\r\n    const numNode = centralNode.countEdgesAroundFace();\r\n    this._edgeSet.addAroundFace(centralNode);\r\n    if (numNode < 4 || centralNode.signedFaceArea() <= 0.0)\r\n      return;\r\n    const numEdge = numNode - 3;\r\n    let farNode = centralNode.faceSuccessor;\r\n    let nearNode = centralNode;\r\n    for (let i = 0; i < numEdge; i++) {\r\n      farNode = farNode.faceSuccessor;\r\n      nearNode = this._graph.createEdgeHalfEdgeHalfEdge(nearNode, 0, farNode, 0);\r\n      farNode = nearNode.faceSuccessor;\r\n      this._edgeSet.addToSet(nearNode);\r\n    }\r\n  }\r\n  /** Reset the \"current\" position to unknown state. */\r\n  public reset() {\r\n    this._searcher = HalfEdgePositionDetail.create();\r\n  }\r\n\r\n  /** Return a (reference to!) the current position in the graph */\r\n  public get currentPosition() { return this._searcher; }\r\n  /**\r\n   * Linear search through the graph\r\n   * * Returns a HalfEdgePositionDetail for the nearest edge or vertex.\r\n   * @param xyz\r\n   */\r\n  public searchForNearestEdgeOrVertex(xyz: Point3d): HalfEdgePositionDetail {\r\n    const position = HalfEdgePositionDetail.create();\r\n    position.setDTag(Number.MAX_VALUE);\r\n    const xyzC = Point3d.create();\r\n    let fractionC;\r\n    let distanceC;\r\n    for (const nodeA of this._graph.allHalfEdges) {\r\n      const nodeB = nodeA.faceSuccessor;\r\n      fractionC = SmallSystem.lineSegment3dXYClosestPointUnbounded(nodeA, nodeB, xyz);\r\n      if (fractionC !== undefined) {\r\n        if (fractionC > 1.0) {\r\n          distanceC = xyz.distanceXY(nodeB);\r\n          if (distanceC < position.getDTag()!) {\r\n            position.resetAsVertex(nodeB);\r\n            position.setDTag(distanceC);\r\n          }\r\n        } else if (fractionC < 0.0) {\r\n          distanceC = xyz.distanceXY(nodeA);\r\n          if (distanceC < position.getDTag()!) {\r\n            position.resetAsVertex(nodeA);\r\n            position.setDTag(distanceC);\r\n          }\r\n        } else {\r\n          nodeA.fractionToPoint3d(fractionC, xyzC);\r\n\r\n          distanceC = xyz.distanceXY(xyzC);\r\n          if (distanceC < position.getDTag()!) {\r\n            position.resetAtEdgeAndFraction(nodeA, fractionC);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return position;\r\n  }\r\n  public searchForNearestVertex(xyz: Point3d): HalfEdgePositionDetail {\r\n    const position = HalfEdgePositionDetail.create();\r\n    position.setDTag(Number.MAX_VALUE);\r\n    let distanceA;\r\n    for (const nodeA of this._graph.allHalfEdges) {\r\n      distanceA = xyz.distanceXY(nodeA);\r\n      if (distanceA < position.getDTag()!) {\r\n        position.resetAsVertex(nodeA);\r\n        position.setDTag(distanceA);\r\n      }\r\n    }\r\n    return position;\r\n  }\r\n\r\n  public resetSearch(xyz: Point3d, maxDim: number) {\r\n    if (maxDim > 0)\r\n      this._searcher = this.searchForNearestEdgeOrVertex(xyz);\r\n    else\r\n      this._searcher = this.searchForNearestVertex(xyz);\r\n  }\r\n  public insertAndRetriangulate(xyz: Point3d, newZWins: boolean): boolean {\r\n    this.moveToPoint(this._searcher, xyz);\r\n    const seedNode = this._searcher.node;\r\n    let stat = false;\r\n    if (seedNode === undefined) {\r\n    } else if (this._searcher.isFace) {\r\n      if (!seedNode.isMaskSet(HalfEdgeMask.EXTERIOR)) {\r\n        const newInteriorNode = this._graph.createEdgeXYZHalfEdge(xyz.x, xyz.y, xyz.z, 0, seedNode, 0);\r\n        this.retriangulateFromBaseVertex(newInteriorNode);\r\n        Triangulator.flipTrianglesInEdgeSet(this._graph, this._edgeSet);\r\n        this._searcher.resetAsVertex(newInteriorNode);\r\n      }\r\n      stat = true;\r\n    } else if (this._searcher.isEdge) {\r\n      const newA = this._graph.splitEdgeAtFraction(seedNode, this._searcher.edgeFraction!);\r\n      const newB = newA.vertexPredecessor;\r\n      this.retriangulateFromBaseVertex(newA);\r\n      this.retriangulateFromBaseVertex(newB);\r\n      Triangulator.flipTrianglesInEdgeSet(this._graph, this._edgeSet);\r\n      this._searcher.resetAsVertex(newA);\r\n      stat = true;\r\n    } else if (this._searcher.isVertex) {\r\n      // There's already a vertex there.  Maybe the z is different.\r\n      if (newZWins)\r\n        seedNode.setXYZAroundVertex(xyz.x, xyz.y, xyz.z);\r\n      stat = true;\r\n    } else {\r\n      stat = false;\r\n    }\r\n    return stat;\r\n  }\r\n\r\n  // Advance movingPosition to a face, edge, or vertex position detail that contains xyz.\r\n  // Prior content in movingPosition is used as seed.\r\n  // Return true if successful.\r\n  public moveToPoint(movingPosition: HalfEdgePositionDetail, xyz: Point3d, announcer?: (position: HalfEdgePositionDetail) => boolean): boolean {\r\n    const psc = PointSearchContext.create();\r\n    movingPosition.setITag(0);\r\n    if (movingPosition.isUnclassified) {\r\n      moveToAnyUnmaskedEdge(this.graph, movingPosition, 0.5, 0);\r\n      if (movingPosition.isUnclassified)\r\n        return false;\r\n    }\r\n\r\n    // double tol = vu_getMergeTol (pGraph);\r\n    const ray = Ray3d.createXAxis();\r\n    for (; movingPosition.getITag() === 0;) {\r\n      if (announcer !== undefined) {\r\n        const continueSearch = announcer(movingPosition);\r\n        if (!continueSearch)\r\n          break;\r\n      }\r\n      if (!psc.setSearchRay(movingPosition, xyz, ray)) {\r\n        return false;\r\n      } else if (movingPosition.isFace) {\r\n        const lastBefore = HalfEdgePositionDetail.create();\r\n        const firstAfter = HalfEdgePositionDetail.create();\r\n        const rc = psc.reAimAroundFace(movingPosition.node!, ray, ray.a!, lastBefore, firstAfter);\r\n        // reAimAroundFace returns lots of cases in `lastBefore` !!\r\n        switch (rc) {\r\n          case RayClassification.RC_NoHits: {\r\n            movingPosition.resetAsUnknown();\r\n            break;\r\n          }\r\n          case RayClassification.RC_TargetOnVertex: {\r\n            movingPosition.setFrom(lastBefore);\r\n            movingPosition.setITag(1);\r\n            break;\r\n          }\r\n          case RayClassification.RC_TargetOnEdge: {\r\n            movingPosition.setFrom(lastBefore);\r\n            movingPosition.setITag(1);\r\n            break;\r\n          }\r\n          case RayClassification.RC_Bracket: {\r\n            movingPosition.resetAsFace(lastBefore.node, xyz);\r\n            movingPosition.setITag(1);\r\n            break;\r\n          }\r\n          case RayClassification.RC_TargetBefore: {\r\n            movingPosition.resetAsFace(movingPosition.node, xyz);\r\n            movingPosition.setITag(1);\r\n            break;\r\n          }\r\n          case RayClassification.RC_TargetAfter: {\r\n            movingPosition.setFrom(lastBefore);\r\n            break;\r\n          }\r\n        }\r\n      } else if (movingPosition.isEdge) {\r\n        psc.reAimFromEdge(movingPosition, ray, ray.a!);\r\n        if (movingPosition.isUnclassified)\r\n          break;\r\n      } else if (movingPosition.isVertex) {\r\n        psc.reAimFromVertex(movingPosition, ray, ray.a!);\r\n        if (movingPosition.isUnclassified)\r\n          break;\r\n      }\r\n    }\r\n\r\n    return movingPosition.isAtXY(xyz.x, xyz.y);\r\n  }\r\n}\r\n// Create a VuPositionDetail for specified fraction along any unmasked edge.\r\nfunction moveToAnyUnmaskedEdge(graph: HalfEdgeGraph, position: HalfEdgePositionDetail, edgeFraction: number, skipMask: HalfEdgeMask): boolean {\r\n  for (const candidate of graph.allHalfEdges) {\r\n    if (!candidate.isMaskSet(skipMask)) {\r\n      position.resetAtEdgeAndFraction(candidate, edgeFraction);\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n/**\n * Methods to \"grab and drop\" mask bits.\n * * Caller code (e.g. HalfEdgeGraph) initializes with a block of bits to be managed.\n * * Callers borrow and return masks with \"grabMask\" and \"dropMask\"\n * * Callers must exercise grab/drop balance discipline.\n * @internal\n */\nexport class MaskManager {\n  private _freeMasks: number;\n  private _originalFreeMasks: number;\n  private _firstFreeMask: number;\n  /**\n   * @param freeMasks caller-defined block of bits that are to be managed.\n   */\n  private constructor(freeMasks: number, firstFreeMask: number) {\n    this._originalFreeMasks = freeMasks;\n    this._freeMasks = freeMasks;\n    this._firstFreeMask = firstFreeMask;\n  }\n  /** Create a MaskManager.\n   * Typical use:   MaskManager.create (0xFFFF0000)\n   * * This makes bits 16 through 31 available to be borrowed, with lower bits available for fixed usage.\n   */\n  public static create(freeMasks: number): MaskManager | undefined {\n    // look for first bit up to bit 31\n    let firstFree = 0;\n    let testBit = 0x01;\n    for (let i = 0; i < 32; i++) {\n      if ((testBit & freeMasks) !== 0) {\n        firstFree = testBit;\n        break;\n      }\n      testBit = (testBit << 1);\n    }\n    if (firstFree === 0)\n      return undefined;\n    return new MaskManager(freeMasks, firstFree);\n  }\n  /**\n   * Find a mask bit that is not \"in use\".\n   */\n  public grabMask(): number {\n    let mask = this._firstFreeMask;\n    if (this._freeMasks === 0)\n      return 0;\n    while (!(mask & this._freeMasks))\n      mask = mask << 1;\n\n    this._freeMasks &= ~mask;\n    return mask;\n  }\n  /**\n   * Find a mask bit that is not \"in use\".\n   */\n  public dropMask(mask: number) {\n    mask &= this._originalFreeMasks;    // prevent \"drop\" of mask not in the pool.\n    this._freeMasks |= mask;\n  }\n\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n\nimport { Geometry } from \"../Geometry\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { HalfEdge, HalfEdgeGraph, HalfEdgeMask } from \"./Graph\";\nimport { ClusterableArray } from \"../numerics/ClusterableArray\";\nimport { Range3d } from \"../geometry3d/Range\";\nimport { HalfEdgePriorityQueueWithPartnerArray } from \"./HalfEdgePriorityQueue\";\nimport { SmallSystem } from \"../numerics/Polynomials\";\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\nimport { Angle } from \"../geometry3d/Angle\";\nimport { Triangulator, MultiLineStringDataVariant } from \"./Triangulation\";\nimport { RegularizationContext } from \"./RegularizeFace\";\n\nexport class GraphSplitData {\n  public numUpEdge = 0;\n  public numIntersectionTest = 0;\n  public numSplit = 0;\n  public numPopOut = 0;\n  public numA0B0 = 0;\n  public numA0B1 = 0;\n  public constructor() {\n  }\n}\n\n/**\n * * Assorted methods used in algorithms on HalfEdgeGraph.\n * @internal\n */\nexport class HalfEdgeGraphOps {\n\n  /** Compare function for sorting with primary y compare, secondary  x compare. */\n  public static compareNodesYXUp(a: HalfEdge, b: HalfEdge) {\n    // Check y's\n    // if (!Geometry.isSameCoordinate(a.y, b.y))\n    if (a.y < b.y)\n      return -1;\n    else if (a.y > b.y)\n      return 1;\n    // Check x's\n    // if (!Geometry.isSameCoordinate(a.x, b.x))\n    if (a.x < b.x)\n      return -1;\n    else if (a.x > b.x)\n      return 1;\n    return 0;\n  }\n\n  /** Return true if nodeB (a) is lower than both its neighbors and (b) inflects as a downward peak (rather than an upward trough) */\n  public static isDownPeak(nodeB: HalfEdge) {\n    const nodeA = nodeB.facePredecessor;\n    const nodeC = nodeB.faceSuccessor;\n    return this.compareNodesYXUp(nodeB, nodeA) < 0\n      && this.compareNodesYXUp(nodeB, nodeC) < 0\n      && this.crossProductToTargets(nodeB, nodeA, nodeC) > 0;\n  }\n\n  /** return the cross product of vectors from base to targetA and base to targetB\n   * @param base base vertex of both vectors.\n   * @param targetA target vertex of first vector\n   * @param targetB target vertex of second vector\n   */\n  public static crossProductToTargets(base: HalfEdge, targetA: HalfEdge, targetB: HalfEdge): number {\n    return Geometry.crossProductXYXY(targetA.x - base.x, targetA.y - base.y, targetB.x - base.x, targetB.y - base.y);\n  }\n\n  // ---------------------------------------------------------------------------------------------------------------------\n  // ----------------------------------------------------------------------------------------------------------------------\n\n  public static graphRange(graph: HalfEdgeGraph): Range3d {\n    const range = Range3d.create();\n    for (const node of graph.allHalfEdges) {\n      range.extendXYZ(node.x, node.y, node.z);\n    }\n    return range;\n  }\n  /** Returns an array of a all nodes (both ends) of edges created from segments. */\n  public static segmentArrayToGraphEdges(segments: LineSegment3d[], returnGraph: HalfEdgeGraph, mask: HalfEdgeMask): HalfEdge[] {\n    const result = [];\n    let idxCounter = 0;\n\n    // Push the endpoints of each segment onto arr[] in the form {(x, y, theta), Node}\n    for (const segment of segments) {\n\n      const node0 = returnGraph.createEdgeXYZXYZ(\n        segment.point0Ref.x, segment.point0Ref.y, segment.point0Ref.z,\n        idxCounter,\n        segment.point1Ref.x, segment.point1Ref.y, segment.point1Ref.z,\n        idxCounter + 1);\n\n      const node1 = node0.edgeMate;\n      idxCounter += 2;\n\n      node0.setMaskAroundFace(mask);   // Original given coordinates must be part of boundary\n      result.push(node0);\n      result.push(node1);\n    }\n\n    return result;\n  }\n\n  /**\n   * * For each face with positive area . . . add edges as needed so that each face has one definitely lower node and one definite upper node.\n   * * Hence tracing edges from the low node, there is a sequence of upward edges, reaching the upper,  then a sequence of downward edges reaching the low node.\n   * * This is an essential step for subsequent triangulation.\n   *\n   * @param graph\n   */\n  public static formMonotoneFaces(graph: HalfEdgeGraph) {\n\n    const allFaces = graph.collectFaceLoops();\n    graph.clearMask(HalfEdgeMask.VISITED);\n    // For every face, break the face down into monotone sections\n    for (const node of allFaces) {\n      if (node.isMaskSet(HalfEdgeMask.VISITED))\n        continue;\n      const area = node.signedFaceArea();\n      if (area <= 0.0) {\n        node.setMaskAroundFace(HalfEdgeMask.VISITED);\n        continue;\n      }\n\n    }\n  }\n\n  /**\n   * * Visit all nodes in `graph`.\n   * * invoke `pinch(node, vertexPredecessor)`\n   * * this leaves the graph as isolated edges.\n   * @param graph graph to modify\n   */\n  public static isolateAllEdges(graph: HalfEdgeGraph) {\n    for (const nodeA of graph.allHalfEdges) {\n      const nodeB = nodeA.vertexPredecessor;\n      HalfEdge.pinch(nodeA, nodeB);\n    }\n  }\n\n}\n/**\n * @internal\n */\nexport class HalfEdgeGraphMerge {\n  /** Simplest merge algorithm:\n   * * collect array of (x,y,theta) at all nodes\n   * * lexical sort of the array.\n   * * twist all vertices together.\n   * * This effectively creates valid face loops for a planar subdivision if there are no edge crossings.\n   * * If there are edge crossings, the graph can be a (highly complicated) Klein bottle topology.\n   * * Mask.NULL_FACE is cleared throughout and applied within null faces.\n   */\n  public static clusterAndMergeXYTheta(graph: HalfEdgeGraph) {\n    const allNodes = graph.allHalfEdges;\n    const numNodes = allNodes.length;\n    graph.clearMask(HalfEdgeMask.NULL_FACE);\n    const clusters = new ClusterableArray(2, 2, numNodes);  // data order: x,y,theta, nodeIndex.  But theta is not set in first round.\n    for (let i = 0; i < numNodes; i++) {\n      const nodeA = allNodes[i];\n      const xA = nodeA.x;\n      const yA = nodeA.y;\n      HalfEdge.pinch(nodeA, nodeA.vertexSuccessor);  // pull it out of its current vertex loop.\n      clusters.addDirect(xA, yA, 0.0, i);\n    }\n    const order = clusters.clusterIndicesLexical();\n    let k0 = 0;\n    const numK = order.length;\n    for (let k1 = 0; k1 < numK; k1++) {\n      if (order[k1] === ClusterableArray.clusterTerminator) {\n        // nodes identified in order[k0]..order[k1] are properly sorted around a vertex.\n        if (k1 > k0) {\n          const iA = clusters.getExtraData(order[k0], 1);\n          const nodeA0 = allNodes[iA];\n          for (let k = k0 + 1; k < k1; k++) {\n            const iB = clusters.getExtraData(order[k], 1);\n            const nodeB = allNodes[iB];\n            nodeB.x = nodeA0.x;\n            nodeB.y = nodeA0.y;\n          }\n        }\n        k0 = k1 + 1;\n      }\n    }\n    // NOW\n    //  1) There are identical coordinates at all nodes around each vertex loop.\n    //  2) Hence ready do sort (at each vertex) by theta.\n\n    // insert theta as extra data in the sort table . . .\n    for (const clusterTableIndex of order) {\n      if (clusterTableIndex !== ClusterableArray.clusterTerminator) {\n        const nodeA = allNodes[clusterTableIndex];\n        const nodeB = nodeA.faceSuccessor;\n        let radians = Math.atan2(nodeB.y - nodeA.y, nodeB.x - nodeA.x);\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, -Math.PI))\n          radians = Math.PI;\n        clusters.setExtraData(clusterTableIndex, 0, radians);\n      }\n    }\n    clusters.sortSubsetsBySingleKey(order, 2);\n    const unmatchedNullFaceNodes: HalfEdge[] = [];\n    k0 = 0;\n    let thetaA, thetaB;\n    // now pinch each neighboring pair together\n    for (let k1 = 0; k1 < numK; k1++) {\n      if (order[k1] === ClusterableArray.clusterTerminator) {\n        // nodes identified in order[k0]..order[k1] are properly sorted around a vertex.\n        if (k1 > k0) {\n          const iA = clusters.getExtraData(order[k0], 1);\n          thetaA = clusters.getExtraData(order[k0], 0);\n          const nodeA0 = allNodes[iA];\n          let nodeA = nodeA0;\n          for (let k = k0 + 1; k < k1; k++) {\n            const iB = clusters.getExtraData(order[k], 1);\n            thetaB = clusters.getExtraData(order[k], 0);\n            const nodeB = allNodes[iB];\n            if (nodeA.isMaskSet(HalfEdgeMask.NULL_FACE)) {\n              // nope, this edge was flagged and pinched from the other end.\n              const j = unmatchedNullFaceNodes.findIndex((node: HalfEdge) => nodeA === node);\n              if (j >= 0) {\n                unmatchedNullFaceNodes[j] = unmatchedNullFaceNodes[unmatchedNullFaceNodes.length - 1];\n                unmatchedNullFaceNodes.pop();\n              }\n              nodeA = nodeB;\n              thetaA = thetaB;\n            } else if (nodeB.isMaskSet(HalfEdgeMask.NULL_FACE)) {\n              const j = unmatchedNullFaceNodes.findIndex((node: HalfEdge) => nodeA === node);\n              if (j >= 0) {\n                unmatchedNullFaceNodes[j] = unmatchedNullFaceNodes[unmatchedNullFaceNodes.length - 1];\n                unmatchedNullFaceNodes.pop();\n              }\n              // NO leave nodeA and thetaA   ignore nodeB -- later step will get the outside of its banana.\n            } else {\n              HalfEdge.pinch(nodeA, nodeB);\n              if (Angle.isAlmostEqualRadiansAllowPeriodShift(thetaA, thetaB)) {\n                const nodeA1 = nodeA.faceSuccessor;\n                const nodeB1 = nodeB.edgeMate;\n                // WE TRUST -- nodeA1 and node B1 must have identical xy.\n                // pinch them together and mark the face loop as null ..\n                HalfEdge.pinch(nodeA1, nodeB1);\n                nodeA.setMask(HalfEdgeMask.NULL_FACE);\n                nodeB1.setMask(HalfEdgeMask.NULL_FACE);\n                unmatchedNullFaceNodes.push(nodeB1);\n              }\n              nodeA = nodeB;\n              thetaA = thetaB;\n            }\n          }\n        }\n        k0 = k1 + 1;\n      }\n    }\n  }\n\n  private static buildVerticalSweepPriorityQueue(graph: HalfEdgeGraph): HalfEdgePriorityQueueWithPartnerArray {\n    const sweepHeap = new HalfEdgePriorityQueueWithPartnerArray();\n    for (const p of graph.allHalfEdges) {\n\n      if (HalfEdgeGraphOps.compareNodesYXUp(p, p.faceSuccessor) < 0) {\n        sweepHeap.priorityQueue.push(p);\n      }\n    }\n    return sweepHeap;\n  }\n  private static computeIntersectionFractionsOnEdges(nodeA0: HalfEdge, nodeB0: HalfEdge, fractions: Vector2d, pointA: Point2d, pointB: Point2d): boolean {\n    const nodeA1 = nodeA0.faceSuccessor;\n    const ax0 = nodeA0.x;\n    const ay0 = nodeA0.y;\n    const ux = nodeA1.x - ax0;\n    const uy = nodeA1.y - ay0;\n    const nodeB1 = nodeB0.faceSuccessor;\n    const bx0 = nodeB0.x;\n    const by0 = nodeB0.y;\n    const vx = nodeB1.x - bx0;\n    const vy = nodeB1.y - by0;\n    if (SmallSystem.lineSegmentXYUVTransverseIntersectionUnbounded(ax0, ay0, ux, uy,\n      bx0, by0, vx, vy, fractions)) {\n      pointA.x = ax0 + fractions.x * ux;\n      pointA.y = ay0 + fractions.x * uy;\n      pointB.x = bx0 + fractions.y * vx;\n      pointB.y = by0 + fractions.y * vy;\n      return Geometry.isIn01(fractions.x) && Geometry.isIn01(fractions.y);\n    }\n    return false;\n  }\n  /**\n   * Split edges at intersections.\n   * * This is a large operation.\n   * @param graph\n   */\n  public static splitIntersectingEdges(graph: HalfEdgeGraph): GraphSplitData {\n    const data = new GraphSplitData();\n    const sweepHeap = this.buildVerticalSweepPriorityQueue(graph);\n    let nodeA0, nodeB1;\n    const smallFraction = 1.0e-8;\n    const largeFraction = 1.0 - smallFraction;\n    let i;\n    const fractions = Vector2d.create();\n    const pointA = Point2d.create();\n    const pointB = Point2d.create();\n    let nodeB0;\n    while (undefined !== (nodeA0 = sweepHeap.priorityQueue.pop())) {\n      data.numUpEdge++;\n      const n0 = sweepHeap.activeEdges.length;\n      sweepHeap.removeArrayMembersWithY1Below(nodeA0.y);\n      data.numPopOut += n0 - sweepHeap.activeEdges.length;\n      for (i = 0; i < sweepHeap.activeEdges.length; i++) {\n        nodeB0 = sweepHeap.activeEdges[i];\n        nodeB1 = nodeB0.faceSuccessor;\n        // const nodeB1 = nodeB0.faceSuccessor;\n        if (Geometry.isSameCoordinateXY(nodeA0.x, nodeA0.y, nodeB0.x, nodeB0.y)) {\n          data.numA0B0++;\n        } else if (Geometry.isSameCoordinateXY(nodeB1.x, nodeB1.y, nodeA0.x, nodeA0.y)) {\n          data.numA0B1++;\n        } else {\n          data.numIntersectionTest++;\n          if (this.computeIntersectionFractionsOnEdges(nodeA0, nodeB0, fractions, pointA, pointB)) {\n            if (fractions.x > smallFraction && fractions.x < largeFraction) {\n              const nodeC0 = graph.splitEdgeAtFraction(nodeA0, fractions.x);\n              sweepHeap.priorityQueue.push(nodeC0);  // The upper portion will be reviewed as a nodeA0 later !!!\n              data.numSplit++;\n            }\n            if (fractions.y > smallFraction && fractions.y < largeFraction) {\n              const nodeD0 = graph.splitEdgeAtFraction(nodeB0, fractions.y);\n              sweepHeap.priorityQueue.push(nodeD0);  // The upper portion will be reviewed as a nodeA0 later !!!\n              data.numSplit++;\n            }\n            // existing nodeA0 and its shortened edge remain for further intersections\n          }\n        }\n      }\n      sweepHeap.activeEdges.push(nodeA0);\n    }\n    return data;\n  }\n\n  /**\n   * Returns a graph structure formed from the given LineSegment array\n   *\n   * *  Find all intersections among segments, and split them if necessary\n   * *  Record endpoints of every segment in the form X, Y, Theta; This information is stored as a new node and sorted to match up\n   *      vertices.\n   * *  For vertices that match up, pinch the nodes to create vertex loops, which in closed objects, will also eventually form face\n   *      loops\n   */\n  public static formGraphFromSegments(lineSegments: LineSegment3d[]): HalfEdgeGraph {\n    // Structure of an index of the array: { xyTheta: Point3d, node: Node }\n    const graph = new HalfEdgeGraph();\n    HalfEdgeGraphOps.segmentArrayToGraphEdges(lineSegments, graph, HalfEdgeMask.BOUNDARY_EDGE);\n    this.splitIntersectingEdges(graph);\n    this.clusterAndMergeXYTheta(graph);\n\n    return graph;\n  }\n\n  /**\n   * * Input is random linestrings, not necessarily loops\n   * * Graph gets full splitEdges, regularize, and triangulate.\n   * @returns triangulated graph, or undefined if bad data.\n   */\n  public static formGraphFromChains(chains: MultiLineStringDataVariant, regularize: boolean = true, mask: HalfEdgeMask = HalfEdgeMask.PRIMARY_EDGE): HalfEdgeGraph | undefined {\n    if (chains.length < 1)\n      return undefined;\n    const graph = new HalfEdgeGraph();\n    const chainSeeds = Triangulator.directCreateChainsFromCoordinates(graph, chains);\n    for (const seed of chainSeeds)\n      seed.setMaskAroundFace(mask);\n\n    this.splitIntersectingEdges(graph);\n    this.clusterAndMergeXYTheta(graph);\n    if (regularize) {\n      const context = new RegularizationContext(graph);\n      context.regularizeGraph(true, true);\n    }\n    return graph;\n  }\n\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n\nimport { HalfEdge, HalfEdgeGraph, HalfEdgeMask } from \"./Graph\";\nimport { HalfEdgeGraphOps } from \"./Merging\";\n//   /* tslint:disable:no-console */\n/**\n * * Context for regularizing single faces.\n * @internal\n */\nexport class RegularizationContext {\n  public constructor(graph: HalfEdgeGraph) {\n    this.graph = graph;\n    this.upEdges = [];\n    this.downEdges = [];\n    this.bottomPeaks = [];\n    this.topPeaks = [];\n    this.localMin = [];\n    this.localMax = [];\n  }\n\n  /**\n   * These are public only for testing.\n   */\n  public graph: HalfEdgeGraph;\n  /** array of edges directed upward.  Turn can be left or right, but is not large enough to be a min or max */\n  public upEdges: HalfEdge[];\n  /** array of edges directed downward, Turn can be left or right, but is not large enough to be a min or max */\n  public downEdges: HalfEdge[];\n  /** Array of edges whose start is an upward peak (right turn, inbound up, outbound down) */\n  public topPeaks: HalfEdge[];\n  /** Array of edges whose start is an downward peak (right turn, inbound down, outbound up) */\n  public bottomPeaks: HalfEdge[];\n\n  /** Array of edges at local minima (left turn, inbound down, outbound up).  Ensuing chain is up */\n  public localMin: HalfEdge[];\n  /** Array of edges at local maxima (left turn, inbound up, outbound down).  Ensuing chain is down */\n  public localMax: HalfEdge[];\n  /**\n   * Collect (and classify) all the edges around a single face.\n   * * The various arrays are collected: upEdges, downEdges, topPeaks, bottomPeaks, upChains, downChains\n   * @param faceSeed face to examine\n   */\n  public collectVerticalEventsAroundFace(faceSeed: HalfEdge) {\n    let nodeA = faceSeed;\n    let nodeB;\n    let nodeC;\n    let abUp;\n    let bcUp;\n    this.upEdges.length = 0;\n    this.downEdges.length = 0;\n    this.topPeaks.length = 0;\n    this.bottomPeaks.length = 0;\n    this.localMin.length = 0;\n    this.localMax.length = 0;\n    do {\n      nodeB = nodeA.faceSuccessor;\n      nodeC = nodeB.faceSuccessor;\n      abUp = HalfEdgeGraphOps.compareNodesYXUp(nodeA, nodeB) < 0;\n      bcUp = HalfEdgeGraphOps.compareNodesYXUp(nodeB, nodeC) < 0;\n      if (abUp) {\n        this.upEdges.push(nodeA);\n        if (!bcUp) {\n          if (HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) < 0)\n            this.localMax.push(nodeB);\n          else\n            this.topPeaks.push(nodeB);\n        }\n\n      } else { // ab is DOWN\n        this.downEdges.push(nodeA);\n        if (bcUp) {\n          if (HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) > 0)\n            this.bottomPeaks.push(nodeB);\n          else\n            this.localMin.push(nodeB);\n        }\n      }\n      nodeA = nodeB;\n    } while (nodeA !== faceSeed);\n  }\n\n  /**\n   * Collect (and classify) all the edges in an array.\n   * * The various arrays are collected: upEdges, downEdges, topPeaks, bottomPeaks, upChains, downChains\n   * @param candidateEdges array of edges.\n   */\n  public collectVerticalEventFromEdgesInAndArray(candidateEdges: HalfEdge[]) {\n    let nodeA;\n    let nodeB;\n    let nodeC;\n    let abUp;\n    let bcUp;\n    this.upEdges.length = 0;\n    this.downEdges.length = 0;\n    this.topPeaks.length = 0;\n    this.bottomPeaks.length = 0;\n    this.localMin.length = 0;\n    this.localMax.length = 0;\n    for (nodeA of candidateEdges) {\n      nodeB = nodeA.faceSuccessor;\n      nodeC = nodeB.faceSuccessor;\n      abUp = HalfEdgeGraphOps.compareNodesYXUp(nodeA, nodeB) < 0;\n      bcUp = HalfEdgeGraphOps.compareNodesYXUp(nodeB, nodeC) < 0;\n      if (abUp) {\n        this.upEdges.push(nodeA);\n        if (!bcUp) {\n          if (HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) < 0)\n            this.localMax.push(nodeB);\n          else\n            this.topPeaks.push(nodeB);\n        }\n\n      } else { // ab is DOWN\n        this.downEdges.push(nodeA);\n        if (bcUp) {\n          if (HalfEdgeGraphOps.crossProductToTargets(nodeB, nodeA, nodeC) > 0)\n            this.bottomPeaks.push(nodeB);\n          else\n            this.localMin.push(nodeB);\n        }\n      }\n    }\n  }\n\n  private swapArrays() {\n    let save = this.downEdges; this.downEdges = this.upEdges; this.upEdges = save;\n    save = this.localMax; this.localMax = this.localMin; this.localMin = save;\n    save = this.topPeaks; this.topPeaks = this.bottomPeaks; this.bottomPeaks = save;\n  }\n\n  /**\n   * Find the edge (among candidates) which is first struck by a \"rightward\" scan from node\n   * * comparisonFunction determines scan sense\n   *   * HalfEdge.compareNodeYXTheta is an upward scan.\n   *   * HalfEdge.compareNodeYXThetaDownward is a downward scan.\n   * @param node\n   * @param candidates Array of nodes to search\n   * @param nodeComparisonFunction function for lexical comparison.\n   */\n  private findTopVisibleEdge(node: HalfEdge, candidates: HalfEdge[],\n    directionSign: number) {\n    const y0 = node.y;\n    const x0 = node.x;\n    let dx;\n    let distanceRight = Number.MAX_SAFE_INTEGER;\n    let result: HalfEdge | undefined;\n    for (const rightBase of candidates) {\n      const rightTop = rightBase.faceSuccessor;\n      if (rightBase === node || rightTop === node)\n        continue;\n      // for horizontal edge cases -- require edges ends to have strict sign change (no zeros!!)\n      const cRight = HalfEdgeGraphOps.compareNodesYXUp(node, rightBase);\n      const cTop = HalfEdgeGraphOps.compareNodesYXUp(node, rightTop);\n      // console.log(node.id, rightBase.id, rightTop.id, cRight, cTop);\n      if (cRight * cTop >= 0)\n        continue;\n      const fraction = HalfEdge.horizontalScanFraction01(rightBase, y0);\n      if (fraction !== undefined) {\n        dx = directionSign * (rightBase.fractionToX(fraction) - x0);\n        if (dx > 0 && dx < distanceRight) {\n          result = rightBase;\n          distanceRight = dx;\n        }\n      }\n    }\n    return result;\n  }\n  /**\n   *\n   * @param downPeak a \"bottom\" node where the interior CCW loop has a local min\n   * @param downEdgeStart (optional) node at the start (heading downwards!) of an edge that brackets downPeak on the left.\n   * @param upEdgeStart  (optional) node at the start (heading up!) of the edge that brackets downPeak on the right.\n   */\n  private highestUpPeakConnection(downPeak: HalfEdge, downEdgeStart: HalfEdge | undefined, upEdgeStart: HalfEdge | undefined): HalfEdge | undefined {\n    let highestPeak;\n\n    for (const upPeak of this.topPeaks) {\n      const y0 = upPeak.y;\n      const x0 = upPeak.x;\n      // is upPeak higher than prior upPeak?\n      if (highestPeak !== undefined && HalfEdgeGraphOps.compareNodesYXUp(upPeak, highestPeak) < 0)\n        continue;\n      // is upPeak BELOW downPeak, ABOVE both limit edges lower node, and between limit edge interiors.\n      if (HalfEdgeGraphOps.compareNodesYXUp(upPeak, downPeak) < 0) {\n        if (downEdgeStart) {\n          const fraction = HalfEdge.horizontalScanFraction01(downEdgeStart, y0);\n          if (fraction === undefined)\n            continue;\n          if (x0 <= downEdgeStart.fractionToX(fraction))\n            continue;\n        }\n        if (upEdgeStart) {\n          const fraction = HalfEdge.horizontalScanFraction01(upEdgeStart, y0);\n          if (fraction === undefined)\n            continue;\n          if (upEdgeStart.fractionToX(fraction) <= x0)\n            continue;\n        }\n        highestPeak = upPeak;\n      }\n    }\n    return highestPeak;\n  }\n\n  private updateMaxNode(maxNode: HalfEdge | undefined, candidate: HalfEdge | undefined, compare: (a: HalfEdge, b: HalfEdge) => number): HalfEdge | undefined {\n    if (!maxNode)\n      return candidate;\n    if (!candidate)\n      return maxNode;\n    // both are defined .. look for positive compare ...\n    if (compare(maxNode, candidate) < 0)\n      return candidate;\n    return maxNode;\n  }\n  private negateXY() {\n    for (const node of this.graph.allHalfEdges) {\n      node.x *= -1;\n      node.y *= -1;\n    }\n  }\n  private downwardConnectionFromBottomPeak(node: HalfEdge): HalfEdge | undefined {\n    let connectTo;\n    const upFunction = HalfEdgeGraphOps.compareNodesYXUp;\n    const upEdgeBase = this.findTopVisibleEdge(node, this.upEdges, 1.0)!;\n    const downEdgeBase = this.findTopVisibleEdge(node, this.downEdges, -1.0)!;\n    connectTo = this.updateMaxNode(connectTo, upEdgeBase, upFunction);\n    if (downEdgeBase)\n      connectTo = this.updateMaxNode(connectTo, downEdgeBase.faceSuccessor, upFunction);\n    const upPeakConnection = this.highestUpPeakConnection(node, downEdgeBase, upEdgeBase);\n    if (upPeakConnection !== undefined)\n      connectTo = this.updateMaxNode(connectTo, upPeakConnection, upFunction);\n    return connectTo;\n  }\n  private joinNodes(nodeA: HalfEdge, nodeB: HalfEdge): HalfEdge {\n    const nodeC = this.graph.createEdgeXYZXYZ(nodeA.x, nodeA.y, nodeA.z, 0, nodeB.x, nodeB.y, nodeB.z, 0);\n    HalfEdge.pinch(nodeA, nodeC);\n    HalfEdge.pinch(nodeB, nodeC.edgeMate);\n    return nodeC;\n  }\n  /**\n   * Regularize a single face.\n   * * Insert edge from any downward interior vertex to something lower\n   * * Insert an edge from each upward interior vertex to something higher.\n   * * The face is split into smaller faces\n   * * Each final face has at most one \"min\" and one \"max\", and is easy to triangulate with a bottom to top sweep.\n   * * Normal usage is to sweep in both directions, i.e. use the default (true,true) for the upSweep and downSweep parameters.\n   * @param faceSeed any representative half edge on the face\n   * @param upSweep true to do the upward sweep.\n   * @param downSweep true to do the downward sweep.\n   */\n  private runRegularization(upSweep: boolean = true, downSweep: boolean = true) {\n    if (upSweep) {\n      this.bottomPeaks.sort(HalfEdgeGraphOps.compareNodesYXUp);\n      for (const bottomPeak of this.bottomPeaks) {\n        // console.log(\"SEARCH\", bottomPeak.id, [bottomPeak.x, bottomPeak.y]);\n        if (!HalfEdgeGraphOps.isDownPeak(bottomPeak))\n          continue;\n        const target = this.downwardConnectionFromBottomPeak(bottomPeak);\n        if (target !== undefined) {\n          // console.log(\"join\", bottomPeak.id, [bottomPeak.x, bottomPeak.y], target.id, [target.x, target.y]);\n          this.joinNodes(bottomPeak, target);\n        }\n      }\n    }\n    if (downSweep) {\n      // flip the whole graph (ouch)\n      this.negateXY();\n      // swap the various p and down seeds ....\n      this.swapArrays();\n      this.bottomPeaks.sort(HalfEdgeGraphOps.compareNodesYXUp);\n      for (const bottomPeak of this.bottomPeaks) {\n        if (!HalfEdgeGraphOps.isDownPeak(bottomPeak))\n          continue;\n        const target = this.downwardConnectionFromBottomPeak(bottomPeak);\n        if (target !== undefined) {\n          this.joinNodes(bottomPeak, target);\n        }\n      }\n      this.negateXY();\n      this.swapArrays();\n    }\n  }\n\n  /**\n   * Regularize a single face.\n   * * Insert edge from any downward interior vertex to something lower\n   * * Insert an edge from each upward interior vertex to something higher.\n   * * The face is split into smaller faces\n   * * Each final face has at most one \"min\" and one \"max\", and is easy to triangulate with a bottom to top sweep.\n   * * Normal usage is to sweep in both directions, i.e. use the default (true,true) for the upSweep and downSweep parameters.\n   * @param faceSeed any representative half edge on the face\n   * @param upSweep true to do the upward sweep.\n   * @param downSweep true to do the downward sweep.\n   */\n  public regularizeFace(faceSeed: HalfEdge, upSweep: boolean = true, downSweep: boolean = true) {\n    this.collectVerticalEventsAroundFace(faceSeed);\n    this.runRegularization(upSweep, downSweep);\n  }\n\n  public regularizeGraph(upSweep: boolean = true, downSweep: boolean = true) {\n    this.collectVerticalEventFromEdgesInAndArray(this.graph.allHalfEdges);\n    this.runRegularization(upSweep, downSweep);\n  }\n\n  /** test if a single face is monotone;  if so, return its (single) min */\n  public static isMonotoneFace(seed: HalfEdge): HalfEdge | undefined {\n    let numMin = 0;\n    let numMax = 0;\n    let nodeMin: HalfEdge | undefined;\n    let nodeA = seed;\n    do {\n      const nodeB = nodeA.faceSuccessor;\n      const nodeC = nodeB.faceSuccessor;\n      const ab = HalfEdgeGraphOps.compareNodesYXUp(nodeA, nodeB);\n      const bc = HalfEdgeGraphOps.compareNodesYXUp(nodeB, nodeC);\n      if (ab * bc <= 0) {\n        if (ab > 0) {\n          numMin++;\n          nodeMin = nodeB;\n        }\n        if (bc > 0) {\n          numMax++;\n        }\n      }\n    } while ((nodeA = nodeA.faceSuccessor) !== seed);\n    return numMin === 1 && numMax === 1 ? nodeMin : undefined;\n  }\n  /** Return faces filtered by area and test function.\n   * * find one arbitrary representative of each face\n   * * offer the candidate to the mutate function.\n   * * collect results\n   * @param mappedSeeds when filter returns a HalfEdge, collect it here\n   * @param unmappedSeeds when filter does not return a half edge, collect the candidate.\n   */\n  public static collectMappedFaceRepresentatives(\n    graph: HalfEdgeGraph,\n    positiveAreaOnly: boolean,\n    mutate: (seed: HalfEdge) => HalfEdge | undefined,\n    mappedEdges: HalfEdge[] | undefined,\n    unMappedSeeds: HalfEdge[] | undefined) {\n    if (mappedEdges)\n      mappedEdges.length = 0;\n    if (unMappedSeeds)\n      unMappedSeeds.length = 0;\n    const mask = HalfEdgeMask.VISITED;\n    graph.clearMask(mask);\n    for (const seed of graph.allHalfEdges) {\n      if (!seed.getMask(mask)) {\n        seed.setMaskAroundFace(mask);\n        if (!positiveAreaOnly || seed.signedFaceArea() > 0) {\n          const edge = mutate(seed);\n          if (edge) {\n            if (mappedEdges)\n              mappedEdges.push(edge);\n          } else {\n            if (unMappedSeeds)\n              unMappedSeeds.push(seed);\n          }\n        }\n      }\n    }\n  }\n\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Topology */\r\n/**\r\n * Class to accumulate statistics about a stream of signed numbers with tag items.\r\n * * All sums, counts, extrema, and item values are initialized to zero in the constructor.\r\n * * Each call to `announceItem (item, value)` updates the various sums, counts, and extrema.\r\n */\r\nexport class SignedDataSummary<T> {\r\n  /** sum of all positive area items */\r\n  public positiveSum: number;\r\n  /** number of positive area items */\r\n  public numPositive: number;\r\n  /** sum of negative area items */\r\n  public negativeSum: number;\r\n  /** number of negative area items */\r\n  public numNegative: number;\r\n  /** number of zero area items */\r\n  public numZero: number;\r\n  /** the tag item item with the largest positive data */\r\n  public largestPositiveItem?: T;\r\n  /** the tag item item with the most negative data */\r\n  public largestNegativeItem?: T;\r\n  public largestPositiveValue: number;\r\n  public largestNegativeValue: number;\r\n  /** array of all negative area items */\r\n  public negativeItemArray?: T[];\r\n  /** array of zero area items */\r\n  public zeroItemArray?: T[];\r\n  /** array of positive area items */\r\n  public positiveItemArray?: T[];\r\n  /** setup with zero sums and optional arrays */\r\n  public constructor(createArrays: boolean) {\r\n    this.positiveSum = this.negativeSum = 0.0;\r\n    this.numPositive = this.numNegative = this.numZero = 0.0;\r\n    this.largestPositiveValue = this.largestNegativeValue = 0.0;\r\n    if (createArrays) {\r\n      this.negativeItemArray = [];\r\n      this.positiveItemArray = [];\r\n      this.zeroItemArray = [];\r\n    }\r\n  }\r\n  /** update with an item and its data value. */\r\n  public announceItem(item: T, data: number) {\r\n    if (data < 0) {\r\n      this.numNegative++;\r\n      this.negativeSum += data;\r\n      if (this.negativeItemArray)\r\n        this.negativeItemArray.push(item);\r\n      if (data < this.largestNegativeValue) {\r\n        this.largestNegativeValue = data;\r\n        this.largestNegativeItem = item;\r\n      }\r\n    } else if (data > 0) {\r\n      this.numPositive++;\r\n      this.positiveSum += data;\r\n      if (this.positiveItemArray)\r\n        this.positiveItemArray.push(item);\r\n      if (data > this.largestPositiveValue) {\r\n        this.largestPositiveValue = data;\r\n        this.largestPositiveItem = item;\r\n      }\r\n    } else {\r\n      this.numZero++;\r\n      if (this.zeroItemArray)\r\n        this.zeroItemArray.push(item);\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n\nimport { HalfEdgeMask, HalfEdge, HalfEdgeGraph } from \"./Graph\";\nimport { XAndY, XYAndZ } from \"../geometry3d/XYZProps\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Geometry } from \"../Geometry\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\nimport { PointStreamXYZXYZHandlerBase, VariantPointDataStream } from \"../geometry3d/PointStreaming\";\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\nimport { InsertAndRetriangulateContext } from \"./InsertAndRetriangulateContext\";\nimport { MarkedEdgeSet } from \"./HalfEdgeMarkSet\";\n\n/**\n * type for use as signature for xyz data of a single linestring appearing in a parameter list.\n * @public\n */\nexport type LineStringDataVariant = IndexedXYZCollection | XYAndZ[] | XAndY[] | number[][];\n\n/**\n * type for use as signature for multiple xyz data of multiple linestrings appearing in a parameter list.\n * @public\n */\nexport type MultiLineStringDataVariant = LineStringDataVariant | LineStringDataVariant[];\n\n/**\n * (static) methods for triangulating polygons\n * * @internal\n */\nexport class Triangulator {\n\n  /** Given the six nodes that make up two bordering triangles, \"pinch\" and relocate the nodes to flip them\n   * * The shared edge mates are a and d.\n   * * (abc) are a triangle in CCW order\n   * * (dfe) are a triangle in CCW order. (!! node dfe instead of def.)\n   */\n  private static flipEdgeBetweenTriangles(a: HalfEdge, b: HalfEdge, c: HalfEdge, d: HalfEdge, e: HalfEdge, f: HalfEdge) {\n    // Reassign all of the pointers\n    HalfEdge.pinch(a, e);\n    HalfEdge.pinch(c, d);\n    HalfEdge.pinch(f, c);\n    HalfEdge.pinch(e, b);\n\n    // Move alpha and beta into the xy coordinates of their predecessors\n    e.x = b.x;\n    e.y = b.y;\n    e.z = b.z;\n    e.i = b.i;\n    c.i = f.i;\n    c.x = f.x;\n    c.y = f.y;\n    c.z = f.z;\n  }\n  /**\n   * * nodeA is a given node\n   * * nodeA1 is its nodeA.faceSuccessor\n   * * nodeA2 is nodeA1.faceSuccessor, i.e. 3rd node of triangle A\n   * * nodeB  is nodeA.edgeMate, i.e. a node in the \"other\" triangle at nodeA's edge\n   * * nodeB1 is nodeB.faceSuccessor\n   * * nodeB2 is nodeB1.faceSuccessor, i.e the 3rd node of triangle B\n   * Construct (as simple doubles, to avoid object creation) xy vectors from:\n   * * (ux,uy): nodeA to nodeA1, i.e. the shared edge\n   * * (vx,vy): nodeA to nodeA2,\n   * * (wx,wy): nodeA to nodeB2\n   * * this determinant is positive if nodeA is \"in the circle\" of nodeB2, nodeA1, nodeA2\n   * * Return true if clearly positive\n   * * Return false if clearly negative or almost zero.\n   * @param nodeA node on the diagonal edge of candidate for edge flip.\n   * @param if true, divide the determinant by the sum of absolute values of the cubic terms of the determinant.\n   * @return the determinant as modified per comment (but undefined if the faces are not triangles as expected.)\n   */\n  public static computeInCircleDeterminantIsStrongPositive(nodeA: HalfEdge): boolean {\n    const nodeA1 = nodeA.faceSuccessor;\n    const nodeA2 = nodeA1.faceSuccessor;\n    if (nodeA2.faceSuccessor !== nodeA)\n      return false;\n    const nodeB = nodeA.edgeMate;\n    const nodeB1 = nodeB.faceSuccessor;\n    const nodeB2 = nodeB1.faceSuccessor;\n    if (nodeB2.faceSuccessor !== nodeB)\n      return false;\n    const ux = nodeA1.x - nodeA.x;\n    const uy = nodeA1.y - nodeA.y;\n    const vx = nodeA2.x - nodeA.x;\n    const vy = nodeA2.y - nodeA.y;\n    if (Geometry.crossProductXYXY(ux, uy, vx, vy) < 0)\n      return false;\n    // we assume identical coordinates in pairs (nodeA, nodeB1)  and (nodeA1, nodeB)\n    const wx = nodeB2.x - nodeA.x;\n    const wy = nodeB2.y - nodeA.y;\n    const tx = wx * wx + wy * wy;\n    const ty = vx * vx + vy * vy;\n    const tz = ux * ux + uy * uy;\n    const q = Geometry.tripleProduct(\n      wx, wy, tx,\n      vx, vy, ty,\n      ux, uy, tz);\n    if (q < 0)\n      return false;\n    const denom = Math.abs(wx * vy * tz) + Math.abs(wx * ty * ux) + Math.abs(tx * vx * uy)\n      + Math.abs(wx * ty * uy) + Math.abs(wy * vx * tz) + Math.abs(tx * vy * ux);\n    return q > 1.0e-12 * denom;\n  }\n\n  /**\n   *  *  Visit each node of the graph array\n   *  *  If a flip would be possible, test the results of flipping using incircle condition\n   *  *  If revealed to be an improvement, conduct the flip, mark involved nodes as unvisited, and repeat until all nodes are visited\n   */\n  public static flipTriangles(graph: HalfEdgeGraph): number {\n    const edgeSet = MarkedEdgeSet.create(graph)!;\n    for (const node of graph.allHalfEdges)\n      edgeSet.addToSet(node);\n    const numFlip = this.flipTrianglesInEdgeSet(graph, edgeSet);\n    edgeSet.teardown();\n    return numFlip;\n  }\n\n  /**\n   *  *  Visit each node of the graph array\n   *  *  If a flip would be possible, test the results of flipping using incircle condition\n   *  *  If revealed to be an improvement, conduct the flip, mark involved nodes as unvisited, and repeat until all nodes are visited\n   */\n  public static flipTrianglesInEdgeSet(graph: HalfEdgeGraph, edgeSet: MarkedEdgeSet): number {\n    const barrierMasks = HalfEdgeMask.EXTERIOR | HalfEdgeMask.PRIMARY_EDGE | HalfEdgeMask.BOUNDARY_EDGE;\n\n    const nodeArray = graph.allHalfEdges;\n    const maxTest = 10.0 * nodeArray.length;\n    let numFlip = 0;\n    let numOK = 0;\n    let node;\n    while (undefined !== (node = edgeSet.chooseAndRemoveAny())) {\n\n      if (node.isMaskSet(barrierMasks)) // Flip not allowed\n        continue;\n\n      if (Triangulator.computeInCircleDeterminantIsStrongPositive(node)) {\n        // Flip the triangles\n        Triangulator.flipEdgeBetweenTriangles(node.edgeMate.faceSuccessor, node.edgeMate.facePredecessor, node.edgeMate, node.faceSuccessor, node, node.facePredecessor);\n        // keep looking at the 2 faces\n        edgeSet.addAroundFace(node);\n        edgeSet.addAroundFace(node.edgeMate);\n        numFlip++;\n      } else {\n        numOK++;\n      }\n      if (numFlip + numOK > maxTest)\n        break;\n    }\n    return numFlip;\n  }\n\n  /** Create a graph with a triangulation points.\n   * * The outer limit of the graph is the convex hull of the points.\n   * * The outside loop is marked `HalfEdgeMask.EXTERIOR`\n   */\n  public static createTriangulatedGraphFromPoints(points: Point3d[]): HalfEdgeGraph | undefined {\n    if (points.length < 3)\n      return undefined;\n    const hull: Point3d[] = [];\n    const interior: Point3d[] = [];\n    Point3dArray.computeConvexHullXY(points, hull, interior, true);\n    const graph = new HalfEdgeGraph();\n    const context = InsertAndRetriangulateContext.create(graph);\n    Triangulator.createFaceLoopFromCoordinates(graph, hull, true, true);\n    // HalfEdgeGraphMerge.clusterAndMergeXYTheta(graph);\n    let numInsert = 0;\n    for (const p of interior) {\n      context.insertAndRetriangulate(p, true);\n      numInsert++;\n      if (numInsert > 16) {\n        /*\n        context.reset();\n        Triangulator.flipTriangles(context.graph);\n        // console.log (\" intermediate flips \" + numFlip);\n        */\n        numInsert = 0;\n      }\n    }\n    /*\n        // final touchup for aspect ratio flip\n        for (let i = 0; i < 15; i++) {\n          const numFlip = Triangulator.flipTriangles(graph);\n          if (numFlip === 0)\n            break;\n        }\n        */\n    return graph;\n  }\n  /**\n   * * Only one outer loop permitted.\n   * * Largest area loop is assumed outer.\n   * @param loops an array of loops as GrowableXYZArray or XAndY[]\n   * @returns triangulated graph, or undefined if bad data.\n   */\n  public static createTriangulatedGraphFromLoops(loops: GrowableXYZArray[] | XAndY[][]): HalfEdgeGraph | undefined {\n    if (loops.length < 1)\n      return undefined;\n    const mask = HalfEdgeMask.BOUNDARY_EDGE | HalfEdgeMask.PRIMARY_EDGE;\n    const graph = new HalfEdgeGraph();\n    const holeSeeds: HalfEdge[] = [];\n    let maxArea = -10000.0;\n    let maxAreaIndex = -1;\n    // collect all the loops with pointers to the positive (inside)\n    // remember which one has largest area.\n    for (let i = 0; i < loops.length; i++) {\n      let seed = Triangulator.directCreateFaceLoopFromCoordinates(graph, loops[i]);\n      if (seed) {\n        seed = seed.faceSuccessor;  // directCreate returns tail\n        const mate = seed.vertexSuccessor;\n        seed.setMaskAroundFace(mask);\n        mate.setMaskAroundFace(mask);\n        const signedFaceArea = seed.signedFaceArea();\n        const area = Math.abs(signedFaceArea);\n        holeSeeds.push(signedFaceArea >= 0 ? seed : mate);\n        if (i === 0 || area > maxArea) {\n          maxArea = area;\n          maxAreaIndex = i;\n        }\n      }\n    }\n    if (holeSeeds.length === 0)\n      return undefined;\n    // extract the max area seed ...\n    const maxAreaFace = holeSeeds[maxAreaIndex];\n    holeSeeds[maxAreaIndex] = holeSeeds[holeSeeds.length - 1];\n    holeSeeds.pop();\n    maxAreaFace.vertexSuccessor.setMaskAroundFace(HalfEdgeMask.EXTERIOR);\n    // The hole seeds all have inside nodes.  Set mask there and jump to outside.\n    for (let i = 0; i < holeSeeds.length; i++) {\n      const seed = holeSeeds[i];\n      seed.setMaskAroundFace(HalfEdgeMask.EXTERIOR);\n      holeSeeds[i] = this.getLeftmost(seed.vertexSuccessor);\n    }\n\n    const startingNode = Triangulator.spliceLeftMostNodesOfHoles(graph, maxAreaFace, holeSeeds);\n    Triangulator.triangulateSingleFace(graph, startingNode);\n    return graph;\n  }\n  /**\n   * Triangulate all positive area faces of a graph.\n   */\n  public static triangulateAllPositiveAreaFaces(graph: HalfEdgeGraph) {\n    const seeds = graph.collectFaceLoops();\n    for (const face of seeds) {\n      if (face.countEdgesAroundFace() > 3) {\n        const area = face.signedFaceArea();\n        if (area > 0.0)\n          Triangulator.triangulateSingleFace(graph, face);\n      }\n    }\n\n  }\n\n  /**\n   * Triangulate the polygon made up of by a series of points.\n   * * The loop may be either CCW or CW -- CCW order will be used for triangles.\n   * * To triangulate a polygon with holes, use createTriangulatedGraphFromLoops\n   */\n  public static createTriangulatedGraphFromSingleLoop(data: XAndY[] | GrowableXYZArray): HalfEdgeGraph {\n    const graph = new HalfEdgeGraph();\n    const startingNode = Triangulator.createFaceLoopFromCoordinates(graph, data, true, true);\n\n    if (!startingNode || graph.countNodes() < 6) return graph;\n\n    Triangulator.triangulateSingleFace(graph, startingNode);\n    Triangulator.flipTriangles(graph);\n    return graph;\n  }\n\n  /**\n   * cautiously split the edge starting at baseNode.\n   * * If baseNode is null, create a trivial loop with the single vertex at xy\n   * * if xy is distinct from the coordinates at both baseNode and its successor, insert xy as a new node within that edge.\n   * * also include z coordinate if present.\n   */\n  private static interiorEdgeSplit(graph: HalfEdgeGraph, baseNode: HalfEdge | undefined, xy: XAndY | number[]): HalfEdge | undefined {\n    let x = 0, y = 0, z = 0;\n    if (Array.isArray(xy)) {\n      x = xy[0];\n      y = xy[1];\n      z = xy.length > 2 ? xy[3] : 0.0;\n    } else {\n      const q = xy as any;\n      if (q.hasOwnProperty(\"x\")) x = q.x;\n      if (q.hasOwnProperty(\"y\")) y = q.y;\n      if (q.hasOwnProperty(\"y\")) z = q.z;\n    }\n    if (!baseNode)\n      return graph.splitEdge(baseNode, x, y, z);\n    if (Triangulator.equalXAndYXY(baseNode, x, y))\n      return baseNode;\n    if (Triangulator.equalXAndYXY(baseNode.faceSuccessor, x, y))\n      return baseNode;\n    return graph.splitEdge(baseNode, x, y, z);\n  }\n  /** Create a loop from coordinates.\n   * * Return a pointer to any node on the loop.\n   * * no masking or other markup is applied.\n   */\n  public static directCreateFaceLoopFromCoordinates(graph: HalfEdgeGraph, data: LineStringDataVariant): HalfEdge | undefined {\n    // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors\n    let baseNode: HalfEdge | undefined;\n    if (data instanceof IndexedXYZCollection) {\n      const xyz = Point3d.create();\n      for (let i = 0; i < data.length; i++) {\n        data.getPoint3dAtCheckedPointIndex(i, xyz);\n        baseNode = Triangulator.interiorEdgeSplit(graph, baseNode, xyz);\n      }\n    } else {\n      for (const xy of data) {\n        baseNode = Triangulator.interiorEdgeSplit(graph, baseNode, xy);\n      }\n    }\n    return baseNode;\n  }\n\n  /** Create chains from coordinates.\n   * * Return array of pointers to base node of the chains.\n   * * no masking or other markup is applied.\n   * @param graph New edges are built in this graph\n   * @param data coordinate data\n   * @param id id to attach to (both side of all) edges\n   */\n  public static directCreateChainsFromCoordinates(graph: HalfEdgeGraph, data: MultiLineStringDataVariant, id: number = 0): HalfEdge[] {\n    // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors\n    const assembler = new AssembleXYZXYZChains(graph, id);\n    VariantPointDataStream.streamXYZ(data, assembler);\n    return assembler.claimSeeds();\n  }\n\n  /**\n   * @param graph the containing graph\n   * @param base The last node of a newly created loop.  (i.e. its `faceSuccessor` has the start xy)\n   * @param returnPositiveAreaLoop if true, return the start node on the side with positive area.  otherwise return the left side as given.\n   * @param maskForBothSides mask to apply on both sides.\n   * @param maskForOtherSide mask to apply to the \"other\" side of the loop.\n   * @return the loop's start node or its vertex successor, chosen to be the positive or negative loop per request.\n   */\n  private static maskAndOrientNewFaceLoop(_graph: HalfEdgeGraph, base: HalfEdge | undefined, returnPositiveAreaLoop: boolean,\n    maskForBothSides: HalfEdgeMask,\n    maskForOtherSide: HalfEdgeMask): HalfEdge | undefined {\n    // base is the final coordinates\n    if (base) {\n      base = base.faceSuccessor; // because typical construction process leaves the \"live\" edge at the end of the loop.\n      const area = base.signedFaceArea();\n      const mate = base.edgeMate;\n      if (maskForBothSides !== HalfEdgeMask.NULL_MASK) {\n        base.setMaskAroundFace(maskForBothSides);\n        mate.setMaskAroundFace(maskForBothSides);\n      }\n\n      let preferredNode = base;\n      if (returnPositiveAreaLoop && (area < 0))\n        preferredNode = mate;\n      const otherNode = preferredNode.vertexSuccessor;\n\n      if (maskForOtherSide !== HalfEdgeMask.NULL_MASK)\n        otherNode.setMaskAroundFace(maskForOtherSide);\n      return preferredNode;\n    }\n    return undefined;\n  }\n  /**\n   * create a circular doubly linked list of internal and external nodes from polygon points in the specified winding order\n   * * This applies the masks used by typical applications:\n   *   * HalfEdgeMask.BOUNDARY on both sides\n   *   * HalfEdgeMask.PRIMARY_EDGE on both sides.\n   * * Use `createFaceLoopFromCoordinatesAndMasks` for detail control of masks.\n   */\n  public static createFaceLoopFromCoordinates(graph: HalfEdgeGraph, data: LineStringDataVariant, returnPositiveAreaLoop: boolean, markExterior: boolean): HalfEdge | undefined {\n    const base = Triangulator.directCreateFaceLoopFromCoordinates(graph, data);\n    return Triangulator.maskAndOrientNewFaceLoop(graph, base, returnPositiveAreaLoop,\n      HalfEdgeMask.BOUNDARY_EDGE | HalfEdgeMask.PRIMARY_EDGE,\n      markExterior ? HalfEdgeMask.EXTERIOR : HalfEdgeMask.NULL_MASK);\n  }\n\n  /**\n   * create a circular doubly linked list of internal and external nodes from polygon points.\n   * * Optionally jump to the \"other\" side so the returned loop has positive area\n   * @param graph graph to receive the new edges\n   * @param data array with x,y coordinates\n   * @param returnPositiveAreaLoop if false, return an edge proceeding around the loop in the order given.  If true, compute the loop area and flip return the side with positive area.\n   * @param maskForBothSides mask to apply on both sides.\n   * @param maskForOtherSide mask to apply on the \"other\" side from the returned loop.\n   */\n  public static createFaceLoopFromCoordinatesAndMasks(graph: HalfEdgeGraph, data: LineStringDataVariant, returnPositiveAreaLoop: boolean,\n    maskForBothSides: HalfEdgeMask,\n    maskForOtherSide: HalfEdgeMask): HalfEdge | undefined {\n    const base = Triangulator.directCreateFaceLoopFromCoordinates(graph, data);\n    return Triangulator.maskAndOrientNewFaceLoop(graph, base, returnPositiveAreaLoop, maskForBothSides, maskForOtherSide);\n  }\n\n  /** Cut off an ear, forming a new face loop of nodes\n   * @param ear the vertex being cut off.\n   * *  Form two new nodes, alpha and beta, which have the coordinates one step away from the ear vertex.\n   * *  Reassigns the pointers such that beta is left behind with the new face created\n   * *  Reassigns the pointers such that alpha becomes the resulting missing node from the remaining polygon\n   * * Reassigns prevZ and nextZ pointers\n   */\n  private static joinNeighborsOfEar(graph: HalfEdgeGraph, ear: HalfEdge) {\n    const alpha = graph.createEdgeXYZXYZ(\n      ear.facePredecessor.x, ear.facePredecessor.y, ear.facePredecessor.z, ear.facePredecessor.i,\n      ear.faceSuccessor.x, ear.faceSuccessor.y, ear.faceSuccessor.z, ear.faceSuccessor.i);\n    const beta = alpha.edgeMate;\n\n    // Add two nodes alpha and beta and reassign pointers (also mark triangle nodes as part of triangle)\n    HalfEdge.pinch(ear.faceSuccessor, beta);\n    HalfEdge.pinch(ear.facePredecessor, alpha);\n    ear.setMaskAroundFace(HalfEdgeMask.TRIANGULATED_FACE);\n  }\n  private static isInteriorTriangle(a: HalfEdge) {\n    if (!a.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE))\n      return false;\n    const b = a.faceSuccessor;\n    if (!b.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE))\n      return false;\n    const c = b.faceSuccessor;\n    if (!c.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE))\n      return false;\n    return c.faceSuccessor === a;\n  }\n\n  /**\n   * Perform 0, 1, or more edge flips to improve aspect ratio just behind an that was just cut.\n   * @param ear the triangle corner which just served as the ear node.\n   * @returns the node at the back corner after flipping.\"appropriately positioned\" node for the usual advance to ear.faceSuccessor.edgeMate.faceSuccessor.\n   */\n  private static doPostCutFlips(ear: HalfEdge) {\n    //    B is the ear -- inside a (probably newly created) triangle ABC\n    //    CA is the recently added cut edge.\n    //    AB is the candidate to be flipped.\n    //    triangle B1 A1 D is on the other side of AB\n    //    The condition for flipping is:\n    //           ! both triangles must be TRIANGULATED_NODE_MASK\n    //           ! incircle condition flags D as in the circle of ABC\n    //     after flip, node A moves to the vertex of D, and is the effective \"ear\",  with the cap edge C A1\n    //      after flip, consider the A1 D (whose nodes are A1 and flipped A!!!)\n    //\n    //\n    //                                   . C0|\n    //                              .        |\n    //                           .           |\n    //                       .              ^|\n    //                   .  A0 ---->       B0|\n    //               *=======================*\n    //                 \\ A1     <----   B1/\n    //                   \\             /\n    //                     \\         /\n    //                       \\  D1 /\n    //                          *\n    let b0 = ear;\n    let a0 = b0.facePredecessor;\n    let b1 = a0.edgeMate;\n    while (Triangulator.isInteriorTriangle(a0) && Triangulator.isInteriorTriangle(b1)) {\n      const detA = Triangulator.computeInCircleDeterminantIsStrongPositive(a0);\n      if (!detA)\n        break;\n      // Flip the triangles\n      const a1 = b1.faceSuccessor;\n      Triangulator.flipEdgeBetweenTriangles(a1, a1.faceSuccessor, a1.facePredecessor, b0, b0.facePredecessor, b0.faceSuccessor);\n      b0 = a0;\n      a0 = b0.facePredecessor;\n      b1 = a0.edgeMate;\n    }\n    return b0;\n  }\n\n  /**\n   * main ear slicing loop which triangulates a polygon (given as a linked list)\n   * While there still exists ear nodes that have not yet been triangulated...\n   *\n   * *  Check if the ear is hashed, and can easily be split off. If so, \"join\" that ear.\n   * *  If not hashed, move on to a separate ear.\n   * *  If no ears are currently hashed, attempt to cure self intersections or split the polygon into two before continuing\n   */\n  private static triangulateSingleFace(graph: HalfEdgeGraph, ear?: HalfEdge) {\n    if (!ear) return;\n\n    let next;\n    let next2;\n    let maxCandidate = ear.countEdgesAroundFace();\n    let numCandidate = 0;\n    ear.clearMaskAroundFace(HalfEdgeMask.TRIANGULATED_FACE);\n    // iterate through ears, slicing them one by one\n    while (!ear.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE)) {\n      next = ear.faceSuccessor;\n      next2 = next.faceSuccessor;\n      if (next === ear || next2 === ear || next2.faceSuccessor === ear)\n        break;\n      if (++numCandidate > maxCandidate)\n        break;\n      if (Triangulator.isEar(ear)) {\n        maxCandidate--;\n        numCandidate = 0;\n\n        // skipping the next vertices leads to less sliver triangles\n\n        // If we already have a separated triangle, do not join\n        if (ear.faceSuccessor.faceSuccessor !== ear.facePredecessor) {\n          Triangulator.joinNeighborsOfEar(graph, ear);\n          ear = Triangulator.doPostCutFlips(ear);\n          ear = ear.faceSuccessor.edgeMate.faceSuccessor;\n          // another step?   Nate's 2017 code went one more.\n        } else {\n          ear.setMaskAroundFace(HalfEdgeMask.TRIANGULATED_FACE);\n          ear = next.faceSuccessor;\n        }\n        continue;\n      }\n      ear = next;\n    }\n  }\n\n  /** Check whether a polygon node forms a valid ear with adjacent nodes */\n  private static isEar(ear: HalfEdge) {\n    const a = ear.facePredecessor;\n    const b = ear;\n    const c = ear.faceSuccessor;\n\n    if (Triangulator.signedTriangleArea(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    let p = ear.faceSuccessor.faceSuccessor;\n\n    while (p !== ear.facePredecessor) {\n      if (Triangulator.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n        Triangulator.signedTriangleArea(p.facePredecessor, p, p.faceSuccessor) >= 0) return false;\n      p = p.faceSuccessor;\n    }\n\n    return true;\n  }\n  /** link holeLoopNodes[1], holeLoopNodes[2] etc into the outer loop, producing a single-ring polygon without holes\n   *\n   */\n  private static spliceLeftMostNodesOfHoles(graph: HalfEdgeGraph, outerNode: HalfEdge, leftMostHoleLoopNode: HalfEdge[]) {\n\n    leftMostHoleLoopNode.sort(Triangulator.compareX);\n\n    // process holes from left to right\n    for (const holeStart of leftMostHoleLoopNode) {\n      Triangulator.eliminateHole(graph, holeStart, outerNode);\n    }\n\n    return outerNode;\n  }\n  /** For use in sorting -- return (signed) difference (a.x - b.x) */\n  private static compareX(a: HalfEdge, b: HalfEdge) {\n    return a.x - b.x;\n  }\n\n  /** find a bridge between vertices that connects hole with an outer ring and and link it */\n  private static eliminateHole(graph: HalfEdgeGraph, hole: HalfEdge, outerNode: HalfEdge) {\n    const outerNodeA = Triangulator.findHoleBridge(hole, outerNode);\n    if (outerNodeA) {\n      Triangulator.splitFace(graph, outerNodeA, hole);\n    }\n  }\n  // cspell:word Eberly\n  /**\n   *  David Eberly algorithm for finding a bridge between hole and outer polygon:\n   *  https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n   */\n  private static findHoleBridge(hole: HalfEdge, outerNode?: HalfEdge): HalfEdge | undefined {\n    let p = outerNode;\n\n    if (!p)\n      return undefined;\n\n    const hx = hole.x;\n    const hy = hole.y;\n    let qx = -Infinity;\n    let m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n      if (hy <= p.y && hy >= p.faceSuccessor.y && p.faceSuccessor.y !== p.y) {\n        const x = p.x + (hy - p.y) * (p.faceSuccessor.x - p.x) / (p.faceSuccessor.y - p.y);\n        if (x <= hx && x > qx) {\n          qx = x;\n          if (x === hx) {\n            if (hy === p.y) return p;\n            if (hy === p.faceSuccessor.y) return p.faceSuccessor;\n          }\n          m = p.x < p.faceSuccessor.x ? p : p.faceSuccessor;\n        }\n      }\n      p = p.faceSuccessor;\n    } while (p !== outerNode);\n\n    if (!m) return undefined;\n\n    if (hx === qx) return m.facePredecessor; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    const stop = m;\n    const mx = m.x;\n    const my = m.y;\n    let tanMin = Infinity;\n    let tan;\n\n    p = m.faceSuccessor;\n\n    while (p !== stop) {\n      if (hx >= p.x && p.x >= mx && hx !== p.x &&\n        Triangulator.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n        tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n        if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Triangulator.locallyInside(p, hole)) {\n          m = p;\n          tanMin = tan;\n        }\n      }\n\n      p = p.faceSuccessor;\n    }\n\n    return m;\n  }\n\n  // find the leftmost node of a polygon ring\n  private static getLeftmost(start: HalfEdge) {\n    let p = start;\n    let leftmost = start;\n    do {\n      if (p.x < leftmost.x) leftmost = p;\n      p = p.faceSuccessor;\n    } while (p !== start);\n\n    return leftmost;\n  }\n\n  /** check if a point lies within a convex triangle */\n  private static pointInTriangle(ax: number, ay: number, bx: number, by: number, cx: number, cy: number, px: number, py: number) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n      (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n      (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n  }\n\n  /** signed area of a triangle */\n  private static signedTriangleArea(p: HalfEdge, q: HalfEdge, r: HalfEdge) {\n    return 0.5 * ((q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y));\n  }\n\n  /** check if two points are equal */\n  private static equalXAndYXY(p1: XAndY, x: number, y: number) {\n    return Geometry.isSameCoordinate(p1.x, x) && Geometry.isSameCoordinate(p1.y, y);\n  }\n\n  /** check if a polygon diagonal is locally inside the polygon */\n  private static locallyInside(a: HalfEdge, b: HalfEdge) {\n    return Triangulator.signedTriangleArea(a.facePredecessor, a, a.faceSuccessor) < 0 ?\n      Triangulator.signedTriangleArea(a, b, a.faceSuccessor) >= 0 && Triangulator.signedTriangleArea(a, a.facePredecessor, b) >= 0 :\n      Triangulator.signedTriangleArea(a, b, a.facePredecessor) < 0 || Triangulator.signedTriangleArea(a, a.faceSuccessor, b) < 0;\n  }\n\n  /**\n   * link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n   * if one belongs to the outer ring and another to a hole, it merges it into a single ring\n   * * Returns the base of the new edge at the \"a\" end.\n   * * \"a\" and \"b\" still represent the same physical pieces of edges\n   * @returns Returns the (base of) the new half edge, at the \"a\" end.\n   */\n  private static splitFace(graph: HalfEdgeGraph, a: HalfEdge, b: HalfEdge): HalfEdge {\n    const a2 = graph.createEdgeXYZXYZ(a.x, a.y, a.z, a.i, b.x, b.y, b.z, b.i);\n    const b2 = a2.faceSuccessor;\n\n    HalfEdge.pinch(a, a2);\n    HalfEdge.pinch(b, b2);\n\n    return a2;\n  }\n\n  /**\n   * Triangulate a single face with (linear time) logic applicable only if the lowNode is the lowest node.\n   * @returns false if any monotonicity condition is violated.\n   */\n  public static triangulateSingleMonotoneFace(graph: HalfEdgeGraph, start: HalfEdge): boolean {\n    let left = start.facePredecessor;\n    let right = start.faceSuccessor;\n    // P0, P1, P2 are successive edges along evolving chain\n    let P0: HalfEdge = start;  // will be reinitialized -- use start to quiet linter\n    let P1: HalfEdge = start;  // will be reinitialized -- use start to quiet linter\n    let P2: HalfEdge = start;  // will be reinitialized -- use start to quiet linter\n    let upperSideOfNewEdge;\n    while (left !== right\n      && right !== start\n      && right.faceSuccessor !== left) {\n      /** These should not happen if face is monotone . .. */\n      if (HalfEdge.crossProductXYAlongChain(left, start, right) <= 0)\n        return false;\n      if (!start.belowYX(left))\n        return false;\n      if (!start.belowYX(right))\n        return false;\n      if (left.belowYX(right)) {\n        /*      Triangulate to all left side edges that\n           are below right */\n\n        /*      Phase 1: move upward, adding back edges\n           when prior nodes are visible. */\n        P0 = left;\n        P1 = start;\n        P2 = right;\n        /*      Invariant: the path from P0 back to P1 is concave.\n           Each loop pass moves P0 up the left side, filling in\n           edges as needed.  The right side edge\n           (following start) is never altered.\n         */\n        while (P0 !== P2 && P0.belowYX(right)) {\n          while (P2 !== right\n            && P2 !== P0\n            && P2 !== P1\n            && HalfEdge.crossProductXYAlongChain(P0, P1, P2) > 0) {\n            upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);\n            P0 = upperSideOfNewEdge;\n            P1 = P0.faceSuccessor;\n            P2 = P1.faceSuccessor;\n          }\n          P2 = P1;\n          P1 = P0;\n          P0 = P0.facePredecessor;\n        }\n        /*      Phase 2: Fan out edges from right to the\n           left side. P0.P1.P2 describes a pair of\n           adjacent edges at the bottom. */\n        left = P1;\n        P2 = right;\n        P1 = P2.facePredecessor;\n        P0 = P1.facePredecessor;\n        while (P2.faceSuccessor !== P0 && P0 !== left) {\n          upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);\n          P1 = upperSideOfNewEdge;\n          P0 = P1.facePredecessor;\n        }\n        /*      Finish off with the last stroke from the\n           left node to the right, except when already\n           topped out */\n        if (P2.faceSuccessor !== P0) {\n          upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);\n          P0 = upperSideOfNewEdge;\n        }\n        start = P0;\n        right = start.faceSuccessor;\n        left = start.facePredecessor;\n\n      } else {\n        /*      Triangulate to all right side edges that\n           are below left */\n\n        /*      Phase 1: move upward, adding back edges\n           when prior nodes are visible. */\n        P0 = left;\n        P1 = start;\n        P2 = right;\n        /*      Invariant: the path up to P1 is concave.\n           Each loop pass advances P1, filling in\n           edges as needed. Note that the\n           start edge may get hidden, so the\n           bottom node must be referenced as\n           left.faceSuccessor rather than as start.\n         */\n        while (P0 !== P2 && P2.belowYX(left)) {\n          while (P0 !== left\n            && P2 !== P0\n            && P2 !== P1\n            && HalfEdge.crossProductXYAlongChain(P0, P1, P2) > 0) {\n            upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);\n            P0 = upperSideOfNewEdge.facePredecessor;\n            P1 = upperSideOfNewEdge;\n          }\n          P0 = P1;\n          P1 = P2;\n          P2 = P2.faceSuccessor;\n        }\n        /*      Phase 2: Fan out edges from left to the\n           right side. P0.P1.P2 describes a pair of\n           adjacent edges at the bottom. */\n        right = P1;\n        P0 = left;\n        P1 = P0.faceSuccessor;\n        P2 = P1.faceSuccessor;\n        while (P2.faceSuccessor !== P0 && P2 !== right) {\n          upperSideOfNewEdge = Triangulator.splitFace(graph, P0, P2);\n          P0 = upperSideOfNewEdge;\n          P1 = P2;\n          P2 = P2.faceSuccessor;\n        }\n        /*      Finish off with the last stroke from the\n           left node to the right, except when already\n           topped out */\n        if (P2.faceSuccessor !== P0) {\n          Triangulator.splitFace(graph, P0, P2);\n        }\n        start = right;\n        right = start.faceSuccessor;\n        left = start.facePredecessor;\n      }\n    }\n    return true;\n  }\n\n}\n\n/**\n * Internal class for assembling chains\n * @internal\n */\nclass AssembleXYZXYZChains extends PointStreamXYZXYZHandlerBase {\n  // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors\n  private _seeds?: HalfEdge[];\n  private _baseNode: HalfEdge | undefined;\n  private _nodeB: HalfEdge | undefined;\n  private _nodeC: HalfEdge | undefined;\n  private _graph: HalfEdgeGraph;\n  private _id: any;\n  public constructor(graph: HalfEdgeGraph, id: any) {\n    super();\n    this._graph = graph;\n    this._id = id;\n  }\n  public startChain(chainData: MultiLineStringDataVariant, isLeaf: boolean): void {\n    super.startChain(chainData, isLeaf);\n    this._baseNode = undefined;\n    this._nodeB = undefined;\n  }\n  public handleXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number) {\n    this._nodeC = this._graph.createEdgeXYZXYZ(x0, y0, z0, this._id, x1, y1, z1, this._id);\n    if (this._baseNode === undefined) {\n      this._baseNode = this._nodeC;\n      this._nodeB = this._baseNode!.faceSuccessor;\n    } else {\n      HalfEdge.pinch(this._nodeB!, this._nodeC);\n      this._nodeB = this._nodeC!.faceSuccessor;\n    }\n  }\n  public endChain(chainData: MultiLineStringDataVariant, isLeaf: boolean): void {\n    super.endChain(chainData, isLeaf);\n    if (this._baseNode !== undefined) {\n      if (this._seeds === undefined)\n        this._seeds = [];\n      this._seeds.push(this._baseNode);\n    }\n    this._baseNode = undefined;\n    this._nodeB = undefined;\n    this._nodeC = undefined;\n  }\n  public claimSeeds(): HalfEdge[] {\n    if (this._seeds === undefined)\n      return [];\n    return this._seeds;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Topology */\r\n\r\n/**\r\n * * XYParitySearchContext is an internal class for callers that can feed points (without extracting to array structures)\r\n * * Most will be via static methods which handle a specific data source.\r\n *   * PolygonOps.classifyPointInPolygon (x,y,points: XAndY[])\r\n *   * HalfEdgeGraphSearch.pointInOrOnFaceXY (halfEdgeOnFace, x, y)\r\n * Use pattern:\r\n * * Caller must be able walk around polygon producing x,y coordinates (possibly transformed from actual polygon)\r\n * * Caller announce edges to tryStartEdge until finding one acceptable to the search.\r\n * * Caller then passes additional points up to and including both x0,y0 and x1, y1 of the accepted start edge.\r\n * Call sequence is:\r\n *    `context = new XYParitySearchContext`\r\n *    `repeat {  acquire edge (x0,y0) (x1,y1)} until context.tryStartEdge (x0,y0,x1,y1);`\r\n *    `for each (x,y) beginning AFTER x1,y1 and ending with (x1,y1) context.advance (x,y)`\r\n *  `return context.classifyCounts ();`\r\n */\r\nexport class XYParitySearchContext {\r\n  public xTest: number;\r\n  public yTest: number;\r\n  public u0: number; // local coordinates of recent point with nonzero v.  Usually \"second last point\" but points can be skipped if y1 is zero\r\n  public v0: number;\r\n  public u1: number; // local coordinates of most recent point\r\n  public v1: number;\r\n  public numLeftCrossing: number;\r\n  public numRightCrossing: number;\r\n  public numHit: number;\r\n  /**\r\n   * Create a new searcher for specified test point.\r\n   * @param xTest x coordinate of test point\r\n   * @param yTest y coordinate of test point\r\n   */\r\n  public constructor(xTest: number, yTest: number) {\r\n    this.xTest = xTest;\r\n    this.yTest = yTest;\r\n    this.u0 = this.v0 = this.u1 = this.v1 = 0; // Not valid for search -- caller must satisfy tryStartEdge !!!\r\n    this.numLeftCrossing = this.numRightCrossing = 0;\r\n    this.numHit = 0;\r\n  }\r\n  /**\r\n   * test if x,y is a safe first coordinate to start the search.\r\n   * * safe start must have non-zero y so that final point test (return to x0,y0) does not need look back for exact crossing logic.\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public tryStartEdge(x0: number, y0: number, x1: number, y1: number): boolean {\r\n    if (y0 !== this.yTest) {\r\n      this.u0 = x0 - this.xTest;\r\n      this.v0 = y0 - this.yTest;\r\n      this.u1 = x1 - this.xTest;\r\n      this.v1 = y1 - this.yTest;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** Return true if parity accumulation proceeded normally.\r\n   * Return false if interrupted for exact hit.\r\n   */\r\n  public advance(x: number, y: number): boolean {\r\n    const u = x - this.xTest;\r\n    const v = y - this.yTest;\r\n    const p = v * this.v1;\r\n    if (p > 0) {\r\n      // The common case -- skittering along above or below the x axis . . .\r\n      this.u0 = this.u1;\r\n      this.v0 = this.v1;\r\n      this.u1 = u;\r\n      this.v1 = v;\r\n      return true;\r\n    }\r\n    if (p < 0) {\r\n      // crossing within (u1,v1) to (u,v)\r\n      // both v values are nonzero and of opposite sign, so this division is safe . . .\r\n      const fraction = -this.v1 / (v - this.v1);\r\n      const uCross = this.u1 + fraction * (u - this.u1);\r\n      if (uCross === 0.0) {\r\n        this.numHit++;\r\n        return false;\r\n      }\r\n      if (uCross > 0)\r\n        this.numRightCrossing++;\r\n      else\r\n        this.numLeftCrossing++;\r\n      this.u0 = this.u1;\r\n      this.v0 = this.v1;\r\n      this.u1 = u;\r\n      this.v1 = v;\r\n      return true;\r\n    }\r\n    // hard stuff -- one or more exact hits . . .\r\n    if (v === 0.0) {\r\n      if (this.v1 === 0.0) {\r\n        // uh oh -- moving along x axis.  Does it pass through xTest:\r\n        if (u * this.u1 <= 0.0) {\r\n          this.numHit++;\r\n          return false;\r\n        }\r\n        // quietly moving along the scan line, both xy and x1y1 to same side of test point ...\r\n        // u0 and u1 remain unchanged !!!\r\n        this.u1 = u;\r\n        this.v1 = v;\r\n        return true;\r\n      }\r\n      // just moved onto the scan line ...\r\n      this.u0 = this.u1;\r\n      this.v0 = this.v1;\r\n      this.u1 = u;\r\n      this.v1 = v;\r\n      return true;\r\n    }\r\n    // fall out with v1 = 0\r\n    // both v0 and v are nonzero.\r\n    // any along-0 v values that have passed through are on the same side of xTest, so u1 determines crossing\r\n    const q = this.v0 * v;\r\n    if (this.u1 > 0) {\r\n      if (q < 0)\r\n        this.numRightCrossing++;\r\n    } else {\r\n      if (q < 0)\r\n        this.numLeftCrossing++;\r\n    }\r\n    this.u0 = this.u1;\r\n    this.v0 = this.v1;\r\n    this.u1 = u;\r\n    this.v1 = v;\r\n    return true;\r\n  }\r\n  /**\r\n   * Return classification as ON, IN, or OUT according to hit and crossing counts.\r\n   * * Any nonzero hit count is ON\r\n   * * Otherwise IN if left crossing count is odd.\r\n   * @return 0 if ON, 1 if IN, -1 if OUT\r\n   */\r\n  public classifyCounts(): number | undefined {\r\n    if (this.numHit > 0)\r\n      return 0;\r\n    const parity = this.numLeftCrossing & 0x01;\r\n    return (parity === 1) ? 1 : -1;\r\n  }\r\n}\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;;;AAGA;;AAEA;AAEA;;AAEA;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;AAIA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoFA;;;;;;;AAOA;AACA;AAqBA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAcA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AAIA;AAEA;;AAEA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;;AA9kBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAaA;AACA;;;;;;;;;;;;;;AC1MA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAgCA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAiCA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA9LA;;;;;;;;;;;;;;ACnBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA;AACA;AAMA;AACA;AANA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqBA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AApNA;AAqNA;;;;AAIA;AACA;AAkCA;AACA;AACA;AAjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AA9VA;;;;;;;;;;;;;;AC1SA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAOA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAmCA;AACA;AACA;AAnCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAjUA;;;;;;;;;;;;;;ACjCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;AAQA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AAwGA;;;AAGA;AACA;AAuIA;;AAEA;AACA;AACA;AA1IA;AACA;AA0IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAzIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AASA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA8BA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/UA;AAiVA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAGA;AACA;AAEA;;;;;;;;;;;;;;;;;AAiBA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;AAgBA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAvOA;AAyOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;;;AAGA;AACA;AAEA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AASA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAnPA;;;;;;;;;;;;;;ACxuBA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;AArUA;AAwKA;;;;;;;;;;;;;;AC5LA;;;AAGA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AA6BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AApCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA/LA;;;;;;;;;;;;;;AC3BA;;;AAGA;;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;;;;AAIA;AACA;AA0DA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAjEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhVA;;;;;;;;;;;;;;ACzBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAIA;AACA;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AAeA;AACA;AAfA;AACA;AAeA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAlNA;;;;;;;;;;;;;;AClCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;AAcA;AACA;AA2BA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAlXA;AASA;AACA;;;;;;;;;;;;;;;ACzDA;;;AAGA;AACA;AACA;AAEA;AAEA;;;;;AAKA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA;AA8BA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAVA;;;;;;;;;;;;;;ACjDA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;;;;;;;;;;;;AAYA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AAEA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AA7jBA;AAoUA;;;;;;;;;;;;;;ACzWA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AAaA;AACA;AACA;AACA;AAXA;;;AAGA;AACA;AACA;AACA;AAMA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzKA;AA2KA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/WA;;;;;;;;;;;;;;;ACvPA;;;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6BA;;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhVA;AACA;;;;;;;;;;;;;;AC1EA;;;AAGA;;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAEA;;;;AAIA;AACA;AAWA;AATA;;;AAGA;AACA;AAMA;AACA;AALA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzUA;AA4SA;;;;;;;;;;;;;;AClUA;;;AAGA;;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AAaA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AArnBA;AACA;AACA;AAgWA;;;;;;;;;;;;;;AC7XA;;;AAGA;AACA;;AAGA;AACA;AAEA;AAIA;AAEA;AACA;AAEA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AACA;AALA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtQA;AA4LA;;;;;;;;;;;;;;ACvNA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAoBA;;;;;;;;;;;;;;;;AAgBA;AACA;AA8CA;AACA;AACA;AA/CA;AACA;AA+CA;AACA;AACA;AACA;AAhDA;;AAEA;AACA;AAMA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AASA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAKA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAIA;AACA;AACA;;;;;;AAMA;AACA;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAv1BA;AAWA;AACA;AAqUA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrZA;;;AAGA;;AAIA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAiBA;;AAEA;AACA;AACA;AACA;AACA;AApBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlGA;;;;;;;;;;;;;;ACvBA;;;AAGA;;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AA3GA;;;;;;;;;;;;;;;ACtBA;;;AAGA;AACA;AACA;AACA;AAIA;AAEA;;AAEA;AACA;AAOA;;AAEA;AACA;AACA;AAVA;AACA;AAUA;AACA;AARA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxEA;;;;;;;;;;;;;;ACfA;;;AAGA;;AAEA;AAEA;AACA;AAIA;AACA;AAEA;AAMA;AACA;AACA;;;;;;AAMA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnFA;AAoFA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AASA;AACA;AACA;AAVA;AACA;AAUA;AACA;AACA;AACA;AARA;AACA;AAQA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvWA;;;;;;;;;;;;;;ACrLA;;;AAGA;;AAIA;AAGA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;;;;;;;;;AASA;AACA;AAAA;;AACA;AACA;AAIA;AACA;AACA;AAkHA;AAjHA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1HA;AA2HA;;;;;;;;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AA9EA;AAgFA;;;;AAIA;AACA;AAUA;AACA;AAAA;AAVA;AACA;AASA;AAAA;AAPA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhEA;AAiEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AATA;;;;;;;;;;;;;;AC7eA;;;AAGA;;AAIA;AACA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;AA9DA;;;;;;;;;;;;;;ACjBA;;;AAGA;;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;;;;AAIA;AACA;AAKA;AACA;AACA;AACA;AACA;AATA;AAUA;;;;;;;AAOA;AACA;AAYA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AACA;AACA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAMA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAkBA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AAIA;AAAA;AACA;AAIA;AAAA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAQA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;;AAx0BA;AA2DA;AA+FA;AACA;AACA;AACA;AA2eA;AACA;AACA;AACA;AAqEA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzyBA;;;AAGA;;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AASA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AACA;AACA;AAgBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAMA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAkBA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AAIA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2DA;AACA;AACA;;;;;;;;;AASA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiGA;AAEA;AACA;AACA;AACA;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AACA;AAEA;;;;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AACA;AACA;AACA;AAYA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AAMA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;;AAlvBA;AAoCA;AAqhBA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjmBA;AACA;AACA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAjEA;;;;;;;;;;;;;;ACtBA;;;AAGA;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA3GA;;;;;;;;;;;;;;;ACrBA;;;AAGA;AACA;AACA;AAGA;AACA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AA7OA;AA8OA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/BA;;;;;;;;;;;;;;;ACvTA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AA4BA;;;;;;;;;;;;;AAaA;AACA;AAMA;AAAA;AALA;AACA;AAIA;AA8BA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AASA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAaA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAIA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AAeA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AAIA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AA5eA;AA8eA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAuBA;AACA;AApBA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AAfA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAlBA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AAXA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACz5BA;;;AAGA;AACA;AACA;AAOA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAjDA;AAmDA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAnEA;;;;;;;;;;;;;;AC3EA;;;AAGA;;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5DA;;;;;;;;;;;;;;;ACrBA;;;AAGA;AACA;AACA;AACA;AAqCA;AACA;;;AAGA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AAMA;;;AAGA;AACA;AAGA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAzEA;;;;;;;;;;;;;;AChDA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;AAUA;AACA;AAqBA;;;;AAIA;AACA;AAAA;AAzBA;AACA;AAwBA;AAAA;AAAA;AAtBA;AACA;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AA/RA;;;;;;;;;;;;;;;AClCA;;;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;;;;AAIA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AA+CA;AACA;AA/CA;AACA;AA+CA;AACA;;AAEA;AACA;AA7CA;AACA;AACA;;AAEA;AACA;AAYA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAEA;;AAnqCA;AAIA;AACA;AACA;AACA;AAyhCA;AAqIA;;;AAGA;AACA;AASA;AATA;AAUA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC90CA;;;AAGA;;AASA;AACA;AAIA;;;AAGA;AACA;AAQA;AACA;AAAA;AARA;AACA;AAEA;AACA;AAIA;AAHA;AACA;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzDA;;;;;;;;;;;;;;ACrBA;;;AAGA;;AAQA;AACA;AAEA;;;;;AAKA;AACA;AAUA;AACA;AAAA;AAVA;AACA;AASA;AAAA;AAPA;AACA;AAGA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlGA;;;;;;;;;;;;;;ACpBA;;;AAGA;;AAKA;AAIA;AAEA;AACA;AAEA;;;;AAIA;AACA;AAUA;AACA;AAAA;AAVA;AACA;AASA;AAPA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtDA;;;;;;;;;;;;;;ACtBA;;;AAGA;;AAEA;AAEA;AACA;AAIA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AASA;AACA;AATA;AACA;AASA;AACA;AARA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA1JA;;;;;;;;;;;;;;ACvBA;;;AAGA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AAOA;;;AAGA;AACA;AAVA;;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxCA;AAyCA;;;AAGA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AA3EA;AAIA;AACA;AACA;AACA;AAuEA;;;AAGA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AA3IA;AAKA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChiBA;;;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAvEA;;;;;;;;;;;;;;ACpBA;;;AAGA;;AAKA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/DA;;;;;;;;;;;;;;AChDA;;;AAGA;;AAKA;AAGA;AACA;AAEA;AAKA;;;AAGA;AACA;AAKA;AACA;AACA;AAKA;AACA;AALA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArGA;;;;;;;;;;;;;;ACvBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;AAGA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA/FA;;;;;;;;;;;;;;;ACtBA;;;AAGA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AACA;AACA;;;;;;AAMA;AACA;AAeA;;;AAGA;AACA;AAEA;AA7BA;AA8BA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAlCA;AAmCA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAlCA;AAmCA;;;;;;AAMA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AAvEA;AAyEA;;;;;AAKA;AACA;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjOA;;;;;;;;;;;;;;;ACzOA;AAEA;AACA;;;;;;;;;;;;AAYA;AACA;AAeA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AApIA;;;;;;;;;;;;;;ACrBA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAOA;;;AAGA;AACA;AAAA;;AAEA;AACA;AA4IA;AA1IA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA/IA;;;;;;;;;;;;;;AC5BA;;;AAGA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AAGA;AAEA;;;;;;;AAOA;AACA;AACA;AAGA;AACA;;;;;;;AAOA;AACA;AACA;AAGA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;AAGA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AAEA;AACA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AAjUA;AAmUA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;AChlBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AAAA;AAYA;AACA;AAkBA;AACA;AAwGA;AAvHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAxIA;;;;;;;;;;;;;;AChCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AAWA;;;;;;;AAOA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5HA;AA6HA;;;;AAIA;AACA;AAwEA;AACA;AAOA;AA/EA;AACA;AA+EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzFA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkBA;AACA;AAgCA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAMA;AACA;;;;;;;;;;AAUA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhaA;AAgGA;AACA;AAkUA;AACA;;;;;;;;;;;;;;AC5kBA;;;AAGA;;AAOA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAUA;AACA;AAAA;AAVA;AACA;AASA;AAAA;AAPA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3DA;;;;;;;;;;;;;;ACpBA;;;AAGA;;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AACA;AACA;;;;;;;;;AASA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;;;;;;;;;;;;AAYA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChPA;;;AAGA;AACA;AACA;AACA;;;;;AAKA;AACA;AAiBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;AA7VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAmBA;;;;;;;;;AASA;AACA;AA1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AA5QA;;;;;;;;;;;;;;;ACrBA;AACA;AAEA;;;AAGA;AAEA;AAEA;;;AAGA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9FA;;;;;;;;;;;;;;ACdA;;;AAGA;;AAEA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;AACA;AASA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAIA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AA/LA;;;;;;;;;;;;;;AC/CA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AAeA;AAVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAlRA;;;;;;;;;;;;;;ACvCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AAcA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AACA;AACA;AACA;AAsBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlGA;;;;;;;;;;;;;;AClCA;;;AAGA;;AAmCA;;;;;AAKA;AACA;AAOA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqBA;AAxDA;AAyDA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1DA;AA2DA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlEA;;;;;;;;;;;;;;;AC3KA;AAEA;;;;AAIA;AACA;AASA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvJA;;;;;;;;;;;;;;ACZA;;;AAGA;;AAcA;;;;;;;;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA1OA;;;;;;;;;;;;;;AC1BA;;;AAGA;;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AAaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArnBA;;;;;;;;;;;;;;ACtBA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAGA;AAEA;;AAEA;AACA;AAaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAl7BA;;;;;;;;;;;;;;;ACXA;;;AAGA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9FA;AAgGA;;;AAGA;AACA;AAEA;AAFA;;;;;;;;;;;;;;AClHA;;;AAGA;;AASA;;;;;;;;AAQA;AACA;AAuDA;AAvDA;;;;;;;;;;;;;;ACrBA;;;AAGA;;AAOA;AACA;AAEA;AAIA;AAFA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;AAQA;AACA;AAoFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;;;;AAIA;AACA;AACA;AACA;AACA;AAzHA;AA0HA;;;AAGA;AACA;AAsBA;AAtBA;;;;;;;;;;;;;;;AC1KA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;;;;AAIA;AACA;AACA;AAAA;AACA;AAUA;AACA;AAEA;;;;AAIA;AACA;AACA;AAAA;AACA;AAUA;AACA;AAEA;;;;AAIA;AACA;AACA;AAAA;AACA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;;;;;AAKA;AACA;AAAA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AAwCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AA5BA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAUA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAIA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AAKA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AAIA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAIA;AAEA;;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;;AAEA;AACA;AACA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AAMA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAMA;AAEA;;;;;AAKA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAMA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAIA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1hEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClKA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AAAA;AACA;AACA;AAKA;AAAA;AACA;AACA;AAKA;AAAA;AACA;AACA;AAKA;AAAA;AACA;AACA;AAKA;AAAA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;;AA7OA;AAKA;;;;;;;;;;;;;;ACxBA;;;AAGA;;AAEA;AACA;AACA;AACA;AAGA;AACA;;;;;;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3MA;;;;;;;;;;;;;;ACnBA;;;AAGA;;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnLA;;;;;;;;;;;;;;ACjBA;;;AAGA;AACA;;AAEA;AACA;AAEA;AAEA;;;;;;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AA/FA;;;;;;;;;;;;;;AClBA;;;AAGA;;AAEA;AACA;AACA;AAEA;AACA;AAGA;;;;;;AAMA;AACA;AASA;AAJA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA/FA;AAgGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApJA;AAqJA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AArQA;;;;;;;;;;;;;;;AC1QA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA7NA;;;;;;;;;;;;;;;ACfA;;;AAGA;AACA;AACA;AACA;AAGA;AAEA;;;;;;;AAOA;AACA;AAiBA;AAVA;;;;;AAKA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAzQA;AA0QA;;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/NA;AAgOA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhtBA;;;;;;;;;;;;;;ACngBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AArGA;AAsGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAvCA;AAyCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AApBA;AAsBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhGA;AA6CA;AAsDA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;;;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAEA;;;;;;;AAOA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;AAhkBA;AA+EA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpYA;;;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAJA;AAKA;;;;;;AAMA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AAxBA;AAyBA;;;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AA0BA;;AAEA;AACA;AAAA;;AACA;AAaA;AAZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;AAMA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AApCA;AAqCA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA5CA;;;;;;;;;;;;;;ACtJA;;;AAGA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzdA;AAqDA;;AAEA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgZA;;;AAGA;AACA;AAIA;;;;;;;;AAQA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAxJA;AACA;AACA;AACA;AAuJA;;;AAGA;AACA;AAEA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3FA;AACA;AA4FA;;;AAGA;AACA;AAQA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACx0BA;;;AAGA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA9OA;AAuBA;AACA;AACA;;;;;;;;;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAlEA;;;;;;;;;;;;;;ACdA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhDA;AACA;AACA;AACA;AACA;AA8CA;;;;;;AAMA;AACA;AAyCA;AACA;AAEA;AACA;AACA;AACA;AAvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AAMA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAKA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7pBA;AA8pBA;;;;;;AAMA;AACA;AAiBA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAAA;;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAGA;AACA;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApVA;AAsVA;;;AAGA;AACA;AAoCA;AACA;AACA;AACA;AACA;AACA;AAjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAGA;AAEA;AAnWA;;;;;;;;;;;;;;AC5kCA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AA7SA;;;;;;;;;;;;;;ACtBA;;;AAGA;;AAEA;AAEA;AACA;;;;;;;;;;;;;;AAcA;AACA;AAKA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3GA;;;;;;;;;;;;;;ACvBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AASA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAriBA;;;;;;;;;;;;;;AC3BA;;;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AAcA;AACA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxKA;;;;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AApIA;;;;;;;;;;;;;;ACdA;;;AAGA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;AAcA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA/sBA;;;;;;;;;;;;;;ACjCA;;;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;AAUA;AACA;AA6DA;AAmPA;AACA;AAnPA;AACA;AACA;AACA;AACA;AACA;AArDA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AAEA;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjYA;;;;;;;;;;;;;;AC7BA;;;AAGA;;AAKA;AACA;;;;;;AAMA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzEA;;;;;;;;;;;;;;AChBA;;;AAGA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAOA;;;;;;;;;AASA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAIA;AACA;;;;;AAKA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhfA;;;;;;;;;;;;;;ACzCA;;;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AA4BA;;;AAGA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5JA;AA6JA;;;AAGA;AACA;AACA;;;;;;AAMA;AACA;AASA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAzIA;AA0IA;;;;;;;;;;;AAWA;AACA;AAIA;AACA;AACA;AACA;AALA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlYA;AAmYA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnFA;AAqFA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAjGA;AAmGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA5IA;AA6IA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAtKA;;;;;;;;;;;;;;ACjiCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAcA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAjBA;AACA;AACA;AACA;AAAA;AACA;AACA;AAaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhWA;AACA;AACA;AACA;AACA;AACA;AAiGA;AACA;AA2PA;;;;;AAKA;AACA;AAUA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;;AA3BA;AACA;;;;;;;;;;;;;;;ACjYA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAaA;AAXA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AApHA;;;;;;;;;;;;;;ACXA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA7FA;AA8FA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA7NA;;;;;;;;;;;;;;AChHA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAYA;;;;;;;;;;AAUA;AACA;AAQA;AACA;AAOA;AACA;AAbA;AACA;AACA;AACA;AAWA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzEA;AA0EA;;;AAGA;AACA;AAOA;AAPA;AAQA;;;AAGA;AACA;AAKA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArCA;AAuCA;;AAEA;AACA;AAKA;AALA;AAOA;;AAEA;AACA;AAUA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA7CA;AA+CA;;AAEA;AACA;AAOA;;;AAGA;AACA;AACA;AACA;AACA;AAdA;AAgBA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AAzCA;;;;;;;;;;;;;;;ACpOA;;;AAGA;AACA;;;AAGA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlFA;AACA;;;;;;;;;;;;;;ACTA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAIA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAxFA;AAyFA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AA1CA;AA2CA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AAEA;AAtCA;AAuCA;;;;;;;;;;AAUA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAuBA;AA1IA;AA2IA;;;;;AAKA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsBA;AA5GA;AA6GA;;;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA9bA;AACA;AACA;AA8bA;;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;AA0CA;;;AAGA;AACA;AAyBA;;;;;;;;;;;;;;;AAeA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AAYA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAQA;AACA;;;;;;;AAOA;AAEA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgFA;AA6HA;;;AAGA;AACA;AACA;;;;;;;;AAQA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAEA;AAMA;AACA;;;;AAIA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnVA;AAoVA;;;;AAIA;AACA;AASA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AAEA;AACA;AA9CA;;;;;;;;;;;;;;AC1gDA;;;AAGA;;AAEA;AAEA;;;;;;;;AAQA;AACA;AA0BA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;;AA9HA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAyGA;;;;AAIA;AACA;AAWA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AAvBA;AACA;AACA;AACA;AAqBA;AA/BA;AAgCA;;;;;;;;;;;;;;ACtLA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;AASA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3VA;AA6VA;;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AANA;;;;;;;;;;;;;;AC9WA;;;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAhSA;;;;;;;;;;;;;;;ACpBA;;;AAGA;AACA;;;;;;;;;;AAUA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtGA;;;;;;;;;;;;;;ACfA;;;AAGA;;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AAYA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7GA;;;;;;;;;;;;;;AC/BA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AA1BA;AA2BA;;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnDA;AAoDA;;;;;;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AA1DA;;;;;;;;;;;;;;ACtHA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAAA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAAA;;;;;;;;;;;;;;;AC1FA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAOA;AACA;AACA;AACA;AAPA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7HA;;;;;;;;;;;;;;;ACVA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;AAMA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;;AAEA;AACA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;AAtPA;AAkPA;AACA;AAMA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3SA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhEA;AAmEA;;AAEA;AACA;AAGA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAvFA;;;;;;;;;;;;;;ACvFA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AAMA;AACA;AANA;AACA;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AA5CA;AA6CA;;;AAGA;AACA;AAqEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAtFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AAoBA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AApcA;AAifA;;;;AAIA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA7IA;AA+IA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;AC1vBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;;;;;AAKA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtBA;AAwBA;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7CA;AA8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;AACA;AAkBA;AACA;AACA;AACA;AAEA;AACA;AArBA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAIA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AAIA;AACA;AACA;;AA/6CA;AAqIA;AACA;AACA;AA2yCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvqDA;;;AAGA;;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;AAcA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjMA;;;;;;;;;;;;;;AC3BA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AA2CA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAbA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;;ACvCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAcA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAljBA;;;;;;;;;;;;;;;AC5CA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;;;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;AACA;AAEA;AAEA;AACA;;;;;;AAMA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AArGA;;;;;;;;;;;;;;;ACXA;AAGA;;;;;;;;AAQA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnJA;;;;;;;;;;;;;;;ACZA;AACA;AACA;;;;;;;AAOA;AACA;AAGA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzDA;;;;;;;;;;;;;;;AChBA;;;AAGA;AACA;AAGA;;;;;;;AAOA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjEA;;;;;;;;;;;;;;;ACfA;;;AAGA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlCA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjBA;;;AAGA;AACA;AAEA;AAEA;AAGA;;;AAGA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhIA;AAiIA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AALA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvDA;;;;;;;;;;;;;;ACnJA;;;AAGA;;AAEA;AAEA;AAEA;;;AAGA;AACA;AAiBA;AAhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAvKA;;;;;;;;;;;;;;ACbA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;;AAGA;AACA;AAoBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAuCA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAmBA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAGA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAIA;AAGA;AAIA;AAKA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAKA;AAKA;AACA;AACA;AACA;AACA;AACA;AAKA;AAKA;AAKA;AAKA;AAKA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAQA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAKA;AACA;AACA;;;AAGA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AAEA;AAKA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AA5nEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AA+OA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAoBA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;;;;;;;;;;;;;ACxcA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;;;AAGA;AACA;AAAA;AAqbA;;;;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AArrBA;AAsrBA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjqBA;AAkqBA;;;;;;;;;;;;;;ACj1DA;;;AAGA;;AAEA;AAEA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;;;;;;;;;AASA;AACA;AAUA;AAEA;AAXA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AAIA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AAIA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAlOA;;;;;;;;;;;;;;AC5BA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AAQA;AACA;AARA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAxPA;;;;;;;;;;;;;;AC/BA;;;AAGA;;AAKA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;;;;;;AAMA;AACA;AAOA;AACA;AAPA;AACA;AAOA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AA9HA;;;;;;;;;;;;;;AC5BA;;;AAGA;;AAKA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAOA;AACA;AAPA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AA3HA;;;;;;;;;;;;;;AC7BA;;;AAGA;;AAOA;AAEA;AACA;AAEA;AACA;AACA;AAQA;;;;AAIA;AACA;AAKA;AACA;AALA;AACA;AAKA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AApLA;;;;;;;;;;;;;;AC9BA;;;AAGA;;AAKA;AA6BA;;;;;AAKA;AACA;AAQA;AAAA;AAPA;AACA;AAMA;AAAA;AACA;AACA;AACA;AACA;AAeA;AA3BA;;;;;;;;;;;;;;AC3CA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AAeA;AACA;AAfA;AACA;AAeA;AACA;AACA;AAbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AArRA;;;;;;;;;;;;;;ACjCA;;;AAGA;;AAQA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;;;;AAIA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAzKA;;;;;;;;;;;;;;AC5BA;;;AAGA;;AAMA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AAUA;AACA;AAVA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AArQA;;;;;;;;;;;;;;AC3CA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAkBA;AACA;AAyBA;;;;AAIA;AACA;AA7BA;;AAEA;AACA;AA2BA;AACA;AACA;AApBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA3CA;;AAEA;AACA;AA0CA;;;;;;;;;;;;;AAaA;AACA;AAIA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlMA;;;;;;;;;;;;;;AChGA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAqBA;;;;;;;;;;;;;;;AAeA;AACA;AAiJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5IA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAUA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAoBA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAIA;AACA;;;;AAIA;AACA;AACA;AACA;AAKA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5tBA;AAgJA;AA8kBA;;;;;AAKA;AACA;AAKA;AADA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;AAMA;AACA;AASA;AACA;AACA;AACA;;;AAGA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7QA;AA8QA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AAAA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;AChmCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAOA;AACA;AACA;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAjBA;AAkBA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhKA;;;;;;;;;;;;;;;ACrCA;AAEA;;;AAGA;AAEA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxKA;AA0KA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;AA2CA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAxCA;AA0CA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAxCA;AAyCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAxCA;AA0CA;;;;;;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;ACxZA;;;AAGA;AACA;AAEA;AAEA;AAEA;AACA;;;AAGA;AACA;AAQA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAjFA;;;;;;;;;;;;;;ACfA;;;AAGA;;AAKA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzOA;;;;;;;;;;;;;;ACvBA;;;AAGA;;AAIA;AACA;AAEA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAeA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;AAcA;AAEA;AACA;AAEA;AACA;AAzKA;;;;;;;;;;;;;;AC5BA;;;AAGA;;AAEA;AACA;AAEA;AAEA;;;;;;;;AAQA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAlDA;;;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AAKA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA/MA;AAgNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7OA;;;AAGA;;AAEA;AACA;;;;;;AAMA;AACA;AAIA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AApDA;;;;;;;;;;;;;;ACbA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AANA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AATA;AAWA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA7GA;AA8GA;;AAEA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAzOA;;;;;;;;;;;;;;ACnJA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;;;;;;;;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAlWA;;;;;;;;;;;;;;ACdA;;;AAGA;;AAEA;AACA;;;;AAIA;AACA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AA5DA;;;;;;;;;;;;;;ACXA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAcA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAGA;AAEA;;;;;;;;AAQA;AACA;AAGA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA3wBA;AA6wBA;;;AAGA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/1BA;;;AAGA;;AAEA;AAEA;;;;;;;;;;;;;;AAcA;AACA;AAUA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1HA;;;;;;;;;;;;ACtBA;;;;;A","sourceRoot":""}